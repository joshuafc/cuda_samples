# 1 "/home/zhoub/CLionProjects/cudaTest/main.cu"
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
# 1
#pragma GCC diagnostic push
# 1
#pragma GCC diagnostic ignored "-Wunused-variable"
# 1
#pragma GCC diagnostic ignored "-Wunused-function"
# 1
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
# 1
#pragma GCC diagnostic pop
# 1
#pragma GCC diagnostic ignored "-Wunused-variable"

# 1
#define __nv_is_extended_device_lambda_closure_type(X) false
#define __nv_is_extended_host_device_lambda_closure_type(X) false
#if defined(__nv_is_extended_device_lambda_closure_type) && defined(__nv_is_extended_host_device_lambda_closure_type)
#endif

# 1
# 61 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
#pragma GCC diagnostic push
# 64
#pragma GCC diagnostic ignored "-Wunused-function"
# 68 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_types.h"
#if 0
# 68
enum cudaRoundMode { 
# 70
cudaRoundNearest, 
# 71
cudaRoundZero, 
# 72
cudaRoundPosInf, 
# 73
cudaRoundMinInf
# 74
}; 
#endif
# 100 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 100
struct char1 { 
# 102
signed char x; 
# 103
}; 
#endif
# 105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 105
struct uchar1 { 
# 107
unsigned char x; 
# 108
}; 
#endif
# 111 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 111
struct __attribute((aligned(2))) char2 { 
# 113
signed char x, y; 
# 114
}; 
#endif
# 116 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 116
struct __attribute((aligned(2))) uchar2 { 
# 118
unsigned char x, y; 
# 119
}; 
#endif
# 121 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 121
struct char3 { 
# 123
signed char x, y, z; 
# 124
}; 
#endif
# 126 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 126
struct uchar3 { 
# 128
unsigned char x, y, z; 
# 129
}; 
#endif
# 131 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 131
struct __attribute((aligned(4))) char4 { 
# 133
signed char x, y, z, w; 
# 134
}; 
#endif
# 136 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 136
struct __attribute((aligned(4))) uchar4 { 
# 138
unsigned char x, y, z, w; 
# 139
}; 
#endif
# 141 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 141
struct short1 { 
# 143
short x; 
# 144
}; 
#endif
# 146 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 146
struct ushort1 { 
# 148
unsigned short x; 
# 149
}; 
#endif
# 151 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 151
struct __attribute((aligned(4))) short2 { 
# 153
short x, y; 
# 154
}; 
#endif
# 156 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 156
struct __attribute((aligned(4))) ushort2 { 
# 158
unsigned short x, y; 
# 159
}; 
#endif
# 161 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 161
struct short3 { 
# 163
short x, y, z; 
# 164
}; 
#endif
# 166 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 166
struct ushort3 { 
# 168
unsigned short x, y, z; 
# 169
}; 
#endif
# 171 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 171
struct __attribute((aligned(8))) short4 { short x; short y; short z; short w; }; 
#endif
# 172 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 172
struct __attribute((aligned(8))) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
# 174 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 174
struct int1 { 
# 176
int x; 
# 177
}; 
#endif
# 179 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 179
struct uint1 { 
# 181
unsigned x; 
# 182
}; 
#endif
# 184 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 184
struct __attribute((aligned(8))) int2 { int x; int y; }; 
#endif
# 185 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 185
struct __attribute((aligned(8))) uint2 { unsigned x; unsigned y; }; 
#endif
# 187 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 187
struct int3 { 
# 189
int x, y, z; 
# 190
}; 
#endif
# 192 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 192
struct uint3 { 
# 194
unsigned x, y, z; 
# 195
}; 
#endif
# 197 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 197
struct __attribute((aligned(16))) int4 { 
# 199
int x, y, z, w; 
# 200
}; 
#endif
# 202 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 202
struct __attribute((aligned(16))) uint4 { 
# 204
unsigned x, y, z, w; 
# 205
}; 
#endif
# 207 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 207
struct long1 { 
# 209
long x; 
# 210
}; 
#endif
# 212 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 212
struct ulong1 { 
# 214
unsigned long x; 
# 215
}; 
#endif
# 222 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 222
struct __attribute((aligned((2) * sizeof(long)))) long2 { 
# 224
long x, y; 
# 225
}; 
#endif
# 227 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 227
struct __attribute((aligned((2) * sizeof(unsigned long)))) ulong2 { 
# 229
unsigned long x, y; 
# 230
}; 
#endif
# 234 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 234
struct long3 { 
# 236
long x, y, z; 
# 237
}; 
#endif
# 239 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 239
struct ulong3 { 
# 241
unsigned long x, y, z; 
# 242
}; 
#endif
# 244 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 244
struct __attribute((aligned(16))) long4 { 
# 246
long x, y, z, w; 
# 247
}; 
#endif
# 249 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 249
struct __attribute((aligned(16))) ulong4 { 
# 251
unsigned long x, y, z, w; 
# 252
}; 
#endif
# 254 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 254
struct float1 { 
# 256
float x; 
# 257
}; 
#endif
# 276 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 276
struct __attribute((aligned(8))) float2 { float x; float y; }; 
#endif
# 281 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 281
struct float3 { 
# 283
float x, y, z; 
# 284
}; 
#endif
# 286 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 286
struct __attribute((aligned(16))) float4 { 
# 288
float x, y, z, w; 
# 289
}; 
#endif
# 291 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 291
struct longlong1 { 
# 293
long long x; 
# 294
}; 
#endif
# 296 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 296
struct ulonglong1 { 
# 298
unsigned long long x; 
# 299
}; 
#endif
# 301 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 301
struct __attribute((aligned(16))) longlong2 { 
# 303
long long x, y; 
# 304
}; 
#endif
# 306 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 306
struct __attribute((aligned(16))) ulonglong2 { 
# 308
unsigned long long x, y; 
# 309
}; 
#endif
# 311 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 311
struct longlong3 { 
# 313
long long x, y, z; 
# 314
}; 
#endif
# 316 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 316
struct ulonglong3 { 
# 318
unsigned long long x, y, z; 
# 319
}; 
#endif
# 321 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 321
struct __attribute((aligned(16))) longlong4 { 
# 323
long long x, y, z, w; 
# 324
}; 
#endif
# 326 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 326
struct __attribute((aligned(16))) ulonglong4 { 
# 328
unsigned long long x, y, z, w; 
# 329
}; 
#endif
# 331 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 331
struct double1 { 
# 333
double x; 
# 334
}; 
#endif
# 336 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 336
struct __attribute((aligned(16))) double2 { 
# 338
double x, y; 
# 339
}; 
#endif
# 341 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 341
struct double3 { 
# 343
double x, y, z; 
# 344
}; 
#endif
# 346 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 346
struct __attribute((aligned(16))) double4 { 
# 348
double x, y, z, w; 
# 349
}; 
#endif
# 363 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef char1 
# 363
char1; 
#endif
# 364 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef uchar1 
# 364
uchar1; 
#endif
# 365 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef char2 
# 365
char2; 
#endif
# 366 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef uchar2 
# 366
uchar2; 
#endif
# 367 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef char3 
# 367
char3; 
#endif
# 368 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef uchar3 
# 368
uchar3; 
#endif
# 369 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef char4 
# 369
char4; 
#endif
# 370 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef uchar4 
# 370
uchar4; 
#endif
# 371 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef short1 
# 371
short1; 
#endif
# 372 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ushort1 
# 372
ushort1; 
#endif
# 373 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef short2 
# 373
short2; 
#endif
# 374 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ushort2 
# 374
ushort2; 
#endif
# 375 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef short3 
# 375
short3; 
#endif
# 376 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ushort3 
# 376
ushort3; 
#endif
# 377 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef short4 
# 377
short4; 
#endif
# 378 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ushort4 
# 378
ushort4; 
#endif
# 379 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef int1 
# 379
int1; 
#endif
# 380 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef uint1 
# 380
uint1; 
#endif
# 381 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef int2 
# 381
int2; 
#endif
# 382 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef uint2 
# 382
uint2; 
#endif
# 383 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef int3 
# 383
int3; 
#endif
# 384 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef uint3 
# 384
uint3; 
#endif
# 385 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef int4 
# 385
int4; 
#endif
# 386 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef uint4 
# 386
uint4; 
#endif
# 387 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef long1 
# 387
long1; 
#endif
# 388 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ulong1 
# 388
ulong1; 
#endif
# 389 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef long2 
# 389
long2; 
#endif
# 390 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ulong2 
# 390
ulong2; 
#endif
# 391 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef long3 
# 391
long3; 
#endif
# 392 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ulong3 
# 392
ulong3; 
#endif
# 393 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef long4 
# 393
long4; 
#endif
# 394 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ulong4 
# 394
ulong4; 
#endif
# 395 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef float1 
# 395
float1; 
#endif
# 396 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef float2 
# 396
float2; 
#endif
# 397 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef float3 
# 397
float3; 
#endif
# 398 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef float4 
# 398
float4; 
#endif
# 399 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef longlong1 
# 399
longlong1; 
#endif
# 400 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ulonglong1 
# 400
ulonglong1; 
#endif
# 401 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef longlong2 
# 401
longlong2; 
#endif
# 402 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ulonglong2 
# 402
ulonglong2; 
#endif
# 403 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef longlong3 
# 403
longlong3; 
#endif
# 404 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ulonglong3 
# 404
ulonglong3; 
#endif
# 405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef longlong4 
# 405
longlong4; 
#endif
# 406 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef ulonglong4 
# 406
ulonglong4; 
#endif
# 407 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef double1 
# 407
double1; 
#endif
# 408 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef double2 
# 408
double2; 
#endif
# 409 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef double3 
# 409
double3; 
#endif
# 410 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef double4 
# 410
double4; 
#endif
# 418 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
# 418
struct dim3 { 
# 420
unsigned x, y, z; 
# 432
}; 
#endif
# 434 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_types.h"
#if 0
typedef dim3 
# 434
dim3; 
#endif
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3
typedef long ptrdiff_t; 
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3
typedef unsigned long size_t; 
#if !defined(__CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__)
#define __CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__
#endif
#include "crt/host_runtime.h"
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3
typedef 
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3
struct { 
# 416
long long __max_align_ll __attribute((__aligned__(__alignof__(long long)))); 
# 417
long double __max_align_ld __attribute((__aligned__(__alignof__(long double)))); 
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3
} max_align_t; 
# 433
typedef __decltype((nullptr)) nullptr_t; 
# 204 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 204
enum cudaError { 
# 211
cudaSuccess, 
# 217
cudaErrorInvalidValue, 
# 223
cudaErrorMemoryAllocation, 
# 229
cudaErrorInitializationError, 
# 236
cudaErrorCudartUnloading, 
# 243
cudaErrorProfilerDisabled, 
# 251
cudaErrorProfilerNotInitialized, 
# 258
cudaErrorProfilerAlreadyStarted, 
# 265
cudaErrorProfilerAlreadyStopped, 
# 274 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorInvalidConfiguration, 
# 280
cudaErrorInvalidPitchValue = 12, 
# 286
cudaErrorInvalidSymbol, 
# 294
cudaErrorInvalidHostPointer = 16, 
# 302
cudaErrorInvalidDevicePointer, 
# 308
cudaErrorInvalidTexture, 
# 314
cudaErrorInvalidTextureBinding, 
# 321
cudaErrorInvalidChannelDescriptor, 
# 327
cudaErrorInvalidMemcpyDirection, 
# 337 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorAddressOfConstant, 
# 346 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorTextureFetchFailed, 
# 355 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorTextureNotBound, 
# 364 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorSynchronizationError, 
# 370
cudaErrorInvalidFilterSetting, 
# 376
cudaErrorInvalidNormSetting, 
# 384
cudaErrorMixedDeviceExecution, 
# 392
cudaErrorNotYetImplemented = 31, 
# 401 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorMemoryValueTooLarge, 
# 408
cudaErrorStubLibrary = 34, 
# 415
cudaErrorInsufficientDriver, 
# 422
cudaErrorCallRequiresNewerDriver, 
# 428
cudaErrorInvalidSurface, 
# 434
cudaErrorDuplicateVariableName = 43, 
# 440
cudaErrorDuplicateTextureName, 
# 446
cudaErrorDuplicateSurfaceName, 
# 456 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorDevicesUnavailable, 
# 469 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorIncompatibleDriverContext = 49, 
# 475
cudaErrorMissingConfiguration = 52, 
# 484 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorPriorLaunchFailure, 
# 491
cudaErrorLaunchMaxDepthExceeded = 65, 
# 499
cudaErrorLaunchFileScopedTex, 
# 507
cudaErrorLaunchFileScopedSurf, 
# 522 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorSyncDepthExceeded, 
# 534 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorLaunchPendingCountExceeded, 
# 540
cudaErrorInvalidDeviceFunction = 98, 
# 546
cudaErrorNoDevice = 100, 
# 553
cudaErrorInvalidDevice, 
# 558
cudaErrorDeviceNotLicensed, 
# 567 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorSoftwareValidityNotEstablished, 
# 572
cudaErrorStartupFailure = 127, 
# 577
cudaErrorInvalidKernelImage = 200, 
# 587 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorDeviceUninitialized, 
# 592
cudaErrorMapBufferObjectFailed = 205, 
# 597
cudaErrorUnmapBufferObjectFailed, 
# 603
cudaErrorArrayIsMapped, 
# 608
cudaErrorAlreadyMapped, 
# 616
cudaErrorNoKernelImageForDevice, 
# 621
cudaErrorAlreadyAcquired, 
# 626
cudaErrorNotMapped, 
# 632
cudaErrorNotMappedAsArray, 
# 638
cudaErrorNotMappedAsPointer, 
# 644
cudaErrorECCUncorrectable, 
# 650
cudaErrorUnsupportedLimit, 
# 656
cudaErrorDeviceAlreadyInUse, 
# 662
cudaErrorPeerAccessUnsupported, 
# 668
cudaErrorInvalidPtx, 
# 673
cudaErrorInvalidGraphicsContext, 
# 679
cudaErrorNvlinkUncorrectable, 
# 686
cudaErrorJitCompilerNotFound, 
# 693
cudaErrorUnsupportedPtxVersion, 
# 700
cudaErrorJitCompilationDisabled, 
# 705
cudaErrorUnsupportedExecAffinity, 
# 710
cudaErrorInvalidSource = 300, 
# 715
cudaErrorFileNotFound, 
# 720
cudaErrorSharedObjectSymbolNotFound, 
# 725
cudaErrorSharedObjectInitFailed, 
# 730
cudaErrorOperatingSystem, 
# 737
cudaErrorInvalidResourceHandle = 400, 
# 743
cudaErrorIllegalState, 
# 750
cudaErrorSymbolNotFound = 500, 
# 758
cudaErrorNotReady = 600, 
# 766
cudaErrorIllegalAddress = 700, 
# 775 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorLaunchOutOfResources, 
# 786 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorLaunchTimeout, 
# 792
cudaErrorLaunchIncompatibleTexturing, 
# 799
cudaErrorPeerAccessAlreadyEnabled, 
# 806
cudaErrorPeerAccessNotEnabled, 
# 819 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorSetOnActiveProcess = 708, 
# 826
cudaErrorContextIsDestroyed, 
# 833
cudaErrorAssert, 
# 840
cudaErrorTooManyPeers, 
# 846
cudaErrorHostMemoryAlreadyRegistered, 
# 852
cudaErrorHostMemoryNotRegistered, 
# 861 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorHardwareStackError, 
# 869
cudaErrorIllegalInstruction, 
# 878 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorMisalignedAddress, 
# 889 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorInvalidAddressSpace, 
# 897
cudaErrorInvalidPc, 
# 908 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorLaunchFailure, 
# 917 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorCooperativeLaunchTooLarge, 
# 922
cudaErrorNotPermitted = 800, 
# 928
cudaErrorNotSupported, 
# 937 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorSystemNotReady, 
# 944
cudaErrorSystemDriverMismatch, 
# 953 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorCompatNotSupportedOnDevice, 
# 958
cudaErrorMpsConnectionFailed, 
# 963
cudaErrorMpsRpcFailure, 
# 969
cudaErrorMpsServerNotReady, 
# 974
cudaErrorMpsMaxClientsReached, 
# 979
cudaErrorMpsMaxConnectionsReached, 
# 984
cudaErrorStreamCaptureUnsupported = 900, 
# 990
cudaErrorStreamCaptureInvalidated, 
# 996
cudaErrorStreamCaptureMerge, 
# 1001
cudaErrorStreamCaptureUnmatched, 
# 1007
cudaErrorStreamCaptureUnjoined, 
# 1014
cudaErrorStreamCaptureIsolation, 
# 1020
cudaErrorStreamCaptureImplicit, 
# 1026
cudaErrorCapturedEvent, 
# 1033
cudaErrorStreamCaptureWrongThread, 
# 1038
cudaErrorTimeout, 
# 1044
cudaErrorGraphExecUpdateFailure, 
# 1054 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorExternalDevice, 
# 1067 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaErrorUnknown = 999, 
# 1075
cudaErrorApiFailureBase = 10000
# 1076
}; 
#endif
# 1081 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1081
enum cudaChannelFormatKind { 
# 1083
cudaChannelFormatKindSigned, 
# 1084
cudaChannelFormatKindUnsigned, 
# 1085
cudaChannelFormatKindFloat, 
# 1086
cudaChannelFormatKindNone, 
# 1087
cudaChannelFormatKindNV12, 
# 1088
cudaChannelFormatKindUnsignedNormalized8X1, 
# 1089
cudaChannelFormatKindUnsignedNormalized8X2, 
# 1090
cudaChannelFormatKindUnsignedNormalized8X4, 
# 1091
cudaChannelFormatKindUnsignedNormalized16X1, 
# 1092
cudaChannelFormatKindUnsignedNormalized16X2, 
# 1093
cudaChannelFormatKindUnsignedNormalized16X4, 
# 1094
cudaChannelFormatKindSignedNormalized8X1, 
# 1095
cudaChannelFormatKindSignedNormalized8X2, 
# 1096
cudaChannelFormatKindSignedNormalized8X4, 
# 1097
cudaChannelFormatKindSignedNormalized16X1, 
# 1098
cudaChannelFormatKindSignedNormalized16X2, 
# 1099
cudaChannelFormatKindSignedNormalized16X4, 
# 1100
cudaChannelFormatKindUnsignedBlockCompressed1, 
# 1101
cudaChannelFormatKindUnsignedBlockCompressed1SRGB, 
# 1102
cudaChannelFormatKindUnsignedBlockCompressed2, 
# 1103
cudaChannelFormatKindUnsignedBlockCompressed2SRGB, 
# 1104
cudaChannelFormatKindUnsignedBlockCompressed3, 
# 1105
cudaChannelFormatKindUnsignedBlockCompressed3SRGB, 
# 1106
cudaChannelFormatKindUnsignedBlockCompressed4, 
# 1107
cudaChannelFormatKindSignedBlockCompressed4, 
# 1108
cudaChannelFormatKindUnsignedBlockCompressed5, 
# 1109
cudaChannelFormatKindSignedBlockCompressed5, 
# 1110
cudaChannelFormatKindUnsignedBlockCompressed6H, 
# 1111
cudaChannelFormatKindSignedBlockCompressed6H, 
# 1112
cudaChannelFormatKindUnsignedBlockCompressed7, 
# 1113
cudaChannelFormatKindUnsignedBlockCompressed7SRGB
# 1114
}; 
#endif
# 1119 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1119
struct cudaChannelFormatDesc { 
# 1121
int x; 
# 1122
int y; 
# 1123
int z; 
# 1124
int w; 
# 1125
cudaChannelFormatKind f; 
# 1126
}; 
#endif
# 1131 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
typedef struct cudaArray *cudaArray_t; 
# 1136
typedef const cudaArray *cudaArray_const_t; 
# 1138
struct cudaArray; 
# 1143
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
# 1148
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
# 1150
struct cudaMipmappedArray; 
# 1160 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1160
struct cudaArraySparseProperties { 
# 1161
struct { 
# 1162
unsigned width; 
# 1163
unsigned height; 
# 1164
unsigned depth; 
# 1165
} tileExtent; 
# 1166
unsigned miptailFirstLevel; 
# 1167
unsigned long long miptailSize; 
# 1168
unsigned flags; 
# 1169
unsigned reserved[4]; 
# 1170
}; 
#endif
# 1176 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1176
struct cudaArrayMemoryRequirements { 
# 1177
size_t size; 
# 1178
size_t alignment; 
# 1179
unsigned reserved[4]; 
# 1180
}; 
#endif
# 1186 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1186
enum cudaMemoryType { 
# 1188
cudaMemoryTypeUnregistered, 
# 1189
cudaMemoryTypeHost, 
# 1190
cudaMemoryTypeDevice, 
# 1191
cudaMemoryTypeManaged
# 1192
}; 
#endif
# 1197 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1197
enum cudaMemcpyKind { 
# 1199
cudaMemcpyHostToHost, 
# 1200
cudaMemcpyHostToDevice, 
# 1201
cudaMemcpyDeviceToHost, 
# 1202
cudaMemcpyDeviceToDevice, 
# 1203
cudaMemcpyDefault
# 1204
}; 
#endif
# 1211 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1211
struct cudaPitchedPtr { 
# 1213
void *ptr; 
# 1214
size_t pitch; 
# 1215
size_t xsize; 
# 1216
size_t ysize; 
# 1217
}; 
#endif
# 1224 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1224
struct cudaExtent { 
# 1226
size_t width; 
# 1227
size_t height; 
# 1228
size_t depth; 
# 1229
}; 
#endif
# 1236 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1236
struct cudaPos { 
# 1238
size_t x; 
# 1239
size_t y; 
# 1240
size_t z; 
# 1241
}; 
#endif
# 1246 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1246
struct cudaMemcpy3DParms { 
# 1248
cudaArray_t srcArray; 
# 1249
cudaPos srcPos; 
# 1250
cudaPitchedPtr srcPtr; 
# 1252
cudaArray_t dstArray; 
# 1253
cudaPos dstPos; 
# 1254
cudaPitchedPtr dstPtr; 
# 1256
cudaExtent extent; 
# 1257
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 1258
}; 
#endif
# 1263 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1263
struct cudaMemcpy3DPeerParms { 
# 1265
cudaArray_t srcArray; 
# 1266
cudaPos srcPos; 
# 1267
cudaPitchedPtr srcPtr; 
# 1268
int srcDevice; 
# 1270
cudaArray_t dstArray; 
# 1271
cudaPos dstPos; 
# 1272
cudaPitchedPtr dstPtr; 
# 1273
int dstDevice; 
# 1275
cudaExtent extent; 
# 1276
}; 
#endif
# 1281 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1281
struct cudaMemsetParams { 
# 1282
void *dst; 
# 1283
size_t pitch; 
# 1284
unsigned value; 
# 1285
unsigned elementSize; 
# 1286
size_t width; 
# 1287
size_t height; 
# 1288
}; 
#endif
# 1293 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1293
enum cudaAccessProperty { 
# 1294
cudaAccessPropertyNormal, 
# 1295
cudaAccessPropertyStreaming, 
# 1296
cudaAccessPropertyPersisting
# 1297
}; 
#endif
# 1310 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1310
struct cudaAccessPolicyWindow { 
# 1311
void *base_ptr; 
# 1312
size_t num_bytes; 
# 1313
float hitRatio; 
# 1314
cudaAccessProperty hitProp; 
# 1315
cudaAccessProperty missProp; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 1316
}; 
#endif
# 1328 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
typedef void (*cudaHostFn_t)(void * userData); 
# 1333
#if 0
# 1333
struct cudaHostNodeParams { 
# 1334
cudaHostFn_t fn; 
# 1335
void *userData; 
# 1336
}; 
#endif
# 1341 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1341
enum cudaStreamCaptureStatus { 
# 1342
cudaStreamCaptureStatusNone, 
# 1343
cudaStreamCaptureStatusActive, 
# 1344
cudaStreamCaptureStatusInvalidated
# 1346
}; 
#endif
# 1352 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1352
enum cudaStreamCaptureMode { 
# 1353
cudaStreamCaptureModeGlobal, 
# 1354
cudaStreamCaptureModeThreadLocal, 
# 1355
cudaStreamCaptureModeRelaxed
# 1356
}; 
#endif
# 1358 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1358
enum cudaSynchronizationPolicy { 
# 1359
cudaSyncPolicyAuto = 1, 
# 1360
cudaSyncPolicySpin, 
# 1361
cudaSyncPolicyYield, 
# 1362
cudaSyncPolicyBlockingSync
# 1363
}; 
#endif
# 1368 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1368
enum cudaStreamAttrID { 
# 1369
cudaStreamAttributeAccessPolicyWindow = 1, 
# 1370
cudaStreamAttributeSynchronizationPolicy = 3
# 1371
}; 
#endif
# 1376 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1376
union cudaStreamAttrValue { 
# 1377
cudaAccessPolicyWindow accessPolicyWindow; 
# 1378
cudaSynchronizationPolicy syncPolicy; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 1379
}; 
#endif
# 1384 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1384
enum cudaStreamUpdateCaptureDependenciesFlags { 
# 1385
cudaStreamAddCaptureDependencies, 
# 1386
cudaStreamSetCaptureDependencies
# 1387
}; 
#endif
# 1392 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1392
enum cudaUserObjectFlags { 
# 1393
cudaUserObjectNoDestructorSync = 1
# 1394
}; 
#endif
# 1399 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1399
enum cudaUserObjectRetainFlags { 
# 1400
cudaGraphUserObjectMove = 1
# 1401
}; 
#endif
# 1406 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
struct cudaGraphicsResource; 
# 1411
#if 0
# 1411
enum cudaGraphicsRegisterFlags { 
# 1413
cudaGraphicsRegisterFlagsNone, 
# 1414
cudaGraphicsRegisterFlagsReadOnly, 
# 1415
cudaGraphicsRegisterFlagsWriteDiscard, 
# 1416
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
# 1417
cudaGraphicsRegisterFlagsTextureGather = 8
# 1418
}; 
#endif
# 1423 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1423
enum cudaGraphicsMapFlags { 
# 1425
cudaGraphicsMapFlagsNone, 
# 1426
cudaGraphicsMapFlagsReadOnly, 
# 1427
cudaGraphicsMapFlagsWriteDiscard
# 1428
}; 
#endif
# 1433 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1433
enum cudaGraphicsCubeFace { 
# 1435
cudaGraphicsCubeFacePositiveX, 
# 1436
cudaGraphicsCubeFaceNegativeX, 
# 1437
cudaGraphicsCubeFacePositiveY, 
# 1438
cudaGraphicsCubeFaceNegativeY, 
# 1439
cudaGraphicsCubeFacePositiveZ, 
# 1440
cudaGraphicsCubeFaceNegativeZ
# 1441
}; 
#endif
# 1446 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1446
enum cudaKernelNodeAttrID { 
# 1447
cudaKernelNodeAttributeAccessPolicyWindow = 1, 
# 1448
cudaKernelNodeAttributeCooperative
# 1449
}; 
#endif
# 1454 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1454
union cudaKernelNodeAttrValue { 
# 1455
cudaAccessPolicyWindow accessPolicyWindow; 
# 1456
int cooperative; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 1457
}; 
#endif
# 1462 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1462
enum cudaResourceType { 
# 1464
cudaResourceTypeArray, 
# 1465
cudaResourceTypeMipmappedArray, 
# 1466
cudaResourceTypeLinear, 
# 1467
cudaResourceTypePitch2D
# 1468
}; 
#endif
# 1473 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1473
enum cudaResourceViewFormat { 
# 1475
cudaResViewFormatNone, 
# 1476
cudaResViewFormatUnsignedChar1, 
# 1477
cudaResViewFormatUnsignedChar2, 
# 1478
cudaResViewFormatUnsignedChar4, 
# 1479
cudaResViewFormatSignedChar1, 
# 1480
cudaResViewFormatSignedChar2, 
# 1481
cudaResViewFormatSignedChar4, 
# 1482
cudaResViewFormatUnsignedShort1, 
# 1483
cudaResViewFormatUnsignedShort2, 
# 1484
cudaResViewFormatUnsignedShort4, 
# 1485
cudaResViewFormatSignedShort1, 
# 1486
cudaResViewFormatSignedShort2, 
# 1487
cudaResViewFormatSignedShort4, 
# 1488
cudaResViewFormatUnsignedInt1, 
# 1489
cudaResViewFormatUnsignedInt2, 
# 1490
cudaResViewFormatUnsignedInt4, 
# 1491
cudaResViewFormatSignedInt1, 
# 1492
cudaResViewFormatSignedInt2, 
# 1493
cudaResViewFormatSignedInt4, 
# 1494
cudaResViewFormatHalf1, 
# 1495
cudaResViewFormatHalf2, 
# 1496
cudaResViewFormatHalf4, 
# 1497
cudaResViewFormatFloat1, 
# 1498
cudaResViewFormatFloat2, 
# 1499
cudaResViewFormatFloat4, 
# 1500
cudaResViewFormatUnsignedBlockCompressed1, 
# 1501
cudaResViewFormatUnsignedBlockCompressed2, 
# 1502
cudaResViewFormatUnsignedBlockCompressed3, 
# 1503
cudaResViewFormatUnsignedBlockCompressed4, 
# 1504
cudaResViewFormatSignedBlockCompressed4, 
# 1505
cudaResViewFormatUnsignedBlockCompressed5, 
# 1506
cudaResViewFormatSignedBlockCompressed5, 
# 1507
cudaResViewFormatUnsignedBlockCompressed6H, 
# 1508
cudaResViewFormatSignedBlockCompressed6H, 
# 1509
cudaResViewFormatUnsignedBlockCompressed7
# 1510
}; 
#endif
# 1515 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1515
struct cudaResourceDesc { 
# 1516
cudaResourceType resType; 
# 1518
union { 
# 1519
struct { 
# 1520
cudaArray_t array; 
# 1521
} array; 
# 1522
struct { 
# 1523
cudaMipmappedArray_t mipmap; 
# 1524
} mipmap; 
# 1525
struct { 
# 1526
void *devPtr; 
# 1527
cudaChannelFormatDesc desc; 
# 1528
size_t sizeInBytes; 
# 1529
} linear; 
# 1530
struct { 
# 1531
void *devPtr; 
# 1532
cudaChannelFormatDesc desc; 
# 1533
size_t width; 
# 1534
size_t height; 
# 1535
size_t pitchInBytes; 
# 1536
} pitch2D; 
# 1537
} res; 
# 1538
}; 
#endif
# 1543 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1543
struct cudaResourceViewDesc { 
# 1545
cudaResourceViewFormat format; 
# 1546
size_t width; 
# 1547
size_t height; 
# 1548
size_t depth; 
# 1549
unsigned firstMipmapLevel; 
# 1550
unsigned lastMipmapLevel; 
# 1551
unsigned firstLayer; 
# 1552
unsigned lastLayer; 
# 1553
}; 
#endif
# 1558 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1558
struct cudaPointerAttributes { 
# 1564
cudaMemoryType type; 
# 1575 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
int device; 
# 1581
void *devicePointer; 
# 1590 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
void *hostPointer; 
# 1591
}; 
#endif
# 1596 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1596
struct cudaFuncAttributes { 
# 1603
size_t sharedSizeBytes; 
# 1609
size_t constSizeBytes; 
# 1614
size_t localSizeBytes; 
# 1621
int maxThreadsPerBlock; 
# 1626
int numRegs; 
# 1633
int ptxVersion; 
# 1640
int binaryVersion; 
# 1646
int cacheModeCA; 
# 1653
int maxDynamicSharedSizeBytes; 
# 1662 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
int preferredShmemCarveout; 
# 1712 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
}; 
#endif
# 1717 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1717
enum cudaFuncAttribute { 
# 1719
cudaFuncAttributeMaxDynamicSharedMemorySize = 8, 
# 1720
cudaFuncAttributePreferredSharedMemoryCarveout, 
# 1729 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaFuncAttributeMax
# 1730
}; 
#endif
# 1735 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1735
enum cudaFuncCache { 
# 1737
cudaFuncCachePreferNone, 
# 1738
cudaFuncCachePreferShared, 
# 1739
cudaFuncCachePreferL1, 
# 1740
cudaFuncCachePreferEqual
# 1741
}; 
#endif
# 1747 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1747
enum cudaSharedMemConfig { 
# 1749
cudaSharedMemBankSizeDefault, 
# 1750
cudaSharedMemBankSizeFourByte, 
# 1751
cudaSharedMemBankSizeEightByte
# 1752
}; 
#endif
# 1757 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1757
enum cudaSharedCarveout { 
# 1758
cudaSharedmemCarveoutDefault = (-1), 
# 1759
cudaSharedmemCarveoutMaxShared = 100, 
# 1760
cudaSharedmemCarveoutMaxL1 = 0
# 1761
}; 
#endif
# 1777 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1777
enum cudaComputeMode { 
# 1779
cudaComputeModeDefault, 
# 1780
cudaComputeModeExclusive, 
# 1781
cudaComputeModeProhibited, 
# 1782
cudaComputeModeExclusiveProcess
# 1783
}; 
#endif
# 1788 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1788
enum cudaLimit { 
# 1790
cudaLimitStackSize, 
# 1791
cudaLimitPrintfFifoSize, 
# 1792
cudaLimitMallocHeapSize, 
# 1793
cudaLimitDevRuntimeSyncDepth, 
# 1794
cudaLimitDevRuntimePendingLaunchCount, 
# 1795
cudaLimitMaxL2FetchGranularity, 
# 1796
cudaLimitPersistingL2CacheSize
# 1797
}; 
#endif
# 1802 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1802
enum cudaMemoryAdvise { 
# 1804
cudaMemAdviseSetReadMostly = 1, 
# 1805
cudaMemAdviseUnsetReadMostly, 
# 1806
cudaMemAdviseSetPreferredLocation, 
# 1807
cudaMemAdviseUnsetPreferredLocation, 
# 1808
cudaMemAdviseSetAccessedBy, 
# 1809
cudaMemAdviseUnsetAccessedBy
# 1810
}; 
#endif
# 1815 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1815
enum cudaMemRangeAttribute { 
# 1817
cudaMemRangeAttributeReadMostly = 1, 
# 1818
cudaMemRangeAttributePreferredLocation, 
# 1819
cudaMemRangeAttributeAccessedBy, 
# 1820
cudaMemRangeAttributeLastPrefetchLocation
# 1821
}; 
#endif
# 1826 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1826
enum cudaOutputMode { 
# 1828
cudaKeyValuePair, 
# 1829
cudaCSV
# 1830
}; 
#endif
# 1835 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1835
enum cudaFlushGPUDirectRDMAWritesOptions { 
# 1836
cudaFlushGPUDirectRDMAWritesOptionHost = (1 << 0), 
# 1837
cudaFlushGPUDirectRDMAWritesOptionMemOps
# 1838
}; 
#endif
# 1843 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1843
enum cudaGPUDirectRDMAWritesOrdering { 
# 1844
cudaGPUDirectRDMAWritesOrderingNone, 
# 1845
cudaGPUDirectRDMAWritesOrderingOwner = 100, 
# 1846
cudaGPUDirectRDMAWritesOrderingAllDevices = 200
# 1847
}; 
#endif
# 1852 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1852
enum cudaFlushGPUDirectRDMAWritesScope { 
# 1853
cudaFlushGPUDirectRDMAWritesToOwner = 100, 
# 1854
cudaFlushGPUDirectRDMAWritesToAllDevices = 200
# 1855
}; 
#endif
# 1860 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1860
enum cudaFlushGPUDirectRDMAWritesTarget { 
# 1861
cudaFlushGPUDirectRDMAWritesTargetCurrentDevice
# 1862
}; 
#endif
# 1868 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1868
enum cudaDeviceAttr { 
# 1870
cudaDevAttrMaxThreadsPerBlock = 1, 
# 1871
cudaDevAttrMaxBlockDimX, 
# 1872
cudaDevAttrMaxBlockDimY, 
# 1873
cudaDevAttrMaxBlockDimZ, 
# 1874
cudaDevAttrMaxGridDimX, 
# 1875
cudaDevAttrMaxGridDimY, 
# 1876
cudaDevAttrMaxGridDimZ, 
# 1877
cudaDevAttrMaxSharedMemoryPerBlock, 
# 1878
cudaDevAttrTotalConstantMemory, 
# 1879
cudaDevAttrWarpSize, 
# 1880
cudaDevAttrMaxPitch, 
# 1881
cudaDevAttrMaxRegistersPerBlock, 
# 1882
cudaDevAttrClockRate, 
# 1883
cudaDevAttrTextureAlignment, 
# 1884
cudaDevAttrGpuOverlap, 
# 1885
cudaDevAttrMultiProcessorCount, 
# 1886
cudaDevAttrKernelExecTimeout, 
# 1887
cudaDevAttrIntegrated, 
# 1888
cudaDevAttrCanMapHostMemory, 
# 1889
cudaDevAttrComputeMode, 
# 1890
cudaDevAttrMaxTexture1DWidth, 
# 1891
cudaDevAttrMaxTexture2DWidth, 
# 1892
cudaDevAttrMaxTexture2DHeight, 
# 1893
cudaDevAttrMaxTexture3DWidth, 
# 1894
cudaDevAttrMaxTexture3DHeight, 
# 1895
cudaDevAttrMaxTexture3DDepth, 
# 1896
cudaDevAttrMaxTexture2DLayeredWidth, 
# 1897
cudaDevAttrMaxTexture2DLayeredHeight, 
# 1898
cudaDevAttrMaxTexture2DLayeredLayers, 
# 1899
cudaDevAttrSurfaceAlignment, 
# 1900
cudaDevAttrConcurrentKernels, 
# 1901
cudaDevAttrEccEnabled, 
# 1902
cudaDevAttrPciBusId, 
# 1903
cudaDevAttrPciDeviceId, 
# 1904
cudaDevAttrTccDriver, 
# 1905
cudaDevAttrMemoryClockRate, 
# 1906
cudaDevAttrGlobalMemoryBusWidth, 
# 1907
cudaDevAttrL2CacheSize, 
# 1908
cudaDevAttrMaxThreadsPerMultiProcessor, 
# 1909
cudaDevAttrAsyncEngineCount, 
# 1910
cudaDevAttrUnifiedAddressing, 
# 1911
cudaDevAttrMaxTexture1DLayeredWidth, 
# 1912
cudaDevAttrMaxTexture1DLayeredLayers, 
# 1913
cudaDevAttrMaxTexture2DGatherWidth = 45, 
# 1914
cudaDevAttrMaxTexture2DGatherHeight, 
# 1915
cudaDevAttrMaxTexture3DWidthAlt, 
# 1916
cudaDevAttrMaxTexture3DHeightAlt, 
# 1917
cudaDevAttrMaxTexture3DDepthAlt, 
# 1918
cudaDevAttrPciDomainId, 
# 1919
cudaDevAttrTexturePitchAlignment, 
# 1920
cudaDevAttrMaxTextureCubemapWidth, 
# 1921
cudaDevAttrMaxTextureCubemapLayeredWidth, 
# 1922
cudaDevAttrMaxTextureCubemapLayeredLayers, 
# 1923
cudaDevAttrMaxSurface1DWidth, 
# 1924
cudaDevAttrMaxSurface2DWidth, 
# 1925
cudaDevAttrMaxSurface2DHeight, 
# 1926
cudaDevAttrMaxSurface3DWidth, 
# 1927
cudaDevAttrMaxSurface3DHeight, 
# 1928
cudaDevAttrMaxSurface3DDepth, 
# 1929
cudaDevAttrMaxSurface1DLayeredWidth, 
# 1930
cudaDevAttrMaxSurface1DLayeredLayers, 
# 1931
cudaDevAttrMaxSurface2DLayeredWidth, 
# 1932
cudaDevAttrMaxSurface2DLayeredHeight, 
# 1933
cudaDevAttrMaxSurface2DLayeredLayers, 
# 1934
cudaDevAttrMaxSurfaceCubemapWidth, 
# 1935
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
# 1936
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
# 1937
cudaDevAttrMaxTexture1DLinearWidth, 
# 1938
cudaDevAttrMaxTexture2DLinearWidth, 
# 1939
cudaDevAttrMaxTexture2DLinearHeight, 
# 1940
cudaDevAttrMaxTexture2DLinearPitch, 
# 1941
cudaDevAttrMaxTexture2DMipmappedWidth, 
# 1942
cudaDevAttrMaxTexture2DMipmappedHeight, 
# 1943
cudaDevAttrComputeCapabilityMajor, 
# 1944
cudaDevAttrComputeCapabilityMinor, 
# 1945
cudaDevAttrMaxTexture1DMipmappedWidth, 
# 1946
cudaDevAttrStreamPrioritiesSupported, 
# 1947
cudaDevAttrGlobalL1CacheSupported, 
# 1948
cudaDevAttrLocalL1CacheSupported, 
# 1949
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
# 1950
cudaDevAttrMaxRegistersPerMultiprocessor, 
# 1951
cudaDevAttrManagedMemory, 
# 1952
cudaDevAttrIsMultiGpuBoard, 
# 1953
cudaDevAttrMultiGpuBoardGroupID, 
# 1954
cudaDevAttrHostNativeAtomicSupported, 
# 1955
cudaDevAttrSingleToDoublePrecisionPerfRatio, 
# 1956
cudaDevAttrPageableMemoryAccess, 
# 1957
cudaDevAttrConcurrentManagedAccess, 
# 1958
cudaDevAttrComputePreemptionSupported, 
# 1959
cudaDevAttrCanUseHostPointerForRegisteredMem, 
# 1960
cudaDevAttrReserved92, 
# 1961
cudaDevAttrReserved93, 
# 1962
cudaDevAttrReserved94, 
# 1963
cudaDevAttrCooperativeLaunch, 
# 1964
cudaDevAttrCooperativeMultiDeviceLaunch, 
# 1965
cudaDevAttrMaxSharedMemoryPerBlockOptin, 
# 1966
cudaDevAttrCanFlushRemoteWrites, 
# 1967
cudaDevAttrHostRegisterSupported, 
# 1968
cudaDevAttrPageableMemoryAccessUsesHostPageTables, 
# 1969
cudaDevAttrDirectManagedMemAccessFromHost, 
# 1970
cudaDevAttrMaxBlocksPerMultiprocessor = 106, 
# 1971
cudaDevAttrMaxPersistingL2CacheSize = 108, 
# 1972
cudaDevAttrMaxAccessPolicyWindowSize, 
# 1973
cudaDevAttrReservedSharedMemoryPerBlock = 111, 
# 1974
cudaDevAttrSparseCudaArraySupported, 
# 1975
cudaDevAttrHostRegisterReadOnlySupported, 
# 1976
cudaDevAttrTimelineSemaphoreInteropSupported, 
# 1977
cudaDevAttrMaxTimelineSemaphoreInteropSupported = 114, 
# 1978
cudaDevAttrMemoryPoolsSupported, 
# 1979
cudaDevAttrGPUDirectRDMASupported, 
# 1980
cudaDevAttrGPUDirectRDMAFlushWritesOptions, 
# 1981
cudaDevAttrGPUDirectRDMAWritesOrdering, 
# 1982
cudaDevAttrMemoryPoolSupportedHandleTypes, 
# 1987
cudaDevAttrDeferredMappingCudaArraySupported = 121, 
# 1989
cudaDevAttrMax
# 1990
}; 
#endif
# 1995 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 1995
enum cudaMemPoolAttr { 
# 2005 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaMemPoolReuseFollowEventDependencies = 1, 
# 2012
cudaMemPoolReuseAllowOpportunistic, 
# 2020
cudaMemPoolReuseAllowInternalDependencies, 
# 2031 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
cudaMemPoolAttrReleaseThreshold, 
# 2037
cudaMemPoolAttrReservedMemCurrent, 
# 2044
cudaMemPoolAttrReservedMemHigh, 
# 2050
cudaMemPoolAttrUsedMemCurrent, 
# 2057
cudaMemPoolAttrUsedMemHigh
# 2058
}; 
#endif
# 2063 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2063
enum cudaMemLocationType { 
# 2064
cudaMemLocationTypeInvalid, 
# 2065
cudaMemLocationTypeDevice
# 2066
}; 
#endif
# 2073 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2073
struct cudaMemLocation { 
# 2074
cudaMemLocationType type; 
# 2075
int id; 
# 2076
}; 
#endif
# 2081 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2081
enum cudaMemAccessFlags { 
# 2082
cudaMemAccessFlagsProtNone, 
# 2083
cudaMemAccessFlagsProtRead, 
# 2084
cudaMemAccessFlagsProtReadWrite = 3
# 2085
}; 
#endif
# 2090 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2090
struct cudaMemAccessDesc { 
# 2091
cudaMemLocation location; 
# 2092
cudaMemAccessFlags flags; 
# 2093
}; 
#endif
# 2098 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2098
enum cudaMemAllocationType { 
# 2099
cudaMemAllocationTypeInvalid, 
# 2103
cudaMemAllocationTypePinned, 
# 2104
cudaMemAllocationTypeMax = 2147483647
# 2105
}; 
#endif
# 2110 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2110
enum cudaMemAllocationHandleType { 
# 2111
cudaMemHandleTypeNone, 
# 2112
cudaMemHandleTypePosixFileDescriptor, 
# 2113
cudaMemHandleTypeWin32, 
# 2114
cudaMemHandleTypeWin32Kmt = 4
# 2115
}; 
#endif
# 2120 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2120
struct cudaMemPoolProps { 
# 2121
cudaMemAllocationType allocType; 
# 2122
cudaMemAllocationHandleType handleTypes; 
# 2123
cudaMemLocation location; 
# 2130
void *win32SecurityAttributes; 
# 2131
unsigned char reserved[64]; 
# 2132
}; 
#endif
# 2137 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2137
struct cudaMemPoolPtrExportData { 
# 2138
unsigned char reserved[64]; 
# 2139
}; 
#endif
# 2144 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2144
struct cudaMemAllocNodeParams { 
# 2149
cudaMemPoolProps poolProps; 
# 2150
const cudaMemAccessDesc *accessDescs; 
# 2151
size_t accessDescCount; 
# 2152
size_t bytesize; 
# 2153
void *dptr; 
# 2154
}; 
#endif
# 2159 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2159
enum cudaGraphMemAttributeType { 
# 2164
cudaGraphMemAttrUsedMemCurrent, 
# 2171
cudaGraphMemAttrUsedMemHigh, 
# 2178
cudaGraphMemAttrReservedMemCurrent, 
# 2185
cudaGraphMemAttrReservedMemHigh
# 2186
}; 
#endif
# 2192 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2192
enum cudaDeviceP2PAttr { 
# 2193
cudaDevP2PAttrPerformanceRank = 1, 
# 2194
cudaDevP2PAttrAccessSupported, 
# 2195
cudaDevP2PAttrNativeAtomicSupported, 
# 2196
cudaDevP2PAttrCudaArrayAccessSupported
# 2197
}; 
#endif
# 2204 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2204
struct CUuuid_st { 
# 2205
char bytes[16]; 
# 2206
}; 
#endif
# 2207 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef CUuuid_st 
# 2207
CUuuid; 
#endif
# 2209 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef CUuuid_st 
# 2209
cudaUUID_t; 
#endif
# 2214 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2214
struct cudaDeviceProp { 
# 2216
char name[256]; 
# 2217
cudaUUID_t uuid; 
# 2218
char luid[8]; 
# 2219
unsigned luidDeviceNodeMask; 
# 2220
size_t totalGlobalMem; 
# 2221
size_t sharedMemPerBlock; 
# 2222
int regsPerBlock; 
# 2223
int warpSize; 
# 2224
size_t memPitch; 
# 2225
int maxThreadsPerBlock; 
# 2226
int maxThreadsDim[3]; 
# 2227
int maxGridSize[3]; 
# 2228
int clockRate; 
# 2229
size_t totalConstMem; 
# 2230
int major; 
# 2231
int minor; 
# 2232
size_t textureAlignment; 
# 2233
size_t texturePitchAlignment; 
# 2234
int deviceOverlap; 
# 2235
int multiProcessorCount; 
# 2236
int kernelExecTimeoutEnabled; 
# 2237
int integrated; 
# 2238
int canMapHostMemory; 
# 2239
int computeMode; 
# 2240
int maxTexture1D; 
# 2241
int maxTexture1DMipmap; 
# 2242
int maxTexture1DLinear; 
# 2243
int maxTexture2D[2]; 
# 2244
int maxTexture2DMipmap[2]; 
# 2245
int maxTexture2DLinear[3]; 
# 2246
int maxTexture2DGather[2]; 
# 2247
int maxTexture3D[3]; 
# 2248
int maxTexture3DAlt[3]; 
# 2249
int maxTextureCubemap; 
# 2250
int maxTexture1DLayered[2]; 
# 2251
int maxTexture2DLayered[3]; 
# 2252
int maxTextureCubemapLayered[2]; 
# 2253
int maxSurface1D; 
# 2254
int maxSurface2D[2]; 
# 2255
int maxSurface3D[3]; 
# 2256
int maxSurface1DLayered[2]; 
# 2257
int maxSurface2DLayered[3]; 
# 2258
int maxSurfaceCubemap; 
# 2259
int maxSurfaceCubemapLayered[2]; 
# 2260
size_t surfaceAlignment; 
# 2261
int concurrentKernels; 
# 2262
int ECCEnabled; 
# 2263
int pciBusID; 
# 2264
int pciDeviceID; 
# 2265
int pciDomainID; 
# 2266
int tccDriver; 
# 2267
int asyncEngineCount; 
# 2268
int unifiedAddressing; 
# 2269
int memoryClockRate; 
# 2270
int memoryBusWidth; 
# 2271
int l2CacheSize; 
# 2272
int persistingL2CacheMaxSize; 
# 2273
int maxThreadsPerMultiProcessor; 
# 2274
int streamPrioritiesSupported; 
# 2275
int globalL1CacheSupported; 
# 2276
int localL1CacheSupported; 
# 2277
size_t sharedMemPerMultiprocessor; 
# 2278
int regsPerMultiprocessor; 
# 2279
int managedMemory; 
# 2280
int isMultiGpuBoard; 
# 2281
int multiGpuBoardGroupID; 
# 2282
int hostNativeAtomicSupported; 
# 2283
int singleToDoublePrecisionPerfRatio; 
# 2284
int pageableMemoryAccess; 
# 2285
int concurrentManagedAccess; 
# 2286
int computePreemptionSupported; 
# 2287
int canUseHostPointerForRegisteredMem; 
# 2288
int cooperativeLaunch; 
# 2289
int cooperativeMultiDeviceLaunch; 
# 2290
size_t sharedMemPerBlockOptin; 
# 2291
int pageableMemoryAccessUsesHostPageTables; 
# 2292
int directManagedMemAccessFromHost; 
# 2293
int maxBlocksPerMultiProcessor; 
# 2294
int accessPolicyMaxWindowSize; 
# 2295
size_t reservedSharedMemPerBlock; 
# 2296
}; 
#endif
# 2397 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef 
# 2394
struct cudaIpcEventHandle_st { 
# 2396
char reserved[64]; 
# 2397
} cudaIpcEventHandle_t; 
#endif
# 2405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef 
# 2402
struct cudaIpcMemHandle_st { 
# 2404
char reserved[64]; 
# 2405
} cudaIpcMemHandle_t; 
#endif
# 2410 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2410
enum cudaExternalMemoryHandleType { 
# 2414
cudaExternalMemoryHandleTypeOpaqueFd = 1, 
# 2418
cudaExternalMemoryHandleTypeOpaqueWin32, 
# 2422
cudaExternalMemoryHandleTypeOpaqueWin32Kmt, 
# 2426
cudaExternalMemoryHandleTypeD3D12Heap, 
# 2430
cudaExternalMemoryHandleTypeD3D12Resource, 
# 2434
cudaExternalMemoryHandleTypeD3D11Resource, 
# 2438
cudaExternalMemoryHandleTypeD3D11ResourceKmt, 
# 2442
cudaExternalMemoryHandleTypeNvSciBuf
# 2443
}; 
#endif
# 2485 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2485
struct cudaExternalMemoryHandleDesc { 
# 2489
cudaExternalMemoryHandleType type; 
# 2490
union { 
# 2496
int fd; 
# 2512 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
struct { 
# 2516
void *handle; 
# 2521
const void *name; 
# 2522
} win32; 
# 2527
const void *nvSciBufObject; 
# 2528
} handle; 
# 2532
unsigned long long size; 
# 2536
unsigned flags; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 2537
}; 
#endif
# 2542 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2542
struct cudaExternalMemoryBufferDesc { 
# 2546
unsigned long long offset; 
# 2550
unsigned long long size; 
# 2554
unsigned flags; 
# 2555
}; 
#endif
# 2560 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2560
struct cudaExternalMemoryMipmappedArrayDesc { 
# 2565
unsigned long long offset; 
# 2569
cudaChannelFormatDesc formatDesc; 
# 2573
cudaExtent extent; 
# 2578
unsigned flags; 
# 2582
unsigned numLevels; 
# 2583
}; 
#endif
# 2588 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2588
enum cudaExternalSemaphoreHandleType { 
# 2592
cudaExternalSemaphoreHandleTypeOpaqueFd = 1, 
# 2596
cudaExternalSemaphoreHandleTypeOpaqueWin32, 
# 2600
cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt, 
# 2604
cudaExternalSemaphoreHandleTypeD3D12Fence, 
# 2608
cudaExternalSemaphoreHandleTypeD3D11Fence, 
# 2612
cudaExternalSemaphoreHandleTypeNvSciSync, 
# 2616
cudaExternalSemaphoreHandleTypeKeyedMutex, 
# 2620
cudaExternalSemaphoreHandleTypeKeyedMutexKmt, 
# 2624
cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd, 
# 2628
cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32
# 2629
}; 
#endif
# 2634 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2634
struct cudaExternalSemaphoreHandleDesc { 
# 2638
cudaExternalSemaphoreHandleType type; 
# 2639
union { 
# 2646
int fd; 
# 2662 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
struct { 
# 2666
void *handle; 
# 2671
const void *name; 
# 2672
} win32; 
# 2676
const void *nvSciSyncObj; 
# 2677
} handle; 
# 2681
unsigned flags; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
# 2682
}; 
#endif
# 2687 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2687
struct cudaExternalSemaphoreSignalParams_v1 { 
# 2688
struct { 
# 2692
struct { 
# 2696
unsigned long long value; 
# 2697
} fence; 
# 2698
union { 
# 2703
void *fence; 
# 2704
unsigned long long reserved; 
# 2705
} nvSciSync; 
# 2709
struct { 
# 2713
unsigned long long key; 
# 2714
} keyedMutex; 
# 2715
} params; 
# 2726 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
unsigned flags; 
# 2727
}; 
#endif
# 2732 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2732
struct cudaExternalSemaphoreWaitParams_v1 { 
# 2733
struct { 
# 2737
struct { 
# 2741
unsigned long long value; 
# 2742
} fence; 
# 2743
union { 
# 2748
void *fence; 
# 2749
unsigned long long reserved; 
# 2750
} nvSciSync; 
# 2754
struct { 
# 2758
unsigned long long key; 
# 2762
unsigned timeoutMs; 
# 2763
} keyedMutex; 
# 2764
} params; 
# 2775 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
unsigned flags; 
# 2776
}; 
#endif
# 2781 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2781
struct cudaExternalSemaphoreSignalParams { 
# 2782
struct { 
# 2786
struct { 
# 2790
unsigned long long value; 
# 2791
} fence; 
# 2792
union { 
# 2797
void *fence; 
# 2798
unsigned long long reserved; 
# 2799
} nvSciSync; 
# 2803
struct { 
# 2807
unsigned long long key; 
# 2808
} keyedMutex; 
# 2809
unsigned reserved[12]; 
# 2810
} params; 
# 2821 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
unsigned flags; 
# 2822
unsigned reserved[16]; 
# 2823
}; 
#endif
# 2828 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2828
struct cudaExternalSemaphoreWaitParams { 
# 2829
struct { 
# 2833
struct { 
# 2837
unsigned long long value; 
# 2838
} fence; 
# 2839
union { 
# 2844
void *fence; 
# 2845
unsigned long long reserved; 
# 2846
} nvSciSync; 
# 2850
struct { 
# 2854
unsigned long long key; 
# 2858
unsigned timeoutMs; 
# 2859
} keyedMutex; 
# 2860
unsigned reserved[10]; 
# 2861
} params; 
# 2872 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
unsigned flags; 
# 2873
unsigned reserved[16]; 
# 2874
}; 
#endif
# 2886 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef cudaError 
# 2886
cudaError_t; 
#endif
# 2891 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUstream_st *
# 2891
cudaStream_t; 
#endif
# 2896 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUevent_st *
# 2896
cudaEvent_t; 
#endif
# 2901 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef cudaGraphicsResource *
# 2901
cudaGraphicsResource_t; 
#endif
# 2906 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef cudaOutputMode 
# 2906
cudaOutputMode_t; 
#endif
# 2911 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUexternalMemory_st *
# 2911
cudaExternalMemory_t; 
#endif
# 2916 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUexternalSemaphore_st *
# 2916
cudaExternalSemaphore_t; 
#endif
# 2921 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUgraph_st *
# 2921
cudaGraph_t; 
#endif
# 2926 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUgraphNode_st *
# 2926
cudaGraphNode_t; 
#endif
# 2931 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUuserObject_st *
# 2931
cudaUserObject_t; 
#endif
# 2936 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUfunc_st *
# 2936
cudaFunction_t; 
#endif
# 2941 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
typedef struct CUmemPoolHandle_st *
# 2941
cudaMemPool_t; 
#endif
# 2946 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2946
enum cudaCGScope { 
# 2947
cudaCGScopeInvalid, 
# 2948
cudaCGScopeGrid, 
# 2949
cudaCGScopeMultiGrid
# 2950
}; 
#endif
# 2955 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2955
struct cudaLaunchParams { 
# 2957
void *func; 
# 2958
dim3 gridDim; 
# 2959
dim3 blockDim; 
# 2960
void **args; 
# 2961
size_t sharedMem; 
# 2962
cudaStream_t stream; 
# 2963
}; 
#endif
# 2968 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2968
struct cudaKernelNodeParams { 
# 2969
void *func; 
# 2970
dim3 gridDim; 
# 2971
dim3 blockDim; 
# 2972
unsigned sharedMemBytes; 
# 2973
void **kernelParams; 
# 2974
void **extra; 
# 2975
}; 
#endif
# 2980 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2980
struct cudaExternalSemaphoreSignalNodeParams { 
# 2981
cudaExternalSemaphore_t *extSemArray; 
# 2982
const cudaExternalSemaphoreSignalParams *paramsArray; 
# 2983
unsigned numExtSems; 
# 2984
}; 
#endif
# 2989 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2989
struct cudaExternalSemaphoreWaitNodeParams { 
# 2990
cudaExternalSemaphore_t *extSemArray; 
# 2991
const cudaExternalSemaphoreWaitParams *paramsArray; 
# 2992
unsigned numExtSems; 
# 2993
}; 
#endif
# 2998 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 2998
enum cudaGraphNodeType { 
# 2999
cudaGraphNodeTypeKernel, 
# 3000
cudaGraphNodeTypeMemcpy, 
# 3001
cudaGraphNodeTypeMemset, 
# 3002
cudaGraphNodeTypeHost, 
# 3003
cudaGraphNodeTypeGraph, 
# 3004
cudaGraphNodeTypeEmpty, 
# 3005
cudaGraphNodeTypeWaitEvent, 
# 3006
cudaGraphNodeTypeEventRecord, 
# 3007
cudaGraphNodeTypeExtSemaphoreSignal, 
# 3008
cudaGraphNodeTypeExtSemaphoreWait, 
# 3009
cudaGraphNodeTypeMemAlloc, 
# 3010
cudaGraphNodeTypeMemFree, 
# 3011
cudaGraphNodeTypeCount
# 3012
}; 
#endif
# 3017 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
typedef struct CUgraphExec_st *cudaGraphExec_t; 
# 3022
#if 0
# 3022
enum cudaGraphExecUpdateResult { 
# 3023
cudaGraphExecUpdateSuccess, 
# 3024
cudaGraphExecUpdateError, 
# 3025
cudaGraphExecUpdateErrorTopologyChanged, 
# 3026
cudaGraphExecUpdateErrorNodeTypeChanged, 
# 3027
cudaGraphExecUpdateErrorFunctionChanged, 
# 3028
cudaGraphExecUpdateErrorParametersChanged, 
# 3029
cudaGraphExecUpdateErrorNotSupported, 
# 3030
cudaGraphExecUpdateErrorUnsupportedFunctionChange, 
# 3031
cudaGraphExecUpdateErrorAttributesChanged
# 3032
}; 
#endif
# 3038 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 3038
enum cudaGetDriverEntryPointFlags { 
# 3039
cudaEnableDefault, 
# 3040
cudaEnableLegacyStream, 
# 3041
cudaEnablePerThreadDefaultStream
# 3042
}; 
#endif
# 3047 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 3047
enum cudaGraphDebugDotFlags { 
# 3048
cudaGraphDebugDotFlagsVerbose = (1 << 0), 
# 3049
cudaGraphDebugDotFlagsKernelNodeParams = (1 << 2), 
# 3050
cudaGraphDebugDotFlagsMemcpyNodeParams = (1 << 3), 
# 3051
cudaGraphDebugDotFlagsMemsetNodeParams = (1 << 4), 
# 3052
cudaGraphDebugDotFlagsHostNodeParams = (1 << 5), 
# 3053
cudaGraphDebugDotFlagsEventNodeParams = (1 << 6), 
# 3054
cudaGraphDebugDotFlagsExtSemasSignalNodeParams = (1 << 7), 
# 3055
cudaGraphDebugDotFlagsExtSemasWaitNodeParams = (1 << 8), 
# 3056
cudaGraphDebugDotFlagsKernelNodeAttributes = (1 << 9), 
# 3057
cudaGraphDebugDotFlagsHandles = (1 << 10)
# 3058
}; 
#endif
# 3063 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_types.h"
#if 0
# 3063
enum cudaGraphInstantiateFlags { 
# 3064
cudaGraphInstantiateFlagAutoFreeOnLaunch = 1
# 3065
}; 
#endif
# 84 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_types.h"
#if 0
# 84
enum cudaSurfaceBoundaryMode { 
# 86
cudaBoundaryModeZero, 
# 87
cudaBoundaryModeClamp, 
# 88
cudaBoundaryModeTrap
# 89
}; 
#endif
# 94 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_types.h"
#if 0
# 94
enum cudaSurfaceFormatMode { 
# 96
cudaFormatModeForced, 
# 97
cudaFormatModeAuto
# 98
}; 
#endif
# 103 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_types.h"
#if 0
# 103
struct surfaceReference { 
# 108
cudaChannelFormatDesc channelDesc; 
# 109
}; 
#endif
# 114 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_types.h"
#if 0
typedef unsigned long long 
# 114
cudaSurfaceObject_t; 
#endif
# 84 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_types.h"
#if 0
# 84
enum cudaTextureAddressMode { 
# 86
cudaAddressModeWrap, 
# 87
cudaAddressModeClamp, 
# 88
cudaAddressModeMirror, 
# 89
cudaAddressModeBorder
# 90
}; 
#endif
# 95 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_types.h"
#if 0
# 95
enum cudaTextureFilterMode { 
# 97
cudaFilterModePoint, 
# 98
cudaFilterModeLinear
# 99
}; 
#endif
# 104 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_types.h"
#if 0
# 104
enum cudaTextureReadMode { 
# 106
cudaReadModeElementType, 
# 107
cudaReadModeNormalizedFloat
# 108
}; 
#endif
# 113 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_types.h"
#if 0
# 113
struct textureReference { 
# 118
int normalized; 
# 122
cudaTextureFilterMode filterMode; 
# 126
cudaTextureAddressMode addressMode[3]; 
# 130
cudaChannelFormatDesc channelDesc; 
# 134
int sRGB; 
# 138
unsigned maxAnisotropy; 
# 142
cudaTextureFilterMode mipmapFilterMode; 
# 146
float mipmapLevelBias; 
# 150
float minMipmapLevelClamp; 
# 154
float maxMipmapLevelClamp; 
# 158
int disableTrilinearOptimization; 
# 159
int __cudaReserved[14]; 
# 160
}; 
#endif
# 165 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_types.h"
#if 0
# 165
struct cudaTextureDesc { 
# 170
cudaTextureAddressMode addressMode[3]; 
# 174
cudaTextureFilterMode filterMode; 
# 178
cudaTextureReadMode readMode; 
# 182
int sRGB; 
# 186
float borderColor[4]; 
# 190
int normalizedCoords; 
# 194
unsigned maxAnisotropy; 
# 198
cudaTextureFilterMode mipmapFilterMode; 
# 202
float mipmapLevelBias; 
# 206
float minMipmapLevelClamp; 
# 210
float maxMipmapLevelClamp; 
# 214
int disableTrilinearOptimization; 
# 218
int seamlessCubemap; 
# 219
}; 
#endif
# 224 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_types.h"
#if 0
typedef unsigned long long 
# 224
cudaTextureObject_t; 
#endif
# 84 "/usr/local/cuda/bin/../targets/x86_64-linux/include/library_types.h"
typedef 
# 54
enum cudaDataType_t { 
# 56
CUDA_R_16F = 2, 
# 57
CUDA_C_16F = 6, 
# 58
CUDA_R_16BF = 14, 
# 59
CUDA_C_16BF, 
# 60
CUDA_R_32F = 0, 
# 61
CUDA_C_32F = 4, 
# 62
CUDA_R_64F = 1, 
# 63
CUDA_C_64F = 5, 
# 64
CUDA_R_4I = 16, 
# 65
CUDA_C_4I, 
# 66
CUDA_R_4U, 
# 67
CUDA_C_4U, 
# 68
CUDA_R_8I = 3, 
# 69
CUDA_C_8I = 7, 
# 70
CUDA_R_8U, 
# 71
CUDA_C_8U, 
# 72
CUDA_R_16I = 20, 
# 73
CUDA_C_16I, 
# 74
CUDA_R_16U, 
# 75
CUDA_C_16U, 
# 76
CUDA_R_32I = 10, 
# 77
CUDA_C_32I, 
# 78
CUDA_R_32U, 
# 79
CUDA_C_32U, 
# 80
CUDA_R_64I = 24, 
# 81
CUDA_C_64I, 
# 82
CUDA_R_64U, 
# 83
CUDA_C_64U
# 84
} cudaDataType; 
# 92
typedef 
# 87
enum libraryPropertyType_t { 
# 89
MAJOR_VERSION, 
# 90
MINOR_VERSION, 
# 91
PATCH_LEVEL
# 92
} libraryPropertyType; 
# 131 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_device_runtime_api.h"
extern "C" {
# 133
extern cudaError_t cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
# 134
extern cudaError_t cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
# 135
extern cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 136
extern cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
# 137
extern cudaError_t cudaDeviceSynchronize(); 
# 138
__attribute__((unused)) extern cudaError_t __cudaDeviceSynchronizeDeprecationAvoidance(); 
# 139
extern cudaError_t cudaGetLastError(); 
# 140
extern cudaError_t cudaPeekAtLastError(); 
# 141
extern const char *cudaGetErrorString(cudaError_t error); 
# 142
extern const char *cudaGetErrorName(cudaError_t error); 
# 143
extern cudaError_t cudaGetDeviceCount(int * count); 
# 144
extern cudaError_t cudaGetDevice(int * device); 
# 145
extern cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
# 146
extern cudaError_t cudaStreamDestroy(cudaStream_t stream); 
# 147
extern cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 148
__attribute__((unused)) extern cudaError_t cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
# 149
extern cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
# 150
extern cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream); 
# 151
__attribute__((unused)) extern cudaError_t cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); 
# 152
extern cudaError_t cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream, unsigned flags); 
# 153
__attribute__((unused)) extern cudaError_t cudaEventRecordWithFlags_ptsz(cudaEvent_t event, cudaStream_t stream, unsigned flags); 
# 154
extern cudaError_t cudaEventDestroy(cudaEvent_t event); 
# 155
extern cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
# 156
extern cudaError_t cudaFree(void * devPtr); 
# 157
extern cudaError_t cudaMalloc(void ** devPtr, size_t size); 
# 158
extern cudaError_t cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
# 159
__attribute__((unused)) extern cudaError_t cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
# 160
extern cudaError_t cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
# 161
__attribute__((unused)) extern cudaError_t cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
# 162
extern cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); 
# 163
__attribute__((unused)) extern cudaError_t cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); 
# 164
extern cudaError_t cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); 
# 165
__attribute__((unused)) extern cudaError_t cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); 
# 166
extern cudaError_t cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
# 167
__attribute__((unused)) extern cudaError_t cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
# 168
extern cudaError_t cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
# 169
__attribute__((unused)) extern cudaError_t cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
# 170
extern cudaError_t cudaRuntimeGetVersion(int * runtimeVersion); 
# 191 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_device_runtime_api.h"
__attribute__((unused)) extern void *cudaGetParameterBuffer(size_t alignment, size_t size); 
# 219 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_device_runtime_api.h"
__attribute__((unused)) extern void *cudaGetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); 
# 220
__attribute__((unused)) extern cudaError_t cudaLaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
# 221
__attribute__((unused)) extern cudaError_t cudaLaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); 
# 239 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_device_runtime_api.h"
__attribute__((unused)) extern cudaError_t cudaLaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
# 240
__attribute__((unused)) extern cudaError_t cudaLaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); 
# 243
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); 
# 244
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
# 246
__attribute__((unused)) extern unsigned long long cudaCGGetIntrinsicHandle(cudaCGScope scope); 
# 247
__attribute__((unused)) extern cudaError_t cudaCGSynchronize(unsigned long long handle, unsigned flags); 
# 248
__attribute__((unused)) extern cudaError_t cudaCGSynchronizeGrid(unsigned long long handle, unsigned flags); 
# 249
__attribute__((unused)) extern cudaError_t cudaCGGetSize(unsigned * numThreads, unsigned * numGrids, unsigned long long handle); 
# 250
__attribute__((unused)) extern cudaError_t cudaCGGetRank(unsigned * threadRank, unsigned * gridRank, unsigned long long handle); 
# 251
}
# 253
template< class T> static inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
# 254
template< class T> static inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
# 255
template< class T> static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
# 256
template< class T> static inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
# 266 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern "C" {
# 306 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceReset(); 
# 328 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSynchronize(); 
# 415 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSetLimit(cudaLimit limit, size_t value); 
# 450 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
# 473 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetTexture1DLinearMaxWidth(size_t * maxWidthInElements, const cudaChannelFormatDesc * fmtDesc, int device); 
# 507 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 544 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
# 588 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); 
# 619 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
# 663 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); 
# 690 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); 
# 720 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); 
# 768 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); 
# 809 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); 
# 852 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); 
# 916 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); 
# 952 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaIpcCloseMemHandle(void * devPtr); 
# 984 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceFlushGPUDirectRDMAWrites(cudaFlushGPUDirectRDMAWritesTarget target, cudaFlushGPUDirectRDMAWritesScope scope); 
# 1028 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaThreadExit(); 
# 1054 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaThreadSynchronize(); 
# 1103 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaThreadSetLimit(cudaLimit limit, size_t value); 
# 1136 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaThreadGetLimit(size_t * pValue, cudaLimit limit); 
# 1172 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); 
# 1219 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); 
# 1282 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetLastError(); 
# 1330 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaPeekAtLastError(); 
# 1346 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern const char *cudaGetErrorName(cudaError_t error); 
# 1362 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern const char *cudaGetErrorString(cudaError_t error); 
# 1390 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDeviceCount(int * count); 
# 1668 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDeviceProperties(cudaDeviceProp * prop, int device); 
# 1872 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
# 1890 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetDefaultMemPool(cudaMemPool_t * memPool, int device); 
# 1914 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSetMemPool(int device, cudaMemPool_t memPool); 
# 1934 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetMemPool(cudaMemPool_t * memPool, int device); 
# 1982 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetNvSciSyncAttributes(void * nvSciSyncAttrList, int device, int flags); 
# 2022 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetP2PAttribute(int * value, cudaDeviceP2PAttr attr, int srcDevice, int dstDevice); 
# 2043 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaChooseDevice(int * device, const cudaDeviceProp * prop); 
# 2084 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaSetDevice(int device); 
# 2105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDevice(int * device); 
# 2136 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaSetValidDevices(int * device_arr, int len); 
# 2201 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaSetDeviceFlags(unsigned flags); 
# 2245 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDeviceFlags(unsigned * flags); 
# 2285 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamCreate(cudaStream_t * pStream); 
# 2317 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
# 2363 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); 
# 2390 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamGetPriority(cudaStream_t hStream, int * priority); 
# 2415 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamGetFlags(cudaStream_t hStream, unsigned * flags); 
# 2430 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaCtxResetPersistingL2Cache(); 
# 2450 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamCopyAttributes(cudaStream_t dst, cudaStream_t src); 
# 2471 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamGetAttribute(cudaStream_t hStream, cudaStreamAttrID attr, cudaStreamAttrValue * value_out); 
# 2495 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamSetAttribute(cudaStream_t hStream, cudaStreamAttrID attr, const cudaStreamAttrValue * value); 
# 2529 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamDestroy(cudaStream_t stream); 
# 2560 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags = 0); 
# 2568
typedef void (*cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); 
# 2635 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamAddCallback(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); 
# 2659 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamSynchronize(cudaStream_t stream); 
# 2684 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamQuery(cudaStream_t stream); 
# 2768 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamAttachMemAsync(cudaStream_t stream, void * devPtr, size_t length = 0, unsigned flags = 4); 
# 2807 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamBeginCapture(cudaStream_t stream, cudaStreamCaptureMode mode); 
# 2858 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaThreadExchangeStreamCaptureMode(cudaStreamCaptureMode * mode); 
# 2886 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamEndCapture(cudaStream_t stream, cudaGraph_t * pGraph); 
# 2924 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamIsCapturing(cudaStream_t stream, cudaStreamCaptureStatus * pCaptureStatus); 
# 2956 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamGetCaptureInfo(cudaStream_t stream, cudaStreamCaptureStatus * pCaptureStatus, unsigned long long * pId); 
# 3011 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamGetCaptureInfo_v2(cudaStream_t stream, cudaStreamCaptureStatus * captureStatus_out, unsigned long long * id_out = 0, cudaGraph_t * graph_out = 0, const cudaGraphNode_t ** dependencies_out = 0, size_t * numDependencies_out = 0); 
# 3044 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaStreamUpdateCaptureDependencies(cudaStream_t stream, cudaGraphNode_t * dependencies, size_t numDependencies, unsigned flags = 0); 
# 3081 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaEventCreate(cudaEvent_t * event); 
# 3118 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
# 3158 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0); 
# 3205 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaEventRecordWithFlags(cudaEvent_t event, cudaStream_t stream = 0, unsigned flags = 0); 
# 3237 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaEventQuery(cudaEvent_t event); 
# 3267 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaEventSynchronize(cudaEvent_t event); 
# 3296 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaEventDestroy(cudaEvent_t event); 
# 3339 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); 
# 3519 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaImportExternalMemory(cudaExternalMemory_t * extMem_out, const cudaExternalMemoryHandleDesc * memHandleDesc); 
# 3574 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaExternalMemoryGetMappedBuffer(void ** devPtr, cudaExternalMemory_t extMem, const cudaExternalMemoryBufferDesc * bufferDesc); 
# 3634 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaExternalMemoryGetMappedMipmappedArray(cudaMipmappedArray_t * mipmap, cudaExternalMemory_t extMem, const cudaExternalMemoryMipmappedArrayDesc * mipmapDesc); 
# 3658 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDestroyExternalMemory(cudaExternalMemory_t extMem); 
# 3811 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaImportExternalSemaphore(cudaExternalSemaphore_t * extSem_out, const cudaExternalSemaphoreHandleDesc * semHandleDesc); 
# 3878 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaSignalExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t * extSemArray, const cudaExternalSemaphoreSignalParams * paramsArray, unsigned numExtSems, cudaStream_t stream = 0); 
# 3954 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaWaitExternalSemaphoresAsync_v2(const cudaExternalSemaphore_t * extSemArray, const cudaExternalSemaphoreWaitParams * paramsArray, unsigned numExtSems, cudaStream_t stream = 0); 
# 3977 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDestroyExternalSemaphore(cudaExternalSemaphore_t extSem); 
# 4044 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaLaunchKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
# 4101 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaLaunchCooperativeKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
# 4202 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaLaunchCooperativeKernelMultiDevice(cudaLaunchParams * launchParamsList, unsigned numDevices, unsigned flags = 0); 
# 4249 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); 
# 4304 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); 
# 4337 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
# 4374 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFuncSetAttribute(const void * func, cudaFuncAttribute attr, int value); 
# 4400 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaSetDoubleForDevice(double * d); 
# 4424 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaSetDoubleForHost(double * d); 
# 4492 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaLaunchHostFunc(cudaStream_t stream, cudaHostFn_t fn, void * userData); 
# 4549 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); 
# 4578 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaOccupancyAvailableDynamicSMemPerBlock(size_t * dynamicSmemSize, const void * func, int numBlocks, int blockSize); 
# 4623 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
# 4744 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocManaged(void ** devPtr, size_t size, unsigned flags = 1); 
# 4777 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMalloc(void ** devPtr, size_t size); 
# 4810 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocHost(void ** ptr, size_t size); 
# 4853 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); 
# 4907 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); 
# 4936 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFree(void * devPtr); 
# 4959 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFreeHost(void * ptr); 
# 4982 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFreeArray(cudaArray_t array); 
# 5005 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); 
# 5071 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaHostAlloc(void ** pHost, size_t size, unsigned flags); 
# 5164 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaHostRegister(void * ptr, size_t size, unsigned flags); 
# 5187 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaHostUnregister(void * ptr); 
# 5232 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); 
# 5254 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaHostGetFlags(unsigned * pFlags, void * pHost); 
# 5293 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); 
# 5440 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); 
# 5587 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); 
# 5620 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); 
# 5725 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy3D(const cudaMemcpy3DParms * p); 
# 5756 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * p); 
# 5874 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); 
# 5900 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); 
# 5934 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemGetInfo(size_t * free, size_t * total); 
# 5960 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); 
# 5989 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaArrayGetPlane(cudaArray_t * pPlaneArray, cudaArray_t hArray, unsigned planeIdx); 
# 6013 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaArrayGetMemoryRequirements(cudaArrayMemoryRequirements * memoryRequirements, cudaArray_t array, int device); 
# 6037 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMipmappedArrayGetMemoryRequirements(cudaArrayMemoryRequirements * memoryRequirements, cudaMipmappedArray_t mipmap, int device); 
# 6066 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaArrayGetSparseProperties(cudaArraySparseProperties * sparseProperties, cudaArray_t array); 
# 6096 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMipmappedArrayGetSparseProperties(cudaArraySparseProperties * sparseProperties, cudaMipmappedArray_t mipmap); 
# 6141 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy(void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
# 6176 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); 
# 6225 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
# 6275 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
# 6325 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DFromArray(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); 
# 6372 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
# 6415 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyToSymbol(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); 
# 6458 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); 
# 6515 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 6550 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); 
# 6613 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 6671 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 6728 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpy2DFromArrayAsync(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 6779 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 6830 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 6859 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset(void * devPtr, int value, size_t count); 
# 6893 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset2D(void * devPtr, size_t pitch, int value, size_t width, size_t height); 
# 6939 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); 
# 6975 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream = 0); 
# 7016 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); 
# 7069 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); 
# 7097 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetSymbolAddress(void ** devPtr, const void * symbol); 
# 7124 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetSymbolSize(size_t * size, const void * symbol); 
# 7194 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPrefetchAsync(const void * devPtr, size_t count, int dstDevice, cudaStream_t stream = 0); 
# 7310 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemAdvise(const void * devPtr, size_t count, cudaMemoryAdvise advice, int device); 
# 7369 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemRangeGetAttribute(void * data, size_t dataSize, cudaMemRangeAttribute attribute, const void * devPtr, size_t count); 
# 7408 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemRangeGetAttributes(void ** data, size_t * dataSizes, cudaMemRangeAttribute * attributes, size_t numAttributes, const void * devPtr, size_t count); 
# 7468 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); 
# 7510 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaMemcpyFromArray(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); 
# 7553 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
# 7604 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 7654 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
# 7723 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocAsync(void ** devPtr, size_t size, cudaStream_t hStream); 
# 7749 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaFreeAsync(void * devPtr, cudaStream_t hStream); 
# 7774 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolTrimTo(cudaMemPool_t memPool, size_t minBytesToKeep); 
# 7818 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolSetAttribute(cudaMemPool_t memPool, cudaMemPoolAttr attr, void * value); 
# 7866 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolGetAttribute(cudaMemPool_t memPool, cudaMemPoolAttr attr, void * value); 
# 7881 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolSetAccess(cudaMemPool_t memPool, const cudaMemAccessDesc * descList, size_t count); 
# 7894 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolGetAccess(cudaMemAccessFlags * flags, cudaMemPool_t memPool, cudaMemLocation * location); 
# 7914 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolCreate(cudaMemPool_t * memPool, const cudaMemPoolProps * poolProps); 
# 7936 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolDestroy(cudaMemPool_t memPool); 
# 7972 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMallocFromPoolAsync(void ** ptr, size_t size, cudaMemPool_t memPool, cudaStream_t stream); 
# 7997 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolExportToShareableHandle(void * shareableHandle, cudaMemPool_t memPool, cudaMemAllocationHandleType handleType, unsigned flags); 
# 8024 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolImportFromShareableHandle(cudaMemPool_t * memPool, void * shareableHandle, cudaMemAllocationHandleType handleType, unsigned flags); 
# 8047 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolExportPointer(cudaMemPoolPtrExportData * exportData, void * ptr); 
# 8076 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaMemPoolImportPointer(void ** ptr, cudaMemPool_t memPool, cudaMemPoolPtrExportData * exportData); 
# 8228 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); 
# 8269 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); 
# 8311 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); 
# 8333 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceDisablePeerAccess(int peerDevice); 
# 8397 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); 
# 8432 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); 
# 8471 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
# 8506 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
# 8538 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); 
# 8576 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); 
# 8605 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); 
# 8676 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaBindTexture(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t size = ((2147483647) * 2U) + 1U); 
# 8735 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaBindTexture2D(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t width, size_t height, size_t pitch); 
# 8773 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaBindTextureToArray(const textureReference * texref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
# 8813 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaBindTextureToMipmappedArray(const textureReference * texref, cudaMipmappedArray_const_t mipmappedArray, const cudaChannelFormatDesc * desc); 
# 8839 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaUnbindTexture(const textureReference * texref); 
# 8868 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaGetTextureAlignmentOffset(size_t * offset, const textureReference * texref); 
# 8898 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaGetTextureReference(const textureReference ** texref, const void * symbol); 
# 8943 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaBindSurfaceToArray(const surfaceReference * surfref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
# 8968 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
__attribute((deprecated)) extern cudaError_t cudaGetSurfaceReference(const surfaceReference ** surfref, const void * symbol); 
# 9003 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); 
# 9033 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaChannelFormatDesc cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); 
# 9257 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
# 9277 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDestroyTextureObject(cudaTextureObject_t texObject); 
# 9297 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); 
# 9317 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); 
# 9338 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); 
# 9383 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); 
# 9403 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); 
# 9422 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); 
# 9456 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDriverGetVersion(int * driverVersion); 
# 9481 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaRuntimeGetVersion(int * runtimeVersion); 
# 9528 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphCreate(cudaGraph_t * pGraph, unsigned flags); 
# 9625 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddKernelNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaKernelNodeParams * pNodeParams); 
# 9658 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphKernelNodeGetParams(cudaGraphNode_t node, cudaKernelNodeParams * pNodeParams); 
# 9683 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphKernelNodeSetParams(cudaGraphNode_t node, const cudaKernelNodeParams * pNodeParams); 
# 9703 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphKernelNodeCopyAttributes(cudaGraphNode_t hSrc, cudaGraphNode_t hDst); 
# 9726 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphKernelNodeGetAttribute(cudaGraphNode_t hNode, cudaKernelNodeAttrID attr, cudaKernelNodeAttrValue * value_out); 
# 9750 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphKernelNodeSetAttribute(cudaGraphNode_t hNode, cudaKernelNodeAttrID attr, const cudaKernelNodeAttrValue * value); 
# 9800 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddMemcpyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaMemcpy3DParms * pCopyParams); 
# 9859 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddMemcpyNodeToSymbol(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
# 9928 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddMemcpyNodeFromSymbol(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
# 9996 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddMemcpyNode1D(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
# 10028 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemcpyNodeGetParams(cudaGraphNode_t node, cudaMemcpy3DParms * pNodeParams); 
# 10054 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemcpyNodeSetParams(cudaGraphNode_t node, const cudaMemcpy3DParms * pNodeParams); 
# 10093 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemcpyNodeSetParamsToSymbol(cudaGraphNode_t node, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
# 10139 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemcpyNodeSetParamsFromSymbol(cudaGraphNode_t node, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
# 10185 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemcpyNodeSetParams1D(cudaGraphNode_t node, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
# 10232 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddMemsetNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaMemsetParams * pMemsetParams); 
# 10255 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemsetNodeGetParams(cudaGraphNode_t node, cudaMemsetParams * pNodeParams); 
# 10278 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemsetNodeSetParams(cudaGraphNode_t node, const cudaMemsetParams * pNodeParams); 
# 10319 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddHostNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaHostNodeParams * pNodeParams); 
# 10342 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphHostNodeGetParams(cudaGraphNode_t node, cudaHostNodeParams * pNodeParams); 
# 10365 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphHostNodeSetParams(cudaGraphNode_t node, const cudaHostNodeParams * pNodeParams); 
# 10405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddChildGraphNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaGraph_t childGraph); 
# 10432 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphChildGraphNodeGetGraph(cudaGraphNode_t node, cudaGraph_t * pGraph); 
# 10469 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddEmptyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies); 
# 10512 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddEventRecordNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaEvent_t event); 
# 10539 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphEventRecordNodeGetEvent(cudaGraphNode_t node, cudaEvent_t * event_out); 
# 10566 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphEventRecordNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event); 
# 10612 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddEventWaitNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaEvent_t event); 
# 10639 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphEventWaitNodeGetEvent(cudaGraphNode_t node, cudaEvent_t * event_out); 
# 10666 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphEventWaitNodeSetEvent(cudaGraphNode_t node, cudaEvent_t event); 
# 10715 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddExternalSemaphoresSignalNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
# 10748 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExternalSemaphoresSignalNodeGetParams(cudaGraphNode_t hNode, cudaExternalSemaphoreSignalNodeParams * params_out); 
# 10775 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExternalSemaphoresSignalNodeSetParams(cudaGraphNode_t hNode, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
# 10824 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddExternalSemaphoresWaitNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
# 10857 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExternalSemaphoresWaitNodeGetParams(cudaGraphNode_t hNode, cudaExternalSemaphoreWaitNodeParams * params_out); 
# 10884 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExternalSemaphoresWaitNodeSetParams(cudaGraphNode_t hNode, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
# 10961 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddMemAllocNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaMemAllocNodeParams * nodeParams); 
# 10988 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemAllocNodeGetParams(cudaGraphNode_t node, cudaMemAllocNodeParams * params_out); 
# 11048 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddMemFreeNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, void * dptr); 
# 11072 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphMemFreeNodeGetParams(cudaGraphNode_t node, void * dptr_out); 
# 11100 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGraphMemTrim(int device); 
# 11137 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceGetGraphMemAttribute(int device, cudaGraphMemAttributeType attr, void * value); 
# 11171 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaDeviceSetGraphMemAttribute(int device, cudaGraphMemAttributeType attr, void * value); 
# 11199 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphClone(cudaGraph_t * pGraphClone, cudaGraph_t originalGraph); 
# 11227 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphNodeFindInClone(cudaGraphNode_t * pNode, cudaGraphNode_t originalNode, cudaGraph_t clonedGraph); 
# 11258 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphNodeGetType(cudaGraphNode_t node, cudaGraphNodeType * pType); 
# 11289 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphGetNodes(cudaGraph_t graph, cudaGraphNode_t * nodes, size_t * numNodes); 
# 11320 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphGetRootNodes(cudaGraph_t graph, cudaGraphNode_t * pRootNodes, size_t * pNumRootNodes); 
# 11354 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphGetEdges(cudaGraph_t graph, cudaGraphNode_t * from, cudaGraphNode_t * to, size_t * numEdges); 
# 11385 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphNodeGetDependencies(cudaGraphNode_t node, cudaGraphNode_t * pDependencies, size_t * pNumDependencies); 
# 11417 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphNodeGetDependentNodes(cudaGraphNode_t node, cudaGraphNode_t * pDependentNodes, size_t * pNumDependentNodes); 
# 11448 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphAddDependencies(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t numDependencies); 
# 11479 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphRemoveDependencies(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t numDependencies); 
# 11509 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphDestroyNode(cudaGraphNode_t node); 
# 11547 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphInstantiate(cudaGraphExec_t * pGraphExec, cudaGraph_t graph, cudaGraphNode_t * pErrorNode, char * pLogBuffer, size_t bufferSize); 
# 11590 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphInstantiateWithFlags(cudaGraphExec_t * pGraphExec, cudaGraph_t graph, unsigned long long flags); 
# 11634 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecKernelNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaKernelNodeParams * pNodeParams); 
# 11684 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecMemcpyNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaMemcpy3DParms * pNodeParams); 
# 11739 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecMemcpyNodeSetParamsToSymbol(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind); 
# 11802 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecMemcpyNodeSetParamsFromSymbol(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind); 
# 11863 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecMemcpyNodeSetParams1D(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
# 11917 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecMemsetNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaMemsetParams * pNodeParams); 
# 11956 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecHostNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaHostNodeParams * pNodeParams); 
# 12002 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecChildGraphNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, cudaGraph_t childGraph); 
# 12046 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecEventRecordNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event); 
# 12090 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecEventWaitNodeSetEvent(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, cudaEvent_t event); 
# 12137 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecExternalSemaphoresSignalNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const cudaExternalSemaphoreSignalNodeParams * nodeParams); 
# 12184 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecExternalSemaphoresWaitNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, const cudaExternalSemaphoreWaitNodeParams * nodeParams); 
# 12224 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphNodeSetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned isEnabled); 
# 12258 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphNodeGetEnabled(cudaGraphExec_t hGraphExec, cudaGraphNode_t hNode, unsigned * isEnabled); 
# 12336 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecUpdate(cudaGraphExec_t hGraphExec, cudaGraph_t hGraph, cudaGraphNode_t * hErrorNode_out, cudaGraphExecUpdateResult * updateResult_out); 
# 12361 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphUpload(cudaGraphExec_t graphExec, cudaStream_t stream); 
# 12392 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphLaunch(cudaGraphExec_t graphExec, cudaStream_t stream); 
# 12415 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphExecDestroy(cudaGraphExec_t graphExec); 
# 12436 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphDestroy(cudaGraph_t graph); 
# 12455 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphDebugDotPrint(cudaGraph_t graph, const char * path, unsigned flags); 
# 12491 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaUserObjectCreate(cudaUserObject_t * object_out, void * ptr, cudaHostFn_t destroy, unsigned initialRefcount, unsigned flags); 
# 12515 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaUserObjectRetain(cudaUserObject_t object, unsigned count = 1); 
# 12543 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaUserObjectRelease(cudaUserObject_t object, unsigned count = 1); 
# 12571 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphRetainUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned count = 1, unsigned flags = 0); 
# 12596 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGraphReleaseUserObject(cudaGraph_t graph, cudaUserObject_t object, unsigned count = 1); 
# 12662 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetDriverEntryPoint(const char * symbol, void ** funcPtr, unsigned long long flags); 
# 12667
extern cudaError_t cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); 
# 12843 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
extern cudaError_t cudaGetFuncBySymbol(cudaFunction_t * functionPtr, const void * symbolPtr); 
# 12985 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime_api.h"
}
# 124 "/usr/local/cuda/bin/../targets/x86_64-linux/include/channel_descriptor.h"
template< class T> inline cudaChannelFormatDesc cudaCreateChannelDesc() 
# 125
{ 
# 126
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
# 127
} 
# 129
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
# 130
{ 
# 131
int e = (((int)sizeof(unsigned short)) * 8); 
# 133
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 134
} 
# 136
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
# 137
{ 
# 138
int e = (((int)sizeof(unsigned short)) * 8); 
# 140
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 141
} 
# 143
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
# 144
{ 
# 145
int e = (((int)sizeof(unsigned short)) * 8); 
# 147
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 148
} 
# 150
static inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
# 151
{ 
# 152
int e = (((int)sizeof(unsigned short)) * 8); 
# 154
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 155
} 
# 157
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
# 158
{ 
# 159
int e = (((int)sizeof(char)) * 8); 
# 164
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 166
} 
# 168
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
# 169
{ 
# 170
int e = (((int)sizeof(signed char)) * 8); 
# 172
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 173
} 
# 175
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
# 176
{ 
# 177
int e = (((int)sizeof(unsigned char)) * 8); 
# 179
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 180
} 
# 182
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
# 183
{ 
# 184
int e = (((int)sizeof(signed char)) * 8); 
# 186
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 187
} 
# 189
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
# 190
{ 
# 191
int e = (((int)sizeof(unsigned char)) * 8); 
# 193
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 194
} 
# 196
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
# 197
{ 
# 198
int e = (((int)sizeof(signed char)) * 8); 
# 200
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 201
} 
# 203
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
# 204
{ 
# 205
int e = (((int)sizeof(unsigned char)) * 8); 
# 207
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 208
} 
# 210
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
# 211
{ 
# 212
int e = (((int)sizeof(signed char)) * 8); 
# 214
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 215
} 
# 217
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
# 218
{ 
# 219
int e = (((int)sizeof(unsigned char)) * 8); 
# 221
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 222
} 
# 224
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
# 225
{ 
# 226
int e = (((int)sizeof(short)) * 8); 
# 228
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 229
} 
# 231
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
# 232
{ 
# 233
int e = (((int)sizeof(unsigned short)) * 8); 
# 235
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 236
} 
# 238
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
# 239
{ 
# 240
int e = (((int)sizeof(short)) * 8); 
# 242
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 243
} 
# 245
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
# 246
{ 
# 247
int e = (((int)sizeof(unsigned short)) * 8); 
# 249
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 250
} 
# 252
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
# 253
{ 
# 254
int e = (((int)sizeof(short)) * 8); 
# 256
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 257
} 
# 259
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
# 260
{ 
# 261
int e = (((int)sizeof(unsigned short)) * 8); 
# 263
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 264
} 
# 266
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
# 267
{ 
# 268
int e = (((int)sizeof(short)) * 8); 
# 270
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 271
} 
# 273
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
# 274
{ 
# 275
int e = (((int)sizeof(unsigned short)) * 8); 
# 277
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 278
} 
# 280
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
# 281
{ 
# 282
int e = (((int)sizeof(int)) * 8); 
# 284
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 285
} 
# 287
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
# 288
{ 
# 289
int e = (((int)sizeof(unsigned)) * 8); 
# 291
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 292
} 
# 294
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
# 295
{ 
# 296
int e = (((int)sizeof(int)) * 8); 
# 298
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
# 299
} 
# 301
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
# 302
{ 
# 303
int e = (((int)sizeof(unsigned)) * 8); 
# 305
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
# 306
} 
# 308
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
# 309
{ 
# 310
int e = (((int)sizeof(int)) * 8); 
# 312
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
# 313
} 
# 315
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
# 316
{ 
# 317
int e = (((int)sizeof(unsigned)) * 8); 
# 319
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
# 320
} 
# 322
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
# 323
{ 
# 324
int e = (((int)sizeof(int)) * 8); 
# 326
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
# 327
} 
# 329
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
# 330
{ 
# 331
int e = (((int)sizeof(unsigned)) * 8); 
# 333
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
# 334
} 
# 396 "/usr/local/cuda/bin/../targets/x86_64-linux/include/channel_descriptor.h"
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
# 397
{ 
# 398
int e = (((int)sizeof(float)) * 8); 
# 400
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 401
} 
# 403
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
# 404
{ 
# 405
int e = (((int)sizeof(float)) * 8); 
# 407
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
# 408
} 
# 410
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
# 411
{ 
# 412
int e = (((int)sizeof(float)) * 8); 
# 414
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
# 415
} 
# 417
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
# 418
{ 
# 419
int e = (((int)sizeof(float)) * 8); 
# 421
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
# 422
} 
# 424
static inline cudaChannelFormatDesc cudaCreateChannelDescNV12() 
# 425
{ 
# 426
int e = (((int)sizeof(char)) * 8); 
# 428
return cudaCreateChannelDesc(e, e, e, 0, cudaChannelFormatKindNV12); 
# 429
} 
# 431
template< cudaChannelFormatKind > inline cudaChannelFormatDesc cudaCreateChannelDesc() 
# 432
{ 
# 433
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
# 434
} 
# 437
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X1> () 
# 438
{ 
# 439
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedNormalized8X1); 
# 440
} 
# 442
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X2> () 
# 443
{ 
# 444
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedNormalized8X2); 
# 445
} 
# 447
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized8X4> () 
# 448
{ 
# 449
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindSignedNormalized8X4); 
# 450
} 
# 453
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X1> () 
# 454
{ 
# 455
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized8X1); 
# 456
} 
# 458
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X2> () 
# 459
{ 
# 460
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedNormalized8X2); 
# 461
} 
# 463
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized8X4> () 
# 464
{ 
# 465
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedNormalized8X4); 
# 466
} 
# 469
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X1> () 
# 470
{ 
# 471
return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindSignedNormalized16X1); 
# 472
} 
# 474
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X2> () 
# 475
{ 
# 476
return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindSignedNormalized16X2); 
# 477
} 
# 479
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedNormalized16X4> () 
# 480
{ 
# 481
return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindSignedNormalized16X4); 
# 482
} 
# 485
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X1> () 
# 486
{ 
# 487
return cudaCreateChannelDesc(16, 0, 0, 0, cudaChannelFormatKindUnsignedNormalized16X1); 
# 488
} 
# 490
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X2> () 
# 491
{ 
# 492
return cudaCreateChannelDesc(16, 16, 0, 0, cudaChannelFormatKindUnsignedNormalized16X2); 
# 493
} 
# 495
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedNormalized16X4> () 
# 496
{ 
# 497
return cudaCreateChannelDesc(16, 16, 16, 16, cudaChannelFormatKindUnsignedNormalized16X4); 
# 498
} 
# 501
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindNV12> () 
# 502
{ 
# 503
return cudaCreateChannelDesc(8, 8, 8, 0, cudaChannelFormatKindNV12); 
# 504
} 
# 507
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed1> () 
# 508
{ 
# 509
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1); 
# 510
} 
# 513
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed1SRGB> () 
# 514
{ 
# 515
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed1SRGB); 
# 516
} 
# 519
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed2> () 
# 520
{ 
# 521
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2); 
# 522
} 
# 525
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed2SRGB> () 
# 526
{ 
# 527
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed2SRGB); 
# 528
} 
# 531
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed3> () 
# 532
{ 
# 533
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3); 
# 534
} 
# 537
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed3SRGB> () 
# 538
{ 
# 539
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed3SRGB); 
# 540
} 
# 543
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed4> () 
# 544
{ 
# 545
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed4); 
# 546
} 
# 549
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed4> () 
# 550
{ 
# 551
return cudaCreateChannelDesc(8, 0, 0, 0, cudaChannelFormatKindSignedBlockCompressed4); 
# 552
} 
# 555
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed5> () 
# 556
{ 
# 557
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindUnsignedBlockCompressed5); 
# 558
} 
# 561
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed5> () 
# 562
{ 
# 563
return cudaCreateChannelDesc(8, 8, 0, 0, cudaChannelFormatKindSignedBlockCompressed5); 
# 564
} 
# 567
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed6H> () 
# 568
{ 
# 569
return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindUnsignedBlockCompressed6H); 
# 570
} 
# 573
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindSignedBlockCompressed6H> () 
# 574
{ 
# 575
return cudaCreateChannelDesc(16, 16, 16, 0, cudaChannelFormatKindSignedBlockCompressed6H); 
# 576
} 
# 579
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed7> () 
# 580
{ 
# 581
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7); 
# 582
} 
# 585
template<> inline cudaChannelFormatDesc cudaCreateChannelDesc< cudaChannelFormatKindUnsignedBlockCompressed7SRGB> () 
# 586
{ 
# 587
return cudaCreateChannelDesc(8, 8, 8, 8, cudaChannelFormatKindUnsignedBlockCompressed7SRGB); 
# 588
} 
# 79 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_functions.h"
static inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
# 80
{ 
# 81
cudaPitchedPtr s; 
# 83
(s.ptr) = d; 
# 84
(s.pitch) = p; 
# 85
(s.xsize) = xsz; 
# 86
(s.ysize) = ysz; 
# 88
return s; 
# 89
} 
# 106 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_functions.h"
static inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
# 107
{ 
# 108
cudaPos p; 
# 110
(p.x) = x; 
# 111
(p.y) = y; 
# 112
(p.z) = z; 
# 114
return p; 
# 115
} 
# 132 "/usr/local/cuda/bin/../targets/x86_64-linux/include/driver_functions.h"
static inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
# 133
{ 
# 134
cudaExtent e; 
# 136
(e.width) = w; 
# 137
(e.height) = h; 
# 138
(e.depth) = d; 
# 140
return e; 
# 141
} 
# 73 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_functions.h"
static inline char1 make_char1(signed char x); 
# 75
static inline uchar1 make_uchar1(unsigned char x); 
# 77
static inline char2 make_char2(signed char x, signed char y); 
# 79
static inline uchar2 make_uchar2(unsigned char x, unsigned char y); 
# 81
static inline char3 make_char3(signed char x, signed char y, signed char z); 
# 83
static inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z); 
# 85
static inline char4 make_char4(signed char x, signed char y, signed char z, signed char w); 
# 87
static inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w); 
# 89
static inline short1 make_short1(short x); 
# 91
static inline ushort1 make_ushort1(unsigned short x); 
# 93
static inline short2 make_short2(short x, short y); 
# 95
static inline ushort2 make_ushort2(unsigned short x, unsigned short y); 
# 97
static inline short3 make_short3(short x, short y, short z); 
# 99
static inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z); 
# 101
static inline short4 make_short4(short x, short y, short z, short w); 
# 103
static inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w); 
# 105
static inline int1 make_int1(int x); 
# 107
static inline uint1 make_uint1(unsigned x); 
# 109
static inline int2 make_int2(int x, int y); 
# 111
static inline uint2 make_uint2(unsigned x, unsigned y); 
# 113
static inline int3 make_int3(int x, int y, int z); 
# 115
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z); 
# 117
static inline int4 make_int4(int x, int y, int z, int w); 
# 119
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w); 
# 121
static inline long1 make_long1(long x); 
# 123
static inline ulong1 make_ulong1(unsigned long x); 
# 125
static inline long2 make_long2(long x, long y); 
# 127
static inline ulong2 make_ulong2(unsigned long x, unsigned long y); 
# 129
static inline long3 make_long3(long x, long y, long z); 
# 131
static inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z); 
# 133
static inline long4 make_long4(long x, long y, long z, long w); 
# 135
static inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w); 
# 137
static inline float1 make_float1(float x); 
# 139
static inline float2 make_float2(float x, float y); 
# 141
static inline float3 make_float3(float x, float y, float z); 
# 143
static inline float4 make_float4(float x, float y, float z, float w); 
# 145
static inline longlong1 make_longlong1(long long x); 
# 147
static inline ulonglong1 make_ulonglong1(unsigned long long x); 
# 149
static inline longlong2 make_longlong2(long long x, long long y); 
# 151
static inline ulonglong2 make_ulonglong2(unsigned long long x, unsigned long long y); 
# 153
static inline longlong3 make_longlong3(long long x, long long y, long long z); 
# 155
static inline ulonglong3 make_ulonglong3(unsigned long long x, unsigned long long y, unsigned long long z); 
# 157
static inline longlong4 make_longlong4(long long x, long long y, long long z, long long w); 
# 159
static inline ulonglong4 make_ulonglong4(unsigned long long x, unsigned long long y, unsigned long long z, unsigned long long w); 
# 161
static inline double1 make_double1(double x); 
# 163
static inline double2 make_double2(double x, double y); 
# 165
static inline double3 make_double3(double x, double y, double z); 
# 167
static inline double4 make_double4(double x, double y, double z, double w); 
# 73 "/usr/local/cuda/bin/../targets/x86_64-linux/include/vector_functions.hpp"
static inline char1 make_char1(signed char x) 
# 74
{ 
# 75
char1 t; (t.x) = x; return t; 
# 76
} 
# 78
static inline uchar1 make_uchar1(unsigned char x) 
# 79
{ 
# 80
uchar1 t; (t.x) = x; return t; 
# 81
} 
# 83
static inline char2 make_char2(signed char x, signed char y) 
# 84
{ 
# 85
char2 t; (t.x) = x; (t.y) = y; return t; 
# 86
} 
# 88
static inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
# 89
{ 
# 90
uchar2 t; (t.x) = x; (t.y) = y; return t; 
# 91
} 
# 93
static inline char3 make_char3(signed char x, signed char y, signed char z) 
# 94
{ 
# 95
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 96
} 
# 98
static inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
# 99
{ 
# 100
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 101
} 
# 103
static inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
# 104
{ 
# 105
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 106
} 
# 108
static inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
# 109
{ 
# 110
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 111
} 
# 113
static inline short1 make_short1(short x) 
# 114
{ 
# 115
short1 t; (t.x) = x; return t; 
# 116
} 
# 118
static inline ushort1 make_ushort1(unsigned short x) 
# 119
{ 
# 120
ushort1 t; (t.x) = x; return t; 
# 121
} 
# 123
static inline short2 make_short2(short x, short y) 
# 124
{ 
# 125
short2 t; (t.x) = x; (t.y) = y; return t; 
# 126
} 
# 128
static inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
# 129
{ 
# 130
ushort2 t; (t.x) = x; (t.y) = y; return t; 
# 131
} 
# 133
static inline short3 make_short3(short x, short y, short z) 
# 134
{ 
# 135
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 136
} 
# 138
static inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
# 139
{ 
# 140
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 141
} 
# 143
static inline short4 make_short4(short x, short y, short z, short w) 
# 144
{ 
# 145
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 146
} 
# 148
static inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
# 149
{ 
# 150
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 151
} 
# 153
static inline int1 make_int1(int x) 
# 154
{ 
# 155
int1 t; (t.x) = x; return t; 
# 156
} 
# 158
static inline uint1 make_uint1(unsigned x) 
# 159
{ 
# 160
uint1 t; (t.x) = x; return t; 
# 161
} 
# 163
static inline int2 make_int2(int x, int y) 
# 164
{ 
# 165
int2 t; (t.x) = x; (t.y) = y; return t; 
# 166
} 
# 168
static inline uint2 make_uint2(unsigned x, unsigned y) 
# 169
{ 
# 170
uint2 t; (t.x) = x; (t.y) = y; return t; 
# 171
} 
# 173
static inline int3 make_int3(int x, int y, int z) 
# 174
{ 
# 175
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 176
} 
# 178
static inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
# 179
{ 
# 180
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 181
} 
# 183
static inline int4 make_int4(int x, int y, int z, int w) 
# 184
{ 
# 185
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 186
} 
# 188
static inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
# 189
{ 
# 190
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 191
} 
# 193
static inline long1 make_long1(long x) 
# 194
{ 
# 195
long1 t; (t.x) = x; return t; 
# 196
} 
# 198
static inline ulong1 make_ulong1(unsigned long x) 
# 199
{ 
# 200
ulong1 t; (t.x) = x; return t; 
# 201
} 
# 203
static inline long2 make_long2(long x, long y) 
# 204
{ 
# 205
long2 t; (t.x) = x; (t.y) = y; return t; 
# 206
} 
# 208
static inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
# 209
{ 
# 210
ulong2 t; (t.x) = x; (t.y) = y; return t; 
# 211
} 
# 213
static inline long3 make_long3(long x, long y, long z) 
# 214
{ 
# 215
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 216
} 
# 218
static inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
# 219
{ 
# 220
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 221
} 
# 223
static inline long4 make_long4(long x, long y, long z, long w) 
# 224
{ 
# 225
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 226
} 
# 228
static inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
# 229
{ 
# 230
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 231
} 
# 233
static inline float1 make_float1(float x) 
# 234
{ 
# 235
float1 t; (t.x) = x; return t; 
# 236
} 
# 238
static inline float2 make_float2(float x, float y) 
# 239
{ 
# 240
float2 t; (t.x) = x; (t.y) = y; return t; 
# 241
} 
# 243
static inline float3 make_float3(float x, float y, float z) 
# 244
{ 
# 245
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 246
} 
# 248
static inline float4 make_float4(float x, float y, float z, float w) 
# 249
{ 
# 250
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 251
} 
# 253
static inline longlong1 make_longlong1(long long x) 
# 254
{ 
# 255
longlong1 t; (t.x) = x; return t; 
# 256
} 
# 258
static inline ulonglong1 make_ulonglong1(unsigned long long x) 
# 259
{ 
# 260
ulonglong1 t; (t.x) = x; return t; 
# 261
} 
# 263
static inline longlong2 make_longlong2(long long x, long long y) 
# 264
{ 
# 265
longlong2 t; (t.x) = x; (t.y) = y; return t; 
# 266
} 
# 268
static inline ulonglong2 make_ulonglong2(unsigned long long x, unsigned long long y) 
# 269
{ 
# 270
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
# 271
} 
# 273
static inline longlong3 make_longlong3(long long x, long long y, long long z) 
# 274
{ 
# 275
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 276
} 
# 278
static inline ulonglong3 make_ulonglong3(unsigned long long x, unsigned long long y, unsigned long long z) 
# 279
{ 
# 280
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 281
} 
# 283
static inline longlong4 make_longlong4(long long x, long long y, long long z, long long w) 
# 284
{ 
# 285
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 286
} 
# 288
static inline ulonglong4 make_ulonglong4(unsigned long long x, unsigned long long y, unsigned long long z, unsigned long long w) 
# 289
{ 
# 290
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 291
} 
# 293
static inline double1 make_double1(double x) 
# 294
{ 
# 295
double1 t; (t.x) = x; return t; 
# 296
} 
# 298
static inline double2 make_double2(double x, double y) 
# 299
{ 
# 300
double2 t; (t.x) = x; (t.y) = y; return t; 
# 301
} 
# 303
static inline double3 make_double3(double x, double y, double z) 
# 304
{ 
# 305
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
# 306
} 
# 308
static inline double4 make_double4(double x, double y, double z, double w) 
# 309
{ 
# 310
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
# 311
} 
# 28 "/usr/include/string.h" 3
extern "C" {
# 43 "/usr/include/string.h" 3
extern void *memcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 44
 __attribute((__nonnull__(1, 2))); 
# 47
extern void *memmove(void * __dest, const void * __src, size_t __n) throw()
# 48
 __attribute((__nonnull__(1, 2))); 
# 54
extern void *memccpy(void *__restrict__ __dest, const void *__restrict__ __src, int __c, size_t __n) throw()
# 56
 __attribute((__nonnull__(1, 2))); 
# 61
extern void *memset(void * __s, int __c, size_t __n) throw() __attribute((__nonnull__(1))); 
# 64
extern int memcmp(const void * __s1, const void * __s2, size_t __n) throw()
# 65
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 69
extern "C++" {
# 71
extern void *memchr(void * __s, int __c, size_t __n) throw() __asm__("memchr")
# 72
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 73
extern const void *memchr(const void * __s, int __c, size_t __n) throw() __asm__("memchr")
# 74
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 89 "/usr/include/string.h" 3
}
# 99 "/usr/include/string.h" 3
extern "C++" void *rawmemchr(void * __s, int __c) throw() __asm__("rawmemchr")
# 100
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 101
extern "C++" const void *rawmemchr(const void * __s, int __c) throw() __asm__("rawmemchr")
# 102
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 110
extern "C++" void *memrchr(void * __s, int __c, size_t __n) throw() __asm__("memrchr")
# 111
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 112
extern "C++" const void *memrchr(const void * __s, int __c, size_t __n) throw() __asm__("memrchr")
# 113
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 122 "/usr/include/string.h" 3
extern char *strcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 123
 __attribute((__nonnull__(1, 2))); 
# 125
extern char *strncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 127
 __attribute((__nonnull__(1, 2))); 
# 130
extern char *strcat(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 131
 __attribute((__nonnull__(1, 2))); 
# 133
extern char *strncat(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 134
 __attribute((__nonnull__(1, 2))); 
# 137
extern int strcmp(const char * __s1, const char * __s2) throw()
# 138
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 140
extern int strncmp(const char * __s1, const char * __s2, size_t __n) throw()
# 141
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 144
extern int strcoll(const char * __s1, const char * __s2) throw()
# 145
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 147
extern size_t strxfrm(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 149
 __attribute((__nonnull__(2))); 
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3
struct __locale_struct { 
# 31
struct __locale_data *__locales[13]; 
# 34
const unsigned short *__ctype_b; 
# 35
const int *__ctype_tolower; 
# 36
const int *__ctype_toupper; 
# 39
const char *__names[13]; 
# 40
}; 
# 42
typedef __locale_struct *__locale_t; 
# 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3
typedef __locale_t locale_t; 
# 156 "/usr/include/string.h" 3
extern int strcoll_l(const char * __s1, const char * __s2, locale_t __l) throw()
# 157
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 160
extern size_t strxfrm_l(char * __dest, const char * __src, size_t __n, locale_t __l) throw()
# 161
 __attribute((__nonnull__(2, 4))); 
# 167
extern char *strdup(const char * __s) throw()
# 168
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 175
extern char *strndup(const char * __string, size_t __n) throw()
# 176
 __attribute((__malloc__)) __attribute((__nonnull__(1))); 
# 204 "/usr/include/string.h" 3
extern "C++" {
# 206
extern char *strchr(char * __s, int __c) throw() __asm__("strchr")
# 207
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 208
extern const char *strchr(const char * __s, int __c) throw() __asm__("strchr")
# 209
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 224 "/usr/include/string.h" 3
}
# 231
extern "C++" {
# 233
extern char *strrchr(char * __s, int __c) throw() __asm__("strrchr")
# 234
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 235
extern const char *strrchr(const char * __s, int __c) throw() __asm__("strrchr")
# 236
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 251 "/usr/include/string.h" 3
}
# 261 "/usr/include/string.h" 3
extern "C++" char *strchrnul(char * __s, int __c) throw() __asm__("strchrnul")
# 262
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 263
extern "C++" const char *strchrnul(const char * __s, int __c) throw() __asm__("strchrnul")
# 264
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 273 "/usr/include/string.h" 3
extern size_t strcspn(const char * __s, const char * __reject) throw()
# 274
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 277
extern size_t strspn(const char * __s, const char * __accept) throw()
# 278
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 281
extern "C++" {
# 283
extern char *strpbrk(char * __s, const char * __accept) throw() __asm__("strpbrk")
# 284
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 285
extern const char *strpbrk(const char * __s, const char * __accept) throw() __asm__("strpbrk")
# 286
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 301 "/usr/include/string.h" 3
}
# 308
extern "C++" {
# 310
extern char *strstr(char * __haystack, const char * __needle) throw() __asm__("strstr")
# 311
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 312
extern const char *strstr(const char * __haystack, const char * __needle) throw() __asm__("strstr")
# 313
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 328 "/usr/include/string.h" 3
}
# 336
extern char *strtok(char *__restrict__ __s, const char *__restrict__ __delim) throw()
# 337
 __attribute((__nonnull__(2))); 
# 341
extern char *__strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char **__restrict__ __save_ptr) throw()
# 344
 __attribute((__nonnull__(2, 3))); 
# 346
extern char *strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char **__restrict__ __save_ptr) throw()
# 348
 __attribute((__nonnull__(2, 3))); 
# 354
extern "C++" char *strcasestr(char * __haystack, const char * __needle) throw() __asm__("strcasestr")
# 355
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 356
extern "C++" const char *strcasestr(const char * __haystack, const char * __needle) throw() __asm__("strcasestr")
# 358
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 369 "/usr/include/string.h" 3
extern void *memmem(const void * __haystack, size_t __haystacklen, const void * __needle, size_t __needlelen) throw()
# 371
 __attribute((__pure__)) __attribute((__nonnull__(1, 3))); 
# 375
extern void *__mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 377
 __attribute((__nonnull__(1, 2))); 
# 378
extern void *mempcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t __n) throw()
# 380
 __attribute((__nonnull__(1, 2))); 
# 385
extern size_t strlen(const char * __s) throw()
# 386
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 391
extern size_t strnlen(const char * __string, size_t __maxlen) throw()
# 392
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 397
extern char *strerror(int __errnum) throw(); 
# 421 "/usr/include/string.h" 3
extern char *strerror_r(int __errnum, char * __buf, size_t __buflen) throw()
# 422
 __attribute((__nonnull__(2))); 
# 428
extern char *strerror_l(int __errnum, locale_t __l) throw(); 
# 30 "/usr/include/strings.h" 3
extern "C" {
# 34
extern int bcmp(const void * __s1, const void * __s2, size_t __n) throw()
# 35
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 38
extern void bcopy(const void * __src, void * __dest, size_t __n) throw()
# 39
 __attribute((__nonnull__(1, 2))); 
# 42
extern void bzero(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 46
extern "C++" {
# 48
extern char *index(char * __s, int __c) throw() __asm__("index")
# 49
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 50
extern const char *index(const char * __s, int __c) throw() __asm__("index")
# 51
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 66 "/usr/include/strings.h" 3
}
# 74
extern "C++" {
# 76
extern char *rindex(char * __s, int __c) throw() __asm__("rindex")
# 77
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 78
extern const char *rindex(const char * __s, int __c) throw() __asm__("rindex")
# 79
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 94 "/usr/include/strings.h" 3
}
# 104 "/usr/include/strings.h" 3
extern int ffs(int __i) throw() __attribute((const)); 
# 110
extern int ffsl(long __l) throw() __attribute((const)); 
# 111
__extension__ extern int ffsll(long long __ll) throw()
# 112
 __attribute((const)); 
# 116
extern int strcasecmp(const char * __s1, const char * __s2) throw()
# 117
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 120
extern int strncasecmp(const char * __s1, const char * __s2, size_t __n) throw()
# 121
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 128
extern int strcasecmp_l(const char * __s1, const char * __s2, locale_t __loc) throw()
# 129
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 3))); 
# 133
extern int strncasecmp_l(const char * __s1, const char * __s2, size_t __n, locale_t __loc) throw()
# 135
 __attribute((__pure__)) __attribute((__nonnull__(1, 2, 4))); 
# 138
}
# 436 "/usr/include/string.h" 3
extern void explicit_bzero(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 440
extern char *strsep(char **__restrict__ __stringp, const char *__restrict__ __delim) throw()
# 442
 __attribute((__nonnull__(1, 2))); 
# 447
extern char *strsignal(int __sig) throw(); 
# 450
extern char *__stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 451
 __attribute((__nonnull__(1, 2))); 
# 452
extern char *stpcpy(char *__restrict__ __dest, const char *__restrict__ __src) throw()
# 453
 __attribute((__nonnull__(1, 2))); 
# 457
extern char *__stpncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 459
 __attribute((__nonnull__(1, 2))); 
# 460
extern char *stpncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t __n) throw()
# 462
 __attribute((__nonnull__(1, 2))); 
# 467
extern int strverscmp(const char * __s1, const char * __s2) throw()
# 468
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 471
extern char *strfry(char * __string) throw() __attribute((__nonnull__(1))); 
# 474
extern void *memfrob(void * __s, size_t __n) throw() __attribute((__nonnull__(1))); 
# 482
extern "C++" char *basename(char * __filename) throw() __asm__("basename")
# 483
 __attribute((__nonnull__(1))); 
# 484
extern "C++" const char *basename(const char * __filename) throw() __asm__("basename")
# 485
 __attribute((__nonnull__(1))); 
# 499 "/usr/include/string.h" 3
}
# 31 "/usr/include/x86_64-linux-gnu/bits/types.h" 3
typedef unsigned char __u_char; 
# 32
typedef unsigned short __u_short; 
# 33
typedef unsigned __u_int; 
# 34
typedef unsigned long __u_long; 
# 37
typedef signed char __int8_t; 
# 38
typedef unsigned char __uint8_t; 
# 39
typedef signed short __int16_t; 
# 40
typedef unsigned short __uint16_t; 
# 41
typedef signed int __int32_t; 
# 42
typedef unsigned __uint32_t; 
# 44
typedef signed long __int64_t; 
# 45
typedef unsigned long __uint64_t; 
# 52
typedef __int8_t __int_least8_t; 
# 53
typedef __uint8_t __uint_least8_t; 
# 54
typedef __int16_t __int_least16_t; 
# 55
typedef __uint16_t __uint_least16_t; 
# 56
typedef __int32_t __int_least32_t; 
# 57
typedef __uint32_t __uint_least32_t; 
# 58
typedef __int64_t __int_least64_t; 
# 59
typedef __uint64_t __uint_least64_t; 
# 63
typedef long __quad_t; 
# 64
typedef unsigned long __u_quad_t; 
# 72
typedef long __intmax_t; 
# 73
typedef unsigned long __uintmax_t; 
# 145 "/usr/include/x86_64-linux-gnu/bits/types.h" 3
typedef unsigned long __dev_t; 
# 146
typedef unsigned __uid_t; 
# 147
typedef unsigned __gid_t; 
# 148
typedef unsigned long __ino_t; 
# 149
typedef unsigned long __ino64_t; 
# 150
typedef unsigned __mode_t; 
# 151
typedef unsigned long __nlink_t; 
# 152
typedef long __off_t; 
# 153
typedef long __off64_t; 
# 154
typedef int __pid_t; 
# 155
typedef struct { int __val[2]; } __fsid_t; 
# 156
typedef long __clock_t; 
# 157
typedef unsigned long __rlim_t; 
# 158
typedef unsigned long __rlim64_t; 
# 159
typedef unsigned __id_t; 
# 160
typedef long __time_t; 
# 161
typedef unsigned __useconds_t; 
# 162
typedef long __suseconds_t; 
# 164
typedef int __daddr_t; 
# 165
typedef int __key_t; 
# 168
typedef int __clockid_t; 
# 171
typedef void *__timer_t; 
# 174
typedef long __blksize_t; 
# 179
typedef long __blkcnt_t; 
# 180
typedef long __blkcnt64_t; 
# 183
typedef unsigned long __fsblkcnt_t; 
# 184
typedef unsigned long __fsblkcnt64_t; 
# 187
typedef unsigned long __fsfilcnt_t; 
# 188
typedef unsigned long __fsfilcnt64_t; 
# 191
typedef long __fsword_t; 
# 193
typedef long __ssize_t; 
# 196
typedef long __syscall_slong_t; 
# 198
typedef unsigned long __syscall_ulong_t; 
# 202
typedef __off64_t __loff_t; 
# 203
typedef char *__caddr_t; 
# 206
typedef long __intptr_t; 
# 209
typedef unsigned __socklen_t; 
# 214
typedef int __sig_atomic_t; 
# 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 3
struct timeval { 
# 10
__time_t tv_sec; 
# 11
__suseconds_t tv_usec; 
# 12
}; 
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3
struct timex { 
# 28
unsigned modes; 
# 29
__syscall_slong_t offset; 
# 30
__syscall_slong_t freq; 
# 31
__syscall_slong_t maxerror; 
# 32
__syscall_slong_t esterror; 
# 33
int status; 
# 34
__syscall_slong_t constant; 
# 35
__syscall_slong_t precision; 
# 36
__syscall_slong_t tolerance; 
# 37
timeval time; 
# 38
__syscall_slong_t tick; 
# 39
__syscall_slong_t ppsfreq; 
# 40
__syscall_slong_t jitter; 
# 41
int shift; 
# 42
__syscall_slong_t stabil; 
# 43
__syscall_slong_t jitcnt; 
# 44
__syscall_slong_t calcnt; 
# 45
__syscall_slong_t errcnt; 
# 46
__syscall_slong_t stbcnt; 
# 48
int tai; 
# 51
int:32; int:32; int:32; int:32; 
# 52
int:32; int:32; int:32; int:32; 
# 53
int:32; int:32; int:32; 
# 54
}; 
# 75 "/usr/include/x86_64-linux-gnu/bits/time.h" 3
extern "C" {
# 78
extern int clock_adjtime(__clockid_t __clock_id, timex * __utx) throw(); 
# 80
}
# 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 3
typedef __clock_t clock_t; 
# 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3
typedef __time_t time_t; 
# 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 3
struct tm { 
# 9
int tm_sec; 
# 10
int tm_min; 
# 11
int tm_hour; 
# 12
int tm_mday; 
# 13
int tm_mon; 
# 14
int tm_year; 
# 15
int tm_wday; 
# 16
int tm_yday; 
# 17
int tm_isdst; 
# 20
long tm_gmtoff; 
# 21
const char *tm_zone; 
# 26
}; 
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3
struct timespec { 
# 12
__time_t tv_sec; 
# 16
__syscall_slong_t tv_nsec; 
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3
}; 
# 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 3
typedef __clockid_t clockid_t; 
# 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 3
typedef __timer_t timer_t; 
# 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 3
struct itimerspec { 
# 10
timespec it_interval; 
# 11
timespec it_value; 
# 12
}; 
# 49 "/usr/include/time.h" 3
struct sigevent; 
# 54
typedef __pid_t pid_t; 
# 68 "/usr/include/time.h" 3
extern "C" {
# 72
extern clock_t clock() throw(); 
# 75
extern time_t time(time_t * __timer) throw(); 
# 78
extern double difftime(time_t __time1, time_t __time0) throw()
# 79
 __attribute((const)); 
# 82
extern time_t mktime(tm * __tp) throw(); 
# 88
extern size_t strftime(char *__restrict__ __s, size_t __maxsize, const char *__restrict__ __format, const tm *__restrict__ __tp) throw(); 
# 95
extern char *strptime(const char *__restrict__ __s, const char *__restrict__ __fmt, tm * __tp) throw(); 
# 104
extern size_t strftime_l(char *__restrict__ __s, size_t __maxsize, const char *__restrict__ __format, const tm *__restrict__ __tp, locale_t __loc) throw(); 
# 111
extern char *strptime_l(const char *__restrict__ __s, const char *__restrict__ __fmt, tm * __tp, locale_t __loc) throw(); 
# 119
extern tm *gmtime(const time_t * __timer) throw(); 
# 123
extern tm *localtime(const time_t * __timer) throw(); 
# 128
extern tm *gmtime_r(const time_t *__restrict__ __timer, tm *__restrict__ __tp) throw(); 
# 133
extern tm *localtime_r(const time_t *__restrict__ __timer, tm *__restrict__ __tp) throw(); 
# 139
extern char *asctime(const tm * __tp) throw(); 
# 142
extern char *ctime(const time_t * __timer) throw(); 
# 149
extern char *asctime_r(const tm *__restrict__ __tp, char *__restrict__ __buf) throw(); 
# 153
extern char *ctime_r(const time_t *__restrict__ __timer, char *__restrict__ __buf) throw(); 
# 159
extern char *__tzname[2]; 
# 160
extern int __daylight; 
# 161
extern long __timezone; 
# 166
extern char *tzname[2]; 
# 170
extern void tzset() throw(); 
# 174
extern int daylight; 
# 175
extern long timezone; 
# 190 "/usr/include/time.h" 3
extern time_t timegm(tm * __tp) throw(); 
# 193
extern time_t timelocal(tm * __tp) throw(); 
# 196
extern int dysize(int __year) throw() __attribute((const)); 
# 205 "/usr/include/time.h" 3
extern int nanosleep(const timespec * __requested_time, timespec * __remaining); 
# 210
extern int clock_getres(clockid_t __clock_id, timespec * __res) throw(); 
# 213
extern int clock_gettime(clockid_t __clock_id, timespec * __tp) throw(); 
# 216
extern int clock_settime(clockid_t __clock_id, const timespec * __tp) throw(); 
# 224
extern int clock_nanosleep(clockid_t __clock_id, int __flags, const timespec * __req, timespec * __rem); 
# 229
extern int clock_getcpuclockid(pid_t __pid, clockid_t * __clock_id) throw(); 
# 234
extern int timer_create(clockid_t __clock_id, sigevent *__restrict__ __evp, timer_t *__restrict__ __timerid) throw(); 
# 239
extern int timer_delete(timer_t __timerid) throw(); 
# 242
extern int timer_settime(timer_t __timerid, int __flags, const itimerspec *__restrict__ __value, itimerspec *__restrict__ __ovalue) throw(); 
# 247
extern int timer_gettime(timer_t __timerid, itimerspec * __value) throw(); 
# 251
extern int timer_getoverrun(timer_t __timerid) throw(); 
# 257
extern int timespec_get(timespec * __ts, int __base) throw()
# 258
 __attribute((__nonnull__(1))); 
# 274 "/usr/include/time.h" 3
extern int getdate_err; 
# 283 "/usr/include/time.h" 3
extern tm *getdate(const char * __string); 
# 297 "/usr/include/time.h" 3
extern int getdate_r(const char *__restrict__ __string, tm *__restrict__ __resbufp); 
# 301
}
# 88 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/common_functions.h"
extern "C" {
# 91
extern clock_t clock() throw(); 
# 96 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/common_functions.h"
extern void *memset(void *, int, size_t) throw(); 
# 97 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/common_functions.h"
extern void *memcpy(void *, const void *, size_t) throw(); 
# 99 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/common_functions.h"
}
# 115 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern "C" {
# 213 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int abs(int a) throw(); 
# 221 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long labs(long a) throw(); 
# 229 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long long llabs(long long a) throw(); 
# 279 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double fabs(double x) throw(); 
# 320 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float fabsf(float x) throw(); 
# 330 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern inline int min(const int a, const int b); 
# 337
extern inline unsigned umin(const unsigned a, const unsigned b); 
# 344
extern inline long long llmin(const long long a, const long long b); 
# 351
extern inline unsigned long long ullmin(const unsigned long long a, const unsigned long long b); 
# 372 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float fminf(float x, float y) throw(); 
# 392 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double fmin(double x, double y) throw(); 
# 405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern inline int max(const int a, const int b); 
# 413
extern inline unsigned umax(const unsigned a, const unsigned b); 
# 420
extern inline long long llmax(const long long a, const long long b); 
# 427
extern inline unsigned long long ullmax(const unsigned long long a, const unsigned long long b); 
# 448 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float fmaxf(float x, float y) throw(); 
# 468 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double fmax(double, double) throw(); 
# 512 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double sin(double x) throw(); 
# 545 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double cos(double x) throw(); 
# 564 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern void sincos(double x, double * sptr, double * cptr) throw(); 
# 580 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern void sincosf(float x, float * sptr, float * cptr) throw(); 
# 625 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double tan(double x) throw(); 
# 694 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double sqrt(double x) throw(); 
# 766 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double rsqrt(double x); 
# 836 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float rsqrtf(float x); 
# 892 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double log2(double x) throw(); 
# 917 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double exp2(double x) throw(); 
# 942 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float exp2f(float x) throw(); 
# 969 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double exp10(double x) throw(); 
# 992 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float exp10f(float x) throw(); 
# 1038 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double expm1(double x) throw(); 
# 1083 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float expm1f(float x) throw(); 
# 1139 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float log2f(float x) throw(); 
# 1193 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double log10(double x) throw(); 
# 1264 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double log(double x) throw(); 
# 1367 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double log1p(double x) throw(); 
# 1473 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float log1pf(float x) throw(); 
# 1537 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double floor(double x) throw(); 
# 1576 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double exp(double x) throw(); 
# 1607 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double cosh(double x) throw(); 
# 1657 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double sinh(double x) throw(); 
# 1687 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double tanh(double x) throw(); 
# 1722 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double acosh(double x) throw(); 
# 1760 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float acoshf(float x) throw(); 
# 1813 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double asinh(double x) throw(); 
# 1865 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float asinhf(float x) throw(); 
# 1919 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double atanh(double x) throw(); 
# 1973 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float atanhf(float x) throw(); 
# 2032 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double ldexp(double x, int exp) throw(); 
# 2088 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float ldexpf(float x, int exp) throw(); 
# 2140 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double logb(double x) throw(); 
# 2195 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float logbf(float x) throw(); 
# 2226 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int ilogb(double x) throw(); 
# 2257 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int ilogbf(float x) throw(); 
# 2333 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double scalbn(double x, int n) throw(); 
# 2409 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float scalbnf(float x, int n) throw(); 
# 2485 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double scalbln(double x, long n) throw(); 
# 2561 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float scalblnf(float x, long n) throw(); 
# 2639 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double frexp(double x, int * nptr) throw(); 
# 2714 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float frexpf(float x, int * nptr) throw(); 
# 2728 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double round(double x) throw(); 
# 2745 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float roundf(float x) throw(); 
# 2763 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long lround(double x) throw(); 
# 2781 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long lroundf(float x) throw(); 
# 2799 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long long llround(double x) throw(); 
# 2817 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long long llroundf(float x) throw(); 
# 2869 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float rintf(float x) throw(); 
# 2886 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long lrint(double x) throw(); 
# 2903 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long lrintf(float x) throw(); 
# 2920 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long long llrint(double x) throw(); 
# 2937 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern long long llrintf(float x) throw(); 
# 2990 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double nearbyint(double x) throw(); 
# 3043 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float nearbyintf(float x) throw(); 
# 3105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double ceil(double x) throw(); 
# 3117 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double trunc(double x) throw(); 
# 3132 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float truncf(float x) throw(); 
# 3158 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double fdim(double x, double y) throw(); 
# 3184 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float fdimf(float x, float y) throw(); 
# 3220 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double atan2(double y, double x) throw(); 
# 3251 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double atan(double x) throw(); 
# 3274 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double acos(double x) throw(); 
# 3306 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double asin(double x) throw(); 
# 3352 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double hypot(double x, double y) throw(); 
# 3450 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float hypotf(float x, float y) throw(); 
# 4182 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double cbrt(double x) throw(); 
# 4268 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float cbrtf(float x) throw(); 
# 4323 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double rcbrt(double x); 
# 4373 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float rcbrtf(float x); 
# 4433 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double sinpi(double x); 
# 4493 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float sinpif(float x); 
# 4545 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double cospi(double x); 
# 4597 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float cospif(float x); 
# 4627 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern void sincospi(double x, double * sptr, double * cptr); 
# 4657 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern void sincospif(float x, float * sptr, float * cptr); 
# 4990 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double pow(double x, double y) throw(); 
# 5046 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double modf(double x, double * iptr) throw(); 
# 5105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double fmod(double x, double y) throw(); 
# 5191 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double remainder(double x, double y) throw(); 
# 5281 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float remainderf(float x, float y) throw(); 
# 5335 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double remquo(double x, double y, int * quo) throw(); 
# 5389 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float remquof(float x, float y, int * quo) throw(); 
# 5430 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double j0(double x) throw(); 
# 5472 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float j0f(float x) throw(); 
# 5541 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double j1(double x) throw(); 
# 5610 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float j1f(float x) throw(); 
# 5653 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double jn(int n, double x) throw(); 
# 5696 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float jnf(int n, float x) throw(); 
# 5748 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double y0(double x) throw(); 
# 5800 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float y0f(float x) throw(); 
# 5852 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double y1(double x) throw(); 
# 5904 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float y1f(float x) throw(); 
# 5957 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double yn(int n, double x) throw(); 
# 6010 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float ynf(int n, float x) throw(); 
# 6199 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double erf(double x) throw(); 
# 6281 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float erff(float x) throw(); 
# 6345 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double erfinv(double y); 
# 6402 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float erfinvf(float y); 
# 6441 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double erfc(double x) throw(); 
# 6479 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float erfcf(float x) throw(); 
# 6606 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double lgamma(double x) throw(); 
# 6669 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double erfcinv(double y); 
# 6725 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float erfcinvf(float y); 
# 6783 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double normcdfinv(double y); 
# 6841 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float normcdfinvf(float y); 
# 6884 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double normcdf(double y); 
# 6927 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float normcdff(float y); 
# 7002 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double erfcx(double x); 
# 7077 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float erfcxf(float x); 
# 7210 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float lgammaf(float x) throw(); 
# 7319 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double tgamma(double x) throw(); 
# 7428 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float tgammaf(float x) throw(); 
# 7441 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double copysign(double x, double y) throw(); 
# 7454 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float copysignf(float x, float y) throw(); 
# 7473 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double nextafter(double x, double y) throw(); 
# 7492 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float nextafterf(float x, float y) throw(); 
# 7508 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double nan(const char * tagp) throw(); 
# 7524 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float nanf(const char * tagp) throw(); 
# 7531 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __isinff(float) throw(); 
# 7532 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __isnanf(float) throw(); 
# 7542 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __finite(double) throw(); 
# 7543 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __finitef(float) throw(); 
# 7544 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __signbit(double) throw(); 
# 7545 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __isnan(double) throw(); 
# 7546 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __isinf(double) throw(); 
# 7549 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __signbitf(float) throw(); 
# 7708 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern double fma(double x, double y, double z) throw(); 
# 7866 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float fmaf(float x, float y, float z) throw(); 
# 7877 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __signbitl(long double) throw(); 
# 7883 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __finitel(long double) throw(); 
# 7884 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __isinfl(long double) throw(); 
# 7885 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern int __isnanl(long double) throw(); 
# 7935 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float acosf(float x) throw(); 
# 7975 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float asinf(float x) throw(); 
# 8015 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float atanf(float x) throw(); 
# 8048 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float atan2f(float y, float x) throw(); 
# 8072 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float cosf(float x) throw(); 
# 8114 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float sinf(float x) throw(); 
# 8156 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float tanf(float x) throw(); 
# 8187 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float coshf(float x) throw(); 
# 8237 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float sinhf(float x) throw(); 
# 8267 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float tanhf(float x) throw(); 
# 8319 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float logf(float x) throw(); 
# 8369 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float expf(float x) throw(); 
# 8421 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float log10f(float x) throw(); 
# 8476 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float modff(float x, float * iptr) throw(); 
# 8806 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float powf(float x, float y) throw(); 
# 8875 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float sqrtf(float x) throw(); 
# 8934 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float ceilf(float x) throw(); 
# 8995 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float floorf(float x) throw(); 
# 9053 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern float fmodf(float x, float y) throw(); 
# 9068 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
}
# 256 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3
namespace std { 
# 258
typedef unsigned long size_t; 
# 259
typedef long ptrdiff_t; 
# 262
typedef __decltype((nullptr)) nullptr_t; 
# 264
}
# 278 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h" 3
namespace std { 
# 280
inline namespace __cxx11 __attribute((__abi_tag__("cxx11"))) { }
# 281
}
# 282
namespace __gnu_cxx { 
# 284
inline namespace __cxx11 __attribute((__abi_tag__("cxx11"))) { }
# 285
}
# 67 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
extern "C++" {
# 69
namespace std __attribute((__visibility__("default"))) { 
# 73
struct __true_type { }; 
# 74
struct __false_type { }; 
# 76
template< bool > 
# 77
struct __truth_type { 
# 78
typedef __false_type __type; }; 
# 81
template<> struct __truth_type< true>  { 
# 82
typedef __true_type __type; }; 
# 86
template< class _Sp, class _Tp> 
# 87
struct __traitor { 
# 89
enum { __value = ((bool)_Sp::__value) || ((bool)_Tp::__value)}; 
# 90
typedef typename __truth_type< __value> ::__type __type; 
# 91
}; 
# 94
template< class , class > 
# 95
struct __are_same { 
# 97
enum { __value}; 
# 98
typedef __false_type __type; 
# 99
}; 
# 101
template< class _Tp> 
# 102
struct __are_same< _Tp, _Tp>  { 
# 104
enum { __value = 1}; 
# 105
typedef __true_type __type; 
# 106
}; 
# 109
template< class _Tp> 
# 110
struct __is_void { 
# 112
enum { __value}; 
# 113
typedef __false_type __type; 
# 114
}; 
# 117
template<> struct __is_void< void>  { 
# 119
enum { __value = 1}; 
# 120
typedef __true_type __type; 
# 121
}; 
# 126
template< class _Tp> 
# 127
struct __is_integer { 
# 129
enum { __value}; 
# 130
typedef __false_type __type; 
# 131
}; 
# 138
template<> struct __is_integer< bool>  { 
# 140
enum { __value = 1}; 
# 141
typedef __true_type __type; 
# 142
}; 
# 145
template<> struct __is_integer< char>  { 
# 147
enum { __value = 1}; 
# 148
typedef __true_type __type; 
# 149
}; 
# 152
template<> struct __is_integer< signed char>  { 
# 154
enum { __value = 1}; 
# 155
typedef __true_type __type; 
# 156
}; 
# 159
template<> struct __is_integer< unsigned char>  { 
# 161
enum { __value = 1}; 
# 162
typedef __true_type __type; 
# 163
}; 
# 167
template<> struct __is_integer< wchar_t>  { 
# 169
enum { __value = 1}; 
# 170
typedef __true_type __type; 
# 171
}; 
# 185 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
template<> struct __is_integer< char16_t>  { 
# 187
enum { __value = 1}; 
# 188
typedef __true_type __type; 
# 189
}; 
# 192
template<> struct __is_integer< char32_t>  { 
# 194
enum { __value = 1}; 
# 195
typedef __true_type __type; 
# 196
}; 
# 200
template<> struct __is_integer< short>  { 
# 202
enum { __value = 1}; 
# 203
typedef __true_type __type; 
# 204
}; 
# 207
template<> struct __is_integer< unsigned short>  { 
# 209
enum { __value = 1}; 
# 210
typedef __true_type __type; 
# 211
}; 
# 214
template<> struct __is_integer< int>  { 
# 216
enum { __value = 1}; 
# 217
typedef __true_type __type; 
# 218
}; 
# 221
template<> struct __is_integer< unsigned>  { 
# 223
enum { __value = 1}; 
# 224
typedef __true_type __type; 
# 225
}; 
# 228
template<> struct __is_integer< long>  { 
# 230
enum { __value = 1}; 
# 231
typedef __true_type __type; 
# 232
}; 
# 235
template<> struct __is_integer< unsigned long>  { 
# 237
enum { __value = 1}; 
# 238
typedef __true_type __type; 
# 239
}; 
# 242
template<> struct __is_integer< long long>  { 
# 244
enum { __value = 1}; 
# 245
typedef __true_type __type; 
# 246
}; 
# 249
template<> struct __is_integer< unsigned long long>  { 
# 251
enum { __value = 1}; 
# 252
typedef __true_type __type; 
# 253
}; 
# 270 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
template<> struct __is_integer< __int128>  { enum { __value = 1}; typedef __true_type __type; }; template<> struct __is_integer< unsigned __int128>  { enum { __value = 1}; typedef __true_type __type; }; 
# 287 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
template< class _Tp> 
# 288
struct __is_floating { 
# 290
enum { __value}; 
# 291
typedef __false_type __type; 
# 292
}; 
# 296
template<> struct __is_floating< float>  { 
# 298
enum { __value = 1}; 
# 299
typedef __true_type __type; 
# 300
}; 
# 303
template<> struct __is_floating< double>  { 
# 305
enum { __value = 1}; 
# 306
typedef __true_type __type; 
# 307
}; 
# 310
template<> struct __is_floating< long double>  { 
# 312
enum { __value = 1}; 
# 313
typedef __true_type __type; 
# 314
}; 
# 319
template< class _Tp> 
# 320
struct __is_pointer { 
# 322
enum { __value}; 
# 323
typedef __false_type __type; 
# 324
}; 
# 326
template< class _Tp> 
# 327
struct __is_pointer< _Tp *>  { 
# 329
enum { __value = 1}; 
# 330
typedef __true_type __type; 
# 331
}; 
# 336
template< class _Tp> 
# 337
struct __is_arithmetic : public __traitor< __is_integer< _Tp> , __is_floating< _Tp> >  { 
# 339
}; 
# 344
template< class _Tp> 
# 345
struct __is_scalar : public __traitor< __is_arithmetic< _Tp> , __is_pointer< _Tp> >  { 
# 347
}; 
# 352
template< class _Tp> 
# 353
struct __is_char { 
# 355
enum { __value}; 
# 356
typedef __false_type __type; 
# 357
}; 
# 360
template<> struct __is_char< char>  { 
# 362
enum { __value = 1}; 
# 363
typedef __true_type __type; 
# 364
}; 
# 368
template<> struct __is_char< wchar_t>  { 
# 370
enum { __value = 1}; 
# 371
typedef __true_type __type; 
# 372
}; 
# 375
template< class _Tp> 
# 376
struct __is_byte { 
# 378
enum { __value}; 
# 379
typedef __false_type __type; 
# 380
}; 
# 383
template<> struct __is_byte< char>  { 
# 385
enum { __value = 1}; 
# 386
typedef __true_type __type; 
# 387
}; 
# 390
template<> struct __is_byte< signed char>  { 
# 392
enum { __value = 1}; 
# 393
typedef __true_type __type; 
# 394
}; 
# 397
template<> struct __is_byte< unsigned char>  { 
# 399
enum { __value = 1}; 
# 400
typedef __true_type __type; 
# 401
}; 
# 417 "/usr/include/c++/9/bits/cpp_type_traits.h" 3
template< class _Tp> 
# 418
struct __is_move_iterator { 
# 420
enum { __value}; 
# 421
typedef __false_type __type; 
# 422
}; 
# 426
template< class _Iterator> inline _Iterator 
# 428
__miter_base(_Iterator __it) 
# 429
{ return __it; } 
# 432
}
# 433
}
# 37 "/usr/include/c++/9/ext/type_traits.h" 3
extern "C++" {
# 39
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 44
template< bool , class > 
# 45
struct __enable_if { 
# 46
}; 
# 48
template< class _Tp> 
# 49
struct __enable_if< true, _Tp>  { 
# 50
typedef _Tp __type; }; 
# 54
template< bool _Cond, class _Iftrue, class _Iffalse> 
# 55
struct __conditional_type { 
# 56
typedef _Iftrue __type; }; 
# 58
template< class _Iftrue, class _Iffalse> 
# 59
struct __conditional_type< false, _Iftrue, _Iffalse>  { 
# 60
typedef _Iffalse __type; }; 
# 64
template< class _Tp> 
# 65
struct __add_unsigned { 
# 68
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 71
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 72
}; 
# 75
template<> struct __add_unsigned< char>  { 
# 76
typedef unsigned char __type; }; 
# 79
template<> struct __add_unsigned< signed char>  { 
# 80
typedef unsigned char __type; }; 
# 83
template<> struct __add_unsigned< short>  { 
# 84
typedef unsigned short __type; }; 
# 87
template<> struct __add_unsigned< int>  { 
# 88
typedef unsigned __type; }; 
# 91
template<> struct __add_unsigned< long>  { 
# 92
typedef unsigned long __type; }; 
# 95
template<> struct __add_unsigned< long long>  { 
# 96
typedef unsigned long long __type; }; 
# 100
template<> struct __add_unsigned< bool> ; 
# 103
template<> struct __add_unsigned< wchar_t> ; 
# 107
template< class _Tp> 
# 108
struct __remove_unsigned { 
# 111
private: typedef __enable_if< std::__is_integer< _Tp> ::__value, _Tp>  __if_type; 
# 114
public: typedef typename __enable_if< std::__is_integer< _Tp> ::__value, _Tp> ::__type __type; 
# 115
}; 
# 118
template<> struct __remove_unsigned< char>  { 
# 119
typedef signed char __type; }; 
# 122
template<> struct __remove_unsigned< unsigned char>  { 
# 123
typedef signed char __type; }; 
# 126
template<> struct __remove_unsigned< unsigned short>  { 
# 127
typedef short __type; }; 
# 130
template<> struct __remove_unsigned< unsigned>  { 
# 131
typedef int __type; }; 
# 134
template<> struct __remove_unsigned< unsigned long>  { 
# 135
typedef long __type; }; 
# 138
template<> struct __remove_unsigned< unsigned long long>  { 
# 139
typedef long long __type; }; 
# 143
template<> struct __remove_unsigned< bool> ; 
# 146
template<> struct __remove_unsigned< wchar_t> ; 
# 150
template< class _Type> inline bool 
# 152
__is_null_pointer(_Type *__ptr) 
# 153
{ return __ptr == 0; } 
# 155
template< class _Type> inline bool 
# 157
__is_null_pointer(_Type) 
# 158
{ return false; } 
# 162
inline bool __is_null_pointer(std::nullptr_t) 
# 163
{ return true; } 
# 167
template< class _Tp, bool  = std::template __is_integer< _Tp> ::__value> 
# 168
struct __promote { 
# 169
typedef double __type; }; 
# 174
template< class _Tp> 
# 175
struct __promote< _Tp, false>  { 
# 176
}; 
# 179
template<> struct __promote< long double>  { 
# 180
typedef long double __type; }; 
# 183
template<> struct __promote< double>  { 
# 184
typedef double __type; }; 
# 187
template<> struct __promote< float>  { 
# 188
typedef float __type; }; 
# 190
template< class _Tp, class _Up, class 
# 191
_Tp2 = typename __promote< _Tp> ::__type, class 
# 192
_Up2 = typename __promote< _Up> ::__type> 
# 193
struct __promote_2 { 
# 195
typedef __typeof__(_Tp2() + _Up2()) __type; 
# 196
}; 
# 198
template< class _Tp, class _Up, class _Vp, class 
# 199
_Tp2 = typename __promote< _Tp> ::__type, class 
# 200
_Up2 = typename __promote< _Up> ::__type, class 
# 201
_Vp2 = typename __promote< _Vp> ::__type> 
# 202
struct __promote_3 { 
# 204
typedef __typeof__((_Tp2() + _Up2()) + _Vp2()) __type; 
# 205
}; 
# 207
template< class _Tp, class _Up, class _Vp, class _Wp, class 
# 208
_Tp2 = typename __promote< _Tp> ::__type, class 
# 209
_Up2 = typename __promote< _Up> ::__type, class 
# 210
_Vp2 = typename __promote< _Vp> ::__type, class 
# 211
_Wp2 = typename __promote< _Wp> ::__type> 
# 212
struct __promote_4 { 
# 214
typedef __typeof__(((_Tp2() + _Up2()) + _Vp2()) + _Wp2()) __type; 
# 215
}; 
# 218
}
# 219
}
# 34 "/usr/include/math.h" 3
extern "C" {
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3
typedef float _Float32; 
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3
typedef double _Float64; 
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3
typedef double _Float32x; 
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3
typedef long double _Float64x; 
# 149 "/usr/include/math.h" 3
typedef float float_t; 
# 150
typedef double double_t; 
# 238 "/usr/include/math.h" 3
enum { 
# 239
FP_INT_UPWARD, 
# 242
FP_INT_DOWNWARD, 
# 245
FP_INT_TOWARDZERO, 
# 248
FP_INT_TONEARESTFROMZERO, 
# 251
FP_INT_TONEAREST
# 254
}; 
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3
extern int __fpclassify(double __value) throw()
# 22
 __attribute((const)); 
# 25
extern int __signbit(double __value) throw()
# 26
 __attribute((const)); 
# 30
extern int __isinf(double __value) throw() __attribute((const)); 
# 33
extern int __finite(double __value) throw() __attribute((const)); 
# 36
extern int __isnan(double __value) throw() __attribute((const)); 
# 39
extern int __iseqsig(double __x, double __y) throw(); 
# 42
extern int __issignaling(double __value) throw()
# 43
 __attribute((const)); 
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern double acos(double __x) throw(); extern double __acos(double __x) throw(); 
# 55
extern double asin(double __x) throw(); extern double __asin(double __x) throw(); 
# 57
extern double atan(double __x) throw(); extern double __atan(double __x) throw(); 
# 59
extern double atan2(double __y, double __x) throw(); extern double __atan2(double __y, double __x) throw(); 
# 62
extern double cos(double __x) throw(); extern double __cos(double __x) throw(); 
# 64
extern double sin(double __x) throw(); extern double __sin(double __x) throw(); 
# 66
extern double tan(double __x) throw(); extern double __tan(double __x) throw(); 
# 71
extern double cosh(double __x) throw(); extern double __cosh(double __x) throw(); 
# 73
extern double sinh(double __x) throw(); extern double __sinh(double __x) throw(); 
# 75
extern double tanh(double __x) throw(); extern double __tanh(double __x) throw(); 
# 79
extern void sincos(double __x, double * __sinx, double * __cosx) throw(); extern void __sincos(double __x, double * __sinx, double * __cosx) throw(); 
# 85
extern double acosh(double __x) throw(); extern double __acosh(double __x) throw(); 
# 87
extern double asinh(double __x) throw(); extern double __asinh(double __x) throw(); 
# 89
extern double atanh(double __x) throw(); extern double __atanh(double __x) throw(); 
# 95
extern double exp(double __x) throw(); extern double __exp(double __x) throw(); 
# 98
extern double frexp(double __x, int * __exponent) throw(); extern double __frexp(double __x, int * __exponent) throw(); 
# 101
extern double ldexp(double __x, int __exponent) throw(); extern double __ldexp(double __x, int __exponent) throw(); 
# 104
extern double log(double __x) throw(); extern double __log(double __x) throw(); 
# 107
extern double log10(double __x) throw(); extern double __log10(double __x) throw(); 
# 110
extern double modf(double __x, double * __iptr) throw(); extern double __modf(double __x, double * __iptr) throw() __attribute((__nonnull__(2))); 
# 114
extern double exp10(double __x) throw(); extern double __exp10(double __x) throw(); 
# 119
extern double expm1(double __x) throw(); extern double __expm1(double __x) throw(); 
# 122
extern double log1p(double __x) throw(); extern double __log1p(double __x) throw(); 
# 125
extern double logb(double __x) throw(); extern double __logb(double __x) throw(); 
# 130
extern double exp2(double __x) throw(); extern double __exp2(double __x) throw(); 
# 133
extern double log2(double __x) throw(); extern double __log2(double __x) throw(); 
# 140
extern double pow(double __x, double __y) throw(); extern double __pow(double __x, double __y) throw(); 
# 143
extern double sqrt(double __x) throw(); extern double __sqrt(double __x) throw(); 
# 147
extern double hypot(double __x, double __y) throw(); extern double __hypot(double __x, double __y) throw(); 
# 152
extern double cbrt(double __x) throw(); extern double __cbrt(double __x) throw(); 
# 159
extern double ceil(double __x) throw() __attribute((const)); extern double __ceil(double __x) throw() __attribute((const)); 
# 162
extern double fabs(double __x) throw() __attribute((const)); extern double __fabs(double __x) throw() __attribute((const)); 
# 165
extern double floor(double __x) throw() __attribute((const)); extern double __floor(double __x) throw() __attribute((const)); 
# 168
extern double fmod(double __x, double __y) throw(); extern double __fmod(double __x, double __y) throw(); 
# 182 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern int finite(double __value) throw() __attribute((const)); 
# 185
extern double drem(double __x, double __y) throw(); extern double __drem(double __x, double __y) throw(); 
# 189
extern double significand(double __x) throw(); extern double __significand(double __x) throw(); 
# 196
extern double copysign(double __x, double __y) throw() __attribute((const)); extern double __copysign(double __x, double __y) throw() __attribute((const)); 
# 201
extern double nan(const char * __tagb) throw(); extern double __nan(const char * __tagb) throw(); 
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern double j0(double) throw(); extern double __j0(double) throw(); 
# 218
extern double j1(double) throw(); extern double __j1(double) throw(); 
# 219
extern double jn(int, double) throw(); extern double __jn(int, double) throw(); 
# 220
extern double y0(double) throw(); extern double __y0(double) throw(); 
# 221
extern double y1(double) throw(); extern double __y1(double) throw(); 
# 222
extern double yn(int, double) throw(); extern double __yn(int, double) throw(); 
# 228
extern double erf(double) throw(); extern double __erf(double) throw(); 
# 229
extern double erfc(double) throw(); extern double __erfc(double) throw(); 
# 230
extern double lgamma(double) throw(); extern double __lgamma(double) throw(); 
# 235
extern double tgamma(double) throw(); extern double __tgamma(double) throw(); 
# 241
extern double gamma(double) throw(); extern double __gamma(double) throw(); 
# 249
extern double lgamma_r(double, int * __signgamp) throw(); extern double __lgamma_r(double, int * __signgamp) throw(); 
# 256
extern double rint(double __x) throw(); extern double __rint(double __x) throw(); 
# 259
extern double nextafter(double __x, double __y) throw(); extern double __nextafter(double __x, double __y) throw(); 
# 261
extern double nexttoward(double __x, long double __y) throw(); extern double __nexttoward(double __x, long double __y) throw(); 
# 266
extern double nextdown(double __x) throw(); extern double __nextdown(double __x) throw(); 
# 268
extern double nextup(double __x) throw(); extern double __nextup(double __x) throw(); 
# 272
extern double remainder(double __x, double __y) throw(); extern double __remainder(double __x, double __y) throw(); 
# 276
extern double scalbn(double __x, int __n) throw(); extern double __scalbn(double __x, int __n) throw(); 
# 280
extern int ilogb(double __x) throw(); extern int __ilogb(double __x) throw(); 
# 285
extern long llogb(double __x) throw(); extern long __llogb(double __x) throw(); 
# 290
extern double scalbln(double __x, long __n) throw(); extern double __scalbln(double __x, long __n) throw(); 
# 294
extern double nearbyint(double __x) throw(); extern double __nearbyint(double __x) throw(); 
# 298
extern double round(double __x) throw() __attribute((const)); extern double __round(double __x) throw() __attribute((const)); 
# 302
extern double trunc(double __x) throw() __attribute((const)); extern double __trunc(double __x) throw() __attribute((const)); 
# 307
extern double remquo(double __x, double __y, int * __quo) throw(); extern double __remquo(double __x, double __y, int * __quo) throw(); 
# 314
extern long lrint(double __x) throw(); extern long __lrint(double __x) throw(); 
# 316
__extension__ extern long long llrint(double __x) throw(); extern long long __llrint(double __x) throw(); 
# 320
extern long lround(double __x) throw(); extern long __lround(double __x) throw(); 
# 322
__extension__ extern long long llround(double __x) throw(); extern long long __llround(double __x) throw(); 
# 326
extern double fdim(double __x, double __y) throw(); extern double __fdim(double __x, double __y) throw(); 
# 329
extern double fmax(double __x, double __y) throw() __attribute((const)); extern double __fmax(double __x, double __y) throw() __attribute((const)); 
# 332
extern double fmin(double __x, double __y) throw() __attribute((const)); extern double __fmin(double __x, double __y) throw() __attribute((const)); 
# 335
extern double fma(double __x, double __y, double __z) throw(); extern double __fma(double __x, double __y, double __z) throw(); 
# 340
extern double roundeven(double __x) throw() __attribute((const)); extern double __roundeven(double __x) throw() __attribute((const)); 
# 344
extern __intmax_t fromfp(double __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfp(double __x, int __round, unsigned __width) throw(); 
# 349
extern __uintmax_t ufromfp(double __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfp(double __x, int __round, unsigned __width) throw(); 
# 355
extern __intmax_t fromfpx(double __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpx(double __x, int __round, unsigned __width) throw(); 
# 361
extern __uintmax_t ufromfpx(double __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpx(double __x, int __round, unsigned __width) throw(); 
# 365
extern double fmaxmag(double __x, double __y) throw() __attribute((const)); extern double __fmaxmag(double __x, double __y) throw() __attribute((const)); 
# 368
extern double fminmag(double __x, double __y) throw() __attribute((const)); extern double __fminmag(double __x, double __y) throw() __attribute((const)); 
# 371
extern int canonicalize(double * __cx, const double * __x) throw(); 
# 376
extern int totalorder(const double * __x, const double * __y) throw()
# 378
 __attribute((__pure__)); 
# 381
extern int totalordermag(const double * __x, const double * __y) throw()
# 383
 __attribute((__pure__)); 
# 386
extern double getpayload(const double * __x) throw(); extern double __getpayload(const double * __x) throw(); 
# 389
extern int setpayload(double * __x, double __payload) throw(); 
# 392
extern int setpayloadsig(double * __x, double __payload) throw(); 
# 400
extern double scalb(double __x, double __n) throw(); extern double __scalb(double __x, double __n) throw(); 
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3
extern int __fpclassifyf(float __value) throw()
# 22
 __attribute((const)); 
# 25
extern int __signbitf(float __value) throw()
# 26
 __attribute((const)); 
# 30
extern int __isinff(float __value) throw() __attribute((const)); 
# 33
extern int __finitef(float __value) throw() __attribute((const)); 
# 36
extern int __isnanf(float __value) throw() __attribute((const)); 
# 39
extern int __iseqsigf(float __x, float __y) throw(); 
# 42
extern int __issignalingf(float __value) throw()
# 43
 __attribute((const)); 
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern float acosf(float __x) throw(); extern float __acosf(float __x) throw(); 
# 55
extern float asinf(float __x) throw(); extern float __asinf(float __x) throw(); 
# 57
extern float atanf(float __x) throw(); extern float __atanf(float __x) throw(); 
# 59
extern float atan2f(float __y, float __x) throw(); extern float __atan2f(float __y, float __x) throw(); 
# 62
extern float cosf(float __x) throw(); 
# 64
extern float sinf(float __x) throw(); 
# 66
extern float tanf(float __x) throw(); 
# 71
extern float coshf(float __x) throw(); extern float __coshf(float __x) throw(); 
# 73
extern float sinhf(float __x) throw(); extern float __sinhf(float __x) throw(); 
# 75
extern float tanhf(float __x) throw(); extern float __tanhf(float __x) throw(); 
# 79
extern void sincosf(float __x, float * __sinx, float * __cosx) throw(); 
# 85
extern float acoshf(float __x) throw(); extern float __acoshf(float __x) throw(); 
# 87
extern float asinhf(float __x) throw(); extern float __asinhf(float __x) throw(); 
# 89
extern float atanhf(float __x) throw(); extern float __atanhf(float __x) throw(); 
# 95
extern float expf(float __x) throw(); 
# 98
extern float frexpf(float __x, int * __exponent) throw(); extern float __frexpf(float __x, int * __exponent) throw(); 
# 101
extern float ldexpf(float __x, int __exponent) throw(); extern float __ldexpf(float __x, int __exponent) throw(); 
# 104
extern float logf(float __x) throw(); 
# 107
extern float log10f(float __x) throw(); 
# 110
extern float modff(float __x, float * __iptr) throw(); extern float __modff(float __x, float * __iptr) throw() __attribute((__nonnull__(2))); 
# 114
extern float exp10f(float __x) throw(); 
# 119
extern float expm1f(float __x) throw(); extern float __expm1f(float __x) throw(); 
# 122
extern float log1pf(float __x) throw(); extern float __log1pf(float __x) throw(); 
# 125
extern float logbf(float __x) throw(); extern float __logbf(float __x) throw(); 
# 130
extern float exp2f(float __x) throw(); extern float __exp2f(float __x) throw(); 
# 133
extern float log2f(float __x) throw(); 
# 140
extern float powf(float __x, float __y) throw(); 
# 143
extern float sqrtf(float __x) throw(); extern float __sqrtf(float __x) throw(); 
# 147
extern float hypotf(float __x, float __y) throw(); extern float __hypotf(float __x, float __y) throw(); 
# 152
extern float cbrtf(float __x) throw(); extern float __cbrtf(float __x) throw(); 
# 159
extern float ceilf(float __x) throw() __attribute((const)); extern float __ceilf(float __x) throw() __attribute((const)); 
# 162
extern float fabsf(float __x) throw() __attribute((const)); extern float __fabsf(float __x) throw() __attribute((const)); 
# 165
extern float floorf(float __x) throw() __attribute((const)); extern float __floorf(float __x) throw() __attribute((const)); 
# 168
extern float fmodf(float __x, float __y) throw(); extern float __fmodf(float __x, float __y) throw(); 
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern int isinff(float __value) throw() __attribute((const)); 
# 182
extern int finitef(float __value) throw() __attribute((const)); 
# 185
extern float dremf(float __x, float __y) throw(); extern float __dremf(float __x, float __y) throw(); 
# 189
extern float significandf(float __x) throw(); extern float __significandf(float __x) throw(); 
# 196
extern float copysignf(float __x, float __y) throw() __attribute((const)); extern float __copysignf(float __x, float __y) throw() __attribute((const)); 
# 201
extern float nanf(const char * __tagb) throw(); extern float __nanf(const char * __tagb) throw(); 
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern int isnanf(float __value) throw() __attribute((const)); 
# 217
extern float j0f(float) throw(); extern float __j0f(float) throw(); 
# 218
extern float j1f(float) throw(); extern float __j1f(float) throw(); 
# 219
extern float jnf(int, float) throw(); extern float __jnf(int, float) throw(); 
# 220
extern float y0f(float) throw(); extern float __y0f(float) throw(); 
# 221
extern float y1f(float) throw(); extern float __y1f(float) throw(); 
# 222
extern float ynf(int, float) throw(); extern float __ynf(int, float) throw(); 
# 228
extern float erff(float) throw(); extern float __erff(float) throw(); 
# 229
extern float erfcf(float) throw(); extern float __erfcf(float) throw(); 
# 230
extern float lgammaf(float) throw(); extern float __lgammaf(float) throw(); 
# 235
extern float tgammaf(float) throw(); extern float __tgammaf(float) throw(); 
# 241
extern float gammaf(float) throw(); extern float __gammaf(float) throw(); 
# 249
extern float lgammaf_r(float, int * __signgamp) throw(); extern float __lgammaf_r(float, int * __signgamp) throw(); 
# 256
extern float rintf(float __x) throw(); extern float __rintf(float __x) throw(); 
# 259
extern float nextafterf(float __x, float __y) throw(); extern float __nextafterf(float __x, float __y) throw(); 
# 261
extern float nexttowardf(float __x, long double __y) throw(); extern float __nexttowardf(float __x, long double __y) throw(); 
# 266
extern float nextdownf(float __x) throw(); extern float __nextdownf(float __x) throw(); 
# 268
extern float nextupf(float __x) throw(); extern float __nextupf(float __x) throw(); 
# 272
extern float remainderf(float __x, float __y) throw(); extern float __remainderf(float __x, float __y) throw(); 
# 276
extern float scalbnf(float __x, int __n) throw(); extern float __scalbnf(float __x, int __n) throw(); 
# 280
extern int ilogbf(float __x) throw(); extern int __ilogbf(float __x) throw(); 
# 285
extern long llogbf(float __x) throw(); extern long __llogbf(float __x) throw(); 
# 290
extern float scalblnf(float __x, long __n) throw(); extern float __scalblnf(float __x, long __n) throw(); 
# 294
extern float nearbyintf(float __x) throw(); extern float __nearbyintf(float __x) throw(); 
# 298
extern float roundf(float __x) throw() __attribute((const)); extern float __roundf(float __x) throw() __attribute((const)); 
# 302
extern float truncf(float __x) throw() __attribute((const)); extern float __truncf(float __x) throw() __attribute((const)); 
# 307
extern float remquof(float __x, float __y, int * __quo) throw(); extern float __remquof(float __x, float __y, int * __quo) throw(); 
# 314
extern long lrintf(float __x) throw(); extern long __lrintf(float __x) throw(); 
# 316
__extension__ extern long long llrintf(float __x) throw(); extern long long __llrintf(float __x) throw(); 
# 320
extern long lroundf(float __x) throw(); extern long __lroundf(float __x) throw(); 
# 322
__extension__ extern long long llroundf(float __x) throw(); extern long long __llroundf(float __x) throw(); 
# 326
extern float fdimf(float __x, float __y) throw(); extern float __fdimf(float __x, float __y) throw(); 
# 329
extern float fmaxf(float __x, float __y) throw() __attribute((const)); extern float __fmaxf(float __x, float __y) throw() __attribute((const)); 
# 332
extern float fminf(float __x, float __y) throw() __attribute((const)); extern float __fminf(float __x, float __y) throw() __attribute((const)); 
# 335
extern float fmaf(float __x, float __y, float __z) throw(); extern float __fmaf(float __x, float __y, float __z) throw(); 
# 340
extern float roundevenf(float __x) throw() __attribute((const)); extern float __roundevenf(float __x) throw() __attribute((const)); 
# 344
extern __intmax_t fromfpf(float __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpf(float __x, int __round, unsigned __width) throw(); 
# 349
extern __uintmax_t ufromfpf(float __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpf(float __x, int __round, unsigned __width) throw(); 
# 355
extern __intmax_t fromfpxf(float __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpxf(float __x, int __round, unsigned __width) throw(); 
# 361
extern __uintmax_t ufromfpxf(float __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpxf(float __x, int __round, unsigned __width) throw(); 
# 365
extern float fmaxmagf(float __x, float __y) throw() __attribute((const)); extern float __fmaxmagf(float __x, float __y) throw() __attribute((const)); 
# 368
extern float fminmagf(float __x, float __y) throw() __attribute((const)); extern float __fminmagf(float __x, float __y) throw() __attribute((const)); 
# 371
extern int canonicalizef(float * __cx, const float * __x) throw(); 
# 376
extern int totalorderf(const float * __x, const float * __y) throw()
# 378
 __attribute((__pure__)); 
# 381
extern int totalordermagf(const float * __x, const float * __y) throw()
# 383
 __attribute((__pure__)); 
# 386
extern float getpayloadf(const float * __x) throw(); extern float __getpayloadf(const float * __x) throw(); 
# 389
extern int setpayloadf(float * __x, float __payload) throw(); 
# 392
extern int setpayloadsigf(float * __x, float __payload) throw(); 
# 400
extern float scalbf(float __x, float __n) throw(); extern float __scalbf(float __x, float __n) throw(); 
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3
extern int __fpclassifyl(long double __value) throw()
# 22
 __attribute((const)); 
# 25
extern int __signbitl(long double __value) throw()
# 26
 __attribute((const)); 
# 30
extern int __isinfl(long double __value) throw() __attribute((const)); 
# 33
extern int __finitel(long double __value) throw() __attribute((const)); 
# 36
extern int __isnanl(long double __value) throw() __attribute((const)); 
# 39
extern int __iseqsigl(long double __x, long double __y) throw(); 
# 42
extern int __issignalingl(long double __value) throw()
# 43
 __attribute((const)); 
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern long double acosl(long double __x) throw(); extern long double __acosl(long double __x) throw(); 
# 55
extern long double asinl(long double __x) throw(); extern long double __asinl(long double __x) throw(); 
# 57
extern long double atanl(long double __x) throw(); extern long double __atanl(long double __x) throw(); 
# 59
extern long double atan2l(long double __y, long double __x) throw(); extern long double __atan2l(long double __y, long double __x) throw(); 
# 62
extern long double cosl(long double __x) throw(); extern long double __cosl(long double __x) throw(); 
# 64
extern long double sinl(long double __x) throw(); extern long double __sinl(long double __x) throw(); 
# 66
extern long double tanl(long double __x) throw(); extern long double __tanl(long double __x) throw(); 
# 71
extern long double coshl(long double __x) throw(); extern long double __coshl(long double __x) throw(); 
# 73
extern long double sinhl(long double __x) throw(); extern long double __sinhl(long double __x) throw(); 
# 75
extern long double tanhl(long double __x) throw(); extern long double __tanhl(long double __x) throw(); 
# 79
extern void sincosl(long double __x, long double * __sinx, long double * __cosx) throw(); extern void __sincosl(long double __x, long double * __sinx, long double * __cosx) throw(); 
# 85
extern long double acoshl(long double __x) throw(); extern long double __acoshl(long double __x) throw(); 
# 87
extern long double asinhl(long double __x) throw(); extern long double __asinhl(long double __x) throw(); 
# 89
extern long double atanhl(long double __x) throw(); extern long double __atanhl(long double __x) throw(); 
# 95
extern long double expl(long double __x) throw(); extern long double __expl(long double __x) throw(); 
# 98
extern long double frexpl(long double __x, int * __exponent) throw(); extern long double __frexpl(long double __x, int * __exponent) throw(); 
# 101
extern long double ldexpl(long double __x, int __exponent) throw(); extern long double __ldexpl(long double __x, int __exponent) throw(); 
# 104
extern long double logl(long double __x) throw(); extern long double __logl(long double __x) throw(); 
# 107
extern long double log10l(long double __x) throw(); extern long double __log10l(long double __x) throw(); 
# 110
extern long double modfl(long double __x, long double * __iptr) throw(); extern long double __modfl(long double __x, long double * __iptr) throw() __attribute((__nonnull__(2))); 
# 114
extern long double exp10l(long double __x) throw(); extern long double __exp10l(long double __x) throw(); 
# 119
extern long double expm1l(long double __x) throw(); extern long double __expm1l(long double __x) throw(); 
# 122
extern long double log1pl(long double __x) throw(); extern long double __log1pl(long double __x) throw(); 
# 125
extern long double logbl(long double __x) throw(); extern long double __logbl(long double __x) throw(); 
# 130
extern long double exp2l(long double __x) throw(); extern long double __exp2l(long double __x) throw(); 
# 133
extern long double log2l(long double __x) throw(); extern long double __log2l(long double __x) throw(); 
# 140
extern long double powl(long double __x, long double __y) throw(); extern long double __powl(long double __x, long double __y) throw(); 
# 143
extern long double sqrtl(long double __x) throw(); extern long double __sqrtl(long double __x) throw(); 
# 147
extern long double hypotl(long double __x, long double __y) throw(); extern long double __hypotl(long double __x, long double __y) throw(); 
# 152
extern long double cbrtl(long double __x) throw(); extern long double __cbrtl(long double __x) throw(); 
# 159
extern long double ceill(long double __x) throw() __attribute((const)); extern long double __ceill(long double __x) throw() __attribute((const)); 
# 162
extern long double fabsl(long double __x) throw() __attribute((const)); extern long double __fabsl(long double __x) throw() __attribute((const)); 
# 165
extern long double floorl(long double __x) throw() __attribute((const)); extern long double __floorl(long double __x) throw() __attribute((const)); 
# 168
extern long double fmodl(long double __x, long double __y) throw(); extern long double __fmodl(long double __x, long double __y) throw(); 
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern int isinfl(long double __value) throw() __attribute((const)); 
# 182
extern int finitel(long double __value) throw() __attribute((const)); 
# 185
extern long double dreml(long double __x, long double __y) throw(); extern long double __dreml(long double __x, long double __y) throw(); 
# 189
extern long double significandl(long double __x) throw(); extern long double __significandl(long double __x) throw(); 
# 196
extern long double copysignl(long double __x, long double __y) throw() __attribute((const)); extern long double __copysignl(long double __x, long double __y) throw() __attribute((const)); 
# 201
extern long double nanl(const char * __tagb) throw(); extern long double __nanl(const char * __tagb) throw(); 
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern int isnanl(long double __value) throw() __attribute((const)); 
# 217
extern long double j0l(long double) throw(); extern long double __j0l(long double) throw(); 
# 218
extern long double j1l(long double) throw(); extern long double __j1l(long double) throw(); 
# 219
extern long double jnl(int, long double) throw(); extern long double __jnl(int, long double) throw(); 
# 220
extern long double y0l(long double) throw(); extern long double __y0l(long double) throw(); 
# 221
extern long double y1l(long double) throw(); extern long double __y1l(long double) throw(); 
# 222
extern long double ynl(int, long double) throw(); extern long double __ynl(int, long double) throw(); 
# 228
extern long double erfl(long double) throw(); extern long double __erfl(long double) throw(); 
# 229
extern long double erfcl(long double) throw(); extern long double __erfcl(long double) throw(); 
# 230
extern long double lgammal(long double) throw(); extern long double __lgammal(long double) throw(); 
# 235
extern long double tgammal(long double) throw(); extern long double __tgammal(long double) throw(); 
# 241
extern long double gammal(long double) throw(); extern long double __gammal(long double) throw(); 
# 249
extern long double lgammal_r(long double, int * __signgamp) throw(); extern long double __lgammal_r(long double, int * __signgamp) throw(); 
# 256
extern long double rintl(long double __x) throw(); extern long double __rintl(long double __x) throw(); 
# 259
extern long double nextafterl(long double __x, long double __y) throw(); extern long double __nextafterl(long double __x, long double __y) throw(); 
# 261
extern long double nexttowardl(long double __x, long double __y) throw(); extern long double __nexttowardl(long double __x, long double __y) throw(); 
# 266
extern long double nextdownl(long double __x) throw(); extern long double __nextdownl(long double __x) throw(); 
# 268
extern long double nextupl(long double __x) throw(); extern long double __nextupl(long double __x) throw(); 
# 272
extern long double remainderl(long double __x, long double __y) throw(); extern long double __remainderl(long double __x, long double __y) throw(); 
# 276
extern long double scalbnl(long double __x, int __n) throw(); extern long double __scalbnl(long double __x, int __n) throw(); 
# 280
extern int ilogbl(long double __x) throw(); extern int __ilogbl(long double __x) throw(); 
# 285
extern long llogbl(long double __x) throw(); extern long __llogbl(long double __x) throw(); 
# 290
extern long double scalblnl(long double __x, long __n) throw(); extern long double __scalblnl(long double __x, long __n) throw(); 
# 294
extern long double nearbyintl(long double __x) throw(); extern long double __nearbyintl(long double __x) throw(); 
# 298
extern long double roundl(long double __x) throw() __attribute((const)); extern long double __roundl(long double __x) throw() __attribute((const)); 
# 302
extern long double truncl(long double __x) throw() __attribute((const)); extern long double __truncl(long double __x) throw() __attribute((const)); 
# 307
extern long double remquol(long double __x, long double __y, int * __quo) throw(); extern long double __remquol(long double __x, long double __y, int * __quo) throw(); 
# 314
extern long lrintl(long double __x) throw(); extern long __lrintl(long double __x) throw(); 
# 316
__extension__ extern long long llrintl(long double __x) throw(); extern long long __llrintl(long double __x) throw(); 
# 320
extern long lroundl(long double __x) throw(); extern long __lroundl(long double __x) throw(); 
# 322
__extension__ extern long long llroundl(long double __x) throw(); extern long long __llroundl(long double __x) throw(); 
# 326
extern long double fdiml(long double __x, long double __y) throw(); extern long double __fdiml(long double __x, long double __y) throw(); 
# 329
extern long double fmaxl(long double __x, long double __y) throw() __attribute((const)); extern long double __fmaxl(long double __x, long double __y) throw() __attribute((const)); 
# 332
extern long double fminl(long double __x, long double __y) throw() __attribute((const)); extern long double __fminl(long double __x, long double __y) throw() __attribute((const)); 
# 335
extern long double fmal(long double __x, long double __y, long double __z) throw(); extern long double __fmal(long double __x, long double __y, long double __z) throw(); 
# 340
extern long double roundevenl(long double __x) throw() __attribute((const)); extern long double __roundevenl(long double __x) throw() __attribute((const)); 
# 344
extern __intmax_t fromfpl(long double __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpl(long double __x, int __round, unsigned __width) throw(); 
# 349
extern __uintmax_t ufromfpl(long double __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpl(long double __x, int __round, unsigned __width) throw(); 
# 355
extern __intmax_t fromfpxl(long double __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpxl(long double __x, int __round, unsigned __width) throw(); 
# 361
extern __uintmax_t ufromfpxl(long double __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpxl(long double __x, int __round, unsigned __width) throw(); 
# 365
extern long double fmaxmagl(long double __x, long double __y) throw() __attribute((const)); extern long double __fmaxmagl(long double __x, long double __y) throw() __attribute((const)); 
# 368
extern long double fminmagl(long double __x, long double __y) throw() __attribute((const)); extern long double __fminmagl(long double __x, long double __y) throw() __attribute((const)); 
# 371
extern int canonicalizel(long double * __cx, const long double * __x) throw(); 
# 376
extern int totalorderl(const long double * __x, const long double * __y) throw()
# 378
 __attribute((__pure__)); 
# 381
extern int totalordermagl(const long double * __x, const long double * __y) throw()
# 383
 __attribute((__pure__)); 
# 386
extern long double getpayloadl(const long double * __x) throw(); extern long double __getpayloadl(const long double * __x) throw(); 
# 389
extern int setpayloadl(long double * __x, long double __payload) throw(); 
# 392
extern int setpayloadsigl(long double * __x, long double __payload) throw(); 
# 400
extern long double scalbl(long double __x, long double __n) throw(); extern long double __scalbl(long double __x, long double __n) throw(); 
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float32 acosf32(_Float32 __x) throw(); extern _Float32 __acosf32(_Float32 __x) throw(); 
# 55
extern _Float32 asinf32(_Float32 __x) throw(); extern _Float32 __asinf32(_Float32 __x) throw(); 
# 57
extern _Float32 atanf32(_Float32 __x) throw(); extern _Float32 __atanf32(_Float32 __x) throw(); 
# 59
extern _Float32 atan2f32(_Float32 __y, _Float32 __x) throw(); extern _Float32 __atan2f32(_Float32 __y, _Float32 __x) throw(); 
# 62
extern _Float32 cosf32(_Float32 __x) throw(); extern _Float32 __cosf32(_Float32 __x) throw(); 
# 64
extern _Float32 sinf32(_Float32 __x) throw(); extern _Float32 __sinf32(_Float32 __x) throw(); 
# 66
extern _Float32 tanf32(_Float32 __x) throw(); extern _Float32 __tanf32(_Float32 __x) throw(); 
# 71
extern _Float32 coshf32(_Float32 __x) throw(); extern _Float32 __coshf32(_Float32 __x) throw(); 
# 73
extern _Float32 sinhf32(_Float32 __x) throw(); extern _Float32 __sinhf32(_Float32 __x) throw(); 
# 75
extern _Float32 tanhf32(_Float32 __x) throw(); extern _Float32 __tanhf32(_Float32 __x) throw(); 
# 79
extern void sincosf32(_Float32 __x, _Float32 * __sinx, _Float32 * __cosx) throw(); extern void __sincosf32(_Float32 __x, _Float32 * __sinx, _Float32 * __cosx) throw(); 
# 85
extern _Float32 acoshf32(_Float32 __x) throw(); extern _Float32 __acoshf32(_Float32 __x) throw(); 
# 87
extern _Float32 asinhf32(_Float32 __x) throw(); extern _Float32 __asinhf32(_Float32 __x) throw(); 
# 89
extern _Float32 atanhf32(_Float32 __x) throw(); extern _Float32 __atanhf32(_Float32 __x) throw(); 
# 95
extern _Float32 expf32(_Float32 __x) throw(); extern _Float32 __expf32(_Float32 __x) throw(); 
# 98
extern _Float32 frexpf32(_Float32 __x, int * __exponent) throw(); extern _Float32 __frexpf32(_Float32 __x, int * __exponent) throw(); 
# 101
extern _Float32 ldexpf32(_Float32 __x, int __exponent) throw(); extern _Float32 __ldexpf32(_Float32 __x, int __exponent) throw(); 
# 104
extern _Float32 logf32(_Float32 __x) throw(); extern _Float32 __logf32(_Float32 __x) throw(); 
# 107
extern _Float32 log10f32(_Float32 __x) throw(); extern _Float32 __log10f32(_Float32 __x) throw(); 
# 110
extern _Float32 modff32(_Float32 __x, _Float32 * __iptr) throw(); extern _Float32 __modff32(_Float32 __x, _Float32 * __iptr) throw() __attribute((__nonnull__(2))); 
# 114
extern _Float32 exp10f32(_Float32 __x) throw(); extern _Float32 __exp10f32(_Float32 __x) throw(); 
# 119
extern _Float32 expm1f32(_Float32 __x) throw(); extern _Float32 __expm1f32(_Float32 __x) throw(); 
# 122
extern _Float32 log1pf32(_Float32 __x) throw(); extern _Float32 __log1pf32(_Float32 __x) throw(); 
# 125
extern _Float32 logbf32(_Float32 __x) throw(); extern _Float32 __logbf32(_Float32 __x) throw(); 
# 130
extern _Float32 exp2f32(_Float32 __x) throw(); extern _Float32 __exp2f32(_Float32 __x) throw(); 
# 133
extern _Float32 log2f32(_Float32 __x) throw(); extern _Float32 __log2f32(_Float32 __x) throw(); 
# 140
extern _Float32 powf32(_Float32 __x, _Float32 __y) throw(); extern _Float32 __powf32(_Float32 __x, _Float32 __y) throw(); 
# 143
extern _Float32 sqrtf32(_Float32 __x) throw(); extern _Float32 __sqrtf32(_Float32 __x) throw(); 
# 147
extern _Float32 hypotf32(_Float32 __x, _Float32 __y) throw(); extern _Float32 __hypotf32(_Float32 __x, _Float32 __y) throw(); 
# 152
extern _Float32 cbrtf32(_Float32 __x) throw(); extern _Float32 __cbrtf32(_Float32 __x) throw(); 
# 159
extern _Float32 ceilf32(_Float32 __x) throw() __attribute((const)); extern _Float32 __ceilf32(_Float32 __x) throw() __attribute((const)); 
# 162
extern _Float32 fabsf32(_Float32 __x) throw() __attribute((const)); extern _Float32 __fabsf32(_Float32 __x) throw() __attribute((const)); 
# 165
extern _Float32 floorf32(_Float32 __x) throw() __attribute((const)); extern _Float32 __floorf32(_Float32 __x) throw() __attribute((const)); 
# 168
extern _Float32 fmodf32(_Float32 __x, _Float32 __y) throw(); extern _Float32 __fmodf32(_Float32 __x, _Float32 __y) throw(); 
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float32 copysignf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); extern _Float32 __copysignf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); 
# 201
extern _Float32 nanf32(const char * __tagb) throw(); extern _Float32 __nanf32(const char * __tagb) throw(); 
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float32 j0f32(_Float32) throw(); extern _Float32 __j0f32(_Float32) throw(); 
# 218
extern _Float32 j1f32(_Float32) throw(); extern _Float32 __j1f32(_Float32) throw(); 
# 219
extern _Float32 jnf32(int, _Float32) throw(); extern _Float32 __jnf32(int, _Float32) throw(); 
# 220
extern _Float32 y0f32(_Float32) throw(); extern _Float32 __y0f32(_Float32) throw(); 
# 221
extern _Float32 y1f32(_Float32) throw(); extern _Float32 __y1f32(_Float32) throw(); 
# 222
extern _Float32 ynf32(int, _Float32) throw(); extern _Float32 __ynf32(int, _Float32) throw(); 
# 228
extern _Float32 erff32(_Float32) throw(); extern _Float32 __erff32(_Float32) throw(); 
# 229
extern _Float32 erfcf32(_Float32) throw(); extern _Float32 __erfcf32(_Float32) throw(); 
# 230
extern _Float32 lgammaf32(_Float32) throw(); extern _Float32 __lgammaf32(_Float32) throw(); 
# 235
extern _Float32 tgammaf32(_Float32) throw(); extern _Float32 __tgammaf32(_Float32) throw(); 
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float32 lgammaf32_r(_Float32, int * __signgamp) throw(); extern _Float32 __lgammaf32_r(_Float32, int * __signgamp) throw(); 
# 256
extern _Float32 rintf32(_Float32 __x) throw(); extern _Float32 __rintf32(_Float32 __x) throw(); 
# 259
extern _Float32 nextafterf32(_Float32 __x, _Float32 __y) throw(); extern _Float32 __nextafterf32(_Float32 __x, _Float32 __y) throw(); 
# 266
extern _Float32 nextdownf32(_Float32 __x) throw(); extern _Float32 __nextdownf32(_Float32 __x) throw(); 
# 268
extern _Float32 nextupf32(_Float32 __x) throw(); extern _Float32 __nextupf32(_Float32 __x) throw(); 
# 272
extern _Float32 remainderf32(_Float32 __x, _Float32 __y) throw(); extern _Float32 __remainderf32(_Float32 __x, _Float32 __y) throw(); 
# 276
extern _Float32 scalbnf32(_Float32 __x, int __n) throw(); extern _Float32 __scalbnf32(_Float32 __x, int __n) throw(); 
# 280
extern int ilogbf32(_Float32 __x) throw(); extern int __ilogbf32(_Float32 __x) throw(); 
# 285
extern long llogbf32(_Float32 __x) throw(); extern long __llogbf32(_Float32 __x) throw(); 
# 290
extern _Float32 scalblnf32(_Float32 __x, long __n) throw(); extern _Float32 __scalblnf32(_Float32 __x, long __n) throw(); 
# 294
extern _Float32 nearbyintf32(_Float32 __x) throw(); extern _Float32 __nearbyintf32(_Float32 __x) throw(); 
# 298
extern _Float32 roundf32(_Float32 __x) throw() __attribute((const)); extern _Float32 __roundf32(_Float32 __x) throw() __attribute((const)); 
# 302
extern _Float32 truncf32(_Float32 __x) throw() __attribute((const)); extern _Float32 __truncf32(_Float32 __x) throw() __attribute((const)); 
# 307
extern _Float32 remquof32(_Float32 __x, _Float32 __y, int * __quo) throw(); extern _Float32 __remquof32(_Float32 __x, _Float32 __y, int * __quo) throw(); 
# 314
extern long lrintf32(_Float32 __x) throw(); extern long __lrintf32(_Float32 __x) throw(); 
# 316
__extension__ extern long long llrintf32(_Float32 __x) throw(); extern long long __llrintf32(_Float32 __x) throw(); 
# 320
extern long lroundf32(_Float32 __x) throw(); extern long __lroundf32(_Float32 __x) throw(); 
# 322
__extension__ extern long long llroundf32(_Float32 __x) throw(); extern long long __llroundf32(_Float32 __x) throw(); 
# 326
extern _Float32 fdimf32(_Float32 __x, _Float32 __y) throw(); extern _Float32 __fdimf32(_Float32 __x, _Float32 __y) throw(); 
# 329
extern _Float32 fmaxf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); extern _Float32 __fmaxf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); 
# 332
extern _Float32 fminf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); extern _Float32 __fminf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); 
# 335
extern _Float32 fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) throw(); extern _Float32 __fmaf32(_Float32 __x, _Float32 __y, _Float32 __z) throw(); 
# 340
extern _Float32 roundevenf32(_Float32 __x) throw() __attribute((const)); extern _Float32 __roundevenf32(_Float32 __x) throw() __attribute((const)); 
# 344
extern __intmax_t fromfpf32(_Float32 __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpf32(_Float32 __x, int __round, unsigned __width) throw(); 
# 349
extern __uintmax_t ufromfpf32(_Float32 __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpf32(_Float32 __x, int __round, unsigned __width) throw(); 
# 355
extern __intmax_t fromfpxf32(_Float32 __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpxf32(_Float32 __x, int __round, unsigned __width) throw(); 
# 361
extern __uintmax_t ufromfpxf32(_Float32 __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpxf32(_Float32 __x, int __round, unsigned __width) throw(); 
# 365
extern _Float32 fmaxmagf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); extern _Float32 __fmaxmagf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); 
# 368
extern _Float32 fminmagf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); extern _Float32 __fminmagf32(_Float32 __x, _Float32 __y) throw() __attribute((const)); 
# 371
extern int canonicalizef32(_Float32 * __cx, const _Float32 * __x) throw(); 
# 376
extern int totalorderf32(const _Float32 * __x, const _Float32 * __y) throw()
# 378
 __attribute((__pure__)); 
# 381
extern int totalordermagf32(const _Float32 * __x, const _Float32 * __y) throw()
# 383
 __attribute((__pure__)); 
# 386
extern _Float32 getpayloadf32(const _Float32 * __x) throw(); extern _Float32 __getpayloadf32(const _Float32 * __x) throw(); 
# 389
extern int setpayloadf32(_Float32 * __x, _Float32 __payload) throw(); 
# 392
extern int setpayloadsigf32(_Float32 * __x, _Float32 __payload) throw(); 
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float64 acosf64(_Float64 __x) throw(); extern _Float64 __acosf64(_Float64 __x) throw(); 
# 55
extern _Float64 asinf64(_Float64 __x) throw(); extern _Float64 __asinf64(_Float64 __x) throw(); 
# 57
extern _Float64 atanf64(_Float64 __x) throw(); extern _Float64 __atanf64(_Float64 __x) throw(); 
# 59
extern _Float64 atan2f64(_Float64 __y, _Float64 __x) throw(); extern _Float64 __atan2f64(_Float64 __y, _Float64 __x) throw(); 
# 62
extern _Float64 cosf64(_Float64 __x) throw(); extern _Float64 __cosf64(_Float64 __x) throw(); 
# 64
extern _Float64 sinf64(_Float64 __x) throw(); extern _Float64 __sinf64(_Float64 __x) throw(); 
# 66
extern _Float64 tanf64(_Float64 __x) throw(); extern _Float64 __tanf64(_Float64 __x) throw(); 
# 71
extern _Float64 coshf64(_Float64 __x) throw(); extern _Float64 __coshf64(_Float64 __x) throw(); 
# 73
extern _Float64 sinhf64(_Float64 __x) throw(); extern _Float64 __sinhf64(_Float64 __x) throw(); 
# 75
extern _Float64 tanhf64(_Float64 __x) throw(); extern _Float64 __tanhf64(_Float64 __x) throw(); 
# 79
extern void sincosf64(_Float64 __x, _Float64 * __sinx, _Float64 * __cosx) throw(); extern void __sincosf64(_Float64 __x, _Float64 * __sinx, _Float64 * __cosx) throw(); 
# 85
extern _Float64 acoshf64(_Float64 __x) throw(); extern _Float64 __acoshf64(_Float64 __x) throw(); 
# 87
extern _Float64 asinhf64(_Float64 __x) throw(); extern _Float64 __asinhf64(_Float64 __x) throw(); 
# 89
extern _Float64 atanhf64(_Float64 __x) throw(); extern _Float64 __atanhf64(_Float64 __x) throw(); 
# 95
extern _Float64 expf64(_Float64 __x) throw(); extern _Float64 __expf64(_Float64 __x) throw(); 
# 98
extern _Float64 frexpf64(_Float64 __x, int * __exponent) throw(); extern _Float64 __frexpf64(_Float64 __x, int * __exponent) throw(); 
# 101
extern _Float64 ldexpf64(_Float64 __x, int __exponent) throw(); extern _Float64 __ldexpf64(_Float64 __x, int __exponent) throw(); 
# 104
extern _Float64 logf64(_Float64 __x) throw(); extern _Float64 __logf64(_Float64 __x) throw(); 
# 107
extern _Float64 log10f64(_Float64 __x) throw(); extern _Float64 __log10f64(_Float64 __x) throw(); 
# 110
extern _Float64 modff64(_Float64 __x, _Float64 * __iptr) throw(); extern _Float64 __modff64(_Float64 __x, _Float64 * __iptr) throw() __attribute((__nonnull__(2))); 
# 114
extern _Float64 exp10f64(_Float64 __x) throw(); extern _Float64 __exp10f64(_Float64 __x) throw(); 
# 119
extern _Float64 expm1f64(_Float64 __x) throw(); extern _Float64 __expm1f64(_Float64 __x) throw(); 
# 122
extern _Float64 log1pf64(_Float64 __x) throw(); extern _Float64 __log1pf64(_Float64 __x) throw(); 
# 125
extern _Float64 logbf64(_Float64 __x) throw(); extern _Float64 __logbf64(_Float64 __x) throw(); 
# 130
extern _Float64 exp2f64(_Float64 __x) throw(); extern _Float64 __exp2f64(_Float64 __x) throw(); 
# 133
extern _Float64 log2f64(_Float64 __x) throw(); extern _Float64 __log2f64(_Float64 __x) throw(); 
# 140
extern _Float64 powf64(_Float64 __x, _Float64 __y) throw(); extern _Float64 __powf64(_Float64 __x, _Float64 __y) throw(); 
# 143
extern _Float64 sqrtf64(_Float64 __x) throw(); extern _Float64 __sqrtf64(_Float64 __x) throw(); 
# 147
extern _Float64 hypotf64(_Float64 __x, _Float64 __y) throw(); extern _Float64 __hypotf64(_Float64 __x, _Float64 __y) throw(); 
# 152
extern _Float64 cbrtf64(_Float64 __x) throw(); extern _Float64 __cbrtf64(_Float64 __x) throw(); 
# 159
extern _Float64 ceilf64(_Float64 __x) throw() __attribute((const)); extern _Float64 __ceilf64(_Float64 __x) throw() __attribute((const)); 
# 162
extern _Float64 fabsf64(_Float64 __x) throw() __attribute((const)); extern _Float64 __fabsf64(_Float64 __x) throw() __attribute((const)); 
# 165
extern _Float64 floorf64(_Float64 __x) throw() __attribute((const)); extern _Float64 __floorf64(_Float64 __x) throw() __attribute((const)); 
# 168
extern _Float64 fmodf64(_Float64 __x, _Float64 __y) throw(); extern _Float64 __fmodf64(_Float64 __x, _Float64 __y) throw(); 
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float64 copysignf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); extern _Float64 __copysignf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); 
# 201
extern _Float64 nanf64(const char * __tagb) throw(); extern _Float64 __nanf64(const char * __tagb) throw(); 
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float64 j0f64(_Float64) throw(); extern _Float64 __j0f64(_Float64) throw(); 
# 218
extern _Float64 j1f64(_Float64) throw(); extern _Float64 __j1f64(_Float64) throw(); 
# 219
extern _Float64 jnf64(int, _Float64) throw(); extern _Float64 __jnf64(int, _Float64) throw(); 
# 220
extern _Float64 y0f64(_Float64) throw(); extern _Float64 __y0f64(_Float64) throw(); 
# 221
extern _Float64 y1f64(_Float64) throw(); extern _Float64 __y1f64(_Float64) throw(); 
# 222
extern _Float64 ynf64(int, _Float64) throw(); extern _Float64 __ynf64(int, _Float64) throw(); 
# 228
extern _Float64 erff64(_Float64) throw(); extern _Float64 __erff64(_Float64) throw(); 
# 229
extern _Float64 erfcf64(_Float64) throw(); extern _Float64 __erfcf64(_Float64) throw(); 
# 230
extern _Float64 lgammaf64(_Float64) throw(); extern _Float64 __lgammaf64(_Float64) throw(); 
# 235
extern _Float64 tgammaf64(_Float64) throw(); extern _Float64 __tgammaf64(_Float64) throw(); 
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float64 lgammaf64_r(_Float64, int * __signgamp) throw(); extern _Float64 __lgammaf64_r(_Float64, int * __signgamp) throw(); 
# 256
extern _Float64 rintf64(_Float64 __x) throw(); extern _Float64 __rintf64(_Float64 __x) throw(); 
# 259
extern _Float64 nextafterf64(_Float64 __x, _Float64 __y) throw(); extern _Float64 __nextafterf64(_Float64 __x, _Float64 __y) throw(); 
# 266
extern _Float64 nextdownf64(_Float64 __x) throw(); extern _Float64 __nextdownf64(_Float64 __x) throw(); 
# 268
extern _Float64 nextupf64(_Float64 __x) throw(); extern _Float64 __nextupf64(_Float64 __x) throw(); 
# 272
extern _Float64 remainderf64(_Float64 __x, _Float64 __y) throw(); extern _Float64 __remainderf64(_Float64 __x, _Float64 __y) throw(); 
# 276
extern _Float64 scalbnf64(_Float64 __x, int __n) throw(); extern _Float64 __scalbnf64(_Float64 __x, int __n) throw(); 
# 280
extern int ilogbf64(_Float64 __x) throw(); extern int __ilogbf64(_Float64 __x) throw(); 
# 285
extern long llogbf64(_Float64 __x) throw(); extern long __llogbf64(_Float64 __x) throw(); 
# 290
extern _Float64 scalblnf64(_Float64 __x, long __n) throw(); extern _Float64 __scalblnf64(_Float64 __x, long __n) throw(); 
# 294
extern _Float64 nearbyintf64(_Float64 __x) throw(); extern _Float64 __nearbyintf64(_Float64 __x) throw(); 
# 298
extern _Float64 roundf64(_Float64 __x) throw() __attribute((const)); extern _Float64 __roundf64(_Float64 __x) throw() __attribute((const)); 
# 302
extern _Float64 truncf64(_Float64 __x) throw() __attribute((const)); extern _Float64 __truncf64(_Float64 __x) throw() __attribute((const)); 
# 307
extern _Float64 remquof64(_Float64 __x, _Float64 __y, int * __quo) throw(); extern _Float64 __remquof64(_Float64 __x, _Float64 __y, int * __quo) throw(); 
# 314
extern long lrintf64(_Float64 __x) throw(); extern long __lrintf64(_Float64 __x) throw(); 
# 316
__extension__ extern long long llrintf64(_Float64 __x) throw(); extern long long __llrintf64(_Float64 __x) throw(); 
# 320
extern long lroundf64(_Float64 __x) throw(); extern long __lroundf64(_Float64 __x) throw(); 
# 322
__extension__ extern long long llroundf64(_Float64 __x) throw(); extern long long __llroundf64(_Float64 __x) throw(); 
# 326
extern _Float64 fdimf64(_Float64 __x, _Float64 __y) throw(); extern _Float64 __fdimf64(_Float64 __x, _Float64 __y) throw(); 
# 329
extern _Float64 fmaxf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); extern _Float64 __fmaxf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); 
# 332
extern _Float64 fminf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); extern _Float64 __fminf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); 
# 335
extern _Float64 fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) throw(); extern _Float64 __fmaf64(_Float64 __x, _Float64 __y, _Float64 __z) throw(); 
# 340
extern _Float64 roundevenf64(_Float64 __x) throw() __attribute((const)); extern _Float64 __roundevenf64(_Float64 __x) throw() __attribute((const)); 
# 344
extern __intmax_t fromfpf64(_Float64 __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpf64(_Float64 __x, int __round, unsigned __width) throw(); 
# 349
extern __uintmax_t ufromfpf64(_Float64 __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpf64(_Float64 __x, int __round, unsigned __width) throw(); 
# 355
extern __intmax_t fromfpxf64(_Float64 __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpxf64(_Float64 __x, int __round, unsigned __width) throw(); 
# 361
extern __uintmax_t ufromfpxf64(_Float64 __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpxf64(_Float64 __x, int __round, unsigned __width) throw(); 
# 365
extern _Float64 fmaxmagf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); extern _Float64 __fmaxmagf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); 
# 368
extern _Float64 fminmagf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); extern _Float64 __fminmagf64(_Float64 __x, _Float64 __y) throw() __attribute((const)); 
# 371
extern int canonicalizef64(_Float64 * __cx, const _Float64 * __x) throw(); 
# 376
extern int totalorderf64(const _Float64 * __x, const _Float64 * __y) throw()
# 378
 __attribute((__pure__)); 
# 381
extern int totalordermagf64(const _Float64 * __x, const _Float64 * __y) throw()
# 383
 __attribute((__pure__)); 
# 386
extern _Float64 getpayloadf64(const _Float64 * __x) throw(); extern _Float64 __getpayloadf64(const _Float64 * __x) throw(); 
# 389
extern int setpayloadf64(_Float64 * __x, _Float64 __payload) throw(); 
# 392
extern int setpayloadsigf64(_Float64 * __x, _Float64 __payload) throw(); 
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float32x acosf32x(_Float32x __x) throw(); extern _Float32x __acosf32x(_Float32x __x) throw(); 
# 55
extern _Float32x asinf32x(_Float32x __x) throw(); extern _Float32x __asinf32x(_Float32x __x) throw(); 
# 57
extern _Float32x atanf32x(_Float32x __x) throw(); extern _Float32x __atanf32x(_Float32x __x) throw(); 
# 59
extern _Float32x atan2f32x(_Float32x __y, _Float32x __x) throw(); extern _Float32x __atan2f32x(_Float32x __y, _Float32x __x) throw(); 
# 62
extern _Float32x cosf32x(_Float32x __x) throw(); extern _Float32x __cosf32x(_Float32x __x) throw(); 
# 64
extern _Float32x sinf32x(_Float32x __x) throw(); extern _Float32x __sinf32x(_Float32x __x) throw(); 
# 66
extern _Float32x tanf32x(_Float32x __x) throw(); extern _Float32x __tanf32x(_Float32x __x) throw(); 
# 71
extern _Float32x coshf32x(_Float32x __x) throw(); extern _Float32x __coshf32x(_Float32x __x) throw(); 
# 73
extern _Float32x sinhf32x(_Float32x __x) throw(); extern _Float32x __sinhf32x(_Float32x __x) throw(); 
# 75
extern _Float32x tanhf32x(_Float32x __x) throw(); extern _Float32x __tanhf32x(_Float32x __x) throw(); 
# 79
extern void sincosf32x(_Float32x __x, _Float32x * __sinx, _Float32x * __cosx) throw(); extern void __sincosf32x(_Float32x __x, _Float32x * __sinx, _Float32x * __cosx) throw(); 
# 85
extern _Float32x acoshf32x(_Float32x __x) throw(); extern _Float32x __acoshf32x(_Float32x __x) throw(); 
# 87
extern _Float32x asinhf32x(_Float32x __x) throw(); extern _Float32x __asinhf32x(_Float32x __x) throw(); 
# 89
extern _Float32x atanhf32x(_Float32x __x) throw(); extern _Float32x __atanhf32x(_Float32x __x) throw(); 
# 95
extern _Float32x expf32x(_Float32x __x) throw(); extern _Float32x __expf32x(_Float32x __x) throw(); 
# 98
extern _Float32x frexpf32x(_Float32x __x, int * __exponent) throw(); extern _Float32x __frexpf32x(_Float32x __x, int * __exponent) throw(); 
# 101
extern _Float32x ldexpf32x(_Float32x __x, int __exponent) throw(); extern _Float32x __ldexpf32x(_Float32x __x, int __exponent) throw(); 
# 104
extern _Float32x logf32x(_Float32x __x) throw(); extern _Float32x __logf32x(_Float32x __x) throw(); 
# 107
extern _Float32x log10f32x(_Float32x __x) throw(); extern _Float32x __log10f32x(_Float32x __x) throw(); 
# 110
extern _Float32x modff32x(_Float32x __x, _Float32x * __iptr) throw(); extern _Float32x __modff32x(_Float32x __x, _Float32x * __iptr) throw() __attribute((__nonnull__(2))); 
# 114
extern _Float32x exp10f32x(_Float32x __x) throw(); extern _Float32x __exp10f32x(_Float32x __x) throw(); 
# 119
extern _Float32x expm1f32x(_Float32x __x) throw(); extern _Float32x __expm1f32x(_Float32x __x) throw(); 
# 122
extern _Float32x log1pf32x(_Float32x __x) throw(); extern _Float32x __log1pf32x(_Float32x __x) throw(); 
# 125
extern _Float32x logbf32x(_Float32x __x) throw(); extern _Float32x __logbf32x(_Float32x __x) throw(); 
# 130
extern _Float32x exp2f32x(_Float32x __x) throw(); extern _Float32x __exp2f32x(_Float32x __x) throw(); 
# 133
extern _Float32x log2f32x(_Float32x __x) throw(); extern _Float32x __log2f32x(_Float32x __x) throw(); 
# 140
extern _Float32x powf32x(_Float32x __x, _Float32x __y) throw(); extern _Float32x __powf32x(_Float32x __x, _Float32x __y) throw(); 
# 143
extern _Float32x sqrtf32x(_Float32x __x) throw(); extern _Float32x __sqrtf32x(_Float32x __x) throw(); 
# 147
extern _Float32x hypotf32x(_Float32x __x, _Float32x __y) throw(); extern _Float32x __hypotf32x(_Float32x __x, _Float32x __y) throw(); 
# 152
extern _Float32x cbrtf32x(_Float32x __x) throw(); extern _Float32x __cbrtf32x(_Float32x __x) throw(); 
# 159
extern _Float32x ceilf32x(_Float32x __x) throw() __attribute((const)); extern _Float32x __ceilf32x(_Float32x __x) throw() __attribute((const)); 
# 162
extern _Float32x fabsf32x(_Float32x __x) throw() __attribute((const)); extern _Float32x __fabsf32x(_Float32x __x) throw() __attribute((const)); 
# 165
extern _Float32x floorf32x(_Float32x __x) throw() __attribute((const)); extern _Float32x __floorf32x(_Float32x __x) throw() __attribute((const)); 
# 168
extern _Float32x fmodf32x(_Float32x __x, _Float32x __y) throw(); extern _Float32x __fmodf32x(_Float32x __x, _Float32x __y) throw(); 
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float32x copysignf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); extern _Float32x __copysignf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); 
# 201
extern _Float32x nanf32x(const char * __tagb) throw(); extern _Float32x __nanf32x(const char * __tagb) throw(); 
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float32x j0f32x(_Float32x) throw(); extern _Float32x __j0f32x(_Float32x) throw(); 
# 218
extern _Float32x j1f32x(_Float32x) throw(); extern _Float32x __j1f32x(_Float32x) throw(); 
# 219
extern _Float32x jnf32x(int, _Float32x) throw(); extern _Float32x __jnf32x(int, _Float32x) throw(); 
# 220
extern _Float32x y0f32x(_Float32x) throw(); extern _Float32x __y0f32x(_Float32x) throw(); 
# 221
extern _Float32x y1f32x(_Float32x) throw(); extern _Float32x __y1f32x(_Float32x) throw(); 
# 222
extern _Float32x ynf32x(int, _Float32x) throw(); extern _Float32x __ynf32x(int, _Float32x) throw(); 
# 228
extern _Float32x erff32x(_Float32x) throw(); extern _Float32x __erff32x(_Float32x) throw(); 
# 229
extern _Float32x erfcf32x(_Float32x) throw(); extern _Float32x __erfcf32x(_Float32x) throw(); 
# 230
extern _Float32x lgammaf32x(_Float32x) throw(); extern _Float32x __lgammaf32x(_Float32x) throw(); 
# 235
extern _Float32x tgammaf32x(_Float32x) throw(); extern _Float32x __tgammaf32x(_Float32x) throw(); 
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float32x lgammaf32x_r(_Float32x, int * __signgamp) throw(); extern _Float32x __lgammaf32x_r(_Float32x, int * __signgamp) throw(); 
# 256
extern _Float32x rintf32x(_Float32x __x) throw(); extern _Float32x __rintf32x(_Float32x __x) throw(); 
# 259
extern _Float32x nextafterf32x(_Float32x __x, _Float32x __y) throw(); extern _Float32x __nextafterf32x(_Float32x __x, _Float32x __y) throw(); 
# 266
extern _Float32x nextdownf32x(_Float32x __x) throw(); extern _Float32x __nextdownf32x(_Float32x __x) throw(); 
# 268
extern _Float32x nextupf32x(_Float32x __x) throw(); extern _Float32x __nextupf32x(_Float32x __x) throw(); 
# 272
extern _Float32x remainderf32x(_Float32x __x, _Float32x __y) throw(); extern _Float32x __remainderf32x(_Float32x __x, _Float32x __y) throw(); 
# 276
extern _Float32x scalbnf32x(_Float32x __x, int __n) throw(); extern _Float32x __scalbnf32x(_Float32x __x, int __n) throw(); 
# 280
extern int ilogbf32x(_Float32x __x) throw(); extern int __ilogbf32x(_Float32x __x) throw(); 
# 285
extern long llogbf32x(_Float32x __x) throw(); extern long __llogbf32x(_Float32x __x) throw(); 
# 290
extern _Float32x scalblnf32x(_Float32x __x, long __n) throw(); extern _Float32x __scalblnf32x(_Float32x __x, long __n) throw(); 
# 294
extern _Float32x nearbyintf32x(_Float32x __x) throw(); extern _Float32x __nearbyintf32x(_Float32x __x) throw(); 
# 298
extern _Float32x roundf32x(_Float32x __x) throw() __attribute((const)); extern _Float32x __roundf32x(_Float32x __x) throw() __attribute((const)); 
# 302
extern _Float32x truncf32x(_Float32x __x) throw() __attribute((const)); extern _Float32x __truncf32x(_Float32x __x) throw() __attribute((const)); 
# 307
extern _Float32x remquof32x(_Float32x __x, _Float32x __y, int * __quo) throw(); extern _Float32x __remquof32x(_Float32x __x, _Float32x __y, int * __quo) throw(); 
# 314
extern long lrintf32x(_Float32x __x) throw(); extern long __lrintf32x(_Float32x __x) throw(); 
# 316
__extension__ extern long long llrintf32x(_Float32x __x) throw(); extern long long __llrintf32x(_Float32x __x) throw(); 
# 320
extern long lroundf32x(_Float32x __x) throw(); extern long __lroundf32x(_Float32x __x) throw(); 
# 322
__extension__ extern long long llroundf32x(_Float32x __x) throw(); extern long long __llroundf32x(_Float32x __x) throw(); 
# 326
extern _Float32x fdimf32x(_Float32x __x, _Float32x __y) throw(); extern _Float32x __fdimf32x(_Float32x __x, _Float32x __y) throw(); 
# 329
extern _Float32x fmaxf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); extern _Float32x __fmaxf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); 
# 332
extern _Float32x fminf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); extern _Float32x __fminf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); 
# 335
extern _Float32x fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) throw(); extern _Float32x __fmaf32x(_Float32x __x, _Float32x __y, _Float32x __z) throw(); 
# 340
extern _Float32x roundevenf32x(_Float32x __x) throw() __attribute((const)); extern _Float32x __roundevenf32x(_Float32x __x) throw() __attribute((const)); 
# 344
extern __intmax_t fromfpf32x(_Float32x __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpf32x(_Float32x __x, int __round, unsigned __width) throw(); 
# 349
extern __uintmax_t ufromfpf32x(_Float32x __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpf32x(_Float32x __x, int __round, unsigned __width) throw(); 
# 355
extern __intmax_t fromfpxf32x(_Float32x __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpxf32x(_Float32x __x, int __round, unsigned __width) throw(); 
# 361
extern __uintmax_t ufromfpxf32x(_Float32x __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpxf32x(_Float32x __x, int __round, unsigned __width) throw(); 
# 365
extern _Float32x fmaxmagf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); extern _Float32x __fmaxmagf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); 
# 368
extern _Float32x fminmagf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); extern _Float32x __fminmagf32x(_Float32x __x, _Float32x __y) throw() __attribute((const)); 
# 371
extern int canonicalizef32x(_Float32x * __cx, const _Float32x * __x) throw(); 
# 376
extern int totalorderf32x(const _Float32x * __x, const _Float32x * __y) throw()
# 378
 __attribute((__pure__)); 
# 381
extern int totalordermagf32x(const _Float32x * __x, const _Float32x * __y) throw()
# 383
 __attribute((__pure__)); 
# 386
extern _Float32x getpayloadf32x(const _Float32x * __x) throw(); extern _Float32x __getpayloadf32x(const _Float32x * __x) throw(); 
# 389
extern int setpayloadf32x(_Float32x * __x, _Float32x __payload) throw(); 
# 392
extern int setpayloadsigf32x(_Float32x * __x, _Float32x __payload) throw(); 
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float64x acosf64x(_Float64x __x) throw(); extern _Float64x __acosf64x(_Float64x __x) throw(); 
# 55
extern _Float64x asinf64x(_Float64x __x) throw(); extern _Float64x __asinf64x(_Float64x __x) throw(); 
# 57
extern _Float64x atanf64x(_Float64x __x) throw(); extern _Float64x __atanf64x(_Float64x __x) throw(); 
# 59
extern _Float64x atan2f64x(_Float64x __y, _Float64x __x) throw(); extern _Float64x __atan2f64x(_Float64x __y, _Float64x __x) throw(); 
# 62
extern _Float64x cosf64x(_Float64x __x) throw(); extern _Float64x __cosf64x(_Float64x __x) throw(); 
# 64
extern _Float64x sinf64x(_Float64x __x) throw(); extern _Float64x __sinf64x(_Float64x __x) throw(); 
# 66
extern _Float64x tanf64x(_Float64x __x) throw(); extern _Float64x __tanf64x(_Float64x __x) throw(); 
# 71
extern _Float64x coshf64x(_Float64x __x) throw(); extern _Float64x __coshf64x(_Float64x __x) throw(); 
# 73
extern _Float64x sinhf64x(_Float64x __x) throw(); extern _Float64x __sinhf64x(_Float64x __x) throw(); 
# 75
extern _Float64x tanhf64x(_Float64x __x) throw(); extern _Float64x __tanhf64x(_Float64x __x) throw(); 
# 79
extern void sincosf64x(_Float64x __x, _Float64x * __sinx, _Float64x * __cosx) throw(); extern void __sincosf64x(_Float64x __x, _Float64x * __sinx, _Float64x * __cosx) throw(); 
# 85
extern _Float64x acoshf64x(_Float64x __x) throw(); extern _Float64x __acoshf64x(_Float64x __x) throw(); 
# 87
extern _Float64x asinhf64x(_Float64x __x) throw(); extern _Float64x __asinhf64x(_Float64x __x) throw(); 
# 89
extern _Float64x atanhf64x(_Float64x __x) throw(); extern _Float64x __atanhf64x(_Float64x __x) throw(); 
# 95
extern _Float64x expf64x(_Float64x __x) throw(); extern _Float64x __expf64x(_Float64x __x) throw(); 
# 98
extern _Float64x frexpf64x(_Float64x __x, int * __exponent) throw(); extern _Float64x __frexpf64x(_Float64x __x, int * __exponent) throw(); 
# 101
extern _Float64x ldexpf64x(_Float64x __x, int __exponent) throw(); extern _Float64x __ldexpf64x(_Float64x __x, int __exponent) throw(); 
# 104
extern _Float64x logf64x(_Float64x __x) throw(); extern _Float64x __logf64x(_Float64x __x) throw(); 
# 107
extern _Float64x log10f64x(_Float64x __x) throw(); extern _Float64x __log10f64x(_Float64x __x) throw(); 
# 110
extern _Float64x modff64x(_Float64x __x, _Float64x * __iptr) throw(); extern _Float64x __modff64x(_Float64x __x, _Float64x * __iptr) throw() __attribute((__nonnull__(2))); 
# 114
extern _Float64x exp10f64x(_Float64x __x) throw(); extern _Float64x __exp10f64x(_Float64x __x) throw(); 
# 119
extern _Float64x expm1f64x(_Float64x __x) throw(); extern _Float64x __expm1f64x(_Float64x __x) throw(); 
# 122
extern _Float64x log1pf64x(_Float64x __x) throw(); extern _Float64x __log1pf64x(_Float64x __x) throw(); 
# 125
extern _Float64x logbf64x(_Float64x __x) throw(); extern _Float64x __logbf64x(_Float64x __x) throw(); 
# 130
extern _Float64x exp2f64x(_Float64x __x) throw(); extern _Float64x __exp2f64x(_Float64x __x) throw(); 
# 133
extern _Float64x log2f64x(_Float64x __x) throw(); extern _Float64x __log2f64x(_Float64x __x) throw(); 
# 140
extern _Float64x powf64x(_Float64x __x, _Float64x __y) throw(); extern _Float64x __powf64x(_Float64x __x, _Float64x __y) throw(); 
# 143
extern _Float64x sqrtf64x(_Float64x __x) throw(); extern _Float64x __sqrtf64x(_Float64x __x) throw(); 
# 147
extern _Float64x hypotf64x(_Float64x __x, _Float64x __y) throw(); extern _Float64x __hypotf64x(_Float64x __x, _Float64x __y) throw(); 
# 152
extern _Float64x cbrtf64x(_Float64x __x) throw(); extern _Float64x __cbrtf64x(_Float64x __x) throw(); 
# 159
extern _Float64x ceilf64x(_Float64x __x) throw() __attribute((const)); extern _Float64x __ceilf64x(_Float64x __x) throw() __attribute((const)); 
# 162
extern _Float64x fabsf64x(_Float64x __x) throw() __attribute((const)); extern _Float64x __fabsf64x(_Float64x __x) throw() __attribute((const)); 
# 165
extern _Float64x floorf64x(_Float64x __x) throw() __attribute((const)); extern _Float64x __floorf64x(_Float64x __x) throw() __attribute((const)); 
# 168
extern _Float64x fmodf64x(_Float64x __x, _Float64x __y) throw(); extern _Float64x __fmodf64x(_Float64x __x, _Float64x __y) throw(); 
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float64x copysignf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); extern _Float64x __copysignf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); 
# 201
extern _Float64x nanf64x(const char * __tagb) throw(); extern _Float64x __nanf64x(const char * __tagb) throw(); 
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float64x j0f64x(_Float64x) throw(); extern _Float64x __j0f64x(_Float64x) throw(); 
# 218
extern _Float64x j1f64x(_Float64x) throw(); extern _Float64x __j1f64x(_Float64x) throw(); 
# 219
extern _Float64x jnf64x(int, _Float64x) throw(); extern _Float64x __jnf64x(int, _Float64x) throw(); 
# 220
extern _Float64x y0f64x(_Float64x) throw(); extern _Float64x __y0f64x(_Float64x) throw(); 
# 221
extern _Float64x y1f64x(_Float64x) throw(); extern _Float64x __y1f64x(_Float64x) throw(); 
# 222
extern _Float64x ynf64x(int, _Float64x) throw(); extern _Float64x __ynf64x(int, _Float64x) throw(); 
# 228
extern _Float64x erff64x(_Float64x) throw(); extern _Float64x __erff64x(_Float64x) throw(); 
# 229
extern _Float64x erfcf64x(_Float64x) throw(); extern _Float64x __erfcf64x(_Float64x) throw(); 
# 230
extern _Float64x lgammaf64x(_Float64x) throw(); extern _Float64x __lgammaf64x(_Float64x) throw(); 
# 235
extern _Float64x tgammaf64x(_Float64x) throw(); extern _Float64x __tgammaf64x(_Float64x) throw(); 
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3
extern _Float64x lgammaf64x_r(_Float64x, int * __signgamp) throw(); extern _Float64x __lgammaf64x_r(_Float64x, int * __signgamp) throw(); 
# 256
extern _Float64x rintf64x(_Float64x __x) throw(); extern _Float64x __rintf64x(_Float64x __x) throw(); 
# 259
extern _Float64x nextafterf64x(_Float64x __x, _Float64x __y) throw(); extern _Float64x __nextafterf64x(_Float64x __x, _Float64x __y) throw(); 
# 266
extern _Float64x nextdownf64x(_Float64x __x) throw(); extern _Float64x __nextdownf64x(_Float64x __x) throw(); 
# 268
extern _Float64x nextupf64x(_Float64x __x) throw(); extern _Float64x __nextupf64x(_Float64x __x) throw(); 
# 272
extern _Float64x remainderf64x(_Float64x __x, _Float64x __y) throw(); extern _Float64x __remainderf64x(_Float64x __x, _Float64x __y) throw(); 
# 276
extern _Float64x scalbnf64x(_Float64x __x, int __n) throw(); extern _Float64x __scalbnf64x(_Float64x __x, int __n) throw(); 
# 280
extern int ilogbf64x(_Float64x __x) throw(); extern int __ilogbf64x(_Float64x __x) throw(); 
# 285
extern long llogbf64x(_Float64x __x) throw(); extern long __llogbf64x(_Float64x __x) throw(); 
# 290
extern _Float64x scalblnf64x(_Float64x __x, long __n) throw(); extern _Float64x __scalblnf64x(_Float64x __x, long __n) throw(); 
# 294
extern _Float64x nearbyintf64x(_Float64x __x) throw(); extern _Float64x __nearbyintf64x(_Float64x __x) throw(); 
# 298
extern _Float64x roundf64x(_Float64x __x) throw() __attribute((const)); extern _Float64x __roundf64x(_Float64x __x) throw() __attribute((const)); 
# 302
extern _Float64x truncf64x(_Float64x __x) throw() __attribute((const)); extern _Float64x __truncf64x(_Float64x __x) throw() __attribute((const)); 
# 307
extern _Float64x remquof64x(_Float64x __x, _Float64x __y, int * __quo) throw(); extern _Float64x __remquof64x(_Float64x __x, _Float64x __y, int * __quo) throw(); 
# 314
extern long lrintf64x(_Float64x __x) throw(); extern long __lrintf64x(_Float64x __x) throw(); 
# 316
__extension__ extern long long llrintf64x(_Float64x __x) throw(); extern long long __llrintf64x(_Float64x __x) throw(); 
# 320
extern long lroundf64x(_Float64x __x) throw(); extern long __lroundf64x(_Float64x __x) throw(); 
# 322
__extension__ extern long long llroundf64x(_Float64x __x) throw(); extern long long __llroundf64x(_Float64x __x) throw(); 
# 326
extern _Float64x fdimf64x(_Float64x __x, _Float64x __y) throw(); extern _Float64x __fdimf64x(_Float64x __x, _Float64x __y) throw(); 
# 329
extern _Float64x fmaxf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); extern _Float64x __fmaxf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); 
# 332
extern _Float64x fminf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); extern _Float64x __fminf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); 
# 335
extern _Float64x fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) throw(); extern _Float64x __fmaf64x(_Float64x __x, _Float64x __y, _Float64x __z) throw(); 
# 340
extern _Float64x roundevenf64x(_Float64x __x) throw() __attribute((const)); extern _Float64x __roundevenf64x(_Float64x __x) throw() __attribute((const)); 
# 344
extern __intmax_t fromfpf64x(_Float64x __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpf64x(_Float64x __x, int __round, unsigned __width) throw(); 
# 349
extern __uintmax_t ufromfpf64x(_Float64x __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpf64x(_Float64x __x, int __round, unsigned __width) throw(); 
# 355
extern __intmax_t fromfpxf64x(_Float64x __x, int __round, unsigned __width) throw(); extern __intmax_t __fromfpxf64x(_Float64x __x, int __round, unsigned __width) throw(); 
# 361
extern __uintmax_t ufromfpxf64x(_Float64x __x, int __round, unsigned __width) throw(); extern __uintmax_t __ufromfpxf64x(_Float64x __x, int __round, unsigned __width) throw(); 
# 365
extern _Float64x fmaxmagf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); extern _Float64x __fmaxmagf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); 
# 368
extern _Float64x fminmagf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); extern _Float64x __fminmagf64x(_Float64x __x, _Float64x __y) throw() __attribute((const)); 
# 371
extern int canonicalizef64x(_Float64x * __cx, const _Float64x * __x) throw(); 
# 376
extern int totalorderf64x(const _Float64x * __x, const _Float64x * __y) throw()
# 378
 __attribute((__pure__)); 
# 381
extern int totalordermagf64x(const _Float64x * __x, const _Float64x * __y) throw()
# 383
 __attribute((__pure__)); 
# 386
extern _Float64x getpayloadf64x(const _Float64x * __x) throw(); extern _Float64x __getpayloadf64x(const _Float64x * __x) throw(); 
# 389
extern int setpayloadf64x(_Float64x * __x, _Float64x __payload) throw(); 
# 392
extern int setpayloadsigf64x(_Float64x * __x, _Float64x __payload) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern float fadd(double __x, double __y) throw(); 
# 27
extern float fdiv(double __x, double __y) throw(); 
# 30
extern float fmul(double __x, double __y) throw(); 
# 33
extern float fsub(double __x, double __y) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern float faddl(long double __x, long double __y) throw(); 
# 27
extern float fdivl(long double __x, long double __y) throw(); 
# 30
extern float fmull(long double __x, long double __y) throw(); 
# 33
extern float fsubl(long double __x, long double __y) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern double daddl(long double __x, long double __y) throw(); 
# 27
extern double ddivl(long double __x, long double __y) throw(); 
# 30
extern double dmull(long double __x, long double __y) throw(); 
# 33
extern double dsubl(long double __x, long double __y) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern _Float32 f32addf32x(_Float32x __x, _Float32x __y) throw(); 
# 27
extern _Float32 f32divf32x(_Float32x __x, _Float32x __y) throw(); 
# 30
extern _Float32 f32mulf32x(_Float32x __x, _Float32x __y) throw(); 
# 33
extern _Float32 f32subf32x(_Float32x __x, _Float32x __y) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern _Float32 f32addf64(_Float64 __x, _Float64 __y) throw(); 
# 27
extern _Float32 f32divf64(_Float64 __x, _Float64 __y) throw(); 
# 30
extern _Float32 f32mulf64(_Float64 __x, _Float64 __y) throw(); 
# 33
extern _Float32 f32subf64(_Float64 __x, _Float64 __y) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern _Float32 f32addf64x(_Float64x __x, _Float64x __y) throw(); 
# 27
extern _Float32 f32divf64x(_Float64x __x, _Float64x __y) throw(); 
# 30
extern _Float32 f32mulf64x(_Float64x __x, _Float64x __y) throw(); 
# 33
extern _Float32 f32subf64x(_Float64x __x, _Float64x __y) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern _Float32x f32xaddf64(_Float64 __x, _Float64 __y) throw(); 
# 27
extern _Float32x f32xdivf64(_Float64 __x, _Float64 __y) throw(); 
# 30
extern _Float32x f32xmulf64(_Float64 __x, _Float64 __y) throw(); 
# 33
extern _Float32x f32xsubf64(_Float64 __x, _Float64 __y) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern _Float32x f32xaddf64x(_Float64x __x, _Float64x __y) throw(); 
# 27
extern _Float32x f32xdivf64x(_Float64x __x, _Float64x __y) throw(); 
# 30
extern _Float32x f32xmulf64x(_Float64x __x, _Float64x __y) throw(); 
# 33
extern _Float32x f32xsubf64x(_Float64x __x, _Float64x __y) throw(); 
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3
extern _Float64 f64addf64x(_Float64x __x, _Float64x __y) throw(); 
# 27
extern _Float64 f64divf64x(_Float64x __x, _Float64x __y) throw(); 
# 30
extern _Float64 f64mulf64x(_Float64x __x, _Float64x __y) throw(); 
# 33
extern _Float64 f64subf64x(_Float64x __x, _Float64x __y) throw(); 
# 773 "/usr/include/math.h" 3
extern int signgam; 
# 854 "/usr/include/math.h" 3
enum { 
# 855
FP_NAN, 
# 858
FP_INFINITE, 
# 861
FP_ZERO, 
# 864
FP_SUBNORMAL, 
# 867
FP_NORMAL
# 870
}; 
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3
extern int __iscanonicall(long double __x) throw()
# 24
 __attribute((const)); 
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3
extern "C++" {
# 47
inline int iscanonical(float __val) { return (((void)((__typeof__(__val))__val)), 1); } 
# 48
inline int iscanonical(double __val) { return (((void)((__typeof__(__val))__val)), 1); } 
# 49
inline int iscanonical(long double __val) { return __iscanonicall(__val); } 
# 53
}
# 985 "/usr/include/math.h" 3
extern "C++" {
# 986
inline int issignaling(float __val) { return __issignalingf(__val); } 
# 987
inline int issignaling(double __val) { return __issignaling(__val); } 
# 989
inline int issignaling(long double __val) 
# 990
{ 
# 994
return __issignalingl(__val); 
# 996
} 
# 1002
}
# 1016 "/usr/include/math.h" 3
extern "C++" {
# 1047 "/usr/include/math.h" 3
template< class __T> inline bool 
# 1048
iszero(__T __val) 
# 1049
{ 
# 1050
return __val == 0; 
# 1051
} 
# 1053
}
# 1278 "/usr/include/math.h" 3
extern "C++" {
# 1279
template< class > struct __iseqsig_type; 
# 1281
template<> struct __iseqsig_type< float>  { 
# 1283
static int __call(float __x, float __y) throw() 
# 1284
{ 
# 1285
return __iseqsigf(__x, __y); 
# 1286
} 
# 1287
}; 
# 1289
template<> struct __iseqsig_type< double>  { 
# 1291
static int __call(double __x, double __y) throw() 
# 1292
{ 
# 1293
return __iseqsig(__x, __y); 
# 1294
} 
# 1295
}; 
# 1297
template<> struct __iseqsig_type< long double>  { 
# 1299
static int __call(long double __x, long double __y) throw() 
# 1300
{ 
# 1302
return __iseqsigl(__x, __y); 
# 1306
} 
# 1307
}; 
# 1321 "/usr/include/math.h" 3
template< class _T1, class _T2> inline int 
# 1323
iseqsig(_T1 __x, _T2 __y) throw() 
# 1324
{ 
# 1326
typedef __decltype(((__x + __y) + (0.0F))) _T3; 
# 1330
return __iseqsig_type< __decltype(((__x + __y) + (0.0F)))> ::__call(__x, __y); 
# 1331
} 
# 1333
}
# 1338
}
# 33 "/usr/include/stdlib.h" 3
extern "C" {
# 57 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3
typedef 
# 53
enum { 
# 54
P_ALL, 
# 55
P_PID, 
# 56
P_PGID
# 57
} idtype_t; 
# 62 "/usr/include/stdlib.h" 3
typedef 
# 59
struct { 
# 60
int quot; 
# 61
int rem; 
# 62
} div_t; 
# 70
typedef 
# 67
struct { 
# 68
long quot; 
# 69
long rem; 
# 70
} ldiv_t; 
# 80
__extension__ typedef 
# 77
struct { 
# 78
long long quot; 
# 79
long long rem; 
# 80
} lldiv_t; 
# 97 "/usr/include/stdlib.h" 3
extern size_t __ctype_get_mb_cur_max() throw(); 
# 101
extern double atof(const char * __nptr) throw()
# 102
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 104
extern int atoi(const char * __nptr) throw()
# 105
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 107
extern long atol(const char * __nptr) throw()
# 108
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 112
__extension__ extern long long atoll(const char * __nptr) throw()
# 113
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 117
extern double strtod(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 119
 __attribute((__nonnull__(1))); 
# 123
extern float strtof(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 124
 __attribute((__nonnull__(1))); 
# 126
extern long double strtold(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 128
 __attribute((__nonnull__(1))); 
# 140 "/usr/include/stdlib.h" 3
extern _Float32 strtof32(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 142
 __attribute((__nonnull__(1))); 
# 146
extern _Float64 strtof64(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 148
 __attribute((__nonnull__(1))); 
# 158 "/usr/include/stdlib.h" 3
extern _Float32x strtof32x(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 160
 __attribute((__nonnull__(1))); 
# 164
extern _Float64x strtof64x(const char *__restrict__ __nptr, char **__restrict__ __endptr) throw()
# 166
 __attribute((__nonnull__(1))); 
# 176 "/usr/include/stdlib.h" 3
extern long strtol(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 178
 __attribute((__nonnull__(1))); 
# 180
extern unsigned long strtoul(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 182
 __attribute((__nonnull__(1))); 
# 187
__extension__ extern long long strtoq(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 189
 __attribute((__nonnull__(1))); 
# 192
__extension__ extern unsigned long long strtouq(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 194
 __attribute((__nonnull__(1))); 
# 200
__extension__ extern long long strtoll(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 202
 __attribute((__nonnull__(1))); 
# 205
__extension__ extern unsigned long long strtoull(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base) throw()
# 207
 __attribute((__nonnull__(1))); 
# 212
extern int strfromd(char * __dest, size_t __size, const char * __format, double __f) throw()
# 214
 __attribute((__nonnull__(3))); 
# 216
extern int strfromf(char * __dest, size_t __size, const char * __format, float __f) throw()
# 218
 __attribute((__nonnull__(3))); 
# 220
extern int strfroml(char * __dest, size_t __size, const char * __format, long double __f) throw()
# 222
 __attribute((__nonnull__(3))); 
# 232 "/usr/include/stdlib.h" 3
extern int strfromf32(char * __dest, size_t __size, const char * __format, _Float32 __f) throw()
# 234
 __attribute((__nonnull__(3))); 
# 238
extern int strfromf64(char * __dest, size_t __size, const char * __format, _Float64 __f) throw()
# 240
 __attribute((__nonnull__(3))); 
# 250 "/usr/include/stdlib.h" 3
extern int strfromf32x(char * __dest, size_t __size, const char * __format, _Float32x __f) throw()
# 252
 __attribute((__nonnull__(3))); 
# 256
extern int strfromf64x(char * __dest, size_t __size, const char * __format, _Float64x __f) throw()
# 258
 __attribute((__nonnull__(3))); 
# 274 "/usr/include/stdlib.h" 3
extern long strtol_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, locale_t __loc) throw()
# 276
 __attribute((__nonnull__(1, 4))); 
# 278
extern unsigned long strtoul_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, locale_t __loc) throw()
# 281
 __attribute((__nonnull__(1, 4))); 
# 284
__extension__ extern long long strtoll_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, locale_t __loc) throw()
# 287
 __attribute((__nonnull__(1, 4))); 
# 290
__extension__ extern unsigned long long strtoull_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, int __base, locale_t __loc) throw()
# 293
 __attribute((__nonnull__(1, 4))); 
# 295
extern double strtod_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, locale_t __loc) throw()
# 297
 __attribute((__nonnull__(1, 3))); 
# 299
extern float strtof_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, locale_t __loc) throw()
# 301
 __attribute((__nonnull__(1, 3))); 
# 303
extern long double strtold_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, locale_t __loc) throw()
# 306
 __attribute((__nonnull__(1, 3))); 
# 316 "/usr/include/stdlib.h" 3
extern _Float32 strtof32_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, locale_t __loc) throw()
# 319
 __attribute((__nonnull__(1, 3))); 
# 323
extern _Float64 strtof64_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, locale_t __loc) throw()
# 326
 __attribute((__nonnull__(1, 3))); 
# 337 "/usr/include/stdlib.h" 3
extern _Float32x strtof32x_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, locale_t __loc) throw()
# 340
 __attribute((__nonnull__(1, 3))); 
# 344
extern _Float64x strtof64x_l(const char *__restrict__ __nptr, char **__restrict__ __endptr, locale_t __loc) throw()
# 347
 __attribute((__nonnull__(1, 3))); 
# 385 "/usr/include/stdlib.h" 3
extern char *l64a(long __n) throw(); 
# 388
extern long a64l(const char * __s) throw()
# 389
 __attribute((__pure__)) __attribute((__nonnull__(1))); 
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
extern "C" {
# 33
typedef __u_char u_char; 
# 34
typedef __u_short u_short; 
# 35
typedef __u_int u_int; 
# 36
typedef __u_long u_long; 
# 37
typedef __quad_t quad_t; 
# 38
typedef __u_quad_t u_quad_t; 
# 39
typedef __fsid_t fsid_t; 
# 42
typedef __loff_t loff_t; 
# 47
typedef __ino_t ino_t; 
# 54
typedef __ino64_t ino64_t; 
# 59
typedef __dev_t dev_t; 
# 64
typedef __gid_t gid_t; 
# 69
typedef __mode_t mode_t; 
# 74
typedef __nlink_t nlink_t; 
# 79
typedef __uid_t uid_t; 
# 85
typedef __off_t off_t; 
# 92
typedef __off64_t off64_t; 
# 103 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
typedef __id_t id_t; 
# 108
typedef __ssize_t ssize_t; 
# 114
typedef __daddr_t daddr_t; 
# 115
typedef __caddr_t caddr_t; 
# 121
typedef __key_t key_t; 
# 134 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
typedef __useconds_t useconds_t; 
# 138
typedef __suseconds_t suseconds_t; 
# 148 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
typedef unsigned long ulong; 
# 149
typedef unsigned short ushort; 
# 150
typedef unsigned uint; 
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3
typedef __int8_t int8_t; 
# 25
typedef __int16_t int16_t; 
# 26
typedef __int32_t int32_t; 
# 27
typedef __int64_t int64_t; 
# 158 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
typedef __uint8_t u_int8_t; 
# 159
typedef __uint16_t u_int16_t; 
# 160
typedef __uint32_t u_int32_t; 
# 161
typedef __uint64_t u_int64_t; 
# 164
typedef long register_t __attribute((__mode__(__word__))); 
# 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3
static inline __uint16_t __bswap_16(__uint16_t __bsx) 
# 35
{ 
# 37
return __builtin_bswap16(__bsx); 
# 41
} 
# 49
static inline __uint32_t __bswap_32(__uint32_t __bsx) 
# 50
{ 
# 52
return __builtin_bswap32(__bsx); 
# 56
} 
# 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3
__extension__ static inline __uint64_t __bswap_64(__uint64_t __bsx) 
# 71
{ 
# 73
return __builtin_bswap64(__bsx); 
# 77
} 
# 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3
static inline __uint16_t __uint16_identity(__uint16_t __x) 
# 34
{ 
# 35
return __x; 
# 36
} 
# 39
static inline __uint32_t __uint32_identity(__uint32_t __x) 
# 40
{ 
# 41
return __x; 
# 42
} 
# 45
static inline __uint64_t __uint64_identity(__uint64_t __x) 
# 46
{ 
# 47
return __x; 
# 48
} 
# 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 3
typedef 
# 6
struct { 
# 7
unsigned long __val[(1024) / ((8) * sizeof(unsigned long))]; 
# 8
} __sigset_t; 
# 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 3
typedef __sigset_t sigset_t; 
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
typedef long __fd_mask; 
# 70 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
typedef 
# 60
struct { 
# 64
__fd_mask fds_bits[1024 / (8 * ((int)sizeof(__fd_mask)))]; 
# 70
} fd_set; 
# 77
typedef __fd_mask fd_mask; 
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
extern int select(int __nfds, fd_set *__restrict__ __readfds, fd_set *__restrict__ __writefds, fd_set *__restrict__ __exceptfds, timeval *__restrict__ __timeout); 
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
extern int pselect(int __nfds, fd_set *__restrict__ __readfds, fd_set *__restrict__ __writefds, fd_set *__restrict__ __exceptfds, const timespec *__restrict__ __timeout, const __sigset_t *__restrict__ __sigmask); 
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3
}
# 185 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
typedef __blksize_t blksize_t; 
# 192
typedef __blkcnt_t blkcnt_t; 
# 196
typedef __fsblkcnt_t fsblkcnt_t; 
# 200
typedef __fsfilcnt_t fsfilcnt_t; 
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
typedef __blkcnt64_t blkcnt64_t; 
# 220
typedef __fsblkcnt64_t fsblkcnt64_t; 
# 221
typedef __fsfilcnt64_t fsfilcnt64_t; 
# 53 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3
typedef 
# 49
struct __pthread_internal_list { 
# 51
__pthread_internal_list *__prev; 
# 52
__pthread_internal_list *__next; 
# 53
} __pthread_list_t; 
# 58
typedef 
# 55
struct __pthread_internal_slist { 
# 57
__pthread_internal_slist *__next; 
# 58
} __pthread_slist_t; 
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3
struct __pthread_mutex_s { 
# 24
int __lock; 
# 25
unsigned __count; 
# 26
int __owner; 
# 28
unsigned __nusers; 
# 32
int __kind; 
# 34
short __spins; 
# 35
short __elision; 
# 36
__pthread_list_t __list; 
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3
}; 
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3
struct __pthread_rwlock_arch_t { 
# 25
unsigned __readers; 
# 26
unsigned __writers; 
# 27
unsigned __wrphase_futex; 
# 28
unsigned __writers_futex; 
# 29
unsigned __pad3; 
# 30
unsigned __pad4; 
# 32
int __cur_writer; 
# 33
int __shared; 
# 34
signed char __rwelision; 
# 39
unsigned char __pad1[7]; 
# 42
unsigned long __pad2; 
# 45
unsigned __flags; 
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3
}; 
# 92 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3
struct __pthread_cond_s { 
# 95
__extension__ union { 
# 96
__extension__ unsigned long long __wseq; 
# 98
struct { 
# 99
unsigned __low; 
# 100
unsigned __high; 
# 101
} __wseq32; 
# 102
}; 
# 104
__extension__ union { 
# 105
__extension__ unsigned long long __g1_start; 
# 107
struct { 
# 108
unsigned __low; 
# 109
unsigned __high; 
# 110
} __g1_start32; 
# 111
}; 
# 112
unsigned __g_refs[2]; 
# 113
unsigned __g_size[2]; 
# 114
unsigned __g1_orig_size; 
# 115
unsigned __wrefs; 
# 116
unsigned __g_signals[2]; 
# 117
}; 
# 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3
typedef unsigned long pthread_t; 
# 36
typedef 
# 33
union { 
# 34
char __size[4]; 
# 35
int __align; 
# 36
} pthread_mutexattr_t; 
# 45
typedef 
# 42
union { 
# 43
char __size[4]; 
# 44
int __align; 
# 45
} pthread_condattr_t; 
# 49
typedef unsigned pthread_key_t; 
# 53
typedef int pthread_once_t; 
# 56
union pthread_attr_t { 
# 58
char __size[56]; 
# 59
long __align; 
# 60
}; 
# 62
typedef pthread_attr_t pthread_attr_t; 
# 72
typedef 
# 68
union { 
# 69
__pthread_mutex_s __data; 
# 70
char __size[40]; 
# 71
long __align; 
# 72
} pthread_mutex_t; 
# 80
typedef 
# 76
union { 
# 77
__pthread_cond_s __data; 
# 78
char __size[48]; 
# 79
__extension__ long long __align; 
# 80
} pthread_cond_t; 
# 91
typedef 
# 87
union { 
# 88
__pthread_rwlock_arch_t __data; 
# 89
char __size[56]; 
# 90
long __align; 
# 91
} pthread_rwlock_t; 
# 97
typedef 
# 94
union { 
# 95
char __size[8]; 
# 96
long __align; 
# 97
} pthread_rwlockattr_t; 
# 103
typedef volatile int pthread_spinlock_t; 
# 112
typedef 
# 109
union { 
# 110
char __size[32]; 
# 111
long __align; 
# 112
} pthread_barrier_t; 
# 118
typedef 
# 115
union { 
# 116
char __size[4]; 
# 117
int __align; 
# 118
} pthread_barrierattr_t; 
# 230 "/usr/include/x86_64-linux-gnu/sys/types.h" 3
}
# 401 "/usr/include/stdlib.h" 3
extern long random() throw(); 
# 404
extern void srandom(unsigned __seed) throw(); 
# 410
extern char *initstate(unsigned __seed, char * __statebuf, size_t __statelen) throw()
# 411
 __attribute((__nonnull__(2))); 
# 415
extern char *setstate(char * __statebuf) throw() __attribute((__nonnull__(1))); 
# 423
struct random_data { 
# 425
int32_t *fptr; 
# 426
int32_t *rptr; 
# 427
int32_t *state; 
# 428
int rand_type; 
# 429
int rand_deg; 
# 430
int rand_sep; 
# 431
int32_t *end_ptr; 
# 432
}; 
# 434
extern int random_r(random_data *__restrict__ __buf, int32_t *__restrict__ __result) throw()
# 435
 __attribute((__nonnull__(1, 2))); 
# 437
extern int srandom_r(unsigned __seed, random_data * __buf) throw()
# 438
 __attribute((__nonnull__(2))); 
# 440
extern int initstate_r(unsigned __seed, char *__restrict__ __statebuf, size_t __statelen, random_data *__restrict__ __buf) throw()
# 443
 __attribute((__nonnull__(2, 4))); 
# 445
extern int setstate_r(char *__restrict__ __statebuf, random_data *__restrict__ __buf) throw()
# 447
 __attribute((__nonnull__(1, 2))); 
# 453
extern int rand() throw(); 
# 455
extern void srand(unsigned __seed) throw(); 
# 459
extern int rand_r(unsigned * __seed) throw(); 
# 467
extern double drand48() throw(); 
# 468
extern double erand48(unsigned short  __xsubi[3]) throw() __attribute((__nonnull__(1))); 
# 471
extern long lrand48() throw(); 
# 472
extern long nrand48(unsigned short  __xsubi[3]) throw()
# 473
 __attribute((__nonnull__(1))); 
# 476
extern long mrand48() throw(); 
# 477
extern long jrand48(unsigned short  __xsubi[3]) throw()
# 478
 __attribute((__nonnull__(1))); 
# 481
extern void srand48(long __seedval) throw(); 
# 482
extern unsigned short *seed48(unsigned short  __seed16v[3]) throw()
# 483
 __attribute((__nonnull__(1))); 
# 484
extern void lcong48(unsigned short  __param[7]) throw() __attribute((__nonnull__(1))); 
# 490
struct drand48_data { 
# 492
unsigned short __x[3]; 
# 493
unsigned short __old_x[3]; 
# 494
unsigned short __c; 
# 495
unsigned short __init; 
# 496
__extension__ unsigned long long __a; 
# 498
}; 
# 501
extern int drand48_r(drand48_data *__restrict__ __buffer, double *__restrict__ __result) throw()
# 502
 __attribute((__nonnull__(1, 2))); 
# 503
extern int erand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, double *__restrict__ __result) throw()
# 505
 __attribute((__nonnull__(1, 2))); 
# 508
extern int lrand48_r(drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 510
 __attribute((__nonnull__(1, 2))); 
# 511
extern int nrand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 514
 __attribute((__nonnull__(1, 2))); 
# 517
extern int mrand48_r(drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 519
 __attribute((__nonnull__(1, 2))); 
# 520
extern int jrand48_r(unsigned short  __xsubi[3], drand48_data *__restrict__ __buffer, long *__restrict__ __result) throw()
# 523
 __attribute((__nonnull__(1, 2))); 
# 526
extern int srand48_r(long __seedval, drand48_data * __buffer) throw()
# 527
 __attribute((__nonnull__(2))); 
# 529
extern int seed48_r(unsigned short  __seed16v[3], drand48_data * __buffer) throw()
# 530
 __attribute((__nonnull__(1, 2))); 
# 532
extern int lcong48_r(unsigned short  __param[7], drand48_data * __buffer) throw()
# 534
 __attribute((__nonnull__(1, 2))); 
# 539
extern void *malloc(size_t __size) throw() __attribute((__malloc__))
# 540
 __attribute((__alloc_size__(1))); 
# 542
extern void *calloc(size_t __nmemb, size_t __size) throw()
# 543
 __attribute((__malloc__)) __attribute((__alloc_size__(1, 2))); 
# 550
extern void *realloc(void * __ptr, size_t __size) throw()
# 551
 __attribute((__warn_unused_result__)) __attribute((__alloc_size__(2))); 
# 559
extern void *reallocarray(void * __ptr, size_t __nmemb, size_t __size) throw()
# 560
 __attribute((__warn_unused_result__))
# 561
 __attribute((__alloc_size__(2, 3))); 
# 565
extern void free(void * __ptr) throw(); 
# 26 "/usr/include/alloca.h" 3
extern "C" {
# 32
extern void *alloca(size_t __size) throw(); 
# 38
}
# 574 "/usr/include/stdlib.h" 3
extern void *valloc(size_t __size) throw() __attribute((__malloc__))
# 575
 __attribute((__alloc_size__(1))); 
# 580
extern int posix_memalign(void ** __memptr, size_t __alignment, size_t __size) throw()
# 581
 __attribute((__nonnull__(1))); 
# 586
extern void *aligned_alloc(size_t __alignment, size_t __size) throw()
# 587
 __attribute((__malloc__)) __attribute((__alloc_size__(2))); 
# 591
extern void abort() throw() __attribute((__noreturn__)); 
# 595
extern int atexit(void (* __func)(void)) throw() __attribute((__nonnull__(1))); 
# 600
extern "C++" int at_quick_exit(void (* __func)(void)) throw() __asm__("at_quick_exit")
# 601
 __attribute((__nonnull__(1))); 
# 610 "/usr/include/stdlib.h" 3
extern int on_exit(void (* __func)(int __status, void * __arg), void * __arg) throw()
# 611
 __attribute((__nonnull__(1))); 
# 617
extern void exit(int __status) throw() __attribute((__noreturn__)); 
# 623
extern void quick_exit(int __status) throw() __attribute((__noreturn__)); 
# 629
extern void _Exit(int __status) throw() __attribute((__noreturn__)); 
# 634
extern char *getenv(const char * __name) throw() __attribute((__nonnull__(1))); 
# 639
extern char *secure_getenv(const char * __name) throw()
# 640
 __attribute((__nonnull__(1))); 
# 647
extern int putenv(char * __string) throw() __attribute((__nonnull__(1))); 
# 653
extern int setenv(const char * __name, const char * __value, int __replace) throw()
# 654
 __attribute((__nonnull__(2))); 
# 657
extern int unsetenv(const char * __name) throw() __attribute((__nonnull__(1))); 
# 664
extern int clearenv() throw(); 
# 675 "/usr/include/stdlib.h" 3
extern char *mktemp(char * __template) throw() __attribute((__nonnull__(1))); 
# 688 "/usr/include/stdlib.h" 3
extern int mkstemp(char * __template) __attribute((__nonnull__(1))); 
# 698 "/usr/include/stdlib.h" 3
extern int mkstemp64(char * __template) __attribute((__nonnull__(1))); 
# 710 "/usr/include/stdlib.h" 3
extern int mkstemps(char * __template, int __suffixlen) __attribute((__nonnull__(1))); 
# 720 "/usr/include/stdlib.h" 3
extern int mkstemps64(char * __template, int __suffixlen)
# 721
 __attribute((__nonnull__(1))); 
# 731 "/usr/include/stdlib.h" 3
extern char *mkdtemp(char * __template) throw() __attribute((__nonnull__(1))); 
# 742 "/usr/include/stdlib.h" 3
extern int mkostemp(char * __template, int __flags) __attribute((__nonnull__(1))); 
# 752 "/usr/include/stdlib.h" 3
extern int mkostemp64(char * __template, int __flags) __attribute((__nonnull__(1))); 
# 762 "/usr/include/stdlib.h" 3
extern int mkostemps(char * __template, int __suffixlen, int __flags)
# 763
 __attribute((__nonnull__(1))); 
# 774 "/usr/include/stdlib.h" 3
extern int mkostemps64(char * __template, int __suffixlen, int __flags)
# 775
 __attribute((__nonnull__(1))); 
# 784 "/usr/include/stdlib.h" 3
extern int system(const char * __command); 
# 790
extern char *canonicalize_file_name(const char * __name) throw()
# 791
 __attribute((__nonnull__(1))); 
# 800 "/usr/include/stdlib.h" 3
extern char *realpath(const char *__restrict__ __name, char *__restrict__ __resolved) throw(); 
# 808
typedef int (*__compar_fn_t)(const void *, const void *); 
# 811
typedef __compar_fn_t comparison_fn_t; 
# 815
typedef int (*__compar_d_fn_t)(const void *, const void *, void *); 
# 820
extern void *bsearch(const void * __key, const void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
# 822
 __attribute((__nonnull__(1, 2, 5))); 
# 830
extern void qsort(void * __base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
# 831
 __attribute((__nonnull__(1, 4))); 
# 833
extern void qsort_r(void * __base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void * __arg)
# 835
 __attribute((__nonnull__(1, 4))); 
# 840
extern int abs(int __x) throw() __attribute((const)); 
# 841
extern long labs(long __x) throw() __attribute((const)); 
# 844
__extension__ extern long long llabs(long long __x) throw()
# 845
 __attribute((const)); 
# 852
extern div_t div(int __numer, int __denom) throw()
# 853
 __attribute((const)); 
# 854
extern ldiv_t ldiv(long __numer, long __denom) throw()
# 855
 __attribute((const)); 
# 858
__extension__ extern lldiv_t lldiv(long long __numer, long long __denom) throw()
# 860
 __attribute((const)); 
# 872 "/usr/include/stdlib.h" 3
extern char *ecvt(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 873
 __attribute((__nonnull__(3, 4))); 
# 878
extern char *fcvt(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 879
 __attribute((__nonnull__(3, 4))); 
# 884
extern char *gcvt(double __value, int __ndigit, char * __buf) throw()
# 885
 __attribute((__nonnull__(3))); 
# 890
extern char *qecvt(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 892
 __attribute((__nonnull__(3, 4))); 
# 893
extern char *qfcvt(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign) throw()
# 895
 __attribute((__nonnull__(3, 4))); 
# 896
extern char *qgcvt(long double __value, int __ndigit, char * __buf) throw()
# 897
 __attribute((__nonnull__(3))); 
# 902
extern int ecvt_r(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 904
 __attribute((__nonnull__(3, 4, 5))); 
# 905
extern int fcvt_r(double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 907
 __attribute((__nonnull__(3, 4, 5))); 
# 909
extern int qecvt_r(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 912
 __attribute((__nonnull__(3, 4, 5))); 
# 913
extern int qfcvt_r(long double __value, int __ndigit, int *__restrict__ __decpt, int *__restrict__ __sign, char *__restrict__ __buf, size_t __len) throw()
# 916
 __attribute((__nonnull__(3, 4, 5))); 
# 922
extern int mblen(const char * __s, size_t __n) throw(); 
# 925
extern int mbtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t __n) throw(); 
# 929
extern int wctomb(char * __s, wchar_t __wchar) throw(); 
# 933
extern size_t mbstowcs(wchar_t *__restrict__ __pwcs, const char *__restrict__ __s, size_t __n) throw(); 
# 936
extern size_t wcstombs(char *__restrict__ __s, const wchar_t *__restrict__ __pwcs, size_t __n) throw(); 
# 946
extern int rpmatch(const char * __response) throw() __attribute((__nonnull__(1))); 
# 957 "/usr/include/stdlib.h" 3
extern int getsubopt(char **__restrict__ __optionp, char *const *__restrict__ __tokens, char **__restrict__ __valuep) throw()
# 960
 __attribute((__nonnull__(1, 2, 3))); 
# 968
extern int posix_openpt(int __oflag); 
# 976
extern int grantpt(int __fd) throw(); 
# 980
extern int unlockpt(int __fd) throw(); 
# 985
extern char *ptsname(int __fd) throw(); 
# 992
extern int ptsname_r(int __fd, char * __buf, size_t __buflen) throw()
# 993
 __attribute((__nonnull__(2))); 
# 996
extern int getpt(); 
# 1003
extern int getloadavg(double  __loadavg[], int __nelem) throw()
# 1004
 __attribute((__nonnull__(1))); 
# 1023 "/usr/include/stdlib.h" 3
}
# 46 "/usr/include/c++/9/bits/std_abs.h" 3
extern "C++" {
# 48
namespace std __attribute((__visibility__("default"))) { 
# 52
using ::abs;
# 56
inline long abs(long __i) { return __builtin_labs(__i); } 
# 61
inline long long abs(long long __x) { return __builtin_llabs(__x); } 
# 71 "/usr/include/c++/9/bits/std_abs.h" 3
constexpr double abs(double __x) 
# 72
{ return __builtin_fabs(__x); } 
# 75
constexpr float abs(float __x) 
# 76
{ return __builtin_fabsf(__x); } 
# 79
constexpr long double abs(long double __x) 
# 80
{ return __builtin_fabsl(__x); } 
# 85
constexpr __int128 abs(__int128 __x) { return (__x >= (0)) ? __x : (-__x); } 
# 108 "/usr/include/c++/9/bits/std_abs.h" 3
}
# 109
}
# 77 "/usr/include/c++/9/cmath" 3
extern "C++" {
# 79
namespace std __attribute((__visibility__("default"))) { 
# 83
using ::acos;
# 87
constexpr float acos(float __x) 
# 88
{ return __builtin_acosf(__x); } 
# 91
constexpr long double acos(long double __x) 
# 92
{ return __builtin_acosl(__x); } 
# 95
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 99
acos(_Tp __x) 
# 100
{ return __builtin_acos(__x); } 
# 102
using ::asin;
# 106
constexpr float asin(float __x) 
# 107
{ return __builtin_asinf(__x); } 
# 110
constexpr long double asin(long double __x) 
# 111
{ return __builtin_asinl(__x); } 
# 114
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 118
asin(_Tp __x) 
# 119
{ return __builtin_asin(__x); } 
# 121
using ::atan;
# 125
constexpr float atan(float __x) 
# 126
{ return __builtin_atanf(__x); } 
# 129
constexpr long double atan(long double __x) 
# 130
{ return __builtin_atanl(__x); } 
# 133
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 137
atan(_Tp __x) 
# 138
{ return __builtin_atan(__x); } 
# 140
using ::atan2;
# 144
constexpr float atan2(float __y, float __x) 
# 145
{ return __builtin_atan2f(__y, __x); } 
# 148
constexpr long double atan2(long double __y, long double __x) 
# 149
{ return __builtin_atan2l(__y, __x); } 
# 152
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 155
atan2(_Tp __y, _Up __x) 
# 156
{ 
# 157
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 158
return atan2((__type)__y, (__type)__x); 
# 159
} 
# 161
using ::ceil;
# 165
constexpr float ceil(float __x) 
# 166
{ return __builtin_ceilf(__x); } 
# 169
constexpr long double ceil(long double __x) 
# 170
{ return __builtin_ceill(__x); } 
# 173
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 177
ceil(_Tp __x) 
# 178
{ return __builtin_ceil(__x); } 
# 180
using ::cos;
# 184
constexpr float cos(float __x) 
# 185
{ return __builtin_cosf(__x); } 
# 188
constexpr long double cos(long double __x) 
# 189
{ return __builtin_cosl(__x); } 
# 192
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 196
cos(_Tp __x) 
# 197
{ return __builtin_cos(__x); } 
# 199
using ::cosh;
# 203
constexpr float cosh(float __x) 
# 204
{ return __builtin_coshf(__x); } 
# 207
constexpr long double cosh(long double __x) 
# 208
{ return __builtin_coshl(__x); } 
# 211
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 215
cosh(_Tp __x) 
# 216
{ return __builtin_cosh(__x); } 
# 218
using ::exp;
# 222
constexpr float exp(float __x) 
# 223
{ return __builtin_expf(__x); } 
# 226
constexpr long double exp(long double __x) 
# 227
{ return __builtin_expl(__x); } 
# 230
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 234
exp(_Tp __x) 
# 235
{ return __builtin_exp(__x); } 
# 237
using ::fabs;
# 241
constexpr float fabs(float __x) 
# 242
{ return __builtin_fabsf(__x); } 
# 245
constexpr long double fabs(long double __x) 
# 246
{ return __builtin_fabsl(__x); } 
# 249
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 253
fabs(_Tp __x) 
# 254
{ return __builtin_fabs(__x); } 
# 256
using ::floor;
# 260
constexpr float floor(float __x) 
# 261
{ return __builtin_floorf(__x); } 
# 264
constexpr long double floor(long double __x) 
# 265
{ return __builtin_floorl(__x); } 
# 268
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 272
floor(_Tp __x) 
# 273
{ return __builtin_floor(__x); } 
# 275
using ::fmod;
# 279
constexpr float fmod(float __x, float __y) 
# 280
{ return __builtin_fmodf(__x, __y); } 
# 283
constexpr long double fmod(long double __x, long double __y) 
# 284
{ return __builtin_fmodl(__x, __y); } 
# 287
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 290
fmod(_Tp __x, _Up __y) 
# 291
{ 
# 292
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 293
return fmod((__type)__x, (__type)__y); 
# 294
} 
# 296
using ::frexp;
# 300
inline float frexp(float __x, int *__exp) 
# 301
{ return __builtin_frexpf(__x, __exp); } 
# 304
inline long double frexp(long double __x, int *__exp) 
# 305
{ return __builtin_frexpl(__x, __exp); } 
# 308
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 312
frexp(_Tp __x, int *__exp) 
# 313
{ return __builtin_frexp(__x, __exp); } 
# 315
using ::ldexp;
# 319
constexpr float ldexp(float __x, int __exp) 
# 320
{ return __builtin_ldexpf(__x, __exp); } 
# 323
constexpr long double ldexp(long double __x, int __exp) 
# 324
{ return __builtin_ldexpl(__x, __exp); } 
# 327
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 331
ldexp(_Tp __x, int __exp) 
# 332
{ return __builtin_ldexp(__x, __exp); } 
# 334
using ::log;
# 338
constexpr float log(float __x) 
# 339
{ return __builtin_logf(__x); } 
# 342
constexpr long double log(long double __x) 
# 343
{ return __builtin_logl(__x); } 
# 346
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 350
log(_Tp __x) 
# 351
{ return __builtin_log(__x); } 
# 353
using ::log10;
# 357
constexpr float log10(float __x) 
# 358
{ return __builtin_log10f(__x); } 
# 361
constexpr long double log10(long double __x) 
# 362
{ return __builtin_log10l(__x); } 
# 365
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 369
log10(_Tp __x) 
# 370
{ return __builtin_log10(__x); } 
# 372
using ::modf;
# 376
inline float modf(float __x, float *__iptr) 
# 377
{ return __builtin_modff(__x, __iptr); } 
# 380
inline long double modf(long double __x, long double *__iptr) 
# 381
{ return __builtin_modfl(__x, __iptr); } 
# 384
using ::pow;
# 388
constexpr float pow(float __x, float __y) 
# 389
{ return __builtin_powf(__x, __y); } 
# 392
constexpr long double pow(long double __x, long double __y) 
# 393
{ return __builtin_powl(__x, __y); } 
# 412 "/usr/include/c++/9/cmath" 3
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 415
pow(_Tp __x, _Up __y) 
# 416
{ 
# 417
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 418
return pow((__type)__x, (__type)__y); 
# 419
} 
# 421
using ::sin;
# 425
constexpr float sin(float __x) 
# 426
{ return __builtin_sinf(__x); } 
# 429
constexpr long double sin(long double __x) 
# 430
{ return __builtin_sinl(__x); } 
# 433
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 437
sin(_Tp __x) 
# 438
{ return __builtin_sin(__x); } 
# 440
using ::sinh;
# 444
constexpr float sinh(float __x) 
# 445
{ return __builtin_sinhf(__x); } 
# 448
constexpr long double sinh(long double __x) 
# 449
{ return __builtin_sinhl(__x); } 
# 452
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 456
sinh(_Tp __x) 
# 457
{ return __builtin_sinh(__x); } 
# 459
using ::sqrt;
# 463
constexpr float sqrt(float __x) 
# 464
{ return __builtin_sqrtf(__x); } 
# 467
constexpr long double sqrt(long double __x) 
# 468
{ return __builtin_sqrtl(__x); } 
# 471
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 475
sqrt(_Tp __x) 
# 476
{ return __builtin_sqrt(__x); } 
# 478
using ::tan;
# 482
constexpr float tan(float __x) 
# 483
{ return __builtin_tanf(__x); } 
# 486
constexpr long double tan(long double __x) 
# 487
{ return __builtin_tanl(__x); } 
# 490
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 494
tan(_Tp __x) 
# 495
{ return __builtin_tan(__x); } 
# 497
using ::tanh;
# 501
constexpr float tanh(float __x) 
# 502
{ return __builtin_tanhf(__x); } 
# 505
constexpr long double tanh(long double __x) 
# 506
{ return __builtin_tanhl(__x); } 
# 509
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 513
tanh(_Tp __x) 
# 514
{ return __builtin_tanh(__x); } 
# 537 "/usr/include/c++/9/cmath" 3
constexpr int fpclassify(float __x) 
# 538
{ return __builtin_fpclassify(0, 1, 4, 3, 2, __x); 
# 539
} 
# 542
constexpr int fpclassify(double __x) 
# 543
{ return __builtin_fpclassify(0, 1, 4, 3, 2, __x); 
# 544
} 
# 547
constexpr int fpclassify(long double __x) 
# 548
{ return __builtin_fpclassify(0, 1, 4, 3, 2, __x); 
# 549
} 
# 553
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, int> ::__type 
# 556
fpclassify(_Tp __x) 
# 557
{ return (__x != 0) ? 4 : 2; } 
# 562
constexpr bool isfinite(float __x) 
# 563
{ return __builtin_isfinite(__x); } 
# 566
constexpr bool isfinite(double __x) 
# 567
{ return __builtin_isfinite(__x); } 
# 570
constexpr bool isfinite(long double __x) 
# 571
{ return __builtin_isfinite(__x); } 
# 575
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 578
isfinite(_Tp __x) 
# 579
{ return true; } 
# 584
constexpr bool isinf(float __x) 
# 585
{ return __builtin_isinf(__x); } 
# 592
constexpr bool isinf(double __x) 
# 593
{ return __builtin_isinf(__x); } 
# 597
constexpr bool isinf(long double __x) 
# 598
{ return __builtin_isinf(__x); } 
# 602
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 605
isinf(_Tp __x) 
# 606
{ return false; } 
# 611
constexpr bool isnan(float __x) 
# 612
{ return __builtin_isnan(__x); } 
# 619
constexpr bool isnan(double __x) 
# 620
{ return __builtin_isnan(__x); } 
# 624
constexpr bool isnan(long double __x) 
# 625
{ return __builtin_isnan(__x); } 
# 629
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 632
isnan(_Tp __x) 
# 633
{ return false; } 
# 638
constexpr bool isnormal(float __x) 
# 639
{ return __builtin_isnormal(__x); } 
# 642
constexpr bool isnormal(double __x) 
# 643
{ return __builtin_isnormal(__x); } 
# 646
constexpr bool isnormal(long double __x) 
# 647
{ return __builtin_isnormal(__x); } 
# 651
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 654
isnormal(_Tp __x) 
# 655
{ return (__x != 0) ? true : false; } 
# 661
constexpr bool signbit(float __x) 
# 662
{ return __builtin_signbit(__x); } 
# 665
constexpr bool signbit(double __x) 
# 666
{ return __builtin_signbit(__x); } 
# 669
constexpr bool signbit(long double __x) 
# 670
{ return __builtin_signbit(__x); } 
# 674
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, bool> ::__type 
# 677
signbit(_Tp __x) 
# 678
{ return (__x < 0) ? true : false; } 
# 683
constexpr bool isgreater(float __x, float __y) 
# 684
{ return __builtin_isgreater(__x, __y); } 
# 687
constexpr bool isgreater(double __x, double __y) 
# 688
{ return __builtin_isgreater(__x, __y); } 
# 691
constexpr bool isgreater(long double __x, long double __y) 
# 692
{ return __builtin_isgreater(__x, __y); } 
# 696
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 700
isgreater(_Tp __x, _Up __y) 
# 701
{ 
# 702
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 703
return __builtin_isgreater((__type)__x, (__type)__y); 
# 704
} 
# 709
constexpr bool isgreaterequal(float __x, float __y) 
# 710
{ return __builtin_isgreaterequal(__x, __y); } 
# 713
constexpr bool isgreaterequal(double __x, double __y) 
# 714
{ return __builtin_isgreaterequal(__x, __y); } 
# 717
constexpr bool isgreaterequal(long double __x, long double __y) 
# 718
{ return __builtin_isgreaterequal(__x, __y); } 
# 722
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 726
isgreaterequal(_Tp __x, _Up __y) 
# 727
{ 
# 728
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 729
return __builtin_isgreaterequal((__type)__x, (__type)__y); 
# 730
} 
# 735
constexpr bool isless(float __x, float __y) 
# 736
{ return __builtin_isless(__x, __y); } 
# 739
constexpr bool isless(double __x, double __y) 
# 740
{ return __builtin_isless(__x, __y); } 
# 743
constexpr bool isless(long double __x, long double __y) 
# 744
{ return __builtin_isless(__x, __y); } 
# 748
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 752
isless(_Tp __x, _Up __y) 
# 753
{ 
# 754
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 755
return __builtin_isless((__type)__x, (__type)__y); 
# 756
} 
# 761
constexpr bool islessequal(float __x, float __y) 
# 762
{ return __builtin_islessequal(__x, __y); } 
# 765
constexpr bool islessequal(double __x, double __y) 
# 766
{ return __builtin_islessequal(__x, __y); } 
# 769
constexpr bool islessequal(long double __x, long double __y) 
# 770
{ return __builtin_islessequal(__x, __y); } 
# 774
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 778
islessequal(_Tp __x, _Up __y) 
# 779
{ 
# 780
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 781
return __builtin_islessequal((__type)__x, (__type)__y); 
# 782
} 
# 787
constexpr bool islessgreater(float __x, float __y) 
# 788
{ return __builtin_islessgreater(__x, __y); } 
# 791
constexpr bool islessgreater(double __x, double __y) 
# 792
{ return __builtin_islessgreater(__x, __y); } 
# 795
constexpr bool islessgreater(long double __x, long double __y) 
# 796
{ return __builtin_islessgreater(__x, __y); } 
# 800
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 804
islessgreater(_Tp __x, _Up __y) 
# 805
{ 
# 806
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 807
return __builtin_islessgreater((__type)__x, (__type)__y); 
# 808
} 
# 813
constexpr bool isunordered(float __x, float __y) 
# 814
{ return __builtin_isunordered(__x, __y); } 
# 817
constexpr bool isunordered(double __x, double __y) 
# 818
{ return __builtin_isunordered(__x, __y); } 
# 821
constexpr bool isunordered(long double __x, long double __y) 
# 822
{ return __builtin_isunordered(__x, __y); } 
# 826
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp> ::__value && __is_arithmetic< _Up> ::__value, bool> ::__type 
# 830
isunordered(_Tp __x, _Up __y) 
# 831
{ 
# 832
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 833
return __builtin_isunordered((__type)__x, (__type)__y); 
# 834
} 
# 1065 "/usr/include/c++/9/cmath" 3
using ::double_t;
# 1066
using ::float_t;
# 1069
using ::acosh;
# 1070
using ::acoshf;
# 1071
using ::acoshl;
# 1073
using ::asinh;
# 1074
using ::asinhf;
# 1075
using ::asinhl;
# 1077
using ::atanh;
# 1078
using ::atanhf;
# 1079
using ::atanhl;
# 1081
using ::cbrt;
# 1082
using ::cbrtf;
# 1083
using ::cbrtl;
# 1085
using ::copysign;
# 1086
using ::copysignf;
# 1087
using ::copysignl;
# 1089
using ::erf;
# 1090
using ::erff;
# 1091
using ::erfl;
# 1093
using ::erfc;
# 1094
using ::erfcf;
# 1095
using ::erfcl;
# 1097
using ::exp2;
# 1098
using ::exp2f;
# 1099
using ::exp2l;
# 1101
using ::expm1;
# 1102
using ::expm1f;
# 1103
using ::expm1l;
# 1105
using ::fdim;
# 1106
using ::fdimf;
# 1107
using ::fdiml;
# 1109
using ::fma;
# 1110
using ::fmaf;
# 1111
using ::fmal;
# 1113
using ::fmax;
# 1114
using ::fmaxf;
# 1115
using ::fmaxl;
# 1117
using ::fmin;
# 1118
using ::fminf;
# 1119
using ::fminl;
# 1121
using ::hypot;
# 1122
using ::hypotf;
# 1123
using ::hypotl;
# 1125
using ::ilogb;
# 1126
using ::ilogbf;
# 1127
using ::ilogbl;
# 1129
using ::lgamma;
# 1130
using ::lgammaf;
# 1131
using ::lgammal;
# 1134
using ::llrint;
# 1135
using ::llrintf;
# 1136
using ::llrintl;
# 1138
using ::llround;
# 1139
using ::llroundf;
# 1140
using ::llroundl;
# 1143
using ::log1p;
# 1144
using ::log1pf;
# 1145
using ::log1pl;
# 1147
using ::log2;
# 1148
using ::log2f;
# 1149
using ::log2l;
# 1151
using ::logb;
# 1152
using ::logbf;
# 1153
using ::logbl;
# 1155
using ::lrint;
# 1156
using ::lrintf;
# 1157
using ::lrintl;
# 1159
using ::lround;
# 1160
using ::lroundf;
# 1161
using ::lroundl;
# 1163
using ::nan;
# 1164
using ::nanf;
# 1165
using ::nanl;
# 1167
using ::nearbyint;
# 1168
using ::nearbyintf;
# 1169
using ::nearbyintl;
# 1171
using ::nextafter;
# 1172
using ::nextafterf;
# 1173
using ::nextafterl;
# 1175
using ::nexttoward;
# 1176
using ::nexttowardf;
# 1177
using ::nexttowardl;
# 1179
using ::remainder;
# 1180
using ::remainderf;
# 1181
using ::remainderl;
# 1183
using ::remquo;
# 1184
using ::remquof;
# 1185
using ::remquol;
# 1187
using ::rint;
# 1188
using ::rintf;
# 1189
using ::rintl;
# 1191
using ::round;
# 1192
using ::roundf;
# 1193
using ::roundl;
# 1195
using ::scalbln;
# 1196
using ::scalblnf;
# 1197
using ::scalblnl;
# 1199
using ::scalbn;
# 1200
using ::scalbnf;
# 1201
using ::scalbnl;
# 1203
using ::tgamma;
# 1204
using ::tgammaf;
# 1205
using ::tgammal;
# 1207
using ::trunc;
# 1208
using ::truncf;
# 1209
using ::truncl;
# 1214
constexpr float acosh(float __x) 
# 1215
{ return __builtin_acoshf(__x); } 
# 1218
constexpr long double acosh(long double __x) 
# 1219
{ return __builtin_acoshl(__x); } 
# 1223
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1226
acosh(_Tp __x) 
# 1227
{ return __builtin_acosh(__x); } 
# 1232
constexpr float asinh(float __x) 
# 1233
{ return __builtin_asinhf(__x); } 
# 1236
constexpr long double asinh(long double __x) 
# 1237
{ return __builtin_asinhl(__x); } 
# 1241
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1244
asinh(_Tp __x) 
# 1245
{ return __builtin_asinh(__x); } 
# 1250
constexpr float atanh(float __x) 
# 1251
{ return __builtin_atanhf(__x); } 
# 1254
constexpr long double atanh(long double __x) 
# 1255
{ return __builtin_atanhl(__x); } 
# 1259
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1262
atanh(_Tp __x) 
# 1263
{ return __builtin_atanh(__x); } 
# 1268
constexpr float cbrt(float __x) 
# 1269
{ return __builtin_cbrtf(__x); } 
# 1272
constexpr long double cbrt(long double __x) 
# 1273
{ return __builtin_cbrtl(__x); } 
# 1277
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1280
cbrt(_Tp __x) 
# 1281
{ return __builtin_cbrt(__x); } 
# 1286
constexpr float copysign(float __x, float __y) 
# 1287
{ return __builtin_copysignf(__x, __y); } 
# 1290
constexpr long double copysign(long double __x, long double __y) 
# 1291
{ return __builtin_copysignl(__x, __y); } 
# 1295
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1297
copysign(_Tp __x, _Up __y) 
# 1298
{ 
# 1299
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1300
return copysign((__type)__x, (__type)__y); 
# 1301
} 
# 1306
constexpr float erf(float __x) 
# 1307
{ return __builtin_erff(__x); } 
# 1310
constexpr long double erf(long double __x) 
# 1311
{ return __builtin_erfl(__x); } 
# 1315
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1318
erf(_Tp __x) 
# 1319
{ return __builtin_erf(__x); } 
# 1324
constexpr float erfc(float __x) 
# 1325
{ return __builtin_erfcf(__x); } 
# 1328
constexpr long double erfc(long double __x) 
# 1329
{ return __builtin_erfcl(__x); } 
# 1333
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1336
erfc(_Tp __x) 
# 1337
{ return __builtin_erfc(__x); } 
# 1342
constexpr float exp2(float __x) 
# 1343
{ return __builtin_exp2f(__x); } 
# 1346
constexpr long double exp2(long double __x) 
# 1347
{ return __builtin_exp2l(__x); } 
# 1351
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1354
exp2(_Tp __x) 
# 1355
{ return __builtin_exp2(__x); } 
# 1360
constexpr float expm1(float __x) 
# 1361
{ return __builtin_expm1f(__x); } 
# 1364
constexpr long double expm1(long double __x) 
# 1365
{ return __builtin_expm1l(__x); } 
# 1369
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1372
expm1(_Tp __x) 
# 1373
{ return __builtin_expm1(__x); } 
# 1378
constexpr float fdim(float __x, float __y) 
# 1379
{ return __builtin_fdimf(__x, __y); } 
# 1382
constexpr long double fdim(long double __x, long double __y) 
# 1383
{ return __builtin_fdiml(__x, __y); } 
# 1387
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1389
fdim(_Tp __x, _Up __y) 
# 1390
{ 
# 1391
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1392
return fdim((__type)__x, (__type)__y); 
# 1393
} 
# 1398
constexpr float fma(float __x, float __y, float __z) 
# 1399
{ return __builtin_fmaf(__x, __y, __z); } 
# 1402
constexpr long double fma(long double __x, long double __y, long double __z) 
# 1403
{ return __builtin_fmal(__x, __y, __z); } 
# 1407
template< class _Tp, class _Up, class _Vp> constexpr typename __gnu_cxx::__promote_3< _Tp, _Up, _Vp> ::__type 
# 1409
fma(_Tp __x, _Up __y, _Vp __z) 
# 1410
{ 
# 1411
typedef typename __gnu_cxx::__promote_3< _Tp, _Up, _Vp> ::__type __type; 
# 1412
return fma((__type)__x, (__type)__y, (__type)__z); 
# 1413
} 
# 1418
constexpr float fmax(float __x, float __y) 
# 1419
{ return __builtin_fmaxf(__x, __y); } 
# 1422
constexpr long double fmax(long double __x, long double __y) 
# 1423
{ return __builtin_fmaxl(__x, __y); } 
# 1427
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1429
fmax(_Tp __x, _Up __y) 
# 1430
{ 
# 1431
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1432
return fmax((__type)__x, (__type)__y); 
# 1433
} 
# 1438
constexpr float fmin(float __x, float __y) 
# 1439
{ return __builtin_fminf(__x, __y); } 
# 1442
constexpr long double fmin(long double __x, long double __y) 
# 1443
{ return __builtin_fminl(__x, __y); } 
# 1447
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1449
fmin(_Tp __x, _Up __y) 
# 1450
{ 
# 1451
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1452
return fmin((__type)__x, (__type)__y); 
# 1453
} 
# 1458
constexpr float hypot(float __x, float __y) 
# 1459
{ return __builtin_hypotf(__x, __y); } 
# 1462
constexpr long double hypot(long double __x, long double __y) 
# 1463
{ return __builtin_hypotl(__x, __y); } 
# 1467
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1469
hypot(_Tp __x, _Up __y) 
# 1470
{ 
# 1471
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1472
return hypot((__type)__x, (__type)__y); 
# 1473
} 
# 1478
constexpr int ilogb(float __x) 
# 1479
{ return __builtin_ilogbf(__x); } 
# 1482
constexpr int ilogb(long double __x) 
# 1483
{ return __builtin_ilogbl(__x); } 
# 1487
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, int> ::__type 
# 1491
ilogb(_Tp __x) 
# 1492
{ return __builtin_ilogb(__x); } 
# 1497
constexpr float lgamma(float __x) 
# 1498
{ return __builtin_lgammaf(__x); } 
# 1501
constexpr long double lgamma(long double __x) 
# 1502
{ return __builtin_lgammal(__x); } 
# 1506
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1509
lgamma(_Tp __x) 
# 1510
{ return __builtin_lgamma(__x); } 
# 1515
constexpr long long llrint(float __x) 
# 1516
{ return __builtin_llrintf(__x); } 
# 1519
constexpr long long llrint(long double __x) 
# 1520
{ return __builtin_llrintl(__x); } 
# 1524
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, long long> ::__type 
# 1527
llrint(_Tp __x) 
# 1528
{ return __builtin_llrint(__x); } 
# 1533
constexpr long long llround(float __x) 
# 1534
{ return __builtin_llroundf(__x); } 
# 1537
constexpr long long llround(long double __x) 
# 1538
{ return __builtin_llroundl(__x); } 
# 1542
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, long long> ::__type 
# 1545
llround(_Tp __x) 
# 1546
{ return __builtin_llround(__x); } 
# 1551
constexpr float log1p(float __x) 
# 1552
{ return __builtin_log1pf(__x); } 
# 1555
constexpr long double log1p(long double __x) 
# 1556
{ return __builtin_log1pl(__x); } 
# 1560
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1563
log1p(_Tp __x) 
# 1564
{ return __builtin_log1p(__x); } 
# 1570
constexpr float log2(float __x) 
# 1571
{ return __builtin_log2f(__x); } 
# 1574
constexpr long double log2(long double __x) 
# 1575
{ return __builtin_log2l(__x); } 
# 1579
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1582
log2(_Tp __x) 
# 1583
{ return __builtin_log2(__x); } 
# 1588
constexpr float logb(float __x) 
# 1589
{ return __builtin_logbf(__x); } 
# 1592
constexpr long double logb(long double __x) 
# 1593
{ return __builtin_logbl(__x); } 
# 1597
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1600
logb(_Tp __x) 
# 1601
{ return __builtin_logb(__x); } 
# 1606
constexpr long lrint(float __x) 
# 1607
{ return __builtin_lrintf(__x); } 
# 1610
constexpr long lrint(long double __x) 
# 1611
{ return __builtin_lrintl(__x); } 
# 1615
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, long> ::__type 
# 1618
lrint(_Tp __x) 
# 1619
{ return __builtin_lrint(__x); } 
# 1624
constexpr long lround(float __x) 
# 1625
{ return __builtin_lroundf(__x); } 
# 1628
constexpr long lround(long double __x) 
# 1629
{ return __builtin_lroundl(__x); } 
# 1633
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, long> ::__type 
# 1636
lround(_Tp __x) 
# 1637
{ return __builtin_lround(__x); } 
# 1642
constexpr float nearbyint(float __x) 
# 1643
{ return __builtin_nearbyintf(__x); } 
# 1646
constexpr long double nearbyint(long double __x) 
# 1647
{ return __builtin_nearbyintl(__x); } 
# 1651
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1654
nearbyint(_Tp __x) 
# 1655
{ return __builtin_nearbyint(__x); } 
# 1660
constexpr float nextafter(float __x, float __y) 
# 1661
{ return __builtin_nextafterf(__x, __y); } 
# 1664
constexpr long double nextafter(long double __x, long double __y) 
# 1665
{ return __builtin_nextafterl(__x, __y); } 
# 1669
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1671
nextafter(_Tp __x, _Up __y) 
# 1672
{ 
# 1673
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1674
return nextafter((__type)__x, (__type)__y); 
# 1675
} 
# 1680
constexpr float nexttoward(float __x, long double __y) 
# 1681
{ return __builtin_nexttowardf(__x, __y); } 
# 1684
constexpr long double nexttoward(long double __x, long double __y) 
# 1685
{ return __builtin_nexttowardl(__x, __y); } 
# 1689
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1692
nexttoward(_Tp __x, long double __y) 
# 1693
{ return __builtin_nexttoward(__x, __y); } 
# 1698
constexpr float remainder(float __x, float __y) 
# 1699
{ return __builtin_remainderf(__x, __y); } 
# 1702
constexpr long double remainder(long double __x, long double __y) 
# 1703
{ return __builtin_remainderl(__x, __y); } 
# 1707
template< class _Tp, class _Up> constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1709
remainder(_Tp __x, _Up __y) 
# 1710
{ 
# 1711
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1712
return remainder((__type)__x, (__type)__y); 
# 1713
} 
# 1718
inline float remquo(float __x, float __y, int *__pquo) 
# 1719
{ return __builtin_remquof(__x, __y, __pquo); } 
# 1722
inline long double remquo(long double __x, long double __y, int *__pquo) 
# 1723
{ return __builtin_remquol(__x, __y, __pquo); } 
# 1727
template< class _Tp, class _Up> inline typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type 
# 1729
remquo(_Tp __x, _Up __y, int *__pquo) 
# 1730
{ 
# 1731
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1732
return remquo((__type)__x, (__type)__y, __pquo); 
# 1733
} 
# 1738
constexpr float rint(float __x) 
# 1739
{ return __builtin_rintf(__x); } 
# 1742
constexpr long double rint(long double __x) 
# 1743
{ return __builtin_rintl(__x); } 
# 1747
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1750
rint(_Tp __x) 
# 1751
{ return __builtin_rint(__x); } 
# 1756
constexpr float round(float __x) 
# 1757
{ return __builtin_roundf(__x); } 
# 1760
constexpr long double round(long double __x) 
# 1761
{ return __builtin_roundl(__x); } 
# 1765
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1768
round(_Tp __x) 
# 1769
{ return __builtin_round(__x); } 
# 1774
constexpr float scalbln(float __x, long __ex) 
# 1775
{ return __builtin_scalblnf(__x, __ex); } 
# 1778
constexpr long double scalbln(long double __x, long __ex) 
# 1779
{ return __builtin_scalblnl(__x, __ex); } 
# 1783
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1786
scalbln(_Tp __x, long __ex) 
# 1787
{ return __builtin_scalbln(__x, __ex); } 
# 1792
constexpr float scalbn(float __x, int __ex) 
# 1793
{ return __builtin_scalbnf(__x, __ex); } 
# 1796
constexpr long double scalbn(long double __x, int __ex) 
# 1797
{ return __builtin_scalbnl(__x, __ex); } 
# 1801
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1804
scalbn(_Tp __x, int __ex) 
# 1805
{ return __builtin_scalbn(__x, __ex); } 
# 1810
constexpr float tgamma(float __x) 
# 1811
{ return __builtin_tgammaf(__x); } 
# 1814
constexpr long double tgamma(long double __x) 
# 1815
{ return __builtin_tgammal(__x); } 
# 1819
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1822
tgamma(_Tp __x) 
# 1823
{ return __builtin_tgamma(__x); } 
# 1828
constexpr float trunc(float __x) 
# 1829
{ return __builtin_truncf(__x); } 
# 1832
constexpr long double trunc(long double __x) 
# 1833
{ return __builtin_truncl(__x); } 
# 1837
template< class _Tp> constexpr typename __gnu_cxx::__enable_if< __is_integer< _Tp> ::__value, double> ::__type 
# 1840
trunc(_Tp __x) 
# 1841
{ return __builtin_trunc(__x); } 
# 1924 "/usr/include/c++/9/cmath" 3
}
# 1930
}
# 38 "/usr/include/c++/9/math.h" 3
using std::abs;
# 39
using std::acos;
# 40
using std::asin;
# 41
using std::atan;
# 42
using std::atan2;
# 43
using std::cos;
# 44
using std::sin;
# 45
using std::tan;
# 46
using std::cosh;
# 47
using std::sinh;
# 48
using std::tanh;
# 49
using std::exp;
# 50
using std::frexp;
# 51
using std::ldexp;
# 52
using std::log;
# 53
using std::log10;
# 54
using std::modf;
# 55
using std::pow;
# 56
using std::sqrt;
# 57
using std::ceil;
# 58
using std::fabs;
# 59
using std::floor;
# 60
using std::fmod;
# 63
using std::fpclassify;
# 64
using std::isfinite;
# 65
using std::isinf;
# 66
using std::isnan;
# 67
using std::isnormal;
# 68
using std::signbit;
# 69
using std::isgreater;
# 70
using std::isgreaterequal;
# 71
using std::isless;
# 72
using std::islessequal;
# 73
using std::islessgreater;
# 74
using std::isunordered;
# 78
using std::acosh;
# 79
using std::asinh;
# 80
using std::atanh;
# 81
using std::cbrt;
# 82
using std::copysign;
# 83
using std::erf;
# 84
using std::erfc;
# 85
using std::exp2;
# 86
using std::expm1;
# 87
using std::fdim;
# 88
using std::fma;
# 89
using std::fmax;
# 90
using std::fmin;
# 91
using std::hypot;
# 92
using std::ilogb;
# 93
using std::lgamma;
# 94
using std::llrint;
# 95
using std::llround;
# 96
using std::log1p;
# 97
using std::log2;
# 98
using std::logb;
# 99
using std::lrint;
# 100
using std::lround;
# 101
using std::nearbyint;
# 102
using std::nextafter;
# 103
using std::nexttoward;
# 104
using std::remainder;
# 105
using std::remquo;
# 106
using std::rint;
# 107
using std::round;
# 108
using std::scalbln;
# 109
using std::scalbn;
# 110
using std::tgamma;
# 111
using std::trunc;
# 121 "/usr/include/c++/9/cstdlib" 3
extern "C++" {
# 123
namespace std __attribute((__visibility__("default"))) { 
# 127
using ::div_t;
# 128
using ::ldiv_t;
# 130
using ::abort;
# 134
using ::atexit;
# 137
using ::at_quick_exit;
# 140
using ::atof;
# 141
using ::atoi;
# 142
using ::atol;
# 143
using ::bsearch;
# 144
using ::calloc;
# 145
using ::div;
# 146
using ::exit;
# 147
using ::free;
# 148
using ::getenv;
# 149
using ::labs;
# 150
using ::ldiv;
# 151
using ::malloc;
# 153
using ::mblen;
# 154
using ::mbstowcs;
# 155
using ::mbtowc;
# 157
using ::qsort;
# 160
using ::quick_exit;
# 163
using ::rand;
# 164
using ::realloc;
# 165
using ::srand;
# 166
using ::strtod;
# 167
using ::strtol;
# 168
using ::strtoul;
# 169
using ::system;
# 171
using ::wcstombs;
# 172
using ::wctomb;
# 177
inline ldiv_t div(long __i, long __j) { return ldiv(__i, __j); } 
# 182
}
# 195 "/usr/include/c++/9/cstdlib" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 200
using ::lldiv_t;
# 206
using ::_Exit;
# 210
using ::llabs;
# 213
inline lldiv_t div(long long __n, long long __d) 
# 214
{ lldiv_t __q; (__q.quot) = (__n / __d); (__q.rem) = (__n % __d); return __q; } 
# 216
using ::lldiv;
# 227 "/usr/include/c++/9/cstdlib" 3
using ::atoll;
# 228
using ::strtoll;
# 229
using ::strtoull;
# 231
using ::strtof;
# 232
using ::strtold;
# 235
}
# 237
namespace std { 
# 240
using __gnu_cxx::lldiv_t;
# 242
using __gnu_cxx::_Exit;
# 244
using __gnu_cxx::llabs;
# 245
using __gnu_cxx::div;
# 246
using __gnu_cxx::lldiv;
# 248
using __gnu_cxx::atoll;
# 249
using __gnu_cxx::strtof;
# 250
using __gnu_cxx::strtoll;
# 251
using __gnu_cxx::strtoull;
# 252
using __gnu_cxx::strtold;
# 253
}
# 257
}
# 38 "/usr/include/c++/9/stdlib.h" 3
using std::abort;
# 39
using std::atexit;
# 40
using std::exit;
# 43
using std::at_quick_exit;
# 46
using std::quick_exit;
# 54
using std::abs;
# 55
using std::atof;
# 56
using std::atoi;
# 57
using std::atol;
# 58
using std::bsearch;
# 59
using std::calloc;
# 60
using std::div;
# 61
using std::free;
# 62
using std::getenv;
# 63
using std::labs;
# 64
using std::ldiv;
# 65
using std::malloc;
# 67
using std::mblen;
# 68
using std::mbstowcs;
# 69
using std::mbtowc;
# 71
using std::qsort;
# 72
using std::rand;
# 73
using std::realloc;
# 74
using std::srand;
# 75
using std::strtod;
# 76
using std::strtol;
# 77
using std::strtoul;
# 78
using std::system;
# 80
using std::wcstombs;
# 81
using std::wctomb;
# 9146 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
namespace std { 
# 9147
constexpr bool signbit(float x); 
# 9148
constexpr bool signbit(double x); 
# 9149
constexpr bool signbit(long double x); 
# 9150
constexpr bool isfinite(float x); 
# 9151
constexpr bool isfinite(double x); 
# 9152
constexpr bool isfinite(long double x); 
# 9153
constexpr bool isnan(float x); 
# 9158
constexpr bool isnan(double x); 
# 9160
constexpr bool isnan(long double x); 
# 9161
constexpr bool isinf(float x); 
# 9166
constexpr bool isinf(double x); 
# 9168
constexpr bool isinf(long double x); 
# 9169
}
# 9322 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
namespace std { 
# 9324
template< class T> extern T __pow_helper(T, int); 
# 9325
template< class T> extern T __cmath_power(T, unsigned); 
# 9326
}
# 9328
using std::abs;
# 9329
using std::fabs;
# 9330
using std::ceil;
# 9331
using std::floor;
# 9332
using std::sqrt;
# 9334
using std::pow;
# 9336
using std::log;
# 9337
using std::log10;
# 9338
using std::fmod;
# 9339
using std::modf;
# 9340
using std::exp;
# 9341
using std::frexp;
# 9342
using std::ldexp;
# 9343
using std::asin;
# 9344
using std::sin;
# 9345
using std::sinh;
# 9346
using std::acos;
# 9347
using std::cos;
# 9348
using std::cosh;
# 9349
using std::atan;
# 9350
using std::atan2;
# 9351
using std::tan;
# 9352
using std::tanh;
# 9723 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
namespace std { 
# 9732 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern inline long long abs(long long); 
# 9742 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern inline long abs(long); 
# 9743
extern constexpr float abs(float); 
# 9744
extern constexpr double abs(double); 
# 9745
extern constexpr float fabs(float); 
# 9746
extern constexpr float ceil(float); 
# 9747
extern constexpr float floor(float); 
# 9748
extern constexpr float sqrt(float); 
# 9749
extern constexpr float pow(float, float); 
# 9754
template< class _Tp, class _Up> extern constexpr typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type pow(_Tp, _Up); 
# 9764
extern constexpr float log(float); 
# 9765
extern constexpr float log10(float); 
# 9766
extern constexpr float fmod(float, float); 
# 9767
extern inline float modf(float, float *); 
# 9768
extern constexpr float exp(float); 
# 9769
extern inline float frexp(float, int *); 
# 9770
extern constexpr float ldexp(float, int); 
# 9771
extern constexpr float asin(float); 
# 9772
extern constexpr float sin(float); 
# 9773
extern constexpr float sinh(float); 
# 9774
extern constexpr float acos(float); 
# 9775
extern constexpr float cos(float); 
# 9776
extern constexpr float cosh(float); 
# 9777
extern constexpr float atan(float); 
# 9778
extern constexpr float atan2(float, float); 
# 9779
extern constexpr float tan(float); 
# 9780
extern constexpr float tanh(float); 
# 9859 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
}
# 9965 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
namespace std { 
# 9966
constexpr float logb(float a); 
# 9967
constexpr int ilogb(float a); 
# 9968
constexpr float scalbn(float a, int b); 
# 9969
constexpr float scalbln(float a, long b); 
# 9970
constexpr float exp2(float a); 
# 9971
constexpr float expm1(float a); 
# 9972
constexpr float log2(float a); 
# 9973
constexpr float log1p(float a); 
# 9974
constexpr float acosh(float a); 
# 9975
constexpr float asinh(float a); 
# 9976
constexpr float atanh(float a); 
# 9977
constexpr float hypot(float a, float b); 
# 9978
constexpr float cbrt(float a); 
# 9979
constexpr float erf(float a); 
# 9980
constexpr float erfc(float a); 
# 9981
constexpr float lgamma(float a); 
# 9982
constexpr float tgamma(float a); 
# 9983
constexpr float copysign(float a, float b); 
# 9984
constexpr float nextafter(float a, float b); 
# 9985
constexpr float remainder(float a, float b); 
# 9986
inline float remquo(float a, float b, int * quo); 
# 9987
constexpr float round(float a); 
# 9988
constexpr long lround(float a); 
# 9989
constexpr long long llround(float a); 
# 9990
constexpr float trunc(float a); 
# 9991
constexpr float rint(float a); 
# 9992
constexpr long lrint(float a); 
# 9993
constexpr long long llrint(float a); 
# 9994
constexpr float nearbyint(float a); 
# 9995
constexpr float fdim(float a, float b); 
# 9996
constexpr float fma(float a, float b, float c); 
# 9997
constexpr float fmax(float a, float b); 
# 9998
constexpr float fmin(float a, float b); 
# 9999
}
# 10104 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline float exp10(const float a); 
# 10106
static inline float rsqrt(const float a); 
# 10108
static inline float rcbrt(const float a); 
# 10110
static inline float sinpi(const float a); 
# 10112
static inline float cospi(const float a); 
# 10114
static inline void sincospi(const float a, float *const sptr, float *const cptr); 
# 10116
static inline void sincos(const float a, float *const sptr, float *const cptr); 
# 10118
static inline float j0(const float a); 
# 10120
static inline float j1(const float a); 
# 10122
static inline float jn(const int n, const float a); 
# 10124
static inline float y0(const float a); 
# 10126
static inline float y1(const float a); 
# 10128
static inline float yn(const int n, const float a); 
# 10130
__attribute__((unused)) static inline float cyl_bessel_i0(const float a); 
# 10132
__attribute__((unused)) static inline float cyl_bessel_i1(const float a); 
# 10134
static inline float erfinv(const float a); 
# 10136
static inline float erfcinv(const float a); 
# 10138
static inline float normcdfinv(const float a); 
# 10140
static inline float normcdf(const float a); 
# 10142
static inline float erfcx(const float a); 
# 10144
static inline double copysign(const double a, const float b); 
# 10146
static inline double copysign(const float a, const double b); 
# 10154
static inline unsigned min(const unsigned a, const unsigned b); 
# 10162
static inline unsigned min(const int a, const unsigned b); 
# 10170
static inline unsigned min(const unsigned a, const int b); 
# 10178
static inline long min(const long a, const long b); 
# 10186
static inline unsigned long min(const unsigned long a, const unsigned long b); 
# 10194
static inline unsigned long min(const long a, const unsigned long b); 
# 10202
static inline unsigned long min(const unsigned long a, const long b); 
# 10210
static inline long long min(const long long a, const long long b); 
# 10218
static inline unsigned long long min(const unsigned long long a, const unsigned long long b); 
# 10226
static inline unsigned long long min(const long long a, const unsigned long long b); 
# 10234
static inline unsigned long long min(const unsigned long long a, const long long b); 
# 10245 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline float min(const float a, const float b); 
# 10256 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline double min(const double a, const double b); 
# 10266 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline double min(const float a, const double b); 
# 10276 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline double min(const double a, const float b); 
# 10284
static inline unsigned max(const unsigned a, const unsigned b); 
# 10292
static inline unsigned max(const int a, const unsigned b); 
# 10300
static inline unsigned max(const unsigned a, const int b); 
# 10308
static inline long max(const long a, const long b); 
# 10316
static inline unsigned long max(const unsigned long a, const unsigned long b); 
# 10324
static inline unsigned long max(const long a, const unsigned long b); 
# 10332
static inline unsigned long max(const unsigned long a, const long b); 
# 10340
static inline long long max(const long long a, const long long b); 
# 10348
static inline unsigned long long max(const unsigned long long a, const unsigned long long b); 
# 10356
static inline unsigned long long max(const long long a, const unsigned long long b); 
# 10364
static inline unsigned long long max(const unsigned long long a, const long long b); 
# 10375 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline float max(const float a, const float b); 
# 10386 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline double max(const double a, const double b); 
# 10396 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline double max(const float a, const double b); 
# 10406 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
static inline double max(const double a, const float b); 
# 10417 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
extern "C" {
# 10418
__attribute__((unused)) inline void *__nv_aligned_device_malloc(size_t size, size_t align) 
# 10419
{int volatile ___ = 1;(void)size;(void)align;
# 10422
::exit(___);}
#if 0
# 10419
{ 
# 10420
__attribute__((unused)) void *__nv_aligned_device_malloc_impl(size_t, size_t); 
# 10421
return __nv_aligned_device_malloc_impl(size, align); 
# 10422
} 
#endif
# 10423 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.h"
}
# 758 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.hpp"
static inline float exp10(const float a) 
# 759
{ 
# 760
return exp10f(a); 
# 761
} 
# 763
static inline float rsqrt(const float a) 
# 764
{ 
# 765
return rsqrtf(a); 
# 766
} 
# 768
static inline float rcbrt(const float a) 
# 769
{ 
# 770
return rcbrtf(a); 
# 771
} 
# 773
static inline float sinpi(const float a) 
# 774
{ 
# 775
return sinpif(a); 
# 776
} 
# 778
static inline float cospi(const float a) 
# 779
{ 
# 780
return cospif(a); 
# 781
} 
# 783
static inline void sincospi(const float a, float *const sptr, float *const cptr) 
# 784
{ 
# 785
sincospif(a, sptr, cptr); 
# 786
} 
# 788
static inline void sincos(const float a, float *const sptr, float *const cptr) 
# 789
{ 
# 790
sincosf(a, sptr, cptr); 
# 791
} 
# 793
static inline float j0(const float a) 
# 794
{ 
# 795
return j0f(a); 
# 796
} 
# 798
static inline float j1(const float a) 
# 799
{ 
# 800
return j1f(a); 
# 801
} 
# 803
static inline float jn(const int n, const float a) 
# 804
{ 
# 805
return jnf(n, a); 
# 806
} 
# 808
static inline float y0(const float a) 
# 809
{ 
# 810
return y0f(a); 
# 811
} 
# 813
static inline float y1(const float a) 
# 814
{ 
# 815
return y1f(a); 
# 816
} 
# 818
static inline float yn(const int n, const float a) 
# 819
{ 
# 820
return ynf(n, a); 
# 821
} 
# 823
__attribute__((unused)) static inline float cyl_bessel_i0(const float a) 
# 824
{int volatile ___ = 1;(void)a;
# 826
::exit(___);}
#if 0
# 824
{ 
# 825
return cyl_bessel_i0f(a); 
# 826
} 
#endif
# 828 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.hpp"
__attribute__((unused)) static inline float cyl_bessel_i1(const float a) 
# 829
{int volatile ___ = 1;(void)a;
# 831
::exit(___);}
#if 0
# 829
{ 
# 830
return cyl_bessel_i1f(a); 
# 831
} 
#endif
# 833 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.hpp"
static inline float erfinv(const float a) 
# 834
{ 
# 835
return erfinvf(a); 
# 836
} 
# 838
static inline float erfcinv(const float a) 
# 839
{ 
# 840
return erfcinvf(a); 
# 841
} 
# 843
static inline float normcdfinv(const float a) 
# 844
{ 
# 845
return normcdfinvf(a); 
# 846
} 
# 848
static inline float normcdf(const float a) 
# 849
{ 
# 850
return normcdff(a); 
# 851
} 
# 853
static inline float erfcx(const float a) 
# 854
{ 
# 855
return erfcxf(a); 
# 856
} 
# 858
static inline double copysign(const double a, const float b) 
# 859
{ 
# 860
return copysign(a, static_cast< double>(b)); 
# 861
} 
# 863
static inline double copysign(const float a, const double b) 
# 864
{ 
# 865
return copysign(static_cast< double>(a), b); 
# 866
} 
# 868
static inline unsigned min(const unsigned a, const unsigned b) 
# 869
{ 
# 870
return umin(a, b); 
# 871
} 
# 873
static inline unsigned min(const int a, const unsigned b) 
# 874
{ 
# 875
return umin(static_cast< unsigned>(a), b); 
# 876
} 
# 878
static inline unsigned min(const unsigned a, const int b) 
# 879
{ 
# 880
return umin(a, static_cast< unsigned>(b)); 
# 881
} 
# 883
static inline long min(const long a, const long b) 
# 884
{ 
# 885
long retval; 
# 891
if (sizeof(long) == sizeof(int)) { 
# 895
retval = (static_cast< long>(min(static_cast< int>(a), static_cast< int>(b)))); 
# 896
} else { 
# 897
retval = (static_cast< long>(llmin(static_cast< long long>(a), static_cast< long long>(b)))); 
# 898
}  
# 899
return retval; 
# 900
} 
# 902
static inline unsigned long min(const unsigned long a, const unsigned long b) 
# 903
{ 
# 904
unsigned long retval; 
# 908
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 912
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
# 913
} else { 
# 914
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned long long>(a), static_cast< unsigned long long>(b)))); 
# 915
}  
# 916
return retval; 
# 917
} 
# 919
static inline unsigned long min(const long a, const unsigned long b) 
# 920
{ 
# 921
unsigned long retval; 
# 925
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 929
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
# 930
} else { 
# 931
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned long long>(a), static_cast< unsigned long long>(b)))); 
# 932
}  
# 933
return retval; 
# 934
} 
# 936
static inline unsigned long min(const unsigned long a, const long b) 
# 937
{ 
# 938
unsigned long retval; 
# 942
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 946
retval = (static_cast< unsigned long>(umin(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
# 947
} else { 
# 948
retval = (static_cast< unsigned long>(ullmin(static_cast< unsigned long long>(a), static_cast< unsigned long long>(b)))); 
# 949
}  
# 950
return retval; 
# 951
} 
# 953
static inline long long min(const long long a, const long long b) 
# 954
{ 
# 955
return llmin(a, b); 
# 956
} 
# 958
static inline unsigned long long min(const unsigned long long a, const unsigned long long b) 
# 959
{ 
# 960
return ullmin(a, b); 
# 961
} 
# 963
static inline unsigned long long min(const long long a, const unsigned long long b) 
# 964
{ 
# 965
return ullmin(static_cast< unsigned long long>(a), b); 
# 966
} 
# 968
static inline unsigned long long min(const unsigned long long a, const long long b) 
# 969
{ 
# 970
return ullmin(a, static_cast< unsigned long long>(b)); 
# 971
} 
# 973
static inline float min(const float a, const float b) 
# 974
{ 
# 975
return fminf(a, b); 
# 976
} 
# 978
static inline double min(const double a, const double b) 
# 979
{ 
# 980
return fmin(a, b); 
# 981
} 
# 983
static inline double min(const float a, const double b) 
# 984
{ 
# 985
return fmin(static_cast< double>(a), b); 
# 986
} 
# 988
static inline double min(const double a, const float b) 
# 989
{ 
# 990
return fmin(a, static_cast< double>(b)); 
# 991
} 
# 993
static inline unsigned max(const unsigned a, const unsigned b) 
# 994
{ 
# 995
return umax(a, b); 
# 996
} 
# 998
static inline unsigned max(const int a, const unsigned b) 
# 999
{ 
# 1000
return umax(static_cast< unsigned>(a), b); 
# 1001
} 
# 1003
static inline unsigned max(const unsigned a, const int b) 
# 1004
{ 
# 1005
return umax(a, static_cast< unsigned>(b)); 
# 1006
} 
# 1008
static inline long max(const long a, const long b) 
# 1009
{ 
# 1010
long retval; 
# 1015
if (sizeof(long) == sizeof(int)) { 
# 1019
retval = (static_cast< long>(max(static_cast< int>(a), static_cast< int>(b)))); 
# 1020
} else { 
# 1021
retval = (static_cast< long>(llmax(static_cast< long long>(a), static_cast< long long>(b)))); 
# 1022
}  
# 1023
return retval; 
# 1024
} 
# 1026
static inline unsigned long max(const unsigned long a, const unsigned long b) 
# 1027
{ 
# 1028
unsigned long retval; 
# 1032
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 1036
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
# 1037
} else { 
# 1038
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned long long>(a), static_cast< unsigned long long>(b)))); 
# 1039
}  
# 1040
return retval; 
# 1041
} 
# 1043
static inline unsigned long max(const long a, const unsigned long b) 
# 1044
{ 
# 1045
unsigned long retval; 
# 1049
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 1053
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
# 1054
} else { 
# 1055
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned long long>(a), static_cast< unsigned long long>(b)))); 
# 1056
}  
# 1057
return retval; 
# 1058
} 
# 1060
static inline unsigned long max(const unsigned long a, const long b) 
# 1061
{ 
# 1062
unsigned long retval; 
# 1066
if (sizeof(unsigned long) == sizeof(unsigned)) { 
# 1070
retval = (static_cast< unsigned long>(umax(static_cast< unsigned>(a), static_cast< unsigned>(b)))); 
# 1071
} else { 
# 1072
retval = (static_cast< unsigned long>(ullmax(static_cast< unsigned long long>(a), static_cast< unsigned long long>(b)))); 
# 1073
}  
# 1074
return retval; 
# 1075
} 
# 1077
static inline long long max(const long long a, const long long b) 
# 1078
{ 
# 1079
return llmax(a, b); 
# 1080
} 
# 1082
static inline unsigned long long max(const unsigned long long a, const unsigned long long b) 
# 1083
{ 
# 1084
return ullmax(a, b); 
# 1085
} 
# 1087
static inline unsigned long long max(const long long a, const unsigned long long b) 
# 1088
{ 
# 1089
return ullmax(static_cast< unsigned long long>(a), b); 
# 1090
} 
# 1092
static inline unsigned long long max(const unsigned long long a, const long long b) 
# 1093
{ 
# 1094
return ullmax(a, static_cast< unsigned long long>(b)); 
# 1095
} 
# 1097
static inline float max(const float a, const float b) 
# 1098
{ 
# 1099
return fmaxf(a, b); 
# 1100
} 
# 1102
static inline double max(const double a, const double b) 
# 1103
{ 
# 1104
return fmax(a, b); 
# 1105
} 
# 1107
static inline double max(const float a, const double b) 
# 1108
{ 
# 1109
return fmax(static_cast< double>(a), b); 
# 1110
} 
# 1112
static inline double max(const double a, const float b) 
# 1113
{ 
# 1114
return fmax(a, static_cast< double>(b)); 
# 1115
} 
# 1126 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/math_functions.hpp"
inline int min(const int a, const int b) 
# 1127
{ 
# 1128
return (a < b) ? a : b; 
# 1129
} 
# 1131
inline unsigned umin(const unsigned a, const unsigned b) 
# 1132
{ 
# 1133
return (a < b) ? a : b; 
# 1134
} 
# 1136
inline long long llmin(const long long a, const long long b) 
# 1137
{ 
# 1138
return (a < b) ? a : b; 
# 1139
} 
# 1141
inline unsigned long long ullmin(const unsigned long long a, const unsigned long long 
# 1142
b) 
# 1143
{ 
# 1144
return (a < b) ? a : b; 
# 1145
} 
# 1147
inline int max(const int a, const int b) 
# 1148
{ 
# 1149
return (a > b) ? a : b; 
# 1150
} 
# 1152
inline unsigned umax(const unsigned a, const unsigned b) 
# 1153
{ 
# 1154
return (a > b) ? a : b; 
# 1155
} 
# 1157
inline long long llmax(const long long a, const long long b) 
# 1158
{ 
# 1159
return (a > b) ? a : b; 
# 1160
} 
# 1162
inline unsigned long long ullmax(const unsigned long long a, const unsigned long long 
# 1163
b) 
# 1164
{ 
# 1165
return (a > b) ? a : b; 
# 1166
} 
# 74 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_surface_types.h"
template< class T, int dim = 1> 
# 75
struct surface : public surfaceReference { 
# 78
surface() 
# 79
{ 
# 80
(channelDesc) = cudaCreateChannelDesc< T> (); 
# 81
} 
# 83
surface(cudaChannelFormatDesc desc) 
# 84
{ 
# 85
(channelDesc) = desc; 
# 86
} 
# 88
}; 
# 90
template< int dim> 
# 91
struct surface< void, dim>  : public surfaceReference { 
# 94
surface() 
# 95
{ 
# 96
(channelDesc) = cudaCreateChannelDesc< void> (); 
# 97
} 
# 99
}; 
# 74 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
# 75
struct texture : public textureReference { 
# 78
texture(int norm = 0, cudaTextureFilterMode 
# 79
fMode = cudaFilterModePoint, cudaTextureAddressMode 
# 80
aMode = cudaAddressModeClamp) 
# 81
{ 
# 82
(normalized) = norm; 
# 83
(filterMode) = fMode; 
# 84
((addressMode)[0]) = aMode; 
# 85
((addressMode)[1]) = aMode; 
# 86
((addressMode)[2]) = aMode; 
# 87
(channelDesc) = cudaCreateChannelDesc< T> (); 
# 88
(sRGB) = 0; 
# 89
} 
# 91
texture(int norm, cudaTextureFilterMode 
# 92
fMode, cudaTextureAddressMode 
# 93
aMode, cudaChannelFormatDesc 
# 94
desc) 
# 95
{ 
# 96
(normalized) = norm; 
# 97
(filterMode) = fMode; 
# 98
((addressMode)[0]) = aMode; 
# 99
((addressMode)[1]) = aMode; 
# 100
((addressMode)[2]) = aMode; 
# 101
(channelDesc) = desc; 
# 102
(sRGB) = 0; 
# 103
} 
# 105
}; 
# 89 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.h"
extern "C" {
# 3207 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.h"
}
# 3229 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.h"
__attribute((deprecated("mulhi() is deprecated in favor of __mulhi() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning)."))) __attribute__((unused)) static inline int mulhi(const int a, const int b); 
# 3231
__attribute((deprecated("mulhi() is deprecated in favor of __mulhi() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning)."))) __attribute__((unused)) static inline unsigned mulhi(const unsigned a, const unsigned b); 
# 3233
__attribute((deprecated("mulhi() is deprecated in favor of __mulhi() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning)."))) __attribute__((unused)) static inline unsigned mulhi(const int a, const unsigned b); 
# 3235
__attribute((deprecated("mulhi() is deprecated in favor of __mulhi() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning)."))) __attribute__((unused)) static inline unsigned mulhi(const unsigned a, const int b); 
# 3237
__attribute((deprecated("mul64hi() is deprecated in favor of __mul64hi() and may be removed in a future release (Use -Wno-deprecated-declarations to supp" "ress this warning)."))) __attribute__((unused)) static inline long long mul64hi(const long long a, const long long b); 
# 3239
__attribute((deprecated("mul64hi() is deprecated in favor of __mul64hi() and may be removed in a future release (Use -Wno-deprecated-declarations to supp" "ress this warning)."))) __attribute__((unused)) static inline unsigned long long mul64hi(const unsigned long long a, const unsigned long long b); 
# 3241
__attribute((deprecated("mul64hi() is deprecated in favor of __mul64hi() and may be removed in a future release (Use -Wno-deprecated-declarations to supp" "ress this warning)."))) __attribute__((unused)) static inline unsigned long long mul64hi(const long long a, const unsigned long long b); 
# 3243
__attribute((deprecated("mul64hi() is deprecated in favor of __mul64hi() and may be removed in a future release (Use -Wno-deprecated-declarations to supp" "ress this warning)."))) __attribute__((unused)) static inline unsigned long long mul64hi(const unsigned long long a, const long long b); 
# 3245
__attribute((deprecated("float_as_int() is deprecated in favor of __float_as_int() and may be removed in a future release (Use -Wno-deprecated-declaratio" "ns to suppress this warning)."))) __attribute__((unused)) static inline int float_as_int(const float a); 
# 3247
__attribute((deprecated("int_as_float() is deprecated in favor of __int_as_float() and may be removed in a future release (Use -Wno-deprecated-declaratio" "ns to suppress this warning)."))) __attribute__((unused)) static inline float int_as_float(const int a); 
# 3249
__attribute((deprecated("float_as_uint() is deprecated in favor of __float_as_uint() and may be removed in a future release (Use -Wno-deprecated-declarat" "ions to suppress this warning)."))) __attribute__((unused)) static inline unsigned float_as_uint(const float a); 
# 3251
__attribute((deprecated("uint_as_float() is deprecated in favor of __uint_as_float() and may be removed in a future release (Use -Wno-deprecated-declarat" "ions to suppress this warning)."))) __attribute__((unused)) static inline float uint_as_float(const unsigned a); 
# 3253
__attribute((deprecated("saturate() is deprecated in favor of __saturatef() and may be removed in a future release (Use -Wno-deprecated-declarations to s" "uppress this warning)."))) __attribute__((unused)) static inline float saturate(const float a); 
# 3255
__attribute((deprecated("mul24() is deprecated in favor of __mul24() and may be removed in a future release (Use -Wno-deprecated-declarations to suppress" " this warning)."))) __attribute__((unused)) static inline int mul24(const int a, const int b); 
# 3257
__attribute((deprecated("umul24() is deprecated in favor of __umul24() and may be removed in a future release (Use -Wno-deprecated-declarations to suppre" "ss this warning)."))) __attribute__((unused)) static inline unsigned umul24(const unsigned a, const unsigned b); 
# 3259
__attribute((deprecated("float2int() is deprecated in favor of __float2int_ru|_rd|_rn|_rz() and may be removed in a future release (Use -Wno-deprecated-d" "eclarations to suppress this warning)."))) __attribute__((unused)) static inline int float2int(const float a, const cudaRoundMode mode = cudaRoundZero); 
# 3261
__attribute((deprecated("float2uint() is deprecated in favor of __float2uint_ru|_rd|_rn|_rz() and may be removed in a future release (Use -Wno-deprecated" "-declarations to suppress this warning)."))) __attribute__((unused)) static inline unsigned float2uint(const float a, const cudaRoundMode mode = cudaRoundZero); 
# 3263
__attribute((deprecated("int2float() is deprecated in favor of __int2float_ru|_rd|_rn|_rz() and may be removed in a future release (Use -Wno-deprecated-d" "eclarations to suppress this warning)."))) __attribute__((unused)) static inline float int2float(const int a, const cudaRoundMode mode = cudaRoundNearest); 
# 3265
__attribute((deprecated("uint2float() is deprecated in favor of __uint2float_ru|_rd|_rn|_rz() and may be removed in a future release (Use -Wno-deprecated" "-declarations to suppress this warning)."))) __attribute__((unused)) static inline float uint2float(const unsigned a, const cudaRoundMode mode = cudaRoundNearest); 
# 90 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline int mulhi(const int a, const int b) 
# 91
{int volatile ___ = 1;(void)a;(void)b;
# 93
::exit(___);}
#if 0
# 91
{ 
# 92
return __mulhi(a, b); 
# 93
} 
#endif
# 95 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(const unsigned a, const unsigned b) 
# 96
{int volatile ___ = 1;(void)a;(void)b;
# 98
::exit(___);}
#if 0
# 96
{ 
# 97
return __umulhi(a, b); 
# 98
} 
#endif
# 100 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(const int a, const unsigned b) 
# 101
{int volatile ___ = 1;(void)a;(void)b;
# 103
::exit(___);}
#if 0
# 101
{ 
# 102
return __umulhi(static_cast< unsigned>(a), b); 
# 103
} 
#endif
# 105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned mulhi(const unsigned a, const int b) 
# 106
{int volatile ___ = 1;(void)a;(void)b;
# 108
::exit(___);}
#if 0
# 106
{ 
# 107
return __umulhi(a, static_cast< unsigned>(b)); 
# 108
} 
#endif
# 110 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline long long mul64hi(const long long a, const long long b) 
# 111
{int volatile ___ = 1;(void)a;(void)b;
# 113
::exit(___);}
#if 0
# 111
{ 
# 112
return __mul64hi(a, b); 
# 113
} 
#endif
# 115 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(const unsigned long long a, const unsigned long long b) 
# 116
{int volatile ___ = 1;(void)a;(void)b;
# 118
::exit(___);}
#if 0
# 116
{ 
# 117
return __umul64hi(a, b); 
# 118
} 
#endif
# 120 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(const long long a, const unsigned long long b) 
# 121
{int volatile ___ = 1;(void)a;(void)b;
# 123
::exit(___);}
#if 0
# 121
{ 
# 122
return __umul64hi(static_cast< unsigned long long>(a), b); 
# 123
} 
#endif
# 125 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned long long mul64hi(const unsigned long long a, const long long b) 
# 126
{int volatile ___ = 1;(void)a;(void)b;
# 128
::exit(___);}
#if 0
# 126
{ 
# 127
return __umul64hi(a, static_cast< unsigned long long>(b)); 
# 128
} 
#endif
# 130 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline int float_as_int(const float a) 
# 131
{int volatile ___ = 1;(void)a;
# 133
::exit(___);}
#if 0
# 131
{ 
# 132
return __float_as_int(a); 
# 133
} 
#endif
# 135 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float int_as_float(const int a) 
# 136
{int volatile ___ = 1;(void)a;
# 138
::exit(___);}
#if 0
# 136
{ 
# 137
return __int_as_float(a); 
# 138
} 
#endif
# 140 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned float_as_uint(const float a) 
# 141
{int volatile ___ = 1;(void)a;
# 143
::exit(___);}
#if 0
# 141
{ 
# 142
return __float_as_uint(a); 
# 143
} 
#endif
# 145 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float uint_as_float(const unsigned a) 
# 146
{int volatile ___ = 1;(void)a;
# 148
::exit(___);}
#if 0
# 146
{ 
# 147
return __uint_as_float(a); 
# 148
} 
#endif
# 149 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float saturate(const float a) 
# 150
{int volatile ___ = 1;(void)a;
# 152
::exit(___);}
#if 0
# 150
{ 
# 151
return __saturatef(a); 
# 152
} 
#endif
# 154 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline int mul24(const int a, const int b) 
# 155
{int volatile ___ = 1;(void)a;(void)b;
# 157
::exit(___);}
#if 0
# 155
{ 
# 156
return __mul24(a, b); 
# 157
} 
#endif
# 159 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned umul24(const unsigned a, const unsigned b) 
# 160
{int volatile ___ = 1;(void)a;(void)b;
# 162
::exit(___);}
#if 0
# 160
{ 
# 161
return __umul24(a, b); 
# 162
} 
#endif
# 164 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline int float2int(const float a, const cudaRoundMode mode) 
# 165
{int volatile ___ = 1;(void)a;(void)mode;
# 170
::exit(___);}
#if 0
# 165
{ 
# 166
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
# 170
} 
#endif
# 172 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline unsigned float2uint(const float a, const cudaRoundMode mode) 
# 173
{int volatile ___ = 1;(void)a;(void)mode;
# 178
::exit(___);}
#if 0
# 173
{ 
# 174
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
# 178
} 
#endif
# 180 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float int2float(const int a, const cudaRoundMode mode) 
# 181
{int volatile ___ = 1;(void)a;(void)mode;
# 186
::exit(___);}
#if 0
# 181
{ 
# 182
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
# 186
} 
#endif
# 188 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.hpp"
__attribute__((unused)) static inline float uint2float(const unsigned a, const cudaRoundMode mode) 
# 189
{int volatile ___ = 1;(void)a;(void)mode;
# 194
::exit(___);}
#if 0
# 189
{ 
# 190
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
# 194
} 
#endif
# 106 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 106
{ } 
#endif
# 108 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 108
{ } 
#endif
# 110 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicSub(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 110
{ } 
#endif
# 112 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicSub(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 112
{ } 
#endif
# 114 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 114
{ } 
#endif
# 116 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 116
{ } 
#endif
# 118 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 118
{ } 
#endif
# 120 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 120
{ } 
#endif
# 122 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 122
{ } 
#endif
# 124 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 124
{ } 
#endif
# 126 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 126
{ } 
#endif
# 128 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 128
{ } 
#endif
# 130 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 130
{ } 
#endif
# 132 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 132
{ } 
#endif
# 134 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 134
{ } 
#endif
# 136 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 136
{ } 
#endif
# 138 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 138
{ } 
#endif
# 140 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 140
{ } 
#endif
# 142 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 142
{ } 
#endif
# 144 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 144
{ } 
#endif
# 146 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 146
{ } 
#endif
# 171 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
extern "C" {
# 180
}
# 189 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 189
{ } 
#endif
# 191 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 191
{ } 
#endif
# 193 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS(unsigned long long *address, unsigned long long compare, unsigned long long val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 193
{ } 
#endif
# 195 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute((deprecated("__any() is deprecated in favor of __any_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning)."))) __attribute__((unused)) static inline bool any(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
# 195
{ } 
#endif
# 197 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_atomic_functions.h"
__attribute((deprecated("__all() is deprecated in favor of __all_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning)."))) __attribute__((unused)) static inline bool all(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
# 197
{ } 
#endif
# 87 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.h"
extern "C" {
# 1139 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.h"
}
# 1147
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode); 
# 1149
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1151
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1153
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
# 1155
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
# 1157
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
# 1159
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
# 1161
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
# 1163
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode = cudaRoundNearest); 
# 1165
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode = cudaRoundNearest); 
# 1167
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
# 1169
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
# 1171
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
# 93 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double fma(double a, double b, double c, cudaRoundMode mode) 
# 94
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
# 99
::exit(___);}
#if 0
# 94
{ 
# 95
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
# 99
} 
#endif
# 101 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double dmul(double a, double b, cudaRoundMode mode) 
# 102
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 107
::exit(___);}
#if 0
# 102
{ 
# 103
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
# 107
} 
#endif
# 109 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double dadd(double a, double b, cudaRoundMode mode) 
# 110
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 115
::exit(___);}
#if 0
# 110
{ 
# 111
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
# 115
} 
#endif
# 117 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double dsub(double a, double b, cudaRoundMode mode) 
# 118
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
# 123
::exit(___);}
#if 0
# 118
{ 
# 119
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
# 123
} 
#endif
# 125 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline int double2int(double a, cudaRoundMode mode) 
# 126
{int volatile ___ = 1;(void)a;(void)mode;
# 131
::exit(___);}
#if 0
# 126
{ 
# 127
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
# 131
} 
#endif
# 133 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline unsigned double2uint(double a, cudaRoundMode mode) 
# 134
{int volatile ___ = 1;(void)a;(void)mode;
# 139
::exit(___);}
#if 0
# 134
{ 
# 135
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
# 139
} 
#endif
# 141 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline long long double2ll(double a, cudaRoundMode mode) 
# 142
{int volatile ___ = 1;(void)a;(void)mode;
# 147
::exit(___);}
#if 0
# 142
{ 
# 143
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
# 147
} 
#endif
# 149 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline unsigned long long double2ull(double a, cudaRoundMode mode) 
# 150
{int volatile ___ = 1;(void)a;(void)mode;
# 155
::exit(___);}
#if 0
# 150
{ 
# 151
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
# 155
} 
#endif
# 157 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double ll2double(long long a, cudaRoundMode mode) 
# 158
{int volatile ___ = 1;(void)a;(void)mode;
# 163
::exit(___);}
#if 0
# 158
{ 
# 159
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
# 163
} 
#endif
# 165 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double ull2double(unsigned long long a, cudaRoundMode mode) 
# 166
{int volatile ___ = 1;(void)a;(void)mode;
# 171
::exit(___);}
#if 0
# 166
{ 
# 167
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
# 171
} 
#endif
# 173 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double int2double(int a, cudaRoundMode mode) 
# 174
{int volatile ___ = 1;(void)a;(void)mode;
# 176
::exit(___);}
#if 0
# 174
{ 
# 175
return (double)a; 
# 176
} 
#endif
# 178 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double uint2double(unsigned a, cudaRoundMode mode) 
# 179
{int volatile ___ = 1;(void)a;(void)mode;
# 181
::exit(___);}
#if 0
# 179
{ 
# 180
return (double)a; 
# 181
} 
#endif
# 183 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_double_functions.hpp"
__attribute__((unused)) static inline double float2double(float a, cudaRoundMode mode) 
# 184
{int volatile ___ = 1;(void)a;(void)mode;
# 186
::exit(___);}
#if 0
# 184
{ 
# 185
return (double)a; 
# 186
} 
#endif
# 89 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 89
{ } 
#endif
# 100 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 100
{ } 
#endif
# 102 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 102
{ } 
#endif
# 104 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicAnd(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 104
{ } 
#endif
# 106 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicOr(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 106
{ } 
#endif
# 108 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline long long atomicXor(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 108
{ } 
#endif
# 110 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 110
{ } 
#endif
# 112 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 112
{ } 
#endif
# 114 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 114
{ } 
#endif
# 116 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 116
{ } 
#endif
# 118 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 118
{ } 
#endif
# 303 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 303
{ } 
#endif
# 306 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 306
{ } 
#endif
# 309 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAdd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 309
{ } 
#endif
# 312 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 312
{ } 
#endif
# 315 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAdd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 315
{ } 
#endif
# 318 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 318
{ } 
#endif
# 321 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAdd_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 321
{ } 
#endif
# 324 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 324
{ } 
#endif
# 327 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicAdd_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 327
{ } 
#endif
# 330 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd_block(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 330
{ } 
#endif
# 333 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline double atomicAdd_system(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 333
{ } 
#endif
# 336 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicSub_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 336
{ } 
#endif
# 339 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicSub_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 339
{ } 
#endif
# 342 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicSub_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 342
{ } 
#endif
# 345 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicSub_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 345
{ } 
#endif
# 348 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 348
{ } 
#endif
# 351 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicExch_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 351
{ } 
#endif
# 354 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 354
{ } 
#endif
# 357 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicExch_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 357
{ } 
#endif
# 360 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 360
{ } 
#endif
# 363 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicExch_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 363
{ } 
#endif
# 366 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 366
{ } 
#endif
# 369 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline float atomicExch_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 369
{ } 
#endif
# 372 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 372
{ } 
#endif
# 375 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMin_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 375
{ } 
#endif
# 378 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 378
{ } 
#endif
# 381 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMin_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 381
{ } 
#endif
# 384 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 384
{ } 
#endif
# 387 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMin_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 387
{ } 
#endif
# 390 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 390
{ } 
#endif
# 393 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMin_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 393
{ } 
#endif
# 396 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 396
{ } 
#endif
# 399 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicMax_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 399
{ } 
#endif
# 402 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 402
{ } 
#endif
# 405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicMax_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 405
{ } 
#endif
# 408 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 408
{ } 
#endif
# 411 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicMax_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 411
{ } 
#endif
# 414 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 414
{ } 
#endif
# 417 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicMax_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 417
{ } 
#endif
# 420 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 420
{ } 
#endif
# 423 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicInc_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 423
{ } 
#endif
# 426 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 426
{ } 
#endif
# 429 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicDec_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 429
{ } 
#endif
# 432 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS_block(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 432
{ } 
#endif
# 435 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicCAS_system(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 435
{ } 
#endif
# 438 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS_block(unsigned *address, unsigned compare, unsigned 
# 439
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 439
{ } 
#endif
# 442 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicCAS_system(unsigned *address, unsigned compare, unsigned 
# 443
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 443
{ } 
#endif
# 446 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS_block(unsigned long long *address, unsigned long long 
# 447
compare, unsigned long long 
# 448
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 448
{ } 
#endif
# 451 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicCAS_system(unsigned long long *address, unsigned long long 
# 452
compare, unsigned long long 
# 453
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 453
{ } 
#endif
# 456 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 456
{ } 
#endif
# 459 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicAnd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 459
{ } 
#endif
# 462 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicAnd_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 462
{ } 
#endif
# 465 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicAnd_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 465
{ } 
#endif
# 468 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 468
{ } 
#endif
# 471 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicAnd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 471
{ } 
#endif
# 474 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 474
{ } 
#endif
# 477 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicAnd_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 477
{ } 
#endif
# 480 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 480
{ } 
#endif
# 483 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicOr_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 483
{ } 
#endif
# 486 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicOr_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 486
{ } 
#endif
# 489 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicOr_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 489
{ } 
#endif
# 492 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 492
{ } 
#endif
# 495 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicOr_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 495
{ } 
#endif
# 498 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 498
{ } 
#endif
# 501 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicOr_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 501
{ } 
#endif
# 504 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 504
{ } 
#endif
# 507 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline int atomicXor_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 507
{ } 
#endif
# 510 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicXor_block(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 510
{ } 
#endif
# 513 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline long long atomicXor_system(long long *address, long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 513
{ } 
#endif
# 516 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 516
{ } 
#endif
# 519 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned atomicXor_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 519
{ } 
#endif
# 522 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor_block(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 522
{ } 
#endif
# 525 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_60_atomic_functions.h"
__attribute__((unused)) static inline unsigned long long atomicXor_system(unsigned long long *address, unsigned long long val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
# 525
{ } 
#endif
# 90 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
extern "C" {
# 1503 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
}
# 1510
__attribute((deprecated("__ballot() is deprecated in favor of __ballot_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to" " suppress this warning)."))) __attribute__((unused)) static inline unsigned ballot(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1510
{ } 
#endif
# 1512 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline int syncthreads_count(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1512
{ } 
#endif
# 1514 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline bool syncthreads_and(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1514
{ } 
#endif
# 1516 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline bool syncthreads_or(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
# 1516
{ } 
#endif
# 1521 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline unsigned __isGlobal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1521
{ } 
#endif
# 1522 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline unsigned __isShared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1522
{ } 
#endif
# 1523 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline unsigned __isConstant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1523
{ } 
#endif
# 1524 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline unsigned __isLocal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1524
{ } 
#endif
# 1526 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline size_t __cvta_generic_to_global(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1526
{ } 
#endif
# 1527 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline size_t __cvta_generic_to_shared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1527
{ } 
#endif
# 1528 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline size_t __cvta_generic_to_constant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1528
{ } 
#endif
# 1529 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline size_t __cvta_generic_to_local(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 1529
{ } 
#endif
# 1531 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline void *__cvta_global_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
# 1531
{ } 
#endif
# 1532 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline void *__cvta_shared_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
# 1532
{ } 
#endif
# 1533 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline void *__cvta_constant_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
# 1533
{ } 
#endif
# 1534 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_20_intrinsics.h"
__attribute__((unused)) static inline void *__cvta_local_to_generic(size_t rawbits) {int volatile ___ = 1;(void)rawbits;::exit(___);}
#if 0
# 1534
{ } 
#endif
# 102 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __fns(unsigned mask, unsigned base, int offset) {int volatile ___ = 1;(void)mask;(void)base;(void)offset;::exit(___);}
#if 0
# 102
{ } 
#endif
# 103 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline void __barrier_sync(unsigned id) {int volatile ___ = 1;(void)id;::exit(___);}
#if 0
# 103
{ } 
#endif
# 104 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline void __barrier_sync_count(unsigned id, unsigned cnt) {int volatile ___ = 1;(void)id;(void)cnt;::exit(___);}
#if 0
# 104
{ } 
#endif
# 105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline void __syncwarp(unsigned mask = 4294967295U) {int volatile ___ = 1;(void)mask;::exit(___);}
#if 0
# 105
{ } 
#endif
# 106 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __all_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
# 106
{ } 
#endif
# 107 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __any_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
# 107
{ } 
#endif
# 108 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __uni_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
# 108
{ } 
#endif
# 109 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __ballot_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
# 109
{ } 
#endif
# 110 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __activemask() {int volatile ___ = 1;::exit(___);}
#if 0
# 110
{ } 
#endif
# 119 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 119
{ } 
#endif
# 120 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline unsigned __shfl(unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 120
{ } 
#endif
# 121 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 121
{ } 
#endif
# 122 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 122
{ } 
#endif
# 123 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 123
{ } 
#endif
# 124 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 124
{ } 
#endif
# 125 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 125
{ } 
#endif
# 126 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 126
{ } 
#endif
# 127 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 127
{ } 
#endif
# 128 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 128
{ } 
#endif
# 129 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 129
{ } 
#endif
# 130 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 130
{ } 
#endif
# 133 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_sync(unsigned mask, int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 133
{ } 
#endif
# 134 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_sync(unsigned mask, unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 134
{ } 
#endif
# 135 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_up_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 135
{ } 
#endif
# 136 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_up_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 136
{ } 
#endif
# 137 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_down_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 137
{ } 
#endif
# 138 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_down_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 138
{ } 
#endif
# 139 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 139
{ } 
#endif
# 140 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned __shfl_xor_sync(unsigned mask, unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 140
{ } 
#endif
# 141 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_sync(unsigned mask, float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 141
{ } 
#endif
# 142 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_up_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 142
{ } 
#endif
# 143 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_down_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 143
{ } 
#endif
# 144 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 144
{ } 
#endif
# 148 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline unsigned long long __shfl(unsigned long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 148
{ } 
#endif
# 149 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline long long __shfl(long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 149
{ } 
#endif
# 150 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline long long __shfl_up(long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 150
{ } 
#endif
# 151 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline unsigned long long __shfl_up(unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 151
{ } 
#endif
# 152 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline long long __shfl_down(long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 152
{ } 
#endif
# 153 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline unsigned long long __shfl_down(unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 153
{ } 
#endif
# 154 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline long long __shfl_xor(long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 154
{ } 
#endif
# 155 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline unsigned long long __shfl_xor(unsigned long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 155
{ } 
#endif
# 156 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline double __shfl(double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 156
{ } 
#endif
# 157 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline double __shfl_up(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 157
{ } 
#endif
# 158 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline double __shfl_down(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 158
{ } 
#endif
# 159 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline double __shfl_xor(double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 159
{ } 
#endif
# 162 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_sync(unsigned mask, long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 162
{ } 
#endif
# 163 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_sync(unsigned mask, unsigned long long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 163
{ } 
#endif
# 164 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_up_sync(unsigned mask, long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 164
{ } 
#endif
# 165 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_up_sync(unsigned mask, unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 165
{ } 
#endif
# 166 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_down_sync(unsigned mask, long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 166
{ } 
#endif
# 167 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_down_sync(unsigned mask, unsigned long long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 167
{ } 
#endif
# 168 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long long __shfl_xor_sync(unsigned mask, long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 168
{ } 
#endif
# 169 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __shfl_xor_sync(unsigned mask, unsigned long long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 169
{ } 
#endif
# 170 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_sync(unsigned mask, double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 170
{ } 
#endif
# 171 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_up_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 171
{ } 
#endif
# 172 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_down_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 172
{ } 
#endif
# 173 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 173
{ } 
#endif
# 177 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline long __shfl(long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 177
{ } 
#endif
# 178 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 178
{ } 
#endif
# 179 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline long __shfl_up(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 179
{ } 
#endif
# 180 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 180
{ } 
#endif
# 181 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline long __shfl_down(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 181
{ } 
#endif
# 182 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 182
{ } 
#endif
# 183 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline long __shfl_xor(long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 183
{ } 
#endif
# 184 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 184
{ } 
#endif
# 187 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_sync(unsigned mask, long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 187
{ } 
#endif
# 188 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
# 188
{ } 
#endif
# 189 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_up_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 189
{ } 
#endif
# 190 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 190
{ } 
#endif
# 191 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_down_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 191
{ } 
#endif
# 192 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
# 192
{ } 
#endif
# 193 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 193
{ } 
#endif
# 194 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_30_intrinsics.h"
__attribute__((unused)) static inline unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
# 194
{ } 
#endif
# 87 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 87
{ } 
#endif
# 88 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 88
{ } 
#endif
# 90 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 90
{ } 
#endif
# 91 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 91
{ } 
#endif
# 92 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 92
{ } 
#endif
# 93 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 93
{ } 
#endif
# 94 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldg(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 94
{ } 
#endif
# 95 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 95
{ } 
#endif
# 96 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 96
{ } 
#endif
# 97 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 97
{ } 
#endif
# 98 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 98
{ } 
#endif
# 99 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 99
{ } 
#endif
# 100 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 100
{ } 
#endif
# 101 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 101
{ } 
#endif
# 103 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 103
{ } 
#endif
# 104 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 104
{ } 
#endif
# 105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 105
{ } 
#endif
# 106 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldg(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 106
{ } 
#endif
# 107 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 107
{ } 
#endif
# 108 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 108
{ } 
#endif
# 109 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 109
{ } 
#endif
# 110 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 110
{ } 
#endif
# 111 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 111
{ } 
#endif
# 112 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 112
{ } 
#endif
# 113 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 113
{ } 
#endif
# 115 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 115
{ } 
#endif
# 116 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 116
{ } 
#endif
# 117 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 117
{ } 
#endif
# 118 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 118
{ } 
#endif
# 119 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 119
{ } 
#endif
# 123 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldcg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 123
{ } 
#endif
# 124 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldcg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 124
{ } 
#endif
# 126 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldcg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 126
{ } 
#endif
# 127 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldcg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 127
{ } 
#endif
# 128 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldcg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 128
{ } 
#endif
# 129 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldcg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 129
{ } 
#endif
# 130 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldcg(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 130
{ } 
#endif
# 131 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldcg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 131
{ } 
#endif
# 132 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldcg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 132
{ } 
#endif
# 133 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldcg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 133
{ } 
#endif
# 134 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldcg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 134
{ } 
#endif
# 135 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldcg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 135
{ } 
#endif
# 136 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldcg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 136
{ } 
#endif
# 137 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldcg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 137
{ } 
#endif
# 139 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldcg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 139
{ } 
#endif
# 140 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldcg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 140
{ } 
#endif
# 141 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldcg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 141
{ } 
#endif
# 142 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldcg(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 142
{ } 
#endif
# 143 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldcg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 143
{ } 
#endif
# 144 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldcg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 144
{ } 
#endif
# 145 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldcg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 145
{ } 
#endif
# 146 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldcg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 146
{ } 
#endif
# 147 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldcg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 147
{ } 
#endif
# 148 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldcg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 148
{ } 
#endif
# 149 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldcg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 149
{ } 
#endif
# 151 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldcg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 151
{ } 
#endif
# 152 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldcg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 152
{ } 
#endif
# 153 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldcg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 153
{ } 
#endif
# 154 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldcg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 154
{ } 
#endif
# 155 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldcg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 155
{ } 
#endif
# 159 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldca(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 159
{ } 
#endif
# 160 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldca(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 160
{ } 
#endif
# 162 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldca(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 162
{ } 
#endif
# 163 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldca(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 163
{ } 
#endif
# 164 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldca(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 164
{ } 
#endif
# 165 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldca(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 165
{ } 
#endif
# 166 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldca(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 166
{ } 
#endif
# 167 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldca(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 167
{ } 
#endif
# 168 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldca(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 168
{ } 
#endif
# 169 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldca(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 169
{ } 
#endif
# 170 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldca(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 170
{ } 
#endif
# 171 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldca(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 171
{ } 
#endif
# 172 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldca(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 172
{ } 
#endif
# 173 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldca(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 173
{ } 
#endif
# 175 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldca(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 175
{ } 
#endif
# 176 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldca(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 176
{ } 
#endif
# 177 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldca(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 177
{ } 
#endif
# 178 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldca(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 178
{ } 
#endif
# 179 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldca(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 179
{ } 
#endif
# 180 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldca(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 180
{ } 
#endif
# 181 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldca(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 181
{ } 
#endif
# 182 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldca(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 182
{ } 
#endif
# 183 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldca(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 183
{ } 
#endif
# 184 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldca(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 184
{ } 
#endif
# 185 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldca(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 185
{ } 
#endif
# 187 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldca(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 187
{ } 
#endif
# 188 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldca(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 188
{ } 
#endif
# 189 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldca(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 189
{ } 
#endif
# 190 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldca(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 190
{ } 
#endif
# 191 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldca(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 191
{ } 
#endif
# 195 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldcs(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 195
{ } 
#endif
# 196 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldcs(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 196
{ } 
#endif
# 198 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldcs(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 198
{ } 
#endif
# 199 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldcs(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 199
{ } 
#endif
# 200 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldcs(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 200
{ } 
#endif
# 201 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldcs(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 201
{ } 
#endif
# 202 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldcs(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 202
{ } 
#endif
# 203 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldcs(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 203
{ } 
#endif
# 204 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldcs(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 204
{ } 
#endif
# 205 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldcs(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 205
{ } 
#endif
# 206 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldcs(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 206
{ } 
#endif
# 207 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldcs(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 207
{ } 
#endif
# 208 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldcs(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 208
{ } 
#endif
# 209 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldcs(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 209
{ } 
#endif
# 211 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldcs(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 211
{ } 
#endif
# 212 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldcs(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 212
{ } 
#endif
# 213 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldcs(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 213
{ } 
#endif
# 214 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldcs(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 214
{ } 
#endif
# 215 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldcs(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 215
{ } 
#endif
# 216 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldcs(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 216
{ } 
#endif
# 217 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldcs(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 217
{ } 
#endif
# 218 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldcs(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 218
{ } 
#endif
# 219 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldcs(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 219
{ } 
#endif
# 220 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldcs(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 220
{ } 
#endif
# 221 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldcs(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 221
{ } 
#endif
# 223 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldcs(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 223
{ } 
#endif
# 224 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldcs(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 224
{ } 
#endif
# 225 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldcs(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 225
{ } 
#endif
# 226 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldcs(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 226
{ } 
#endif
# 227 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldcs(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 227
{ } 
#endif
# 231 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldlu(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 231
{ } 
#endif
# 232 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldlu(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 232
{ } 
#endif
# 234 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldlu(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 234
{ } 
#endif
# 235 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldlu(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 235
{ } 
#endif
# 236 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldlu(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 236
{ } 
#endif
# 237 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldlu(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 237
{ } 
#endif
# 238 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldlu(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 238
{ } 
#endif
# 239 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldlu(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 239
{ } 
#endif
# 240 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldlu(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 240
{ } 
#endif
# 241 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldlu(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 241
{ } 
#endif
# 242 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldlu(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 242
{ } 
#endif
# 243 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldlu(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 243
{ } 
#endif
# 244 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldlu(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 244
{ } 
#endif
# 245 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldlu(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 245
{ } 
#endif
# 247 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldlu(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 247
{ } 
#endif
# 248 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldlu(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 248
{ } 
#endif
# 249 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldlu(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 249
{ } 
#endif
# 250 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldlu(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 250
{ } 
#endif
# 251 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldlu(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 251
{ } 
#endif
# 252 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldlu(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 252
{ } 
#endif
# 253 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldlu(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 253
{ } 
#endif
# 254 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldlu(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 254
{ } 
#endif
# 255 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldlu(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 255
{ } 
#endif
# 256 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldlu(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 256
{ } 
#endif
# 257 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldlu(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 257
{ } 
#endif
# 259 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldlu(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 259
{ } 
#endif
# 260 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldlu(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 260
{ } 
#endif
# 261 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldlu(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 261
{ } 
#endif
# 262 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldlu(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 262
{ } 
#endif
# 263 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldlu(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 263
{ } 
#endif
# 267 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long __ldcv(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 267
{ } 
#endif
# 268 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long __ldcv(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 268
{ } 
#endif
# 270 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char __ldcv(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 270
{ } 
#endif
# 271 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline signed char __ldcv(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 271
{ } 
#endif
# 272 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short __ldcv(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 272
{ } 
#endif
# 273 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int __ldcv(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 273
{ } 
#endif
# 274 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline long long __ldcv(const long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 274
{ } 
#endif
# 275 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char2 __ldcv(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 275
{ } 
#endif
# 276 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline char4 __ldcv(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 276
{ } 
#endif
# 277 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short2 __ldcv(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 277
{ } 
#endif
# 278 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline short4 __ldcv(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 278
{ } 
#endif
# 279 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int2 __ldcv(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 279
{ } 
#endif
# 280 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline int4 __ldcv(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 280
{ } 
#endif
# 281 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline longlong2 __ldcv(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 281
{ } 
#endif
# 283 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned char __ldcv(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 283
{ } 
#endif
# 284 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned short __ldcv(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 284
{ } 
#endif
# 285 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __ldcv(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 285
{ } 
#endif
# 286 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned long long __ldcv(const unsigned long long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 286
{ } 
#endif
# 287 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar2 __ldcv(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 287
{ } 
#endif
# 288 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uchar4 __ldcv(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 288
{ } 
#endif
# 289 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort2 __ldcv(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 289
{ } 
#endif
# 290 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ushort4 __ldcv(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 290
{ } 
#endif
# 291 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint2 __ldcv(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 291
{ } 
#endif
# 292 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline uint4 __ldcv(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 292
{ } 
#endif
# 293 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline ulonglong2 __ldcv(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 293
{ } 
#endif
# 295 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float __ldcv(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 295
{ } 
#endif
# 296 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double __ldcv(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 296
{ } 
#endif
# 297 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float2 __ldcv(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 297
{ } 
#endif
# 298 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline float4 __ldcv(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 298
{ } 
#endif
# 299 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline double2 __ldcv(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
# 299
{ } 
#endif
# 303 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 303
{ } 
#endif
# 304 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 304
{ } 
#endif
# 306 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 306
{ } 
#endif
# 307 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 307
{ } 
#endif
# 308 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 308
{ } 
#endif
# 309 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 309
{ } 
#endif
# 310 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(long long *ptr, long long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 310
{ } 
#endif
# 311 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 311
{ } 
#endif
# 312 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 312
{ } 
#endif
# 313 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 313
{ } 
#endif
# 314 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 314
{ } 
#endif
# 315 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 315
{ } 
#endif
# 316 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 316
{ } 
#endif
# 317 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 317
{ } 
#endif
# 319 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 319
{ } 
#endif
# 320 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 320
{ } 
#endif
# 321 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 321
{ } 
#endif
# 322 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(unsigned long long *ptr, unsigned long long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 322
{ } 
#endif
# 323 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 323
{ } 
#endif
# 324 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 324
{ } 
#endif
# 325 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 325
{ } 
#endif
# 326 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 326
{ } 
#endif
# 327 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 327
{ } 
#endif
# 328 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 328
{ } 
#endif
# 329 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 329
{ } 
#endif
# 331 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 331
{ } 
#endif
# 332 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 332
{ } 
#endif
# 333 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 333
{ } 
#endif
# 334 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 334
{ } 
#endif
# 335 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwb(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 335
{ } 
#endif
# 339 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 339
{ } 
#endif
# 340 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 340
{ } 
#endif
# 342 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 342
{ } 
#endif
# 343 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 343
{ } 
#endif
# 344 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 344
{ } 
#endif
# 345 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 345
{ } 
#endif
# 346 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(long long *ptr, long long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 346
{ } 
#endif
# 347 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 347
{ } 
#endif
# 348 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 348
{ } 
#endif
# 349 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 349
{ } 
#endif
# 350 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 350
{ } 
#endif
# 351 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 351
{ } 
#endif
# 352 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 352
{ } 
#endif
# 353 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 353
{ } 
#endif
# 355 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 355
{ } 
#endif
# 356 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 356
{ } 
#endif
# 357 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 357
{ } 
#endif
# 358 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(unsigned long long *ptr, unsigned long long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 358
{ } 
#endif
# 359 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 359
{ } 
#endif
# 360 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 360
{ } 
#endif
# 361 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 361
{ } 
#endif
# 362 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 362
{ } 
#endif
# 363 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 363
{ } 
#endif
# 364 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 364
{ } 
#endif
# 365 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 365
{ } 
#endif
# 367 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 367
{ } 
#endif
# 368 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 368
{ } 
#endif
# 369 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 369
{ } 
#endif
# 370 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 370
{ } 
#endif
# 371 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcg(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 371
{ } 
#endif
# 375 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 375
{ } 
#endif
# 376 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 376
{ } 
#endif
# 378 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 378
{ } 
#endif
# 379 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 379
{ } 
#endif
# 380 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 380
{ } 
#endif
# 381 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 381
{ } 
#endif
# 382 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(long long *ptr, long long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 382
{ } 
#endif
# 383 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 383
{ } 
#endif
# 384 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 384
{ } 
#endif
# 385 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 385
{ } 
#endif
# 386 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 386
{ } 
#endif
# 387 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 387
{ } 
#endif
# 388 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 388
{ } 
#endif
# 389 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 389
{ } 
#endif
# 391 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 391
{ } 
#endif
# 392 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 392
{ } 
#endif
# 393 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 393
{ } 
#endif
# 394 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(unsigned long long *ptr, unsigned long long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 394
{ } 
#endif
# 395 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 395
{ } 
#endif
# 396 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 396
{ } 
#endif
# 397 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 397
{ } 
#endif
# 398 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 398
{ } 
#endif
# 399 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 399
{ } 
#endif
# 400 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 400
{ } 
#endif
# 401 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 401
{ } 
#endif
# 403 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 403
{ } 
#endif
# 404 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 404
{ } 
#endif
# 405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 405
{ } 
#endif
# 406 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 406
{ } 
#endif
# 407 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stcs(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 407
{ } 
#endif
# 411 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(long *ptr, long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 411
{ } 
#endif
# 412 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(unsigned long *ptr, unsigned long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 412
{ } 
#endif
# 414 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(char *ptr, char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 414
{ } 
#endif
# 415 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(signed char *ptr, signed char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 415
{ } 
#endif
# 416 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(short *ptr, short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 416
{ } 
#endif
# 417 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(int *ptr, int value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 417
{ } 
#endif
# 418 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(long long *ptr, long long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 418
{ } 
#endif
# 419 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(char2 *ptr, char2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 419
{ } 
#endif
# 420 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(char4 *ptr, char4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 420
{ } 
#endif
# 421 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(short2 *ptr, short2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 421
{ } 
#endif
# 422 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(short4 *ptr, short4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 422
{ } 
#endif
# 423 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(int2 *ptr, int2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 423
{ } 
#endif
# 424 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(int4 *ptr, int4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 424
{ } 
#endif
# 425 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(longlong2 *ptr, longlong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 425
{ } 
#endif
# 427 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(unsigned char *ptr, unsigned char value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 427
{ } 
#endif
# 428 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(unsigned short *ptr, unsigned short value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 428
{ } 
#endif
# 429 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(unsigned *ptr, unsigned value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 429
{ } 
#endif
# 430 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(unsigned long long *ptr, unsigned long long value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 430
{ } 
#endif
# 431 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(uchar2 *ptr, uchar2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 431
{ } 
#endif
# 432 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(uchar4 *ptr, uchar4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 432
{ } 
#endif
# 433 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(ushort2 *ptr, ushort2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 433
{ } 
#endif
# 434 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(ushort4 *ptr, ushort4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 434
{ } 
#endif
# 435 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(uint2 *ptr, uint2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 435
{ } 
#endif
# 436 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(uint4 *ptr, uint4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 436
{ } 
#endif
# 437 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(ulonglong2 *ptr, ulonglong2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 437
{ } 
#endif
# 439 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(float *ptr, float value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 439
{ } 
#endif
# 440 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(double *ptr, double value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 440
{ } 
#endif
# 441 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(float2 *ptr, float2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 441
{ } 
#endif
# 442 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(float4 *ptr, float4 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 442
{ } 
#endif
# 443 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline void __stwt(double2 *ptr, double2 value) {int volatile ___ = 1;(void)ptr;(void)value;::exit(___);}
#if 0
# 443
{ } 
#endif
# 460 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 460
{ } 
#endif
# 472 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 472
{ } 
#endif
# 485 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 485
{ } 
#endif
# 497 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_32_intrinsics.h"
__attribute__((unused)) static inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
# 497
{ } 
#endif
# 89 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_lo(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 89
{ } 
#endif
# 90 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_lo(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 90
{ } 
#endif
# 92 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_lo(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 92
{ } 
#endif
# 93 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 93
{ } 
#endif
# 95 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_hi(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 95
{ } 
#endif
# 96 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_hi(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 96
{ } 
#endif
# 98 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp2a_hi(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 98
{ } 
#endif
# 99 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 99
{ } 
#endif
# 106 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp4a(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 106
{ } 
#endif
# 107 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp4a(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 107
{ } 
#endif
# 109 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline int __dp4a(char4 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 109
{ } 
#endif
# 110 "/usr/local/cuda/bin/../targets/x86_64-linux/include/sm_61_intrinsics.h"
__attribute__((unused)) static inline unsigned __dp4a(uchar4 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
# 110
{ } 
#endif
# 93 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 93
{ } 
#endif
# 94 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 94
{ } 
#endif
# 95 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, unsigned long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 95
{ } 
#endif
# 96 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 96
{ } 
#endif
# 97 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, unsigned long long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 97
{ } 
#endif
# 98 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, long long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 98
{ } 
#endif
# 99 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, float value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 99
{ } 
#endif
# 100 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_any_sync(unsigned mask, double value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 100
{ } 
#endif
# 102 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, unsigned value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 102
{ } 
#endif
# 103 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, int value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 103
{ } 
#endif
# 104 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, unsigned long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 104
{ } 
#endif
# 105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 105
{ } 
#endif
# 106 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, unsigned long long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 106
{ } 
#endif
# 107 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, long long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 107
{ } 
#endif
# 108 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, float value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 108
{ } 
#endif
# 109 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned __match_all_sync(unsigned mask, double value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
# 109
{ } 
#endif
# 111 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline void __nanosleep(unsigned ns) {int volatile ___ = 1;(void)ns;::exit(___);}
#if 0
# 111
{ } 
#endif
# 113 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_70_rt.h"
__attribute__((unused)) static inline unsigned short atomicCAS(unsigned short *address, unsigned short compare, unsigned short val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
# 113
{ } 
#endif
# 93 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline unsigned __reduce_add_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 93
{ } 
#endif
# 94 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline unsigned __reduce_min_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 94
{ } 
#endif
# 95 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline unsigned __reduce_max_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 95
{ } 
#endif
# 97 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline int __reduce_add_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 97
{ } 
#endif
# 98 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline int __reduce_min_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 98
{ } 
#endif
# 99 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline int __reduce_max_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 99
{ } 
#endif
# 101 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline unsigned __reduce_and_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 101
{ } 
#endif
# 102 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline unsigned __reduce_or_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 102
{ } 
#endif
# 103 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) static inline unsigned __reduce_xor_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
# 103
{ } 
#endif
# 106 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
extern "C" {
# 107
__attribute__((unused)) inline void *__nv_associate_access_property(const void *ptr, unsigned long long 
# 108
property) {int volatile ___ = 1;(void)ptr;(void)property;
# 112
::exit(___);}
#if 0
# 108
{ 
# 109
__attribute__((unused)) extern void *__nv_associate_access_property_impl(const void *, unsigned long long); 
# 111
return __nv_associate_access_property_impl(ptr, property); 
# 112
} 
#endif
# 114 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) inline void __nv_memcpy_async_shared_global_4(void *dst, const void *
# 115
src, unsigned 
# 116
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;
# 121
::exit(___);}
#if 0
# 116
{ 
# 117
__attribute__((unused)) extern void __nv_memcpy_async_shared_global_4_impl(void *, const void *, unsigned); 
# 120
__nv_memcpy_async_shared_global_4_impl(dst, src, src_size); 
# 121
} 
#endif
# 123 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) inline void __nv_memcpy_async_shared_global_8(void *dst, const void *
# 124
src, unsigned 
# 125
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;
# 130
::exit(___);}
#if 0
# 125
{ 
# 126
__attribute__((unused)) extern void __nv_memcpy_async_shared_global_8_impl(void *, const void *, unsigned); 
# 129
__nv_memcpy_async_shared_global_8_impl(dst, src, src_size); 
# 130
} 
#endif
# 132 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
__attribute__((unused)) inline void __nv_memcpy_async_shared_global_16(void *dst, const void *
# 133
src, unsigned 
# 134
src_size) {int volatile ___ = 1;(void)dst;(void)src;(void)src_size;
# 139
::exit(___);}
#if 0
# 134
{ 
# 135
__attribute__((unused)) extern void __nv_memcpy_async_shared_global_16_impl(void *, const void *, unsigned); 
# 138
__nv_memcpy_async_shared_global_16_impl(dst, src, src_size); 
# 139
} 
#endif
# 141 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/sm_80_rt.h"
}
# 122 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 123
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(T *res, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 124
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
# 128
::exit(___);}
#if 0
# 124
{ 
# 128
} 
#endif
# 130 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 131
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline T surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 132
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
# 138
::exit(___);}
#if 0
# 132
{ 
# 138
} 
#endif
# 140 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 141
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf1Dread(T *res, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 142
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
# 146
::exit(___);}
#if 0
# 142
{ 
# 146
} 
#endif
# 149 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 150
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 151
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 155
::exit(___);}
#if 0
# 151
{ 
# 155
} 
#endif
# 157 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 158
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline T surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 159
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
# 165
::exit(___);}
#if 0
# 159
{ 
# 165
} 
#endif
# 167 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 168
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf2Dread(T *res, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 169
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
# 173
::exit(___);}
#if 0
# 169
{ 
# 173
} 
#endif
# 176 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 177
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 178
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 182
::exit(___);}
#if 0
# 178
{ 
# 182
} 
#endif
# 184 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 185
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline T surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 186
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 192
::exit(___);}
#if 0
# 186
{ 
# 192
} 
#endif
# 194 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 195
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf3Dread(T *res, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 196
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 200
::exit(___);}
#if 0
# 196
{ 
# 200
} 
#endif
# 204 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 205
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 206
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 210
::exit(___);}
#if 0
# 206
{ 
# 210
} 
#endif
# 212 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 213
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline T surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 214
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
# 220
::exit(___);}
#if 0
# 214
{ 
# 220
} 
#endif
# 223 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 224
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredread(T *res, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 225
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
# 229
::exit(___);}
#if 0
# 225
{ 
# 229
} 
#endif
# 232 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 233
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 234
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 238
::exit(___);}
#if 0
# 234
{ 
# 238
} 
#endif
# 240 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 241
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline T surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 242
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 248
::exit(___);}
#if 0
# 242
{ 
# 248
} 
#endif
# 251 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 252
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredread(T *res, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 253
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 257
::exit(___);}
#if 0
# 253
{ 
# 257
} 
#endif
# 260 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 261
__attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 262
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 266
::exit(___);}
#if 0
# 262
{ 
# 266
} 
#endif
# 268 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 269
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 270
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 277
::exit(___);}
#if 0
# 270
{ 
# 277
} 
#endif
# 279 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 280
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapread(T *res, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 281
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 285
::exit(___);}
#if 0
# 281
{ 
# 285
} 
#endif
# 288 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 289
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 290
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 294
::exit(___);}
#if 0
# 290
{ 
# 294
} 
#endif
# 296 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 297
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline T surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 298
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 304
::exit(___);}
#if 0
# 298
{ 
# 304
} 
#endif
# 306 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 307
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredread(T *res, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 308
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 312
::exit(___);}
#if 0
# 308
{ 
# 312
} 
#endif
# 315 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 316
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 317
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
# 321
::exit(___);}
#if 0
# 317
{ 
# 321
} 
#endif
# 323 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 324
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf1Dwrite(T val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 325
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
# 329
::exit(___);}
#if 0
# 325
{ 
# 329
} 
#endif
# 333 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 334
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 335
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
# 339
::exit(___);}
#if 0
# 335
{ 
# 339
} 
#endif
# 341 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 342
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf2Dwrite(T val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 343
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
# 347
::exit(___);}
#if 0
# 343
{ 
# 347
} 
#endif
# 350 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 351
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 352
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
# 356
::exit(___);}
#if 0
# 352
{ 
# 356
} 
#endif
# 358 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 359
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf3Dwrite(T val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 360
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
# 364
::exit(___);}
#if 0
# 360
{ 
# 364
} 
#endif
# 367 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 368
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 369
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
# 373
::exit(___);}
#if 0
# 369
{ 
# 373
} 
#endif
# 375 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 376
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf1DLayeredwrite(T val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 377
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
# 381
::exit(___);}
#if 0
# 377
{ 
# 381
} 
#endif
# 384 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 385
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 386
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
# 390
::exit(___);}
#if 0
# 386
{ 
# 390
} 
#endif
# 392 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 393
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surf2DLayeredwrite(T val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 394
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
# 398
::exit(___);}
#if 0
# 394
{ 
# 398
} 
#endif
# 401 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 402
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 403
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
# 407
::exit(___);}
#if 0
# 403
{ 
# 407
} 
#endif
# 409 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 410
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapwrite(T val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 411
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
# 415
::exit(___);}
#if 0
# 411
{ 
# 415
} 
#endif
# 419 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 420
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, int s, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 421
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
# 425
::exit(___);}
#if 0
# 421
{ 
# 425
} 
#endif
# 427 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_functions.h"
template< class T> 
# 428
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline void surfCubemapLayeredwrite(T val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 429
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
# 433
::exit(___);}
#if 0
# 429
{ 
# 433
} 
#endif
# 72 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 73
struct __nv_tex_rmet_ret { }; 
# 75
template<> struct __nv_tex_rmet_ret< char>  { typedef char type; }; 
# 76
template<> struct __nv_tex_rmet_ret< signed char>  { typedef signed char type; }; 
# 77
template<> struct __nv_tex_rmet_ret< unsigned char>  { typedef unsigned char type; }; 
# 78
template<> struct __nv_tex_rmet_ret< char1>  { typedef char1 type; }; 
# 79
template<> struct __nv_tex_rmet_ret< uchar1>  { typedef uchar1 type; }; 
# 80
template<> struct __nv_tex_rmet_ret< char2>  { typedef char2 type; }; 
# 81
template<> struct __nv_tex_rmet_ret< uchar2>  { typedef uchar2 type; }; 
# 82
template<> struct __nv_tex_rmet_ret< char4>  { typedef char4 type; }; 
# 83
template<> struct __nv_tex_rmet_ret< uchar4>  { typedef uchar4 type; }; 
# 85
template<> struct __nv_tex_rmet_ret< short>  { typedef short type; }; 
# 86
template<> struct __nv_tex_rmet_ret< unsigned short>  { typedef unsigned short type; }; 
# 87
template<> struct __nv_tex_rmet_ret< short1>  { typedef short1 type; }; 
# 88
template<> struct __nv_tex_rmet_ret< ushort1>  { typedef ushort1 type; }; 
# 89
template<> struct __nv_tex_rmet_ret< short2>  { typedef short2 type; }; 
# 90
template<> struct __nv_tex_rmet_ret< ushort2>  { typedef ushort2 type; }; 
# 91
template<> struct __nv_tex_rmet_ret< short4>  { typedef short4 type; }; 
# 92
template<> struct __nv_tex_rmet_ret< ushort4>  { typedef ushort4 type; }; 
# 94
template<> struct __nv_tex_rmet_ret< int>  { typedef int type; }; 
# 95
template<> struct __nv_tex_rmet_ret< unsigned>  { typedef unsigned type; }; 
# 96
template<> struct __nv_tex_rmet_ret< int1>  { typedef int1 type; }; 
# 97
template<> struct __nv_tex_rmet_ret< uint1>  { typedef uint1 type; }; 
# 98
template<> struct __nv_tex_rmet_ret< int2>  { typedef int2 type; }; 
# 99
template<> struct __nv_tex_rmet_ret< uint2>  { typedef uint2 type; }; 
# 100
template<> struct __nv_tex_rmet_ret< int4>  { typedef int4 type; }; 
# 101
template<> struct __nv_tex_rmet_ret< uint4>  { typedef uint4 type; }; 
# 113 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template<> struct __nv_tex_rmet_ret< float>  { typedef float type; }; 
# 114
template<> struct __nv_tex_rmet_ret< float1>  { typedef float1 type; }; 
# 115
template<> struct __nv_tex_rmet_ret< float2>  { typedef float2 type; }; 
# 116
template<> struct __nv_tex_rmet_ret< float4>  { typedef float4 type; }; 
# 119
template< class T> struct __nv_tex_rmet_cast { typedef T *type; }; 
# 131 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 132
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1Dfetch(texture< T, 1, cudaReadModeElementType>  t, int x) 
# 133
{int volatile ___ = 1;(void)t;(void)x;
# 139
::exit(___);}
#if 0
# 133
{ 
# 139
} 
#endif
# 141 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 142
struct __nv_tex_rmnf_ret { }; 
# 144
template<> struct __nv_tex_rmnf_ret< char>  { typedef float type; }; 
# 145
template<> struct __nv_tex_rmnf_ret< signed char>  { typedef float type; }; 
# 146
template<> struct __nv_tex_rmnf_ret< unsigned char>  { typedef float type; }; 
# 147
template<> struct __nv_tex_rmnf_ret< short>  { typedef float type; }; 
# 148
template<> struct __nv_tex_rmnf_ret< unsigned short>  { typedef float type; }; 
# 149
template<> struct __nv_tex_rmnf_ret< char1>  { typedef float1 type; }; 
# 150
template<> struct __nv_tex_rmnf_ret< uchar1>  { typedef float1 type; }; 
# 151
template<> struct __nv_tex_rmnf_ret< short1>  { typedef float1 type; }; 
# 152
template<> struct __nv_tex_rmnf_ret< ushort1>  { typedef float1 type; }; 
# 153
template<> struct __nv_tex_rmnf_ret< char2>  { typedef float2 type; }; 
# 154
template<> struct __nv_tex_rmnf_ret< uchar2>  { typedef float2 type; }; 
# 155
template<> struct __nv_tex_rmnf_ret< short2>  { typedef float2 type; }; 
# 156
template<> struct __nv_tex_rmnf_ret< ushort2>  { typedef float2 type; }; 
# 157
template<> struct __nv_tex_rmnf_ret< char4>  { typedef float4 type; }; 
# 158
template<> struct __nv_tex_rmnf_ret< uchar4>  { typedef float4 type; }; 
# 159
template<> struct __nv_tex_rmnf_ret< short4>  { typedef float4 type; }; 
# 160
template<> struct __nv_tex_rmnf_ret< ushort4>  { typedef float4 type; }; 
# 162
template< class T> 
# 163
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1Dfetch(texture< T, 1, cudaReadModeNormalizedFloat>  t, int x) 
# 164
{int volatile ___ = 1;(void)t;(void)x;
# 171
::exit(___);}
#if 0
# 164
{ 
# 171
} 
#endif
# 174 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 175
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1D(texture< T, 1, cudaReadModeElementType>  t, float x) 
# 176
{int volatile ___ = 1;(void)t;(void)x;
# 182
::exit(___);}
#if 0
# 176
{ 
# 182
} 
#endif
# 184 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 185
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1D(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x) 
# 186
{int volatile ___ = 1;(void)t;(void)x;
# 193
::exit(___);}
#if 0
# 186
{ 
# 193
} 
#endif
# 197 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 198
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2D(texture< T, 2, cudaReadModeElementType>  t, float x, float y) 
# 199
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 206
::exit(___);}
#if 0
# 199
{ 
# 206
} 
#endif
# 208 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 209
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2D(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
# 210
{int volatile ___ = 1;(void)t;(void)x;(void)y;
# 217
::exit(___);}
#if 0
# 210
{ 
# 217
} 
#endif
# 221 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 222
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DLayered(texture< T, 241, cudaReadModeElementType>  t, float x, int layer) 
# 223
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 229
::exit(___);}
#if 0
# 223
{ 
# 229
} 
#endif
# 231 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 232
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DLayered(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
# 233
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
# 240
::exit(___);}
#if 0
# 233
{ 
# 240
} 
#endif
# 244 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 245
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DLayered(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
# 246
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 252
::exit(___);}
#if 0
# 246
{ 
# 252
} 
#endif
# 254 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 255
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DLayered(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
# 256
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
# 263
::exit(___);}
#if 0
# 256
{ 
# 263
} 
#endif
# 266 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 267
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex3D(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z) 
# 268
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 274
::exit(___);}
#if 0
# 268
{ 
# 274
} 
#endif
# 276 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 277
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex3D(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 285
::exit(___);}
#if 0
# 278
{ 
# 285
} 
#endif
# 288 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 289
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemap(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z) 
# 290
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 296
::exit(___);}
#if 0
# 290
{ 
# 296
} 
#endif
# 298 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 299
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemap(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
# 300
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
# 307
::exit(___);}
#if 0
# 300
{ 
# 307
} 
#endif
# 310 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 311
struct __nv_tex2dgather_ret { }; 
# 312
template<> struct __nv_tex2dgather_ret< char>  { typedef char4 type; }; 
# 313
template<> struct __nv_tex2dgather_ret< signed char>  { typedef char4 type; }; 
# 314
template<> struct __nv_tex2dgather_ret< char1>  { typedef char4 type; }; 
# 315
template<> struct __nv_tex2dgather_ret< char2>  { typedef char4 type; }; 
# 316
template<> struct __nv_tex2dgather_ret< char3>  { typedef char4 type; }; 
# 317
template<> struct __nv_tex2dgather_ret< char4>  { typedef char4 type; }; 
# 318
template<> struct __nv_tex2dgather_ret< unsigned char>  { typedef uchar4 type; }; 
# 319
template<> struct __nv_tex2dgather_ret< uchar1>  { typedef uchar4 type; }; 
# 320
template<> struct __nv_tex2dgather_ret< uchar2>  { typedef uchar4 type; }; 
# 321
template<> struct __nv_tex2dgather_ret< uchar3>  { typedef uchar4 type; }; 
# 322
template<> struct __nv_tex2dgather_ret< uchar4>  { typedef uchar4 type; }; 
# 324
template<> struct __nv_tex2dgather_ret< short>  { typedef short4 type; }; 
# 325
template<> struct __nv_tex2dgather_ret< short1>  { typedef short4 type; }; 
# 326
template<> struct __nv_tex2dgather_ret< short2>  { typedef short4 type; }; 
# 327
template<> struct __nv_tex2dgather_ret< short3>  { typedef short4 type; }; 
# 328
template<> struct __nv_tex2dgather_ret< short4>  { typedef short4 type; }; 
# 329
template<> struct __nv_tex2dgather_ret< unsigned short>  { typedef ushort4 type; }; 
# 330
template<> struct __nv_tex2dgather_ret< ushort1>  { typedef ushort4 type; }; 
# 331
template<> struct __nv_tex2dgather_ret< ushort2>  { typedef ushort4 type; }; 
# 332
template<> struct __nv_tex2dgather_ret< ushort3>  { typedef ushort4 type; }; 
# 333
template<> struct __nv_tex2dgather_ret< ushort4>  { typedef ushort4 type; }; 
# 335
template<> struct __nv_tex2dgather_ret< int>  { typedef int4 type; }; 
# 336
template<> struct __nv_tex2dgather_ret< int1>  { typedef int4 type; }; 
# 337
template<> struct __nv_tex2dgather_ret< int2>  { typedef int4 type; }; 
# 338
template<> struct __nv_tex2dgather_ret< int3>  { typedef int4 type; }; 
# 339
template<> struct __nv_tex2dgather_ret< int4>  { typedef int4 type; }; 
# 340
template<> struct __nv_tex2dgather_ret< unsigned>  { typedef uint4 type; }; 
# 341
template<> struct __nv_tex2dgather_ret< uint1>  { typedef uint4 type; }; 
# 342
template<> struct __nv_tex2dgather_ret< uint2>  { typedef uint4 type; }; 
# 343
template<> struct __nv_tex2dgather_ret< uint3>  { typedef uint4 type; }; 
# 344
template<> struct __nv_tex2dgather_ret< uint4>  { typedef uint4 type; }; 
# 346
template<> struct __nv_tex2dgather_ret< float>  { typedef float4 type; }; 
# 347
template<> struct __nv_tex2dgather_ret< float1>  { typedef float4 type; }; 
# 348
template<> struct __nv_tex2dgather_ret< float2>  { typedef float4 type; }; 
# 349
template<> struct __nv_tex2dgather_ret< float3>  { typedef float4 type; }; 
# 350
template<> struct __nv_tex2dgather_ret< float4>  { typedef float4 type; }; 
# 352
template< class T> 
# 353
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex2dgather_ret< T> ::type tex2Dgather(texture< T, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) 
# 354
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 361
::exit(___);}
#if 0
# 354
{ 
# 361
} 
#endif
# 364 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> struct __nv_tex2dgather_rmnf_ret { }; 
# 365
template<> struct __nv_tex2dgather_rmnf_ret< char>  { typedef float4 type; }; 
# 366
template<> struct __nv_tex2dgather_rmnf_ret< signed char>  { typedef float4 type; }; 
# 367
template<> struct __nv_tex2dgather_rmnf_ret< unsigned char>  { typedef float4 type; }; 
# 368
template<> struct __nv_tex2dgather_rmnf_ret< char1>  { typedef float4 type; }; 
# 369
template<> struct __nv_tex2dgather_rmnf_ret< uchar1>  { typedef float4 type; }; 
# 370
template<> struct __nv_tex2dgather_rmnf_ret< char2>  { typedef float4 type; }; 
# 371
template<> struct __nv_tex2dgather_rmnf_ret< uchar2>  { typedef float4 type; }; 
# 372
template<> struct __nv_tex2dgather_rmnf_ret< char3>  { typedef float4 type; }; 
# 373
template<> struct __nv_tex2dgather_rmnf_ret< uchar3>  { typedef float4 type; }; 
# 374
template<> struct __nv_tex2dgather_rmnf_ret< char4>  { typedef float4 type; }; 
# 375
template<> struct __nv_tex2dgather_rmnf_ret< uchar4>  { typedef float4 type; }; 
# 376
template<> struct __nv_tex2dgather_rmnf_ret< signed short>  { typedef float4 type; }; 
# 377
template<> struct __nv_tex2dgather_rmnf_ret< unsigned short>  { typedef float4 type; }; 
# 378
template<> struct __nv_tex2dgather_rmnf_ret< short1>  { typedef float4 type; }; 
# 379
template<> struct __nv_tex2dgather_rmnf_ret< ushort1>  { typedef float4 type; }; 
# 380
template<> struct __nv_tex2dgather_rmnf_ret< short2>  { typedef float4 type; }; 
# 381
template<> struct __nv_tex2dgather_rmnf_ret< ushort2>  { typedef float4 type; }; 
# 382
template<> struct __nv_tex2dgather_rmnf_ret< short3>  { typedef float4 type; }; 
# 383
template<> struct __nv_tex2dgather_rmnf_ret< ushort3>  { typedef float4 type; }; 
# 384
template<> struct __nv_tex2dgather_rmnf_ret< short4>  { typedef float4 type; }; 
# 385
template<> struct __nv_tex2dgather_rmnf_ret< ushort4>  { typedef float4 type; }; 
# 387
template< class T> 
# 388
__attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex2dgather_rmnf_ret< T> ::type tex2Dgather(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) 
# 389
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
# 396
::exit(___);}
#if 0
# 389
{ 
# 396
} 
#endif
# 400 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 401
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DLod(texture< T, 1, cudaReadModeElementType>  t, float x, float level) 
# 402
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 408
::exit(___);}
#if 0
# 402
{ 
# 408
} 
#endif
# 410 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 411
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DLod(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
# 412
{int volatile ___ = 1;(void)t;(void)x;(void)level;
# 419
::exit(___);}
#if 0
# 412
{ 
# 419
} 
#endif
# 422 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 423
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DLod(texture< T, 2, cudaReadModeElementType>  t, float x, float y, float level) 
# 424
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 430
::exit(___);}
#if 0
# 424
{ 
# 430
} 
#endif
# 432 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 433
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DLod(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
# 434
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
# 441
::exit(___);}
#if 0
# 434
{ 
# 441
} 
#endif
# 444 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 445
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DLayeredLod(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
# 446
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 452
::exit(___);}
#if 0
# 446
{ 
# 452
} 
#endif
# 454 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 455
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DLayeredLod(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
# 456
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
# 463
::exit(___);}
#if 0
# 456
{ 
# 463
} 
#endif
# 466 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 467
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DLayeredLod(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
# 468
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 474
::exit(___);}
#if 0
# 468
{ 
# 474
} 
#endif
# 476 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 477
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DLayeredLod(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
# 478
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
# 485
::exit(___);}
#if 0
# 478
{ 
# 485
} 
#endif
# 488 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 489
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex3DLod(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 490
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 496
::exit(___);}
#if 0
# 490
{ 
# 496
} 
#endif
# 498 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 499
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex3DLod(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 500
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 507
::exit(___);}
#if 0
# 500
{ 
# 507
} 
#endif
# 510 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 511
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapLod(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
# 512
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 518
::exit(___);}
#if 0
# 512
{ 
# 518
} 
#endif
# 520 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 521
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapLod(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
# 522
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
# 529
::exit(___);}
#if 0
# 522
{ 
# 529
} 
#endif
# 533 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 534
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapLayered(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
# 535
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 541
::exit(___);}
#if 0
# 535
{ 
# 541
} 
#endif
# 543 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 544
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayered(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
# 545
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
# 552
::exit(___);}
#if 0
# 545
{ 
# 552
} 
#endif
# 556 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 557
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapLayeredLod(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
# 558
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 564
::exit(___);}
#if 0
# 558
{ 
# 564
} 
#endif
# 566 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 567
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayeredLod(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
# 568
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 575
::exit(___);}
#if 0
# 568
{ 
# 575
} 
#endif
# 579 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 580
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapGrad(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 581
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 587
::exit(___);}
#if 0
# 581
{ 
# 587
} 
#endif
# 589 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 590
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapGrad(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 591
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 598
::exit(___);}
#if 0
# 591
{ 
# 598
} 
#endif
# 602 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 603
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type texCubemapLayeredGrad(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
# 604
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
# 610
::exit(___);}
#if 0
# 604
{ 
# 610
} 
#endif
# 612 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 613
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type texCubemapLayeredGrad(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
# 614
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
# 621
::exit(___);}
#if 0
# 614
{ 
# 621
} 
#endif
# 625 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 626
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DGrad(texture< T, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
# 627
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 633
::exit(___);}
#if 0
# 627
{ 
# 633
} 
#endif
# 635 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 636
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DGrad(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
# 637
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
# 644
::exit(___);}
#if 0
# 637
{ 
# 644
} 
#endif
# 648 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 649
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DGrad(texture< T, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 650
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 656
::exit(___);}
#if 0
# 650
{ 
# 656
} 
#endif
# 658 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 659
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DGrad(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
# 660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 667
::exit(___);}
#if 0
# 660
{ 
# 667
} 
#endif
# 670 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 671
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex1DLayeredGrad(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
# 672
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 678
::exit(___);}
#if 0
# 672
{ 
# 678
} 
#endif
# 680 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 681
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex1DLayeredGrad(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
# 682
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 689
::exit(___);}
#if 0
# 682
{ 
# 689
} 
#endif
# 692 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 693
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex2DLayeredGrad(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 694
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 700
::exit(___);}
#if 0
# 694
{ 
# 700
} 
#endif
# 702 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 703
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex2DLayeredGrad(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 704
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 711
::exit(___);}
#if 0
# 704
{ 
# 711
} 
#endif
# 714 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 715
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmet_ret< T> ::type tex3DGrad(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 716
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 722
::exit(___);}
#if 0
# 716
{ 
# 722
} 
#endif
# 724 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_fetch_functions.h"
template< class T> 
# 725
__attribute((deprecated)) __attribute((always_inline)) __attribute__((unused)) static inline typename __nv_tex_rmnf_ret< T> ::type tex3DGrad(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 733
::exit(___);}
#if 0
# 726
{ 
# 733
} 
#endif
# 64 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> struct __nv_itex_trait { }; 
# 65
template<> struct __nv_itex_trait< char>  { typedef void type; }; 
# 66
template<> struct __nv_itex_trait< signed char>  { typedef void type; }; 
# 67
template<> struct __nv_itex_trait< char1>  { typedef void type; }; 
# 68
template<> struct __nv_itex_trait< char2>  { typedef void type; }; 
# 69
template<> struct __nv_itex_trait< char4>  { typedef void type; }; 
# 70
template<> struct __nv_itex_trait< unsigned char>  { typedef void type; }; 
# 71
template<> struct __nv_itex_trait< uchar1>  { typedef void type; }; 
# 72
template<> struct __nv_itex_trait< uchar2>  { typedef void type; }; 
# 73
template<> struct __nv_itex_trait< uchar4>  { typedef void type; }; 
# 74
template<> struct __nv_itex_trait< short>  { typedef void type; }; 
# 75
template<> struct __nv_itex_trait< short1>  { typedef void type; }; 
# 76
template<> struct __nv_itex_trait< short2>  { typedef void type; }; 
# 77
template<> struct __nv_itex_trait< short4>  { typedef void type; }; 
# 78
template<> struct __nv_itex_trait< unsigned short>  { typedef void type; }; 
# 79
template<> struct __nv_itex_trait< ushort1>  { typedef void type; }; 
# 80
template<> struct __nv_itex_trait< ushort2>  { typedef void type; }; 
# 81
template<> struct __nv_itex_trait< ushort4>  { typedef void type; }; 
# 82
template<> struct __nv_itex_trait< int>  { typedef void type; }; 
# 83
template<> struct __nv_itex_trait< int1>  { typedef void type; }; 
# 84
template<> struct __nv_itex_trait< int2>  { typedef void type; }; 
# 85
template<> struct __nv_itex_trait< int4>  { typedef void type; }; 
# 86
template<> struct __nv_itex_trait< unsigned>  { typedef void type; }; 
# 87
template<> struct __nv_itex_trait< uint1>  { typedef void type; }; 
# 88
template<> struct __nv_itex_trait< uint2>  { typedef void type; }; 
# 89
template<> struct __nv_itex_trait< uint4>  { typedef void type; }; 
# 100 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template<> struct __nv_itex_trait< float>  { typedef void type; }; 
# 101
template<> struct __nv_itex_trait< float1>  { typedef void type; }; 
# 102
template<> struct __nv_itex_trait< float2>  { typedef void type; }; 
# 103
template<> struct __nv_itex_trait< float4>  { typedef void type; }; 
# 107
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 108
tex1Dfetch(T *ptr, cudaTextureObject_t obj, int x) 
# 109
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;
# 113
::exit(___);}
#if 0
# 109
{ 
# 113
} 
#endif
# 115 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 116
tex1Dfetch(cudaTextureObject_t texObject, int x) 
# 117
{int volatile ___ = 1;(void)texObject;(void)x;
# 123
::exit(___);}
#if 0
# 117
{ 
# 123
} 
#endif
# 125 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 126
tex1D(T *ptr, cudaTextureObject_t obj, float x) 
# 127
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;
# 131
::exit(___);}
#if 0
# 127
{ 
# 131
} 
#endif
# 134 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 135
tex1D(cudaTextureObject_t texObject, float x) 
# 136
{int volatile ___ = 1;(void)texObject;(void)x;
# 142
::exit(___);}
#if 0
# 136
{ 
# 142
} 
#endif
# 145 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 146
tex2D(T *ptr, cudaTextureObject_t obj, float x, float y) 
# 147
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;
# 151
::exit(___);}
#if 0
# 147
{ 
# 151
} 
#endif
# 153 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 154
tex2D(cudaTextureObject_t texObject, float x, float y) 
# 155
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
# 161
::exit(___);}
#if 0
# 155
{ 
# 161
} 
#endif
# 164 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 165
tex2D(T *ptr, cudaTextureObject_t obj, float x, float y, bool *
# 166
isResident) 
# 167
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)isResident;
# 173
::exit(___);}
#if 0
# 167
{ 
# 173
} 
#endif
# 175 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 176
tex2D(cudaTextureObject_t texObject, float x, float y, bool *isResident) 
# 177
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)isResident;
# 183
::exit(___);}
#if 0
# 177
{ 
# 183
} 
#endif
# 188 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 189
tex3D(T *ptr, cudaTextureObject_t obj, float x, float y, float z) 
# 190
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;
# 194
::exit(___);}
#if 0
# 190
{ 
# 194
} 
#endif
# 196 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 197
tex3D(cudaTextureObject_t texObject, float x, float y, float z) 
# 198
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 204
::exit(___);}
#if 0
# 198
{ 
# 204
} 
#endif
# 207 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 208
tex3D(T *ptr, cudaTextureObject_t obj, float x, float y, float z, bool *
# 209
isResident) 
# 210
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)isResident;
# 216
::exit(___);}
#if 0
# 210
{ 
# 216
} 
#endif
# 218 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 219
tex3D(cudaTextureObject_t texObject, float x, float y, float z, bool *isResident) 
# 220
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)isResident;
# 226
::exit(___);}
#if 0
# 220
{ 
# 226
} 
#endif
# 230 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 231
tex1DLayered(T *ptr, cudaTextureObject_t obj, float x, int layer) 
# 232
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;
# 236
::exit(___);}
#if 0
# 232
{ 
# 236
} 
#endif
# 238 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 239
tex1DLayered(cudaTextureObject_t texObject, float x, int layer) 
# 240
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
# 246
::exit(___);}
#if 0
# 240
{ 
# 246
} 
#endif
# 248 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 249
tex2DLayered(T *ptr, cudaTextureObject_t obj, float x, float y, int layer) 
# 250
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;
# 254
::exit(___);}
#if 0
# 250
{ 
# 254
} 
#endif
# 256 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 257
tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer) 
# 258
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
# 264
::exit(___);}
#if 0
# 258
{ 
# 264
} 
#endif
# 267 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 268
tex2DLayered(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, bool *isResident) 
# 269
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)isResident;
# 275
::exit(___);}
#if 0
# 269
{ 
# 275
} 
#endif
# 277 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 278
tex2DLayered(cudaTextureObject_t texObject, float x, float y, int layer, bool *isResident) 
# 279
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)isResident;
# 285
::exit(___);}
#if 0
# 279
{ 
# 285
} 
#endif
# 289 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 290
texCubemap(T *ptr, cudaTextureObject_t obj, float x, float y, float z) 
# 291
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;
# 295
::exit(___);}
#if 0
# 291
{ 
# 295
} 
#endif
# 298 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 299
texCubemap(cudaTextureObject_t texObject, float x, float y, float z) 
# 300
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
# 306
::exit(___);}
#if 0
# 300
{ 
# 306
} 
#endif
# 309 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 310
texCubemapLayered(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer) 
# 311
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;
# 315
::exit(___);}
#if 0
# 311
{ 
# 315
} 
#endif
# 317 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 318
texCubemapLayered(cudaTextureObject_t texObject, float x, float y, float z, int layer) 
# 319
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
# 325
::exit(___);}
#if 0
# 319
{ 
# 325
} 
#endif
# 327 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 328
tex2Dgather(T *ptr, cudaTextureObject_t obj, float x, float y, int comp = 0) 
# 329
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)comp;
# 333
::exit(___);}
#if 0
# 329
{ 
# 333
} 
#endif
# 335 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 336
tex2Dgather(cudaTextureObject_t to, float x, float y, int comp = 0) 
# 337
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
# 343
::exit(___);}
#if 0
# 337
{ 
# 343
} 
#endif
# 346 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 347
tex2Dgather(T *ptr, cudaTextureObject_t obj, float x, float y, bool *isResident, int comp = 0) 
# 348
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)isResident;(void)comp;
# 354
::exit(___);}
#if 0
# 348
{ 
# 354
} 
#endif
# 356 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 357
tex2Dgather(cudaTextureObject_t to, float x, float y, bool *isResident, int comp = 0) 
# 358
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)isResident;(void)comp;
# 364
::exit(___);}
#if 0
# 358
{ 
# 364
} 
#endif
# 368 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 369
tex1DLod(T *ptr, cudaTextureObject_t obj, float x, float level) 
# 370
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)level;
# 374
::exit(___);}
#if 0
# 370
{ 
# 374
} 
#endif
# 376 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 377
tex1DLod(cudaTextureObject_t texObject, float x, float level) 
# 378
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
# 384
::exit(___);}
#if 0
# 378
{ 
# 384
} 
#endif
# 387 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 388
tex2DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float level) 
# 389
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;
# 393
::exit(___);}
#if 0
# 389
{ 
# 393
} 
#endif
# 395 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 396
tex2DLod(cudaTextureObject_t texObject, float x, float y, float level) 
# 397
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
# 403
::exit(___);}
#if 0
# 397
{ 
# 403
} 
#endif
# 407 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 408
tex2DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float level, bool *isResident) 
# 409
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;(void)isResident;
# 415
::exit(___);}
#if 0
# 409
{ 
# 415
} 
#endif
# 417 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 418
tex2DLod(cudaTextureObject_t texObject, float x, float y, float level, bool *isResident) 
# 419
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;(void)isResident;
# 425
::exit(___);}
#if 0
# 419
{ 
# 425
} 
#endif
# 430 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 431
tex3DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level) 
# 432
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;
# 436
::exit(___);}
#if 0
# 432
{ 
# 436
} 
#endif
# 438 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 439
tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 440
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 446
::exit(___);}
#if 0
# 440
{ 
# 446
} 
#endif
# 449 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 450
tex3DLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level, bool *isResident) 
# 451
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;(void)isResident;
# 457
::exit(___);}
#if 0
# 451
{ 
# 457
} 
#endif
# 459 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 460
tex3DLod(cudaTextureObject_t texObject, float x, float y, float z, float level, bool *isResident) 
# 461
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;(void)isResident;
# 467
::exit(___);}
#if 0
# 461
{ 
# 467
} 
#endif
# 472 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 473
tex1DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, int layer, float level) 
# 474
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)level;
# 478
::exit(___);}
#if 0
# 474
{ 
# 478
} 
#endif
# 480 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 481
tex1DLayeredLod(cudaTextureObject_t texObject, float x, int layer, float level) 
# 482
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
# 488
::exit(___);}
#if 0
# 482
{ 
# 488
} 
#endif
# 491 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 492
tex2DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float level) 
# 493
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;
# 497
::exit(___);}
#if 0
# 493
{ 
# 497
} 
#endif
# 499 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 500
tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level) 
# 501
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
# 507
::exit(___);}
#if 0
# 501
{ 
# 507
} 
#endif
# 510 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 511
tex2DLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float level, bool *isResident) 
# 512
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;(void)isResident;
# 518
::exit(___);}
#if 0
# 512
{ 
# 518
} 
#endif
# 520 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 521
tex2DLayeredLod(cudaTextureObject_t texObject, float x, float y, int layer, float level, bool *isResident) 
# 522
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;(void)isResident;
# 528
::exit(___);}
#if 0
# 522
{ 
# 528
} 
#endif
# 531 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 532
texCubemapLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float level) 
# 533
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;
# 537
::exit(___);}
#if 0
# 533
{ 
# 537
} 
#endif
# 539 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 540
texCubemapLod(cudaTextureObject_t texObject, float x, float y, float z, float level) 
# 541
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
# 547
::exit(___);}
#if 0
# 541
{ 
# 547
} 
#endif
# 550 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 551
texCubemapGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 552
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 556
::exit(___);}
#if 0
# 552
{ 
# 556
} 
#endif
# 558 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 559
texCubemapGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 560
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 566
::exit(___);}
#if 0
# 560
{ 
# 566
} 
#endif
# 568 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 569
texCubemapLayeredLod(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer, float level) 
# 570
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 574
::exit(___);}
#if 0
# 570
{ 
# 574
} 
#endif
# 576 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 577
texCubemapLayeredLod(cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
# 578
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
# 584
::exit(___);}
#if 0
# 578
{ 
# 584
} 
#endif
# 586 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 587
tex1DGrad(T *ptr, cudaTextureObject_t obj, float x, float dPdx, float dPdy) 
# 588
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)dPdx;(void)dPdy;
# 592
::exit(___);}
#if 0
# 588
{ 
# 592
} 
#endif
# 594 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 595
tex1DGrad(cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
# 596
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
# 602
::exit(___);}
#if 0
# 596
{ 
# 602
} 
#endif
# 605 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 606
tex2DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float2 dPdx, float2 dPdy) 
# 607
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 612
::exit(___);}
#if 0
# 607
{ 
# 612
} 
#endif
# 614 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 615
tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
# 616
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
# 622
::exit(___);}
#if 0
# 616
{ 
# 622
} 
#endif
# 625 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 626
tex2DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float2 dPdx, float2 dPdy, bool *isResident) 
# 627
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;(void)isResident;
# 634
::exit(___);}
#if 0
# 627
{ 
# 634
} 
#endif
# 636 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 637
tex2DGrad(cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy, bool *isResident) 
# 638
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;(void)isResident;
# 644
::exit(___);}
#if 0
# 638
{ 
# 644
} 
#endif
# 648 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 649
tex3DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 650
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 654
::exit(___);}
#if 0
# 650
{ 
# 654
} 
#endif
# 656 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 657
tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
# 658
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
# 664
::exit(___);}
#if 0
# 658
{ 
# 664
} 
#endif
# 667 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 668
tex3DGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, float4 dPdx, float4 dPdy, bool *isResident) 
# 669
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;(void)isResident;
# 675
::exit(___);}
#if 0
# 669
{ 
# 675
} 
#endif
# 677 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 678
tex3DGrad(cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy, bool *isResident) 
# 679
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;(void)isResident;
# 685
::exit(___);}
#if 0
# 679
{ 
# 685
} 
#endif
# 690 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 691
tex1DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, int layer, float dPdx, float dPdy) 
# 692
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 696
::exit(___);}
#if 0
# 692
{ 
# 696
} 
#endif
# 698 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 699
tex1DLayeredGrad(cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
# 700
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
# 706
::exit(___);}
#if 0
# 700
{ 
# 706
} 
#endif
# 709 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 710
tex2DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 711
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 715
::exit(___);}
#if 0
# 711
{ 
# 715
} 
#endif
# 717 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 718
tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
# 719
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
# 725
::exit(___);}
#if 0
# 719
{ 
# 725
} 
#endif
# 728 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 729
tex2DLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, int layer, float2 dPdx, float2 dPdy, bool *isResident) 
# 730
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;(void)isResident;
# 736
::exit(___);}
#if 0
# 730
{ 
# 736
} 
#endif
# 738 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 739
tex2DLayeredGrad(cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy, bool *isResident) 
# 740
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;(void)isResident;
# 746
::exit(___);}
#if 0
# 740
{ 
# 746
} 
#endif
# 750 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_itex_trait< T> ::type 
# 751
texCubemapLayeredGrad(T *ptr, cudaTextureObject_t obj, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
# 752
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
# 756
::exit(___);}
#if 0
# 752
{ 
# 756
} 
#endif
# 758 "/usr/local/cuda/bin/../targets/x86_64-linux/include/texture_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 759
texCubemapLayeredGrad(cudaTextureObject_t texObject, float x, float y, float z, int layer, float4 dPdx, float4 dPdy) 
# 760
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;
# 766
::exit(___);}
#if 0
# 760
{ 
# 766
} 
#endif
# 59 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> struct __nv_isurf_trait { }; 
# 60
template<> struct __nv_isurf_trait< char>  { typedef void type; }; 
# 61
template<> struct __nv_isurf_trait< signed char>  { typedef void type; }; 
# 62
template<> struct __nv_isurf_trait< char1>  { typedef void type; }; 
# 63
template<> struct __nv_isurf_trait< unsigned char>  { typedef void type; }; 
# 64
template<> struct __nv_isurf_trait< uchar1>  { typedef void type; }; 
# 65
template<> struct __nv_isurf_trait< short>  { typedef void type; }; 
# 66
template<> struct __nv_isurf_trait< short1>  { typedef void type; }; 
# 67
template<> struct __nv_isurf_trait< unsigned short>  { typedef void type; }; 
# 68
template<> struct __nv_isurf_trait< ushort1>  { typedef void type; }; 
# 69
template<> struct __nv_isurf_trait< int>  { typedef void type; }; 
# 70
template<> struct __nv_isurf_trait< int1>  { typedef void type; }; 
# 71
template<> struct __nv_isurf_trait< unsigned>  { typedef void type; }; 
# 72
template<> struct __nv_isurf_trait< uint1>  { typedef void type; }; 
# 73
template<> struct __nv_isurf_trait< long long>  { typedef void type; }; 
# 74
template<> struct __nv_isurf_trait< longlong1>  { typedef void type; }; 
# 75
template<> struct __nv_isurf_trait< unsigned long long>  { typedef void type; }; 
# 76
template<> struct __nv_isurf_trait< ulonglong1>  { typedef void type; }; 
# 77
template<> struct __nv_isurf_trait< float>  { typedef void type; }; 
# 78
template<> struct __nv_isurf_trait< float1>  { typedef void type; }; 
# 80
template<> struct __nv_isurf_trait< char2>  { typedef void type; }; 
# 81
template<> struct __nv_isurf_trait< uchar2>  { typedef void type; }; 
# 82
template<> struct __nv_isurf_trait< short2>  { typedef void type; }; 
# 83
template<> struct __nv_isurf_trait< ushort2>  { typedef void type; }; 
# 84
template<> struct __nv_isurf_trait< int2>  { typedef void type; }; 
# 85
template<> struct __nv_isurf_trait< uint2>  { typedef void type; }; 
# 86
template<> struct __nv_isurf_trait< longlong2>  { typedef void type; }; 
# 87
template<> struct __nv_isurf_trait< ulonglong2>  { typedef void type; }; 
# 88
template<> struct __nv_isurf_trait< float2>  { typedef void type; }; 
# 90
template<> struct __nv_isurf_trait< char4>  { typedef void type; }; 
# 91
template<> struct __nv_isurf_trait< uchar4>  { typedef void type; }; 
# 92
template<> struct __nv_isurf_trait< short4>  { typedef void type; }; 
# 93
template<> struct __nv_isurf_trait< ushort4>  { typedef void type; }; 
# 94
template<> struct __nv_isurf_trait< int4>  { typedef void type; }; 
# 95
template<> struct __nv_isurf_trait< uint4>  { typedef void type; }; 
# 96
template<> struct __nv_isurf_trait< float4>  { typedef void type; }; 
# 99
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 100
surf1Dread(T *ptr, cudaSurfaceObject_t obj, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 101
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)mode;
# 105
::exit(___);}
#if 0
# 101
{ 
# 105
} 
#endif
# 107 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 108
surf1Dread(cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 109
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
# 115
::exit(___);}
#if 0
# 109
{ 
# 115
} 
#endif
# 117 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 118
surf2Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 119
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)mode;
# 123
::exit(___);}
#if 0
# 119
{ 
# 123
} 
#endif
# 125 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 126
surf2Dread(cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 127
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
# 133
::exit(___);}
#if 0
# 127
{ 
# 133
} 
#endif
# 136 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 137
surf3Dread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 138
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)mode;
# 142
::exit(___);}
#if 0
# 138
{ 
# 142
} 
#endif
# 144 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 145
surf3Dread(cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 146
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
# 152
::exit(___);}
#if 0
# 146
{ 
# 152
} 
#endif
# 154 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 155
surf1DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 156
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)mode;
# 160
::exit(___);}
#if 0
# 156
{ 
# 160
} 
#endif
# 162 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 163
surf1DLayeredread(cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 164
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
# 170
::exit(___);}
#if 0
# 164
{ 
# 170
} 
#endif
# 172 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 173
surf2DLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 174
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)mode;
# 178
::exit(___);}
#if 0
# 174
{ 
# 178
} 
#endif
# 180 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 181
surf2DLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 182
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
# 188
::exit(___);}
#if 0
# 182
{ 
# 188
} 
#endif
# 190 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 191
surfCubemapread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 192
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)face;(void)mode;
# 196
::exit(___);}
#if 0
# 192
{ 
# 196
} 
#endif
# 198 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 199
surfCubemapread(cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 200
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
# 206
::exit(___);}
#if 0
# 200
{ 
# 206
} 
#endif
# 208 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 209
surfCubemapLayeredread(T *ptr, cudaSurfaceObject_t obj, int x, int y, int layerface, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 210
{int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;
# 214
::exit(___);}
#if 0
# 210
{ 
# 214
} 
#endif
# 216 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static T 
# 217
surfCubemapLayeredread(cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
# 218
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
# 224
::exit(___);}
#if 0
# 218
{ 
# 224
} 
#endif
# 226 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 227
surf1Dwrite(T val, cudaSurfaceObject_t obj, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 228
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)mode;
# 232
::exit(___);}
#if 0
# 228
{ 
# 232
} 
#endif
# 234 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 235
surf2Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 236
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)mode;
# 240
::exit(___);}
#if 0
# 236
{ 
# 240
} 
#endif
# 242 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 243
surf3Dwrite(T val, cudaSurfaceObject_t obj, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 244
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)z;(void)mode;
# 248
::exit(___);}
#if 0
# 244
{ 
# 248
} 
#endif
# 250 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 251
surf1DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 252
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)layer;(void)mode;
# 256
::exit(___);}
#if 0
# 252
{ 
# 256
} 
#endif
# 258 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 259
surf2DLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 260
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layer;(void)mode;
# 264
::exit(___);}
#if 0
# 260
{ 
# 264
} 
#endif
# 266 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 267
surfCubemapwrite(T val, cudaSurfaceObject_t obj, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 268
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)face;(void)mode;
# 272
::exit(___);}
#if 0
# 268
{ 
# 272
} 
#endif
# 274 "/usr/local/cuda/bin/../targets/x86_64-linux/include/surface_indirect_functions.h"
template< class T> __attribute__((unused)) static typename __nv_isurf_trait< T> ::type 
# 275
surfCubemapLayeredwrite(T val, cudaSurfaceObject_t obj, int x, int y, int layerface, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
# 276
{int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;
# 280
::exit(___);}
#if 0
# 276
{ 
# 280
} 
#endif
# 3307 "/usr/local/cuda/bin/../targets/x86_64-linux/include/crt/device_functions.h"
extern "C" unsigned __cudaPushCallConfiguration(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, CUstream_st * stream = 0); 
# 68 "/usr/local/cuda/bin/../targets/x86_64-linux/include/device_launch_parameters.h"
extern "C" {
# 71
extern const uint3 __device_builtin_variable_threadIdx; 
# 72
extern const uint3 __device_builtin_variable_blockIdx; 
# 73
extern const dim3 __device_builtin_variable_blockDim; 
# 74
extern const dim3 __device_builtin_variable_gridDim; 
# 75
extern const int __device_builtin_variable_warpSize; 
# 80
}
# 201 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 202
cudaLaunchKernel(const T *
# 203
func, dim3 
# 204
gridDim, dim3 
# 205
blockDim, void **
# 206
args, size_t 
# 207
sharedMem = 0, cudaStream_t 
# 208
stream = 0) 
# 210
{ 
# 211
return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
# 212
} 
# 263 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 264
cudaLaunchCooperativeKernel(const T *
# 265
func, dim3 
# 266
gridDim, dim3 
# 267
blockDim, void **
# 268
args, size_t 
# 269
sharedMem = 0, cudaStream_t 
# 270
stream = 0) 
# 272
{ 
# 273
return ::cudaLaunchCooperativeKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
# 274
} 
# 307 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
static inline cudaError_t cudaEventCreate(cudaEvent_t *
# 308
event, unsigned 
# 309
flags) 
# 311
{ 
# 312
return ::cudaEventCreateWithFlags(event, flags); 
# 313
} 
# 372 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
static inline cudaError_t cudaMallocHost(void **
# 373
ptr, size_t 
# 374
size, unsigned 
# 375
flags) 
# 377
{ 
# 378
return ::cudaHostAlloc(ptr, size, flags); 
# 379
} 
# 381
template< class T> static inline cudaError_t 
# 382
cudaHostAlloc(T **
# 383
ptr, size_t 
# 384
size, unsigned 
# 385
flags) 
# 387
{ 
# 388
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
# 389
} 
# 391
template< class T> static inline cudaError_t 
# 392
cudaHostGetDevicePointer(T **
# 393
pDevice, void *
# 394
pHost, unsigned 
# 395
flags) 
# 397
{ 
# 398
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
# 399
} 
# 501 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 502
cudaMallocManaged(T **
# 503
devPtr, size_t 
# 504
size, unsigned 
# 505
flags = 1) 
# 507
{ 
# 508
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
# 509
} 
# 591 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 592
cudaStreamAttachMemAsync(cudaStream_t 
# 593
stream, T *
# 594
devPtr, size_t 
# 595
length = 0, unsigned 
# 596
flags = 4) 
# 598
{ 
# 599
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
# 600
} 
# 602
template< class T> inline cudaError_t 
# 603
cudaMalloc(T **
# 604
devPtr, size_t 
# 605
size) 
# 607
{ 
# 608
return ::cudaMalloc((void **)((void *)devPtr), size); 
# 609
} 
# 611
template< class T> static inline cudaError_t 
# 612
cudaMallocHost(T **
# 613
ptr, size_t 
# 614
size, unsigned 
# 615
flags = 0) 
# 617
{ 
# 618
return cudaMallocHost((void **)((void *)ptr), size, flags); 
# 619
} 
# 621
template< class T> static inline cudaError_t 
# 622
cudaMallocPitch(T **
# 623
devPtr, size_t *
# 624
pitch, size_t 
# 625
width, size_t 
# 626
height) 
# 628
{ 
# 629
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
# 630
} 
# 641 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
static inline cudaError_t cudaMallocAsync(void **
# 642
ptr, size_t 
# 643
size, cudaMemPool_t 
# 644
memPool, cudaStream_t 
# 645
stream) 
# 647
{ 
# 648
return ::cudaMallocFromPoolAsync(ptr, size, memPool, stream); 
# 649
} 
# 651
template< class T> static inline cudaError_t 
# 652
cudaMallocAsync(T **
# 653
ptr, size_t 
# 654
size, cudaMemPool_t 
# 655
memPool, cudaStream_t 
# 656
stream) 
# 658
{ 
# 659
return ::cudaMallocFromPoolAsync((void **)((void *)ptr), size, memPool, stream); 
# 660
} 
# 662
template< class T> static inline cudaError_t 
# 663
cudaMallocAsync(T **
# 664
ptr, size_t 
# 665
size, cudaStream_t 
# 666
stream) 
# 668
{ 
# 669
return ::cudaMallocAsync((void **)((void *)ptr), size, stream); 
# 670
} 
# 672
template< class T> static inline cudaError_t 
# 673
cudaMallocFromPoolAsync(T **
# 674
ptr, size_t 
# 675
size, cudaMemPool_t 
# 676
memPool, cudaStream_t 
# 677
stream) 
# 679
{ 
# 680
return ::cudaMallocFromPoolAsync((void **)((void *)ptr), size, memPool, stream); 
# 681
} 
# 720 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 721
cudaMemcpyToSymbol(const T &
# 722
symbol, const void *
# 723
src, size_t 
# 724
count, size_t 
# 725
offset = 0, cudaMemcpyKind 
# 726
kind = cudaMemcpyHostToDevice) 
# 728
{ 
# 729
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
# 730
} 
# 774 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 775
cudaMemcpyToSymbolAsync(const T &
# 776
symbol, const void *
# 777
src, size_t 
# 778
count, size_t 
# 779
offset = 0, cudaMemcpyKind 
# 780
kind = cudaMemcpyHostToDevice, cudaStream_t 
# 781
stream = 0) 
# 783
{ 
# 784
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
# 785
} 
# 822 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 823
cudaMemcpyFromSymbol(void *
# 824
dst, const T &
# 825
symbol, size_t 
# 826
count, size_t 
# 827
offset = 0, cudaMemcpyKind 
# 828
kind = cudaMemcpyDeviceToHost) 
# 830
{ 
# 831
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
# 832
} 
# 876 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 877
cudaMemcpyFromSymbolAsync(void *
# 878
dst, const T &
# 879
symbol, size_t 
# 880
count, size_t 
# 881
offset = 0, cudaMemcpyKind 
# 882
kind = cudaMemcpyDeviceToHost, cudaStream_t 
# 883
stream = 0) 
# 885
{ 
# 886
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
# 887
} 
# 945 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 946
cudaGraphAddMemcpyNodeToSymbol(cudaGraphNode_t *
# 947
pGraphNode, cudaGraph_t 
# 948
graph, const cudaGraphNode_t *
# 949
pDependencies, size_t 
# 950
numDependencies, const T &
# 951
symbol, const void *
# 952
src, size_t 
# 953
count, size_t 
# 954
offset, cudaMemcpyKind 
# 955
kind) 
# 956
{ 
# 957
return ::cudaGraphAddMemcpyNodeToSymbol(pGraphNode, graph, pDependencies, numDependencies, (const void *)(&symbol), src, count, offset, kind); 
# 958
} 
# 1016 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1017
cudaGraphAddMemcpyNodeFromSymbol(cudaGraphNode_t *
# 1018
pGraphNode, cudaGraph_t 
# 1019
graph, const cudaGraphNode_t *
# 1020
pDependencies, size_t 
# 1021
numDependencies, void *
# 1022
dst, const T &
# 1023
symbol, size_t 
# 1024
count, size_t 
# 1025
offset, cudaMemcpyKind 
# 1026
kind) 
# 1027
{ 
# 1028
return ::cudaGraphAddMemcpyNodeFromSymbol(pGraphNode, graph, pDependencies, numDependencies, dst, (const void *)(&symbol), count, offset, kind); 
# 1029
} 
# 1067 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1068
cudaGraphMemcpyNodeSetParamsToSymbol(cudaGraphNode_t 
# 1069
node, const T &
# 1070
symbol, const void *
# 1071
src, size_t 
# 1072
count, size_t 
# 1073
offset, cudaMemcpyKind 
# 1074
kind) 
# 1075
{ 
# 1076
return ::cudaGraphMemcpyNodeSetParamsToSymbol(node, (const void *)(&symbol), src, count, offset, kind); 
# 1077
} 
# 1115 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1116
cudaGraphMemcpyNodeSetParamsFromSymbol(cudaGraphNode_t 
# 1117
node, void *
# 1118
dst, const T &
# 1119
symbol, size_t 
# 1120
count, size_t 
# 1121
offset, cudaMemcpyKind 
# 1122
kind) 
# 1123
{ 
# 1124
return ::cudaGraphMemcpyNodeSetParamsFromSymbol(node, dst, (const void *)(&symbol), count, offset, kind); 
# 1125
} 
# 1173 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1174
cudaGraphExecMemcpyNodeSetParamsToSymbol(cudaGraphExec_t 
# 1175
hGraphExec, cudaGraphNode_t 
# 1176
node, const T &
# 1177
symbol, const void *
# 1178
src, size_t 
# 1179
count, size_t 
# 1180
offset, cudaMemcpyKind 
# 1181
kind) 
# 1182
{ 
# 1183
return ::cudaGraphExecMemcpyNodeSetParamsToSymbol(hGraphExec, node, (const void *)(&symbol), src, count, offset, kind); 
# 1184
} 
# 1232 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1233
cudaGraphExecMemcpyNodeSetParamsFromSymbol(cudaGraphExec_t 
# 1234
hGraphExec, cudaGraphNode_t 
# 1235
node, void *
# 1236
dst, const T &
# 1237
symbol, size_t 
# 1238
count, size_t 
# 1239
offset, cudaMemcpyKind 
# 1240
kind) 
# 1241
{ 
# 1242
return ::cudaGraphExecMemcpyNodeSetParamsFromSymbol(hGraphExec, node, dst, (const void *)(&symbol), count, offset, kind); 
# 1243
} 
# 1271 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1272
cudaUserObjectCreate(cudaUserObject_t *
# 1273
object_out, T *
# 1274
objectToWrap, unsigned 
# 1275
initialRefcount, unsigned 
# 1276
flags) 
# 1277
{ 
# 1278
return ::cudaUserObjectCreate(object_out, objectToWrap, [](void *
# 1281
vpObj) { delete (reinterpret_cast< T *>(vpObj)); } , initialRefcount, flags); 
# 1284
} 
# 1286
template< class T> static inline cudaError_t 
# 1287
cudaUserObjectCreate(cudaUserObject_t *
# 1288
object_out, T *
# 1289
objectToWrap, unsigned 
# 1290
initialRefcount, cudaUserObjectFlags 
# 1291
flags) 
# 1292
{ 
# 1293
return cudaUserObjectCreate(object_out, objectToWrap, initialRefcount, (unsigned)flags); 
# 1294
} 
# 1321 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1322
cudaGetSymbolAddress(void **
# 1323
devPtr, const T &
# 1324
symbol) 
# 1326
{ 
# 1327
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
# 1328
} 
# 1353 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1354
cudaGetSymbolSize(size_t *
# 1355
size, const T &
# 1356
symbol) 
# 1358
{ 
# 1359
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
# 1360
} 
# 1397 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1398
__attribute((deprecated)) static inline cudaError_t cudaBindTexture(size_t *
# 1399
offset, const texture< T, dim, readMode>  &
# 1400
tex, const void *
# 1401
devPtr, const cudaChannelFormatDesc &
# 1402
desc, size_t 
# 1403
size = ((2147483647) * 2U) + 1U) 
# 1405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
{ 
# 1406
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
# 1407
} 
# 1443 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1444
__attribute((deprecated)) static inline cudaError_t cudaBindTexture(size_t *
# 1445
offset, const texture< T, dim, readMode>  &
# 1446
tex, const void *
# 1447
devPtr, size_t 
# 1448
size = ((2147483647) * 2U) + 1U) 
# 1450 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
{ 
# 1451
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
# 1452
} 
# 1500 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1501
__attribute((deprecated)) static inline cudaError_t cudaBindTexture2D(size_t *
# 1502
offset, const texture< T, dim, readMode>  &
# 1503
tex, const void *
# 1504
devPtr, const cudaChannelFormatDesc &
# 1505
desc, size_t 
# 1506
width, size_t 
# 1507
height, size_t 
# 1508
pitch) 
# 1510
{ 
# 1511
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
# 1512
} 
# 1559 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1560
__attribute((deprecated)) static inline cudaError_t cudaBindTexture2D(size_t *
# 1561
offset, const texture< T, dim, readMode>  &
# 1562
tex, const void *
# 1563
devPtr, size_t 
# 1564
width, size_t 
# 1565
height, size_t 
# 1566
pitch) 
# 1568
{ 
# 1569
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
# 1570
} 
# 1602 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1603
__attribute((deprecated)) static inline cudaError_t cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 1604
tex, cudaArray_const_t 
# 1605
array, const cudaChannelFormatDesc &
# 1606
desc) 
# 1608
{ 
# 1609
return ::cudaBindTextureToArray(&tex, array, &desc); 
# 1610
} 
# 1641 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1642
__attribute((deprecated)) static inline cudaError_t cudaBindTextureToArray(const texture< T, dim, readMode>  &
# 1643
tex, cudaArray_const_t 
# 1644
array) 
# 1646
{ 
# 1647
cudaChannelFormatDesc desc; 
# 1648
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 1650
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
# 1651
} 
# 1683 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1684
__attribute((deprecated)) static inline cudaError_t cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 1685
tex, cudaMipmappedArray_const_t 
# 1686
mipmappedArray, const cudaChannelFormatDesc &
# 1687
desc) 
# 1689
{ 
# 1690
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
# 1691
} 
# 1722 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1723
__attribute((deprecated)) static inline cudaError_t cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
# 1724
tex, cudaMipmappedArray_const_t 
# 1725
mipmappedArray) 
# 1727
{ 
# 1728
cudaChannelFormatDesc desc; 
# 1729
cudaArray_t levelArray; 
# 1730
cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
# 1732
if (err != (cudaSuccess)) { 
# 1733
return err; 
# 1734
}  
# 1735
err = ::cudaGetChannelDesc(&desc, levelArray); 
# 1737
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
# 1738
} 
# 1765 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1766
__attribute((deprecated)) static inline cudaError_t cudaUnbindTexture(const texture< T, dim, readMode>  &
# 1767
tex) 
# 1769
{ 
# 1770
return ::cudaUnbindTexture(&tex); 
# 1771
} 
# 1801 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim, cudaTextureReadMode readMode> 
# 1802
__attribute((deprecated)) static inline cudaError_t cudaGetTextureAlignmentOffset(size_t *
# 1803
offset, const texture< T, dim, readMode>  &
# 1804
tex) 
# 1806
{ 
# 1807
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
# 1808
} 
# 1853 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 1854
cudaFuncSetCacheConfig(T *
# 1855
func, cudaFuncCache 
# 1856
cacheConfig) 
# 1858
{ 
# 1859
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
# 1860
} 
# 1862
template< class T> static inline cudaError_t 
# 1863
cudaFuncSetSharedMemConfig(T *
# 1864
func, cudaSharedMemConfig 
# 1865
config) 
# 1867
{ 
# 1868
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
# 1869
} 
# 1901 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 1902
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
# 1903
numBlocks, T 
# 1904
func, int 
# 1905
blockSize, size_t 
# 1906
dynamicSMemSize) 
# 1907
{ 
# 1908
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
# 1909
} 
# 1953 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 1954
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
# 1955
numBlocks, T 
# 1956
func, int 
# 1957
blockSize, size_t 
# 1958
dynamicSMemSize, unsigned 
# 1959
flags) 
# 1960
{ 
# 1961
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
# 1962
} 
# 1967
class __cudaOccupancyB2DHelper { 
# 1968
size_t n; 
# 1970
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
# 1971
size_t operator()(int) 
# 1972
{ 
# 1973
return n; 
# 1974
} 
# 1975
}; 
# 2023 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class UnaryFunction, class T> static inline cudaError_t 
# 2024
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
# 2025
minGridSize, int *
# 2026
blockSize, T 
# 2027
func, UnaryFunction 
# 2028
blockSizeToDynamicSMemSize, int 
# 2029
blockSizeLimit = 0, unsigned 
# 2030
flags = 0) 
# 2031
{ 
# 2032
cudaError_t status; 
# 2035
int device; 
# 2036
cudaFuncAttributes attr; 
# 2039
int maxThreadsPerMultiProcessor; 
# 2040
int warpSize; 
# 2041
int devMaxThreadsPerBlock; 
# 2042
int multiProcessorCount; 
# 2043
int funcMaxThreadsPerBlock; 
# 2044
int occupancyLimit; 
# 2045
int granularity; 
# 2048
int maxBlockSize = 0; 
# 2049
int numBlocks = 0; 
# 2050
int maxOccupancy = 0; 
# 2053
int blockSizeToTryAligned; 
# 2054
int blockSizeToTry; 
# 2055
int blockSizeLimitAligned; 
# 2056
int occupancyInBlocks; 
# 2057
int occupancyInThreads; 
# 2058
size_t dynamicSMemSize; 
# 2064
if (((!minGridSize) || (!blockSize)) || (!func)) { 
# 2065
return cudaErrorInvalidValue; 
# 2066
}  
# 2072
status = ::cudaGetDevice(&device); 
# 2073
if (status != (cudaSuccess)) { 
# 2074
return status; 
# 2075
}  
# 2077
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
# 2081
if (status != (cudaSuccess)) { 
# 2082
return status; 
# 2083
}  
# 2085
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
# 2089
if (status != (cudaSuccess)) { 
# 2090
return status; 
# 2091
}  
# 2093
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
# 2097
if (status != (cudaSuccess)) { 
# 2098
return status; 
# 2099
}  
# 2101
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
# 2105
if (status != (cudaSuccess)) { 
# 2106
return status; 
# 2107
}  
# 2109
status = cudaFuncGetAttributes(&attr, func); 
# 2110
if (status != (cudaSuccess)) { 
# 2111
return status; 
# 2112
}  
# 2114
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
# 2120
occupancyLimit = maxThreadsPerMultiProcessor; 
# 2121
granularity = warpSize; 
# 2123
if (blockSizeLimit == 0) { 
# 2124
blockSizeLimit = devMaxThreadsPerBlock; 
# 2125
}  
# 2127
if (devMaxThreadsPerBlock < blockSizeLimit) { 
# 2128
blockSizeLimit = devMaxThreadsPerBlock; 
# 2129
}  
# 2131
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
# 2132
blockSizeLimit = funcMaxThreadsPerBlock; 
# 2133
}  
# 2135
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
# 2137
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
# 2141
if (blockSizeLimit < blockSizeToTryAligned) { 
# 2142
blockSizeToTry = blockSizeLimit; 
# 2143
} else { 
# 2144
blockSizeToTry = blockSizeToTryAligned; 
# 2145
}  
# 2147
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
# 2149
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
# 2156
if (status != (cudaSuccess)) { 
# 2157
return status; 
# 2158
}  
# 2160
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
# 2162
if (occupancyInThreads > maxOccupancy) { 
# 2163
maxBlockSize = blockSizeToTry; 
# 2164
numBlocks = occupancyInBlocks; 
# 2165
maxOccupancy = occupancyInThreads; 
# 2166
}  
# 2170
if (occupancyLimit == maxOccupancy) { 
# 2171
break; 
# 2172
}  
# 2173
}  
# 2181
(*minGridSize) = (numBlocks * multiProcessorCount); 
# 2182
(*blockSize) = maxBlockSize; 
# 2184
return status; 
# 2185
} 
# 2219 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class UnaryFunction, class T> static inline cudaError_t 
# 2220
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
# 2221
minGridSize, int *
# 2222
blockSize, T 
# 2223
func, UnaryFunction 
# 2224
blockSizeToDynamicSMemSize, int 
# 2225
blockSizeLimit = 0) 
# 2226
{ 
# 2227
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
# 2228
} 
# 2265 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 2266
cudaOccupancyMaxPotentialBlockSize(int *
# 2267
minGridSize, int *
# 2268
blockSize, T 
# 2269
func, size_t 
# 2270
dynamicSMemSize = 0, int 
# 2271
blockSizeLimit = 0) 
# 2272
{ 
# 2273
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
# 2274
} 
# 2303 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 2304
cudaOccupancyAvailableDynamicSMemPerBlock(size_t *
# 2305
dynamicSmemSize, T 
# 2306
func, int 
# 2307
numBlocks, int 
# 2308
blockSize) 
# 2309
{ 
# 2310
return ::cudaOccupancyAvailableDynamicSMemPerBlock(dynamicSmemSize, (const void *)func, numBlocks, blockSize); 
# 2311
} 
# 2362 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 2363
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
# 2364
minGridSize, int *
# 2365
blockSize, T 
# 2366
func, size_t 
# 2367
dynamicSMemSize = 0, int 
# 2368
blockSizeLimit = 0, unsigned 
# 2369
flags = 0) 
# 2370
{ 
# 2371
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
# 2372
} 
# 2405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> inline cudaError_t 
# 2406
cudaFuncGetAttributes(cudaFuncAttributes *
# 2407
attr, T *
# 2408
entry) 
# 2410
{ 
# 2411
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
# 2412
} 
# 2450 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T> static inline cudaError_t 
# 2451
cudaFuncSetAttribute(T *
# 2452
entry, cudaFuncAttribute 
# 2453
attr, int 
# 2454
value) 
# 2456
{ 
# 2457
return ::cudaFuncSetAttribute((const void *)entry, attr, value); 
# 2458
} 
# 2482 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim> 
# 2483
__attribute((deprecated)) static inline cudaError_t cudaBindSurfaceToArray(const surface< T, dim>  &
# 2484
surf, cudaArray_const_t 
# 2485
array, const cudaChannelFormatDesc &
# 2486
desc) 
# 2488
{ 
# 2489
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
# 2490
} 
# 2513 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
template< class T, int dim> 
# 2514
__attribute((deprecated)) static inline cudaError_t cudaBindSurfaceToArray(const surface< T, dim>  &
# 2515
surf, cudaArray_const_t 
# 2516
array) 
# 2518
{ 
# 2519
cudaChannelFormatDesc desc; 
# 2520
cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
# 2522
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
# 2523
} 
# 2534 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_runtime.h"
#pragma GCC diagnostic pop
# 50 "/usr/include/c++/9/bits/memoryfwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63 "/usr/include/c++/9/bits/memoryfwd.h" 3
template< class > class allocator; 
# 67
template<> class allocator< void> ; 
# 71
template< class , class > struct uses_allocator; 
# 78
}
# 42 "/usr/include/c++/9/bits/stringfwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _CharT> struct char_traits; 
# 55
template<> struct char_traits< char> ; 
# 58
template<> struct char_traits< wchar_t> ; 
# 66
template<> struct char_traits< char16_t> ; 
# 67
template<> struct char_traits< char32_t> ; 
# 70
inline namespace __cxx11 { 
# 72
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 73
_Alloc = allocator< _CharT> > class basic_string; 
# 76
}
# 79
typedef __cxx11::basic_string< char>  string; 
# 83
typedef __cxx11::basic_string< wchar_t>  wstring; 
# 93 "/usr/include/c++/9/bits/stringfwd.h" 3
typedef __cxx11::basic_string< char16_t>  u16string; 
# 96
typedef __cxx11::basic_string< char32_t>  u32string; 
# 102
}
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list; 
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3
typedef unsigned wint_t; 
# 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3
typedef 
# 14
struct { 
# 15
int __count; 
# 17
union { 
# 18
unsigned __wch; 
# 19
char __wchb[4]; 
# 20
} __value; 
# 21
} __mbstate_t; 
# 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 3
typedef __mbstate_t mbstate_t; 
# 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 3
struct _IO_FILE; 
# 5
typedef _IO_FILE __FILE; 
# 4 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 3
struct _IO_FILE; 
# 7
typedef _IO_FILE FILE; 
# 79 "/usr/include/wchar.h" 3
extern "C" {
# 83
struct tm; 
# 87
extern wchar_t *wcscpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw()
# 89
 __attribute((__nonnull__(1, 2))); 
# 92
extern wchar_t *wcsncpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw()
# 94
 __attribute((__nonnull__(1, 2))); 
# 97
extern wchar_t *wcscat(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw()
# 99
 __attribute((__nonnull__(1, 2))); 
# 101
extern wchar_t *wcsncat(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw()
# 103
 __attribute((__nonnull__(1, 2))); 
# 106
extern int wcscmp(const wchar_t * __s1, const wchar_t * __s2) throw()
# 107
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 109
extern int wcsncmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw()
# 110
 __attribute((__pure__)) __attribute((__nonnull__(1, 2))); 
# 114
extern int wcscasecmp(const wchar_t * __s1, const wchar_t * __s2) throw(); 
# 117
extern int wcsncasecmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw(); 
# 122
extern int wcscasecmp_l(const wchar_t * __s1, const wchar_t * __s2, locale_t __loc) throw(); 
# 125
extern int wcsncasecmp_l(const wchar_t * __s1, const wchar_t * __s2, size_t __n, locale_t __loc) throw(); 
# 131
extern int wcscoll(const wchar_t * __s1, const wchar_t * __s2) throw(); 
# 135
extern size_t wcsxfrm(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 144
extern int wcscoll_l(const wchar_t * __s1, const wchar_t * __s2, locale_t __loc) throw(); 
# 150
extern size_t wcsxfrm_l(wchar_t * __s1, const wchar_t * __s2, size_t __n, locale_t __loc) throw(); 
# 154
extern wchar_t *wcsdup(const wchar_t * __s) throw() __attribute((__malloc__)); 
# 159
extern "C++" wchar_t *wcschr(wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcschr")
# 160
 __attribute((__pure__)); 
# 161
extern "C++" const wchar_t *wcschr(const wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcschr")
# 162
 __attribute((__pure__)); 
# 169
extern "C++" wchar_t *wcsrchr(wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcsrchr")
# 170
 __attribute((__pure__)); 
# 171
extern "C++" const wchar_t *wcsrchr(const wchar_t * __wcs, wchar_t __wc) throw() __asm__("wcsrchr")
# 172
 __attribute((__pure__)); 
# 181 "/usr/include/wchar.h" 3
extern wchar_t *wcschrnul(const wchar_t * __s, wchar_t __wc) throw()
# 182
 __attribute((__pure__)); 
# 187
extern size_t wcscspn(const wchar_t * __wcs, const wchar_t * __reject) throw()
# 188
 __attribute((__pure__)); 
# 191
extern size_t wcsspn(const wchar_t * __wcs, const wchar_t * __accept) throw()
# 192
 __attribute((__pure__)); 
# 195
extern "C++" wchar_t *wcspbrk(wchar_t * __wcs, const wchar_t * __accept) throw() __asm__("wcspbrk")
# 196
 __attribute((__pure__)); 
# 197
extern "C++" const wchar_t *wcspbrk(const wchar_t * __wcs, const wchar_t * __accept) throw() __asm__("wcspbrk")
# 199
 __attribute((__pure__)); 
# 206
extern "C++" wchar_t *wcsstr(wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcsstr")
# 207
 __attribute((__pure__)); 
# 208
extern "C++" const wchar_t *wcsstr(const wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcsstr")
# 210
 __attribute((__pure__)); 
# 217
extern wchar_t *wcstok(wchar_t *__restrict__ __s, const wchar_t *__restrict__ __delim, wchar_t **__restrict__ __ptr) throw(); 
# 222
extern size_t wcslen(const wchar_t * __s) throw() __attribute((__pure__)); 
# 227
extern "C++" wchar_t *wcswcs(wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcswcs")
# 228
 __attribute((__pure__)); 
# 229
extern "C++" const wchar_t *wcswcs(const wchar_t * __haystack, const wchar_t * __needle) throw() __asm__("wcswcs")
# 231
 __attribute((__pure__)); 
# 240 "/usr/include/wchar.h" 3
extern size_t wcsnlen(const wchar_t * __s, size_t __maxlen) throw()
# 241
 __attribute((__pure__)); 
# 247
extern "C++" wchar_t *wmemchr(wchar_t * __s, wchar_t __c, size_t __n) throw() __asm__("wmemchr")
# 248
 __attribute((__pure__)); 
# 249
extern "C++" const wchar_t *wmemchr(const wchar_t * __s, wchar_t __c, size_t __n) throw() __asm__("wmemchr")
# 251
 __attribute((__pure__)); 
# 258
extern int wmemcmp(const wchar_t * __s1, const wchar_t * __s2, size_t __n) throw()
# 259
 __attribute((__pure__)); 
# 262
extern wchar_t *wmemcpy(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 267
extern wchar_t *wmemmove(wchar_t * __s1, const wchar_t * __s2, size_t __n) throw(); 
# 271
extern wchar_t *wmemset(wchar_t * __s, wchar_t __c, size_t __n) throw(); 
# 276
extern wchar_t *wmempcpy(wchar_t *__restrict__ __s1, const wchar_t *__restrict__ __s2, size_t __n) throw(); 
# 284
extern wint_t btowc(int __c) throw(); 
# 288
extern int wctob(wint_t __c) throw(); 
# 292
extern int mbsinit(const mbstate_t * __ps) throw() __attribute((__pure__)); 
# 296
extern size_t mbrtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __p) throw(); 
# 301
extern size_t wcrtomb(char *__restrict__ __s, wchar_t __wc, mbstate_t *__restrict__ __ps) throw(); 
# 305
extern size_t __mbrlen(const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __ps) throw(); 
# 307
extern size_t mbrlen(const char *__restrict__ __s, size_t __n, mbstate_t *__restrict__ __ps) throw(); 
# 337 "/usr/include/wchar.h" 3
extern size_t mbsrtowcs(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 343
extern size_t wcsrtombs(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 351
extern size_t mbsnrtowcs(wchar_t *__restrict__ __dst, const char **__restrict__ __src, size_t __nmc, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 357
extern size_t wcsnrtombs(char *__restrict__ __dst, const wchar_t **__restrict__ __src, size_t __nwc, size_t __len, mbstate_t *__restrict__ __ps) throw(); 
# 367
extern int wcwidth(wchar_t __c) throw(); 
# 371
extern int wcswidth(const wchar_t * __s, size_t __n) throw(); 
# 377
extern double wcstod(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 382
extern float wcstof(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 384
extern long double wcstold(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 396 "/usr/include/wchar.h" 3
extern _Float32 wcstof32(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 401
extern _Float64 wcstof64(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 411 "/usr/include/wchar.h" 3
extern _Float32x wcstof32x(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 416
extern _Float64x wcstof64x(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr) throw(); 
# 428 "/usr/include/wchar.h" 3
extern long wcstol(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 433
extern unsigned long wcstoul(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 441
__extension__ extern long long wcstoll(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 448
__extension__ extern unsigned long long wcstoull(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 457
__extension__ extern long long wcstoq(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 464
__extension__ extern unsigned long long wcstouq(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base) throw(); 
# 473
extern long wcstol_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, locale_t __loc) throw(); 
# 477
extern unsigned long wcstoul_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, locale_t __loc) throw(); 
# 482
__extension__ extern long long wcstoll_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, locale_t __loc) throw(); 
# 487
__extension__ extern unsigned long long wcstoull_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, int __base, locale_t __loc) throw(); 
# 492
extern double wcstod_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, locale_t __loc) throw(); 
# 496
extern float wcstof_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, locale_t __loc) throw(); 
# 500
extern long double wcstold_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, locale_t __loc) throw(); 
# 511 "/usr/include/wchar.h" 3
extern _Float32 wcstof32_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, locale_t __loc) throw(); 
# 517
extern _Float64 wcstof64_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, locale_t __loc) throw(); 
# 529 "/usr/include/wchar.h" 3
extern _Float32x wcstof32x_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, locale_t __loc) throw(); 
# 535
extern _Float64x wcstof64x_l(const wchar_t *__restrict__ __nptr, wchar_t **__restrict__ __endptr, locale_t __loc) throw(); 
# 551 "/usr/include/wchar.h" 3
extern wchar_t *wcpcpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src) throw(); 
# 556
extern wchar_t *wcpncpy(wchar_t *__restrict__ __dest, const wchar_t *__restrict__ __src, size_t __n) throw(); 
# 567 "/usr/include/wchar.h" 3
extern __FILE *open_wmemstream(wchar_t ** __bufloc, size_t * __sizeloc) throw(); 
# 573
extern int fwide(__FILE * __fp, int __mode) throw(); 
# 580
extern int fwprintf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ __format, ...); 
# 587
extern int wprintf(const wchar_t *__restrict__ __format, ...); 
# 590
extern int swprintf(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __format, ...) throw(); 
# 598
extern int vfwprintf(__FILE *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 606
extern int vwprintf(const wchar_t *__restrict__ __format, __gnuc_va_list __arg); 
# 611
extern int vswprintf(wchar_t *__restrict__ __s, size_t __n, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 621
extern int fwscanf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ __format, ...) __asm__("__isoc99_fwscanf"); 
# 628
extern int wscanf(const wchar_t *__restrict__ __format, ...) __asm__("__isoc99_wscanf"); 
# 631
extern int swscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format, ...) throw() __asm__("__isoc99_swscanf"); 
# 640
extern int fwscanf(__FILE *__restrict__ __stream, const wchar_t *__restrict__ __format, ...) __asm__("__isoc99_fwscanf"); 
# 644
extern int wscanf(const wchar_t *__restrict__ __format, ...) __asm__("__isoc99_wscanf"); 
# 647
extern int swscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format, ...) throw() __asm__("__isoc99_swscanf"); 
# 671 "/usr/include/wchar.h" 3
extern int vfwscanf(__FILE *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) __asm__("__isoc99_vfwscanf"); 
# 679
extern int vwscanf(const wchar_t *__restrict__ __format, __gnuc_va_list __arg) __asm__("__isoc99_vwscanf"); 
# 683
extern int vswscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) throw() __asm__("__isoc99_vswscanf"); 
# 693
extern int vfwscanf(__FILE *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) __asm__("__isoc99_vfwscanf"); 
# 697
extern int vwscanf(const wchar_t *__restrict__ __format, __gnuc_va_list __arg) __asm__("__isoc99_vwscanf"); 
# 700
extern int vswscanf(const wchar_t *__restrict__ __s, const wchar_t *__restrict__ __format, __gnuc_va_list __arg) throw() __asm__("__isoc99_vswscanf"); 
# 726 "/usr/include/wchar.h" 3
extern wint_t fgetwc(__FILE * __stream); 
# 727
extern wint_t getwc(__FILE * __stream); 
# 733
extern wint_t getwchar(); 
# 740
extern wint_t fputwc(wchar_t __wc, __FILE * __stream); 
# 741
extern wint_t putwc(wchar_t __wc, __FILE * __stream); 
# 747
extern wint_t putwchar(wchar_t __wc); 
# 755
extern wchar_t *fgetws(wchar_t *__restrict__ __ws, int __n, __FILE *__restrict__ __stream); 
# 762
extern int fputws(const wchar_t *__restrict__ __ws, __FILE *__restrict__ __stream); 
# 770
extern wint_t ungetwc(wint_t __wc, __FILE * __stream); 
# 781 "/usr/include/wchar.h" 3
extern wint_t getwc_unlocked(__FILE * __stream); 
# 782
extern wint_t getwchar_unlocked(); 
# 790
extern wint_t fgetwc_unlocked(__FILE * __stream); 
# 798
extern wint_t fputwc_unlocked(wchar_t __wc, __FILE * __stream); 
# 807 "/usr/include/wchar.h" 3
extern wint_t putwc_unlocked(wchar_t __wc, __FILE * __stream); 
# 808
extern wint_t putwchar_unlocked(wchar_t __wc); 
# 817 "/usr/include/wchar.h" 3
extern wchar_t *fgetws_unlocked(wchar_t *__restrict__ __ws, int __n, __FILE *__restrict__ __stream); 
# 826
extern int fputws_unlocked(const wchar_t *__restrict__ __ws, __FILE *__restrict__ __stream); 
# 834
extern size_t wcsftime(wchar_t *__restrict__ __s, size_t __maxsize, const wchar_t *__restrict__ __format, const tm *__restrict__ __tp) throw(); 
# 841
extern size_t wcsftime_l(wchar_t *__restrict__ __s, size_t __maxsize, const wchar_t *__restrict__ __format, const tm *__restrict__ __tp, locale_t __loc) throw(); 
# 856 "/usr/include/wchar.h" 3
}
# 62 "/usr/include/c++/9/cwchar" 3
namespace std { 
# 64
using ::mbstate_t;
# 65
}
# 135 "/usr/include/c++/9/cwchar" 3
extern "C++" {
# 137
namespace std __attribute((__visibility__("default"))) { 
# 141
using ::wint_t;
# 143
using ::btowc;
# 144
using ::fgetwc;
# 145
using ::fgetws;
# 146
using ::fputwc;
# 147
using ::fputws;
# 148
using ::fwide;
# 149
using ::fwprintf;
# 150
using ::fwscanf;
# 151
using ::getwc;
# 152
using ::getwchar;
# 153
using ::mbrlen;
# 154
using ::mbrtowc;
# 155
using ::mbsinit;
# 156
using ::mbsrtowcs;
# 157
using ::putwc;
# 158
using ::putwchar;
# 160
using ::swprintf;
# 162
using ::swscanf;
# 163
using ::ungetwc;
# 164
using ::vfwprintf;
# 166
using ::vfwscanf;
# 169
using ::vswprintf;
# 172
using ::vswscanf;
# 174
using ::vwprintf;
# 176
using ::vwscanf;
# 178
using ::wcrtomb;
# 179
using ::wcscat;
# 180
using ::wcscmp;
# 181
using ::wcscoll;
# 182
using ::wcscpy;
# 183
using ::wcscspn;
# 184
using ::wcsftime;
# 185
using ::wcslen;
# 186
using ::wcsncat;
# 187
using ::wcsncmp;
# 188
using ::wcsncpy;
# 189
using ::wcsrtombs;
# 190
using ::wcsspn;
# 191
using ::wcstod;
# 193
using ::wcstof;
# 195
using ::wcstok;
# 196
using ::wcstol;
# 197
using ::wcstoul;
# 198
using ::wcsxfrm;
# 199
using ::wctob;
# 200
using ::wmemcmp;
# 201
using ::wmemcpy;
# 202
using ::wmemmove;
# 203
using ::wmemset;
# 204
using ::wprintf;
# 205
using ::wscanf;
# 206
using ::wcschr;
# 207
using ::wcspbrk;
# 208
using ::wcsrchr;
# 209
using ::wcsstr;
# 210
using ::wmemchr;
# 235 "/usr/include/c++/9/cwchar" 3
}
# 236
}
# 244
namespace __gnu_cxx { 
# 251
using ::wcstold;
# 260 "/usr/include/c++/9/cwchar" 3
using ::wcstoll;
# 261
using ::wcstoull;
# 263
}
# 265
namespace std { 
# 267
using __gnu_cxx::wcstold;
# 268
using __gnu_cxx::wcstoll;
# 269
using __gnu_cxx::wcstoull;
# 270
}
# 280 "/usr/include/c++/9/cwchar" 3
namespace std { 
# 300
}
# 68 "/usr/include/c++/9/bits/postypes.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 88 "/usr/include/c++/9/bits/postypes.h" 3
typedef long streamoff; 
# 98 "/usr/include/c++/9/bits/postypes.h" 3
typedef ptrdiff_t streamsize; 
# 111 "/usr/include/c++/9/bits/postypes.h" 3
template< class _StateT> 
# 112
class fpos { 
# 115
streamoff _M_off; 
# 116
_StateT _M_state; 
# 123
public: fpos() : _M_off((0)), _M_state() 
# 124
{ } 
# 133 "/usr/include/c++/9/bits/postypes.h" 3
fpos(streamoff __off) : _M_off(__off), _M_state() 
# 134
{ } 
# 137
fpos(const fpos &) = default;
# 138
fpos &operator=(const fpos &) = default;
# 139
~fpos() = default;
# 143
operator streamoff() const { return _M_off; } 
# 147
void state(_StateT __st) 
# 148
{ (_M_state) = __st; } 
# 152
_StateT state() const 
# 153
{ return _M_state; } 
# 160
fpos &operator+=(streamoff __off) 
# 161
{ 
# 162
(_M_off) += __off; 
# 163
return *this; 
# 164
} 
# 171
fpos &operator-=(streamoff __off) 
# 172
{ 
# 173
(_M_off) -= __off; 
# 174
return *this; 
# 175
} 
# 184
fpos operator+(streamoff __off) const 
# 185
{ 
# 186
fpos __pos(*this); 
# 187
__pos += __off; 
# 188
return __pos; 
# 189
} 
# 198
fpos operator-(streamoff __off) const 
# 199
{ 
# 200
fpos __pos(*this); 
# 201
__pos -= __off; 
# 202
return __pos; 
# 203
} 
# 211
streamoff operator-(const fpos &__other) const 
# 212
{ return (_M_off) - (__other._M_off); } 
# 213
}; 
# 220
template< class _StateT> inline bool 
# 222
operator==(const fpos< _StateT>  &__lhs, const fpos< _StateT>  &__rhs) 
# 223
{ return ((streamoff)__lhs) == ((streamoff)__rhs); } 
# 225
template< class _StateT> inline bool 
# 227
operator!=(const fpos< _StateT>  &__lhs, const fpos< _StateT>  &__rhs) 
# 228
{ return ((streamoff)__lhs) != ((streamoff)__rhs); } 
# 234
typedef fpos< __mbstate_t>  streampos; 
# 236
typedef fpos< __mbstate_t>  wstreampos; 
# 245 "/usr/include/c++/9/bits/postypes.h" 3
typedef fpos< __mbstate_t>  u16streampos; 
# 247
typedef fpos< __mbstate_t>  u32streampos; 
# 251
}
# 42 "/usr/include/c++/9/iosfwd" 3
namespace std __attribute((__visibility__("default"))) { 
# 74 "/usr/include/c++/9/iosfwd" 3
class ios_base; 
# 76
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ios; 
# 79
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_streambuf; 
# 82
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_istream; 
# 85
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ostream; 
# 88
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_iostream; 
# 92
inline namespace __cxx11 { 
# 94
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 95
_Alloc = allocator< _CharT> > class basic_stringbuf; 
# 98
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 99
_Alloc = allocator< _CharT> > class basic_istringstream; 
# 102
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 103
_Alloc = allocator< _CharT> > class basic_ostringstream; 
# 106
template< class _CharT, class _Traits = char_traits< _CharT> , class 
# 107
_Alloc = allocator< _CharT> > class basic_stringstream; 
# 110
}
# 112
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_filebuf; 
# 115
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ifstream; 
# 118
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_ofstream; 
# 121
template< class _CharT, class _Traits = char_traits< _CharT> > class basic_fstream; 
# 124
template< class _CharT, class _Traits = char_traits< _CharT> > class istreambuf_iterator; 
# 127
template< class _CharT, class _Traits = char_traits< _CharT> > class ostreambuf_iterator; 
# 132
typedef basic_ios< char>  ios; 
# 135
typedef basic_streambuf< char>  streambuf; 
# 138
typedef basic_istream< char>  istream; 
# 141
typedef basic_ostream< char>  ostream; 
# 144
typedef basic_iostream< char>  iostream; 
# 147
typedef __cxx11::basic_stringbuf< char>  stringbuf; 
# 150
typedef __cxx11::basic_istringstream< char>  istringstream; 
# 153
typedef __cxx11::basic_ostringstream< char>  ostringstream; 
# 156
typedef __cxx11::basic_stringstream< char>  stringstream; 
# 159
typedef basic_filebuf< char>  filebuf; 
# 162
typedef basic_ifstream< char>  ifstream; 
# 165
typedef basic_ofstream< char>  ofstream; 
# 168
typedef basic_fstream< char>  fstream; 
# 172
typedef basic_ios< wchar_t>  wios; 
# 175
typedef basic_streambuf< wchar_t>  wstreambuf; 
# 178
typedef basic_istream< wchar_t>  wistream; 
# 181
typedef basic_ostream< wchar_t>  wostream; 
# 184
typedef basic_iostream< wchar_t>  wiostream; 
# 187
typedef __cxx11::basic_stringbuf< wchar_t>  wstringbuf; 
# 190
typedef __cxx11::basic_istringstream< wchar_t>  wistringstream; 
# 193
typedef __cxx11::basic_ostringstream< wchar_t>  wostringstream; 
# 196
typedef __cxx11::basic_stringstream< wchar_t>  wstringstream; 
# 199
typedef basic_filebuf< wchar_t>  wfilebuf; 
# 202
typedef basic_ifstream< wchar_t>  wifstream; 
# 205
typedef basic_ofstream< wchar_t>  wofstream; 
# 208
typedef basic_fstream< wchar_t>  wfstream; 
# 213
}
# 35 "/usr/include/c++/9/exception" 3
#pragma GCC visibility push ( default )
# 36 "/usr/include/c++/9/bits/exception.h" 3
#pragma GCC visibility push ( default )
# 40
extern "C++" {
# 42
namespace std { 
# 60 "/usr/include/c++/9/bits/exception.h" 3
class exception { 
# 63
public: exception() noexcept { } 
# 64
virtual ~exception() noexcept; 
# 66
exception(const exception &) = default;
# 67
exception &operator=(const exception &) = default;
# 68
exception(exception &&) = default;
# 69
exception &operator=(exception &&) = default;
# 75
virtual const char *what() const noexcept; 
# 76
}; 
# 80
}
# 82
}
# 84
#pragma GCC visibility pop
# 40 "/usr/include/c++/9/exception" 3
extern "C++" {
# 42
namespace std { 
# 46
class bad_exception : public exception { 
# 49
public: bad_exception() noexcept { } 
# 53
virtual ~bad_exception() noexcept; 
# 57
virtual const char *what() const noexcept; 
# 58
}; 
# 61
typedef void (*terminate_handler)(void); 
# 64
typedef void (*unexpected_handler)(void); 
# 67
terminate_handler set_terminate(terminate_handler) noexcept; 
# 71
terminate_handler get_terminate() noexcept; 
# 76
void terminate() noexcept __attribute((__noreturn__)); 
# 79
unexpected_handler set_unexpected(unexpected_handler) noexcept; 
# 83
unexpected_handler get_unexpected() noexcept; 
# 88
void unexpected() __attribute((__noreturn__)); 
# 102 "/usr/include/c++/9/exception" 3
bool uncaught_exception() noexcept __attribute((__pure__)); 
# 107
int uncaught_exceptions() noexcept __attribute((__pure__)); 
# 111
}
# 113
namespace __gnu_cxx { 
# 133 "/usr/include/c++/9/exception" 3
void __verbose_terminate_handler(); 
# 136
}
# 138
}
# 140
#pragma GCC visibility pop
# 34 "/usr/include/c++/9/bits/exception_ptr.h" 3
#pragma GCC visibility push ( default )
# 36 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 3
#pragma GCC visibility push ( default )
# 50 "/usr/include/c++/9/bits/cxxabi_init_exception.h" 3
namespace std { 
# 52
class type_info; 
# 53
}
# 55
namespace __cxxabiv1 { 
# 57
struct __cxa_refcounted_exception; 
# 59
extern "C" {
# 63
void *__cxa_allocate_exception(size_t) noexcept; 
# 66
void __cxa_free_exception(void *) noexcept; 
# 70
__cxa_refcounted_exception *__cxa_init_primary_exception(void * object, std::type_info * tinfo, void (* dest)(void *)) noexcept; 
# 73
}
# 74
}
# 78
#pragma GCC visibility pop
# 37 "/usr/include/c++/9/bits/hash_bytes.h" 3
namespace std { 
# 47
size_t _Hash_bytes(const void * __ptr, size_t __len, size_t __seed); 
# 54
size_t _Fnv_hash_bytes(const void * __ptr, size_t __len, size_t __seed); 
# 57
}
# 39 "/usr/include/c++/9/typeinfo" 3
#pragma GCC visibility push ( default )
# 41
extern "C++" {
# 43
namespace __cxxabiv1 { 
# 45
class __class_type_info; 
# 46
}
# 80 "/usr/include/c++/9/typeinfo" 3
namespace std { 
# 88
class type_info { 
# 95
public: virtual ~type_info(); 
# 99
const char *name() const noexcept 
# 100
{ return (((__name)[0]) == ('*')) ? (__name) + 1 : (__name); } 
# 115 "/usr/include/c++/9/typeinfo" 3
bool before(const type_info &__arg) const noexcept 
# 116
{ return ((((__name)[0]) == ('*')) && (((__arg.__name)[0]) == ('*'))) ? (__name) < (__arg.__name) : (__builtin_strcmp(__name, __arg.__name) < 0); 
# 118
} 
# 120
bool operator==(const type_info &__arg) const noexcept 
# 121
{ 
# 122
return (((__name) == (__arg.__name)) || ((((__name)[0]) != ('*')) && (__builtin_strcmp(__name, __arg.__name) == 0))); 
# 125
} 
# 136 "/usr/include/c++/9/typeinfo" 3
bool operator!=(const type_info &__arg) const noexcept 
# 137
{ return !this->operator==(__arg); } 
# 140
size_t hash_code() const noexcept 
# 141
{ 
# 143
return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast< size_t>(3339675911UL)); 
# 148
} 
# 152
virtual bool __is_pointer_p() const; 
# 155
virtual bool __is_function_p() const; 
# 163
virtual bool __do_catch(const type_info * __thr_type, void ** __thr_obj, unsigned __outer) const; 
# 167
virtual bool __do_upcast(const __cxxabiv1::__class_type_info * __target, void ** __obj_ptr) const; 
# 171
protected: const char *__name; 
# 173
explicit type_info(const char *__n) : __name(__n) { } 
# 177
private: type_info &operator=(const type_info &); 
# 178
type_info(const type_info &); 
# 179
}; 
# 187
class bad_cast : public exception { 
# 190
public: bad_cast() noexcept { } 
# 194
virtual ~bad_cast() noexcept; 
# 197
virtual const char *what() const noexcept; 
# 198
}; 
# 204
class bad_typeid : public exception { 
# 207
public: bad_typeid() noexcept { } 
# 211
virtual ~bad_typeid() noexcept; 
# 214
virtual const char *what() const noexcept; 
# 215
}; 
# 216
}
# 218
}
# 220
#pragma GCC visibility pop
# 42 "/usr/include/c++/9/new" 3
#pragma GCC visibility push ( default )
# 44
extern "C++" {
# 46
namespace std { 
# 54
class bad_alloc : public exception { 
# 57
public: bad_alloc() throw() { } 
# 60
bad_alloc(const bad_alloc &) = default;
# 61
bad_alloc &operator=(const bad_alloc &) = default;
# 66
virtual ~bad_alloc() throw(); 
# 69
virtual const char *what() const throw(); 
# 70
}; 
# 73
class bad_array_new_length : public bad_alloc { 
# 76
public: bad_array_new_length() throw() { } 
# 80
virtual ~bad_array_new_length() throw(); 
# 83
virtual const char *what() const throw(); 
# 84
}; 
# 91
struct nothrow_t { 
# 94
explicit nothrow_t() = default;
# 96
}; 
# 98
extern const nothrow_t nothrow; 
# 102
typedef void (*new_handler)(void); 
# 106
new_handler set_new_handler(new_handler) throw(); 
# 110
new_handler get_new_handler() noexcept; 
# 112
}
# 125 "/usr/include/c++/9/new" 3
void *operator new(std::size_t)
# 126
 __attribute((__externally_visible__)); 
# 127
void *operator new[](std::size_t)
# 128
 __attribute((__externally_visible__)); 
# 129
void operator delete(void *) noexcept
# 130
 __attribute((__externally_visible__)); 
# 131
void operator delete[](void *) noexcept
# 132
 __attribute((__externally_visible__)); 
# 134
void operator delete(void *, std::size_t) noexcept
# 135
 __attribute((__externally_visible__)); 
# 136
void operator delete[](void *, std::size_t) noexcept
# 137
 __attribute((__externally_visible__)); 
# 139
void *operator new(std::size_t, const std::nothrow_t &) noexcept
# 140
 __attribute((__externally_visible__, __malloc__)); 
# 141
void *operator new[](std::size_t, const std::nothrow_t &) noexcept
# 142
 __attribute((__externally_visible__, __malloc__)); 
# 143
void operator delete(void *, const std::nothrow_t &) noexcept
# 144
 __attribute((__externally_visible__)); 
# 145
void operator delete[](void *, const std::nothrow_t &) noexcept
# 146
 __attribute((__externally_visible__)); 
# 173 "/usr/include/c++/9/new" 3
inline void *operator new(std::size_t, void *__p) noexcept 
# 174
{ return __p; } 
# 175
inline void *operator new[](std::size_t, void *__p) noexcept 
# 176
{ return __p; } 
# 179
inline void operator delete(void *, void *) noexcept { } 
# 180
inline void operator delete[](void *, void *) noexcept { } 
# 182
}
# 226 "/usr/include/c++/9/new" 3
#pragma GCC visibility pop
# 42 "/usr/include/c++/9/bits/exception_ptr.h" 3
extern "C++" {
# 44
namespace std { 
# 46
class type_info; 
# 52
namespace __exception_ptr { 
# 54
class exception_ptr; 
# 55
}
# 57
using __exception_ptr::exception_ptr;
# 63
__exception_ptr::exception_ptr current_exception() noexcept; 
# 65
template< class _Ex> __exception_ptr::exception_ptr make_exception_ptr(_Ex) noexcept; 
# 69
void rethrow_exception(__exception_ptr::exception_ptr) __attribute((__noreturn__)); 
# 71
namespace __exception_ptr { 
# 73
using std::rethrow_exception;
# 79
class exception_ptr { 
# 81
void *_M_exception_object; 
# 83
explicit exception_ptr(void * __e) noexcept; 
# 85
void _M_addref() noexcept; 
# 86
void _M_release() noexcept; 
# 88
void *_M_get() const noexcept __attribute((__pure__)); 
# 90
friend exception_ptr std::current_exception() noexcept; 
# 91
friend void std::rethrow_exception(exception_ptr); 
# 92
template< class _Ex> friend exception_ptr std::make_exception_ptr(_Ex) noexcept; 
# 96
public: exception_ptr() noexcept; 
# 98
exception_ptr(const exception_ptr &) noexcept; 
# 101
exception_ptr(nullptr_t) noexcept : _M_exception_object((0)) 
# 103
{ } 
# 105
exception_ptr(exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object) 
# 107
{ (__o._M_exception_object) = (0); } 
# 118 "/usr/include/c++/9/bits/exception_ptr.h" 3
exception_ptr &operator=(const exception_ptr &) noexcept; 
# 122
exception_ptr &operator=(exception_ptr &&__o) noexcept 
# 123
{ 
# 124
((exception_ptr)(static_cast< exception_ptr &&>(__o))).swap(*this); 
# 125
return *this; 
# 126
} 
# 129
~exception_ptr() noexcept; 
# 132
void swap(exception_ptr &) noexcept; 
# 144 "/usr/include/c++/9/bits/exception_ptr.h" 3
explicit operator bool() const 
# 145
{ return _M_exception_object; } 
# 149
friend bool operator==(const exception_ptr &, const exception_ptr &) noexcept
# 150
 __attribute((__pure__)); 
# 153
const type_info *__cxa_exception_type() const noexcept
# 154
 __attribute((__pure__)); 
# 155
}; 
# 158
bool operator==(const exception_ptr &, const exception_ptr &) noexcept
# 159
 __attribute((__pure__)); 
# 162
bool operator!=(const exception_ptr &, const exception_ptr &) noexcept
# 163
 __attribute((__pure__)); 
# 166
inline void swap(exception_ptr &__lhs, exception_ptr &__rhs) 
# 167
{ __lhs.swap(__rhs); } 
# 169
template< class _Ex> inline void 
# 171
__dest_thunk(void *__x) 
# 172
{ (static_cast< _Ex *>(__x))->~_Ex(); } 
# 174
}
# 177
template< class _Ex> __exception_ptr::exception_ptr 
# 179
make_exception_ptr(_Ex __ex) noexcept 
# 180
{ 
# 182
void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex)); 
# 183
(void)__cxxabiv1::__cxa_init_primary_exception(__e, const_cast< type_info *>(&typeid(__ex)), __exception_ptr::__dest_thunk< _Ex> ); 
# 186
try 
# 187
{ 
# 188
::new (__e) _Ex(__ex); 
# 189
return ((__exception_ptr::exception_ptr)(__e)); 
# 190
} 
# 191
catch (...) 
# 192
{ 
# 193
__cxxabiv1::__cxa_free_exception(__e); 
# 194
return current_exception(); 
# 195
}  
# 208 "/usr/include/c++/9/bits/exception_ptr.h" 3
} 
# 211
}
# 213
}
# 215
#pragma GCC visibility pop
# 33 "/usr/include/c++/9/bits/nested_exception.h" 3
#pragma GCC visibility push ( default )
# 36 "/usr/include/c++/9/bits/move.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _Tp> constexpr _Tp *
# 47
__addressof(_Tp &__r) noexcept 
# 48
{ return __builtin_addressof(__r); } 
# 53
}
# 40 "/usr/include/c++/9/type_traits" 3
namespace std __attribute((__visibility__("default"))) { 
# 56 "/usr/include/c++/9/type_traits" 3
template< class _Tp, _Tp __v> 
# 57
struct integral_constant { 
# 59
static constexpr _Tp value = (__v); 
# 60
typedef _Tp value_type; 
# 61
typedef integral_constant type; 
# 62
constexpr operator value_type() const noexcept { return value; } 
# 67
constexpr value_type operator()() const noexcept { return value; } 
# 69
}; 
# 71
template< class _Tp, _Tp __v> constexpr _Tp integral_constant< _Tp, __v> ::value; 
# 75
typedef integral_constant< bool, true>  true_type; 
# 78
typedef integral_constant< bool, false>  false_type; 
# 80
template< bool __v> using __bool_constant = integral_constant< bool, __v> ; 
# 91 "/usr/include/c++/9/type_traits" 3
template< bool , class , class > struct conditional; 
# 94
template< class ...> struct __or_; 
# 98
template<> struct __or_< >  : public false_type { 
# 100
}; 
# 102
template< class _B1> 
# 103
struct __or_< _B1>  : public _B1 { 
# 105
}; 
# 107
template< class _B1, class _B2> 
# 108
struct __or_< _B1, _B2>  : public conditional< _B1::value, _B1, _B2> ::type { 
# 110
}; 
# 112
template< class _B1, class _B2, class _B3, class ..._Bn> 
# 113
struct __or_< _B1, _B2, _B3, _Bn...>  : public conditional< _B1::value, _B1, std::__or_< _B2, _B3, _Bn...> > ::type { 
# 115
}; 
# 117
template< class ...> struct __and_; 
# 121
template<> struct __and_< >  : public true_type { 
# 123
}; 
# 125
template< class _B1> 
# 126
struct __and_< _B1>  : public _B1 { 
# 128
}; 
# 130
template< class _B1, class _B2> 
# 131
struct __and_< _B1, _B2>  : public conditional< _B1::value, _B2, _B1> ::type { 
# 133
}; 
# 135
template< class _B1, class _B2, class _B3, class ..._Bn> 
# 136
struct __and_< _B1, _B2, _B3, _Bn...>  : public conditional< _B1::value, std::__and_< _B2, _B3, _Bn...> , _B1> ::type { 
# 138
}; 
# 140
template< class _Pp> 
# 141
struct __not_ : public __bool_constant< !((bool)_Pp::value)>  { 
# 143
}; 
# 185 "/usr/include/c++/9/type_traits" 3
template< class _Tp> 
# 186
struct __success_type { 
# 187
typedef _Tp type; }; 
# 189
struct __failure_type { 
# 190
}; 
# 194
template< class > struct remove_cv; 
# 197
template< class > 
# 198
struct __is_void_helper : public false_type { 
# 199
}; 
# 202
template<> struct __is_void_helper< void>  : public true_type { 
# 203
}; 
# 206
template< class _Tp> 
# 207
struct is_void : public __is_void_helper< typename remove_cv< _Tp> ::type> ::type { 
# 209
}; 
# 211
template< class > 
# 212
struct __is_integral_helper : public false_type { 
# 213
}; 
# 216
template<> struct __is_integral_helper< bool>  : public true_type { 
# 217
}; 
# 220
template<> struct __is_integral_helper< char>  : public true_type { 
# 221
}; 
# 224
template<> struct __is_integral_helper< signed char>  : public true_type { 
# 225
}; 
# 228
template<> struct __is_integral_helper< unsigned char>  : public true_type { 
# 229
}; 
# 233
template<> struct __is_integral_helper< wchar_t>  : public true_type { 
# 234
}; 
# 244 "/usr/include/c++/9/type_traits" 3
template<> struct __is_integral_helper< char16_t>  : public true_type { 
# 245
}; 
# 248
template<> struct __is_integral_helper< char32_t>  : public true_type { 
# 249
}; 
# 252
template<> struct __is_integral_helper< short>  : public true_type { 
# 253
}; 
# 256
template<> struct __is_integral_helper< unsigned short>  : public true_type { 
# 257
}; 
# 260
template<> struct __is_integral_helper< int>  : public true_type { 
# 261
}; 
# 264
template<> struct __is_integral_helper< unsigned>  : public true_type { 
# 265
}; 
# 268
template<> struct __is_integral_helper< long>  : public true_type { 
# 269
}; 
# 272
template<> struct __is_integral_helper< unsigned long>  : public true_type { 
# 273
}; 
# 276
template<> struct __is_integral_helper< long long>  : public true_type { 
# 277
}; 
# 280
template<> struct __is_integral_helper< unsigned long long>  : public true_type { 
# 281
}; 
# 287
template<> struct __is_integral_helper< __int128>  : public true_type { 
# 288
}; 
# 291
template<> struct __is_integral_helper< unsigned __int128>  : public true_type { 
# 292
}; 
# 323 "/usr/include/c++/9/type_traits" 3
template< class _Tp> 
# 324
struct is_integral : public __is_integral_helper< typename remove_cv< _Tp> ::type> ::type { 
# 326
}; 
# 328
template< class > 
# 329
struct __is_floating_point_helper : public false_type { 
# 330
}; 
# 333
template<> struct __is_floating_point_helper< float>  : public true_type { 
# 334
}; 
# 337
template<> struct __is_floating_point_helper< double>  : public true_type { 
# 338
}; 
# 341
template<> struct __is_floating_point_helper< long double>  : public true_type { 
# 342
}; 
# 351 "/usr/include/c++/9/type_traits" 3
template< class _Tp> 
# 352
struct is_floating_point : public __is_floating_point_helper< typename remove_cv< _Tp> ::type> ::type { 
# 354
}; 
# 357
template< class > 
# 358
struct is_array : public false_type { 
# 359
}; 
# 361
template< class _Tp, size_t _Size> 
# 362
struct is_array< _Tp [_Size]>  : public true_type { 
# 363
}; 
# 365
template< class _Tp> 
# 366
struct is_array< _Tp []>  : public true_type { 
# 367
}; 
# 369
template< class > 
# 370
struct __is_pointer_helper : public false_type { 
# 371
}; 
# 373
template< class _Tp> 
# 374
struct __is_pointer_helper< _Tp *>  : public true_type { 
# 375
}; 
# 378
template< class _Tp> 
# 379
struct is_pointer : public __is_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 381
}; 
# 384
template< class > 
# 385
struct is_lvalue_reference : public false_type { 
# 386
}; 
# 388
template< class _Tp> 
# 389
struct is_lvalue_reference< _Tp &>  : public true_type { 
# 390
}; 
# 393
template< class > 
# 394
struct is_rvalue_reference : public false_type { 
# 395
}; 
# 397
template< class _Tp> 
# 398
struct is_rvalue_reference< _Tp &&>  : public true_type { 
# 399
}; 
# 401
template< class > struct is_function; 
# 404
template< class > 
# 405
struct __is_member_object_pointer_helper : public false_type { 
# 406
}; 
# 408
template< class _Tp, class _Cp> 
# 409
struct __is_member_object_pointer_helper< _Tp (_Cp::*)>  : public __not_< is_function< _Tp> > ::type { 
# 410
}; 
# 413
template< class _Tp> 
# 414
struct is_member_object_pointer : public __is_member_object_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 417
}; 
# 419
template< class > 
# 420
struct __is_member_function_pointer_helper : public false_type { 
# 421
}; 
# 423
template< class _Tp, class _Cp> 
# 424
struct __is_member_function_pointer_helper< _Tp (_Cp::*)>  : public is_function< _Tp> ::type { 
# 425
}; 
# 428
template< class _Tp> 
# 429
struct is_member_function_pointer : public __is_member_function_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 432
}; 
# 435
template< class _Tp> 
# 436
struct is_enum : public integral_constant< bool, __is_enum(_Tp)>  { 
# 438
}; 
# 441
template< class _Tp> 
# 442
struct is_union : public integral_constant< bool, __is_union(_Tp)>  { 
# 444
}; 
# 447
template< class _Tp> 
# 448
struct is_class : public integral_constant< bool, __is_class(_Tp)>  { 
# 450
}; 
# 453
template< class > 
# 454
struct is_function : public false_type { 
# 455
}; 
# 457
template< class _Res, class ..._ArgTypes> 
# 458
struct is_function< _Res (_ArgTypes ...)>  : public true_type { 
# 459
}; 
# 461
template< class _Res, class ..._ArgTypes> 
# 462
struct is_function< _Res (_ArgTypes ...) &>  : public true_type { 
# 463
}; 
# 465
template< class _Res, class ..._ArgTypes> 
# 466
struct is_function< _Res (_ArgTypes ...) &&>  : public true_type { 
# 467
}; 
# 469
template< class _Res, class ..._ArgTypes> 
# 470
struct is_function< _Res (_ArgTypes ..., ...)>  : public true_type { 
# 471
}; 
# 473
template< class _Res, class ..._ArgTypes> 
# 474
struct is_function< _Res (_ArgTypes ..., ...) &>  : public true_type { 
# 475
}; 
# 477
template< class _Res, class ..._ArgTypes> 
# 478
struct is_function< _Res (_ArgTypes ..., ...) &&>  : public true_type { 
# 479
}; 
# 481
template< class _Res, class ..._ArgTypes> 
# 482
struct is_function< _Res (_ArgTypes ...) const>  : public true_type { 
# 483
}; 
# 485
template< class _Res, class ..._ArgTypes> 
# 486
struct is_function< _Res (_ArgTypes ...) const &>  : public true_type { 
# 487
}; 
# 489
template< class _Res, class ..._ArgTypes> 
# 490
struct is_function< _Res (_ArgTypes ...) const &&>  : public true_type { 
# 491
}; 
# 493
template< class _Res, class ..._ArgTypes> 
# 494
struct is_function< _Res (_ArgTypes ..., ...) const>  : public true_type { 
# 495
}; 
# 497
template< class _Res, class ..._ArgTypes> 
# 498
struct is_function< _Res (_ArgTypes ..., ...) const &>  : public true_type { 
# 499
}; 
# 501
template< class _Res, class ..._ArgTypes> 
# 502
struct is_function< _Res (_ArgTypes ..., ...) const &&>  : public true_type { 
# 503
}; 
# 505
template< class _Res, class ..._ArgTypes> 
# 506
struct is_function< _Res (_ArgTypes ...) volatile>  : public true_type { 
# 507
}; 
# 509
template< class _Res, class ..._ArgTypes> 
# 510
struct is_function< _Res (_ArgTypes ...) volatile &>  : public true_type { 
# 511
}; 
# 513
template< class _Res, class ..._ArgTypes> 
# 514
struct is_function< _Res (_ArgTypes ...) volatile &&>  : public true_type { 
# 515
}; 
# 517
template< class _Res, class ..._ArgTypes> 
# 518
struct is_function< _Res (_ArgTypes ..., ...) volatile>  : public true_type { 
# 519
}; 
# 521
template< class _Res, class ..._ArgTypes> 
# 522
struct is_function< _Res (_ArgTypes ..., ...) volatile &>  : public true_type { 
# 523
}; 
# 525
template< class _Res, class ..._ArgTypes> 
# 526
struct is_function< _Res (_ArgTypes ..., ...) volatile &&>  : public true_type { 
# 527
}; 
# 529
template< class _Res, class ..._ArgTypes> 
# 530
struct is_function< _Res (_ArgTypes ...) const volatile>  : public true_type { 
# 531
}; 
# 533
template< class _Res, class ..._ArgTypes> 
# 534
struct is_function< _Res (_ArgTypes ...) const volatile &>  : public true_type { 
# 535
}; 
# 537
template< class _Res, class ..._ArgTypes> 
# 538
struct is_function< _Res (_ArgTypes ...) const volatile &&>  : public true_type { 
# 539
}; 
# 541
template< class _Res, class ..._ArgTypes> 
# 542
struct is_function< _Res (_ArgTypes ..., ...) const volatile>  : public true_type { 
# 543
}; 
# 545
template< class _Res, class ..._ArgTypes> 
# 546
struct is_function< _Res (_ArgTypes ..., ...) const volatile &>  : public true_type { 
# 547
}; 
# 549
template< class _Res, class ..._ArgTypes> 
# 550
struct is_function< _Res (_ArgTypes ..., ...) const volatile &&>  : public true_type { 
# 551
}; 
# 555
template< class > 
# 556
struct __is_null_pointer_helper : public false_type { 
# 557
}; 
# 560
template<> struct __is_null_pointer_helper< nullptr_t>  : public true_type { 
# 561
}; 
# 564
template< class _Tp> 
# 565
struct is_null_pointer : public __is_null_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 567
}; 
# 570
template< class _Tp> 
# 571
struct __is_nullptr_t : public is_null_pointer< _Tp>  { 
# 573
}; 
# 578
template< class _Tp> 
# 579
struct is_reference : public __or_< is_lvalue_reference< _Tp> , is_rvalue_reference< _Tp> > ::type { 
# 582
}; 
# 585
template< class _Tp> 
# 586
struct is_arithmetic : public __or_< is_integral< _Tp> , is_floating_point< _Tp> > ::type { 
# 588
}; 
# 591
template< class _Tp> 
# 592
struct is_fundamental : public __or_< is_arithmetic< _Tp> , is_void< _Tp> , is_null_pointer< _Tp> > ::type { 
# 595
}; 
# 598
template< class _Tp> 
# 599
struct is_object : public __not_< __or_< is_function< _Tp> , is_reference< _Tp> , is_void< _Tp> > > ::type { 
# 602
}; 
# 604
template< class > struct is_member_pointer; 
# 608
template< class _Tp> 
# 609
struct is_scalar : public __or_< is_arithmetic< _Tp> , is_enum< _Tp> , is_pointer< _Tp> , is_member_pointer< _Tp> , is_null_pointer< _Tp> > ::type { 
# 612
}; 
# 615
template< class _Tp> 
# 616
struct is_compound : public __not_< is_fundamental< _Tp> > ::type { 
# 617
}; 
# 619
template< class _Tp> 
# 620
struct __is_member_pointer_helper : public false_type { 
# 621
}; 
# 623
template< class _Tp, class _Cp> 
# 624
struct __is_member_pointer_helper< _Tp (_Cp::*)>  : public true_type { 
# 625
}; 
# 628
template< class _Tp> 
# 629
struct is_member_pointer : public __is_member_pointer_helper< typename remove_cv< _Tp> ::type> ::type { 
# 631
}; 
# 635
template< class _Tp> 
# 636
struct __is_referenceable : public __or_< is_object< _Tp> , is_reference< _Tp> > ::type { 
# 638
}; 
# 640
template< class _Res, class ..._Args> 
# 641
struct __is_referenceable< _Res (_Args ...)>  : public true_type { 
# 643
}; 
# 645
template< class _Res, class ..._Args> 
# 646
struct __is_referenceable< _Res (_Args ..., ...)>  : public true_type { 
# 648
}; 
# 653
template< class > 
# 654
struct is_const : public false_type { 
# 655
}; 
# 657
template< class _Tp> 
# 658
struct is_const< const _Tp>  : public true_type { 
# 659
}; 
# 662
template< class > 
# 663
struct is_volatile : public false_type { 
# 664
}; 
# 666
template< class _Tp> 
# 667
struct is_volatile< volatile _Tp>  : public true_type { 
# 668
}; 
# 671
template< class _Tp> 
# 672
struct is_trivial : public integral_constant< bool, __is_trivial(_Tp)>  { 
# 674
}; 
# 677
template< class _Tp> 
# 678
struct is_trivially_copyable : public integral_constant< bool, __is_trivially_copyable(_Tp)>  { 
# 680
}; 
# 683
template< class _Tp> 
# 684
struct is_standard_layout : public integral_constant< bool, __is_standard_layout(_Tp)>  { 
# 686
}; 
# 690
template< class _Tp> 
# 691
struct is_pod : public integral_constant< bool, __is_pod(_Tp)>  { 
# 693
}; 
# 696
template< class _Tp> 
# 697
struct is_literal_type : public integral_constant< bool, __is_literal_type(_Tp)>  { 
# 699
}; 
# 702
template< class _Tp> 
# 703
struct is_empty : public integral_constant< bool, __is_empty(_Tp)>  { 
# 705
}; 
# 708
template< class _Tp> 
# 709
struct is_polymorphic : public integral_constant< bool, __is_polymorphic(_Tp)>  { 
# 711
}; 
# 716
template< class _Tp> 
# 717
struct is_final : public integral_constant< bool, __is_final(_Tp)>  { 
# 719
}; 
# 723
template< class _Tp> 
# 724
struct is_abstract : public integral_constant< bool, __is_abstract(_Tp)>  { 
# 726
}; 
# 728
template< class _Tp, bool 
# 729
 = is_arithmetic< _Tp> ::value> 
# 730
struct __is_signed_helper : public false_type { 
# 731
}; 
# 733
template< class _Tp> 
# 734
struct __is_signed_helper< _Tp, true>  : public integral_constant< bool, ((_Tp)(-1)) < ((_Tp)0)>  { 
# 736
}; 
# 739
template< class _Tp> 
# 740
struct is_signed : public __is_signed_helper< _Tp> ::type { 
# 742
}; 
# 745
template< class _Tp> 
# 746
struct is_unsigned : public __and_< is_arithmetic< _Tp> , __not_< is_signed< _Tp> > >  { 
# 748
}; 
# 758 "/usr/include/c++/9/type_traits" 3
template< class _Tp, class _Up = _Tp &&> _Up __declval(int); 
# 762
template< class _Tp> _Tp __declval(long); 
# 766
template< class _Tp> auto declval() noexcept->__decltype((__declval< _Tp> (0))); 
# 769
template< class , unsigned  = 0U> struct extent; 
# 772
template< class > struct remove_all_extents; 
# 775
template< class _Tp> 
# 776
struct __is_array_known_bounds : public integral_constant< bool, (extent< _Tp> ::value > 0)>  { 
# 778
}; 
# 780
template< class _Tp> 
# 781
struct __is_array_unknown_bounds : public __and_< is_array< _Tp> , __not_< extent< _Tp> > >  { 
# 783
}; 
# 790
struct __do_is_destructible_impl { 
# 792
template< class _Tp, class  = __decltype((declval< _Tp &> ().~_Tp()))> static true_type __test(int); 
# 795
template< class > static false_type __test(...); 
# 797
}; 
# 799
template< class _Tp> 
# 800
struct __is_destructible_impl : public __do_is_destructible_impl { 
# 803
typedef __decltype((__test< _Tp> (0))) type; 
# 804
}; 
# 806
template< class _Tp, bool 
# 807
 = __or_< is_void< _Tp> , __is_array_unknown_bounds< _Tp> , is_function< _Tp> > ::value, bool 
# 810
 = __or_< is_reference< _Tp> , is_scalar< _Tp> > ::value> struct __is_destructible_safe; 
# 813
template< class _Tp> 
# 814
struct __is_destructible_safe< _Tp, false, false>  : public __is_destructible_impl< typename remove_all_extents< _Tp> ::type> ::type { 
# 817
}; 
# 819
template< class _Tp> 
# 820
struct __is_destructible_safe< _Tp, true, false>  : public false_type { 
# 821
}; 
# 823
template< class _Tp> 
# 824
struct __is_destructible_safe< _Tp, false, true>  : public true_type { 
# 825
}; 
# 828
template< class _Tp> 
# 829
struct is_destructible : public __is_destructible_safe< _Tp> ::type { 
# 831
}; 
# 837
struct __do_is_nt_destructible_impl { 
# 839
template< class _Tp> static __bool_constant< noexcept(declval< _Tp &> ().~_Tp())>  __test(int); 
# 843
template< class > static false_type __test(...); 
# 845
}; 
# 847
template< class _Tp> 
# 848
struct __is_nt_destructible_impl : public __do_is_nt_destructible_impl { 
# 851
typedef __decltype((__test< _Tp> (0))) type; 
# 852
}; 
# 854
template< class _Tp, bool 
# 855
 = __or_< is_void< _Tp> , __is_array_unknown_bounds< _Tp> , is_function< _Tp> > ::value, bool 
# 858
 = __or_< is_reference< _Tp> , is_scalar< _Tp> > ::value> struct __is_nt_destructible_safe; 
# 861
template< class _Tp> 
# 862
struct __is_nt_destructible_safe< _Tp, false, false>  : public __is_nt_destructible_impl< typename remove_all_extents< _Tp> ::type> ::type { 
# 865
}; 
# 867
template< class _Tp> 
# 868
struct __is_nt_destructible_safe< _Tp, true, false>  : public false_type { 
# 869
}; 
# 871
template< class _Tp> 
# 872
struct __is_nt_destructible_safe< _Tp, false, true>  : public true_type { 
# 873
}; 
# 876
template< class _Tp> 
# 877
struct is_nothrow_destructible : public __is_nt_destructible_safe< _Tp> ::type { 
# 879
}; 
# 882
template< class _Tp, class ..._Args> 
# 883
struct is_constructible : public __bool_constant< __is_constructible(_Tp, _Args...)>  { 
# 885
}; 
# 888
template< class _Tp> 
# 889
struct is_default_constructible : public is_constructible< _Tp> ::type { 
# 891
}; 
# 893
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_copy_constructible_impl; 
# 896
template< class _Tp> 
# 897
struct __is_copy_constructible_impl< _Tp, false>  : public false_type { 
# 898
}; 
# 900
template< class _Tp> 
# 901
struct __is_copy_constructible_impl< _Tp, true>  : public is_constructible< _Tp, const _Tp &>  { 
# 903
}; 
# 906
template< class _Tp> 
# 907
struct is_copy_constructible : public __is_copy_constructible_impl< _Tp>  { 
# 909
}; 
# 911
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_move_constructible_impl; 
# 914
template< class _Tp> 
# 915
struct __is_move_constructible_impl< _Tp, false>  : public false_type { 
# 916
}; 
# 918
template< class _Tp> 
# 919
struct __is_move_constructible_impl< _Tp, true>  : public is_constructible< _Tp, _Tp &&>  { 
# 921
}; 
# 924
template< class _Tp> 
# 925
struct is_move_constructible : public __is_move_constructible_impl< _Tp>  { 
# 927
}; 
# 929
template< bool , class _Tp, class ..._Args> 
# 930
struct __is_nt_constructible_impl : public false_type { 
# 932
}; 
# 934
template< class _Tp, class ..._Args> 
# 935
struct __is_nt_constructible_impl< true, _Tp, _Args...>  : public __bool_constant< noexcept((_Tp(std::declval< _Args> ()...)))>  { 
# 937
}; 
# 939
template< class _Tp, class _Arg> 
# 940
struct __is_nt_constructible_impl< true, _Tp, _Arg>  : public __bool_constant< noexcept((static_cast< _Tp>(std::declval< _Arg> ())))>  { 
# 942
}; 
# 944
template< class _Tp> 
# 945
struct __is_nt_constructible_impl< true, _Tp>  : public __bool_constant< noexcept(_Tp())>  { 
# 947
}; 
# 949
template< class _Tp, size_t _Num> 
# 950
struct __is_nt_constructible_impl< true, _Tp [_Num]>  : public __bool_constant< noexcept(typename remove_all_extents< _Tp> ::type())>  { 
# 952
}; 
# 954
template< class _Tp, class ..._Args> using __is_nothrow_constructible_impl = __is_nt_constructible_impl< __is_constructible(_Tp, _Args...), _Tp, _Args...> ; 
# 960
template< class _Tp, class ..._Args> 
# 961
struct is_nothrow_constructible : public __is_nt_constructible_impl< __is_constructible(_Tp, _Args...), _Tp, _Args...> ::type { 
# 963
}; 
# 966
template< class _Tp> 
# 967
struct is_nothrow_default_constructible : public __is_nt_constructible_impl< __is_constructible(_Tp), _Tp> ::type { 
# 969
}; 
# 972
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_nothrow_copy_constructible_impl; 
# 975
template< class _Tp> 
# 976
struct __is_nothrow_copy_constructible_impl< _Tp, false>  : public false_type { 
# 977
}; 
# 979
template< class _Tp> 
# 980
struct __is_nothrow_copy_constructible_impl< _Tp, true>  : public is_nothrow_constructible< _Tp, const _Tp &>  { 
# 982
}; 
# 985
template< class _Tp> 
# 986
struct is_nothrow_copy_constructible : public __is_nothrow_copy_constructible_impl< _Tp>  { 
# 988
}; 
# 990
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_nothrow_move_constructible_impl; 
# 993
template< class _Tp> 
# 994
struct __is_nothrow_move_constructible_impl< _Tp, false>  : public false_type { 
# 995
}; 
# 997
template< class _Tp> 
# 998
struct __is_nothrow_move_constructible_impl< _Tp, true>  : public is_nothrow_constructible< _Tp, _Tp &&>  { 
# 1000
}; 
# 1003
template< class _Tp> 
# 1004
struct is_nothrow_move_constructible : public __is_nothrow_move_constructible_impl< _Tp>  { 
# 1006
}; 
# 1009
template< class _Tp, class _Up> 
# 1010
struct is_assignable : public __bool_constant< __is_assignable(_Tp, _Up)>  { 
# 1012
}; 
# 1014
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_copy_assignable_impl; 
# 1017
template< class _Tp> 
# 1018
struct __is_copy_assignable_impl< _Tp, false>  : public false_type { 
# 1019
}; 
# 1021
template< class _Tp> 
# 1022
struct __is_copy_assignable_impl< _Tp, true>  : public is_assignable< _Tp &, const _Tp &>  { 
# 1024
}; 
# 1027
template< class _Tp> 
# 1028
struct is_copy_assignable : public __is_copy_assignable_impl< _Tp>  { 
# 1030
}; 
# 1032
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_move_assignable_impl; 
# 1035
template< class _Tp> 
# 1036
struct __is_move_assignable_impl< _Tp, false>  : public false_type { 
# 1037
}; 
# 1039
template< class _Tp> 
# 1040
struct __is_move_assignable_impl< _Tp, true>  : public is_assignable< _Tp &, _Tp &&>  { 
# 1042
}; 
# 1045
template< class _Tp> 
# 1046
struct is_move_assignable : public __is_move_assignable_impl< _Tp>  { 
# 1048
}; 
# 1050
template< class _Tp, class _Up> 
# 1051
struct __is_nt_assignable_impl : public integral_constant< bool, noexcept((declval< _Tp> () = declval< _Up> ()))>  { 
# 1053
}; 
# 1056
template< class _Tp, class _Up> 
# 1057
struct is_nothrow_assignable : public __and_< is_assignable< _Tp, _Up> , __is_nt_assignable_impl< _Tp, _Up> >  { 
# 1060
}; 
# 1062
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_nt_copy_assignable_impl; 
# 1065
template< class _Tp> 
# 1066
struct __is_nt_copy_assignable_impl< _Tp, false>  : public false_type { 
# 1067
}; 
# 1069
template< class _Tp> 
# 1070
struct __is_nt_copy_assignable_impl< _Tp, true>  : public is_nothrow_assignable< _Tp &, const _Tp &>  { 
# 1072
}; 
# 1075
template< class _Tp> 
# 1076
struct is_nothrow_copy_assignable : public __is_nt_copy_assignable_impl< _Tp>  { 
# 1078
}; 
# 1080
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_nt_move_assignable_impl; 
# 1083
template< class _Tp> 
# 1084
struct __is_nt_move_assignable_impl< _Tp, false>  : public false_type { 
# 1085
}; 
# 1087
template< class _Tp> 
# 1088
struct __is_nt_move_assignable_impl< _Tp, true>  : public is_nothrow_assignable< _Tp &, _Tp &&>  { 
# 1090
}; 
# 1093
template< class _Tp> 
# 1094
struct is_nothrow_move_assignable : public __is_nt_move_assignable_impl< _Tp>  { 
# 1096
}; 
# 1099
template< class _Tp, class ..._Args> 
# 1100
struct is_trivially_constructible : public __bool_constant< __is_trivially_constructible(_Tp, _Args...)>  { 
# 1102
}; 
# 1105
template< class _Tp> 
# 1106
struct is_trivially_default_constructible : public is_trivially_constructible< _Tp> ::type { 
# 1108
}; 
# 1110
struct __do_is_implicitly_default_constructible_impl { 
# 1112
template< class _Tp> static void __helper(const _Tp &); 
# 1115
template< class _Tp> static true_type __test(const _Tp &, __decltype((__helper< const _Tp &> ({}))) * = 0); 
# 1119
static false_type __test(...); 
# 1120
}; 
# 1122
template< class _Tp> 
# 1123
struct __is_implicitly_default_constructible_impl : public __do_is_implicitly_default_constructible_impl { 
# 1126
typedef __decltype((__test(declval< _Tp> ()))) type; 
# 1127
}; 
# 1129
template< class _Tp> 
# 1130
struct __is_implicitly_default_constructible_safe : public __is_implicitly_default_constructible_impl< _Tp> ::type { 
# 1132
}; 
# 1134
template< class _Tp> 
# 1135
struct __is_implicitly_default_constructible : public __and_< is_default_constructible< _Tp> , __is_implicitly_default_constructible_safe< _Tp> >  { 
# 1138
}; 
# 1142
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_trivially_copy_constructible_impl; 
# 1145
template< class _Tp> 
# 1146
struct __is_trivially_copy_constructible_impl< _Tp, false>  : public false_type { 
# 1147
}; 
# 1149
template< class _Tp> 
# 1150
struct __is_trivially_copy_constructible_impl< _Tp, true>  : public __and_< is_copy_constructible< _Tp> , integral_constant< bool, __is_trivially_constructible(_Tp, const _Tp &)> >  { 
# 1154
}; 
# 1156
template< class _Tp> 
# 1157
struct is_trivially_copy_constructible : public __is_trivially_copy_constructible_impl< _Tp>  { 
# 1159
}; 
# 1163
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_trivially_move_constructible_impl; 
# 1166
template< class _Tp> 
# 1167
struct __is_trivially_move_constructible_impl< _Tp, false>  : public false_type { 
# 1168
}; 
# 1170
template< class _Tp> 
# 1171
struct __is_trivially_move_constructible_impl< _Tp, true>  : public __and_< is_move_constructible< _Tp> , integral_constant< bool, __is_trivially_constructible(_Tp, _Tp &&)> >  { 
# 1175
}; 
# 1177
template< class _Tp> 
# 1178
struct is_trivially_move_constructible : public __is_trivially_move_constructible_impl< _Tp>  { 
# 1180
}; 
# 1183
template< class _Tp, class _Up> 
# 1184
struct is_trivially_assignable : public __bool_constant< __is_trivially_assignable(_Tp, _Up)>  { 
# 1186
}; 
# 1190
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_trivially_copy_assignable_impl; 
# 1193
template< class _Tp> 
# 1194
struct __is_trivially_copy_assignable_impl< _Tp, false>  : public false_type { 
# 1195
}; 
# 1197
template< class _Tp> 
# 1198
struct __is_trivially_copy_assignable_impl< _Tp, true>  : public __bool_constant< __is_trivially_assignable(_Tp &, const _Tp &)>  { 
# 1200
}; 
# 1202
template< class _Tp> 
# 1203
struct is_trivially_copy_assignable : public __is_trivially_copy_assignable_impl< _Tp>  { 
# 1205
}; 
# 1209
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> struct __is_trivially_move_assignable_impl; 
# 1212
template< class _Tp> 
# 1213
struct __is_trivially_move_assignable_impl< _Tp, false>  : public false_type { 
# 1214
}; 
# 1216
template< class _Tp> 
# 1217
struct __is_trivially_move_assignable_impl< _Tp, true>  : public __bool_constant< __is_trivially_assignable(_Tp &, _Tp &&)>  { 
# 1219
}; 
# 1221
template< class _Tp> 
# 1222
struct is_trivially_move_assignable : public __is_trivially_move_assignable_impl< _Tp>  { 
# 1224
}; 
# 1227
template< class _Tp> 
# 1228
struct is_trivially_destructible : public __and_< is_destructible< _Tp> , __bool_constant< __has_trivial_destructor(_Tp)> >  { 
# 1231
}; 
# 1235
template< class _Tp> 
# 1236
struct has_virtual_destructor : public integral_constant< bool, __has_virtual_destructor(_Tp)>  { 
# 1238
}; 
# 1244
template< class _Tp> 
# 1245
struct alignment_of : public integral_constant< unsigned long, __alignof__(_Tp)>  { 
# 1246
}; 
# 1249
template< class > 
# 1250
struct rank : public integral_constant< unsigned long, 0UL>  { 
# 1251
}; 
# 1253
template< class _Tp, size_t _Size> 
# 1254
struct rank< _Tp [_Size]>  : public integral_constant< unsigned long, 1 + std::rank< _Tp> ::value>  { 
# 1255
}; 
# 1257
template< class _Tp> 
# 1258
struct rank< _Tp []>  : public integral_constant< unsigned long, 1 + std::rank< _Tp> ::value>  { 
# 1259
}; 
# 1262
template< class , unsigned _Uint> 
# 1263
struct extent : public integral_constant< unsigned long, 0UL>  { 
# 1264
}; 
# 1266
template< class _Tp, unsigned _Uint, size_t _Size> 
# 1267
struct extent< _Tp [_Size], _Uint>  : public integral_constant< unsigned long, (_Uint == (0)) ? _Size : std::extent< _Tp, _Uint - (1)> ::value>  { 
# 1271
}; 
# 1273
template< class _Tp, unsigned _Uint> 
# 1274
struct extent< _Tp [], _Uint>  : public integral_constant< unsigned long, (_Uint == (0)) ? 0 : std::extent< _Tp, _Uint - (1)> ::value>  { 
# 1278
}; 
# 1284
template< class , class > 
# 1285
struct is_same : public false_type { 
# 1286
}; 
# 1288
template< class _Tp> 
# 1289
struct is_same< _Tp, _Tp>  : public true_type { 
# 1290
}; 
# 1293
template< class _Base, class _Derived> 
# 1294
struct is_base_of : public integral_constant< bool, __is_base_of(_Base, _Derived)>  { 
# 1296
}; 
# 1298
template< class _From, class _To, bool 
# 1299
 = __or_< is_void< _From> , is_function< _To> , is_array< _To> > ::value> 
# 1301
struct __is_convertible_helper { 
# 1303
typedef typename is_void< _To> ::type type; 
# 1304
}; 
# 1306
template< class _From, class _To> 
# 1307
class __is_convertible_helper< _From, _To, false>  { 
# 1309
template< class _To1> static void __test_aux(_To1) noexcept; 
# 1312
template< class _From1, class _To1, class 
# 1313
 = __decltype((__test_aux< _To1> (std::declval< _From1> ())))> static true_type 
# 1312
__test(int); 
# 1317
template< class , class > static false_type __test(...); 
# 1322
public: typedef __decltype((__test< _From, _To> (0))) type; 
# 1323
}; 
# 1327
template< class _From, class _To> 
# 1328
struct is_convertible : public __is_convertible_helper< _From, _To> ::type { 
# 1330
}; 
# 1374 "/usr/include/c++/9/type_traits" 3
template< class _Tp> 
# 1375
struct remove_const { 
# 1376
typedef _Tp type; }; 
# 1378
template< class _Tp> 
# 1379
struct remove_const< const _Tp>  { 
# 1380
typedef _Tp type; }; 
# 1383
template< class _Tp> 
# 1384
struct remove_volatile { 
# 1385
typedef _Tp type; }; 
# 1387
template< class _Tp> 
# 1388
struct remove_volatile< volatile _Tp>  { 
# 1389
typedef _Tp type; }; 
# 1392
template< class _Tp> 
# 1393
struct remove_cv { 
# 1396
typedef typename remove_const< typename remove_volatile< _Tp> ::type> ::type type; 
# 1397
}; 
# 1400
template< class _Tp> 
# 1401
struct add_const { 
# 1402
typedef const _Tp type; }; 
# 1405
template< class _Tp> 
# 1406
struct add_volatile { 
# 1407
typedef volatile _Tp type; }; 
# 1410
template< class _Tp> 
# 1411
struct add_cv { 
# 1414
typedef typename add_const< typename add_volatile< _Tp> ::type> ::type type; 
# 1415
}; 
# 1422
template< class _Tp> using remove_const_t = typename remove_const< _Tp> ::type; 
# 1426
template< class _Tp> using remove_volatile_t = typename remove_volatile< _Tp> ::type; 
# 1430
template< class _Tp> using remove_cv_t = typename remove_cv< _Tp> ::type; 
# 1434
template< class _Tp> using add_const_t = typename add_const< _Tp> ::type; 
# 1438
template< class _Tp> using add_volatile_t = typename add_volatile< _Tp> ::type; 
# 1442
template< class _Tp> using add_cv_t = typename add_cv< _Tp> ::type; 
# 1449
template< class _Tp> 
# 1450
struct remove_reference { 
# 1451
typedef _Tp type; }; 
# 1453
template< class _Tp> 
# 1454
struct remove_reference< _Tp &>  { 
# 1455
typedef _Tp type; }; 
# 1457
template< class _Tp> 
# 1458
struct remove_reference< _Tp &&>  { 
# 1459
typedef _Tp type; }; 
# 1461
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> 
# 1462
struct __add_lvalue_reference_helper { 
# 1463
typedef _Tp type; }; 
# 1465
template< class _Tp> 
# 1466
struct __add_lvalue_reference_helper< _Tp, true>  { 
# 1467
typedef _Tp &type; }; 
# 1470
template< class _Tp> 
# 1471
struct add_lvalue_reference : public __add_lvalue_reference_helper< _Tp>  { 
# 1473
}; 
# 1475
template< class _Tp, bool  = __is_referenceable< _Tp> ::value> 
# 1476
struct __add_rvalue_reference_helper { 
# 1477
typedef _Tp type; }; 
# 1479
template< class _Tp> 
# 1480
struct __add_rvalue_reference_helper< _Tp, true>  { 
# 1481
typedef _Tp &&type; }; 
# 1484
template< class _Tp> 
# 1485
struct add_rvalue_reference : public __add_rvalue_reference_helper< _Tp>  { 
# 1487
}; 
# 1491
template< class _Tp> using remove_reference_t = typename remove_reference< _Tp> ::type; 
# 1495
template< class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference< _Tp> ::type; 
# 1499
template< class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference< _Tp> ::type; 
# 1506
template< class _Unqualified, bool _IsConst, bool _IsVol> struct __cv_selector; 
# 1509
template< class _Unqualified> 
# 1510
struct __cv_selector< _Unqualified, false, false>  { 
# 1511
typedef _Unqualified __type; }; 
# 1513
template< class _Unqualified> 
# 1514
struct __cv_selector< _Unqualified, false, true>  { 
# 1515
typedef volatile _Unqualified __type; }; 
# 1517
template< class _Unqualified> 
# 1518
struct __cv_selector< _Unqualified, true, false>  { 
# 1519
typedef const _Unqualified __type; }; 
# 1521
template< class _Unqualified> 
# 1522
struct __cv_selector< _Unqualified, true, true>  { 
# 1523
typedef const volatile _Unqualified __type; }; 
# 1525
template< class _Qualified, class _Unqualified, bool 
# 1526
_IsConst = is_const< _Qualified> ::value, bool 
# 1527
_IsVol = is_volatile< _Qualified> ::value> 
# 1528
class __match_cv_qualifiers { 
# 1530
typedef __cv_selector< _Unqualified, _IsConst, _IsVol>  __match; 
# 1533
public: typedef typename __cv_selector< _Unqualified, _IsConst, _IsVol> ::__type __type; 
# 1534
}; 
# 1537
template< class _Tp> 
# 1538
struct __make_unsigned { 
# 1539
typedef _Tp __type; }; 
# 1542
template<> struct __make_unsigned< char>  { 
# 1543
typedef unsigned char __type; }; 
# 1546
template<> struct __make_unsigned< signed char>  { 
# 1547
typedef unsigned char __type; }; 
# 1550
template<> struct __make_unsigned< short>  { 
# 1551
typedef unsigned short __type; }; 
# 1554
template<> struct __make_unsigned< int>  { 
# 1555
typedef unsigned __type; }; 
# 1558
template<> struct __make_unsigned< long>  { 
# 1559
typedef unsigned long __type; }; 
# 1562
template<> struct __make_unsigned< long long>  { 
# 1563
typedef unsigned long long __type; }; 
# 1567
template<> struct __make_unsigned< __int128>  { 
# 1568
typedef unsigned __int128 __type; }; 
# 1587 "/usr/include/c++/9/type_traits" 3
template< class _Tp, bool 
# 1588
_IsInt = is_integral< _Tp> ::value, bool 
# 1589
_IsEnum = is_enum< _Tp> ::value> class __make_unsigned_selector; 
# 1592
template< class _Tp> 
# 1593
class __make_unsigned_selector< _Tp, true, false>  { 
# 1595
using __unsigned_type = typename __make_unsigned< typename remove_cv< _Tp> ::type> ::__type; 
# 1599
public: using __type = typename __match_cv_qualifiers< _Tp, __unsigned_type> ::__type; 
# 1601
}; 
# 1603
class __make_unsigned_selector_base { 
# 1606
protected: template< class ...> struct _List { }; 
# 1608
template< class _Tp, class ..._Up> 
# 1609
struct _List< _Tp, _Up...>  : public __make_unsigned_selector_base::_List< _Up...>  { 
# 1610
static constexpr std::size_t __size = sizeof(_Tp); }; 
# 1612
template< size_t _Sz, class _Tp, bool  = _Sz <= _Tp::__size> struct __select; 
# 1615
template< size_t _Sz, class _Uint, class ..._UInts> 
# 1616
struct __select< _Sz, _List< _Uint, _UInts...> , true>  { 
# 1617
using __type = _Uint; }; 
# 1619
template< size_t _Sz, class _Uint, class ..._UInts> 
# 1620
struct __select< _Sz, _List< _Uint, _UInts...> , false>  : public __make_unsigned_selector_base::__select< _Sz, _List< _UInts...> >  { 
# 1622
}; 
# 1623
}; 
# 1626
template< class _Tp> 
# 1627
class __make_unsigned_selector< _Tp, false, true>  : private __make_unsigned_selector_base { 
# 1631
using _UInts = _List< unsigned char, unsigned short, unsigned, unsigned long, unsigned long long> ; 
# 1634
using __unsigned_type = typename __select< sizeof(_Tp), _List< unsigned char, unsigned short, unsigned, unsigned long, unsigned long long> > ::__type; 
# 1637
public: using __type = typename __match_cv_qualifiers< _Tp, __unsigned_type> ::__type; 
# 1639
}; 
# 1647
template<> struct __make_unsigned< wchar_t>  { 
# 1649
using __type = __make_unsigned_selector< wchar_t, false, true> ::__type; 
# 1651
}; 
# 1664 "/usr/include/c++/9/type_traits" 3
template<> struct __make_unsigned< char16_t>  { 
# 1666
using __type = __make_unsigned_selector< char16_t, false, true> ::__type; 
# 1668
}; 
# 1671
template<> struct __make_unsigned< char32_t>  { 
# 1673
using __type = __make_unsigned_selector< char32_t, false, true> ::__type; 
# 1675
}; 
# 1681
template< class _Tp> 
# 1682
struct make_unsigned { 
# 1683
typedef typename __make_unsigned_selector< _Tp> ::__type type; }; 
# 1687
template<> struct make_unsigned< bool> ; 
# 1691
template< class _Tp> 
# 1692
struct __make_signed { 
# 1693
typedef _Tp __type; }; 
# 1696
template<> struct __make_signed< char>  { 
# 1697
typedef signed char __type; }; 
# 1700
template<> struct __make_signed< unsigned char>  { 
# 1701
typedef signed char __type; }; 
# 1704
template<> struct __make_signed< unsigned short>  { 
# 1705
typedef signed short __type; }; 
# 1708
template<> struct __make_signed< unsigned>  { 
# 1709
typedef signed int __type; }; 
# 1712
template<> struct __make_signed< unsigned long>  { 
# 1713
typedef signed long __type; }; 
# 1716
template<> struct __make_signed< unsigned long long>  { 
# 1717
typedef signed long long __type; }; 
# 1721
template<> struct __make_signed< unsigned __int128>  { 
# 1722
typedef __int128 __type; }; 
# 1741 "/usr/include/c++/9/type_traits" 3
template< class _Tp, bool 
# 1742
_IsInt = is_integral< _Tp> ::value, bool 
# 1743
_IsEnum = is_enum< _Tp> ::value> class __make_signed_selector; 
# 1746
template< class _Tp> 
# 1747
class __make_signed_selector< _Tp, true, false>  { 
# 1749
using __signed_type = typename __make_signed< typename remove_cv< _Tp> ::type> ::__type; 
# 1753
public: using __type = typename __match_cv_qualifiers< _Tp, __signed_type> ::__type; 
# 1755
}; 
# 1758
template< class _Tp> 
# 1759
class __make_signed_selector< _Tp, false, true>  { 
# 1761
typedef typename __make_unsigned_selector< _Tp> ::__type __unsigned_type; 
# 1764
public: typedef typename std::__make_signed_selector< __unsigned_type> ::__type __type; 
# 1765
}; 
# 1773
template<> struct __make_signed< wchar_t>  { 
# 1775
using __type = __make_signed_selector< wchar_t, false, true> ::__type; 
# 1777
}; 
# 1790 "/usr/include/c++/9/type_traits" 3
template<> struct __make_signed< char16_t>  { 
# 1792
using __type = __make_signed_selector< char16_t, false, true> ::__type; 
# 1794
}; 
# 1797
template<> struct __make_signed< char32_t>  { 
# 1799
using __type = __make_signed_selector< char32_t, false, true> ::__type; 
# 1801
}; 
# 1807
template< class _Tp> 
# 1808
struct make_signed { 
# 1809
typedef typename __make_signed_selector< _Tp> ::__type type; }; 
# 1813
template<> struct make_signed< bool> ; 
# 1817
template< class _Tp> using make_signed_t = typename make_signed< _Tp> ::type; 
# 1821
template< class _Tp> using make_unsigned_t = typename make_unsigned< _Tp> ::type; 
# 1828
template< class _Tp> 
# 1829
struct remove_extent { 
# 1830
typedef _Tp type; }; 
# 1832
template< class _Tp, size_t _Size> 
# 1833
struct remove_extent< _Tp [_Size]>  { 
# 1834
typedef _Tp type; }; 
# 1836
template< class _Tp> 
# 1837
struct remove_extent< _Tp []>  { 
# 1838
typedef _Tp type; }; 
# 1841
template< class _Tp> 
# 1842
struct remove_all_extents { 
# 1843
typedef _Tp type; }; 
# 1845
template< class _Tp, size_t _Size> 
# 1846
struct remove_all_extents< _Tp [_Size]>  { 
# 1847
typedef typename std::remove_all_extents< _Tp> ::type type; }; 
# 1849
template< class _Tp> 
# 1850
struct remove_all_extents< _Tp []>  { 
# 1851
typedef typename std::remove_all_extents< _Tp> ::type type; }; 
# 1855
template< class _Tp> using remove_extent_t = typename remove_extent< _Tp> ::type; 
# 1859
template< class _Tp> using remove_all_extents_t = typename remove_all_extents< _Tp> ::type; 
# 1865
template< class _Tp, class > 
# 1866
struct __remove_pointer_helper { 
# 1867
typedef _Tp type; }; 
# 1869
template< class _Tp, class _Up> 
# 1870
struct __remove_pointer_helper< _Tp, _Up *>  { 
# 1871
typedef _Up type; }; 
# 1874
template< class _Tp> 
# 1875
struct remove_pointer : public __remove_pointer_helper< _Tp, typename remove_cv< _Tp> ::type>  { 
# 1877
}; 
# 1880
template< class _Tp, bool  = __or_< __is_referenceable< _Tp> , is_void< _Tp> > ::value> 
# 1882
struct __add_pointer_helper { 
# 1883
typedef _Tp type; }; 
# 1885
template< class _Tp> 
# 1886
struct __add_pointer_helper< _Tp, true>  { 
# 1887
typedef typename remove_reference< _Tp> ::type *type; }; 
# 1889
template< class _Tp> 
# 1890
struct add_pointer : public __add_pointer_helper< _Tp>  { 
# 1892
}; 
# 1896
template< class _Tp> using remove_pointer_t = typename remove_pointer< _Tp> ::type; 
# 1900
template< class _Tp> using add_pointer_t = typename add_pointer< _Tp> ::type; 
# 1904
template< size_t _Len> 
# 1905
struct __aligned_storage_msa { 
# 1907
union __type { 
# 1909
unsigned char __data[_Len]; 
# 1910
struct __attribute((__aligned__)) { } __align; 
# 1911
}; 
# 1912
}; 
# 1924 "/usr/include/c++/9/type_traits" 3
template< size_t _Len, size_t _Align = __alignof__(typename __aligned_storage_msa< _Len> ::__type)> 
# 1926
struct aligned_storage { 
# 1928
union type { 
# 1930
unsigned char __data[_Len]; 
# 1931
struct __attribute((__aligned__(_Align))) { } __align; 
# 1932
}; 
# 1933
}; 
# 1935
template< class ..._Types> 
# 1936
struct __strictest_alignment { 
# 1938
static const size_t _S_alignment = (0); 
# 1939
static const size_t _S_size = (0); 
# 1940
}; 
# 1942
template< class _Tp, class ..._Types> 
# 1943
struct __strictest_alignment< _Tp, _Types...>  { 
# 1945
static const size_t _S_alignment = ((__alignof__(_Tp) > __strictest_alignment< _Types...> ::_S_alignment) ? __alignof__(_Tp) : __strictest_alignment< _Types...> ::_S_alignment); 
# 1948
static const size_t _S_size = ((sizeof(_Tp) > __strictest_alignment< _Types...> ::_S_size) ? sizeof(_Tp) : __strictest_alignment< _Types...> ::_S_size); 
# 1951
}; 
# 1963 "/usr/include/c++/9/type_traits" 3
template< size_t _Len, class ..._Types> 
# 1964
struct aligned_union { 
# 1967
static_assert((sizeof...(_Types) != (0)), "At least one type is required");
# 1969
private: using __strictest = __strictest_alignment< _Types...> ; 
# 1970
static const size_t _S_len = ((_Len > __strictest::_S_size) ? _Len : __strictest::_S_size); 
# 1974
public: static const size_t alignment_value = (__strictest::_S_alignment); 
# 1976
typedef typename aligned_storage< _S_len, alignment_value> ::type type; 
# 1977
}; 
# 1979
template< size_t _Len, class ..._Types> const size_t aligned_union< _Len, _Types...> ::alignment_value; 
# 1984
template< class _Up, bool 
# 1985
_IsArray = is_array< _Up> ::value, bool 
# 1986
_IsFunction = is_function< _Up> ::value> struct __decay_selector; 
# 1990
template< class _Up> 
# 1991
struct __decay_selector< _Up, false, false>  { 
# 1992
typedef typename remove_cv< _Up> ::type __type; }; 
# 1994
template< class _Up> 
# 1995
struct __decay_selector< _Up, true, false>  { 
# 1996
typedef typename remove_extent< _Up> ::type *__type; }; 
# 1998
template< class _Up> 
# 1999
struct __decay_selector< _Up, false, true>  { 
# 2000
typedef typename add_pointer< _Up> ::type __type; }; 
# 2003
template< class _Tp> 
# 2004
class decay { 
# 2006
typedef typename remove_reference< _Tp> ::type __remove_type; 
# 2009
public: typedef typename __decay_selector< __remove_type> ::__type type; 
# 2010
}; 
# 2012
template< class _Tp> class reference_wrapper; 
# 2016
template< class _Tp> 
# 2017
struct __strip_reference_wrapper { 
# 2019
typedef _Tp __type; 
# 2020
}; 
# 2022
template< class _Tp> 
# 2023
struct __strip_reference_wrapper< reference_wrapper< _Tp> >  { 
# 2025
typedef _Tp &__type; 
# 2026
}; 
# 2028
template< class _Tp> 
# 2029
struct __decay_and_strip { 
# 2032
typedef typename __strip_reference_wrapper< typename decay< _Tp> ::type> ::__type __type; 
# 2033
}; 
# 2038
template< bool , class _Tp = void> 
# 2039
struct enable_if { 
# 2040
}; 
# 2043
template< class _Tp> 
# 2044
struct enable_if< true, _Tp>  { 
# 2045
typedef _Tp type; }; 
# 2047
template< class ..._Cond> using _Require = typename enable_if< __and_< _Cond...> ::value> ::type; 
# 2052
template< bool _Cond, class _Iftrue, class _Iffalse> 
# 2053
struct conditional { 
# 2054
typedef _Iftrue type; }; 
# 2057
template< class _Iftrue, class _Iffalse> 
# 2058
struct conditional< false, _Iftrue, _Iffalse>  { 
# 2059
typedef _Iffalse type; }; 
# 2062
template< class ..._Tp> struct common_type; 
# 2067
struct __do_common_type_impl { 
# 2069
template< class _Tp, class _Up> static __success_type< typename decay< __decltype((true ? std::declval< _Tp> () : std::declval< _Up> ()))> ::type>  _S_test(int); 
# 2074
template< class , class > static __failure_type _S_test(...); 
# 2076
}; 
# 2078
template< class _Tp, class _Up> 
# 2079
struct __common_type_impl : private __do_common_type_impl { 
# 2082
typedef __decltype((_S_test< _Tp, _Up> (0))) type; 
# 2083
}; 
# 2085
struct __do_member_type_wrapper { 
# 2087
template< class _Tp> static __success_type< typename _Tp::type>  _S_test(int); 
# 2090
template< class > static __failure_type _S_test(...); 
# 2092
}; 
# 2094
template< class _Tp> 
# 2095
struct __member_type_wrapper : private __do_member_type_wrapper { 
# 2098
typedef __decltype((_S_test< _Tp> (0))) type; 
# 2099
}; 
# 2101
template< class _CTp, class ..._Args> 
# 2102
struct __expanded_common_type_wrapper { 
# 2104
typedef common_type< typename _CTp::type, _Args...>  type; 
# 2105
}; 
# 2107
template< class ..._Args> 
# 2108
struct __expanded_common_type_wrapper< __failure_type, _Args...>  { 
# 2109
typedef __failure_type type; }; 
# 2112
template<> struct common_type< >  { 
# 2113
}; 
# 2115
template< class _Tp> 
# 2116
struct common_type< _Tp>  : public std::common_type< _Tp, _Tp>  { 
# 2118
}; 
# 2120
template< class _Tp, class _Up> 
# 2121
struct common_type< _Tp, _Up>  : public __common_type_impl< _Tp, _Up> ::type { 
# 2123
}; 
# 2125
template< class _Tp, class _Up, class ..._Vp> 
# 2126
struct common_type< _Tp, _Up, _Vp...>  : public __expanded_common_type_wrapper< typename __member_type_wrapper< std::common_type< _Tp, _Up> > ::type, _Vp...> ::type { 
# 2129
}; 
# 2131
template< class _Tp, bool  = is_enum< _Tp> ::value> 
# 2132
struct __underlying_type_impl { 
# 2134
using type = __underlying_type(_Tp); 
# 2135
}; 
# 2137
template< class _Tp> 
# 2138
struct __underlying_type_impl< _Tp, false>  { 
# 2139
}; 
# 2142
template< class _Tp> 
# 2143
struct underlying_type : public __underlying_type_impl< _Tp>  { 
# 2145
}; 
# 2147
template< class _Tp> 
# 2148
struct __declval_protector { 
# 2150
static const bool __stop = false; 
# 2151
}; 
# 2153
template< class _Tp> auto 
# 2154
declval() noexcept->__decltype((__declval< _Tp> (0))) 
# 2155
{ 
# 2156
static_assert((__declval_protector< _Tp> ::__stop), "declval() must not be used!");
# 2158
return __declval< _Tp> (0); 
# 2159
} 
# 2162
template< class _Tp> using __remove_cvref_t = typename remove_cv< typename remove_reference< _Tp> ::type> ::type; 
# 2167
template< class _Signature> class result_of; 
# 2174
struct __invoke_memfun_ref { }; 
# 2175
struct __invoke_memfun_deref { }; 
# 2176
struct __invoke_memobj_ref { }; 
# 2177
struct __invoke_memobj_deref { }; 
# 2178
struct __invoke_other { }; 
# 2181
template< class _Tp, class _Tag> 
# 2182
struct __result_of_success : public __success_type< _Tp>  { 
# 2183
using __invoke_type = _Tag; }; 
# 2186
struct __result_of_memfun_ref_impl { 
# 2188
template< class _Fp, class _Tp1, class ..._Args> static __result_of_success< __decltype(((std::declval< _Tp1> ().*std::declval< _Fp> ())(std::declval< _Args> ()...))), __invoke_memfun_ref>  _S_test(int); 
# 2193
template< class ...> static __failure_type _S_test(...); 
# 2195
}; 
# 2197
template< class _MemPtr, class _Arg, class ..._Args> 
# 2198
struct __result_of_memfun_ref : private __result_of_memfun_ref_impl { 
# 2201
typedef __decltype((_S_test< _MemPtr, _Arg, _Args...> (0))) type; 
# 2202
}; 
# 2205
struct __result_of_memfun_deref_impl { 
# 2207
template< class _Fp, class _Tp1, class ..._Args> static __result_of_success< __decltype((((*std::declval< _Tp1> ()).*std::declval< _Fp> ())(std::declval< _Args> ()...))), __invoke_memfun_deref>  _S_test(int); 
# 2212
template< class ...> static __failure_type _S_test(...); 
# 2214
}; 
# 2216
template< class _MemPtr, class _Arg, class ..._Args> 
# 2217
struct __result_of_memfun_deref : private __result_of_memfun_deref_impl { 
# 2220
typedef __decltype((_S_test< _MemPtr, _Arg, _Args...> (0))) type; 
# 2221
}; 
# 2224
struct __result_of_memobj_ref_impl { 
# 2226
template< class _Fp, class _Tp1> static __result_of_success< __decltype((std::declval< _Tp1> ().*std::declval< _Fp> ())), __invoke_memobj_ref>  _S_test(int); 
# 2231
template< class , class > static __failure_type _S_test(...); 
# 2233
}; 
# 2235
template< class _MemPtr, class _Arg> 
# 2236
struct __result_of_memobj_ref : private __result_of_memobj_ref_impl { 
# 2239
typedef __decltype((_S_test< _MemPtr, _Arg> (0))) type; 
# 2240
}; 
# 2243
struct __result_of_memobj_deref_impl { 
# 2245
template< class _Fp, class _Tp1> static __result_of_success< __decltype(((*std::declval< _Tp1> ()).*std::declval< _Fp> ())), __invoke_memobj_deref>  _S_test(int); 
# 2250
template< class , class > static __failure_type _S_test(...); 
# 2252
}; 
# 2254
template< class _MemPtr, class _Arg> 
# 2255
struct __result_of_memobj_deref : private __result_of_memobj_deref_impl { 
# 2258
typedef __decltype((_S_test< _MemPtr, _Arg> (0))) type; 
# 2259
}; 
# 2261
template< class _MemPtr, class _Arg> struct __result_of_memobj; 
# 2264
template< class _Res, class _Class, class _Arg> 
# 2265
struct __result_of_memobj< _Res (_Class::*), _Arg>  { 
# 2267
typedef __remove_cvref_t< _Arg>  _Argval; 
# 2268
typedef _Res (_Class::*_MemPtr); 
# 2273
typedef typename conditional< __or_< is_same< _Argval, _Class> , is_base_of< _Class, _Argval> > ::value, __result_of_memobj_ref< _MemPtr, _Arg> , __result_of_memobj_deref< _MemPtr, _Arg> > ::type::type type; 
# 2274
}; 
# 2276
template< class _MemPtr, class _Arg, class ..._Args> struct __result_of_memfun; 
# 2279
template< class _Res, class _Class, class _Arg, class ..._Args> 
# 2280
struct __result_of_memfun< _Res (_Class::*), _Arg, _Args...>  { 
# 2282
typedef typename remove_reference< _Arg> ::type _Argval; 
# 2283
typedef _Res (_Class::*_MemPtr); 
# 2287
typedef typename conditional< is_base_of< _Class, _Argval> ::value, __result_of_memfun_ref< _MemPtr, _Arg, _Args...> , __result_of_memfun_deref< _MemPtr, _Arg, _Args...> > ::type::type type; 
# 2288
}; 
# 2295
template< class _Tp, class _Up = __remove_cvref_t< _Tp> > 
# 2296
struct __inv_unwrap { 
# 2298
using type = _Tp; 
# 2299
}; 
# 2301
template< class _Tp, class _Up> 
# 2302
struct __inv_unwrap< _Tp, reference_wrapper< _Up> >  { 
# 2304
using type = _Up &; 
# 2305
}; 
# 2307
template< bool , bool , class _Functor, class ..._ArgTypes> 
# 2308
struct __result_of_impl { 
# 2310
typedef __failure_type type; 
# 2311
}; 
# 2313
template< class _MemPtr, class _Arg> 
# 2314
struct __result_of_impl< true, false, _MemPtr, _Arg>  : public __result_of_memobj< typename decay< _MemPtr> ::type, typename __inv_unwrap< _Arg> ::type>  { 
# 2317
}; 
# 2319
template< class _MemPtr, class _Arg, class ..._Args> 
# 2320
struct __result_of_impl< false, true, _MemPtr, _Arg, _Args...>  : public __result_of_memfun< typename decay< _MemPtr> ::type, typename __inv_unwrap< _Arg> ::type, _Args...>  { 
# 2323
}; 
# 2326
struct __result_of_other_impl { 
# 2328
template< class _Fn, class ..._Args> static __result_of_success< __decltype((std::declval< _Fn> ()(std::declval< _Args> ()...))), __invoke_other>  _S_test(int); 
# 2333
template< class ...> static __failure_type _S_test(...); 
# 2335
}; 
# 2337
template< class _Functor, class ..._ArgTypes> 
# 2338
struct __result_of_impl< false, false, _Functor, _ArgTypes...>  : private __result_of_other_impl { 
# 2341
typedef __decltype((_S_test< _Functor, _ArgTypes...> (0))) type; 
# 2342
}; 
# 2345
template< class _Functor, class ..._ArgTypes> 
# 2346
struct __invoke_result : public __result_of_impl< is_member_object_pointer< typename remove_reference< _Functor> ::type> ::value, is_member_function_pointer< typename remove_reference< _Functor> ::type> ::value, _Functor, _ArgTypes...> ::type { 
# 2356
}; 
# 2358
template< class _Functor, class ..._ArgTypes> 
# 2359
struct result_of< _Functor (_ArgTypes ...)>  : public __invoke_result< _Functor, _ArgTypes...>  { 
# 2361
}; 
# 2365
template< size_t _Len, size_t _Align = __alignof__(typename __aligned_storage_msa< _Len> ::__type)> using aligned_storage_t = typename aligned_storage< _Len, _Align> ::type; 
# 2369
template< size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union< _Len, _Types...> ::type; 
# 2373
template< class _Tp> using decay_t = typename decay< _Tp> ::type; 
# 2377
template< bool _Cond, class _Tp = void> using enable_if_t = typename enable_if< _Cond, _Tp> ::type; 
# 2381
template< bool _Cond, class _Iftrue, class _Iffalse> using conditional_t = typename conditional< _Cond, _Iftrue, _Iffalse> ::type; 
# 2385
template< class ..._Tp> using common_type_t = typename common_type< _Tp...> ::type; 
# 2389
template< class _Tp> using underlying_type_t = typename underlying_type< _Tp> ::type; 
# 2393
template< class _Tp> using result_of_t = typename result_of< _Tp> ::type; 
# 2398
template< bool _Cond, class _Tp = void> using __enable_if_t = typename enable_if< _Cond, _Tp> ::type; 
# 2402
template< class ...> using __void_t = void; 
# 2407
template< class ...> using void_t = void; 
# 2411
template< class _Default, class _AlwaysVoid, 
# 2412
template< class ...>  class _Op, class ..._Args> 
# 2413
struct __detector { 
# 2415
using value_t = false_type; 
# 2416
using type = _Default; 
# 2417
}; 
# 2420
template< class _Default, template< class ...>  class _Op, class ...
# 2421
_Args> 
# 2422
struct __detector< _Default, __void_t< _Op< _Args...> > , _Op, _Args...>  { 
# 2424
using value_t = true_type; 
# 2425
using type = _Op< _Args...> ; 
# 2426
}; 
# 2429
template< class _Default, template< class ...>  class _Op, class ...
# 2430
_Args> using __detected_or = __detector< _Default, void, _Op, _Args...> ; 
# 2434
template< class _Default, template< class ...>  class _Op, class ...
# 2435
_Args> using __detected_or_t = typename __detector< _Default, void, _Op, _Args...> ::type; 
# 2455 "/usr/include/c++/9/type_traits" 3
template< class _Tp> struct __is_swappable; 
# 2458
template< class _Tp> struct __is_nothrow_swappable; 
# 2461
template< class ..._Elements> class tuple; 
# 2464
template< class > 
# 2465
struct __is_tuple_like_impl : public false_type { 
# 2466
}; 
# 2468
template< class ..._Tps> 
# 2469
struct __is_tuple_like_impl< tuple< _Tps...> >  : public true_type { 
# 2470
}; 
# 2473
template< class _Tp> 
# 2474
struct __is_tuple_like : public __is_tuple_like_impl< __remove_cvref_t< _Tp> > ::type { 
# 2476
}; 
# 2478
template< class _Tp> inline typename enable_if< __and_< __not_< __is_tuple_like< _Tp> > , is_move_constructible< _Tp> , is_move_assignable< _Tp> > ::value> ::type swap(_Tp &, _Tp &) noexcept(__and_< is_nothrow_move_constructible< _Tp> , is_nothrow_move_assignable< _Tp> > ::value); 
# 2487
template< class _Tp, size_t _Nm> inline typename enable_if< __is_swappable< _Tp> ::value> ::type swap(_Tp (& __a)[_Nm], _Tp (& __b)[_Nm]) noexcept(__is_nothrow_swappable< _Tp> ::value); 
# 2493
namespace __swappable_details { 
# 2494
using std::swap;
# 2496
struct __do_is_swappable_impl { 
# 2498
template< class _Tp, class 
# 2499
 = __decltype((swap(std::declval< _Tp &> (), std::declval< _Tp &> ())))> static true_type 
# 2498
__test(int); 
# 2502
template< class > static false_type __test(...); 
# 2504
}; 
# 2506
struct __do_is_nothrow_swappable_impl { 
# 2508
template< class _Tp> static __bool_constant< noexcept(swap(std::declval< _Tp &> (), std::declval< _Tp &> ()))>  __test(int); 
# 2513
template< class > static false_type __test(...); 
# 2515
}; 
# 2517
}
# 2519
template< class _Tp> 
# 2520
struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl { 
# 2523
typedef __decltype((__test< _Tp> (0))) type; 
# 2524
}; 
# 2526
template< class _Tp> 
# 2527
struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl { 
# 2530
typedef __decltype((__test< _Tp> (0))) type; 
# 2531
}; 
# 2533
template< class _Tp> 
# 2534
struct __is_swappable : public __is_swappable_impl< _Tp> ::type { 
# 2536
}; 
# 2538
template< class _Tp> 
# 2539
struct __is_nothrow_swappable : public __is_nothrow_swappable_impl< _Tp> ::type { 
# 2541
}; 
# 2548
template< class _Tp> 
# 2549
struct is_swappable : public __is_swappable_impl< _Tp> ::type { 
# 2551
}; 
# 2554
template< class _Tp> 
# 2555
struct is_nothrow_swappable : public __is_nothrow_swappable_impl< _Tp> ::type { 
# 2557
}; 
# 2561
template< class _Tp> constexpr bool 
# 2562
is_swappable_v = (is_swappable< _Tp> ::value); 
# 2566
template< class _Tp> constexpr bool 
# 2567
is_nothrow_swappable_v = (is_nothrow_swappable< _Tp> ::value); 
# 2571
namespace __swappable_with_details { 
# 2572
using std::swap;
# 2574
struct __do_is_swappable_with_impl { 
# 2576
template< class _Tp, class _Up, class 
# 2577
 = __decltype((swap(std::declval< _Tp> (), std::declval< _Up> ()))), class 
# 2579
 = __decltype((swap(std::declval< _Up> (), std::declval< _Tp> ())))> static true_type 
# 2576
__test(int); 
# 2582
template< class , class > static false_type __test(...); 
# 2584
}; 
# 2586
struct __do_is_nothrow_swappable_with_impl { 
# 2588
template< class _Tp, class _Up> static __bool_constant< noexcept(swap(std::declval< _Tp> (), std::declval< _Up> ())) && noexcept(swap(std::declval< _Up> (), std::declval< _Tp> ()))>  __test(int); 
# 2595
template< class , class > static false_type __test(...); 
# 2597
}; 
# 2599
}
# 2601
template< class _Tp, class _Up> 
# 2602
struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl { 
# 2605
typedef __decltype((__test< _Tp, _Up> (0))) type; 
# 2606
}; 
# 2609
template< class _Tp> 
# 2610
struct __is_swappable_with_impl< _Tp &, _Tp &>  : public __swappable_details::__do_is_swappable_impl { 
# 2613
typedef __decltype((__test< _Tp &> (0))) type; 
# 2614
}; 
# 2616
template< class _Tp, class _Up> 
# 2617
struct __is_nothrow_swappable_with_impl : public __swappable_with_details::__do_is_nothrow_swappable_with_impl { 
# 2620
typedef __decltype((__test< _Tp, _Up> (0))) type; 
# 2621
}; 
# 2624
template< class _Tp> 
# 2625
struct __is_nothrow_swappable_with_impl< _Tp &, _Tp &>  : public __swappable_details::__do_is_nothrow_swappable_impl { 
# 2628
typedef __decltype((__test< _Tp &> (0))) type; 
# 2629
}; 
# 2632
template< class _Tp, class _Up> 
# 2633
struct is_swappable_with : public __is_swappable_with_impl< _Tp, _Up> ::type { 
# 2635
}; 
# 2638
template< class _Tp, class _Up> 
# 2639
struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl< _Tp, _Up> ::type { 
# 2641
}; 
# 2645
template< class _Tp, class _Up> constexpr bool 
# 2646
is_swappable_with_v = (is_swappable_with< _Tp, _Up> ::value); 
# 2650
template< class _Tp, class _Up> constexpr bool 
# 2651
is_nothrow_swappable_with_v = (is_nothrow_swappable_with< _Tp, _Up> ::value); 
# 2660
template< class _Result, class _Ret, bool 
# 2661
 = is_void< _Ret> ::value, class  = void> 
# 2662
struct __is_invocable_impl : public false_type { }; 
# 2665
template< class _Result, class _Ret> 
# 2666
struct __is_invocable_impl< _Result, _Ret, true, __void_t< typename _Result::type> >  : public true_type { 
# 2670
}; 
# 2672
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
# 2675
template< class _Result, class _Ret> 
# 2676
struct __is_invocable_impl< _Result, _Ret, false, __void_t< typename _Result::type> >  { 
# 2683
private: static typename _Result::type _S_get(); 
# 2685
template< class _Tp> static void _S_conv(_Tp); 
# 2689
template< class _Tp, class  = __decltype((_S_conv< _Tp> ((_S_get)())))> static true_type _S_test(int); 
# 2693
template< class _Tp> static false_type _S_test(...); 
# 2698
public: using type = __decltype((_S_test< _Ret> (1))); 
# 2699
}; 
#pragma GCC diagnostic pop
# 2702
template< class _Fn, class ..._ArgTypes> 
# 2703
struct __is_invocable : public __is_invocable_impl< __invoke_result< _Fn, _ArgTypes...> , void> ::type { 
# 2705
}; 
# 2707
template< class _Fn, class _Tp, class ..._Args> constexpr bool 
# 2708
__call_is_nt(__invoke_memfun_ref) 
# 2709
{ 
# 2710
using _Up = typename __inv_unwrap< _Tp> ::type; 
# 2711
return noexcept((std::declval< typename __inv_unwrap< _Tp> ::type> ().*std::declval< _Fn> ())(std::declval< _Args> ()...)); 
# 2713
} 
# 2715
template< class _Fn, class _Tp, class ..._Args> constexpr bool 
# 2716
__call_is_nt(__invoke_memfun_deref) 
# 2717
{ 
# 2718
return noexcept(((*std::declval< _Tp> ()).*std::declval< _Fn> ())(std::declval< _Args> ()...)); 
# 2720
} 
# 2722
template< class _Fn, class _Tp> constexpr bool 
# 2723
__call_is_nt(__invoke_memobj_ref) 
# 2724
{ 
# 2725
using _Up = typename __inv_unwrap< _Tp> ::type; 
# 2726
return noexcept((std::declval< typename __inv_unwrap< _Tp> ::type> ().*std::declval< _Fn> ())); 
# 2727
} 
# 2729
template< class _Fn, class _Tp> constexpr bool 
# 2730
__call_is_nt(__invoke_memobj_deref) 
# 2731
{ 
# 2732
return noexcept(((*std::declval< _Tp> ()).*std::declval< _Fn> ())); 
# 2733
} 
# 2735
template< class _Fn, class ..._Args> constexpr bool 
# 2736
__call_is_nt(__invoke_other) 
# 2737
{ 
# 2738
return noexcept(std::declval< _Fn> ()(std::declval< _Args> ()...)); 
# 2739
} 
# 2741
template< class _Result, class _Fn, class ..._Args> 
# 2742
struct __call_is_nothrow : public __bool_constant< std::__call_is_nt< _Fn, _Args...> (typename _Result::__invoke_type{})>  { 
# 2746
}; 
# 2748
template< class _Fn, class ..._Args> using __call_is_nothrow_ = __call_is_nothrow< __invoke_result< _Fn, _Args...> , _Fn, _Args...> ; 
# 2753
template< class _Fn, class ..._Args> 
# 2754
struct __is_nothrow_invocable : public __and_< __is_invocable< _Fn, _Args...> , __call_is_nothrow_< _Fn, _Args...> > ::type { 
# 2757
}; 
# 2759
struct __nonesuch { 
# 2760
__nonesuch() = delete;
# 2761
~__nonesuch() = delete;
# 2762
__nonesuch(const __nonesuch &) = delete;
# 2763
void operator=(const __nonesuch &) = delete;
# 2764
}; 
# 3097 "/usr/include/c++/9/type_traits" 3
}
# 57 "/usr/include/c++/9/bits/move.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 72 "/usr/include/c++/9/bits/move.h" 3
template< class _Tp> constexpr _Tp &&
# 74
forward(typename remove_reference< _Tp> ::type &__t) noexcept 
# 75
{ return static_cast< _Tp &&>(__t); } 
# 83
template< class _Tp> constexpr _Tp &&
# 85
forward(typename remove_reference< _Tp> ::type &&__t) noexcept 
# 86
{ 
# 87
static_assert((!std::template is_lvalue_reference< _Tp> ::value), "template argument substituting _Tp is an lvalue reference type");
# 89
return static_cast< _Tp &&>(__t); 
# 90
} 
# 97
template< class _Tp> constexpr typename remove_reference< _Tp> ::type &&
# 99
move(_Tp &&__t) noexcept 
# 100
{ return static_cast< typename remove_reference< _Tp> ::type &&>(__t); } 
# 103
template< class _Tp> 
# 104
struct __move_if_noexcept_cond : public __and_< __not_< is_nothrow_move_constructible< _Tp> > , is_copy_constructible< _Tp> > ::type { 
# 106
}; 
# 116 "/usr/include/c++/9/bits/move.h" 3
template< class _Tp> constexpr typename conditional< __move_if_noexcept_cond< _Tp> ::value, const _Tp &, _Tp &&> ::type 
# 119
move_if_noexcept(_Tp &__x) noexcept 
# 120
{ return std::move(__x); } 
# 136 "/usr/include/c++/9/bits/move.h" 3
template< class _Tp> inline _Tp *
# 138
addressof(_Tp &__r) noexcept 
# 139
{ return std::__addressof(__r); } 
# 143
template < typename _Tp >
    const _Tp * addressof ( const _Tp && ) = delete;
# 147
template< class _Tp, class _Up = _Tp> inline _Tp 
# 149
__exchange(_Tp &__obj, _Up &&__new_val) 
# 150
{ 
# 151
_Tp __old_val = std::move(__obj); 
# 152
__obj = std::forward< _Up> (__new_val); 
# 153
return __old_val; 
# 154
} 
# 176 "/usr/include/c++/9/bits/move.h" 3
template< class _Tp> inline typename enable_if< __and_< __not_< __is_tuple_like< _Tp> > , is_move_constructible< _Tp> , is_move_assignable< _Tp> > ::value> ::type 
# 182
swap(_Tp &__a, _Tp &__b) noexcept(__and_< is_nothrow_move_constructible< _Tp> , is_nothrow_move_assignable< _Tp> > ::value) 
# 189
{ 
# 193
_Tp __tmp = std::move(__a); 
# 194
__a = std::move(__b); 
# 195
__b = std::move(__tmp); 
# 196
} 
# 201
template< class _Tp, size_t _Nm> inline typename enable_if< __is_swappable< _Tp> ::value> ::type 
# 205
swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable< _Tp> ::value) 
# 211
{ 
# 212
for (size_t __n = (0); __n < _Nm; ++__n) { 
# 213
swap(__a[__n], __b[__n]); }  
# 214
} 
# 218
}
# 42 "/usr/include/c++/9/bits/nested_exception.h" 3
extern "C++" {
# 44
namespace std { 
# 52
class nested_exception { 
# 54
__exception_ptr::exception_ptr _M_ptr; 
# 57
public: nested_exception() noexcept : _M_ptr(current_exception()) { } 
# 59
nested_exception(const nested_exception &) noexcept = default;
# 61
nested_exception &operator=(const nested_exception &) noexcept = default;
# 63
virtual ~nested_exception() noexcept; 
# 65
[[noreturn]] void 
# 67
rethrow_nested() const 
# 68
{ 
# 69
if ((_M_ptr)) { 
# 70
rethrow_exception(_M_ptr); }  
# 71
std::terminate(); 
# 72
} 
# 75
__exception_ptr::exception_ptr nested_ptr() const noexcept 
# 76
{ return _M_ptr; } 
# 77
}; 
# 79
template< class _Except> 
# 80
struct _Nested_exception : public _Except, public nested_exception { 
# 82
explicit _Nested_exception(const _Except &__ex) : _Except(__ex) 
# 84
{ } 
# 86
explicit _Nested_exception(_Except &&__ex) : _Except(static_cast< _Except &&>(__ex)) 
# 88
{ } 
# 89
}; 
# 94
template< class _Tp> 
# 95
[[noreturn]] inline void 
# 97
__throw_with_nested_impl(_Tp &&__t, true_type) 
# 98
{ 
# 99
using _Up = typename remove_reference< _Tp> ::type; 
# 100
throw _Nested_exception< typename remove_reference< _Tp> ::type> {std::forward< _Tp> (__t)}; 
# 101
} 
# 103
template< class _Tp> 
# 104
[[noreturn]] inline void 
# 106
__throw_with_nested_impl(_Tp &&__t, false_type) 
# 107
{ throw std::forward< _Tp> (__t); } 
# 111
template< class _Tp> 
# 112
[[noreturn]] inline void 
# 114
throw_with_nested(_Tp &&__t) 
# 115
{ 
# 116
using _Up = typename decay< _Tp> ::type; 
# 117
using _CopyConstructible = __and_< is_copy_constructible< typename decay< _Tp> ::type> , is_move_constructible< typename decay< _Tp> ::type> > ; 
# 119
static_assert((_CopyConstructible::value), "throw_with_nested argument must be CopyConstructible");
# 121
using __nest = __and_< is_class< typename decay< _Tp> ::type> , __bool_constant< !__is_final(_Up)> , __not_< is_base_of< nested_exception, typename decay< _Tp> ::type> > > ; 
# 123
std::__throw_with_nested_impl(std::forward< _Tp> (__t), __nest{}); 
# 124
} 
# 127
template< class _Tp> using __rethrow_if_nested_cond = typename enable_if< __and_< is_polymorphic< _Tp> , __or_< __not_< is_base_of< nested_exception, _Tp> > , is_convertible< _Tp *, nested_exception *> > > ::value> ::type; 
# 135
template< class _Ex> inline __rethrow_if_nested_cond< _Ex>  
# 137
__rethrow_if_nested_impl(const _Ex *__ptr) 
# 138
{ 
# 139
if (auto __ne_ptr = dynamic_cast< const nested_exception *>(__ptr)) { 
# 140
__ne_ptr->rethrow_nested(); }  
# 141
} 
# 145
inline void __rethrow_if_nested_impl(const void *) 
# 146
{ } 
# 149
template< class _Ex> inline void 
# 151
rethrow_if_nested(const _Ex &__ex) 
# 152
{ std::__rethrow_if_nested_impl(std::__addressof(__ex)); } 
# 155
}
# 157
}
# 161
#pragma GCC visibility pop
# 42 "/usr/include/c++/9/bits/functexcept.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 48
void __throw_bad_exception() __attribute((__noreturn__)); 
# 52
void __throw_bad_alloc() __attribute((__noreturn__)); 
# 56
void __throw_bad_cast() __attribute((__noreturn__)); 
# 59
void __throw_bad_typeid() __attribute((__noreturn__)); 
# 63
void __throw_logic_error(const char *) __attribute((__noreturn__)); 
# 66
void __throw_domain_error(const char *) __attribute((__noreturn__)); 
# 69
void __throw_invalid_argument(const char *) __attribute((__noreturn__)); 
# 72
void __throw_length_error(const char *) __attribute((__noreturn__)); 
# 75
void __throw_out_of_range(const char *) __attribute((__noreturn__)); 
# 78
void __throw_out_of_range_fmt(const char *, ...) __attribute((__noreturn__))
# 79
 __attribute((__format__(__gnu_printf__, 1, 2))); 
# 82
void __throw_runtime_error(const char *) __attribute((__noreturn__)); 
# 85
void __throw_range_error(const char *) __attribute((__noreturn__)); 
# 88
void __throw_overflow_error(const char *) __attribute((__noreturn__)); 
# 91
void __throw_underflow_error(const char *) __attribute((__noreturn__)); 
# 95
void __throw_ios_failure(const char *) __attribute((__noreturn__)); 
# 98
void __throw_ios_failure(const char *, int) __attribute((__noreturn__)); 
# 102
void __throw_system_error(int) __attribute((__noreturn__)); 
# 106
void __throw_future_error(int) __attribute((__noreturn__)); 
# 110
void __throw_bad_function_call() __attribute((__noreturn__)); 
# 113
}
# 37 "/usr/include/c++/9/ext/numeric_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 50 "/usr/include/c++/9/ext/numeric_traits.h" 3
template< class _Tp> 
# 51
struct __is_integer_nonstrict : public std::__is_integer< _Tp>  { 
# 54
using std::__is_integer< _Tp> ::__value;
# 57
enum { __width = (__value) ? sizeof(_Tp) * (8) : (0)}; 
# 58
}; 
# 60
template< class _Value> 
# 61
struct __numeric_traits_integer { 
# 64
static_assert((__is_integer_nonstrict< _Value> ::__value), "invalid specialization");
# 70
static const bool __is_signed = (((_Value)(-1)) < 0); 
# 71
static const int __digits = (__is_integer_nonstrict< _Value> ::__width - __is_signed); 
# 75
static const _Value __max = (__is_signed ? (((((_Value)1) << (__digits - 1)) - 1) << 1) + 1 : (~((_Value)0))); 
# 78
static const _Value __min = (__is_signed ? (-__max) - 1 : ((_Value)0)); 
# 79
}; 
# 81
template< class _Value> const _Value __numeric_traits_integer< _Value> ::__min; 
# 84
template< class _Value> const _Value __numeric_traits_integer< _Value> ::__max; 
# 87
template< class _Value> const bool __numeric_traits_integer< _Value> ::__is_signed; 
# 90
template< class _Value> const int __numeric_traits_integer< _Value> ::__digits; 
# 135 "/usr/include/c++/9/ext/numeric_traits.h" 3
template< class _Tp> using __int_traits = __numeric_traits_integer< _Tp> ; 
# 155 "/usr/include/c++/9/ext/numeric_traits.h" 3
template< class _Value> 
# 156
struct __numeric_traits_floating { 
# 159
static const int __max_digits10 = ((2) + ((((std::template __are_same< _Value, float> ::__value) ? 24 : ((std::template __are_same< _Value, double> ::__value) ? 53 : 64)) * 643L) / (2136))); 
# 162
static const bool __is_signed = true; 
# 163
static const int __digits10 = ((std::template __are_same< _Value, float> ::__value) ? 6 : ((std::template __are_same< _Value, double> ::__value) ? 15 : 18)); 
# 164
static const int __max_exponent10 = ((std::template __are_same< _Value, float> ::__value) ? 38 : ((std::template __are_same< _Value, double> ::__value) ? 308 : 4932)); 
# 165
}; 
# 167
template< class _Value> const int __numeric_traits_floating< _Value> ::__max_digits10; 
# 170
template< class _Value> const bool __numeric_traits_floating< _Value> ::__is_signed; 
# 173
template< class _Value> const int __numeric_traits_floating< _Value> ::__digits10; 
# 176
template< class _Value> const int __numeric_traits_floating< _Value> ::__max_exponent10; 
# 179
template< class _Value> 
# 180
struct __numeric_traits : public __conditional_type< std::__is_integer< _Value> ::__value, __numeric_traits_integer< _Value> , __numeric_traits_floating< _Value> > ::__type { 
# 184
}; 
# 187
}
# 65 "/usr/include/c++/9/bits/stl_pair.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 76 "/usr/include/c++/9/bits/stl_pair.h" 3
struct piecewise_construct_t { explicit piecewise_construct_t() = default;}; 
# 79
constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t(); 
# 83
template< class ...> class tuple; 
# 86
template< size_t ...> struct _Index_tuple; 
# 94
template< bool , class _T1, class _T2> 
# 95
struct _PCC { 
# 97
template< class _U1, class _U2> static constexpr bool 
# 98
_ConstructiblePair() 
# 99
{ 
# 100
return __and_< is_constructible< _T1, const _U1 &> , is_constructible< _T2, const _U2 &> > ::value; 
# 102
} 
# 104
template< class _U1, class _U2> static constexpr bool 
# 105
_ImplicitlyConvertiblePair() 
# 106
{ 
# 107
return __and_< is_convertible< const _U1 &, _T1> , is_convertible< const _U2 &, _T2> > ::value; 
# 109
} 
# 111
template< class _U1, class _U2> static constexpr bool 
# 112
_MoveConstructiblePair() 
# 113
{ 
# 114
return __and_< is_constructible< _T1, _U1 &&> , is_constructible< _T2, _U2 &&> > ::value; 
# 116
} 
# 118
template< class _U1, class _U2> static constexpr bool 
# 119
_ImplicitlyMoveConvertiblePair() 
# 120
{ 
# 121
return __and_< is_convertible< _U1 &&, _T1> , is_convertible< _U2 &&, _T2> > ::value; 
# 123
} 
# 125
template< bool __implicit, class _U1, class _U2> static constexpr bool 
# 126
_CopyMovePair() 
# 127
{ 
# 128
using __do_converts = __and_< is_convertible< const _U1 &, _T1> , is_convertible< _U2 &&, _T2> > ; 
# 130
using __converts = typename conditional< __implicit, __and_< is_convertible< const _U1 &, _T1> , is_convertible< _U2 &&, _T2> > , __not_< __and_< is_convertible< const _U1 &, _T1> , is_convertible< _U2 &&, _T2> > > > ::type; 
# 133
return __and_< is_constructible< _T1, const _U1 &> , is_constructible< _T2, _U2 &&> , typename conditional< __implicit, __and_< is_convertible< const _U1 &, _T1> , is_convertible< _U2 &&, _T2> > , __not_< __and_< is_convertible< const _U1 &, _T1> , is_convertible< _U2 &&, _T2> > > > ::type> ::value; 
# 137
} 
# 139
template< bool __implicit, class _U1, class _U2> static constexpr bool 
# 140
_MoveCopyPair() 
# 141
{ 
# 142
using __do_converts = __and_< is_convertible< _U1 &&, _T1> , is_convertible< const _U2 &, _T2> > ; 
# 144
using __converts = typename conditional< __implicit, __and_< is_convertible< _U1 &&, _T1> , is_convertible< const _U2 &, _T2> > , __not_< __and_< is_convertible< _U1 &&, _T1> , is_convertible< const _U2 &, _T2> > > > ::type; 
# 147
return __and_< is_constructible< _T1, _U1 &&> , is_constructible< _T2, const _U2 &&> , typename conditional< __implicit, __and_< is_convertible< _U1 &&, _T1> , is_convertible< const _U2 &, _T2> > , __not_< __and_< is_convertible< _U1 &&, _T1> , is_convertible< const _U2 &, _T2> > > > ::type> ::value; 
# 151
} 
# 152
}; 
# 154
template< class _T1, class _T2> 
# 155
struct _PCC< false, _T1, _T2>  { 
# 157
template< class _U1, class _U2> static constexpr bool 
# 158
_ConstructiblePair() 
# 159
{ 
# 160
return false; 
# 161
} 
# 163
template< class _U1, class _U2> static constexpr bool 
# 164
_ImplicitlyConvertiblePair() 
# 165
{ 
# 166
return false; 
# 167
} 
# 169
template< class _U1, class _U2> static constexpr bool 
# 170
_MoveConstructiblePair() 
# 171
{ 
# 172
return false; 
# 173
} 
# 175
template< class _U1, class _U2> static constexpr bool 
# 176
_ImplicitlyMoveConvertiblePair() 
# 177
{ 
# 178
return false; 
# 179
} 
# 180
}; 
# 185
struct __nonesuch_no_braces : public __nonesuch { 
# 186
explicit __nonesuch_no_braces(const __nonesuch &) = delete;
# 187
}; 
# 190
template< class _U1, class _U2> class __pair_base { 
# 193
template< class _T1, class _T2> friend struct pair; 
# 194
__pair_base() = default;
# 195
~__pair_base() = default;
# 196
__pair_base(const __pair_base &) = default;
# 197
__pair_base &operator=(const __pair_base &) = delete;
# 199
}; 
# 207
template< class _T1, class _T2> 
# 208
struct pair : private __pair_base< _T1, _T2>  { 
# 211
typedef _T1 first_type; 
# 212
typedef _T2 second_type; 
# 214
_T1 first; 
# 215
_T2 second; 
# 222
template< class _U1 = _T1, class 
# 223
_U2 = _T2, typename enable_if< __and_< __is_implicitly_default_constructible< _U1> , __is_implicitly_default_constructible< _U2> > ::value, bool> ::type 
# 227
 = true> constexpr 
# 229
pair() : first(), second() 
# 230
{ } 
# 233
template< class _U1 = _T1, class 
# 234
_U2 = _T2, typename enable_if< __and_< is_default_constructible< _U1> , is_default_constructible< _U2> , __not_< __and_< __is_implicitly_default_constructible< _U1> , __is_implicitly_default_constructible< _U2> > > > ::value, bool> ::type 
# 241
 = false> constexpr explicit 
# 242
pair() : first(), second() 
# 243
{ } 
# 252 "/usr/include/c++/9/bits/stl_pair.h" 3
using _PCCP = _PCC< true, _T1, _T2> ; 
# 254
template< class _U1 = _T1, class _U2 = _T2, typename enable_if< _PCC< true, _T1, _T2> ::template _ConstructiblePair< _U1, _U2> () && _PCC< true, _T1, _T2> ::template _ImplicitlyConvertiblePair< _U1, _U2> (), bool> ::type 
# 259
 = true> constexpr 
# 260
pair(const _T1 &__a, const _T2 &__b) : first(__a), second(__b) 
# 261
{ } 
# 263
template< class _U1 = _T1, class _U2 = _T2, typename enable_if< _PCC< true, _T1, _T2> ::template _ConstructiblePair< _U1, _U2> () && (!_PCC< true, _T1, _T2> ::template _ImplicitlyConvertiblePair< _U1, _U2> ()), bool> ::type 
# 268
 = false> constexpr explicit 
# 269
pair(const _T1 &__a, const _T2 &__b) : first(__a), second(__b) 
# 270
{ } 
# 280 "/usr/include/c++/9/bits/stl_pair.h" 3
template< class _U1, class _U2> using _PCCFP = _PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ; 
# 285
template< class _U1, class _U2, typename enable_if< _PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ::template _ConstructiblePair< _U1, _U2> () && _PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ::template _ImplicitlyConvertiblePair< _U1, _U2> (), bool> ::type 
# 290
 = true> constexpr 
# 291
pair(const std::pair< _U1, _U2>  &__p) : first((__p.first)), second((__p.second)) 
# 292
{ } 
# 294
template< class _U1, class _U2, typename enable_if< _PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ::template _ConstructiblePair< _U1, _U2> () && (!_PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ::template _ImplicitlyConvertiblePair< _U1, _U2> ()), bool> ::type 
# 299
 = false> constexpr explicit 
# 300
pair(const std::pair< _U1, _U2>  &__p) : first((__p.first)), second((__p.second)) 
# 301
{ } 
# 303
constexpr pair(const pair &) = default;
# 304
constexpr pair(pair &&) = default;
# 307
template< class _U1, typename enable_if< _PCC< true, _T1, _T2> ::template _MoveCopyPair< true, _U1, _T2> (), bool> ::type 
# 310
 = true> constexpr 
# 311
pair(_U1 &&__x, const _T2 &__y) : first(std::forward< _U1> (__x)), second(__y) 
# 312
{ } 
# 314
template< class _U1, typename enable_if< _PCC< true, _T1, _T2> ::template _MoveCopyPair< false, _U1, _T2> (), bool> ::type 
# 317
 = false> constexpr explicit 
# 318
pair(_U1 &&__x, const _T2 &__y) : first(std::forward< _U1> (__x)), second(__y) 
# 319
{ } 
# 321
template< class _U2, typename enable_if< _PCC< true, _T1, _T2> ::template _CopyMovePair< true, _T1, _U2> (), bool> ::type 
# 324
 = true> constexpr 
# 325
pair(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward< _U2> (__y)) 
# 326
{ } 
# 328
template< class _U2, typename enable_if< _PCC< true, _T1, _T2> ::template _CopyMovePair< false, _T1, _U2> (), bool> ::type 
# 331
 = false> explicit 
# 332
pair(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward< _U2> (__y)) 
# 333
{ } 
# 335
template< class _U1, class _U2, typename enable_if< _PCC< true, _T1, _T2> ::template _MoveConstructiblePair< _U1, _U2> () && _PCC< true, _T1, _T2> ::template _ImplicitlyMoveConvertiblePair< _U1, _U2> (), bool> ::type 
# 340
 = true> constexpr 
# 341
pair(_U1 &&__x, _U2 &&__y) : first(std::forward< _U1> (__x)), second(std::forward< _U2> (__y)) 
# 342
{ } 
# 344
template< class _U1, class _U2, typename enable_if< _PCC< true, _T1, _T2> ::template _MoveConstructiblePair< _U1, _U2> () && (!_PCC< true, _T1, _T2> ::template _ImplicitlyMoveConvertiblePair< _U1, _U2> ()), bool> ::type 
# 349
 = false> constexpr explicit 
# 350
pair(_U1 &&__x, _U2 &&__y) : first(std::forward< _U1> (__x)), second(std::forward< _U2> (__y)) 
# 351
{ } 
# 354
template< class _U1, class _U2, typename enable_if< _PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ::template _MoveConstructiblePair< _U1, _U2> () && _PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ::template _ImplicitlyMoveConvertiblePair< _U1, _U2> (), bool> ::type 
# 359
 = true> constexpr 
# 360
pair(std::pair< _U1, _U2>  &&__p) : first(std::forward< _U1> ((__p.first))), second(std::forward< _U2> ((__p.second))) 
# 362
{ } 
# 364
template< class _U1, class _U2, typename enable_if< _PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ::template _MoveConstructiblePair< _U1, _U2> () && (!_PCC< (!is_same< _T1, _U1> ::value) || (!is_same< _T2, _U2> ::value), _T1, _T2> ::template _ImplicitlyMoveConvertiblePair< _U1, _U2> ()), bool> ::type 
# 369
 = false> constexpr explicit 
# 370
pair(std::pair< _U1, _U2>  &&__p) : first(std::forward< _U1> ((__p.first))), second(std::forward< _U2> ((__p.second))) 
# 372
{ } 
# 374
template< class ..._Args1, class ..._Args2> inline pair(std::piecewise_construct_t, tuple< _Args1...> , tuple< _Args2...> ); 
# 378
pair &operator=(typename conditional< __and_< is_copy_assignable< _T1> , is_copy_assignable< _T2> > ::value, const pair &, const std::__nonesuch_no_braces &> ::type 
# 381
__p) 
# 382
{ 
# 383
(first) = (__p.first); 
# 384
(second) = (__p.second); 
# 385
return *this; 
# 386
} 
# 389
pair &operator=(typename conditional< __and_< is_move_assignable< _T1> , is_move_assignable< _T2> > ::value, pair &&, std::__nonesuch_no_braces &&> ::type 
# 392
__p) noexcept(__and_< is_nothrow_move_assignable< _T1> , is_nothrow_move_assignable< _T2> > ::value) 
# 395
{ 
# 396
(first) = std::forward< first_type> ((__p.first)); 
# 397
(second) = std::forward< second_type> ((__p.second)); 
# 398
return *this; 
# 399
} 
# 401
template< class _U1, class _U2> typename enable_if< __and_< is_assignable< _T1 &, const _U1 &> , is_assignable< _T2 &, const _U2 &> > ::value, pair &> ::type 
# 405
operator=(const std::pair< _U1, _U2>  &__p) 
# 406
{ 
# 407
(first) = (__p.first); 
# 408
(second) = (__p.second); 
# 409
return *this; 
# 410
} 
# 412
template< class _U1, class _U2> typename enable_if< __and_< is_assignable< _T1 &, _U1 &&> , is_assignable< _T2 &, _U2 &&> > ::value, pair &> ::type 
# 416
operator=(std::pair< _U1, _U2>  &&__p) 
# 417
{ 
# 418
(first) = std::forward< _U1> ((__p.first)); 
# 419
(second) = std::forward< _U2> ((__p.second)); 
# 420
return *this; 
# 421
} 
# 424
void swap(pair &__p) noexcept(__and_< __is_nothrow_swappable< _T1> , __is_nothrow_swappable< _T2> > ::value) 
# 427
{ 
# 428
using std::swap;
# 429
swap(first, __p.first); 
# 430
swap(second, __p.second); 
# 431
} 
# 434
private: template< class ..._Args1, std::size_t ..._Indexes1, class ...
# 435
_Args2, std::size_t ..._Indexes2> inline 
# 434
pair(tuple< _Args1...>  &, tuple< _Args2...>  &, _Index_tuple< _Indexes1...> , _Index_tuple< _Indexes2...> ); 
# 439
}; 
# 446
template< class _T1, class _T2> constexpr bool 
# 448
operator==(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 449
{ return ((__x.first) == (__y.first)) && ((__x.second) == (__y.second)); } 
# 452
template< class _T1, class _T2> constexpr bool 
# 454
operator<(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 455
{ return ((__x.first) < (__y.first)) || ((!((__y.first) < (__x.first))) && ((__x.second) < (__y.second))); 
# 456
} 
# 459
template< class _T1, class _T2> constexpr bool 
# 461
operator!=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 462
{ return !(__x == __y); } 
# 465
template< class _T1, class _T2> constexpr bool 
# 467
operator>(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 468
{ return __y < __x; } 
# 471
template< class _T1, class _T2> constexpr bool 
# 473
operator<=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 474
{ return !(__y < __x); } 
# 477
template< class _T1, class _T2> constexpr bool 
# 479
operator>=(const pair< _T1, _T2>  &__x, const pair< _T1, _T2>  &__y) 
# 480
{ return !(__x < __y); } 
# 486
template< class _T1, class _T2> inline typename enable_if< __and_< __is_swappable< _T1> , __is_swappable< _T2> > ::value> ::type 
# 495
swap(pair< _T1, _T2>  &__x, pair< _T1, _T2>  &__y) noexcept(noexcept(__x.swap(__y))) 
# 497
{ __x.swap(__y); } 
# 500
template < typename _T1, typename _T2 >
    typename enable_if < ! __and_ < __is_swappable < _T1 >,
          __is_swappable < _T2 > > :: value > :: type
    swap ( pair < _T1, _T2 > &, pair < _T1, _T2 > & ) = delete;
# 521 "/usr/include/c++/9/bits/stl_pair.h" 3
template< class _T1, class _T2> constexpr pair< typename __decay_and_strip< _T1> ::__type, typename __decay_and_strip< _T2> ::__type>  
# 524
make_pair(_T1 &&__x, _T2 &&__y) 
# 525
{ 
# 526
typedef typename __decay_and_strip< _T1> ::__type __ds_type1; 
# 527
typedef typename __decay_and_strip< _T2> ::__type __ds_type2; 
# 528
typedef pair< typename __decay_and_strip< _T1> ::__type, typename __decay_and_strip< _T2> ::__type>  __pair_type; 
# 529
return __pair_type(std::forward< _T1> (__x), std::forward< _T2> (__y)); 
# 530
} 
# 541 "/usr/include/c++/9/bits/stl_pair.h" 3
}
# 70 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 89 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
struct input_iterator_tag { }; 
# 92
struct output_iterator_tag { }; 
# 95
struct forward_iterator_tag : public input_iterator_tag { }; 
# 99
struct bidirectional_iterator_tag : public forward_iterator_tag { }; 
# 103
struct random_access_iterator_tag : public bidirectional_iterator_tag { }; 
# 116 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
template< class _Category, class _Tp, class _Distance = ptrdiff_t, class 
# 117
_Pointer = _Tp *, class _Reference = _Tp &> 
# 118
struct iterator { 
# 121
typedef _Category iterator_category; 
# 123
typedef _Tp value_type; 
# 125
typedef _Distance difference_type; 
# 127
typedef _Pointer pointer; 
# 129
typedef _Reference reference; 
# 130
}; 
# 143 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
template< class _Iterator, class  = __void_t< > > 
# 144
struct __iterator_traits { }; 
# 146
template< class _Iterator> 
# 147
struct __iterator_traits< _Iterator, __void_t< typename _Iterator::iterator_category, typename _Iterator::value_type, typename _Iterator::difference_type, typename _Iterator::pointer, typename _Iterator::reference> >  { 
# 154
typedef typename _Iterator::iterator_category iterator_category; 
# 155
typedef typename _Iterator::value_type value_type; 
# 156
typedef typename _Iterator::difference_type difference_type; 
# 157
typedef typename _Iterator::pointer pointer; 
# 158
typedef typename _Iterator::reference reference; 
# 159
}; 
# 161
template< class _Iterator> 
# 162
struct iterator_traits : public __iterator_traits< _Iterator>  { 
# 163
}; 
# 177 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
template< class _Tp> 
# 178
struct iterator_traits< _Tp *>  { 
# 180
typedef random_access_iterator_tag iterator_category; 
# 181
typedef _Tp value_type; 
# 182
typedef ptrdiff_t difference_type; 
# 183
typedef _Tp *pointer; 
# 184
typedef _Tp &reference; 
# 185
}; 
# 188
template< class _Tp> 
# 189
struct iterator_traits< const _Tp *>  { 
# 191
typedef random_access_iterator_tag iterator_category; 
# 192
typedef _Tp value_type; 
# 193
typedef ptrdiff_t difference_type; 
# 194
typedef const _Tp *pointer; 
# 195
typedef const _Tp &reference; 
# 196
}; 
# 202
template< class _Iter> constexpr typename iterator_traits< _Iter> ::iterator_category 
# 205
__iterator_category(const _Iter &) 
# 206
{ return typename iterator_traits< _Iter> ::iterator_category(); } 
# 231 "/usr/include/c++/9/bits/stl_iterator_base_types.h" 3
template< class _InIter> using _RequireInputIter = typename enable_if< is_convertible< typename iterator_traits< _InIter> ::iterator_category, input_iterator_tag> ::value> ::type; 
# 239
}
# 67 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 73
template< class > struct _List_iterator; 
# 74
template< class > struct _List_const_iterator; 
# 77
template< class _InputIterator> constexpr typename iterator_traits< _InputIterator> ::difference_type 
# 80
__distance(_InputIterator __first, _InputIterator __last, input_iterator_tag) 
# 82
{ 
# 86
typename iterator_traits< _InputIterator> ::difference_type __n = (0); 
# 87
while (__first != __last) 
# 88
{ 
# 89
++__first; 
# 90
++__n; 
# 91
}  
# 92
return __n; 
# 93
} 
# 95
template< class _RandomAccessIterator> constexpr typename iterator_traits< _RandomAccessIterator> ::difference_type 
# 98
__distance(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag) 
# 100
{ 
# 104
return __last - __first; 
# 105
} 
# 109
template< class _Tp> inline ptrdiff_t __distance(_List_iterator< _Tp> , _List_iterator< _Tp> , input_iterator_tag); 
# 115
template< class _Tp> inline ptrdiff_t __distance(_List_const_iterator< _Tp> , _List_const_iterator< _Tp> , input_iterator_tag); 
# 135 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 3
template< class _InputIterator> inline typename iterator_traits< _InputIterator> ::difference_type 
# 138
distance(_InputIterator __first, _InputIterator __last) 
# 139
{ 
# 141
return std::__distance(__first, __last, std::__iterator_category(__first)); 
# 143
} 
# 145
template< class _InputIterator, class _Distance> constexpr void 
# 147
__advance(_InputIterator &__i, _Distance __n, input_iterator_tag) 
# 148
{ 
# 151
; 
# 152
while (__n--) { 
# 153
++__i; }  
# 154
} 
# 156
template< class _BidirectionalIterator, class _Distance> constexpr void 
# 158
__advance(_BidirectionalIterator &__i, _Distance __n, bidirectional_iterator_tag) 
# 160
{ 
# 164
if (__n > 0) { 
# 165
while (__n--) { 
# 166
++__i; }  } else { 
# 168
while (__n++) { 
# 169
--__i; }  }  
# 170
} 
# 172
template< class _RandomAccessIterator, class _Distance> constexpr void 
# 174
__advance(_RandomAccessIterator &__i, _Distance __n, random_access_iterator_tag) 
# 176
{ 
# 180
if (__builtin_constant_p(__n) && (__n == 1)) { 
# 181
++__i; } else { 
# 182
if (__builtin_constant_p(__n) && (__n == (-1))) { 
# 183
--__i; } else { 
# 185
__i += __n; }  }  
# 186
} 
# 200 "/usr/include/c++/9/bits/stl_iterator_base_funcs.h" 3
template< class _InputIterator, class _Distance> inline void 
# 202
advance(_InputIterator &__i, _Distance __n) 
# 203
{ 
# 205
typename iterator_traits< _InputIterator> ::difference_type __d = __n; 
# 206
std::__advance(__i, __d, std::__iterator_category(__i)); 
# 207
} 
# 211
template< class _InputIterator> inline _InputIterator 
# 213
next(_InputIterator __x, typename iterator_traits< _InputIterator> ::difference_type 
# 214
__n = 1) 
# 215
{ 
# 218
std::advance(__x, __n); 
# 219
return __x; 
# 220
} 
# 222
template< class _BidirectionalIterator> inline _BidirectionalIterator 
# 224
prev(_BidirectionalIterator __x, typename iterator_traits< _BidirectionalIterator> ::difference_type 
# 225
__n = 1) 
# 226
{ 
# 230
std::advance(__x, -__n); 
# 231
return __x; 
# 232
} 
# 237
}
# 42 "/usr/include/c++/9/bits/ptr_traits.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 46
class __undefined; 
# 49
template< class _Tp> 
# 50
struct __get_first_arg { 
# 51
using type = __undefined; }; 
# 53
template< template< class , class ...>  class _Template, class _Tp, class ...
# 54
_Types> 
# 55
struct __get_first_arg< _Template< _Tp, _Types...> >  { 
# 56
using type = _Tp; }; 
# 58
template< class _Tp> using __get_first_arg_t = typename __get_first_arg< _Tp> ::type; 
# 62
template< class _Tp, class _Up> 
# 63
struct __replace_first_arg { 
# 64
}; 
# 66
template< template< class , class ...>  class _Template, class _Up, class 
# 67
_Tp, class ..._Types> 
# 68
struct __replace_first_arg< _Template< _Tp, _Types...> , _Up>  { 
# 69
using type = _Template< _Up, _Types...> ; }; 
# 71
template< class _Tp, class _Up> using __replace_first_arg_t = typename __replace_first_arg< _Tp, _Up> ::type; 
# 74
template< class _Tp> using __make_not_void = typename conditional< is_void< _Tp> ::value, __undefined, _Tp> ::type; 
# 82
template< class _Ptr> 
# 83
struct pointer_traits { 
# 87
private: 
# 86
template< class _Tp> using __element_type = typename _Tp::element_type; 
# 89
template< class _Tp> using __difference_type = typename _Tp::difference_type; 
# 92
template< class _Tp, class _Up, class  = void> 
# 93
struct __rebind : public __replace_first_arg< _Tp, _Up>  { }; 
# 95
template< class _Tp, class _Up> 
# 96
struct __rebind< _Tp, _Up, __void_t< typename _Tp::template rebind< _Up> > >  { 
# 97
using type = typename _Tp::template rebind< _Up> ; }; 
# 101
public: using pointer = _Ptr; 
# 104
using element_type = __detected_or_t< __get_first_arg_t< _Ptr> , __element_type, _Ptr> ; 
# 108
using difference_type = __detected_or_t< ptrdiff_t, __difference_type, _Ptr> ; 
# 112
template< class _Up> using rebind = typename __rebind< _Ptr, _Up> ::type; 
# 116
static _Ptr pointer_to(__make_not_void< element_type>  &__e) 
# 117
{ return _Ptr::pointer_to(__e); } 
# 119
static_assert((!is_same< element_type, __undefined> ::value), "pointer type defines element_type or is like SomePointer<T, Args>");
# 121
}; 
# 127
template< class _Tp> 
# 128
struct pointer_traits< _Tp *>  { 
# 131
typedef _Tp *pointer; 
# 133
typedef _Tp element_type; 
# 135
typedef ptrdiff_t difference_type; 
# 137
template< class _Up> using rebind = _Up *; 
# 146
static pointer pointer_to(__make_not_void< element_type>  &__r) noexcept 
# 147
{ return std::addressof(__r); } 
# 148
}; 
# 151
template< class _Ptr, class _Tp> using __ptr_rebind = typename pointer_traits< _Ptr> ::template rebind< _Tp> ; 
# 154
template< class _Tp> constexpr _Tp *
# 156
__to_address(_Tp *__ptr) noexcept 
# 157
{ 
# 158
static_assert((!std::template is_function< _Tp> ::value), "not a function pointer");
# 159
return __ptr; 
# 160
} 
# 163
template< class _Ptr> constexpr typename pointer_traits< _Ptr> ::element_type *
# 165
__to_address(const _Ptr &__ptr) 
# 166
{ return std::__to_address(__ptr.operator->()); } 
# 211 "/usr/include/c++/9/bits/ptr_traits.h" 3
}
# 76 "/usr/include/c++/9/bits/stl_iterator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 104 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Iterator> 
# 105
class reverse_iterator : public iterator< typename iterator_traits< _Iterator> ::iterator_category, typename iterator_traits< _Iterator> ::value_type, typename iterator_traits< _Iterator> ::difference_type, typename iterator_traits< _Iterator> ::pointer, typename iterator_traits< _Iterator> ::reference>  { 
# 113
protected: _Iterator current; 
# 115
typedef iterator_traits< _Iterator>  __traits_type; 
# 118
public: typedef _Iterator iterator_type; 
# 119
typedef typename iterator_traits< _Iterator> ::difference_type difference_type; 
# 120
typedef typename iterator_traits< _Iterator> ::pointer pointer; 
# 121
typedef typename iterator_traits< _Iterator> ::reference reference; 
# 131 "/usr/include/c++/9/bits/stl_iterator.h" 3
reverse_iterator() : current() { } 
# 137
explicit reverse_iterator(iterator_type __x) : current(__x) { } 
# 143
reverse_iterator(const reverse_iterator &__x) : current(__x.current) 
# 144
{ } 
# 147
reverse_iterator &operator=(const reverse_iterator &) = default;
# 154
template< class _Iter> 
# 156
reverse_iterator(const reverse_iterator< _Iter>  &__x) : current(__x.base()) 
# 157
{ } 
# 163
iterator_type base() const 
# 164
{ return current; } 
# 177 "/usr/include/c++/9/bits/stl_iterator.h" 3
reference operator*() const 
# 178
{ 
# 179
_Iterator __tmp = current; 
# 180
return *(--__tmp); 
# 181
} 
# 189
pointer operator->() const 
# 190
{ 
# 193
_Iterator __tmp = current; 
# 194
--__tmp; 
# 195
return _S_to_pointer(__tmp); 
# 196
} 
# 204
reverse_iterator &operator++() 
# 205
{ 
# 206
--(current); 
# 207
return *this; 
# 208
} 
# 216
reverse_iterator operator++(int) 
# 217
{ 
# 218
reverse_iterator __tmp = *this; 
# 219
--(current); 
# 220
return __tmp; 
# 221
} 
# 229
reverse_iterator &operator--() 
# 230
{ 
# 231
++(current); 
# 232
return *this; 
# 233
} 
# 241
reverse_iterator operator--(int) 
# 242
{ 
# 243
reverse_iterator __tmp = *this; 
# 244
++(current); 
# 245
return __tmp; 
# 246
} 
# 254
reverse_iterator operator+(difference_type __n) const 
# 255
{ return ((reverse_iterator)((current) - __n)); } 
# 264
reverse_iterator &operator+=(difference_type __n) 
# 265
{ 
# 266
(current) -= __n; 
# 267
return *this; 
# 268
} 
# 276
reverse_iterator operator-(difference_type __n) const 
# 277
{ return ((reverse_iterator)((current) + __n)); } 
# 286
reverse_iterator &operator-=(difference_type __n) 
# 287
{ 
# 288
(current) += __n; 
# 289
return *this; 
# 290
} 
# 298
reference operator[](difference_type __n) const 
# 299
{ return *((*this) + __n); } 
# 304
private: 
# 302
template< class _Tp> static _Tp *
# 304
_S_to_pointer(_Tp *__p) 
# 305
{ return __p; } 
# 307
template< class _Tp> static pointer 
# 309
_S_to_pointer(_Tp __t) 
# 310
{ return __t.operator->(); } 
# 311
}; 
# 323 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Iterator> inline bool 
# 325
operator==(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 326
__y) 
# 327
{ return __x.base() == __y.base(); } 
# 329
template< class _Iterator> inline bool 
# 331
operator<(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 332
__y) 
# 333
{ return __y.base() < __x.base(); } 
# 335
template< class _Iterator> inline bool 
# 337
operator!=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 338
__y) 
# 339
{ return !(__x == __y); } 
# 341
template< class _Iterator> inline bool 
# 343
operator>(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 344
__y) 
# 345
{ return __y < __x; } 
# 347
template< class _Iterator> inline bool 
# 349
operator<=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 350
__y) 
# 351
{ return !(__y < __x); } 
# 353
template< class _Iterator> inline bool 
# 355
operator>=(const reverse_iterator< _Iterator>  &__x, const reverse_iterator< _Iterator>  &
# 356
__y) 
# 357
{ return !(__x < __y); } 
# 361
template< class _IteratorL, class _IteratorR> inline bool 
# 363
operator==(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 364
__y) 
# 365
{ return __x.base() == __y.base(); } 
# 367
template< class _IteratorL, class _IteratorR> inline bool 
# 369
operator<(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 370
__y) 
# 371
{ return __y.base() < __x.base(); } 
# 373
template< class _IteratorL, class _IteratorR> inline bool 
# 375
operator!=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 376
__y) 
# 377
{ return !(__x == __y); } 
# 379
template< class _IteratorL, class _IteratorR> inline bool 
# 381
operator>(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 382
__y) 
# 383
{ return __y < __x; } 
# 385
template< class _IteratorL, class _IteratorR> inline bool 
# 387
operator<=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 388
__y) 
# 389
{ return !(__y < __x); } 
# 391
template< class _IteratorL, class _IteratorR> inline bool 
# 393
operator>=(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 394
__y) 
# 395
{ return !(__x < __y); } 
# 413 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _IteratorL, class _IteratorR> inline auto 
# 415
operator-(const reverse_iterator< _IteratorL>  &__x, const reverse_iterator< _IteratorR>  &
# 416
__y)->__decltype((__y.base() - __x.base())) 
# 418
{ return __y.base() - __x.base(); } 
# 421
template< class _Iterator> inline reverse_iterator< _Iterator>  
# 423
operator+(typename reverse_iterator< _Iterator> ::difference_type __n, const reverse_iterator< _Iterator>  &
# 424
__x) 
# 425
{ return ((reverse_iterator< _Iterator> )(__x.base() - __n)); } 
# 429
template< class _Iterator> inline reverse_iterator< _Iterator>  
# 431
__make_reverse_iterator(_Iterator __i) 
# 432
{ return ((reverse_iterator< _Iterator> )(__i)); } 
# 440
template< class _Iterator> inline reverse_iterator< _Iterator>  
# 442
make_reverse_iterator(_Iterator __i) 
# 443
{ return ((reverse_iterator< _Iterator> )(__i)); } 
# 448
template< class _Iterator> auto 
# 450
__niter_base(reverse_iterator< _Iterator>  __it)->__decltype((__make_reverse_iterator(__niter_base(__it.base())))) 
# 452
{ return __make_reverse_iterator(__niter_base(__it.base())); } 
# 454
template< class _Iterator> 
# 455
struct __is_move_iterator< reverse_iterator< _Iterator> >  : public std::__is_move_iterator< _Iterator>  { 
# 457
}; 
# 459
template< class _Iterator> auto 
# 461
__miter_base(reverse_iterator< _Iterator>  __it)->__decltype((__make_reverse_iterator(__miter_base(__it.base())))) 
# 463
{ return __make_reverse_iterator(__miter_base(__it.base())); } 
# 477 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Container> 
# 478
class back_insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 482
protected: _Container *container; 
# 486
public: typedef _Container container_type; 
# 490
explicit back_insert_iterator(_Container &__x) : container(std::__addressof(__x)) 
# 491
{ } 
# 513 "/usr/include/c++/9/bits/stl_iterator.h" 3
back_insert_iterator &operator=(const typename _Container::value_type &__value) 
# 514
{ 
# 515
(container)->push_back(__value); 
# 516
return *this; 
# 517
} 
# 520
back_insert_iterator &operator=(typename _Container::value_type &&__value) 
# 521
{ 
# 522
(container)->push_back(std::move(__value)); 
# 523
return *this; 
# 524
} 
# 529
back_insert_iterator &operator*() 
# 530
{ return *this; } 
# 534
back_insert_iterator &operator++() 
# 535
{ return *this; } 
# 539
back_insert_iterator operator++(int) 
# 540
{ return *this; } 
# 541
}; 
# 554 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Container> inline back_insert_iterator< _Container>  
# 556
back_inserter(_Container &__x) 
# 557
{ return ((back_insert_iterator< _Container> )(__x)); } 
# 569 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Container> 
# 570
class front_insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 574
protected: _Container *container; 
# 578
public: typedef _Container container_type; 
# 581
explicit front_insert_iterator(_Container &__x) : container(std::__addressof(__x)) 
# 582
{ } 
# 604 "/usr/include/c++/9/bits/stl_iterator.h" 3
front_insert_iterator &operator=(const typename _Container::value_type &__value) 
# 605
{ 
# 606
(container)->push_front(__value); 
# 607
return *this; 
# 608
} 
# 611
front_insert_iterator &operator=(typename _Container::value_type &&__value) 
# 612
{ 
# 613
(container)->push_front(std::move(__value)); 
# 614
return *this; 
# 615
} 
# 620
front_insert_iterator &operator*() 
# 621
{ return *this; } 
# 625
front_insert_iterator &operator++() 
# 626
{ return *this; } 
# 630
front_insert_iterator operator++(int) 
# 631
{ return *this; } 
# 632
}; 
# 645 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Container> inline front_insert_iterator< _Container>  
# 647
front_inserter(_Container &__x) 
# 648
{ return ((front_insert_iterator< _Container> )(__x)); } 
# 664 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Container> 
# 665
class insert_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 669
protected: _Container *container; 
# 670
typename _Container::iterator iter; 
# 674
public: typedef _Container container_type; 
# 680
insert_iterator(_Container &__x, typename _Container::iterator __i) : container(std::__addressof(__x)), iter(__i) 
# 681
{ } 
# 716 "/usr/include/c++/9/bits/stl_iterator.h" 3
insert_iterator &operator=(const typename _Container::value_type &__value) 
# 717
{ 
# 718
(iter) = (container)->insert(iter, __value); 
# 719
++(iter); 
# 720
return *this; 
# 721
} 
# 724
insert_iterator &operator=(typename _Container::value_type &&__value) 
# 725
{ 
# 726
(iter) = (container)->insert(iter, std::move(__value)); 
# 727
++(iter); 
# 728
return *this; 
# 729
} 
# 734
insert_iterator &operator*() 
# 735
{ return *this; } 
# 739
insert_iterator &operator++() 
# 740
{ return *this; } 
# 744
insert_iterator &operator++(int) 
# 745
{ return *this; } 
# 746
}; 
# 760 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Container> inline insert_iterator< _Container>  
# 762
inserter(_Container &__x, typename _Container::iterator __i) 
# 763
{ return insert_iterator< _Container> (__x, __i); } 
# 768
}
# 770
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 781 "/usr/include/c++/9/bits/stl_iterator.h" 3
using std::iterator_traits;
# 782
using std::iterator;
# 783
template< class _Iterator, class _Container> 
# 784
class __normal_iterator { 
# 787
protected: _Iterator _M_current; 
# 789
typedef std::iterator_traits< _Iterator>  __traits_type; 
# 792
public: typedef _Iterator iterator_type; 
# 793
typedef typename std::iterator_traits< _Iterator> ::iterator_category iterator_category; 
# 794
typedef typename std::iterator_traits< _Iterator> ::value_type value_type; 
# 795
typedef typename std::iterator_traits< _Iterator> ::difference_type difference_type; 
# 796
typedef typename std::iterator_traits< _Iterator> ::reference reference; 
# 797
typedef typename std::iterator_traits< _Iterator> ::pointer pointer; 
# 799
constexpr __normal_iterator() noexcept : _M_current(_Iterator()) 
# 800
{ } 
# 803
explicit __normal_iterator(const _Iterator &__i) noexcept : _M_current(__i) 
# 804
{ } 
# 807
template< class _Iter> 
# 808
__normal_iterator(const __normal_iterator< _Iter, typename __enable_if< std::__are_same< _Iter, typename _Container::pointer> ::__value, _Container> ::__type>  &
# 811
__i) noexcept : _M_current(__i.base()) 
# 812
{ } 
# 816
reference operator*() const noexcept 
# 817
{ return *(_M_current); } 
# 820
pointer operator->() const noexcept 
# 821
{ return _M_current; } 
# 824
__normal_iterator &operator++() noexcept 
# 825
{ 
# 826
++(_M_current); 
# 827
return *this; 
# 828
} 
# 831
__normal_iterator operator++(int) noexcept 
# 832
{ return ((__normal_iterator)((_M_current)++)); } 
# 836
__normal_iterator &operator--() noexcept 
# 837
{ 
# 838
--(_M_current); 
# 839
return *this; 
# 840
} 
# 843
__normal_iterator operator--(int) noexcept 
# 844
{ return ((__normal_iterator)((_M_current)--)); } 
# 848
reference operator[](difference_type __n) const noexcept 
# 849
{ return (_M_current)[__n]; } 
# 852
__normal_iterator &operator+=(difference_type __n) noexcept 
# 853
{ (_M_current) += __n; return *this; } 
# 856
__normal_iterator operator+(difference_type __n) const noexcept 
# 857
{ return ((__normal_iterator)((_M_current) + __n)); } 
# 860
__normal_iterator &operator-=(difference_type __n) noexcept 
# 861
{ (_M_current) -= __n; return *this; } 
# 864
__normal_iterator operator-(difference_type __n) const noexcept 
# 865
{ return ((__normal_iterator)((_M_current) - __n)); } 
# 868
const _Iterator &base() const noexcept 
# 869
{ return _M_current; } 
# 870
}; 
# 881 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 883
operator==(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 884
__rhs) noexcept 
# 886
{ return __lhs.base() == __rhs.base(); } 
# 888
template< class _Iterator, class _Container> inline bool 
# 890
operator==(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 891
__rhs) noexcept 
# 893
{ return __lhs.base() == __rhs.base(); } 
# 895
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 897
operator!=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 898
__rhs) noexcept 
# 900
{ return __lhs.base() != __rhs.base(); } 
# 902
template< class _Iterator, class _Container> inline bool 
# 904
operator!=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 905
__rhs) noexcept 
# 907
{ return __lhs.base() != __rhs.base(); } 
# 910
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 912
operator<(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 913
__rhs) noexcept 
# 915
{ return __lhs.base() < __rhs.base(); } 
# 917
template< class _Iterator, class _Container> inline bool 
# 919
operator<(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 920
__rhs) noexcept 
# 922
{ return __lhs.base() < __rhs.base(); } 
# 924
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 926
operator>(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 927
__rhs) noexcept 
# 929
{ return __lhs.base() > __rhs.base(); } 
# 931
template< class _Iterator, class _Container> inline bool 
# 933
operator>(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 934
__rhs) noexcept 
# 936
{ return __lhs.base() > __rhs.base(); } 
# 938
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 940
operator<=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 941
__rhs) noexcept 
# 943
{ return __lhs.base() <= __rhs.base(); } 
# 945
template< class _Iterator, class _Container> inline bool 
# 947
operator<=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 948
__rhs) noexcept 
# 950
{ return __lhs.base() <= __rhs.base(); } 
# 952
template< class _IteratorL, class _IteratorR, class _Container> inline bool 
# 954
operator>=(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 955
__rhs) noexcept 
# 957
{ return __lhs.base() >= __rhs.base(); } 
# 959
template< class _Iterator, class _Container> inline bool 
# 961
operator>=(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 962
__rhs) noexcept 
# 964
{ return __lhs.base() >= __rhs.base(); } 
# 970
template< class _IteratorL, class _IteratorR, class _Container> inline auto 
# 974
operator-(const __normal_iterator< _IteratorL, _Container>  &__lhs, const __normal_iterator< _IteratorR, _Container>  &
# 975
__rhs) noexcept->__decltype((__lhs.base() - __rhs.base())) 
# 982
{ return __lhs.base() - __rhs.base(); } 
# 984
template< class _Iterator, class _Container> inline typename __normal_iterator< _Iterator, _Container> ::difference_type 
# 986
operator-(const __normal_iterator< _Iterator, _Container>  &__lhs, const __normal_iterator< _Iterator, _Container>  &
# 987
__rhs) noexcept 
# 989
{ return __lhs.base() - __rhs.base(); } 
# 991
template< class _Iterator, class _Container> inline __normal_iterator< _Iterator, _Container>  
# 993
operator+(typename __normal_iterator< _Iterator, _Container> ::difference_type 
# 994
__n, const __normal_iterator< _Iterator, _Container>  &__i) noexcept 
# 996
{ return ((__normal_iterator< _Iterator, _Container> )(__i.base() + __n)); } 
# 999
}
# 1001
namespace std __attribute((__visibility__("default"))) { 
# 1005
template< class _Iterator, class _Container> _Iterator 
# 1007
__niter_base(__gnu_cxx::__normal_iterator< _Iterator, _Container>  __it) noexcept(std::template is_nothrow_copy_constructible< _Iterator> ::value) 
# 1009
{ return __it.base(); } 
# 1027 "/usr/include/c++/9/bits/stl_iterator.h" 3
template< class _Iterator> 
# 1028
class move_iterator { 
# 1031
protected: _Iterator _M_current; 
# 1033
typedef iterator_traits< _Iterator>  __traits_type; 
# 1034
typedef typename iterator_traits< _Iterator> ::reference __base_ref; 
# 1037
public: typedef _Iterator iterator_type; 
# 1038
typedef typename iterator_traits< _Iterator> ::iterator_category iterator_category; 
# 1039
typedef typename iterator_traits< _Iterator> ::value_type value_type; 
# 1040
typedef typename iterator_traits< _Iterator> ::difference_type difference_type; 
# 1042
typedef _Iterator pointer; 
# 1047
typedef typename conditional< is_reference< __base_ref> ::value, typename remove_reference< __base_ref> ::type &&, __base_ref> ::type reference; 
# 1050
move_iterator() : _M_current() 
# 1051
{ } 
# 1054
explicit move_iterator(iterator_type __i) : _M_current(__i) 
# 1055
{ } 
# 1057
template< class _Iter> 
# 1059
move_iterator(const move_iterator< _Iter>  &__i) : _M_current(__i.base()) 
# 1060
{ } 
# 1063
iterator_type base() const 
# 1064
{ return _M_current; } 
# 1067
reference operator*() const 
# 1068
{ return static_cast< reference>(*(_M_current)); } 
# 1071
pointer operator->() const 
# 1072
{ return _M_current; } 
# 1075
move_iterator &operator++() 
# 1076
{ 
# 1077
++(_M_current); 
# 1078
return *this; 
# 1079
} 
# 1082
move_iterator operator++(int) 
# 1083
{ 
# 1084
move_iterator __tmp = *this; 
# 1085
++(_M_current); 
# 1086
return __tmp; 
# 1087
} 
# 1090
move_iterator &operator--() 
# 1091
{ 
# 1092
--(_M_current); 
# 1093
return *this; 
# 1094
} 
# 1097
move_iterator operator--(int) 
# 1098
{ 
# 1099
move_iterator __tmp = *this; 
# 1100
--(_M_current); 
# 1101
return __tmp; 
# 1102
} 
# 1105
move_iterator operator+(difference_type __n) const 
# 1106
{ return ((move_iterator)((_M_current) + __n)); } 
# 1109
move_iterator &operator+=(difference_type __n) 
# 1110
{ 
# 1111
(_M_current) += __n; 
# 1112
return *this; 
# 1113
} 
# 1116
move_iterator operator-(difference_type __n) const 
# 1117
{ return ((move_iterator)((_M_current) - __n)); } 
# 1120
move_iterator &operator-=(difference_type __n) 
# 1121
{ 
# 1122
(_M_current) -= __n; 
# 1123
return *this; 
# 1124
} 
# 1127
reference operator[](difference_type __n) const 
# 1128
{ return std::move((_M_current)[__n]); } 
# 1129
}; 
# 1134
template< class _IteratorL, class _IteratorR> inline bool 
# 1136
operator==(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1137
__y) 
# 1138
{ return __x.base() == __y.base(); } 
# 1140
template< class _Iterator> inline bool 
# 1142
operator==(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1143
__y) 
# 1144
{ return __x.base() == __y.base(); } 
# 1146
template< class _IteratorL, class _IteratorR> inline bool 
# 1148
operator!=(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1149
__y) 
# 1150
{ return !(__x == __y); } 
# 1152
template< class _Iterator> inline bool 
# 1154
operator!=(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1155
__y) 
# 1156
{ return !(__x == __y); } 
# 1158
template< class _IteratorL, class _IteratorR> inline bool 
# 1160
operator<(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1161
__y) 
# 1162
{ return __x.base() < __y.base(); } 
# 1164
template< class _Iterator> inline bool 
# 1166
operator<(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1167
__y) 
# 1168
{ return __x.base() < __y.base(); } 
# 1170
template< class _IteratorL, class _IteratorR> inline bool 
# 1172
operator<=(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1173
__y) 
# 1174
{ return !(__y < __x); } 
# 1176
template< class _Iterator> inline bool 
# 1178
operator<=(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1179
__y) 
# 1180
{ return !(__y < __x); } 
# 1182
template< class _IteratorL, class _IteratorR> inline bool 
# 1184
operator>(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1185
__y) 
# 1186
{ return __y < __x; } 
# 1188
template< class _Iterator> inline bool 
# 1190
operator>(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1191
__y) 
# 1192
{ return __y < __x; } 
# 1194
template< class _IteratorL, class _IteratorR> inline bool 
# 1196
operator>=(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1197
__y) 
# 1198
{ return !(__x < __y); } 
# 1200
template< class _Iterator> inline bool 
# 1202
operator>=(const move_iterator< _Iterator>  &__x, const move_iterator< _Iterator>  &
# 1203
__y) 
# 1204
{ return !(__x < __y); } 
# 1207
template< class _IteratorL, class _IteratorR> inline auto 
# 1209
operator-(const move_iterator< _IteratorL>  &__x, const move_iterator< _IteratorR>  &
# 1210
__y)->__decltype((__x.base() - __y.base())) 
# 1212
{ return __x.base() - __y.base(); } 
# 1214
template< class _Iterator> inline move_iterator< _Iterator>  
# 1216
operator+(typename move_iterator< _Iterator> ::difference_type __n, const move_iterator< _Iterator>  &
# 1217
__x) 
# 1218
{ return __x + __n; } 
# 1220
template< class _Iterator> inline move_iterator< _Iterator>  
# 1222
make_move_iterator(_Iterator __i) 
# 1223
{ return ((move_iterator< _Iterator> )(__i)); } 
# 1225
template< class _Iterator, class _ReturnType = typename conditional< __move_if_noexcept_cond< typename iterator_traits< _Iterator> ::value_type> ::value, _Iterator, move_iterator< _Iterator> > ::type> inline _ReturnType 
# 1230
__make_move_if_noexcept_iterator(_Iterator __i) 
# 1231
{ return (_ReturnType)__i; } 
# 1235
template< class _Tp, class _ReturnType = typename conditional< __move_if_noexcept_cond< _Tp> ::value, const _Tp *, move_iterator< _Tp *> > ::type> inline _ReturnType 
# 1239
__make_move_if_noexcept_iterator(_Tp *__i) 
# 1240
{ return (_ReturnType)__i; } 
# 1244
template< class _Iterator> auto 
# 1246
__niter_base(move_iterator< _Iterator>  __it)->__decltype((make_move_iterator(__niter_base(__it.base())))) 
# 1248
{ return make_move_iterator(__niter_base(__it.base())); } 
# 1250
template< class _Iterator> 
# 1251
struct __is_move_iterator< move_iterator< _Iterator> >  { 
# 1253
enum { __value = 1}; 
# 1254
typedef __true_type __type; 
# 1255
}; 
# 1257
template< class _Iterator> auto 
# 1259
__miter_base(move_iterator< _Iterator>  __it)->__decltype((__miter_base(__it.base()))) 
# 1261
{ return __miter_base(__it.base()); } 
# 1293 "/usr/include/c++/9/bits/stl_iterator.h" 3
}
# 48 "/usr/include/c++/9/debug/debug.h" 3
namespace std { 
# 50
namespace __debug { }
# 51
}
# 56
namespace __gnu_debug { 
# 58
using namespace std::__debug;
# 59
}
# 33 "/usr/include/c++/9/bits/predefined_ops.h" 3
namespace __gnu_cxx { 
# 35
namespace __ops { 
# 37
struct _Iter_less_iter { 
# 39
template< class _Iterator1, class _Iterator2> constexpr bool 
# 42
operator()(_Iterator1 __it1, _Iterator2 __it2) const 
# 43
{ return (*__it1) < (*__it2); } 
# 44
}; 
# 48
constexpr _Iter_less_iter __iter_less_iter() 
# 49
{ return _Iter_less_iter(); } 
# 51
struct _Iter_less_val { 
# 54
constexpr _Iter_less_val() = default;
# 60
explicit _Iter_less_val(_Iter_less_iter) { } 
# 62
template< class _Iterator, class _Value> bool 
# 64
operator()(_Iterator __it, _Value &__val) const 
# 65
{ return (*__it) < __val; } 
# 66
}; 
# 69
inline _Iter_less_val __iter_less_val() 
# 70
{ return _Iter_less_val(); } 
# 73
inline _Iter_less_val __iter_comp_val(_Iter_less_iter) 
# 74
{ return _Iter_less_val(); } 
# 76
struct _Val_less_iter { 
# 79
constexpr _Val_less_iter() = default;
# 85
explicit _Val_less_iter(_Iter_less_iter) { } 
# 87
template< class _Value, class _Iterator> bool 
# 89
operator()(_Value &__val, _Iterator __it) const 
# 90
{ return __val < (*__it); } 
# 91
}; 
# 94
inline _Val_less_iter __val_less_iter() 
# 95
{ return _Val_less_iter(); } 
# 98
inline _Val_less_iter __val_comp_iter(_Iter_less_iter) 
# 99
{ return _Val_less_iter(); } 
# 101
struct _Iter_equal_to_iter { 
# 103
template< class _Iterator1, class _Iterator2> bool 
# 105
operator()(_Iterator1 __it1, _Iterator2 __it2) const 
# 106
{ return (*__it1) == (*__it2); } 
# 107
}; 
# 110
inline _Iter_equal_to_iter __iter_equal_to_iter() 
# 111
{ return _Iter_equal_to_iter(); } 
# 113
struct _Iter_equal_to_val { 
# 115
template< class _Iterator, class _Value> bool 
# 117
operator()(_Iterator __it, _Value &__val) const 
# 118
{ return (*__it) == __val; } 
# 119
}; 
# 122
inline _Iter_equal_to_val __iter_equal_to_val() 
# 123
{ return _Iter_equal_to_val(); } 
# 126
inline _Iter_equal_to_val __iter_comp_val(_Iter_equal_to_iter) 
# 127
{ return _Iter_equal_to_val(); } 
# 129
template< class _Compare> 
# 130
struct _Iter_comp_iter { 
# 132
_Compare _M_comp; 
# 135
constexpr explicit _Iter_comp_iter(_Compare __comp) : _M_comp(std::move(__comp)) 
# 137
{ } 
# 139
template< class _Iterator1, class _Iterator2> constexpr bool 
# 142
operator()(_Iterator1 __it1, _Iterator2 __it2) 
# 143
{ return (bool)(_M_comp)(*__it1, *__it2); } 
# 144
}; 
# 146
template< class _Compare> constexpr _Iter_comp_iter< _Compare>  
# 149
__iter_comp_iter(_Compare __comp) 
# 150
{ return ((_Iter_comp_iter< _Compare> )(std::move(__comp))); } 
# 152
template< class _Compare> 
# 153
struct _Iter_comp_val { 
# 155
_Compare _M_comp; 
# 158
explicit _Iter_comp_val(_Compare __comp) : _M_comp(std::move(__comp)) 
# 160
{ } 
# 163
explicit _Iter_comp_val(const _Iter_comp_iter< _Compare>  &__comp) : _M_comp((__comp._M_comp)) 
# 165
{ } 
# 169
explicit _Iter_comp_val(_Iter_comp_iter< _Compare>  &&__comp) : _M_comp(std::move((__comp._M_comp))) 
# 171
{ } 
# 174
template< class _Iterator, class _Value> bool 
# 176
operator()(_Iterator __it, _Value &__val) 
# 177
{ return (bool)(_M_comp)(*__it, __val); } 
# 178
}; 
# 180
template< class _Compare> inline _Iter_comp_val< _Compare>  
# 182
__iter_comp_val(_Compare __comp) 
# 183
{ return ((_Iter_comp_val< _Compare> )(std::move(__comp))); } 
# 185
template< class _Compare> inline _Iter_comp_val< _Compare>  
# 187
__iter_comp_val(_Iter_comp_iter< _Compare>  __comp) 
# 188
{ return ((_Iter_comp_val< _Compare> )(std::move(__comp))); } 
# 190
template< class _Compare> 
# 191
struct _Val_comp_iter { 
# 193
_Compare _M_comp; 
# 196
explicit _Val_comp_iter(_Compare __comp) : _M_comp(std::move(__comp)) 
# 198
{ } 
# 201
explicit _Val_comp_iter(const _Iter_comp_iter< _Compare>  &__comp) : _M_comp((__comp._M_comp)) 
# 203
{ } 
# 207
explicit _Val_comp_iter(_Iter_comp_iter< _Compare>  &&__comp) : _M_comp(std::move((__comp._M_comp))) 
# 209
{ } 
# 212
template< class _Value, class _Iterator> bool 
# 214
operator()(_Value &__val, _Iterator __it) 
# 215
{ return (bool)(_M_comp)(__val, *__it); } 
# 216
}; 
# 218
template< class _Compare> inline _Val_comp_iter< _Compare>  
# 220
__val_comp_iter(_Compare __comp) 
# 221
{ return ((_Val_comp_iter< _Compare> )(std::move(__comp))); } 
# 223
template< class _Compare> inline _Val_comp_iter< _Compare>  
# 225
__val_comp_iter(_Iter_comp_iter< _Compare>  __comp) 
# 226
{ return ((_Val_comp_iter< _Compare> )(std::move(__comp))); } 
# 228
template< class _Value> 
# 229
struct _Iter_equals_val { 
# 231
_Value &_M_value; 
# 234
explicit _Iter_equals_val(_Value &__value) : _M_value(__value) 
# 236
{ } 
# 238
template< class _Iterator> bool 
# 240
operator()(_Iterator __it) 
# 241
{ return (*__it) == (_M_value); } 
# 242
}; 
# 244
template< class _Value> inline _Iter_equals_val< _Value>  
# 246
__iter_equals_val(_Value &__val) 
# 247
{ return ((_Iter_equals_val< _Value> )(__val)); } 
# 249
template< class _Iterator1> 
# 250
struct _Iter_equals_iter { 
# 252
_Iterator1 _M_it1; 
# 255
explicit _Iter_equals_iter(_Iterator1 __it1) : _M_it1(__it1) 
# 257
{ } 
# 259
template< class _Iterator2> bool 
# 261
operator()(_Iterator2 __it2) 
# 262
{ return (*__it2) == (*(_M_it1)); } 
# 263
}; 
# 265
template< class _Iterator> inline _Iter_equals_iter< _Iterator>  
# 267
__iter_comp_iter(_Iter_equal_to_iter, _Iterator __it) 
# 268
{ return ((_Iter_equals_iter< _Iterator> )(__it)); } 
# 270
template< class _Predicate> 
# 271
struct _Iter_pred { 
# 273
_Predicate _M_pred; 
# 276
explicit _Iter_pred(_Predicate __pred) : _M_pred(std::move(__pred)) 
# 278
{ } 
# 280
template< class _Iterator> bool 
# 282
operator()(_Iterator __it) 
# 283
{ return (bool)(_M_pred)(*__it); } 
# 284
}; 
# 286
template< class _Predicate> inline _Iter_pred< _Predicate>  
# 288
__pred_iter(_Predicate __pred) 
# 289
{ return ((_Iter_pred< _Predicate> )(std::move(__pred))); } 
# 291
template< class _Compare, class _Value> 
# 292
struct _Iter_comp_to_val { 
# 294
_Compare _M_comp; 
# 295
_Value &_M_value; 
# 297
_Iter_comp_to_val(_Compare __comp, _Value &__value) : _M_comp(std::move(__comp)), _M_value(__value) 
# 299
{ } 
# 301
template< class _Iterator> bool 
# 303
operator()(_Iterator __it) 
# 304
{ return (bool)(_M_comp)(*__it, _M_value); } 
# 305
}; 
# 307
template< class _Compare, class _Value> _Iter_comp_to_val< _Compare, _Value>  
# 309
__iter_comp_val(_Compare __comp, _Value &__val) 
# 310
{ 
# 311
return _Iter_comp_to_val< _Compare, _Value> (std::move(__comp), __val); 
# 312
} 
# 314
template< class _Compare, class _Iterator1> 
# 315
struct _Iter_comp_to_iter { 
# 317
_Compare _M_comp; 
# 318
_Iterator1 _M_it1; 
# 320
_Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1) : _M_comp(std::move(__comp)), _M_it1(__it1) 
# 322
{ } 
# 324
template< class _Iterator2> bool 
# 326
operator()(_Iterator2 __it2) 
# 327
{ return (bool)(_M_comp)(*__it2, *(_M_it1)); } 
# 328
}; 
# 330
template< class _Compare, class _Iterator> inline _Iter_comp_to_iter< _Compare, _Iterator>  
# 332
__iter_comp_iter(_Iter_comp_iter< _Compare>  __comp, _Iterator __it) 
# 333
{ 
# 334
return _Iter_comp_to_iter< _Compare, _Iterator> (std::move((__comp._M_comp)), __it); 
# 336
} 
# 338
template< class _Predicate> 
# 339
struct _Iter_negate { 
# 341
_Predicate _M_pred; 
# 344
explicit _Iter_negate(_Predicate __pred) : _M_pred(std::move(__pred)) 
# 346
{ } 
# 348
template< class _Iterator> bool 
# 350
operator()(_Iterator __it) 
# 351
{ return !((bool)(_M_pred)(*__it)); } 
# 352
}; 
# 354
template< class _Predicate> inline _Iter_negate< _Predicate>  
# 356
__negate(_Iter_pred< _Predicate>  __pred) 
# 357
{ return ((_Iter_negate< _Predicate> )(std::move((__pred._M_pred)))); } 
# 359
}
# 360
}
# 76 "/usr/include/c++/9/bits/stl_algobase.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 121 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline void 
# 123
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b) 
# 124
{ 
# 151 "/usr/include/c++/9/bits/stl_algobase.h" 3
swap(*__a, *__b); 
# 153
} 
# 167 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> _ForwardIterator2 
# 169
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 170
__first2) 
# 171
{ 
# 177
; 
# 179
for (; __first1 != __last1; (++__first1), ((void)(++__first2))) { 
# 180
std::iter_swap(__first1, __first2); }  
# 181
return __first2; 
# 182
} 
# 195 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _Tp> constexpr const _Tp &
# 198
min(const _Tp &__a, const _Tp &__b) 
# 199
{ 
# 203
if (__b < __a) { 
# 204
return __b; }  
# 205
return __a; 
# 206
} 
# 219 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _Tp> constexpr const _Tp &
# 222
max(const _Tp &__a, const _Tp &__b) 
# 223
{ 
# 227
if (__a < __b) { 
# 228
return __b; }  
# 229
return __a; 
# 230
} 
# 243 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _Tp, class _Compare> constexpr const _Tp &
# 246
min(const _Tp &__a, const _Tp &__b, _Compare __comp) 
# 247
{ 
# 249
if (__comp(__b, __a)) { 
# 250
return __b; }  
# 251
return __a; 
# 252
} 
# 265 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _Tp, class _Compare> constexpr const _Tp &
# 268
max(const _Tp &__a, const _Tp &__b, _Compare __comp) 
# 269
{ 
# 271
if (__comp(__a, __b)) { 
# 272
return __b; }  
# 273
return __a; 
# 274
} 
# 278
template< class _Iterator> inline _Iterator 
# 280
__niter_base(_Iterator __it) noexcept(std::template is_nothrow_copy_constructible< _Iterator> ::value) 
# 282
{ return __it; } 
# 287
template< class _From, class _To> inline _From 
# 289
__niter_wrap(_From __from, _To __res) 
# 290
{ return __from + (__res - std::__niter_base(__from)); } 
# 293
template< class _Iterator> inline _Iterator 
# 295
__niter_wrap(const _Iterator &, _Iterator __res) 
# 296
{ return __res; } 
# 304
template< bool _IsMove, bool _IsSimple, class _Category> 
# 305
struct __copy_move { 
# 307
template< class _II, class _OI> static _OI 
# 309
__copy_m(_II __first, _II __last, _OI __result) 
# 310
{ 
# 311
for (; __first != __last; (++__result), ((void)(++__first))) { 
# 312
(*__result) = (*__first); }  
# 313
return __result; 
# 314
} 
# 315
}; 
# 318
template< class _Category> 
# 319
struct __copy_move< true, false, _Category>  { 
# 321
template< class _II, class _OI> static _OI 
# 323
__copy_m(_II __first, _II __last, _OI __result) 
# 324
{ 
# 325
for (; __first != __last; (++__result), ((void)(++__first))) { 
# 326
(*__result) = std::move(*__first); }  
# 327
return __result; 
# 328
} 
# 329
}; 
# 333
template<> struct __copy_move< false, false, random_access_iterator_tag>  { 
# 335
template< class _II, class _OI> static _OI 
# 337
__copy_m(_II __first, _II __last, _OI __result) 
# 338
{ 
# 339
typedef typename iterator_traits< _II> ::difference_type _Distance; 
# 340
for (_Distance __n = __last - __first; __n > 0; --__n) 
# 341
{ 
# 342
(*__result) = (*__first); 
# 343
++__first; 
# 344
++__result; 
# 345
}  
# 346
return __result; 
# 347
} 
# 348
}; 
# 352
template<> struct __copy_move< true, false, random_access_iterator_tag>  { 
# 354
template< class _II, class _OI> static _OI 
# 356
__copy_m(_II __first, _II __last, _OI __result) 
# 357
{ 
# 358
typedef typename iterator_traits< _II> ::difference_type _Distance; 
# 359
for (_Distance __n = __last - __first; __n > 0; --__n) 
# 360
{ 
# 361
(*__result) = std::move(*__first); 
# 362
++__first; 
# 363
++__result; 
# 364
}  
# 365
return __result; 
# 366
} 
# 367
}; 
# 370
template< bool _IsMove> 
# 371
struct __copy_move< _IsMove, true, random_access_iterator_tag>  { 
# 373
template< class _Tp> static _Tp *
# 375
__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result) 
# 376
{ 
# 378
using __assignable = conditional< _IsMove, is_move_assignable< _Tp> , is_copy_assignable< _Tp> > ; 
# 382
static_assert((__assignable::type::value), "type is not assignable");
# 384
const ptrdiff_t _Num = __last - __first; 
# 385
if (_Num) { 
# 386
__builtin_memmove(__result, __first, sizeof(_Tp) * _Num); }  
# 387
return __result + _Num; 
# 388
} 
# 389
}; 
# 391
template< bool _IsMove, class _II, class _OI> inline _OI 
# 393
__copy_move_a(_II __first, _II __last, _OI __result) 
# 394
{ 
# 395
typedef typename iterator_traits< _II> ::value_type _ValueTypeI; 
# 396
typedef typename iterator_traits< _OI> ::value_type _ValueTypeO; 
# 397
typedef typename iterator_traits< _II> ::iterator_category _Category; 
# 398
const bool __simple = (__is_trivially_copyable(_ValueTypeI) && __is_pointer< _II> ::__value && __is_pointer< _OI> ::__value && __are_same< typename iterator_traits< _II> ::value_type, typename iterator_traits< _OI> ::value_type> ::__value); 
# 403
return std::template __copy_move< _IsMove, __simple, typename iterator_traits< _II> ::iterator_category> ::__copy_m(__first, __last, __result); 
# 405
} 
# 409
template< class _CharT> struct char_traits; 
# 412
template< class _CharT, class _Traits> class istreambuf_iterator; 
# 415
template< class _CharT, class _Traits> class ostreambuf_iterator; 
# 418
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator< _CharT, char_traits< _CharT> > ); 
# 424
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT, char_traits< _CharT> > > ::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator< _CharT, char_traits< _CharT> > ); 
# 430
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, _CharT *> ::__type __copy_move_a2(istreambuf_iterator< _CharT> , istreambuf_iterator< _CharT> , _CharT *); 
# 436
template< bool _IsMove, class _II, class _OI> inline _OI 
# 438
__copy_move_a2(_II __first, _II __last, _OI __result) 
# 439
{ 
# 440
return std::__niter_wrap(__result, std::__copy_move_a< _IsMove> (std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result))); 
# 444
} 
# 463 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _II, class _OI> inline _OI 
# 465
copy(_II __first, _II __last, _OI __result) 
# 466
{ 
# 471
; 
# 473
return std::__copy_move_a2< __is_move_iterator< _II> ::__value> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 475
} 
# 495 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _II, class _OI> inline _OI 
# 497
move(_II __first, _II __last, _OI __result) 
# 498
{ 
# 503
; 
# 505
return std::__copy_move_a2< true> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 507
} 
# 514
template< bool , bool , class > 
# 515
struct __copy_move_backward { 
# 517
template< class _BI1, class _BI2> static _BI2 
# 519
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 520
{ 
# 521
while (__first != __last) { 
# 522
(*(--__result)) = (*(--__last)); }  
# 523
return __result; 
# 524
} 
# 525
}; 
# 528
template< class _Category> 
# 529
struct __copy_move_backward< true, false, _Category>  { 
# 531
template< class _BI1, class _BI2> static _BI2 
# 533
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 534
{ 
# 535
while (__first != __last) { 
# 536
(*(--__result)) = std::move(*(--__last)); }  
# 537
return __result; 
# 538
} 
# 539
}; 
# 543
template<> struct __copy_move_backward< false, false, random_access_iterator_tag>  { 
# 545
template< class _BI1, class _BI2> static _BI2 
# 547
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 548
{ 
# 549
typename iterator_traits< _BI1> ::difference_type __n; 
# 550
for (__n = (__last - __first); __n > 0; --__n) { 
# 551
(*(--__result)) = (*(--__last)); }  
# 552
return __result; 
# 553
} 
# 554
}; 
# 558
template<> struct __copy_move_backward< true, false, random_access_iterator_tag>  { 
# 560
template< class _BI1, class _BI2> static _BI2 
# 562
__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result) 
# 563
{ 
# 564
typename iterator_traits< _BI1> ::difference_type __n; 
# 565
for (__n = (__last - __first); __n > 0; --__n) { 
# 566
(*(--__result)) = std::move(*(--__last)); }  
# 567
return __result; 
# 568
} 
# 569
}; 
# 572
template< bool _IsMove> 
# 573
struct __copy_move_backward< _IsMove, true, random_access_iterator_tag>  { 
# 575
template< class _Tp> static _Tp *
# 577
__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result) 
# 578
{ 
# 580
using __assignable = conditional< _IsMove, is_move_assignable< _Tp> , is_copy_assignable< _Tp> > ; 
# 584
static_assert((__assignable::type::value), "type is not assignable");
# 586
const ptrdiff_t _Num = __last - __first; 
# 587
if (_Num) { 
# 588
__builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num); }  
# 589
return __result - _Num; 
# 590
} 
# 591
}; 
# 593
template< bool _IsMove, class _BI1, class _BI2> inline _BI2 
# 595
__copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result) 
# 596
{ 
# 597
typedef typename iterator_traits< _BI1> ::value_type _ValueType1; 
# 598
typedef typename iterator_traits< _BI2> ::value_type _ValueType2; 
# 599
typedef typename iterator_traits< _BI1> ::iterator_category _Category; 
# 600
const bool __simple = (__is_trivially_copyable(_ValueType1) && __is_pointer< _BI1> ::__value && __is_pointer< _BI2> ::__value && __are_same< typename iterator_traits< _BI1> ::value_type, typename iterator_traits< _BI2> ::value_type> ::__value); 
# 605
return std::template __copy_move_backward< _IsMove, __simple, typename iterator_traits< _BI1> ::iterator_category> ::__copy_move_b(__first, __last, __result); 
# 609
} 
# 611
template< bool _IsMove, class _BI1, class _BI2> inline _BI2 
# 613
__copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result) 
# 614
{ 
# 615
return std::__niter_wrap(__result, std::__copy_move_backward_a< _IsMove> (std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result))); 
# 619
} 
# 639 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _BI1, class _BI2> inline _BI2 
# 641
copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) 
# 642
{ 
# 649
; 
# 651
return std::__copy_move_backward_a2< __is_move_iterator< _BI1> ::__value> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 653
} 
# 674 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _BI1, class _BI2> inline _BI2 
# 676
move_backward(_BI1 __first, _BI1 __last, _BI2 __result) 
# 677
{ 
# 684
; 
# 686
return std::__copy_move_backward_a2< true> (std::__miter_base(__first), std::__miter_base(__last), __result); 
# 689
} 
# 696
template< class _ForwardIterator, class _Tp> inline typename __gnu_cxx::__enable_if< !__is_scalar< _Tp> ::__value, void> ::__type 
# 699
__fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 700
__value) 
# 701
{ 
# 702
for (; __first != __last; ++__first) { 
# 703
(*__first) = __value; }  
# 704
} 
# 706
template< class _ForwardIterator, class _Tp> inline typename __gnu_cxx::__enable_if< __is_scalar< _Tp> ::__value, void> ::__type 
# 709
__fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 710
__value) 
# 711
{ 
# 712
const _Tp __tmp = __value; 
# 713
for (; __first != __last; ++__first) { 
# 714
(*__first) = __tmp; }  
# 715
} 
# 718
template< class _Tp> inline typename __gnu_cxx::__enable_if< __is_byte< _Tp> ::__value, void> ::__type 
# 721
__fill_a(_Tp *__first, _Tp *__last, const _Tp &__c) 
# 722
{ 
# 723
const _Tp __tmp = __c; 
# 724
if (const size_t __len = __last - __first) { 
# 725
__builtin_memset(__first, static_cast< unsigned char>(__tmp), __len); }  
# 726
} 
# 740 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _ForwardIterator, class _Tp> inline void 
# 742
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value) 
# 743
{ 
# 747
; 
# 749
std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value); 
# 751
} 
# 753
template< class _OutputIterator, class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< !__is_scalar< _Tp> ::__value, _OutputIterator> ::__type 
# 756
__fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value) 
# 757
{ 
# 758
for (__decltype((__n + 0)) __niter = __n; __niter > 0; (--__niter), ((void)(++__first))) { 
# 760
(*__first) = __value; }  
# 761
return __first; 
# 762
} 
# 764
template< class _OutputIterator, class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< __is_scalar< _Tp> ::__value, _OutputIterator> ::__type 
# 767
__fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value) 
# 768
{ 
# 769
const _Tp __tmp = __value; 
# 770
for (__decltype((__n + 0)) __niter = __n; __niter > 0; (--__niter), ((void)(++__first))) { 
# 772
(*__first) = __tmp; }  
# 773
return __first; 
# 774
} 
# 776
template< class _Size, class _Tp> inline typename __gnu_cxx::__enable_if< __is_byte< _Tp> ::__value, _Tp *> ::__type 
# 779
__fill_n_a(_Tp *__first, _Size __n, const _Tp &__c) 
# 780
{ 
# 781
std::__fill_a(__first, __first + __n, __c); 
# 782
return __first + __n; 
# 783
} 
# 800 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _OI, class _Size, class _Tp> inline _OI 
# 802
fill_n(_OI __first, _Size __n, const _Tp &__value) 
# 803
{ 
# 806
; 
# 808
return std::__niter_wrap(__first, std::__fill_n_a(std::__niter_base(__first), __n, __value)); 
# 810
} 
# 812
template< bool _BoolType> 
# 813
struct __equal { 
# 815
template< class _II1, class _II2> static bool 
# 817
equal(_II1 __first1, _II1 __last1, _II2 __first2) 
# 818
{ 
# 819
for (; __first1 != __last1; (++__first1), ((void)(++__first2))) { 
# 820
if (!((*__first1) == (*__first2))) { 
# 821
return false; }  }  
# 822
return true; 
# 823
} 
# 824
}; 
# 827
template<> struct __equal< true>  { 
# 829
template< class _Tp> static bool 
# 831
equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2) 
# 832
{ 
# 833
if (const size_t __len = __last1 - __first1) { 
# 834
return !(__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len)); }  
# 835
return true; 
# 836
} 
# 837
}; 
# 839
template< class _II1, class _II2> inline bool 
# 841
__equal_aux(_II1 __first1, _II1 __last1, _II2 __first2) 
# 842
{ 
# 843
typedef typename iterator_traits< _II1> ::value_type _ValueType1; 
# 844
typedef typename iterator_traits< _II2> ::value_type _ValueType2; 
# 845
const bool __simple = ((__is_integer< typename iterator_traits< _II1> ::value_type> ::__value || __is_pointer< typename iterator_traits< _II1> ::value_type> ::__value) && __is_pointer< _II1> ::__value && __is_pointer< _II2> ::__value && __are_same< typename iterator_traits< _II1> ::value_type, typename iterator_traits< _II2> ::value_type> ::__value); 
# 851
return std::template __equal< __simple> ::equal(__first1, __last1, __first2); 
# 852
} 
# 854
template< class , class > 
# 855
struct __lc_rai { 
# 857
template< class _II1, class _II2> static _II1 
# 859
__newlast1(_II1, _II1 __last1, _II2, _II2) 
# 860
{ return __last1; } 
# 862
template< class _II> static bool 
# 864
__cnd2(_II __first, _II __last) 
# 865
{ return __first != __last; } 
# 866
}; 
# 869
template<> struct __lc_rai< random_access_iterator_tag, random_access_iterator_tag>  { 
# 871
template< class _RAI1, class _RAI2> static _RAI1 
# 873
__newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 
# 874
__first2, _RAI2 __last2) 
# 875
{ 
# 877
const typename iterator_traits< _RAI1> ::difference_type __diff1 = __last1 - __first1; 
# 879
const typename iterator_traits< _RAI2> ::difference_type __diff2 = __last2 - __first2; 
# 880
return (__diff2 < __diff1) ? __first1 + __diff2 : __last1; 
# 881
} 
# 883
template< class _RAI> static bool 
# 885
__cnd2(_RAI, _RAI) 
# 886
{ return true; } 
# 887
}; 
# 889
template< class _II1, class _II2, class _Compare> bool 
# 891
__lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 
# 892
__first2, _II2 __last2, _Compare 
# 893
__comp) 
# 894
{ 
# 895
typedef typename iterator_traits< _II1> ::iterator_category _Category1; 
# 896
typedef typename iterator_traits< _II2> ::iterator_category _Category2; 
# 897
typedef __lc_rai< typename iterator_traits< _II1> ::iterator_category, typename iterator_traits< _II2> ::iterator_category>  __rai_type; 
# 899
__last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2); 
# 900
for (; (__first1 != __last1) && __rai_type::__cnd2(__first2, __last2); (++__first1), ((void)(++__first2))) 
# 902
{ 
# 903
if (__comp(__first1, __first2)) { 
# 904
return true; }  
# 905
if (__comp(__first2, __first1)) { 
# 906
return false; }  
# 907
}  
# 908
return (__first1 == __last1) && (__first2 != __last2); 
# 909
} 
# 911
template< bool _BoolType> 
# 912
struct __lexicographical_compare { 
# 914
template< class _II1, class _II2> static bool __lc(_II1, _II1, _II2, _II2); 
# 916
}; 
# 918
template< bool _BoolType> 
# 919
template< class _II1, class _II2> bool 
# 922
__lexicographical_compare< _BoolType> ::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) 
# 923
{ 
# 924
return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter()); 
# 927
} 
# 930
template<> struct __lexicographical_compare< true>  { 
# 932
template< class _Tp, class _Up> static bool 
# 934
__lc(const _Tp *__first1, const _Tp *__last1, const _Up *
# 935
__first2, const _Up *__last2) 
# 936
{ 
# 937
const size_t __len1 = __last1 - __first1; 
# 938
const size_t __len2 = __last2 - __first2; 
# 939
if (const size_t __len = std::min(__len1, __len2)) { 
# 940
if (int __result = __builtin_memcmp(__first1, __first2, __len)) { 
# 941
return __result < 0; }  }  
# 942
return __len1 < __len2; 
# 943
} 
# 944
}; 
# 946
template< class _II1, class _II2> inline bool 
# 948
__lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 
# 949
__first2, _II2 __last2) 
# 950
{ 
# 951
typedef typename iterator_traits< _II1> ::value_type _ValueType1; 
# 952
typedef typename iterator_traits< _II2> ::value_type _ValueType2; 
# 953
const bool __simple = (__is_byte< typename iterator_traits< _II1> ::value_type> ::__value && __is_byte< typename iterator_traits< _II2> ::value_type> ::__value && (!__gnu_cxx::template __numeric_traits< typename iterator_traits< _II1> ::value_type> ::__is_signed) && (!__gnu_cxx::template __numeric_traits< typename iterator_traits< _II2> ::value_type> ::__is_signed) && __is_pointer< _II1> ::__value && __is_pointer< _II2> ::__value); 
# 960
return std::template __lexicographical_compare< __simple> ::__lc(__first1, __last1, __first2, __last2); 
# 962
} 
# 964
template< class _ForwardIterator, class _Tp, class _Compare> _ForwardIterator 
# 966
__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 967
__val, _Compare __comp) 
# 968
{ 
# 970
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 972
_DistanceType __len = std::distance(__first, __last); 
# 974
while (__len > 0) 
# 975
{ 
# 976
_DistanceType __half = __len >> 1; 
# 977
_ForwardIterator __middle = __first; 
# 978
std::advance(__middle, __half); 
# 979
if (__comp(__middle, __val)) 
# 980
{ 
# 981
__first = __middle; 
# 982
++__first; 
# 983
__len = ((__len - __half) - 1); 
# 984
} else { 
# 986
__len = __half; }  
# 987
}  
# 988
return __first; 
# 989
} 
# 1002 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 1004
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 1005
__val) 
# 1006
{ 
# 1011
; 
# 1013
return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val()); 
# 1015
} 
# 1020
constexpr int __lg(int __n) 
# 1021
{ return ((((int)sizeof(int)) * 8) - 1) - __builtin_clz(__n); } 
# 1024
constexpr unsigned __lg(unsigned __n) 
# 1025
{ return ((((int)sizeof(int)) * 8) - 1) - __builtin_clz(__n); } 
# 1028
constexpr long __lg(long __n) 
# 1029
{ return ((((int)sizeof(long)) * 8) - 1) - __builtin_clzl(__n); } 
# 1032
constexpr unsigned long __lg(unsigned long __n) 
# 1033
{ return ((((int)sizeof(long)) * 8) - 1) - __builtin_clzl(__n); } 
# 1036
constexpr long long __lg(long long __n) 
# 1037
{ return ((((int)sizeof(long long)) * 8) - 1) - __builtin_clzll(__n); } 
# 1040
constexpr unsigned long long __lg(unsigned long long __n) 
# 1041
{ return ((((int)sizeof(long long)) * 8) - 1) - __builtin_clzll(__n); } 
# 1057 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _II1, class _II2> inline bool 
# 1059
equal(_II1 __first1, _II1 __last1, _II2 __first2) 
# 1060
{ 
# 1067
; 
# 1069
return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2)); 
# 1072
} 
# 1089 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _IIter1, class _IIter2, class _BinaryPredicate> inline bool 
# 1091
equal(_IIter1 __first1, _IIter1 __last1, _IIter2 
# 1092
__first2, _BinaryPredicate __binary_pred) 
# 1093
{ 
# 1097
; 
# 1099
for (; __first1 != __last1; (++__first1), ((void)(++__first2))) { 
# 1100
if (!((bool)__binary_pred(*__first1, *__first2))) { 
# 1101
return false; }  }  
# 1102
return true; 
# 1103
} 
# 1107
template< class _II1, class _II2> inline bool 
# 1109
__equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) 
# 1110
{ 
# 1111
using _RATag = random_access_iterator_tag; 
# 1112
using _Cat1 = typename iterator_traits< _II1> ::iterator_category; 
# 1113
using _Cat2 = typename iterator_traits< _II2> ::iterator_category; 
# 1114
using _RAIters = __and_< is_same< typename iterator_traits< _II1> ::iterator_category, random_access_iterator_tag> , is_same< typename iterator_traits< _II2> ::iterator_category, random_access_iterator_tag> > ; 
# 1115
if (_RAIters()) 
# 1116
{ 
# 1117
auto __d1 = std::distance(__first1, __last1); 
# 1118
auto __d2 = std::distance(__first2, __last2); 
# 1119
if (__d1 != __d2) { 
# 1120
return false; }  
# 1121
return std::equal(__first1, __last1, __first2); 
# 1122
}  
# 1124
for (; (__first1 != __last1) && (__first2 != __last2); (++__first1), ((void)(++__first2))) { 
# 1126
if (!((*__first1) == (*__first2))) { 
# 1127
return false; }  }  
# 1128
return (__first1 == __last1) && (__first2 == __last2); 
# 1129
} 
# 1132
template< class _II1, class _II2, class _BinaryPredicate> inline bool 
# 1134
__equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _BinaryPredicate 
# 1135
__binary_pred) 
# 1136
{ 
# 1137
using _RATag = random_access_iterator_tag; 
# 1138
using _Cat1 = typename iterator_traits< _II1> ::iterator_category; 
# 1139
using _Cat2 = typename iterator_traits< _II2> ::iterator_category; 
# 1140
using _RAIters = __and_< is_same< typename iterator_traits< _II1> ::iterator_category, random_access_iterator_tag> , is_same< typename iterator_traits< _II2> ::iterator_category, random_access_iterator_tag> > ; 
# 1141
if (_RAIters()) 
# 1142
{ 
# 1143
auto __d1 = std::distance(__first1, __last1); 
# 1144
auto __d2 = std::distance(__first2, __last2); 
# 1145
if (__d1 != __d2) { 
# 1146
return false; }  
# 1147
return std::equal(__first1, __last1, __first2, __binary_pred); 
# 1149
}  
# 1151
for (; (__first1 != __last1) && (__first2 != __last2); (++__first1), ((void)(++__first2))) { 
# 1153
if (!((bool)__binary_pred(*__first1, *__first2))) { 
# 1154
return false; }  }  
# 1155
return (__first1 == __last1) && (__first2 == __last2); 
# 1156
} 
# 1176 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _II1, class _II2> inline bool 
# 1178
equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2) 
# 1179
{ 
# 1186
; 
# 1187
; 
# 1189
return std::__equal4(__first1, __last1, __first2, __last2); 
# 1190
} 
# 1208 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _IIter1, class _IIter2, class _BinaryPredicate> inline bool 
# 1210
equal(_IIter1 __first1, _IIter1 __last1, _IIter2 
# 1211
__first2, _IIter2 __last2, _BinaryPredicate __binary_pred) 
# 1212
{ 
# 1216
; 
# 1217
; 
# 1219
return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred); 
# 1221
} 
# 1239 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _II1, class _II2> inline bool 
# 1241
lexicographical_compare(_II1 __first1, _II1 __last1, _II2 
# 1242
__first2, _II2 __last2) 
# 1243
{ 
# 1253
; 
# 1254
; 
# 1256
return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2)); 
# 1260
} 
# 1275 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _II1, class _II2, class _Compare> inline bool 
# 1277
lexicographical_compare(_II1 __first1, _II1 __last1, _II2 
# 1278
__first2, _II2 __last2, _Compare __comp) 
# 1279
{ 
# 1283
; 
# 1284
; 
# 1286
return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 1289
} 
# 1291
template< class _InputIterator1, class _InputIterator2, class 
# 1292
_BinaryPredicate> pair< _InputIterator1, _InputIterator2>  
# 1294
__mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1295
__first2, _BinaryPredicate __binary_pred) 
# 1296
{ 
# 1297
while ((__first1 != __last1) && __binary_pred(__first1, __first2)) 
# 1298
{ 
# 1299
++__first1; 
# 1300
++__first2; 
# 1301
}  
# 1302
return pair< _InputIterator1, _InputIterator2> (__first1, __first2); 
# 1303
} 
# 1318 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _InputIterator1, class _InputIterator2> inline pair< _InputIterator1, _InputIterator2>  
# 1320
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1321
__first2) 
# 1322
{ 
# 1329
; 
# 1331
return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 1333
} 
# 1351 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 1352
_BinaryPredicate> inline pair< _InputIterator1, _InputIterator2>  
# 1354
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1355
__first2, _BinaryPredicate __binary_pred) 
# 1356
{ 
# 1360
; 
# 1362
return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred)); 
# 1364
} 
# 1368
template< class _InputIterator1, class _InputIterator2, class 
# 1369
_BinaryPredicate> pair< _InputIterator1, _InputIterator2>  
# 1371
__mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1372
__first2, _InputIterator2 __last2, _BinaryPredicate 
# 1373
__binary_pred) 
# 1374
{ 
# 1375
while ((__first1 != __last1) && (__first2 != __last2) && __binary_pred(__first1, __first2)) 
# 1377
{ 
# 1378
++__first1; 
# 1379
++__first2; 
# 1380
}  
# 1381
return pair< _InputIterator1, _InputIterator2> (__first1, __first2); 
# 1382
} 
# 1398 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _InputIterator1, class _InputIterator2> inline pair< _InputIterator1, _InputIterator2>  
# 1400
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1401
__first2, _InputIterator2 __last2) 
# 1402
{ 
# 1409
; 
# 1410
; 
# 1412
return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 1414
} 
# 1433 "/usr/include/c++/9/bits/stl_algobase.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 1434
_BinaryPredicate> inline pair< _InputIterator1, _InputIterator2>  
# 1436
mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 1437
__first2, _InputIterator2 __last2, _BinaryPredicate 
# 1438
__binary_pred) 
# 1439
{ 
# 1443
; 
# 1444
; 
# 1446
return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred)); 
# 1448
} 
# 1453
}
# 47 "/usr/include/c++/9/bits/char_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 61 "/usr/include/c++/9/bits/char_traits.h" 3
template< class _CharT> 
# 62
struct _Char_types { 
# 64
typedef unsigned long int_type; 
# 65
typedef std::streampos pos_type; 
# 66
typedef std::streamoff off_type; 
# 67
typedef mbstate_t state_type; 
# 68
}; 
# 86 "/usr/include/c++/9/bits/char_traits.h" 3
template< class _CharT> 
# 87
struct char_traits { 
# 89
typedef _CharT char_type; 
# 90
typedef typename _Char_types< _CharT> ::int_type int_type; 
# 91
typedef typename _Char_types< _CharT> ::pos_type pos_type; 
# 92
typedef typename _Char_types< _CharT> ::off_type off_type; 
# 93
typedef typename _Char_types< _CharT> ::state_type state_type; 
# 96
static constexpr void assign(char_type &__c1, const char_type &__c2) 
# 97
{ __c1 = __c2; } 
# 100
static constexpr bool eq(const char_type &__c1, const char_type &__c2) 
# 101
{ return __c1 == __c2; } 
# 104
static constexpr bool lt(const char_type &__c1, const char_type &__c2) 
# 105
{ return __c1 < __c2; } 
# 108
static constexpr int compare(const char_type * __s1, const char_type * __s2, std::size_t __n); 
# 111
static constexpr std::size_t length(const char_type * __s); 
# 114
static constexpr const char_type *find(const char_type * __s, std::size_t __n, const char_type & __a); 
# 117
static char_type *move(char_type * __s1, const char_type * __s2, std::size_t __n); 
# 120
static char_type *copy(char_type * __s1, const char_type * __s2, std::size_t __n); 
# 123
static char_type *assign(char_type * __s, std::size_t __n, char_type __a); 
# 126
static constexpr char_type to_char_type(const int_type &__c) 
# 127
{ return static_cast< char_type>(__c); } 
# 130
static constexpr int_type to_int_type(const char_type &__c) 
# 131
{ return static_cast< int_type>(__c); } 
# 134
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) 
# 135
{ return __c1 == __c2; } 
# 138
static constexpr int_type eof() 
# 139
{ return static_cast< int_type>(-1); } 
# 142
static constexpr int_type not_eof(const int_type &__c) 
# 143
{ return (!(eq_int_type)(__c, (eof)())) ? __c : (to_int_type)(char_type()); } 
# 144
}; 
# 146
template< class _CharT> constexpr int 
# 149
char_traits< _CharT> ::compare(const char_type *__s1, const char_type *__s2, std::size_t __n) 
# 150
{ 
# 151
for (std::size_t __i = (0); __i < __n; ++__i) { 
# 152
if ((lt)(__s1[__i], __s2[__i])) { 
# 153
return -1; } else { 
# 154
if ((lt)(__s2[__i], __s1[__i])) { 
# 155
return 1; }  }  }  
# 156
return 0; 
# 157
} 
# 159
template< class _CharT> constexpr std::size_t 
# 162
char_traits< _CharT> ::length(const char_type *__p) 
# 163
{ 
# 164
std::size_t __i = (0); 
# 165
while (!(eq)(__p[__i], char_type())) { 
# 166
++__i; }  
# 167
return __i; 
# 168
} 
# 170
template< class _CharT> constexpr const typename char_traits< _CharT> ::char_type *
# 173
char_traits< _CharT> ::find(const char_type *__s, std::size_t __n, const char_type &__a) 
# 174
{ 
# 175
for (std::size_t __i = (0); __i < __n; ++__i) { 
# 176
if ((eq)(__s[__i], __a)) { 
# 177
return __s + __i; }  }  
# 178
return 0; 
# 179
} 
# 181
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 184
char_traits< _CharT> ::move(char_type *__s1, const char_type *__s2, std::size_t __n) 
# 185
{ 
# 186
if (__n == (0)) { 
# 187
return __s1; }  
# 188
return static_cast< _CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))); 
# 190
} 
# 192
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 195
char_traits< _CharT> ::copy(char_type *__s1, const char_type *__s2, std::size_t __n) 
# 196
{ 
# 198
std::copy(__s2, __s2 + __n, __s1); 
# 199
return __s1; 
# 200
} 
# 202
template< class _CharT> typename char_traits< _CharT> ::char_type *
# 205
char_traits< _CharT> ::assign(char_type *__s, std::size_t __n, char_type __a) 
# 206
{ 
# 208
std::fill_n(__s, __n, __a); 
# 209
return __s; 
# 210
} 
# 213
}
# 215
namespace std __attribute((__visibility__("default"))) { 
# 283 "/usr/include/c++/9/bits/char_traits.h" 3
template< class _CharT> 
# 284
struct char_traits : public __gnu_cxx::char_traits< _CharT>  { 
# 285
}; 
# 290
template<> struct char_traits< char>  { 
# 292
typedef char char_type; 
# 293
typedef int int_type; 
# 294
typedef streampos pos_type; 
# 295
typedef streamoff off_type; 
# 296
typedef mbstate_t state_type; 
# 299
static void assign(char_type &__c1, const char_type &__c2) noexcept 
# 300
{ __c1 = __c2; } 
# 303
static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
# 304
{ return __c1 == __c2; } 
# 307
static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
# 308
{ 
# 310
return ((static_cast< unsigned char>(__c1)) < (static_cast< unsigned char>(__c2))); 
# 312
} 
# 315
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 316
{ 
# 317
if (__n == (0)) { 
# 318
return 0; }  
# 332 "/usr/include/c++/9/bits/char_traits.h" 3
return __builtin_memcmp(__s1, __s2, __n); 
# 333
} 
# 336
static size_t length(const char_type *__s) 
# 337
{ 
# 342
return __builtin_strlen(__s); 
# 343
} 
# 346
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 347
{ 
# 348
if (__n == (0)) { 
# 349
return 0; }  
# 356
return static_cast< const char_type *>(__builtin_memchr(__s, __a, __n)); 
# 357
} 
# 360
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 361
{ 
# 362
if (__n == (0)) { 
# 363
return __s1; }  
# 364
return static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n)); 
# 365
} 
# 368
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 369
{ 
# 370
if (__n == (0)) { 
# 371
return __s1; }  
# 372
return static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n)); 
# 373
} 
# 376
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 377
{ 
# 378
if (__n == (0)) { 
# 379
return __s; }  
# 380
return static_cast< char_type *>(__builtin_memset(__s, __a, __n)); 
# 381
} 
# 384
static constexpr char_type to_char_type(const int_type &__c) noexcept 
# 385
{ return static_cast< char_type>(__c); } 
# 390
static constexpr int_type to_int_type(const char_type &__c) noexcept 
# 391
{ return static_cast< int_type>(static_cast< unsigned char>(__c)); } 
# 394
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
# 395
{ return __c1 == __c2; } 
# 398
static constexpr int_type eof() noexcept 
# 399
{ return static_cast< int_type>(-1); } 
# 402
static constexpr int_type not_eof(const int_type &__c) noexcept 
# 403
{ return (__c == eof()) ? 0 : __c; } 
# 404
}; 
# 410
template<> struct char_traits< wchar_t>  { 
# 412
typedef wchar_t char_type; 
# 413
typedef wint_t int_type; 
# 414
typedef streamoff off_type; 
# 415
typedef wstreampos pos_type; 
# 416
typedef mbstate_t state_type; 
# 419
static void assign(char_type &__c1, const char_type &__c2) noexcept 
# 420
{ __c1 = __c2; } 
# 423
static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
# 424
{ return __c1 == __c2; } 
# 427
static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
# 428
{ return __c1 < __c2; } 
# 431
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 432
{ 
# 433
if (__n == (0)) { 
# 434
return 0; }  
# 441
return wmemcmp(__s1, __s2, __n); 
# 442
} 
# 445
static size_t length(const char_type *__s) 
# 446
{ 
# 451
return wcslen(__s); 
# 452
} 
# 455
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 456
{ 
# 457
if (__n == (0)) { 
# 458
return 0; }  
# 465
return wmemchr(__s, __a, __n); 
# 466
} 
# 469
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 470
{ 
# 471
if (__n == (0)) { 
# 472
return __s1; }  
# 473
return wmemmove(__s1, __s2, __n); 
# 474
} 
# 477
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 478
{ 
# 479
if (__n == (0)) { 
# 480
return __s1; }  
# 481
return wmemcpy(__s1, __s2, __n); 
# 482
} 
# 485
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 486
{ 
# 487
if (__n == (0)) { 
# 488
return __s; }  
# 489
return wmemset(__s, __a, __n); 
# 490
} 
# 493
static constexpr char_type to_char_type(const int_type &__c) noexcept 
# 494
{ return (char_type)__c; } 
# 497
static constexpr int_type to_int_type(const char_type &__c) noexcept 
# 498
{ return (int_type)__c; } 
# 501
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
# 502
{ return __c1 == __c2; } 
# 505
static constexpr int_type eof() noexcept 
# 506
{ return static_cast< int_type>(4294967295U); } 
# 509
static constexpr int_type not_eof(const int_type &__c) noexcept 
# 510
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
# 511
}; 
# 624 "/usr/include/c++/9/bits/char_traits.h" 3
}
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3
typedef __uint8_t uint8_t; 
# 25
typedef __uint16_t uint16_t; 
# 26
typedef __uint32_t uint32_t; 
# 27
typedef __uint64_t uint64_t; 
# 43 "/usr/include/stdint.h" 3
typedef __int_least8_t int_least8_t; 
# 44
typedef __int_least16_t int_least16_t; 
# 45
typedef __int_least32_t int_least32_t; 
# 46
typedef __int_least64_t int_least64_t; 
# 49
typedef __uint_least8_t uint_least8_t; 
# 50
typedef __uint_least16_t uint_least16_t; 
# 51
typedef __uint_least32_t uint_least32_t; 
# 52
typedef __uint_least64_t uint_least64_t; 
# 58
typedef signed char int_fast8_t; 
# 60
typedef long int_fast16_t; 
# 61
typedef long int_fast32_t; 
# 62
typedef long int_fast64_t; 
# 71 "/usr/include/stdint.h" 3
typedef unsigned char uint_fast8_t; 
# 73
typedef unsigned long uint_fast16_t; 
# 74
typedef unsigned long uint_fast32_t; 
# 75
typedef unsigned long uint_fast64_t; 
# 87 "/usr/include/stdint.h" 3
typedef long intptr_t; 
# 90
typedef unsigned long uintptr_t; 
# 101 "/usr/include/stdint.h" 3
typedef __intmax_t intmax_t; 
# 102
typedef __uintmax_t uintmax_t; 
# 44 "/usr/include/c++/9/cstdint" 3
namespace std { 
# 47
using ::int8_t;
# 48
using ::int16_t;
# 49
using ::int32_t;
# 50
using ::int64_t;
# 52
using ::int_fast8_t;
# 53
using ::int_fast16_t;
# 54
using ::int_fast32_t;
# 55
using ::int_fast64_t;
# 57
using ::int_least8_t;
# 58
using ::int_least16_t;
# 59
using ::int_least32_t;
# 60
using ::int_least64_t;
# 62
using ::intmax_t;
# 63
using ::intptr_t;
# 65
using ::uint8_t;
# 66
using ::uint16_t;
# 67
using ::uint32_t;
# 68
using ::uint64_t;
# 70
using ::uint_fast8_t;
# 71
using ::uint_fast16_t;
# 72
using ::uint_fast32_t;
# 73
using ::uint_fast64_t;
# 75
using ::uint_least8_t;
# 76
using ::uint_least16_t;
# 77
using ::uint_least32_t;
# 78
using ::uint_least64_t;
# 80
using ::uintmax_t;
# 81
using ::uintptr_t;
# 87
}
# 630 "/usr/include/c++/9/bits/char_traits.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 635
template<> struct char_traits< char16_t>  { 
# 637
typedef char16_t char_type; 
# 639
typedef uint_least16_t int_type; 
# 645
typedef streamoff off_type; 
# 646
typedef u16streampos pos_type; 
# 647
typedef mbstate_t state_type; 
# 650
static void assign(char_type &__c1, const char_type &__c2) noexcept 
# 651
{ __c1 = __c2; } 
# 654
static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
# 655
{ return __c1 == __c2; } 
# 658
static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
# 659
{ return __c1 < __c2; } 
# 662
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 663
{ 
# 664
for (size_t __i = (0); __i < __n; ++__i) { 
# 665
if (lt(__s1[__i], __s2[__i])) { 
# 666
return -1; } else { 
# 667
if (lt(__s2[__i], __s1[__i])) { 
# 668
return 1; }  }  }  
# 669
return 0; 
# 670
} 
# 673
static size_t length(const char_type *__s) 
# 674
{ 
# 675
size_t __i = (0); 
# 676
while (!eq(__s[__i], char_type())) { 
# 677
++__i; }  
# 678
return __i; 
# 679
} 
# 682
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 683
{ 
# 684
for (size_t __i = (0); __i < __n; ++__i) { 
# 685
if (eq(__s[__i], __a)) { 
# 686
return __s + __i; }  }  
# 687
return 0; 
# 688
} 
# 691
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 692
{ 
# 693
if (__n == (0)) { 
# 694
return __s1; }  
# 695
return (static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type)))); 
# 697
} 
# 700
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 701
{ 
# 702
if (__n == (0)) { 
# 703
return __s1; }  
# 704
return (static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type)))); 
# 706
} 
# 709
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 710
{ 
# 711
for (size_t __i = (0); __i < __n; ++__i) { 
# 712
assign(__s[__i], __a); }  
# 713
return __s; 
# 714
} 
# 717
static constexpr char_type to_char_type(const int_type &__c) noexcept 
# 718
{ return (char_type)__c; } 
# 721
static constexpr int_type to_int_type(const char_type &__c) noexcept 
# 722
{ return (__c == (eof())) ? (int_type)65533 : ((int_type)__c); } 
# 725
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
# 726
{ return __c1 == __c2; } 
# 729
static constexpr int_type eof() noexcept 
# 730
{ return static_cast< int_type>(-1); } 
# 733
static constexpr int_type not_eof(const int_type &__c) noexcept 
# 734
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
# 735
}; 
# 738
template<> struct char_traits< char32_t>  { 
# 740
typedef char32_t char_type; 
# 742
typedef uint_least32_t int_type; 
# 748
typedef streamoff off_type; 
# 749
typedef u32streampos pos_type; 
# 750
typedef mbstate_t state_type; 
# 753
static void assign(char_type &__c1, const char_type &__c2) noexcept 
# 754
{ __c1 = __c2; } 
# 757
static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
# 758
{ return __c1 == __c2; } 
# 761
static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
# 762
{ return __c1 < __c2; } 
# 765
static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
# 766
{ 
# 767
for (size_t __i = (0); __i < __n; ++__i) { 
# 768
if (lt(__s1[__i], __s2[__i])) { 
# 769
return -1; } else { 
# 770
if (lt(__s2[__i], __s1[__i])) { 
# 771
return 1; }  }  }  
# 772
return 0; 
# 773
} 
# 776
static size_t length(const char_type *__s) 
# 777
{ 
# 778
size_t __i = (0); 
# 779
while (!eq(__s[__i], char_type())) { 
# 780
++__i; }  
# 781
return __i; 
# 782
} 
# 785
static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
# 786
{ 
# 787
for (size_t __i = (0); __i < __n; ++__i) { 
# 788
if (eq(__s[__i], __a)) { 
# 789
return __s + __i; }  }  
# 790
return 0; 
# 791
} 
# 794
static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
# 795
{ 
# 796
if (__n == (0)) { 
# 797
return __s1; }  
# 798
return (static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type)))); 
# 800
} 
# 803
static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
# 804
{ 
# 805
if (__n == (0)) { 
# 806
return __s1; }  
# 807
return (static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type)))); 
# 809
} 
# 812
static char_type *assign(char_type *__s, size_t __n, char_type __a) 
# 813
{ 
# 814
for (size_t __i = (0); __i < __n; ++__i) { 
# 815
assign(__s[__i], __a); }  
# 816
return __s; 
# 817
} 
# 820
static constexpr char_type to_char_type(const int_type &__c) noexcept 
# 821
{ return (char_type)__c; } 
# 824
static constexpr int_type to_int_type(const char_type &__c) noexcept 
# 825
{ return (int_type)__c; } 
# 828
static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
# 829
{ return __c1 == __c2; } 
# 832
static constexpr int_type eof() noexcept 
# 833
{ return static_cast< int_type>(-1); } 
# 836
static constexpr int_type not_eof(const int_type &__c) noexcept 
# 837
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
# 838
}; 
# 841
}
# 31 "/usr/include/locale.h" 3
extern "C" {
# 51 "/usr/include/locale.h" 3
struct lconv { 
# 55
char *decimal_point; 
# 56
char *thousands_sep; 
# 62
char *grouping; 
# 68
char *int_curr_symbol; 
# 69
char *currency_symbol; 
# 70
char *mon_decimal_point; 
# 71
char *mon_thousands_sep; 
# 72
char *mon_grouping; 
# 73
char *positive_sign; 
# 74
char *negative_sign; 
# 75
char int_frac_digits; 
# 76
char frac_digits; 
# 78
char p_cs_precedes; 
# 80
char p_sep_by_space; 
# 82
char n_cs_precedes; 
# 84
char n_sep_by_space; 
# 91
char p_sign_posn; 
# 92
char n_sign_posn; 
# 95
char int_p_cs_precedes; 
# 97
char int_p_sep_by_space; 
# 99
char int_n_cs_precedes; 
# 101
char int_n_sep_by_space; 
# 108
char int_p_sign_posn; 
# 109
char int_n_sign_posn; 
# 118 "/usr/include/locale.h" 3
}; 
# 122
extern char *setlocale(int __category, const char * __locale) throw(); 
# 125
extern lconv *localeconv() throw(); 
# 141 "/usr/include/locale.h" 3
extern locale_t newlocale(int __category_mask, const char * __locale, locale_t __base) throw(); 
# 176 "/usr/include/locale.h" 3
extern locale_t duplocale(locale_t __dataset) throw(); 
# 180
extern void freelocale(locale_t __dataset) throw(); 
# 187
extern locale_t uselocale(locale_t __dataset) throw(); 
# 195
}
# 51 "/usr/include/c++/9/clocale" 3
namespace std { 
# 53
using ::lconv;
# 54
using ::setlocale;
# 55
using ::localeconv;
# 56
}
# 48 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++locale.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 52
extern "C" __typeof__(uselocale) __uselocale; 
# 55
}
# 58
namespace std __attribute((__visibility__("default"))) { 
# 62
typedef __locale_t __c_locale; 
# 69
inline int __convert_from_v(const __c_locale &__cloc __attribute((__unused__)), char *
# 70
__out, const int 
# 71
__size __attribute((__unused__)), const char *
# 72
__fmt, ...) 
# 73
{ 
# 75
__c_locale __old = __gnu_cxx::__uselocale(__cloc); 
# 88 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++locale.h" 3
__builtin_va_list __args; 
# 89
__builtin_va_start((__args),__fmt); 
# 92
const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args); 
# 97
__builtin_va_end(__args); 
# 100
__gnu_cxx::__uselocale(__old); 
# 108
return __ret; 
# 109
} 
# 112
}
# 28 "/usr/include/ctype.h" 3
extern "C" {
# 47 "/usr/include/ctype.h" 3
enum { 
# 48
_ISupper = ((0 < 8) ? (1 << 0) << 8 : ((1 << 0) >> 8)), 
# 49
_ISlower = ((1 < 8) ? (1 << 1) << 8 : ((1 << 1) >> 8)), 
# 50
_ISalpha = ((2 < 8) ? (1 << 2) << 8 : ((1 << 2) >> 8)), 
# 51
_ISdigit = ((3 < 8) ? (1 << 3) << 8 : ((1 << 3) >> 8)), 
# 52
_ISxdigit = ((4 < 8) ? (1 << 4) << 8 : ((1 << 4) >> 8)), 
# 53
_ISspace = ((5 < 8) ? (1 << 5) << 8 : ((1 << 5) >> 8)), 
# 54
_ISprint = ((6 < 8) ? (1 << 6) << 8 : ((1 << 6) >> 8)), 
# 55
_ISgraph = ((7 < 8) ? (1 << 7) << 8 : ((1 << 7) >> 8)), 
# 56
_ISblank = ((8 < 8) ? (1 << 8) << 8 : ((1 << 8) >> 8)), 
# 57
_IScntrl, 
# 58
_ISpunct = ((10 < 8) ? (1 << 10) << 8 : ((1 << 10) >> 8)), 
# 59
_ISalnum = ((11 < 8) ? (1 << 11) << 8 : ((1 << 11) >> 8))
# 60
}; 
# 79 "/usr/include/ctype.h" 3
extern const unsigned short **__ctype_b_loc() throw()
# 80
 __attribute((const)); 
# 81
extern const __int32_t **__ctype_tolower_loc() throw()
# 82
 __attribute((const)); 
# 83
extern const __int32_t **__ctype_toupper_loc() throw()
# 84
 __attribute((const)); 
# 108 "/usr/include/ctype.h" 3
extern int isalnum(int) throw(); 
# 109
extern int isalpha(int) throw(); 
# 110
extern int iscntrl(int) throw(); 
# 111
extern int isdigit(int) throw(); 
# 112
extern int islower(int) throw(); 
# 113
extern int isgraph(int) throw(); 
# 114
extern int isprint(int) throw(); 
# 115
extern int ispunct(int) throw(); 
# 116
extern int isspace(int) throw(); 
# 117
extern int isupper(int) throw(); 
# 118
extern int isxdigit(int) throw(); 
# 122
extern int tolower(int __c) throw(); 
# 125
extern int toupper(int __c) throw(); 
# 130
extern int isblank(int) throw(); 
# 135
extern int isctype(int __c, int __mask) throw(); 
# 142
extern int isascii(int __c) throw(); 
# 146
extern int toascii(int __c) throw(); 
# 150
extern int _toupper(int) throw(); 
# 151
extern int _tolower(int) throw(); 
# 251 "/usr/include/ctype.h" 3
extern int isalnum_l(int, locale_t) throw(); 
# 252
extern int isalpha_l(int, locale_t) throw(); 
# 253
extern int iscntrl_l(int, locale_t) throw(); 
# 254
extern int isdigit_l(int, locale_t) throw(); 
# 255
extern int islower_l(int, locale_t) throw(); 
# 256
extern int isgraph_l(int, locale_t) throw(); 
# 257
extern int isprint_l(int, locale_t) throw(); 
# 258
extern int ispunct_l(int, locale_t) throw(); 
# 259
extern int isspace_l(int, locale_t) throw(); 
# 260
extern int isupper_l(int, locale_t) throw(); 
# 261
extern int isxdigit_l(int, locale_t) throw(); 
# 263
extern int isblank_l(int, locale_t) throw(); 
# 267
extern int __tolower_l(int __c, locale_t __l) throw(); 
# 268
extern int tolower_l(int __c, locale_t __l) throw(); 
# 271
extern int __toupper_l(int __c, locale_t __l) throw(); 
# 272
extern int toupper_l(int __c, locale_t __l) throw(); 
# 327 "/usr/include/ctype.h" 3
}
# 62 "/usr/include/c++/9/cctype" 3
namespace std { 
# 64
using ::isalnum;
# 65
using ::isalpha;
# 66
using ::iscntrl;
# 67
using ::isdigit;
# 68
using ::isgraph;
# 69
using ::islower;
# 70
using ::isprint;
# 71
using ::ispunct;
# 72
using ::isspace;
# 73
using ::isupper;
# 74
using ::isxdigit;
# 75
using ::tolower;
# 76
using ::toupper;
# 77
}
# 85
namespace std { 
# 87
using ::isblank;
# 88
}
# 44 "/usr/include/c++/9/bits/localefwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 55 "/usr/include/c++/9/bits/localefwd.h" 3
class locale; 
# 57
template< class _Facet> bool has_facet(const locale &) throw(); 
# 61
template< class _Facet> const _Facet &use_facet(const locale &); 
# 66
template< class _CharT> inline bool isspace(_CharT, const locale &); 
# 70
template< class _CharT> inline bool isprint(_CharT, const locale &); 
# 74
template< class _CharT> inline bool iscntrl(_CharT, const locale &); 
# 78
template< class _CharT> inline bool isupper(_CharT, const locale &); 
# 82
template< class _CharT> inline bool islower(_CharT, const locale &); 
# 86
template< class _CharT> inline bool isalpha(_CharT, const locale &); 
# 90
template< class _CharT> inline bool isdigit(_CharT, const locale &); 
# 94
template< class _CharT> inline bool ispunct(_CharT, const locale &); 
# 98
template< class _CharT> inline bool isxdigit(_CharT, const locale &); 
# 102
template< class _CharT> inline bool isalnum(_CharT, const locale &); 
# 106
template< class _CharT> inline bool isgraph(_CharT, const locale &); 
# 111
template< class _CharT> inline bool isblank(_CharT, const locale &); 
# 116
template< class _CharT> inline _CharT toupper(_CharT, const locale &); 
# 120
template< class _CharT> inline _CharT tolower(_CharT, const locale &); 
# 125
struct ctype_base; 
# 126
template< class _CharT> class ctype; 
# 128
template<> class ctype< char> ; 
# 130
template<> class ctype< wchar_t> ; 
# 132
template< class _CharT> class ctype_byname; 
# 136
class codecvt_base; 
# 137
template< class _InternT, class _ExternT, class _StateT> class codecvt; 
# 139
template<> class codecvt< char, char, __mbstate_t> ; 
# 141
template<> class codecvt< wchar_t, char, __mbstate_t> ; 
# 144
template<> class codecvt< char16_t, char, __mbstate_t> ; 
# 145
template<> class codecvt< char32_t, char, __mbstate_t> ; 
# 151
template< class _InternT, class _ExternT, class _StateT> class codecvt_byname; 
# 156
template< class _CharT, class _InIter = istreambuf_iterator< _CharT> > class num_get; 
# 158
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT> > class num_put; 
# 161
inline namespace __cxx11 { 
# 162
template< class _CharT> class numpunct; 
# 163
template< class _CharT> class numpunct_byname; 
# 164
}
# 166
inline namespace __cxx11 { 
# 168
template< class _CharT> class collate; 
# 170
template< class _CharT> class collate_byname; 
# 172
}
# 175
class time_base; 
# 176
inline namespace __cxx11 { 
# 177
template< class _CharT, class _InIter = istreambuf_iterator< _CharT> > class time_get; 
# 179
template< class _CharT, class _InIter = istreambuf_iterator< _CharT> > class time_get_byname; 
# 181
}
# 182
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT> > class time_put; 
# 184
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT> > class time_put_byname; 
# 188
class money_base; 
# 189
inline namespace __cxx11 { 
# 190
template< class _CharT, class _InIter = istreambuf_iterator< _CharT> > class money_get; 
# 192
template< class _CharT, class _OutIter = ostreambuf_iterator< _CharT> > class money_put; 
# 194
}
# 195
inline namespace __cxx11 { 
# 196
template< class _CharT, bool _Intl = false> class moneypunct; 
# 198
template< class _CharT, bool _Intl = false> class moneypunct_byname; 
# 200
}
# 203
struct messages_base; 
# 204
inline namespace __cxx11 { 
# 205
template< class _CharT> class messages; 
# 207
template< class _CharT> class messages_byname; 
# 209
}
# 212
}
# 30 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr.h" 3
#pragma GCC visibility push ( default )
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 3
struct sched_param { 
# 25
int sched_priority; 
# 26
}; 
# 78 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3
extern "C" {
# 82
extern int clone(int (* __fn)(void * __arg), void * __child_stack, int __flags, void * __arg, ...) throw(); 
# 86
extern int unshare(int __flags) throw(); 
# 89
extern int sched_getcpu() throw(); 
# 92
extern int getcpu(unsigned *, unsigned *) throw(); 
# 95
extern int setns(int __fd, int __nstype) throw(); 
# 98
}
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3
typedef unsigned long __cpu_mask; 
# 42
typedef 
# 40
struct { 
# 41
__cpu_mask __bits[(1024) / ((8) * sizeof(__cpu_mask))]; 
# 42
} cpu_set_t; 
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3
extern "C" {
# 117
extern int __sched_cpucount(size_t __setsize, const cpu_set_t * __setp) throw(); 
# 119
extern cpu_set_t *__sched_cpualloc(size_t __count) throw(); 
# 120
extern void __sched_cpufree(cpu_set_t * __set) throw(); 
# 122
}
# 51 "/usr/include/sched.h" 3
extern "C" {
# 54
extern int sched_setparam(__pid_t __pid, const sched_param * __param) throw(); 
# 58
extern int sched_getparam(__pid_t __pid, sched_param * __param) throw(); 
# 61
extern int sched_setscheduler(__pid_t __pid, int __policy, const sched_param * __param) throw(); 
# 65
extern int sched_getscheduler(__pid_t __pid) throw(); 
# 68
extern int sched_yield() throw(); 
# 71
extern int sched_get_priority_max(int __algorithm) throw(); 
# 74
extern int sched_get_priority_min(int __algorithm) throw(); 
# 77
extern int sched_rr_get_interval(__pid_t __pid, timespec * __t) throw(); 
# 121 "/usr/include/sched.h" 3
extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t * __cpuset) throw(); 
# 125
extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t * __cpuset) throw(); 
# 129
}
# 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3
typedef long __jmp_buf[8]; 
# 34 "/usr/include/pthread.h" 3
enum { 
# 35
PTHREAD_CREATE_JOINABLE, 
# 37
PTHREAD_CREATE_DETACHED
# 39
}; 
# 44
enum { 
# 45
PTHREAD_MUTEX_TIMED_NP, 
# 46
PTHREAD_MUTEX_RECURSIVE_NP, 
# 47
PTHREAD_MUTEX_ERRORCHECK_NP, 
# 48
PTHREAD_MUTEX_ADAPTIVE_NP, 
# 51
PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP, 
# 52
PTHREAD_MUTEX_RECURSIVE, 
# 53
PTHREAD_MUTEX_ERRORCHECK, 
# 54
PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL, 
# 58
PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
# 60
}; 
# 66
enum { 
# 67
PTHREAD_MUTEX_STALLED, 
# 68
PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED, 
# 69
PTHREAD_MUTEX_ROBUST, 
# 70
PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
# 71
}; 
# 78
enum { 
# 79
PTHREAD_PRIO_NONE, 
# 80
PTHREAD_PRIO_INHERIT, 
# 81
PTHREAD_PRIO_PROTECT
# 82
}; 
# 101 "/usr/include/pthread.h" 3
enum { 
# 102
PTHREAD_RWLOCK_PREFER_READER_NP, 
# 103
PTHREAD_RWLOCK_PREFER_WRITER_NP, 
# 104
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, 
# 105
PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
# 106
}; 
# 121 "/usr/include/pthread.h" 3
enum { 
# 122
PTHREAD_INHERIT_SCHED, 
# 124
PTHREAD_EXPLICIT_SCHED
# 126
}; 
# 131
enum { 
# 132
PTHREAD_SCOPE_SYSTEM, 
# 134
PTHREAD_SCOPE_PROCESS
# 136
}; 
# 141
enum { 
# 142
PTHREAD_PROCESS_PRIVATE, 
# 144
PTHREAD_PROCESS_SHARED
# 146
}; 
# 155 "/usr/include/pthread.h" 3
struct _pthread_cleanup_buffer { 
# 157
void (*__routine)(void *); 
# 158
void *__arg; 
# 159
int __canceltype; 
# 160
_pthread_cleanup_buffer *__prev; 
# 161
}; 
# 165
enum { 
# 166
PTHREAD_CANCEL_ENABLE, 
# 168
PTHREAD_CANCEL_DISABLE
# 170
}; 
# 172
enum { 
# 173
PTHREAD_CANCEL_DEFERRED, 
# 175
PTHREAD_CANCEL_ASYNCHRONOUS
# 177
}; 
# 193 "/usr/include/pthread.h" 3
extern "C" {
# 198
extern int pthread_create(pthread_t *__restrict__ __newthread, const pthread_attr_t *__restrict__ __attr, void *(* __start_routine)(void *), void *__restrict__ __arg) throw()
# 201
 __attribute((__nonnull__(1, 3))); 
# 207
extern void pthread_exit(void * __retval) __attribute((__noreturn__)); 
# 215
extern int pthread_join(pthread_t __th, void ** __thread_return); 
# 220
extern int pthread_tryjoin_np(pthread_t __th, void ** __thread_return) throw(); 
# 228
extern int pthread_timedjoin_np(pthread_t __th, void ** __thread_return, const timespec * __abstime); 
# 238 "/usr/include/pthread.h" 3
extern int pthread_clockjoin_np(pthread_t __th, void ** __thread_return, clockid_t __clockid, const timespec * __abstime); 
# 247
extern int pthread_detach(pthread_t __th) throw(); 
# 251
extern pthread_t pthread_self() throw() __attribute((const)); 
# 254
extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) throw()
# 255
 __attribute((const)); 
# 263
extern int pthread_attr_init(pthread_attr_t * __attr) throw() __attribute((__nonnull__(1))); 
# 266
extern int pthread_attr_destroy(pthread_attr_t * __attr) throw()
# 267
 __attribute((__nonnull__(1))); 
# 270
extern int pthread_attr_getdetachstate(const pthread_attr_t * __attr, int * __detachstate) throw()
# 272
 __attribute((__nonnull__(1, 2))); 
# 275
extern int pthread_attr_setdetachstate(pthread_attr_t * __attr, int __detachstate) throw()
# 277
 __attribute((__nonnull__(1))); 
# 281
extern int pthread_attr_getguardsize(const pthread_attr_t * __attr, size_t * __guardsize) throw()
# 283
 __attribute((__nonnull__(1, 2))); 
# 286
extern int pthread_attr_setguardsize(pthread_attr_t * __attr, size_t __guardsize) throw()
# 288
 __attribute((__nonnull__(1))); 
# 292
extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict__ __attr, sched_param *__restrict__ __param) throw()
# 294
 __attribute((__nonnull__(1, 2))); 
# 297
extern int pthread_attr_setschedparam(pthread_attr_t *__restrict__ __attr, const sched_param *__restrict__ __param) throw()
# 299
 __attribute((__nonnull__(1, 2))); 
# 302
extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __policy) throw()
# 304
 __attribute((__nonnull__(1, 2))); 
# 307
extern int pthread_attr_setschedpolicy(pthread_attr_t * __attr, int __policy) throw()
# 308
 __attribute((__nonnull__(1))); 
# 311
extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __inherit) throw()
# 313
 __attribute((__nonnull__(1, 2))); 
# 316
extern int pthread_attr_setinheritsched(pthread_attr_t * __attr, int __inherit) throw()
# 318
 __attribute((__nonnull__(1))); 
# 322
extern int pthread_attr_getscope(const pthread_attr_t *__restrict__ __attr, int *__restrict__ __scope) throw()
# 324
 __attribute((__nonnull__(1, 2))); 
# 327
extern int pthread_attr_setscope(pthread_attr_t * __attr, int __scope) throw()
# 328
 __attribute((__nonnull__(1))); 
# 331
extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict__ __attr, void **__restrict__ __stackaddr) throw()
# 333
 __attribute((__nonnull__(1, 2))) __attribute((__deprecated__)); 
# 339
extern int pthread_attr_setstackaddr(pthread_attr_t * __attr, void * __stackaddr) throw()
# 341
 __attribute((__nonnull__(1))) __attribute((__deprecated__)); 
# 344
extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict__ __attr, size_t *__restrict__ __stacksize) throw()
# 346
 __attribute((__nonnull__(1, 2))); 
# 351
extern int pthread_attr_setstacksize(pthread_attr_t * __attr, size_t __stacksize) throw()
# 353
 __attribute((__nonnull__(1))); 
# 357
extern int pthread_attr_getstack(const pthread_attr_t *__restrict__ __attr, void **__restrict__ __stackaddr, size_t *__restrict__ __stacksize) throw()
# 360
 __attribute((__nonnull__(1, 2, 3))); 
# 365
extern int pthread_attr_setstack(pthread_attr_t * __attr, void * __stackaddr, size_t __stacksize) throw()
# 366
 __attribute((__nonnull__(1))); 
# 372
extern int pthread_attr_setaffinity_np(pthread_attr_t * __attr, size_t __cpusetsize, const cpu_set_t * __cpuset) throw()
# 375
 __attribute((__nonnull__(1, 3))); 
# 379
extern int pthread_attr_getaffinity_np(const pthread_attr_t * __attr, size_t __cpusetsize, cpu_set_t * __cpuset) throw()
# 382
 __attribute((__nonnull__(1, 3))); 
# 385
extern int pthread_getattr_default_np(pthread_attr_t * __attr) throw()
# 386
 __attribute((__nonnull__(1))); 
# 390
extern int pthread_setattr_default_np(const pthread_attr_t * __attr) throw()
# 391
 __attribute((__nonnull__(1))); 
# 396
extern int pthread_getattr_np(pthread_t __th, pthread_attr_t * __attr) throw()
# 397
 __attribute((__nonnull__(2))); 
# 405
extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const sched_param * __param) throw()
# 407
 __attribute((__nonnull__(3))); 
# 410
extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict__ __policy, sched_param *__restrict__ __param) throw()
# 413
 __attribute((__nonnull__(2, 3))); 
# 416
extern int pthread_setschedprio(pthread_t __target_thread, int __prio) throw(); 
# 422
extern int pthread_getname_np(pthread_t __target_thread, char * __buf, size_t __buflen) throw()
# 424
 __attribute((__nonnull__(2))); 
# 427
extern int pthread_setname_np(pthread_t __target_thread, const char * __name) throw()
# 428
 __attribute((__nonnull__(2))); 
# 434
extern int pthread_getconcurrency() throw(); 
# 437
extern int pthread_setconcurrency(int __level) throw(); 
# 445
extern int pthread_yield() throw(); 
# 450
extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t * __cpuset) throw()
# 452
 __attribute((__nonnull__(3))); 
# 455
extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t * __cpuset) throw()
# 457
 __attribute((__nonnull__(3))); 
# 470 "/usr/include/pthread.h" 3
extern int pthread_once(pthread_once_t * __once_control, void (* __init_routine)(void))
# 471
 __attribute((__nonnull__(1, 2))); 
# 482 "/usr/include/pthread.h" 3
extern int pthread_setcancelstate(int __state, int * __oldstate); 
# 486
extern int pthread_setcanceltype(int __type, int * __oldtype); 
# 489
extern int pthread_cancel(pthread_t __th); 
# 494
extern void pthread_testcancel(); 
# 507
typedef 
# 500
struct { 
# 502
struct { 
# 503
__jmp_buf __cancel_jmp_buf; 
# 504
int __mask_was_saved; 
# 505
} __cancel_jmp_buf[1]; 
# 506
void *__pad[4]; 
# 507
} __pthread_unwind_buf_t __attribute((__aligned__)); 
# 516 "/usr/include/pthread.h" 3
struct __pthread_cleanup_frame { 
# 518
void (*__cancel_routine)(void *); 
# 519
void *__cancel_arg; 
# 520
int __do_it; 
# 521
int __cancel_type; 
# 522
}; 
# 527
class __pthread_cleanup_class { 
# 529
void (*__cancel_routine)(void *); 
# 530
void *__cancel_arg; 
# 531
int __do_it; 
# 532
int __cancel_type; 
# 535
public: __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1) 
# 536
{ } 
# 537
~__pthread_cleanup_class() { if (__do_it) { (__cancel_routine)(__cancel_arg); }  } 
# 538
void __setdoit(int __newval) { (__do_it) = __newval; } 
# 539
void __defer() { pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &(__cancel_type)); 
# 540
} 
# 541
void __restore() const { pthread_setcanceltype(__cancel_type, 0); } 
# 542
}; 
# 718 "/usr/include/pthread.h" 3
struct __jmp_buf_tag; 
# 719
extern int __sigsetjmp(__jmp_buf_tag * __env, int __savemask) throw(); 
# 725
extern int pthread_mutex_init(pthread_mutex_t * __mutex, const pthread_mutexattr_t * __mutexattr) throw()
# 727
 __attribute((__nonnull__(1))); 
# 730
extern int pthread_mutex_destroy(pthread_mutex_t * __mutex) throw()
# 731
 __attribute((__nonnull__(1))); 
# 734
extern int pthread_mutex_trylock(pthread_mutex_t * __mutex) throw()
# 735
 __attribute((__nonnull__(1))); 
# 738
extern int pthread_mutex_lock(pthread_mutex_t * __mutex) throw()
# 739
 __attribute((__nonnull__(1))); 
# 743
extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict__ __mutex, const timespec *__restrict__ __abstime) throw()
# 745
 __attribute((__nonnull__(1, 2))); 
# 749
extern int pthread_mutex_clocklock(pthread_mutex_t *__restrict__ __mutex, clockid_t __clockid, const timespec *__restrict__ __abstime) throw()
# 752
 __attribute((__nonnull__(1, 3))); 
# 756
extern int pthread_mutex_unlock(pthread_mutex_t * __mutex) throw()
# 757
 __attribute((__nonnull__(1))); 
# 761
extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict__ __mutex, int *__restrict__ __prioceiling) throw()
# 764
 __attribute((__nonnull__(1, 2))); 
# 768
extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict__ __mutex, int __prioceiling, int *__restrict__ __old_ceiling) throw()
# 771
 __attribute((__nonnull__(1, 3))); 
# 776
extern int pthread_mutex_consistent(pthread_mutex_t * __mutex) throw()
# 777
 __attribute((__nonnull__(1))); 
# 779
extern int pthread_mutex_consistent_np(pthread_mutex_t * __mutex) throw()
# 780
 __attribute((__nonnull__(1))); 
# 789 "/usr/include/pthread.h" 3
extern int pthread_mutexattr_init(pthread_mutexattr_t * __attr) throw()
# 790
 __attribute((__nonnull__(1))); 
# 793
extern int pthread_mutexattr_destroy(pthread_mutexattr_t * __attr) throw()
# 794
 __attribute((__nonnull__(1))); 
# 797
extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 800
 __attribute((__nonnull__(1, 2))); 
# 803
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t * __attr, int __pshared) throw()
# 805
 __attribute((__nonnull__(1))); 
# 809
extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __kind) throw()
# 811
 __attribute((__nonnull__(1, 2))); 
# 816
extern int pthread_mutexattr_settype(pthread_mutexattr_t * __attr, int __kind) throw()
# 817
 __attribute((__nonnull__(1))); 
# 821
extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __protocol) throw()
# 824
 __attribute((__nonnull__(1, 2))); 
# 828
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t * __attr, int __protocol) throw()
# 830
 __attribute((__nonnull__(1))); 
# 833
extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict__ __attr, int *__restrict__ __prioceiling) throw()
# 836
 __attribute((__nonnull__(1, 2))); 
# 839
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * __attr, int __prioceiling) throw()
# 841
 __attribute((__nonnull__(1))); 
# 845
extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t * __attr, int * __robustness) throw()
# 847
 __attribute((__nonnull__(1, 2))); 
# 849
extern int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t * __attr, int * __robustness) throw()
# 851
 __attribute((__nonnull__(1, 2))); 
# 855
extern int pthread_mutexattr_setrobust(pthread_mutexattr_t * __attr, int __robustness) throw()
# 857
 __attribute((__nonnull__(1))); 
# 859
extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * __attr, int __robustness) throw()
# 861
 __attribute((__nonnull__(1))); 
# 871 "/usr/include/pthread.h" 3
extern int pthread_rwlock_init(pthread_rwlock_t *__restrict__ __rwlock, const pthread_rwlockattr_t *__restrict__ __attr) throw()
# 873
 __attribute((__nonnull__(1))); 
# 876
extern int pthread_rwlock_destroy(pthread_rwlock_t * __rwlock) throw()
# 877
 __attribute((__nonnull__(1))); 
# 880
extern int pthread_rwlock_rdlock(pthread_rwlock_t * __rwlock) throw()
# 881
 __attribute((__nonnull__(1))); 
# 884
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t * __rwlock) throw()
# 885
 __attribute((__nonnull__(1))); 
# 889
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict__ __rwlock, const timespec *__restrict__ __abstime) throw()
# 891
 __attribute((__nonnull__(1, 2))); 
# 895
extern int pthread_rwlock_clockrdlock(pthread_rwlock_t *__restrict__ __rwlock, clockid_t __clockid, const timespec *__restrict__ __abstime) throw()
# 898
 __attribute((__nonnull__(1, 3))); 
# 902
extern int pthread_rwlock_wrlock(pthread_rwlock_t * __rwlock) throw()
# 903
 __attribute((__nonnull__(1))); 
# 906
extern int pthread_rwlock_trywrlock(pthread_rwlock_t * __rwlock) throw()
# 907
 __attribute((__nonnull__(1))); 
# 911
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict__ __rwlock, const timespec *__restrict__ __abstime) throw()
# 913
 __attribute((__nonnull__(1, 2))); 
# 917
extern int pthread_rwlock_clockwrlock(pthread_rwlock_t *__restrict__ __rwlock, clockid_t __clockid, const timespec *__restrict__ __abstime) throw()
# 920
 __attribute((__nonnull__(1, 3))); 
# 924
extern int pthread_rwlock_unlock(pthread_rwlock_t * __rwlock) throw()
# 925
 __attribute((__nonnull__(1))); 
# 931
extern int pthread_rwlockattr_init(pthread_rwlockattr_t * __attr) throw()
# 932
 __attribute((__nonnull__(1))); 
# 935
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t * __attr) throw()
# 936
 __attribute((__nonnull__(1))); 
# 939
extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 942
 __attribute((__nonnull__(1, 2))); 
# 945
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * __attr, int __pshared) throw()
# 947
 __attribute((__nonnull__(1))); 
# 950
extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict__ __attr, int *__restrict__ __pref) throw()
# 953
 __attribute((__nonnull__(1, 2))); 
# 956
extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t * __attr, int __pref) throw()
# 957
 __attribute((__nonnull__(1))); 
# 965
extern int pthread_cond_init(pthread_cond_t *__restrict__ __cond, const pthread_condattr_t *__restrict__ __cond_attr) throw()
# 967
 __attribute((__nonnull__(1))); 
# 970
extern int pthread_cond_destroy(pthread_cond_t * __cond) throw()
# 971
 __attribute((__nonnull__(1))); 
# 974
extern int pthread_cond_signal(pthread_cond_t * __cond) throw()
# 975
 __attribute((__nonnull__(1))); 
# 978
extern int pthread_cond_broadcast(pthread_cond_t * __cond) throw()
# 979
 __attribute((__nonnull__(1))); 
# 986
extern int pthread_cond_wait(pthread_cond_t *__restrict__ __cond, pthread_mutex_t *__restrict__ __mutex)
# 988
 __attribute((__nonnull__(1, 2))); 
# 997 "/usr/include/pthread.h" 3
extern int pthread_cond_timedwait(pthread_cond_t *__restrict__ __cond, pthread_mutex_t *__restrict__ __mutex, const timespec *__restrict__ __abstime)
# 1000
 __attribute((__nonnull__(1, 2, 3))); 
# 1010 "/usr/include/pthread.h" 3
extern int pthread_cond_clockwait(pthread_cond_t *__restrict__ __cond, pthread_mutex_t *__restrict__ __mutex, __clockid_t __clock_id, const timespec *__restrict__ __abstime)
# 1014
 __attribute((__nonnull__(1, 2, 4))); 
# 1020
extern int pthread_condattr_init(pthread_condattr_t * __attr) throw()
# 1021
 __attribute((__nonnull__(1))); 
# 1024
extern int pthread_condattr_destroy(pthread_condattr_t * __attr) throw()
# 1025
 __attribute((__nonnull__(1))); 
# 1028
extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 1031
 __attribute((__nonnull__(1, 2))); 
# 1034
extern int pthread_condattr_setpshared(pthread_condattr_t * __attr, int __pshared) throw()
# 1035
 __attribute((__nonnull__(1))); 
# 1039
extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict__ __attr, __clockid_t *__restrict__ __clock_id) throw()
# 1042
 __attribute((__nonnull__(1, 2))); 
# 1045
extern int pthread_condattr_setclock(pthread_condattr_t * __attr, __clockid_t __clock_id) throw()
# 1047
 __attribute((__nonnull__(1))); 
# 1056 "/usr/include/pthread.h" 3
extern int pthread_spin_init(pthread_spinlock_t * __lock, int __pshared) throw()
# 1057
 __attribute((__nonnull__(1))); 
# 1060
extern int pthread_spin_destroy(pthread_spinlock_t * __lock) throw()
# 1061
 __attribute((__nonnull__(1))); 
# 1064
extern int pthread_spin_lock(pthread_spinlock_t * __lock) throw()
# 1065
 __attribute((__nonnull__(1))); 
# 1068
extern int pthread_spin_trylock(pthread_spinlock_t * __lock) throw()
# 1069
 __attribute((__nonnull__(1))); 
# 1072
extern int pthread_spin_unlock(pthread_spinlock_t * __lock) throw()
# 1073
 __attribute((__nonnull__(1))); 
# 1080
extern int pthread_barrier_init(pthread_barrier_t *__restrict__ __barrier, const pthread_barrierattr_t *__restrict__ __attr, unsigned __count) throw()
# 1083
 __attribute((__nonnull__(1))); 
# 1086
extern int pthread_barrier_destroy(pthread_barrier_t * __barrier) throw()
# 1087
 __attribute((__nonnull__(1))); 
# 1090
extern int pthread_barrier_wait(pthread_barrier_t * __barrier) throw()
# 1091
 __attribute((__nonnull__(1))); 
# 1095
extern int pthread_barrierattr_init(pthread_barrierattr_t * __attr) throw()
# 1096
 __attribute((__nonnull__(1))); 
# 1099
extern int pthread_barrierattr_destroy(pthread_barrierattr_t * __attr) throw()
# 1100
 __attribute((__nonnull__(1))); 
# 1103
extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict__ __attr, int *__restrict__ __pshared) throw()
# 1106
 __attribute((__nonnull__(1, 2))); 
# 1109
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t * __attr, int __pshared) throw()
# 1111
 __attribute((__nonnull__(1))); 
# 1123 "/usr/include/pthread.h" 3
extern int pthread_key_create(pthread_key_t * __key, void (* __destr_function)(void *)) throw()
# 1125
 __attribute((__nonnull__(1))); 
# 1128
extern int pthread_key_delete(pthread_key_t __key) throw(); 
# 1131
extern void *pthread_getspecific(pthread_key_t __key) throw(); 
# 1134
extern int pthread_setspecific(pthread_key_t __key, const void * __pointer) throw(); 
# 1140
extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t * __clock_id) throw()
# 1142
 __attribute((__nonnull__(2))); 
# 1157 "/usr/include/pthread.h" 3
extern int pthread_atfork(void (* __prepare)(void), void (* __parent)(void), void (* __child)(void)) throw(); 
# 1171 "/usr/include/pthread.h" 3
}
# 47 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
typedef pthread_t __gthread_t; 
# 48
typedef pthread_key_t __gthread_key_t; 
# 49
typedef pthread_once_t __gthread_once_t; 
# 50
typedef pthread_mutex_t __gthread_mutex_t; 
# 51
typedef pthread_mutex_t __gthread_recursive_mutex_t; 
# 52
typedef pthread_cond_t __gthread_cond_t; 
# 53
typedef timespec __gthread_time_t; 
# 102 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static __typeof__(pthread_once) __gthrw_pthread_once __attribute((__weakref__("pthread_once"), __copy__(pthread_once ))); 
# 103
static __typeof__(pthread_getspecific) __gthrw_pthread_getspecific __attribute((__weakref__("pthread_getspecific"), __copy__(pthread_getspecific ))); 
# 104
static __typeof__(pthread_setspecific) __gthrw_pthread_setspecific __attribute((__weakref__("pthread_setspecific"), __copy__(pthread_setspecific ))); 
# 106
static __typeof__(pthread_create) __gthrw_pthread_create __attribute((__weakref__("pthread_create"), __copy__(pthread_create ))); 
# 107
static __typeof__(pthread_join) __gthrw_pthread_join __attribute((__weakref__("pthread_join"), __copy__(pthread_join ))); 
# 108
static __typeof__(pthread_equal) __gthrw_pthread_equal __attribute((__weakref__("pthread_equal"), __copy__(pthread_equal ))); 
# 109
static __typeof__(pthread_self) __gthrw_pthread_self __attribute((__weakref__("pthread_self"), __copy__(pthread_self ))); 
# 110
static __typeof__(pthread_detach) __gthrw_pthread_detach __attribute((__weakref__("pthread_detach"), __copy__(pthread_detach ))); 
# 112
static __typeof__(pthread_cancel) __gthrw_pthread_cancel __attribute((__weakref__("pthread_cancel"), __copy__(pthread_cancel ))); 
# 114
static __typeof__(sched_yield) __gthrw_sched_yield __attribute((__weakref__("sched_yield"), __copy__(sched_yield ))); 
# 116
static __typeof__(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute((__weakref__("pthread_mutex_lock"), __copy__(pthread_mutex_lock ))); 
# 117
static __typeof__(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute((__weakref__("pthread_mutex_trylock"), __copy__(pthread_mutex_trylock ))); 
# 119
static __typeof__(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute((__weakref__("pthread_mutex_timedlock"), __copy__(pthread_mutex_timedlock ))); 
# 121
static __typeof__(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute((__weakref__("pthread_mutex_unlock"), __copy__(pthread_mutex_unlock ))); 
# 122
static __typeof__(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute((__weakref__("pthread_mutex_init"), __copy__(pthread_mutex_init ))); 
# 123
static __typeof__(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute((__weakref__("pthread_mutex_destroy"), __copy__(pthread_mutex_destroy ))); 
# 125
static __typeof__(pthread_cond_init) __gthrw_pthread_cond_init __attribute((__weakref__("pthread_cond_init"), __copy__(pthread_cond_init ))); 
# 126
static __typeof__(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute((__weakref__("pthread_cond_broadcast"), __copy__(pthread_cond_broadcast ))); 
# 127
static __typeof__(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute((__weakref__("pthread_cond_signal"), __copy__(pthread_cond_signal ))); 
# 128
static __typeof__(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute((__weakref__("pthread_cond_wait"), __copy__(pthread_cond_wait ))); 
# 129
static __typeof__(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute((__weakref__("pthread_cond_timedwait"), __copy__(pthread_cond_timedwait ))); 
# 130
static __typeof__(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute((__weakref__("pthread_cond_destroy"), __copy__(pthread_cond_destroy ))); 
# 132
static __typeof__(pthread_key_create) __gthrw_pthread_key_create __attribute((__weakref__("pthread_key_create"), __copy__(pthread_key_create ))); 
# 133
static __typeof__(pthread_key_delete) __gthrw_pthread_key_delete __attribute((__weakref__("pthread_key_delete"), __copy__(pthread_key_delete ))); 
# 134
static __typeof__(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute((__weakref__("pthread_mutexattr_init"), __copy__(pthread_mutexattr_init ))); 
# 135
static __typeof__(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute((__weakref__("pthread_mutexattr_settype"), __copy__(pthread_mutexattr_settype ))); 
# 136
static __typeof__(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute((__weakref__("pthread_mutexattr_destroy"), __copy__(pthread_mutexattr_destroy ))); 
# 237 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static __typeof__(pthread_key_create) __gthrw___pthread_key_create __attribute((__weakref__("__pthread_key_create"), __copy__(pthread_key_create ))); 
# 248 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static inline int __gthread_active_p() 
# 249
{ 
# 250
static void *const __gthread_active_ptr = __extension__ ((void *)(&__gthrw___pthread_key_create)); 
# 252
return __gthread_active_ptr != (0); 
# 253
} 
# 660 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *
# 661
__args) 
# 662
{ 
# 663
return __gthrw_pthread_create(__threadid, __null, __func, __args); 
# 664
} 
# 667
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) 
# 668
{ 
# 669
return __gthrw_pthread_join(__threadid, __value_ptr); 
# 670
} 
# 673
static inline int __gthread_detach(__gthread_t __threadid) 
# 674
{ 
# 675
return __gthrw_pthread_detach(__threadid); 
# 676
} 
# 679
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) 
# 680
{ 
# 681
return __gthrw_pthread_equal(__t1, __t2); 
# 682
} 
# 685
static inline __gthread_t __gthread_self() 
# 686
{ 
# 687
return __gthrw_pthread_self(); 
# 688
} 
# 691
static inline int __gthread_yield() 
# 692
{ 
# 693
return __gthrw_sched_yield(); 
# 694
} 
# 697
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)(void)) 
# 698
{ 
# 699
if (__gthread_active_p()) { 
# 700
return __gthrw_pthread_once(__once, __func); } else { 
# 702
return -1; }  
# 703
} 
# 706
static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) 
# 707
{ 
# 708
return __gthrw_pthread_key_create(__key, __dtor); 
# 709
} 
# 712
static inline int __gthread_key_delete(__gthread_key_t __key) 
# 713
{ 
# 714
return __gthrw_pthread_key_delete(__key); 
# 715
} 
# 718
static inline void *__gthread_getspecific(__gthread_key_t __key) 
# 719
{ 
# 720
return __gthrw_pthread_getspecific(__key); 
# 721
} 
# 724
static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) 
# 725
{ 
# 726
return __gthrw_pthread_setspecific(__key, __ptr); 
# 727
} 
# 730
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) 
# 731
{ 
# 732
if (__gthread_active_p()) { 
# 733
__gthrw_pthread_mutex_init(__mutex, __null); }  
# 734
} 
# 737
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) 
# 738
{ 
# 739
if (__gthread_active_p()) { 
# 740
return __gthrw_pthread_mutex_destroy(__mutex); } else { 
# 742
return 0; }  
# 743
} 
# 746
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) 
# 747
{ 
# 748
if (__gthread_active_p()) { 
# 749
return __gthrw_pthread_mutex_lock(__mutex); } else { 
# 751
return 0; }  
# 752
} 
# 755
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) 
# 756
{ 
# 757
if (__gthread_active_p()) { 
# 758
return __gthrw_pthread_mutex_trylock(__mutex); } else { 
# 760
return 0; }  
# 761
} 
# 765
static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *
# 766
__abs_timeout) 
# 767
{ 
# 768
if (__gthread_active_p()) { 
# 769
return __gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout); } else { 
# 771
return 0; }  
# 772
} 
# 776
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) 
# 777
{ 
# 778
if (__gthread_active_p()) { 
# 779
return __gthrw_pthread_mutex_unlock(__mutex); } else { 
# 781
return 0; }  
# 782
} 
# 809 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) 
# 810
{ 
# 811
return __gthread_mutex_lock(__mutex); 
# 812
} 
# 815
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) 
# 816
{ 
# 817
return __gthread_mutex_trylock(__mutex); 
# 818
} 
# 822
static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *
# 823
__abs_timeout) 
# 824
{ 
# 825
return __gthread_mutex_timedlock(__mutex, __abs_timeout); 
# 826
} 
# 830
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) 
# 831
{ 
# 832
return __gthread_mutex_unlock(__mutex); 
# 833
} 
# 836
static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) 
# 837
{ 
# 838
return __gthread_mutex_destroy(__mutex); 
# 839
} 
# 851 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h" 3
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) 
# 852
{ 
# 853
return __gthrw_pthread_cond_broadcast(__cond); 
# 854
} 
# 857
static inline int __gthread_cond_signal(__gthread_cond_t *__cond) 
# 858
{ 
# 859
return __gthrw_pthread_cond_signal(__cond); 
# 860
} 
# 863
static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) 
# 864
{ 
# 865
return __gthrw_pthread_cond_wait(__cond, __mutex); 
# 866
} 
# 869
static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *
# 870
__abs_timeout) 
# 871
{ 
# 872
return __gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout); 
# 873
} 
# 876
static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *
# 877
__mutex) 
# 878
{ 
# 879
return __gthread_cond_wait(__cond, __mutex); 
# 880
} 
# 883
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) 
# 884
{ 
# 885
return __gthrw_pthread_cond_destroy(__cond); 
# 886
} 
# 151 "/usr/include/x86_64-linux-gnu/c++/9/bits/gthr.h" 3
#pragma GCC visibility pop
# 32 "/usr/include/x86_64-linux-gnu/c++/9/bits/atomic_word.h" 3
typedef int _Atomic_word; 
# 38 "/usr/include/c++/9/ext/atomicity.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 48
static inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val) 
# 49
{ return __atomic_fetch_add(__mem, __val, 4); } 
# 52
static inline void __atomic_add(volatile _Atomic_word *__mem, int __val) 
# 53
{ __atomic_fetch_add(__mem, __val, 4); } 
# 65 "/usr/include/c++/9/ext/atomicity.h" 3
static inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val) 
# 66
{ 
# 67
_Atomic_word __result = *__mem; 
# 68
(*__mem) += __val; 
# 69
return __result; 
# 70
} 
# 73
static inline void __atomic_add_single(_Atomic_word *__mem, int __val) 
# 74
{ (*__mem) += __val; } 
# 77
__attribute((__unused__)) static inline _Atomic_word 
# 78
__exchange_and_add_dispatch(_Atomic_word *__mem, int __val) 
# 79
{ 
# 81
if (__gthread_active_p()) { 
# 82
return __exchange_and_add(__mem, __val); } else { 
# 84
return __exchange_and_add_single(__mem, __val); }  
# 88
} 
# 91
__attribute((__unused__)) static inline void 
# 92
__atomic_add_dispatch(_Atomic_word *__mem, int __val) 
# 93
{ 
# 95
if (__gthread_active_p()) { 
# 96
__atomic_add(__mem, __val); } else { 
# 98
__atomic_add_single(__mem, __val); }  
# 102
} 
# 105
}
# 40 "/usr/include/c++/9/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 44
using std::size_t;
# 45
using std::ptrdiff_t;
# 57 "/usr/include/c++/9/ext/new_allocator.h" 3
template< class _Tp> 
# 58
class new_allocator { 
# 61
public: typedef std::size_t size_type; 
# 62
typedef std::ptrdiff_t difference_type; 
# 63
typedef _Tp *pointer; 
# 64
typedef const _Tp *const_pointer; 
# 65
typedef _Tp &reference; 
# 66
typedef const _Tp &const_reference; 
# 67
typedef _Tp value_type; 
# 69
template< class _Tp1> 
# 70
struct rebind { 
# 71
typedef new_allocator< _Tp1>  other; }; 
# 76
typedef std::true_type propagate_on_container_move_assignment; 
# 80
new_allocator() noexcept { } 
# 83
new_allocator(const new_allocator &) noexcept { } 
# 85
template< class _Tp1> 
# 87
new_allocator(const new_allocator< _Tp1>  &) noexcept { } 
# 89
~new_allocator() noexcept { } 
# 92
pointer address(reference __x) const noexcept 
# 93
{ return std::__addressof(__x); } 
# 96
const_pointer address(const_reference __x) const noexcept 
# 97
{ return std::__addressof(__x); } 
# 102
pointer allocate(size_type __n, const void * = 0) 
# 103
{ 
# 104
if (__n > max_size()) { 
# 105
std::__throw_bad_alloc(); }  
# 114 "/usr/include/c++/9/ext/new_allocator.h" 3
return static_cast< _Tp *>(::operator new(__n * sizeof(_Tp))); 
# 115
} 
# 119
void deallocate(pointer __p, size_type) 
# 120
{ 
# 128
::operator delete(__p); 
# 129
} 
# 132
size_type max_size() const noexcept 
# 133
{ 
# 135
return ((std::size_t)9223372036854775807L) / sizeof(_Tp); 
# 139
} 
# 142
template< class _Up, class ..._Args> void 
# 144
construct(_Up *__p, _Args &&...__args) noexcept(std::template is_nothrow_constructible< _Up, _Args...> ::value) 
# 146
{ ::new ((void *)__p) _Up(std::forward< _Args> (__args)...); } 
# 148
template< class _Up> void 
# 150
destroy(_Up *__p) noexcept(std::template is_nothrow_destructible< _Up> ::value) 
# 152
{ __p->~_Up(); } 
# 164 "/usr/include/c++/9/ext/new_allocator.h" 3
template< class _Up> friend inline bool 
# 166
operator==(const new_allocator< _Tp>  &, const __gnu_cxx::new_allocator< _Up>  &) noexcept 
# 168
{ return true; } 
# 170
template< class _Up> friend inline bool 
# 172
operator!=(const new_allocator< _Tp>  &, const __gnu_cxx::new_allocator< _Up>  &) noexcept 
# 174
{ return false; } 
# 175
}; 
# 178
}
# 36 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h" 3
namespace std { 
# 47 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h" 3
template< class _Tp> using __allocator_base = __gnu_cxx::new_allocator< _Tp> ; 
# 49
}
# 57 "/usr/include/c++/9/bits/allocator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 68
template<> class allocator< void>  { 
# 71
public: typedef size_t size_type; 
# 72
typedef ptrdiff_t difference_type; 
# 73
typedef void *pointer; 
# 74
typedef const void *const_pointer; 
# 75
typedef void value_type; 
# 77
template< class _Tp1> 
# 78
struct rebind { 
# 79
typedef std::allocator< _Tp1>  other; }; 
# 84
typedef true_type propagate_on_container_move_assignment; 
# 86
typedef true_type is_always_equal; 
# 88
template< class _Up, class ..._Args> void 
# 90
construct(_Up *__p, _Args &&...__args) noexcept(std::template is_nothrow_constructible< _Up, _Args...> ::value) 
# 92
{ ::new ((void *)__p) _Up(std::forward< _Args> (__args)...); } 
# 94
template< class _Up> void 
# 96
destroy(_Up *__p) noexcept(std::template is_nothrow_destructible< _Up> ::value) 
# 98
{ __p->~_Up(); } 
# 100
}; 
# 110 "/usr/include/c++/9/bits/allocator.h" 3
template< class _Tp> 
# 111
class allocator : public __allocator_base< _Tp>  { 
# 114
public: typedef std::size_t size_type; 
# 115
typedef std::ptrdiff_t difference_type; 
# 116
typedef _Tp *pointer; 
# 117
typedef const _Tp *const_pointer; 
# 118
typedef _Tp &reference; 
# 119
typedef const _Tp &const_reference; 
# 120
typedef _Tp value_type; 
# 122
template< class _Tp1> 
# 123
struct rebind { 
# 124
typedef allocator< _Tp1>  other; }; 
# 129
typedef std::true_type propagate_on_container_move_assignment; 
# 131
typedef std::true_type is_always_equal; 
# 137
allocator() noexcept { } 
# 140
allocator(const allocator &__a) noexcept : std::__allocator_base< _Tp> (__a) 
# 141
{ } 
# 145
allocator &operator=(const allocator &) = default;
# 148
template< class _Tp1> 
# 150
allocator(const allocator< _Tp1>  &) noexcept { } 
# 152
~allocator() noexcept { } 
# 155
friend inline bool operator==(const allocator< _Tp>  &, const allocator< _Tp>  &) noexcept 
# 156
{ return true; } 
# 159
friend inline bool operator!=(const allocator< _Tp>  &, const allocator< _Tp>  &) noexcept 
# 160
{ return false; } 
# 163
}; 
# 165
template< class _T1, class _T2> inline bool 
# 167
operator==(const allocator< _T1>  &, const allocator< _T2>  &) noexcept 
# 169
{ return true; } 
# 171
template< class _T1, class _T2> inline bool 
# 173
operator!=(const allocator< _T1>  &, const allocator< _T2>  &) noexcept 
# 175
{ return false; } 
# 179
template< class _Tp> 
# 180
class allocator< const _Tp>  { 
# 183
public: typedef _Tp value_type; 
# 184
template< class _Up> allocator(const std::allocator< _Up>  &) { } 
# 185
}; 
# 187
template< class _Tp> 
# 188
class allocator< volatile _Tp>  { 
# 191
public: typedef _Tp value_type; 
# 192
template< class _Up> allocator(const std::allocator< _Up>  &) { } 
# 193
}; 
# 195
template< class _Tp> 
# 196
class allocator< const volatile _Tp>  { 
# 199
public: typedef _Tp value_type; 
# 200
template< class _Up> allocator(const std::allocator< _Up>  &) { } 
# 201
}; 
# 208
extern template class allocator< char> ;
# 209
extern template class allocator< wchar_t> ;
# 216
template< class _Alloc, bool  = __is_empty(_Alloc)> 
# 217
struct __alloc_swap { 
# 218
static void _S_do_it(_Alloc &, _Alloc &) noexcept { } }; 
# 220
template< class _Alloc> 
# 221
struct __alloc_swap< _Alloc, false>  { 
# 224
static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept 
# 225
{ 
# 227
if (__one != __two) { 
# 228
swap(__one, __two); }  
# 229
} 
# 230
}; 
# 233
template< class _Alloc, bool  = __is_empty(_Alloc)> 
# 234
struct __alloc_neq { 
# 237
static bool _S_do_it(const _Alloc &, const _Alloc &) 
# 238
{ return false; } 
# 239
}; 
# 241
template< class _Alloc> 
# 242
struct __alloc_neq< _Alloc, false>  { 
# 245
static bool _S_do_it(const _Alloc &__one, const _Alloc &__two) 
# 246
{ return __one != __two; } 
# 247
}; 
# 250
template< class _Tp, bool 
# 251
 = __or_< is_copy_constructible< typename _Tp::value_type> , is_nothrow_move_constructible< typename _Tp::value_type> > ::value> 
# 253
struct __shrink_to_fit_aux { 
# 254
static bool _S_do_it(_Tp &) noexcept { return false; } }; 
# 256
template< class _Tp> 
# 257
struct __shrink_to_fit_aux< _Tp, true>  { 
# 260
static bool _S_do_it(_Tp &__c) noexcept 
# 261
{ 
# 263
try 
# 264
{ 
# 265
_Tp(__make_move_if_noexcept_iterator(__c.begin()), __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator()).swap(__c); 
# 268
return true; 
# 269
} 
# 270
catch (...) 
# 271
{ return false; }  
# 275
} 
# 276
}; 
# 280
}
# 36 "/usr/include/c++/9/bits/cxxabi_forced.h" 3
#pragma GCC visibility push ( default )
# 39
namespace __cxxabiv1 { 
# 48
class __forced_unwind { 
# 50
virtual ~__forced_unwind() throw(); 
# 53
virtual void __pure_dummy() = 0; 
# 54
}; 
# 55
}
# 58
#pragma GCC visibility pop
# 38 "/usr/include/c++/9/bits/ostream_insert.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 42
template< class _CharT, class _Traits> inline void 
# 44
__ostream_write(basic_ostream< _CharT, _Traits>  &__out, const _CharT *
# 45
__s, streamsize __n) 
# 46
{ 
# 47
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 48
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 50
const streamsize __put = __out.rdbuf()->sputn(__s, __n); 
# 51
if (__put != __n) { 
# 52
__out.setstate(__ios_base::badbit); }  
# 53
} 
# 55
template< class _CharT, class _Traits> inline void 
# 57
__ostream_fill(basic_ostream< _CharT, _Traits>  &__out, streamsize __n) 
# 58
{ 
# 59
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 60
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 62
const _CharT __c = __out.fill(); 
# 63
for (; __n > (0); --__n) 
# 64
{ 
# 65
const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c); 
# 66
if (_Traits::eq_int_type(__put, _Traits::eof())) 
# 67
{ 
# 68
__out.setstate(__ios_base::badbit); 
# 69
break; 
# 70
}  
# 71
}  
# 72
} 
# 74
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 76
__ostream_insert(basic_ostream< _CharT, _Traits>  &__out, const _CharT *
# 77
__s, streamsize __n) 
# 78
{ 
# 79
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 80
typedef typename basic_ostream< _CharT, _Traits> ::ios_base __ios_base; 
# 82
typename basic_ostream< _CharT, _Traits> ::sentry __cerb(__out); 
# 83
if (__cerb) 
# 84
{ 
# 85
try 
# 86
{ 
# 87
const streamsize __w = __out.width(); 
# 88
if (__w > __n) 
# 89
{ 
# 90
const bool __left = (__out.flags() & __ios_base::adjustfield) == __ios_base::left; 
# 93
if (!__left) { 
# 94
__ostream_fill(__out, __w - __n); }  
# 95
if (__out.good()) { 
# 96
__ostream_write(__out, __s, __n); }  
# 97
if (__left && __out.good()) { 
# 98
__ostream_fill(__out, __w - __n); }  
# 99
} else { 
# 101
__ostream_write(__out, __s, __n); }  
# 102
__out.width(0); 
# 103
} 
# 104
catch (__cxxabiv1::__forced_unwind &) 
# 105
{ 
# 106
__out._M_setstate(__ios_base::badbit); 
# 107
throw; 
# 108
} 
# 109
catch (...) 
# 110
{ __out._M_setstate(__ios_base::badbit); }  
# 111
}  
# 112
return __out; 
# 113
} 
# 118
extern template basic_ostream< char>  &__ostream_insert(basic_ostream< char>  & __out, const char * __s, streamsize __n);
# 121
extern template basic_ostream< wchar_t>  &__ostream_insert(basic_ostream< wchar_t>  & __out, const wchar_t * __s, streamsize __n);
# 127
}
# 63 "/usr/include/c++/9/bits/stl_function.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 104 "/usr/include/c++/9/bits/stl_function.h" 3
template< class _Arg, class _Result> 
# 105
struct unary_function { 
# 108
typedef _Arg argument_type; 
# 111
typedef _Result result_type; 
# 112
}; 
# 117
template< class _Arg1, class _Arg2, class _Result> 
# 118
struct binary_function { 
# 121
typedef _Arg1 first_argument_type; 
# 124
typedef _Arg2 second_argument_type; 
# 127
typedef _Result result_type; 
# 128
}; 
# 144 "/usr/include/c++/9/bits/stl_function.h" 3
struct __is_transparent; 
# 146
template< class _Tp = void> struct plus; 
# 149
template< class _Tp = void> struct minus; 
# 152
template< class _Tp = void> struct multiplies; 
# 155
template< class _Tp = void> struct divides; 
# 158
template< class _Tp = void> struct modulus; 
# 161
template< class _Tp = void> struct negate; 
# 166
template< class _Tp> 
# 167
struct plus : public binary_function< _Tp, _Tp, _Tp>  { 
# 171
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 172
{ return __x + __y; } 
# 173
}; 
# 176
template< class _Tp> 
# 177
struct minus : public binary_function< _Tp, _Tp, _Tp>  { 
# 181
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 182
{ return __x - __y; } 
# 183
}; 
# 186
template< class _Tp> 
# 187
struct multiplies : public binary_function< _Tp, _Tp, _Tp>  { 
# 191
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 192
{ return __x * __y; } 
# 193
}; 
# 196
template< class _Tp> 
# 197
struct divides : public binary_function< _Tp, _Tp, _Tp>  { 
# 201
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 202
{ return __x / __y; } 
# 203
}; 
# 206
template< class _Tp> 
# 207
struct modulus : public binary_function< _Tp, _Tp, _Tp>  { 
# 211
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 212
{ return __x % __y; } 
# 213
}; 
# 216
template< class _Tp> 
# 217
struct negate : public unary_function< _Tp, _Tp>  { 
# 221
constexpr _Tp operator()(const _Tp &__x) const 
# 222
{ return -__x; } 
# 223
}; 
# 230
template<> struct plus< void>  { 
# 232
template< class _Tp, class _Up> constexpr auto 
# 235
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) + std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) + std::forward< _Up> (__u))) 
# 238
{ return std::forward< _Tp> (__t) + std::forward< _Up> (__u); } 
# 240
typedef __is_transparent is_transparent; 
# 241
}; 
# 245
template<> struct minus< void>  { 
# 247
template< class _Tp, class _Up> constexpr auto 
# 250
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) - std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) - std::forward< _Up> (__u))) 
# 253
{ return std::forward< _Tp> (__t) - std::forward< _Up> (__u); } 
# 255
typedef __is_transparent is_transparent; 
# 256
}; 
# 260
template<> struct multiplies< void>  { 
# 262
template< class _Tp, class _Up> constexpr auto 
# 265
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) * std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) * std::forward< _Up> (__u))) 
# 268
{ return std::forward< _Tp> (__t) * std::forward< _Up> (__u); } 
# 270
typedef __is_transparent is_transparent; 
# 271
}; 
# 275
template<> struct divides< void>  { 
# 277
template< class _Tp, class _Up> constexpr auto 
# 280
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) / std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) / std::forward< _Up> (__u))) 
# 283
{ return std::forward< _Tp> (__t) / std::forward< _Up> (__u); } 
# 285
typedef __is_transparent is_transparent; 
# 286
}; 
# 290
template<> struct modulus< void>  { 
# 292
template< class _Tp, class _Up> constexpr auto 
# 295
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) % std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) % std::forward< _Up> (__u))) 
# 298
{ return std::forward< _Tp> (__t) % std::forward< _Up> (__u); } 
# 300
typedef __is_transparent is_transparent; 
# 301
}; 
# 305
template<> struct negate< void>  { 
# 307
template< class _Tp> constexpr auto 
# 310
operator()(_Tp &&__t) const noexcept(noexcept((-std::forward< _Tp> (__t))))->__decltype((-std::forward< _Tp> (__t))) 
# 313
{ return -std::forward< _Tp> (__t); } 
# 315
typedef __is_transparent is_transparent; 
# 316
}; 
# 330 "/usr/include/c++/9/bits/stl_function.h" 3
template< class _Tp = void> struct equal_to; 
# 333
template< class _Tp = void> struct not_equal_to; 
# 336
template< class _Tp = void> struct greater; 
# 339
template< class _Tp = void> struct less; 
# 342
template< class _Tp = void> struct greater_equal; 
# 345
template< class _Tp = void> struct less_equal; 
# 350
template< class _Tp> 
# 351
struct equal_to : public binary_function< _Tp, _Tp, bool>  { 
# 355
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const 
# 356
{ return __x == __y; } 
# 357
}; 
# 360
template< class _Tp> 
# 361
struct not_equal_to : public binary_function< _Tp, _Tp, bool>  { 
# 365
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const 
# 366
{ return __x != __y; } 
# 367
}; 
# 370
template< class _Tp> 
# 371
struct greater : public binary_function< _Tp, _Tp, bool>  { 
# 375
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const 
# 376
{ return __x > __y; } 
# 377
}; 
# 380
template< class _Tp> 
# 381
struct less : public binary_function< _Tp, _Tp, bool>  { 
# 385
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const 
# 386
{ return __x < __y; } 
# 387
}; 
# 390
template< class _Tp> 
# 391
struct greater_equal : public binary_function< _Tp, _Tp, bool>  { 
# 395
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const 
# 396
{ return __x >= __y; } 
# 397
}; 
# 400
template< class _Tp> 
# 401
struct less_equal : public binary_function< _Tp, _Tp, bool>  { 
# 405
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const 
# 406
{ return __x <= __y; } 
# 407
}; 
# 410
template< class _Tp> 
# 411
struct greater< _Tp *>  : public binary_function< _Tp *, _Tp *, bool>  { 
# 414
constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept 
# 415
{ 
# 418
if (__builtin_is_constant_evaluated()) { 
# 422
return __x > __y; }  
# 424
return ((unsigned long)__x) > ((unsigned long)__y); 
# 425
} 
# 426
}; 
# 429
template< class _Tp> 
# 430
struct less< _Tp *>  : public binary_function< _Tp *, _Tp *, bool>  { 
# 433
constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept 
# 434
{ 
# 437
if (__builtin_is_constant_evaluated()) { 
# 441
return __x < __y; }  
# 443
return ((unsigned long)__x) < ((unsigned long)__y); 
# 444
} 
# 445
}; 
# 448
template< class _Tp> 
# 449
struct greater_equal< _Tp *>  : public binary_function< _Tp *, _Tp *, bool>  { 
# 452
constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept 
# 453
{ 
# 456
if (__builtin_is_constant_evaluated()) { 
# 460
return __x >= __y; }  
# 462
return ((unsigned long)__x) >= ((unsigned long)__y); 
# 463
} 
# 464
}; 
# 467
template< class _Tp> 
# 468
struct less_equal< _Tp *>  : public binary_function< _Tp *, _Tp *, bool>  { 
# 471
constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept 
# 472
{ 
# 475
if (__builtin_is_constant_evaluated()) { 
# 479
return __x <= __y; }  
# 481
return ((unsigned long)__x) <= ((unsigned long)__y); 
# 482
} 
# 483
}; 
# 488
template<> struct equal_to< void>  { 
# 490
template< class _Tp, class _Up> constexpr auto 
# 492
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) == std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) == std::forward< _Up> (__u))) 
# 495
{ return std::forward< _Tp> (__t) == std::forward< _Up> (__u); } 
# 497
typedef __is_transparent is_transparent; 
# 498
}; 
# 502
template<> struct not_equal_to< void>  { 
# 504
template< class _Tp, class _Up> constexpr auto 
# 506
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) != std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) != std::forward< _Up> (__u))) 
# 509
{ return std::forward< _Tp> (__t) != std::forward< _Up> (__u); } 
# 511
typedef __is_transparent is_transparent; 
# 512
}; 
# 516
template<> struct greater< void>  { 
# 518
template< class _Tp, class _Up> constexpr auto 
# 520
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) > std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) > std::forward< _Up> (__u))) 
# 523
{ 
# 524
return _S_cmp(std::forward< _Tp> (__t), std::forward< _Up> (__u), __ptr_cmp< _Tp, _Up> {}); 
# 526
} 
# 528
template< class _Tp, class _Up> constexpr bool 
# 530
operator()(_Tp *__t, _Up *__u) const noexcept 
# 531
{ return std::greater< common_type_t< _Tp *, _Up *> > {}(__t, __u); } 
# 533
typedef __is_transparent is_transparent; 
# 538
private: 
# 536
template< class _Tp, class _Up> static constexpr decltype(auto) 
# 538
_S_cmp(_Tp &&__t, _Up &&__u, false_type) 
# 539
{ return std::forward< _Tp> (__t) > std::forward< _Up> (__u); } 
# 541
template< class _Tp, class _Up> static constexpr bool 
# 543
_S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept 
# 544
{ 
# 545
return std::greater< const volatile void *> {}(static_cast< const volatile void *>(std::forward< _Tp> (__t)), static_cast< const volatile void *>(std::forward< _Up> (__u))); 
# 548
} 
# 551
template< class _Tp, class _Up, class  = void> 
# 552
struct __not_overloaded2 : public true_type { }; 
# 555
template< class _Tp, class _Up> 
# 556
struct __not_overloaded2< _Tp, _Up, __void_t< __decltype((std::declval< _Tp> ().operator>(std::declval< _Up> ())))> >  : public false_type { 
# 558
}; 
# 561
template< class _Tp, class _Up, class  = void> 
# 562
struct __not_overloaded : public __not_overloaded2< _Tp, _Up>  { }; 
# 565
template< class _Tp, class _Up> 
# 566
struct __not_overloaded< _Tp, _Up, __void_t< __decltype((operator>(std::declval< _Tp> (), std::declval< _Up> ())))> >  : public false_type { 
# 568
}; 
# 570
template< class _Tp, class _Up> using __ptr_cmp = __and_< __not_overloaded< _Tp, _Up> , is_convertible< _Tp, const volatile void *> , is_convertible< _Up, const volatile void *> > ; 
# 574
}; 
# 578
template<> struct less< void>  { 
# 580
template< class _Tp, class _Up> constexpr auto 
# 582
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) < std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) < std::forward< _Up> (__u))) 
# 585
{ 
# 586
return _S_cmp(std::forward< _Tp> (__t), std::forward< _Up> (__u), __ptr_cmp< _Tp, _Up> {}); 
# 588
} 
# 590
template< class _Tp, class _Up> constexpr bool 
# 592
operator()(_Tp *__t, _Up *__u) const noexcept 
# 593
{ return std::less< common_type_t< _Tp *, _Up *> > {}(__t, __u); } 
# 595
typedef __is_transparent is_transparent; 
# 600
private: 
# 598
template< class _Tp, class _Up> static constexpr decltype(auto) 
# 600
_S_cmp(_Tp &&__t, _Up &&__u, false_type) 
# 601
{ return std::forward< _Tp> (__t) < std::forward< _Up> (__u); } 
# 603
template< class _Tp, class _Up> static constexpr bool 
# 605
_S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept 
# 606
{ 
# 607
return std::less< const volatile void *> {}(static_cast< const volatile void *>(std::forward< _Tp> (__t)), static_cast< const volatile void *>(std::forward< _Up> (__u))); 
# 610
} 
# 613
template< class _Tp, class _Up, class  = void> 
# 614
struct __not_overloaded2 : public true_type { }; 
# 617
template< class _Tp, class _Up> 
# 618
struct __not_overloaded2< _Tp, _Up, __void_t< __decltype((std::declval< _Tp> ().operator< (std::declval< _Up> ())))> >  : public false_type { 
# 620
}; 
# 623
template< class _Tp, class _Up, class  = void> 
# 624
struct __not_overloaded : public __not_overloaded2< _Tp, _Up>  { }; 
# 627
template< class _Tp, class _Up> 
# 628
struct __not_overloaded< _Tp, _Up, __void_t< __decltype((operator< (std::declval< _Tp> (), std::declval< _Up> ())))> >  : public false_type { 
# 630
}; 
# 632
template< class _Tp, class _Up> using __ptr_cmp = __and_< __not_overloaded< _Tp, _Up> , is_convertible< _Tp, const volatile void *> , is_convertible< _Up, const volatile void *> > ; 
# 636
}; 
# 640
template<> struct greater_equal< void>  { 
# 642
template< class _Tp, class _Up> constexpr auto 
# 644
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) >= std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) >= std::forward< _Up> (__u))) 
# 647
{ 
# 648
return _S_cmp(std::forward< _Tp> (__t), std::forward< _Up> (__u), __ptr_cmp< _Tp, _Up> {}); 
# 650
} 
# 652
template< class _Tp, class _Up> constexpr bool 
# 654
operator()(_Tp *__t, _Up *__u) const noexcept 
# 655
{ return std::greater_equal< common_type_t< _Tp *, _Up *> > {}(__t, __u); } 
# 657
typedef __is_transparent is_transparent; 
# 662
private: 
# 660
template< class _Tp, class _Up> static constexpr decltype(auto) 
# 662
_S_cmp(_Tp &&__t, _Up &&__u, false_type) 
# 663
{ return std::forward< _Tp> (__t) >= std::forward< _Up> (__u); } 
# 665
template< class _Tp, class _Up> static constexpr bool 
# 667
_S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept 
# 668
{ 
# 669
return std::greater_equal< const volatile void *> {}(static_cast< const volatile void *>(std::forward< _Tp> (__t)), static_cast< const volatile void *>(std::forward< _Up> (__u))); 
# 672
} 
# 675
template< class _Tp, class _Up, class  = void> 
# 676
struct __not_overloaded2 : public true_type { }; 
# 679
template< class _Tp, class _Up> 
# 680
struct __not_overloaded2< _Tp, _Up, __void_t< __decltype((std::declval< _Tp> ().operator>=(std::declval< _Up> ())))> >  : public false_type { 
# 682
}; 
# 685
template< class _Tp, class _Up, class  = void> 
# 686
struct __not_overloaded : public __not_overloaded2< _Tp, _Up>  { }; 
# 689
template< class _Tp, class _Up> 
# 690
struct __not_overloaded< _Tp, _Up, __void_t< __decltype((operator>=(std::declval< _Tp> (), std::declval< _Up> ())))> >  : public false_type { 
# 692
}; 
# 694
template< class _Tp, class _Up> using __ptr_cmp = __and_< __not_overloaded< _Tp, _Up> , is_convertible< _Tp, const volatile void *> , is_convertible< _Up, const volatile void *> > ; 
# 698
}; 
# 702
template<> struct less_equal< void>  { 
# 704
template< class _Tp, class _Up> constexpr auto 
# 706
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) <= std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) <= std::forward< _Up> (__u))) 
# 709
{ 
# 710
return _S_cmp(std::forward< _Tp> (__t), std::forward< _Up> (__u), __ptr_cmp< _Tp, _Up> {}); 
# 712
} 
# 714
template< class _Tp, class _Up> constexpr bool 
# 716
operator()(_Tp *__t, _Up *__u) const noexcept 
# 717
{ return std::less_equal< common_type_t< _Tp *, _Up *> > {}(__t, __u); } 
# 719
typedef __is_transparent is_transparent; 
# 724
private: 
# 722
template< class _Tp, class _Up> static constexpr decltype(auto) 
# 724
_S_cmp(_Tp &&__t, _Up &&__u, false_type) 
# 725
{ return std::forward< _Tp> (__t) <= std::forward< _Up> (__u); } 
# 727
template< class _Tp, class _Up> static constexpr bool 
# 729
_S_cmp(_Tp &&__t, _Up &&__u, true_type) noexcept 
# 730
{ 
# 731
return std::less_equal< const volatile void *> {}(static_cast< const volatile void *>(std::forward< _Tp> (__t)), static_cast< const volatile void *>(std::forward< _Up> (__u))); 
# 734
} 
# 737
template< class _Tp, class _Up, class  = void> 
# 738
struct __not_overloaded2 : public true_type { }; 
# 741
template< class _Tp, class _Up> 
# 742
struct __not_overloaded2< _Tp, _Up, __void_t< __decltype((std::declval< _Tp> ().operator<=(std::declval< _Up> ())))> >  : public false_type { 
# 744
}; 
# 747
template< class _Tp, class _Up, class  = void> 
# 748
struct __not_overloaded : public __not_overloaded2< _Tp, _Up>  { }; 
# 751
template< class _Tp, class _Up> 
# 752
struct __not_overloaded< _Tp, _Up, __void_t< __decltype((operator<=(std::declval< _Tp> (), std::declval< _Up> ())))> >  : public false_type { 
# 754
}; 
# 756
template< class _Tp, class _Up> using __ptr_cmp = __and_< __not_overloaded< _Tp, _Up> , is_convertible< _Tp, const volatile void *> , is_convertible< _Up, const volatile void *> > ; 
# 760
}; 
# 774 "/usr/include/c++/9/bits/stl_function.h" 3
template< class _Tp = void> struct logical_and; 
# 777
template< class _Tp = void> struct logical_or; 
# 780
template< class _Tp = void> struct logical_not; 
# 785
template< class _Tp> 
# 786
struct logical_and : public binary_function< _Tp, _Tp, bool>  { 
# 790
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const 
# 791
{ return __x && __y; } 
# 792
}; 
# 795
template< class _Tp> 
# 796
struct logical_or : public binary_function< _Tp, _Tp, bool>  { 
# 800
constexpr bool operator()(const _Tp &__x, const _Tp &__y) const 
# 801
{ return __x || __y; } 
# 802
}; 
# 805
template< class _Tp> 
# 806
struct logical_not : public unary_function< _Tp, bool>  { 
# 810
constexpr bool operator()(const _Tp &__x) const 
# 811
{ return !__x; } 
# 812
}; 
# 817
template<> struct logical_and< void>  { 
# 819
template< class _Tp, class _Up> constexpr auto 
# 822
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) && std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) && std::forward< _Up> (__u))) 
# 825
{ return std::forward< _Tp> (__t) && std::forward< _Up> (__u); } 
# 827
typedef __is_transparent is_transparent; 
# 828
}; 
# 832
template<> struct logical_or< void>  { 
# 834
template< class _Tp, class _Up> constexpr auto 
# 837
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) || std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) || std::forward< _Up> (__u))) 
# 840
{ return std::forward< _Tp> (__t) || std::forward< _Up> (__u); } 
# 842
typedef __is_transparent is_transparent; 
# 843
}; 
# 847
template<> struct logical_not< void>  { 
# 849
template< class _Tp> constexpr auto 
# 852
operator()(_Tp &&__t) const noexcept(noexcept((!std::forward< _Tp> (__t))))->__decltype((!std::forward< _Tp> (__t))) 
# 855
{ return !std::forward< _Tp> (__t); } 
# 857
typedef __is_transparent is_transparent; 
# 858
}; 
# 863
template< class _Tp = void> struct bit_and; 
# 866
template< class _Tp = void> struct bit_or; 
# 869
template< class _Tp = void> struct bit_xor; 
# 872
template< class _Tp = void> struct bit_not; 
# 878
template< class _Tp> 
# 879
struct bit_and : public binary_function< _Tp, _Tp, _Tp>  { 
# 883
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 884
{ return __x & __y; } 
# 885
}; 
# 887
template< class _Tp> 
# 888
struct bit_or : public binary_function< _Tp, _Tp, _Tp>  { 
# 892
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 893
{ return __x | __y; } 
# 894
}; 
# 896
template< class _Tp> 
# 897
struct bit_xor : public binary_function< _Tp, _Tp, _Tp>  { 
# 901
constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const 
# 902
{ return __x ^ __y; } 
# 903
}; 
# 905
template< class _Tp> 
# 906
struct bit_not : public unary_function< _Tp, _Tp>  { 
# 910
constexpr _Tp operator()(const _Tp &__x) const 
# 911
{ return ~__x; } 
# 912
}; 
# 916
template<> struct bit_and< void>  { 
# 918
template< class _Tp, class _Up> constexpr auto 
# 921
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) & std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) & std::forward< _Up> (__u))) 
# 924
{ return std::forward< _Tp> (__t) & std::forward< _Up> (__u); } 
# 926
typedef __is_transparent is_transparent; 
# 927
}; 
# 930
template<> struct bit_or< void>  { 
# 932
template< class _Tp, class _Up> constexpr auto 
# 935
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) | std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) | std::forward< _Up> (__u))) 
# 938
{ return std::forward< _Tp> (__t) | std::forward< _Up> (__u); } 
# 940
typedef __is_transparent is_transparent; 
# 941
}; 
# 944
template<> struct bit_xor< void>  { 
# 946
template< class _Tp, class _Up> constexpr auto 
# 949
operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept((std::forward< _Tp> (__t) ^ std::forward< _Up> (__u))))->__decltype((std::forward< _Tp> (__t) ^ std::forward< _Up> (__u))) 
# 952
{ return std::forward< _Tp> (__t) ^ std::forward< _Up> (__u); } 
# 954
typedef __is_transparent is_transparent; 
# 955
}; 
# 958
template<> struct bit_not< void>  { 
# 960
template< class _Tp> constexpr auto 
# 963
operator()(_Tp &&__t) const noexcept(noexcept((~std::forward< _Tp> (__t))))->__decltype((~std::forward< _Tp> (__t))) 
# 966
{ return ~std::forward< _Tp> (__t); } 
# 968
typedef __is_transparent is_transparent; 
# 969
}; 
# 1002 "/usr/include/c++/9/bits/stl_function.h" 3
template< class _Predicate> 
# 1003
class unary_negate : public unary_function< typename _Predicate::argument_type, bool>  { 
# 1007
protected: _Predicate _M_pred; 
# 1012
public: constexpr explicit unary_negate(const _Predicate &__x) : _M_pred(__x) { } 
# 1016
constexpr bool operator()(const typename _Predicate::argument_type &__x) const 
# 1017
{ return !(_M_pred)(__x); } 
# 1018
}; 
# 1021
template< class _Predicate> constexpr unary_negate< _Predicate>  
# 1024
not1(const _Predicate &__pred) 
# 1025
{ return ((unary_negate< _Predicate> )(__pred)); } 
# 1028
template< class _Predicate> 
# 1029
class binary_negate : public binary_function< typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool>  { 
# 1034
protected: _Predicate _M_pred; 
# 1039
public: constexpr explicit binary_negate(const _Predicate &__x) : _M_pred(__x) { } 
# 1043
constexpr bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &
# 1044
__y) const 
# 1045
{ return !(_M_pred)(__x, __y); } 
# 1046
}; 
# 1049
template< class _Predicate> constexpr binary_negate< _Predicate>  
# 1052
not2(const _Predicate &__pred) 
# 1053
{ return ((binary_negate< _Predicate> )(__pred)); } 
# 1079 "/usr/include/c++/9/bits/stl_function.h" 3
template< class _Arg, class _Result> 
# 1080
class pointer_to_unary_function : public unary_function< _Arg, _Result>  { 
# 1083
protected: _Result (*_M_ptr)(_Arg); 
# 1086
public: pointer_to_unary_function() { } 
# 1089
explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) 
# 1090
{ } 
# 1093
_Result operator()(_Arg __x) const 
# 1094
{ return (_M_ptr)(__x); } 
# 1095
}; 
# 1098
template< class _Arg, class _Result> inline pointer_to_unary_function< _Arg, _Result>  
# 1100
ptr_fun(_Result (*__x)(_Arg)) 
# 1101
{ return ((pointer_to_unary_function< _Arg, _Result> )(__x)); } 
# 1104
template< class _Arg1, class _Arg2, class _Result> 
# 1105
class pointer_to_binary_function : public binary_function< _Arg1, _Arg2, _Result>  { 
# 1109
protected: _Result (*_M_ptr)(_Arg1, _Arg2); 
# 1112
public: pointer_to_binary_function() { } 
# 1115
explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x) 
# 1116
{ } 
# 1119
_Result operator()(_Arg1 __x, _Arg2 __y) const 
# 1120
{ return (_M_ptr)(__x, __y); } 
# 1121
}; 
# 1124
template< class _Arg1, class _Arg2, class _Result> inline pointer_to_binary_function< _Arg1, _Arg2, _Result>  
# 1126
ptr_fun(_Result (*__x)(_Arg1, _Arg2)) 
# 1127
{ return ((pointer_to_binary_function< _Arg1, _Arg2, _Result> )(__x)); } 
# 1130
template< class _Tp> 
# 1131
struct _Identity : public unary_function< _Tp, _Tp>  { 
# 1135
_Tp &operator()(_Tp &__x) const 
# 1136
{ return __x; } 
# 1139
const _Tp &operator()(const _Tp &__x) const 
# 1140
{ return __x; } 
# 1141
}; 
# 1144
template< class _Tp> struct _Identity< const _Tp>  : public std::_Identity< _Tp>  { }; 
# 1146
template< class _Pair> 
# 1147
struct _Select1st : public unary_function< _Pair, typename _Pair::first_type>  { 
# 1151
typename _Pair::first_type &operator()(_Pair &__x) const 
# 1152
{ return __x.first; } 
# 1155
const typename _Pair::first_type &operator()(const _Pair &__x) const 
# 1156
{ return __x.first; } 
# 1159
template< class _Pair2> typename _Pair2::first_type &
# 1161
operator()(_Pair2 &__x) const 
# 1162
{ return __x.first; } 
# 1164
template< class _Pair2> const typename _Pair2::first_type &
# 1166
operator()(const _Pair2 &__x) const 
# 1167
{ return __x.first; } 
# 1169
}; 
# 1171
template< class _Pair> 
# 1172
struct _Select2nd : public unary_function< _Pair, typename _Pair::second_type>  { 
# 1176
typename _Pair::second_type &operator()(_Pair &__x) const 
# 1177
{ return __x.second; } 
# 1180
const typename _Pair::second_type &operator()(const _Pair &__x) const 
# 1181
{ return __x.second; } 
# 1182
}; 
# 1202 "/usr/include/c++/9/bits/stl_function.h" 3
template< class _Ret, class _Tp> 
# 1203
class mem_fun_t : public unary_function< _Tp *, _Ret>  { 
# 1207
public: explicit mem_fun_t(_Ret (_Tp::*__pf)(void)) : _M_f(__pf) 
# 1208
{ } 
# 1211
_Ret operator()(_Tp *__p) const 
# 1212
{ return (__p->*(_M_f))(); } 
# 1215
private: _Ret (_Tp::*_M_f)(void); 
# 1216
}; 
# 1220
template< class _Ret, class _Tp> 
# 1221
class const_mem_fun_t : public unary_function< const _Tp *, _Ret>  { 
# 1225
public: explicit const_mem_fun_t(_Ret (_Tp::*__pf)(void) const) : _M_f(__pf) 
# 1226
{ } 
# 1229
_Ret operator()(const _Tp *__p) const 
# 1230
{ return (__p->*(_M_f))(); } 
# 1233
private: _Ret (_Tp::*_M_f)(void) const; 
# 1234
}; 
# 1238
template< class _Ret, class _Tp> 
# 1239
class mem_fun_ref_t : public unary_function< _Tp, _Ret>  { 
# 1243
public: explicit mem_fun_ref_t(_Ret (_Tp::*__pf)(void)) : _M_f(__pf) 
# 1244
{ } 
# 1247
_Ret operator()(_Tp &__r) const 
# 1248
{ return (__r.*(_M_f))(); } 
# 1251
private: _Ret (_Tp::*_M_f)(void); 
# 1252
}; 
# 1256
template< class _Ret, class _Tp> 
# 1257
class const_mem_fun_ref_t : public unary_function< _Tp, _Ret>  { 
# 1261
public: explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)(void) const) : _M_f(__pf) 
# 1262
{ } 
# 1265
_Ret operator()(const _Tp &__r) const 
# 1266
{ return (__r.*(_M_f))(); } 
# 1269
private: _Ret (_Tp::*_M_f)(void) const; 
# 1270
}; 
# 1274
template< class _Ret, class _Tp, class _Arg> 
# 1275
class mem_fun1_t : public binary_function< _Tp *, _Arg, _Ret>  { 
# 1279
public: explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) 
# 1280
{ } 
# 1283
_Ret operator()(_Tp *__p, _Arg __x) const 
# 1284
{ return (__p->*(_M_f))(__x); } 
# 1287
private: _Ret (_Tp::*_M_f)(_Arg); 
# 1288
}; 
# 1292
template< class _Ret, class _Tp, class _Arg> 
# 1293
class const_mem_fun1_t : public binary_function< const _Tp *, _Arg, _Ret>  { 
# 1297
public: explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) 
# 1298
{ } 
# 1301
_Ret operator()(const _Tp *__p, _Arg __x) const 
# 1302
{ return (__p->*(_M_f))(__x); } 
# 1305
private: _Ret (_Tp::*_M_f)(_Arg) const; 
# 1306
}; 
# 1310
template< class _Ret, class _Tp, class _Arg> 
# 1311
class mem_fun1_ref_t : public binary_function< _Tp, _Arg, _Ret>  { 
# 1315
public: explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) 
# 1316
{ } 
# 1319
_Ret operator()(_Tp &__r, _Arg __x) const 
# 1320
{ return (__r.*(_M_f))(__x); } 
# 1323
private: _Ret (_Tp::*_M_f)(_Arg); 
# 1324
}; 
# 1328
template< class _Ret, class _Tp, class _Arg> 
# 1329
class const_mem_fun1_ref_t : public binary_function< _Tp, _Arg, _Ret>  { 
# 1333
public: explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) 
# 1334
{ } 
# 1337
_Ret operator()(const _Tp &__r, _Arg __x) const 
# 1338
{ return (__r.*(_M_f))(__x); } 
# 1341
private: _Ret (_Tp::*_M_f)(_Arg) const; 
# 1342
}; 
# 1346
template< class _Ret, class _Tp> inline mem_fun_t< _Ret, _Tp>  
# 1348
mem_fun(_Ret (_Tp::*__f)(void)) 
# 1349
{ return ((mem_fun_t< _Ret, _Tp> )(__f)); } 
# 1351
template< class _Ret, class _Tp> inline const_mem_fun_t< _Ret, _Tp>  
# 1353
mem_fun(_Ret (_Tp::*__f)(void) const) 
# 1354
{ return ((const_mem_fun_t< _Ret, _Tp> )(__f)); } 
# 1356
template< class _Ret, class _Tp> inline mem_fun_ref_t< _Ret, _Tp>  
# 1358
mem_fun_ref(_Ret (_Tp::*__f)(void)) 
# 1359
{ return ((mem_fun_ref_t< _Ret, _Tp> )(__f)); } 
# 1361
template< class _Ret, class _Tp> inline const_mem_fun_ref_t< _Ret, _Tp>  
# 1363
mem_fun_ref(_Ret (_Tp::*__f)(void) const) 
# 1364
{ return ((const_mem_fun_ref_t< _Ret, _Tp> )(__f)); } 
# 1366
template< class _Ret, class _Tp, class _Arg> inline mem_fun1_t< _Ret, _Tp, _Arg>  
# 1368
mem_fun(_Ret (_Tp::*__f)(_Arg)) 
# 1369
{ return ((mem_fun1_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1371
template< class _Ret, class _Tp, class _Arg> inline const_mem_fun1_t< _Ret, _Tp, _Arg>  
# 1373
mem_fun(_Ret (_Tp::*__f)(_Arg) const) 
# 1374
{ return ((const_mem_fun1_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1376
template< class _Ret, class _Tp, class _Arg> inline mem_fun1_ref_t< _Ret, _Tp, _Arg>  
# 1378
mem_fun_ref(_Ret (_Tp::*__f)(_Arg)) 
# 1379
{ return ((mem_fun1_ref_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1381
template< class _Ret, class _Tp, class _Arg> inline const_mem_fun1_ref_t< _Ret, _Tp, _Arg>  
# 1383
mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const) 
# 1384
{ return ((const_mem_fun1_ref_t< _Ret, _Tp, _Arg> )(__f)); } 
# 1389
}
# 60 "/usr/include/c++/9/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 63
namespace std __attribute((__visibility__("default"))) { 
# 107 "/usr/include/c++/9/backward/binders.h" 3
template< class _Operation> 
# 108
class binder1st : public unary_function< typename _Operation::second_argument_type, typename _Operation::result_type>  { 
# 113
protected: _Operation op; 
# 114
typename _Operation::first_argument_type value; 
# 117
public: binder1st(const _Operation &__x, const typename _Operation::first_argument_type &
# 118
__y) : op(__x), value(__y) 
# 119
{ } 
# 122
typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const 
# 123
{ return (op)(value, __x); } 
# 128
typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const 
# 129
{ return (op)(value, __x); } 
# 130
} __attribute((__deprecated__)); 
# 133
template< class _Operation, class _Tp> inline binder1st< _Operation>  
# 135
bind1st(const _Operation &__fn, const _Tp &__x) 
# 136
{ 
# 137
typedef typename _Operation::first_argument_type _Arg1_type; 
# 138
return binder1st< _Operation> (__fn, (_Arg1_type)__x); 
# 139
} 
# 142
template< class _Operation> 
# 143
class binder2nd : public unary_function< typename _Operation::first_argument_type, typename _Operation::result_type>  { 
# 148
protected: _Operation op; 
# 149
typename _Operation::second_argument_type value; 
# 152
public: binder2nd(const _Operation &__x, const typename _Operation::second_argument_type &
# 153
__y) : op(__x), value(__y) 
# 154
{ } 
# 157
typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const 
# 158
{ return (op)(__x, value); } 
# 163
typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const 
# 164
{ return (op)(__x, value); } 
# 165
} __attribute((__deprecated__)); 
# 168
template< class _Operation, class _Tp> inline binder2nd< _Operation>  
# 170
bind2nd(const _Operation &__fn, const _Tp &__x) 
# 171
{ 
# 172
typedef typename _Operation::second_argument_type _Arg2_type; 
# 173
return binder2nd< _Operation> (__fn, (_Arg2_type)__x); 
# 174
} 
# 178
}
# 180
#pragma GCC diagnostic pop
# 39 "/usr/include/c++/9/initializer_list" 3
#pragma GCC visibility push ( default )
# 43
namespace std { 
# 46
template< class _E> 
# 47
class initializer_list { 
# 50
public: typedef _E value_type; 
# 51
typedef const _E &reference; 
# 52
typedef const _E &const_reference; 
# 53
typedef size_t size_type; 
# 54
typedef const _E *iterator; 
# 55
typedef const _E *const_iterator; 
# 58
private: iterator _M_array; 
# 59
size_type _M_len; 
# 62
constexpr initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l) 
# 63
{ } 
# 66
public: constexpr initializer_list() noexcept : _M_array((0)), _M_len((0)) 
# 67
{ } 
# 71
constexpr size_type size() const noexcept { return _M_len; } 
# 75
constexpr const_iterator begin() const noexcept { return _M_array; } 
# 79
constexpr const_iterator end() const noexcept { return begin() + size(); } 
# 80
}; 
# 87
template< class _Tp> constexpr const _Tp *
# 89
begin(initializer_list< _Tp>  __ils) noexcept 
# 90
{ return __ils.begin(); } 
# 97
template< class _Tp> constexpr const _Tp *
# 99
end(initializer_list< _Tp>  __ils) noexcept 
# 100
{ return __ils.end(); } 
# 101
}
# 103
#pragma GCC visibility pop
# 37 "/usr/include/c++/9/bits/range_access.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 46
template< class _Container> inline auto 
# 48
begin(_Container &__cont)->__decltype((__cont.begin())) 
# 49
{ return __cont.begin(); } 
# 56
template< class _Container> inline auto 
# 58
begin(const _Container &__cont)->__decltype((__cont.begin())) 
# 59
{ return __cont.begin(); } 
# 66
template< class _Container> inline auto 
# 68
end(_Container &__cont)->__decltype((__cont.end())) 
# 69
{ return __cont.end(); } 
# 76
template< class _Container> inline auto 
# 78
end(const _Container &__cont)->__decltype((__cont.end())) 
# 79
{ return __cont.end(); } 
# 85
template< class _Tp, size_t _Nm> constexpr _Tp *
# 87
begin(_Tp (&__arr)[_Nm]) noexcept 
# 88
{ return __arr; } 
# 95
template< class _Tp, size_t _Nm> constexpr _Tp *
# 97
end(_Tp (&__arr)[_Nm]) noexcept 
# 98
{ return __arr + _Nm; } 
# 102
template< class _Tp> class valarray; 
# 104
template< class _Tp> _Tp *begin(valarray< _Tp>  &); 
# 105
template< class _Tp> const _Tp *begin(const valarray< _Tp>  &); 
# 106
template< class _Tp> _Tp *end(valarray< _Tp>  &); 
# 107
template< class _Tp> const _Tp *end(const valarray< _Tp>  &); 
# 114
template< class _Container> constexpr auto 
# 116
cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont)))->__decltype((std::begin(__cont))) 
# 118
{ return std::begin(__cont); } 
# 125
template< class _Container> constexpr auto 
# 127
cend(const _Container &__cont) noexcept(noexcept(std::end(__cont)))->__decltype((std::end(__cont))) 
# 129
{ return std::end(__cont); } 
# 136
template< class _Container> inline auto 
# 138
rbegin(_Container &__cont)->__decltype((__cont.rbegin())) 
# 139
{ return __cont.rbegin(); } 
# 146
template< class _Container> inline auto 
# 148
rbegin(const _Container &__cont)->__decltype((__cont.rbegin())) 
# 149
{ return __cont.rbegin(); } 
# 156
template< class _Container> inline auto 
# 158
rend(_Container &__cont)->__decltype((__cont.rend())) 
# 159
{ return __cont.rend(); } 
# 166
template< class _Container> inline auto 
# 168
rend(const _Container &__cont)->__decltype((__cont.rend())) 
# 169
{ return __cont.rend(); } 
# 176
template< class _Tp, size_t _Nm> inline reverse_iterator< _Tp *>  
# 178
rbegin(_Tp (&__arr)[_Nm]) noexcept 
# 179
{ return ((reverse_iterator< _Tp *> )(__arr + _Nm)); } 
# 186
template< class _Tp, size_t _Nm> inline reverse_iterator< _Tp *>  
# 188
rend(_Tp (&__arr)[_Nm]) noexcept 
# 189
{ return ((reverse_iterator< _Tp *> )(__arr)); } 
# 196
template< class _Tp> inline reverse_iterator< const _Tp *>  
# 198
rbegin(initializer_list< _Tp>  __il) noexcept 
# 199
{ return ((reverse_iterator< const _Tp *> )(__il.end())); } 
# 206
template< class _Tp> inline reverse_iterator< const _Tp *>  
# 208
rend(initializer_list< _Tp>  __il) noexcept 
# 209
{ return ((reverse_iterator< const _Tp *> )(__il.begin())); } 
# 216
template< class _Container> inline auto 
# 218
crbegin(const _Container &__cont)->__decltype((std::rbegin(__cont))) 
# 219
{ return std::rbegin(__cont); } 
# 226
template< class _Container> inline auto 
# 228
crend(const _Container &__cont)->__decltype((std::rend(__cont))) 
# 229
{ return std::rend(__cont); } 
# 324 "/usr/include/c++/9/bits/range_access.h" 3
}
# 41 "/usr/include/c++/9/bits/alloc_traits.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
struct __allocator_traits_base { 
# 47
template< class _Tp, class _Up, class  = void> 
# 48
struct __rebind : public __replace_first_arg< _Tp, _Up>  { }; 
# 50
template< class _Tp, class _Up> 
# 51
struct __rebind< _Tp, _Up, __void_t< typename _Tp::template rebind< _Up> ::other> >  { 
# 53
using type = typename _Tp::template rebind< _Up> ::other; }; 
# 57
protected: 
# 56
template< class _Tp> using __pointer = typename _Tp::pointer; 
# 58
template< class _Tp> using __c_pointer = typename _Tp::const_pointer; 
# 60
template< class _Tp> using __v_pointer = typename _Tp::void_pointer; 
# 62
template< class _Tp> using __cv_pointer = typename _Tp::const_void_pointer; 
# 64
template< class _Tp> using __pocca = typename _Tp::propagate_on_container_copy_assignment; 
# 66
template< class _Tp> using __pocma = typename _Tp::propagate_on_container_move_assignment; 
# 68
template< class _Tp> using __pocs = typename _Tp::propagate_on_container_swap; 
# 70
template< class _Tp> using __equal = typename _Tp::is_always_equal; 
# 72
}; 
# 74
template< class _Alloc, class _Up> using __alloc_rebind = typename __allocator_traits_base::__rebind< _Alloc, _Up> ::type; 
# 82
template< class _Alloc> 
# 83
struct allocator_traits : public __allocator_traits_base { 
# 86
typedef _Alloc allocator_type; 
# 88
typedef typename _Alloc::value_type value_type; 
# 95
using pointer = __detected_or_t< value_type *, __pointer, _Alloc> ; 
# 100
private: 
# 99
template< template< class >  class _Func, class _Tp, class  = void> 
# 100
struct _Ptr { 
# 102
using type = typename pointer_traits< pointer> ::template rebind< _Tp> ; 
# 103
}; 
# 105
template< template< class >  class _Func, class _Tp> 
# 106
struct _Ptr< _Func, _Tp, __void_t< _Func< _Alloc> > >  { 
# 108
using type = _Func< _Alloc> ; 
# 109
}; 
# 112
template< class _A2, class _PtrT, class  = void> 
# 113
struct _Diff { 
# 114
using type = typename pointer_traits< _PtrT> ::difference_type; }; 
# 116
template< class _A2, class _PtrT> 
# 117
struct _Diff< _A2, _PtrT, __void_t< typename _A2::difference_type> >  { 
# 118
using type = typename _A2::difference_type; }; 
# 121
template< class _A2, class _DiffT, class  = void> 
# 122
struct _Size : public make_unsigned< _DiffT>  { }; 
# 124
template< class _A2, class _DiffT> 
# 125
struct _Size< _A2, _DiffT, __void_t< typename _A2::size_type> >  { 
# 126
using type = typename _A2::size_type; }; 
# 135
public: using const_pointer = typename _Ptr< __c_pointer, const value_type> ::type; 
# 143
using void_pointer = typename _Ptr< __v_pointer, void> ::type; 
# 151
using const_void_pointer = typename _Ptr< __cv_pointer, const void> ::type; 
# 159
using difference_type = typename _Diff< _Alloc, pointer> ::type; 
# 167
using size_type = typename _Size< _Alloc, difference_type> ::type; 
# 175
using propagate_on_container_copy_assignment = __detected_or_t< false_type, __pocca, _Alloc> ; 
# 184
using propagate_on_container_move_assignment = __detected_or_t< false_type, __pocma, _Alloc> ; 
# 193
using propagate_on_container_swap = __detected_or_t< false_type, __pocs, _Alloc> ; 
# 202
using is_always_equal = __detected_or_t< typename is_empty< _Alloc> ::type, __equal, _Alloc> ; 
# 205
template< class _Tp> using rebind_alloc = __alloc_rebind< _Alloc, _Tp> ; 
# 207
template< class _Tp> using rebind_traits = allocator_traits< rebind_alloc< _Tp> > ; 
# 213
private: 
# 211
template< class _Alloc2> static auto 
# 213
_S_allocate(_Alloc2 &__a, size_type __n, const_void_pointer __hint, int)->__decltype((__a.allocate(__n, __hint))) 
# 215
{ return __a.allocate(__n, __hint); } 
# 217
template< class _Alloc2> static pointer 
# 219
_S_allocate(_Alloc2 &__a, size_type __n, const_void_pointer, ...) 
# 220
{ return __a.allocate(__n); } 
# 222
template< class _Tp, class ..._Args> 
# 223
struct __construct_helper { 
# 225
template< class _Alloc2, class 
# 226
 = __decltype((std::declval< _Alloc2 *> ()->construct(std::declval< _Tp *> (), std::declval< _Args> ()...)))> static true_type 
# 225
__test(int); 
# 230
template< class > static false_type __test(...); 
# 233
using type = __decltype((__test< _Alloc> (0))); 
# 234
}; 
# 236
template< class _Tp, class ..._Args> using __has_construct = typename __construct_helper< _Tp, _Args...> ::type; 
# 240
template< class _Tp, class ..._Args> static _Require< __has_construct< _Tp, _Args...> >  
# 242
_S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward< _Args> (__args)...))) 
# 244
{ __a.construct(__p, std::forward< _Args> (__args)...); } 
# 246
template< class _Tp, class ..._Args> static _Require< __and_< __not_< __has_construct< _Tp, _Args...> > , is_constructible< _Tp, _Args...> > >  
# 250
_S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(std::template is_nothrow_constructible< _Tp, _Args...> ::value) 
# 252
{ ::new ((void *)__p) _Tp(std::forward< _Args> (__args)...); } 
# 254
template< class _Alloc2, class _Tp> static auto 
# 256
_S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p)))->__decltype((__a.destroy(__p))) 
# 259
{ __a.destroy(__p); } 
# 261
template< class _Alloc2, class _Tp> static void 
# 263
_S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(std::template is_nothrow_destructible< _Tp> ::value) 
# 265
{ __p->~_Tp(); } 
# 267
template< class _Alloc2> static auto 
# 269
_S_max_size(_Alloc2 &__a, int)->__decltype((__a.max_size())) 
# 271
{ return __a.max_size(); } 
# 273
template< class _Alloc2> static size_type 
# 275
_S_max_size(_Alloc2 &, ...) 
# 276
{ 
# 279
return __gnu_cxx::template __numeric_traits< size_type> ::__max / sizeof(value_type); 
# 281
} 
# 283
template< class _Alloc2> static auto 
# 285
_S_select(_Alloc2 &__a, int)->__decltype((__a.select_on_container_copy_construction())) 
# 287
{ return __a.select_on_container_copy_construction(); } 
# 289
template< class _Alloc2> static _Alloc2 
# 291
_S_select(_Alloc2 &__a, ...) 
# 292
{ return __a; } 
# 304 "/usr/include/c++/9/bits/alloc_traits.h" 3
public: static pointer allocate(_Alloc &__a, size_type __n) 
# 305
{ return __a.allocate(__n); } 
# 319 "/usr/include/c++/9/bits/alloc_traits.h" 3
static pointer allocate(_Alloc &__a, size_type __n, const_void_pointer __hint) 
# 320
{ return _S_allocate(__a, __n, __hint, 0); } 
# 331 "/usr/include/c++/9/bits/alloc_traits.h" 3
static void deallocate(_Alloc &__a, pointer __p, size_type __n) 
# 332
{ __a.deallocate(__p, __n); } 
# 345 "/usr/include/c++/9/bits/alloc_traits.h" 3
template< class _Tp, class ..._Args> static auto 
# 346
construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward< _Args> (__args)...)))->__decltype((_S_construct(__a, __p, std::forward< _Args> (__args)...))) 
# 350
{ _S_construct(__a, __p, std::forward< _Args> (__args)...); } 
# 360 "/usr/include/c++/9/bits/alloc_traits.h" 3
template< class _Tp> static void 
# 361
destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0))) 
# 363
{ _S_destroy(__a, __p, 0); } 
# 373 "/usr/include/c++/9/bits/alloc_traits.h" 3
static size_type max_size(const _Alloc &__a) noexcept 
# 374
{ return _S_max_size(__a, 0); } 
# 385 "/usr/include/c++/9/bits/alloc_traits.h" 3
static _Alloc select_on_container_copy_construction(const _Alloc &__rhs) 
# 386
{ return _S_select(__rhs, 0); } 
# 387
}; 
# 390
template< class _Tp> 
# 391
struct allocator_traits< allocator< _Tp> >  { 
# 394
using allocator_type = allocator< _Tp> ; 
# 396
using value_type = _Tp; 
# 399
using pointer = _Tp *; 
# 402
using const_pointer = const _Tp *; 
# 405
using void_pointer = void *; 
# 408
using const_void_pointer = const void *; 
# 411
using difference_type = ptrdiff_t; 
# 414
using size_type = size_t; 
# 417
using propagate_on_container_copy_assignment = false_type; 
# 420
using propagate_on_container_move_assignment = true_type; 
# 423
using propagate_on_container_swap = false_type; 
# 426
using is_always_equal = true_type; 
# 428
template< class _Up> using rebind_alloc = allocator< _Up> ; 
# 431
template< class _Up> using rebind_traits = std::allocator_traits< allocator< _Up> > ; 
# 442 "/usr/include/c++/9/bits/alloc_traits.h" 3
static pointer allocate(allocator_type &__a, size_type __n) 
# 443
{ return __a.allocate(__n); } 
# 456 "/usr/include/c++/9/bits/alloc_traits.h" 3
static pointer allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) 
# 457
{ return __a.allocate(__n, __hint); } 
# 468 "/usr/include/c++/9/bits/alloc_traits.h" 3
static void deallocate(allocator_type &__a, pointer __p, size_type __n) 
# 469
{ __a.deallocate(__p, __n); } 
# 479 "/usr/include/c++/9/bits/alloc_traits.h" 3
template< class _Up, class ..._Args> static void 
# 481
construct(allocator_type &__a, _Up *__p, _Args &&...__args) noexcept(std::template is_nothrow_constructible< _Up, _Args...> ::value) 
# 483
{ __a.construct(__p, std::forward< _Args> (__args)...); } 
# 492 "/usr/include/c++/9/bits/alloc_traits.h" 3
template< class _Up> static void 
# 494
destroy(allocator_type &__a, _Up *__p) noexcept(noexcept(__a.destroy(__p))) 
# 496
{ __a.destroy(__p); } 
# 504
static size_type max_size(const allocator_type &__a) noexcept 
# 505
{ return __a.max_size(); } 
# 513
static allocator_type select_on_container_copy_construction(const allocator_type &__rhs) 
# 514
{ return __rhs; } 
# 515
}; 
# 518
template< class _Alloc> inline void 
# 520
__do_alloc_on_copy(_Alloc &__one, const _Alloc &__two, true_type) 
# 521
{ __one = __two; } 
# 523
template< class _Alloc> inline void 
# 525
__do_alloc_on_copy(_Alloc &, const _Alloc &, false_type) 
# 526
{ } 
# 528
template< class _Alloc> inline void 
# 529
__alloc_on_copy(_Alloc &__one, const _Alloc &__two) 
# 530
{ 
# 531
typedef allocator_traits< _Alloc>  __traits; 
# 532
typedef typename allocator_traits< _Alloc> ::propagate_on_container_copy_assignment __pocca; 
# 533
__do_alloc_on_copy(__one, __two, __pocca()); 
# 534
} 
# 536
template< class _Alloc> inline _Alloc 
# 537
__alloc_on_copy(const _Alloc &__a) 
# 538
{ 
# 539
typedef allocator_traits< _Alloc>  __traits; 
# 540
return __traits::select_on_container_copy_construction(__a); 
# 541
} 
# 543
template< class _Alloc> inline void 
# 544
__do_alloc_on_move(_Alloc &__one, _Alloc &__two, true_type) 
# 545
{ __one = std::move(__two); } 
# 547
template< class _Alloc> inline void 
# 548
__do_alloc_on_move(_Alloc &, _Alloc &, false_type) 
# 549
{ } 
# 551
template< class _Alloc> inline void 
# 552
__alloc_on_move(_Alloc &__one, _Alloc &__two) 
# 553
{ 
# 554
typedef allocator_traits< _Alloc>  __traits; 
# 555
typedef typename allocator_traits< _Alloc> ::propagate_on_container_move_assignment __pocma; 
# 556
__do_alloc_on_move(__one, __two, __pocma()); 
# 557
} 
# 559
template< class _Alloc> inline void 
# 560
__do_alloc_on_swap(_Alloc &__one, _Alloc &__two, true_type) 
# 561
{ 
# 562
using std::swap;
# 563
swap(__one, __two); 
# 564
} 
# 566
template< class _Alloc> inline void 
# 567
__do_alloc_on_swap(_Alloc &, _Alloc &, false_type) 
# 568
{ } 
# 570
template< class _Alloc> inline void 
# 571
__alloc_on_swap(_Alloc &__one, _Alloc &__two) 
# 572
{ 
# 573
typedef allocator_traits< _Alloc>  __traits; 
# 574
typedef typename allocator_traits< _Alloc> ::propagate_on_container_swap __pocs; 
# 575
__do_alloc_on_swap(__one, __two, __pocs()); 
# 576
} 
# 578
template< class _Alloc, class _Tp, class 
# 579
_ValueT = __remove_cvref_t< typename _Alloc::value_type> , class 
# 580
 = void> 
# 581
struct __is_alloc_insertable_impl : public false_type { 
# 583
}; 
# 585
template< class _Alloc, class _Tp, class _ValueT> 
# 586
struct __is_alloc_insertable_impl< _Alloc, _Tp, _ValueT, __void_t< __decltype((allocator_traits< _Alloc> ::construct(std::declval< _Alloc &> (), std::declval< _ValueT *> (), std::declval< _Tp> ())))> >  : public true_type { 
# 591
}; 
# 596
template< class _Alloc> 
# 597
struct __is_copy_insertable : public __is_alloc_insertable_impl< _Alloc, const typename _Alloc::value_type &> ::type { 
# 600
}; 
# 603
template< class _Tp> 
# 604
struct __is_copy_insertable< allocator< _Tp> >  : public is_copy_constructible< _Tp>  { 
# 606
}; 
# 611
template< class _Alloc> 
# 612
struct __is_move_insertable : public __is_alloc_insertable_impl< _Alloc, typename _Alloc::value_type> ::type { 
# 614
}; 
# 617
template< class _Tp> 
# 618
struct __is_move_insertable< allocator< _Tp> >  : public is_move_constructible< _Tp>  { 
# 620
}; 
# 623
template< class _Alloc, class  = void> 
# 624
struct __is_allocator : public false_type { }; 
# 626
template< class _Alloc> 
# 627
struct __is_allocator< _Alloc, __void_t< typename _Alloc::value_type, __decltype((std::declval< _Alloc &> ().allocate((unsigned long)0UL)))> >  : public true_type { 
# 630
}; 
# 632
template< class _Alloc> using _RequireAllocator = typename enable_if< __is_allocator< _Alloc> ::value, _Alloc> ::type; 
# 636
template< class _Alloc> using _RequireNotAllocator = typename enable_if< !__is_allocator< _Alloc> ::value, _Alloc> ::type; 
# 641
}
# 41 "/usr/include/c++/9/ext/alloc_traits.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 49
template< class _Alloc, class  = typename _Alloc::value_type> 
# 50
struct __alloc_traits : public std::allocator_traits< _Alloc>  { 
# 55
typedef _Alloc allocator_type; 
# 57
typedef std::allocator_traits< _Alloc>  _Base_type; 
# 58
typedef typename std::allocator_traits< _Alloc> ::value_type value_type; 
# 59
typedef typename std::allocator_traits< _Alloc> ::pointer pointer; 
# 60
typedef typename std::allocator_traits< _Alloc> ::const_pointer const_pointer; 
# 61
typedef typename std::allocator_traits< _Alloc> ::size_type size_type; 
# 62
typedef typename std::allocator_traits< _Alloc> ::difference_type difference_type; 
# 64
typedef value_type &reference; 
# 65
typedef const value_type &const_reference; 
# 66
using std::allocator_traits< _Alloc> ::allocate;
# 67
using std::allocator_traits< _Alloc> ::deallocate;
# 68
using std::allocator_traits< _Alloc> ::construct;
# 69
using std::allocator_traits< _Alloc> ::destroy;
# 70
using std::allocator_traits< _Alloc> ::max_size;
# 74
private: 
# 73
template< class _Ptr> using __is_custom_pointer = std::__and_< std::is_same< pointer, _Ptr> , std::__not_< std::is_pointer< _Ptr> > > ; 
# 82
public: 
# 80
template< class _Ptr, class ..._Args> static typename std::enable_if< __is_custom_pointer< _Ptr> ::value> ::type 
# 82
construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward< _Args> (__args)...))) 
# 85
{ 
# 86
_Base_type::construct(__a, std::__to_address(__p), std::forward< _Args> (__args)...); 
# 88
} 
# 91
template< class _Ptr> static typename std::enable_if< __is_custom_pointer< _Ptr> ::value> ::type 
# 93
destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p)))) 
# 95
{ _Base_type::destroy(__a, std::__to_address(__p)); } 
# 97
static _Alloc _S_select_on_copy(const _Alloc &__a) 
# 98
{ return _Base_type::select_on_container_copy_construction(__a); } 
# 100
static void _S_on_swap(_Alloc &__a, _Alloc &__b) 
# 101
{ std::__alloc_on_swap(__a, __b); } 
# 103
static constexpr bool _S_propagate_on_copy_assign() 
# 104
{ return _Base_type::propagate_on_container_copy_assignment::value; } 
# 106
static constexpr bool _S_propagate_on_move_assign() 
# 107
{ return _Base_type::propagate_on_container_move_assignment::value; } 
# 109
static constexpr bool _S_propagate_on_swap() 
# 110
{ return _Base_type::propagate_on_container_swap::value; } 
# 112
static constexpr bool _S_always_equal() 
# 113
{ return _Base_type::is_always_equal::value; } 
# 115
static constexpr bool _S_nothrow_move() 
# 116
{ return (_S_propagate_on_move_assign)() || (_S_always_equal)(); } 
# 118
template< class _Tp> 
# 119
struct rebind { 
# 120
typedef typename std::allocator_traits< _Alloc> ::template rebind_alloc< _Tp>  other; }; 
# 161 "/usr/include/c++/9/ext/alloc_traits.h" 3
}; 
# 164
}
# 51 "/usr/include/c++/9/bits/basic_string.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 61
inline namespace __cxx11 { 
# 80 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> 
# 81
class basic_string { 
# 84
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _CharT> ::other _Char_alloc_type; 
# 85
typedef __gnu_cxx::__alloc_traits< _Char_alloc_type>  _Alloc_traits; 
# 89
public: typedef _Traits traits_type; 
# 90
typedef typename _Traits::char_type value_type; 
# 91
typedef _Char_alloc_type allocator_type; 
# 92
typedef typename __gnu_cxx::__alloc_traits< _Char_alloc_type> ::size_type size_type; 
# 93
typedef typename __gnu_cxx::__alloc_traits< _Char_alloc_type> ::difference_type difference_type; 
# 94
typedef typename __gnu_cxx::__alloc_traits< _Char_alloc_type> ::reference reference; 
# 95
typedef typename __gnu_cxx::__alloc_traits< _Char_alloc_type> ::const_reference const_reference; 
# 96
typedef typename __gnu_cxx::__alloc_traits< _Char_alloc_type> ::pointer pointer; 
# 97
typedef typename __gnu_cxx::__alloc_traits< _Char_alloc_type> ::const_pointer const_pointer; 
# 98
typedef __gnu_cxx::__normal_iterator< pointer, basic_string>  iterator; 
# 100
typedef __gnu_cxx::__normal_iterator< const_pointer, basic_string>  const_iterator; 
# 101
typedef std::reverse_iterator< const_iterator>  const_reverse_iterator; 
# 102
typedef std::reverse_iterator< iterator>  reverse_iterator; 
# 105
static const size_type npos = (static_cast< size_type>(-1)); 
# 112
protected: typedef const_iterator __const_iterator; 
# 154 "/usr/include/c++/9/bits/basic_string.h" 3
private: struct _Alloc_hider : public allocator_type { 
# 160
_Alloc_hider(typename basic_string< _CharT, _Traits, _Alloc> ::pointer __dat, const _Alloc &__a) : basic_string< _CharT, _Traits, _Alloc> ::allocator_type(__a), _M_p(__dat) 
# 161
{ } 
# 163
_Alloc_hider(typename basic_string< _CharT, _Traits, _Alloc> ::pointer __dat, _Alloc &&__a = _Alloc()) : basic_string< _CharT, _Traits, _Alloc> ::allocator_type(std::move(__a)), _M_p(__dat) 
# 164
{ } 
# 167
typename basic_string< _CharT, _Traits, _Alloc> ::pointer _M_p; 
# 168
}; 
# 170
_Alloc_hider _M_dataplus; 
# 171
size_type _M_string_length; 
# 173
enum { _S_local_capacity = (15) / sizeof(_CharT)}; 
# 176
union { 
# 177
_CharT _M_local_buf[_S_local_capacity + 1]; 
# 178
size_type _M_allocated_capacity; 
# 179
}; 
# 182
void _M_data(pointer __p) 
# 183
{ ((_M_dataplus)._M_p) = __p; } 
# 186
void _M_length(size_type __length) 
# 187
{ (_M_string_length) = __length; } 
# 190
pointer _M_data() const 
# 191
{ return (_M_dataplus)._M_p; } 
# 194
pointer _M_local_data() 
# 195
{ 
# 197
return std::template pointer_traits< pointer> ::pointer_to(*(_M_local_buf)); 
# 201
} 
# 204
const_pointer _M_local_data() const 
# 205
{ 
# 207
return std::template pointer_traits< const_pointer> ::pointer_to(*(_M_local_buf)); 
# 211
} 
# 214
void _M_capacity(size_type __capacity) 
# 215
{ (_M_allocated_capacity) = __capacity; } 
# 218
void _M_set_length(size_type __n) 
# 219
{ 
# 220
_M_length(__n); 
# 221
traits_type::assign(_M_data()[__n], _CharT()); 
# 222
} 
# 225
bool _M_is_local() const 
# 226
{ return _M_data() == _M_local_data(); } 
# 230
pointer _M_create(size_type &, size_type); 
# 233
void _M_dispose() 
# 234
{ 
# 235
if (!_M_is_local()) { 
# 236
_M_destroy(_M_allocated_capacity); }  
# 237
} 
# 240
void _M_destroy(size_type __size) throw() 
# 241
{ _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); } 
# 245
template< class _InIterator> void 
# 247
_M_construct_aux(_InIterator __beg, _InIterator __end, __false_type) 
# 249
{ 
# 250
typedef typename iterator_traits< _InIterator> ::iterator_category _Tag; 
# 251
_M_construct(__beg, __end, _Tag()); 
# 252
} 
# 256
template< class _Integer> void 
# 258
_M_construct_aux(_Integer __beg, _Integer __end, __true_type) 
# 259
{ _M_construct_aux_2(static_cast< size_type>(__beg), __end); } 
# 262
void _M_construct_aux_2(size_type __req, _CharT __c) 
# 263
{ _M_construct(__req, __c); } 
# 265
template< class _InIterator> void 
# 267
_M_construct(_InIterator __beg, _InIterator __end) 
# 268
{ 
# 269
typedef typename __is_integer< _InIterator> ::__type _Integral; 
# 270
_M_construct_aux(__beg, __end, _Integral()); 
# 271
} 
# 274
template< class _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, input_iterator_tag); 
# 281
template< class _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, forward_iterator_tag); 
# 287
void _M_construct(size_type __req, _CharT __c); 
# 290
allocator_type &_M_get_allocator() 
# 291
{ return _M_dataplus; } 
# 294
const allocator_type &_M_get_allocator() const 
# 295
{ return _M_dataplus; } 
# 314 "/usr/include/c++/9/bits/basic_string.h" 3
size_type _M_check(size_type __pos, const char *__s) const 
# 315
{ 
# 316
if (__pos > size()) { 
# 317
__throw_out_of_range_fmt("%s: __pos (which is %zu) > this->size() (which is %zu)", __s, __pos, size()); }  
# 320
return __pos; 
# 321
} 
# 324
void _M_check_length(size_type __n1, size_type __n2, const char *__s) const 
# 325
{ 
# 326
if ((max_size() - (size() - __n1)) < __n2) { 
# 327
__throw_length_error(__s); }  
# 328
} 
# 333
size_type _M_limit(size_type __pos, size_type __off) const noexcept 
# 334
{ 
# 335
const bool __testoff = __off < (size() - __pos); 
# 336
return __testoff ? __off : (size() - __pos); 
# 337
} 
# 341
bool _M_disjunct(const _CharT *__s) const noexcept 
# 342
{ 
# 343
return (less< const _CharT *> ()(__s, _M_data()) || less< const _CharT *> ()(_M_data() + size(), __s)); 
# 345
} 
# 350
static void _S_copy(_CharT *__d, const _CharT *__s, size_type __n) 
# 351
{ 
# 352
if (__n == 1) { 
# 353
traits_type::assign(*__d, *__s); } else { 
# 355
traits_type::copy(__d, __s, __n); }  
# 356
} 
# 359
static void _S_move(_CharT *__d, const _CharT *__s, size_type __n) 
# 360
{ 
# 361
if (__n == 1) { 
# 362
traits_type::assign(*__d, *__s); } else { 
# 364
traits_type::move(__d, __s, __n); }  
# 365
} 
# 368
static void _S_assign(_CharT *__d, size_type __n, _CharT __c) 
# 369
{ 
# 370
if (__n == 1) { 
# 371
traits_type::assign(*__d, __c); } else { 
# 373
traits_type::assign(__d, __n, __c); }  
# 374
} 
# 378
template< class _Iterator> static void 
# 380
_S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2) 
# 381
{ 
# 382
for (; __k1 != __k2; (++__k1), ((void)(++__p))) { 
# 383
traits_type::assign(*__p, *__k1); }  
# 384
} 
# 387
static void _S_copy_chars(_CharT *__p, iterator __k1, iterator __k2) noexcept 
# 388
{ _S_copy_chars(__p, __k1.base(), __k2.base()); } 
# 391
static void _S_copy_chars(_CharT *__p, const_iterator __k1, const_iterator __k2) noexcept 
# 393
{ _S_copy_chars(__p, __k1.base(), __k2.base()); } 
# 396
static void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) noexcept 
# 397
{ (_S_copy)(__p, __k1, __k2 - __k1); } 
# 400
static void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) noexcept 
# 402
{ (_S_copy)(__p, __k1, __k2 - __k1); } 
# 405
static int _S_compare(size_type __n1, size_type __n2) noexcept 
# 406
{ 
# 407
const difference_type __d = (difference_type)(__n1 - __n2); 
# 409
if (__d > __gnu_cxx::__numeric_traits< int> ::__max) { 
# 410
return __gnu_cxx::__numeric_traits< int> ::__max; } else { 
# 411
if (__d < __gnu_cxx::__numeric_traits< int> ::__min) { 
# 412
return __gnu_cxx::__numeric_traits< int> ::__min; } else { 
# 414
return (int)__d; }  }  
# 415
} 
# 418
void _M_assign(const basic_string &); 
# 421
void _M_mutate(size_type __pos, size_type __len1, const _CharT * __s, size_type __len2); 
# 425
void _M_erase(size_type __pos, size_type __n); 
# 435
public: basic_string() noexcept(is_nothrow_default_constructible< _Alloc> ::value) : _M_dataplus(_M_local_data()) 
# 438
{ _M_set_length(0); } 
# 444
explicit basic_string(const _Alloc &__a) noexcept : _M_dataplus(_M_local_data(), __a) 
# 446
{ _M_set_length(0); } 
# 452
basic_string(const basic_string &__str) : _M_dataplus(_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator())) 
# 455
{ _M_construct(__str._M_data(), __str._M_data() + __str.length()); } 
# 465 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string(const basic_string &__str, size_type __pos, const _Alloc &
# 466
__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) 
# 468
{ 
# 469
const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string"); 
# 471
_M_construct(__start, __start + __str._M_limit(__pos, npos)); 
# 472
} 
# 480
basic_string(const basic_string &__str, size_type __pos, size_type 
# 481
__n) : _M_dataplus(_M_local_data()) 
# 483
{ 
# 484
const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string"); 
# 486
_M_construct(__start, __start + __str._M_limit(__pos, __n)); 
# 487
} 
# 496 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string(const basic_string &__str, size_type __pos, size_type 
# 497
__n, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a) 
# 499
{ 
# 500
const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string"); 
# 502
_M_construct(__start, __start + __str._M_limit(__pos, __n)); 
# 503
} 
# 514 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string(const _CharT *__s, size_type __n, const _Alloc &
# 515
__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) 
# 517
{ _M_construct(__s, __s + __n); } 
# 529 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) 
# 531
{ _M_construct(__s, (__s) ? __s + traits_type::length(__s) : (__s + npos)); } 
# 544 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string(size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) 
# 546
{ _M_construct(__n, __c); } 
# 556 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string(basic_string &&__str) noexcept : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator())) 
# 558
{ 
# 559
if (__str._M_is_local()) 
# 560
{ 
# 561
traits_type::copy(_M_local_buf, __str._M_local_buf, _S_local_capacity + 1); 
# 563
} else 
# 565
{ 
# 566
_M_data(__str._M_data()); 
# 567
_M_capacity(__str._M_allocated_capacity); 
# 568
}  
# 573
_M_length(__str.length()); 
# 574
__str._M_data(__str._M_local_data()); 
# 575
__str._M_set_length(0); 
# 576
} 
# 583
basic_string(initializer_list< _CharT>  __l, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) 
# 585
{ _M_construct(__l.begin(), __l.end()); } 
# 587
basic_string(const basic_string &__str, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a) 
# 589
{ _M_construct(__str.begin(), __str.end()); } 
# 591
basic_string(basic_string &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()) : _M_dataplus(_M_local_data(), __a) 
# 594
{ 
# 595
if (__str._M_is_local()) 
# 596
{ 
# 597
traits_type::copy(_M_local_buf, __str._M_local_buf, _S_local_capacity + 1); 
# 599
_M_length(__str.length()); 
# 600
__str._M_set_length(0); 
# 601
} else { 
# 602
if (_Alloc_traits::_S_always_equal() || (__str.get_allocator() == __a)) 
# 604
{ 
# 605
_M_data(__str._M_data()); 
# 606
_M_length(__str.length()); 
# 607
_M_capacity(__str._M_allocated_capacity); 
# 608
__str._M_data(__str._M_local_buf); 
# 609
__str._M_set_length(0); 
# 610
} else { 
# 612
_M_construct(__str.begin(), __str.end()); }  }  
# 613
} 
# 624 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _InputIterator, class 
# 625
 = _RequireInputIter< _InputIterator> > 
# 629
basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &
# 630
__a = _Alloc()) : _M_dataplus(_M_local_data(), __a) 
# 632
{ _M_construct(__beg, __end); } 
# 661 "/usr/include/c++/9/bits/basic_string.h" 3
~basic_string() 
# 662
{ _M_dispose(); } 
# 669
basic_string &operator=(const basic_string &__str) 
# 670
{ 
# 672
if (_Alloc_traits::_S_propagate_on_copy_assign()) 
# 673
{ 
# 674
if ((!_Alloc_traits::_S_always_equal()) && (!_M_is_local()) && (_M_get_allocator() != __str._M_get_allocator())) 
# 676
{ 
# 679
if (__str.size() <= _S_local_capacity) 
# 680
{ 
# 681
_M_destroy(_M_allocated_capacity); 
# 682
_M_data(_M_local_data()); 
# 683
_M_set_length(0); 
# 684
} else 
# 686
{ 
# 687
const auto __len = __str.size(); 
# 688
auto __alloc = __str._M_get_allocator(); 
# 690
auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1); 
# 691
_M_destroy(_M_allocated_capacity); 
# 692
_M_data(__ptr); 
# 693
_M_capacity(__len); 
# 694
_M_set_length(__len); 
# 695
}  
# 696
}  
# 697
std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator()); 
# 698
}  
# 700
return this->assign(__str); 
# 701
} 
# 708
basic_string &operator=(const _CharT *__s) 
# 709
{ return this->assign(__s); } 
# 719 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &operator=(_CharT __c) 
# 720
{ 
# 721
this->assign(1, __c); 
# 722
return *this; 
# 723
} 
# 736 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &operator=(basic_string &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) 
# 738
{ 
# 739
if ((!_M_is_local()) && _Alloc_traits::_S_propagate_on_move_assign() && (!_Alloc_traits::_S_always_equal()) && (_M_get_allocator() != __str._M_get_allocator())) 
# 742
{ 
# 744
_M_destroy(_M_allocated_capacity); 
# 745
_M_data(_M_local_data()); 
# 746
_M_set_length(0); 
# 747
}  
# 749
std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator()); 
# 751
if (__str._M_is_local()) 
# 752
{ 
# 754
if (__str.size()) { 
# 755
this->_S_copy(_M_data(), __str._M_data(), __str.size()); }  
# 756
_M_set_length(__str.size()); 
# 757
} else { 
# 758
if ((_Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal()) || (_M_get_allocator() == __str._M_get_allocator())) 
# 761
{ 
# 763
pointer __data = (nullptr); 
# 764
size_type __capacity; 
# 765
if (!_M_is_local()) 
# 766
{ 
# 767
if (_Alloc_traits::_S_always_equal()) 
# 768
{ 
# 770
__data = _M_data(); 
# 771
__capacity = (_M_allocated_capacity); 
# 772
} else { 
# 774
_M_destroy(_M_allocated_capacity); }  
# 775
}  
# 777
_M_data(__str._M_data()); 
# 778
_M_length(__str.length()); 
# 779
_M_capacity(__str._M_allocated_capacity); 
# 780
if (__data) 
# 781
{ 
# 782
__str._M_data(__data); 
# 783
__str._M_capacity(__capacity); 
# 784
} else { 
# 786
__str._M_data(__str._M_local_buf); }  
# 787
} else { 
# 789
assign(__str); }  }  
# 790
__str.clear(); 
# 791
return *this; 
# 792
} 
# 799
basic_string &operator=(initializer_list< _CharT>  __l) 
# 800
{ 
# 801
this->assign(__l.begin(), __l.size()); 
# 802
return *this; 
# 803
} 
# 830 "/usr/include/c++/9/bits/basic_string.h" 3
iterator begin() noexcept 
# 831
{ return ((__gnu_cxx::__normal_iterator< pointer, basic_string> )(_M_data())); } 
# 838
const_iterator begin() const noexcept 
# 839
{ return ((__gnu_cxx::__normal_iterator< const_pointer, basic_string> )(_M_data())); } 
# 846
iterator end() noexcept 
# 847
{ return ((__gnu_cxx::__normal_iterator< pointer, basic_string> )(_M_data() + size())); } 
# 854
const_iterator end() const noexcept 
# 855
{ return ((__gnu_cxx::__normal_iterator< const_pointer, basic_string> )(_M_data() + size())); } 
# 863
reverse_iterator rbegin() noexcept 
# 864
{ return ((std::reverse_iterator< iterator> )(end())); } 
# 872
const_reverse_iterator rbegin() const noexcept 
# 873
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 881
reverse_iterator rend() noexcept 
# 882
{ return ((std::reverse_iterator< iterator> )(begin())); } 
# 890
const_reverse_iterator rend() const noexcept 
# 891
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 899
const_iterator cbegin() const noexcept 
# 900
{ return ((__gnu_cxx::__normal_iterator< const_pointer, basic_string> )(this->_M_data())); } 
# 907
const_iterator cend() const noexcept 
# 908
{ return ((__gnu_cxx::__normal_iterator< const_pointer, basic_string> )(this->_M_data() + size())); } 
# 916
const_reverse_iterator crbegin() const noexcept 
# 917
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 925
const_reverse_iterator crend() const noexcept 
# 926
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 934
size_type size() const noexcept 
# 935
{ return _M_string_length; } 
# 940
size_type length() const noexcept 
# 941
{ return _M_string_length; } 
# 945
size_type max_size() const noexcept 
# 946
{ return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; } 
# 959 "/usr/include/c++/9/bits/basic_string.h" 3
void resize(size_type __n, _CharT __c); 
# 972 "/usr/include/c++/9/bits/basic_string.h" 3
void resize(size_type __n) 
# 973
{ this->resize(__n, _CharT()); } 
# 978
void shrink_to_fit() noexcept 
# 979
{ 
# 981
if (capacity() > size()) 
# 982
{ 
# 983
try 
# 984
{ reserve(0); } 
# 985
catch (...) 
# 986
{ }  
# 987
}  
# 989
} 
# 997
size_type capacity() const noexcept 
# 998
{ 
# 999
return (_M_is_local()) ? (size_type)_S_local_capacity : (_M_allocated_capacity); 
# 1001
} 
# 1021 "/usr/include/c++/9/bits/basic_string.h" 3
void reserve(size_type __res_arg = 0); 
# 1027
void clear() noexcept 
# 1028
{ _M_set_length(0); } 
# 1035
bool empty() const noexcept 
# 1036
{ return size() == 0; } 
# 1050 "/usr/include/c++/9/bits/basic_string.h" 3
const_reference operator[](size_type __pos) const noexcept 
# 1051
{ 
# 1052
; 
# 1053
return _M_data()[__pos]; 
# 1054
} 
# 1067 "/usr/include/c++/9/bits/basic_string.h" 3
reference operator[](size_type __pos) 
# 1068
{ 
# 1071
; 
# 1073
; 
# 1074
return _M_data()[__pos]; 
# 1075
} 
# 1088 "/usr/include/c++/9/bits/basic_string.h" 3
const_reference at(size_type __n) const 
# 1089
{ 
# 1090
if (__n >= size()) { 
# 1091
__throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, size()); }  
# 1095
return _M_data()[__n]; 
# 1096
} 
# 1109 "/usr/include/c++/9/bits/basic_string.h" 3
reference at(size_type __n) 
# 1110
{ 
# 1111
if (__n >= size()) { 
# 1112
__throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, size()); }  
# 1116
return _M_data()[__n]; 
# 1117
} 
# 1125
reference front() noexcept 
# 1126
{ 
# 1127
; 
# 1128
return operator[](0); 
# 1129
} 
# 1136
const_reference front() const noexcept 
# 1137
{ 
# 1138
; 
# 1139
return operator[](0); 
# 1140
} 
# 1147
reference back() noexcept 
# 1148
{ 
# 1149
; 
# 1150
return operator[](size() - 1); 
# 1151
} 
# 1158
const_reference back() const noexcept 
# 1159
{ 
# 1160
; 
# 1161
return operator[](size() - 1); 
# 1162
} 
# 1172 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &operator+=(const basic_string &__str) 
# 1173
{ return this->append(__str); } 
# 1181
basic_string &operator+=(const _CharT *__s) 
# 1182
{ return this->append(__s); } 
# 1190
basic_string &operator+=(_CharT __c) 
# 1191
{ 
# 1192
push_back(__c); 
# 1193
return *this; 
# 1194
} 
# 1203
basic_string &operator+=(initializer_list< _CharT>  __l) 
# 1204
{ return this->append(__l.begin(), __l.size()); } 
# 1225 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &append(const basic_string &__str) 
# 1226
{ return _M_append(__str._M_data(), __str.size()); } 
# 1242 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &append(const basic_string &__str, size_type __pos, size_type __n = npos) 
# 1243
{ return _M_append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n)); 
# 1245
} 
# 1254
basic_string &append(const _CharT *__s, size_type __n) 
# 1255
{ 
# 1256
; 
# 1257
_M_check_length((size_type)0, __n, "basic_string::append"); 
# 1258
return _M_append(__s, __n); 
# 1259
} 
# 1267
basic_string &append(const _CharT *__s) 
# 1268
{ 
# 1269
; 
# 1270
const size_type __n = traits_type::length(__s); 
# 1271
_M_check_length((size_type)0, __n, "basic_string::append"); 
# 1272
return _M_append(__s, __n); 
# 1273
} 
# 1284 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &append(size_type __n, _CharT __c) 
# 1285
{ return _M_replace_aux(size(), (size_type)0, __n, __c); } 
# 1294
basic_string &append(initializer_list< _CharT>  __l) 
# 1295
{ return this->append(__l.begin(), __l.size()); } 
# 1307 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _InputIterator, class 
# 1308
 = _RequireInputIter< _InputIterator> > basic_string &
# 1313
append(_InputIterator __first, _InputIterator __last) 
# 1314
{ return this->replace(end(), end(), __first, __last); } 
# 1353 "/usr/include/c++/9/bits/basic_string.h" 3
void push_back(_CharT __c) 
# 1354
{ 
# 1355
const size_type __size = size(); 
# 1356
if ((__size + 1) > capacity()) { 
# 1357
_M_mutate(__size, (size_type)0, 0, (size_type)1); }  
# 1358
traits_type::assign(this->_M_data()[__size], __c); 
# 1359
_M_set_length(__size + 1); 
# 1360
} 
# 1368
basic_string &assign(const basic_string &__str) 
# 1369
{ 
# 1370
_M_assign(__str); 
# 1371
return *this; 
# 1372
} 
# 1384 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &assign(basic_string &&__str) noexcept(_Alloc_traits::_S_nothrow_move()) 
# 1386
{ 
# 1389
return (*this) = std::move(__str); 
# 1390
} 
# 1407 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &assign(const basic_string &__str, size_type __pos, size_type __n = npos) 
# 1408
{ return _M_replace((size_type)0, size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n)); 
# 1410
} 
# 1423 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &assign(const _CharT *__s, size_type __n) 
# 1424
{ 
# 1425
; 
# 1426
return _M_replace((size_type)0, size(), __s, __n); 
# 1427
} 
# 1439 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &assign(const _CharT *__s) 
# 1440
{ 
# 1441
; 
# 1442
return _M_replace((size_type)0, size(), __s, traits_type::length(__s)); 
# 1444
} 
# 1456 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &assign(size_type __n, _CharT __c) 
# 1457
{ return _M_replace_aux((size_type)0, size(), __n, __c); } 
# 1468 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _InputIterator, class 
# 1469
 = _RequireInputIter< _InputIterator> > basic_string &
# 1474
assign(_InputIterator __first, _InputIterator __last) 
# 1475
{ return this->replace(begin(), end(), __first, __last); } 
# 1484
basic_string &assign(initializer_list< _CharT>  __l) 
# 1485
{ return this->assign(__l.begin(), __l.size()); } 
# 1538 "/usr/include/c++/9/bits/basic_string.h" 3
iterator insert(const_iterator __p, size_type __n, _CharT __c) 
# 1539
{ 
# 1540
; 
# 1541
const size_type __pos = __p - begin(); 
# 1542
this->replace(__p, __p, __n, __c); 
# 1543
return ((__gnu_cxx::__normal_iterator< pointer, basic_string> )(this->_M_data() + __pos)); 
# 1544
} 
# 1579 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _InputIterator, class 
# 1580
 = _RequireInputIter< _InputIterator> > iterator 
# 1582
insert(const_iterator __p, _InputIterator __beg, _InputIterator __end) 
# 1583
{ 
# 1584
; 
# 1585
const size_type __pos = __p - begin(); 
# 1586
this->replace(__p, __p, __beg, __end); 
# 1587
return ((__gnu_cxx::__normal_iterator< pointer, basic_string> )(this->_M_data() + __pos)); 
# 1588
} 
# 1616 "/usr/include/c++/9/bits/basic_string.h" 3
iterator insert(const_iterator __p, initializer_list< _CharT>  __l) 
# 1617
{ return this->insert(__p, __l.begin(), __l.end()); } 
# 1643 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &insert(size_type __pos1, const basic_string &__str) 
# 1644
{ return this->replace(__pos1, (size_type)0, __str._M_data(), __str.size()); 
# 1645
} 
# 1666 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &insert(size_type __pos1, const basic_string &__str, size_type 
# 1667
__pos2, size_type __n = npos) 
# 1668
{ return this->replace(__pos1, (size_type)0, __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n)); 
# 1670
} 
# 1689 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &insert(size_type __pos, const _CharT *__s, size_type __n) 
# 1690
{ return this->replace(__pos, (size_type)0, __s, __n); } 
# 1708 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &insert(size_type __pos, const _CharT *__s) 
# 1709
{ 
# 1710
; 
# 1711
return this->replace(__pos, (size_type)0, __s, traits_type::length(__s)); 
# 1713
} 
# 1732 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &insert(size_type __pos, size_type __n, _CharT __c) 
# 1733
{ return _M_replace_aux(_M_check(__pos, "basic_string::insert"), (size_type)0, __n, __c); 
# 1734
} 
# 1750 "/usr/include/c++/9/bits/basic_string.h" 3
iterator insert(__const_iterator __p, _CharT __c) 
# 1751
{ 
# 1752
; 
# 1753
const size_type __pos = __p - begin(); 
# 1754
_M_replace_aux(__pos, (size_type)0, (size_type)1, __c); 
# 1755
return ((__gnu_cxx::__normal_iterator< pointer, basic_string> )(_M_data() + __pos)); 
# 1756
} 
# 1811 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &erase(size_type __pos = 0, size_type __n = npos) 
# 1812
{ 
# 1813
_M_check(__pos, "basic_string::erase"); 
# 1814
if (__n == npos) { 
# 1815
_M_set_length(__pos); } else { 
# 1816
if (__n != 0) { 
# 1817
_M_erase(__pos, _M_limit(__pos, __n)); }  }  
# 1818
return *this; 
# 1819
} 
# 1830 "/usr/include/c++/9/bits/basic_string.h" 3
iterator erase(__const_iterator __position) 
# 1831
{ 
# 1833
; 
# 1834
const size_type __pos = __position - begin(); 
# 1835
_M_erase(__pos, (size_type)1); 
# 1836
return ((__gnu_cxx::__normal_iterator< pointer, basic_string> )(_M_data() + __pos)); 
# 1837
} 
# 1849 "/usr/include/c++/9/bits/basic_string.h" 3
iterator erase(__const_iterator __first, __const_iterator __last) 
# 1850
{ 
# 1852
; 
# 1853
const size_type __pos = __first - begin(); 
# 1854
if (__last == end()) { 
# 1855
_M_set_length(__pos); } else { 
# 1857
_M_erase(__pos, __last - __first); }  
# 1858
return ((__gnu_cxx::__normal_iterator< pointer, basic_string> )(this->_M_data() + __pos)); 
# 1859
} 
# 1868
void pop_back() noexcept 
# 1869
{ 
# 1870
; 
# 1871
_M_erase(size() - 1, 1); 
# 1872
} 
# 1893 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(size_type __pos, size_type __n, const basic_string &__str) 
# 1894
{ return this->replace(__pos, __n, __str._M_data(), __str.size()); } 
# 1915 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(size_type __pos1, size_type __n1, const basic_string &__str, size_type 
# 1916
__pos2, size_type __n2 = npos) 
# 1917
{ return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2)); 
# 1919
} 
# 1940 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(size_type __pos, size_type __n1, const _CharT *__s, size_type 
# 1941
__n2) 
# 1942
{ 
# 1943
; 
# 1944
return _M_replace(_M_check(__pos, "basic_string::replace"), _M_limit(__pos, __n1), __s, __n2); 
# 1946
} 
# 1965 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(size_type __pos, size_type __n1, const _CharT *__s) 
# 1966
{ 
# 1967
; 
# 1968
return this->replace(__pos, __n1, __s, traits_type::length(__s)); 
# 1969
} 
# 1989 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c) 
# 1990
{ return _M_replace_aux(_M_check(__pos, "basic_string::replace"), _M_limit(__pos, __n1), __n2, __c); 
# 1991
} 
# 2007 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const basic_string &
# 2008
__str) 
# 2009
{ return this->replace(__i1, __i2, __str._M_data(), __str.size()); } 
# 2027 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *
# 2028
__s, size_type __n) 
# 2029
{ 
# 2031
; 
# 2032
return this->replace(__i1 - begin(), __i2 - __i1, __s, __n); 
# 2033
} 
# 2049 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *__s) 
# 2050
{ 
# 2051
; 
# 2052
return this->replace(__i1, __i2, __s, traits_type::length(__s)); 
# 2053
} 
# 2070 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, size_type __n, _CharT 
# 2071
__c) 
# 2072
{ 
# 2074
; 
# 2075
return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c); 
# 2076
} 
# 2094 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _InputIterator, class 
# 2095
 = _RequireInputIter< _InputIterator> > basic_string &
# 2097
replace(const_iterator __i1, const_iterator __i2, _InputIterator 
# 2098
__k1, _InputIterator __k2) 
# 2099
{ 
# 2101
; 
# 2102
; 
# 2103
return this->_M_replace_dispatch(__i1, __i2, __k1, __k2, __false_type()); 
# 2105
} 
# 2127 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(__const_iterator __i1, __const_iterator __i2, _CharT *
# 2128
__k1, _CharT *__k2) 
# 2129
{ 
# 2131
; 
# 2132
; 
# 2133
return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1); 
# 2135
} 
# 2138
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const _CharT *
# 2139
__k1, const _CharT *__k2) 
# 2140
{ 
# 2142
; 
# 2143
; 
# 2144
return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1); 
# 2146
} 
# 2149
basic_string &replace(__const_iterator __i1, __const_iterator __i2, iterator 
# 2150
__k1, iterator __k2) 
# 2151
{ 
# 2153
; 
# 2154
; 
# 2155
return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1); 
# 2157
} 
# 2160
basic_string &replace(__const_iterator __i1, __const_iterator __i2, const_iterator 
# 2161
__k1, const_iterator __k2) 
# 2162
{ 
# 2164
; 
# 2165
; 
# 2166
return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1); 
# 2168
} 
# 2185 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string &replace(const_iterator __i1, const_iterator __i2, initializer_list< _CharT>  
# 2186
__l) 
# 2187
{ return this->replace(__i1, __i2, __l.begin(), __l.size()); } 
# 2248 "/usr/include/c++/9/bits/basic_string.h" 3
private: 
# 2246
template< class _Integer> basic_string &
# 2248
_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _Integer 
# 2249
__n, _Integer __val, __true_type) 
# 2250
{ return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); } 
# 2252
template< class _InputIterator> basic_string &_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator __k1, _InputIterator __k2, __false_type); 
# 2259
basic_string &_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT __c); 
# 2263
basic_string &_M_replace(size_type __pos, size_type __len1, const _CharT * __s, const size_type __len2); 
# 2267
basic_string &_M_append(const _CharT * __s, size_type __n); 
# 2284 "/usr/include/c++/9/bits/basic_string.h" 3
public: size_type copy(_CharT * __s, size_type __n, size_type __pos = 0) const; 
# 2294 "/usr/include/c++/9/bits/basic_string.h" 3
void swap(basic_string & __s) noexcept; 
# 2304 "/usr/include/c++/9/bits/basic_string.h" 3
const _CharT *c_str() const noexcept 
# 2305
{ return _M_data(); } 
# 2316 "/usr/include/c++/9/bits/basic_string.h" 3
const _CharT *data() const noexcept 
# 2317
{ return _M_data(); } 
# 2335 "/usr/include/c++/9/bits/basic_string.h" 3
allocator_type get_allocator() const noexcept 
# 2336
{ return _M_get_allocator(); } 
# 2351 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find(const _CharT * __s, size_type __pos, size_type __n) const noexcept; 
# 2365 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find(const basic_string &__str, size_type __pos = 0) const noexcept 
# 2367
{ return this->find(__str.data(), __pos, __str.size()); } 
# 2397 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find(const _CharT *__s, size_type __pos = 0) const noexcept 
# 2398
{ 
# 2399
; 
# 2400
return this->find(__s, __pos, traits_type::length(__s)); 
# 2401
} 
# 2414 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find(_CharT __c, size_type __pos = 0) const noexcept; 
# 2427 "/usr/include/c++/9/bits/basic_string.h" 3
size_type rfind(const basic_string &__str, size_type __pos = npos) const noexcept 
# 2429
{ return this->rfind(__str.data(), __pos, __str.size()); } 
# 2461 "/usr/include/c++/9/bits/basic_string.h" 3
size_type rfind(const _CharT * __s, size_type __pos, size_type __n) const noexcept; 
# 2475 "/usr/include/c++/9/bits/basic_string.h" 3
size_type rfind(const _CharT *__s, size_type __pos = npos) const 
# 2476
{ 
# 2477
; 
# 2478
return this->rfind(__s, __pos, traits_type::length(__s)); 
# 2479
} 
# 2492 "/usr/include/c++/9/bits/basic_string.h" 3
size_type rfind(_CharT __c, size_type __pos = npos) const noexcept; 
# 2506 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_first_of(const basic_string &__str, size_type __pos = 0) const noexcept 
# 2508
{ return this->find_first_of(__str.data(), __pos, __str.size()); } 
# 2541 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_first_of(const _CharT * __s, size_type __pos, size_type __n) const noexcept; 
# 2555 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_first_of(const _CharT *__s, size_type __pos = 0) const noexcept 
# 2557
{ 
# 2558
; 
# 2559
return this->find_first_of(__s, __pos, traits_type::length(__s)); 
# 2560
} 
# 2575 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_first_of(_CharT __c, size_type __pos = 0) const noexcept 
# 2576
{ return this->find(__c, __pos); } 
# 2590 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_last_of(const basic_string &__str, size_type __pos = npos) const noexcept 
# 2592
{ return this->find_last_of(__str.data(), __pos, __str.size()); } 
# 2625 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_last_of(const _CharT * __s, size_type __pos, size_type __n) const noexcept; 
# 2639 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_last_of(const _CharT *__s, size_type __pos = npos) const noexcept 
# 2641
{ 
# 2642
; 
# 2643
return this->find_last_of(__s, __pos, traits_type::length(__s)); 
# 2644
} 
# 2659 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_last_of(_CharT __c, size_type __pos = npos) const noexcept 
# 2660
{ return this->rfind(__c, __pos); } 
# 2673 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_first_not_of(const basic_string &__str, size_type __pos = 0) const noexcept 
# 2675
{ return this->find_first_not_of(__str.data(), __pos, __str.size()); } 
# 2708 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_first_not_of(const _CharT * __s, size_type __pos, size_type __n) const noexcept; 
# 2722 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_first_not_of(const _CharT *__s, size_type __pos = 0) const noexcept 
# 2724
{ 
# 2725
; 
# 2726
return this->find_first_not_of(__s, __pos, traits_type::length(__s)); 
# 2727
} 
# 2740 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept; 
# 2755 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_last_not_of(const basic_string &__str, size_type __pos = npos) const noexcept 
# 2757
{ return this->find_last_not_of(__str.data(), __pos, __str.size()); } 
# 2790 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_last_not_of(const _CharT * __s, size_type __pos, size_type __n) const noexcept; 
# 2804 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_last_not_of(const _CharT *__s, size_type __pos = npos) const noexcept 
# 2806
{ 
# 2807
; 
# 2808
return this->find_last_not_of(__s, __pos, traits_type::length(__s)); 
# 2809
} 
# 2822 "/usr/include/c++/9/bits/basic_string.h" 3
size_type find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept; 
# 2838 "/usr/include/c++/9/bits/basic_string.h" 3
basic_string substr(size_type __pos = 0, size_type __n = npos) const 
# 2839
{ return basic_string(*this, _M_check(__pos, "basic_string::substr"), __n); 
# 2840
} 
# 2857 "/usr/include/c++/9/bits/basic_string.h" 3
int compare(const basic_string &__str) const 
# 2858
{ 
# 2859
const size_type __size = size(); 
# 2860
const size_type __osize = __str.size(); 
# 2861
const size_type __len = std::min(__size, __osize); 
# 2863
int __r = traits_type::compare(_M_data(), __str.data(), __len); 
# 2864
if (!__r) { 
# 2865
__r = (_S_compare)(__size, __osize); }  
# 2866
return __r; 
# 2867
} 
# 2950 "/usr/include/c++/9/bits/basic_string.h" 3
int compare(size_type __pos, size_type __n, const basic_string & __str) const; 
# 2976 "/usr/include/c++/9/bits/basic_string.h" 3
int compare(size_type __pos1, size_type __n1, const basic_string & __str, size_type __pos2, size_type __n2 = npos) const; 
# 2994 "/usr/include/c++/9/bits/basic_string.h" 3
int compare(const _CharT * __s) const noexcept; 
# 3018 "/usr/include/c++/9/bits/basic_string.h" 3
int compare(size_type __pos, size_type __n1, const _CharT * __s) const; 
# 3045 "/usr/include/c++/9/bits/basic_string.h" 3
int compare(size_type __pos, size_type __n1, const _CharT * __s, size_type __n2) const; 
# 3075 "/usr/include/c++/9/bits/basic_string.h" 3
template< class , class , class > friend class basic_stringbuf; 
# 3076
}; 
# 3077
}
# 6021 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6023
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6024
__rhs) 
# 6025
{ 
# 6026
__cxx11::basic_string< _CharT, _Traits, _Alloc>  __str(__lhs); 
# 6027
__str.append(__rhs); 
# 6028
return __str; 
# 6029
} 
# 6037
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  operator+(const _CharT * __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __rhs); 
# 6048
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  operator+(_CharT __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __rhs); 
# 6058
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6060
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 6061
__rhs) 
# 6062
{ 
# 6063
__cxx11::basic_string< _CharT, _Traits, _Alloc>  __str(__lhs); 
# 6064
__str.append(__rhs); 
# 6065
return __str; 
# 6066
} 
# 6074
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6076
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, _CharT __rhs) 
# 6077
{ 
# 6078
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 6079
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 6080
__string_type __str(__lhs); 
# 6081
__str.append((__size_type)1, __rhs); 
# 6082
return __str; 
# 6083
} 
# 6086
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6088
operator+(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &&__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6089
__rhs) 
# 6090
{ return std::move(__lhs.append(__rhs)); } 
# 6092
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6094
operator+(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &&
# 6095
__rhs) 
# 6096
{ return std::move(__rhs.insert(0, __lhs)); } 
# 6098
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6100
operator+(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &&__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &&
# 6101
__rhs) 
# 6102
{ 
# 6103
const auto __size = __lhs.size() + __rhs.size(); 
# 6104
const bool __cond = (__size > __lhs.capacity()) && (__size <= __rhs.capacity()); 
# 6106
return __cond ? std::move(__rhs.insert(0, __lhs)) : std::move(__lhs.append(__rhs)); 
# 6108
} 
# 6110
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6112
operator+(const _CharT *__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &&
# 6113
__rhs) 
# 6114
{ return std::move(__rhs.insert(0, __lhs)); } 
# 6116
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6118
operator+(_CharT __lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &&
# 6119
__rhs) 
# 6120
{ return std::move(__rhs.insert(0, 1, __lhs)); } 
# 6122
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6124
operator+(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &&__lhs, const _CharT *
# 6125
__rhs) 
# 6126
{ return std::move(__lhs.append(__rhs)); } 
# 6128
template< class _CharT, class _Traits, class _Alloc> inline __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 6130
operator+(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &&__lhs, _CharT 
# 6131
__rhs) 
# 6132
{ return std::move(__lhs.append(1, __rhs)); } 
# 6142 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6144
operator==(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6145
__rhs) noexcept 
# 6147
{ return __lhs.compare(__rhs) == 0; } 
# 6149
template< class _CharT> inline typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, bool> ::__type 
# 6152
operator==(const __cxx11::basic_string< _CharT>  &__lhs, const __cxx11::basic_string< _CharT>  &
# 6153
__rhs) noexcept 
# 6154
{ return ((__lhs.size() == __rhs.size()) && (!std::template char_traits< _CharT> ::compare(__lhs.data(), __rhs.data(), __lhs.size()))); 
# 6156
} 
# 6164
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6166
operator==(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6167
__rhs) 
# 6168
{ return __rhs.compare(__lhs) == 0; } 
# 6176
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6178
operator==(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 6179
__rhs) 
# 6180
{ return __lhs.compare(__rhs) == 0; } 
# 6189 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6191
operator!=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6192
__rhs) noexcept 
# 6194
{ return !(__lhs == __rhs); } 
# 6202
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6204
operator!=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6205
__rhs) 
# 6206
{ return !(__lhs == __rhs); } 
# 6214
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6216
operator!=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 6217
__rhs) 
# 6218
{ return !(__lhs == __rhs); } 
# 6227 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6229
operator<(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6230
__rhs) noexcept 
# 6232
{ return __lhs.compare(__rhs) < 0; } 
# 6240
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6242
operator<(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 6243
__rhs) 
# 6244
{ return __lhs.compare(__rhs) < 0; } 
# 6252
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6254
operator<(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6255
__rhs) 
# 6256
{ return __rhs.compare(__lhs) > 0; } 
# 6265 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6267
operator>(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6268
__rhs) noexcept 
# 6270
{ return __lhs.compare(__rhs) > 0; } 
# 6278
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6280
operator>(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 6281
__rhs) 
# 6282
{ return __lhs.compare(__rhs) > 0; } 
# 6290
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6292
operator>(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6293
__rhs) 
# 6294
{ return __rhs.compare(__lhs) < 0; } 
# 6303 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6305
operator<=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6306
__rhs) noexcept 
# 6308
{ return __lhs.compare(__rhs) <= 0; } 
# 6316
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6318
operator<=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 6319
__rhs) 
# 6320
{ return __lhs.compare(__rhs) <= 0; } 
# 6328
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6330
operator<=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6331
__rhs) 
# 6332
{ return __rhs.compare(__lhs) >= 0; } 
# 6341 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6343
operator>=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6344
__rhs) noexcept 
# 6346
{ return __lhs.compare(__rhs) >= 0; } 
# 6354
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6356
operator>=(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, const _CharT *
# 6357
__rhs) 
# 6358
{ return __lhs.compare(__rhs) >= 0; } 
# 6366
template< class _CharT, class _Traits, class _Alloc> inline bool 
# 6368
operator>=(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6369
__rhs) 
# 6370
{ return __rhs.compare(__lhs) <= 0; } 
# 6379 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline void 
# 6381
swap(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &__lhs, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6382
__rhs) noexcept(noexcept(__lhs.swap(__rhs))) 
# 6384
{ __lhs.swap(__rhs); } 
# 6399 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __str); 
# 6406
template<> basic_istream< char>  &operator>>(basic_istream< char>  & __is, __cxx11::basic_string< char>  & __str); 
# 6417 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline basic_ostream< _CharT, _Traits>  &
# 6419
operator<<(basic_ostream< _CharT, _Traits>  &__os, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6420
__str) 
# 6421
{ 
# 6424
return __ostream_insert(__os, __str.data(), __str.size()); 
# 6425
} 
# 6440 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &getline(basic_istream< _CharT, _Traits>  & __is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  & __str, _CharT __delim); 
# 6457 "/usr/include/c++/9/bits/basic_string.h" 3
template< class _CharT, class _Traits, class _Alloc> inline basic_istream< _CharT, _Traits>  &
# 6459
getline(basic_istream< _CharT, _Traits>  &__is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6460
__str) 
# 6461
{ return std::getline(__is, __str, __is.widen('\n')); } 
# 6465
template< class _CharT, class _Traits, class _Alloc> inline basic_istream< _CharT, _Traits>  &
# 6467
getline(basic_istream< _CharT, _Traits>  &&__is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6468
__str, _CharT __delim) 
# 6469
{ return std::getline(__is, __str, __delim); } 
# 6472
template< class _CharT, class _Traits, class _Alloc> inline basic_istream< _CharT, _Traits>  &
# 6474
getline(basic_istream< _CharT, _Traits>  &&__is, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 6475
__str) 
# 6476
{ return std::getline(__is, __str); } 
# 6481
template<> basic_istream< char>  &getline(basic_istream< char>  & __in, __cxx11::basic_string< char>  & __str, char __delim); 
# 6487
template<> basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __in, __cxx11::basic_string< wchar_t>  & __str, wchar_t __delim); 
# 6492
}
# 29 "/usr/include/stdio.h" 3
extern "C" {
# 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 3
typedef 
# 10
struct _G_fpos_t { 
# 12
__off_t __pos; 
# 13
__mbstate_t __state; 
# 14
} __fpos_t; 
# 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3
typedef 
# 10
struct _G_fpos64_t { 
# 12
__off64_t __pos; 
# 13
__mbstate_t __state; 
# 14
} __fpos64_t; 
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3
struct _IO_FILE; 
# 36
struct _IO_marker; 
# 37
struct _IO_codecvt; 
# 38
struct _IO_wide_data; 
# 43
typedef void _IO_lock_t; 
# 49
struct _IO_FILE { 
# 51
int _flags; 
# 54
char *_IO_read_ptr; 
# 55
char *_IO_read_end; 
# 56
char *_IO_read_base; 
# 57
char *_IO_write_base; 
# 58
char *_IO_write_ptr; 
# 59
char *_IO_write_end; 
# 60
char *_IO_buf_base; 
# 61
char *_IO_buf_end; 
# 64
char *_IO_save_base; 
# 65
char *_IO_backup_base; 
# 66
char *_IO_save_end; 
# 68
_IO_marker *_markers; 
# 70
_IO_FILE *_chain; 
# 72
int _fileno; 
# 73
int _flags2; 
# 74
__off_t _old_offset; 
# 77
unsigned short _cur_column; 
# 78
signed char _vtable_offset; 
# 79
char _shortbuf[1]; 
# 81
_IO_lock_t *_lock; 
# 89
__off64_t _offset; 
# 91
_IO_codecvt *_codecvt; 
# 92
_IO_wide_data *_wide_data; 
# 93
_IO_FILE *_freeres_list; 
# 94
void *_freeres_buf; 
# 95
size_t __pad5; 
# 96
int _mode; 
# 98
char _unused2[(((15) * sizeof(int)) - ((4) * sizeof(void *))) - sizeof(size_t)]; 
# 99
}; 
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3
typedef __ssize_t cookie_read_function_t(void * __cookie, char * __buf, size_t __nbytes); 
# 36
typedef __ssize_t cookie_write_function_t(void * __cookie, const char * __buf, size_t __nbytes); 
# 45
typedef int cookie_seek_function_t(void * __cookie, __off64_t * __pos, int __w); 
# 48
typedef int cookie_close_function_t(void * __cookie); 
# 61
typedef 
# 55
struct _IO_cookie_io_functions_t { 
# 57
cookie_read_function_t *read; 
# 58
cookie_write_function_t *write; 
# 59
cookie_seek_function_t *seek; 
# 60
cookie_close_function_t *close; 
# 61
} cookie_io_functions_t; 
# 52 "/usr/include/stdio.h" 3
typedef __gnuc_va_list va_list; 
# 84 "/usr/include/stdio.h" 3
typedef __fpos_t fpos_t; 
# 89
typedef __fpos64_t fpos64_t; 
# 137 "/usr/include/stdio.h" 3
extern FILE *stdin; 
# 138
extern FILE *stdout; 
# 139
extern FILE *stderr; 
# 146
extern int remove(const char * __filename) throw(); 
# 148
extern int rename(const char * __old, const char * __new) throw(); 
# 152
extern int renameat(int __oldfd, const char * __old, int __newfd, const char * __new) throw(); 
# 164 "/usr/include/stdio.h" 3
extern int renameat2(int __oldfd, const char * __old, int __newfd, const char * __new, unsigned __flags) throw(); 
# 173
extern FILE *tmpfile(); 
# 183 "/usr/include/stdio.h" 3
extern FILE *tmpfile64(); 
# 187
extern char *tmpnam(char * __s) throw(); 
# 192
extern char *tmpnam_r(char * __s) throw(); 
# 204 "/usr/include/stdio.h" 3
extern char *tempnam(const char * __dir, const char * __pfx) throw()
# 205
 __attribute((__malloc__)); 
# 213
extern int fclose(FILE * __stream); 
# 218
extern int fflush(FILE * __stream); 
# 227 "/usr/include/stdio.h" 3
extern int fflush_unlocked(FILE * __stream); 
# 237 "/usr/include/stdio.h" 3
extern int fcloseall(); 
# 246 "/usr/include/stdio.h" 3
extern FILE *fopen(const char *__restrict__ __filename, const char *__restrict__ __modes); 
# 252
extern FILE *freopen(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream); 
# 270 "/usr/include/stdio.h" 3
extern FILE *fopen64(const char *__restrict__ __filename, const char *__restrict__ __modes); 
# 272
extern FILE *freopen64(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream); 
# 279
extern FILE *fdopen(int __fd, const char * __modes) throw(); 
# 285
extern FILE *fopencookie(void *__restrict__ __magic_cookie, const char *__restrict__ __modes, cookie_io_functions_t __io_funcs) throw(); 
# 292
extern FILE *fmemopen(void * __s, size_t __len, const char * __modes) throw(); 
# 298
extern FILE *open_memstream(char ** __bufloc, size_t * __sizeloc) throw(); 
# 304
extern void setbuf(FILE *__restrict__ __stream, char *__restrict__ __buf) throw(); 
# 308
extern int setvbuf(FILE *__restrict__ __stream, char *__restrict__ __buf, int __modes, size_t __n) throw(); 
# 314
extern void setbuffer(FILE *__restrict__ __stream, char *__restrict__ __buf, size_t __size) throw(); 
# 318
extern void setlinebuf(FILE * __stream) throw(); 
# 326
extern int fprintf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...); 
# 332
extern int printf(const char *__restrict__ __format, ...); 
# 334
extern int sprintf(char *__restrict__ __s, const char *__restrict__ __format, ...) throw(); 
# 341
extern int vfprintf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg); 
# 347
extern int vprintf(const char *__restrict__ __format, __gnuc_va_list __arg); 
# 349
extern int vsprintf(char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) throw(); 
# 354
extern int snprintf(char *__restrict__ __s, size_t __maxlen, const char *__restrict__ __format, ...) throw()
# 356
 __attribute((__format__(__printf__, 3, 4))); 
# 358
extern int vsnprintf(char *__restrict__ __s, size_t __maxlen, const char *__restrict__ __format, __gnuc_va_list __arg) throw()
# 360
 __attribute((__format__(__printf__, 3, 0))); 
# 366
extern int vasprintf(char **__restrict__ __ptr, const char *__restrict__ __f, __gnuc_va_list __arg) throw()
# 368
 __attribute((__format__(__printf__, 2, 0))); 
# 369
extern int __asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, ...) throw()
# 371
 __attribute((__format__(__printf__, 2, 3))); 
# 372
extern int asprintf(char **__restrict__ __ptr, const char *__restrict__ __fmt, ...) throw()
# 374
 __attribute((__format__(__printf__, 2, 3))); 
# 379
extern int vdprintf(int __fd, const char *__restrict__ __fmt, __gnuc_va_list __arg)
# 381
 __attribute((__format__(__printf__, 2, 0))); 
# 382
extern int dprintf(int __fd, const char *__restrict__ __fmt, ...)
# 383
 __attribute((__format__(__printf__, 2, 3))); 
# 391
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...) __asm__("__isoc99_fscanf"); 
# 397
extern int scanf(const char *__restrict__ __format, ...) __asm__("__isoc99_scanf"); 
# 399
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) throw() __asm__("__isoc99_sscanf"); 
# 407
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...) __asm__("__isoc99_fscanf"); 
# 410
extern int scanf(const char *__restrict__ __format, ...) __asm__("__isoc99_scanf"); 
# 412
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) throw() __asm__("__isoc99_sscanf"); 
# 432 "/usr/include/stdio.h" 3
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) __asm__("__isoc99_vfscanf")
# 434
 __attribute((__format__(__scanf__, 2, 0))); 
# 440
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list __arg) __asm__("__isoc99_vscanf")
# 441
 __attribute((__format__(__scanf__, 1, 0))); 
# 444
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) throw() __asm__("__isoc99_vsscanf")
# 446
 __attribute((__format__(__scanf__, 2, 0))); 
# 451
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) __asm__("__isoc99_vfscanf")
# 455
 __attribute((__format__(__scanf__, 2, 0))); 
# 456
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list __arg) __asm__("__isoc99_vscanf")
# 458
 __attribute((__format__(__scanf__, 1, 0))); 
# 459
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list __arg) throw() __asm__("__isoc99_vsscanf")
# 463
 __attribute((__format__(__scanf__, 2, 0))); 
# 485 "/usr/include/stdio.h" 3
extern int fgetc(FILE * __stream); 
# 486
extern int getc(FILE * __stream); 
# 492
extern int getchar(); 
# 499
extern int getc_unlocked(FILE * __stream); 
# 500
extern int getchar_unlocked(); 
# 510 "/usr/include/stdio.h" 3
extern int fgetc_unlocked(FILE * __stream); 
# 521 "/usr/include/stdio.h" 3
extern int fputc(int __c, FILE * __stream); 
# 522
extern int putc(int __c, FILE * __stream); 
# 528
extern int putchar(int __c); 
# 537 "/usr/include/stdio.h" 3
extern int fputc_unlocked(int __c, FILE * __stream); 
# 545
extern int putc_unlocked(int __c, FILE * __stream); 
# 546
extern int putchar_unlocked(int __c); 
# 553
extern int getw(FILE * __stream); 
# 556
extern int putw(int __w, FILE * __stream); 
# 564
extern char *fgets(char *__restrict__ __s, int __n, FILE *__restrict__ __stream); 
# 587 "/usr/include/stdio.h" 3
extern char *fgets_unlocked(char *__restrict__ __s, int __n, FILE *__restrict__ __stream); 
# 603 "/usr/include/stdio.h" 3
extern __ssize_t __getdelim(char **__restrict__ __lineptr, size_t *__restrict__ __n, int __delimiter, FILE *__restrict__ __stream); 
# 606
extern __ssize_t getdelim(char **__restrict__ __lineptr, size_t *__restrict__ __n, int __delimiter, FILE *__restrict__ __stream); 
# 616
extern __ssize_t getline(char **__restrict__ __lineptr, size_t *__restrict__ __n, FILE *__restrict__ __stream); 
# 626
extern int fputs(const char *__restrict__ __s, FILE *__restrict__ __stream); 
# 632
extern int puts(const char * __s); 
# 639
extern int ungetc(int __c, FILE * __stream); 
# 646
extern size_t fread(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream); 
# 652
extern size_t fwrite(const void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __s); 
# 662 "/usr/include/stdio.h" 3
extern int fputs_unlocked(const char *__restrict__ __s, FILE *__restrict__ __stream); 
# 673 "/usr/include/stdio.h" 3
extern size_t fread_unlocked(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream); 
# 675
extern size_t fwrite_unlocked(const void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream); 
# 684
extern int fseek(FILE * __stream, long __off, int __whence); 
# 689
extern long ftell(FILE * __stream); 
# 694
extern void rewind(FILE * __stream); 
# 707 "/usr/include/stdio.h" 3
extern int fseeko(FILE * __stream, __off_t __off, int __whence); 
# 712
extern __off_t ftello(FILE * __stream); 
# 731 "/usr/include/stdio.h" 3
extern int fgetpos(FILE *__restrict__ __stream, fpos_t *__restrict__ __pos); 
# 736
extern int fsetpos(FILE * __stream, const fpos_t * __pos); 
# 750 "/usr/include/stdio.h" 3
extern int fseeko64(FILE * __stream, __off64_t __off, int __whence); 
# 751
extern __off64_t ftello64(FILE * __stream); 
# 752
extern int fgetpos64(FILE *__restrict__ __stream, fpos64_t *__restrict__ __pos); 
# 753
extern int fsetpos64(FILE * __stream, const fpos64_t * __pos); 
# 757
extern void clearerr(FILE * __stream) throw(); 
# 759
extern int feof(FILE * __stream) throw(); 
# 761
extern int ferror(FILE * __stream) throw(); 
# 765
extern void clearerr_unlocked(FILE * __stream) throw(); 
# 766
extern int feof_unlocked(FILE * __stream) throw(); 
# 767
extern int ferror_unlocked(FILE * __stream) throw(); 
# 775
extern void perror(const char * __s); 
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3
extern int sys_nerr; 
# 27
extern const char *const sys_errlist[]; 
# 30
extern int _sys_nerr; 
# 31
extern const char *const _sys_errlist[]; 
# 786 "/usr/include/stdio.h" 3
extern int fileno(FILE * __stream) throw(); 
# 791
extern int fileno_unlocked(FILE * __stream) throw(); 
# 800 "/usr/include/stdio.h" 3
extern FILE *popen(const char * __command, const char * __modes); 
# 806
extern int pclose(FILE * __stream); 
# 812
extern char *ctermid(char * __s) throw(); 
# 818
extern char *cuserid(char * __s); 
# 823
struct obstack; 
# 826
extern int obstack_printf(obstack *__restrict__ __obstack, const char *__restrict__ __format, ...) throw()
# 828
 __attribute((__format__(__printf__, 2, 3))); 
# 829
extern int obstack_vprintf(obstack *__restrict__ __obstack, const char *__restrict__ __format, __gnuc_va_list __args) throw()
# 832
 __attribute((__format__(__printf__, 2, 0))); 
# 840
extern void flockfile(FILE * __stream) throw(); 
# 844
extern int ftrylockfile(FILE * __stream) throw(); 
# 847
extern void funlockfile(FILE * __stream) throw(); 
# 858 "/usr/include/stdio.h" 3
extern int __uflow(FILE *); 
# 859
extern int __overflow(FILE *, int); 
# 873 "/usr/include/stdio.h" 3
}
# 96 "/usr/include/c++/9/cstdio" 3
namespace std { 
# 98
using ::FILE;
# 99
using ::fpos_t;
# 101
using ::clearerr;
# 102
using ::fclose;
# 103
using ::feof;
# 104
using ::ferror;
# 105
using ::fflush;
# 106
using ::fgetc;
# 107
using ::fgetpos;
# 108
using ::fgets;
# 109
using ::fopen;
# 110
using ::fprintf;
# 111
using ::fputc;
# 112
using ::fputs;
# 113
using ::fread;
# 114
using ::freopen;
# 115
using ::fscanf;
# 116
using ::fseek;
# 117
using ::fsetpos;
# 118
using ::ftell;
# 119
using ::fwrite;
# 120
using ::getc;
# 121
using ::getchar;
# 126
using ::perror;
# 127
using ::printf;
# 128
using ::putc;
# 129
using ::putchar;
# 130
using ::puts;
# 131
using ::remove;
# 132
using ::rename;
# 133
using ::rewind;
# 134
using ::scanf;
# 135
using ::setbuf;
# 136
using ::setvbuf;
# 137
using ::sprintf;
# 138
using ::sscanf;
# 139
using ::tmpfile;
# 141
using ::tmpnam;
# 143
using ::ungetc;
# 144
using ::vfprintf;
# 145
using ::vprintf;
# 146
using ::vsprintf;
# 147
}
# 157 "/usr/include/c++/9/cstdio" 3
namespace __gnu_cxx { 
# 175 "/usr/include/c++/9/cstdio" 3
using ::snprintf;
# 176
using ::vfscanf;
# 177
using ::vscanf;
# 178
using ::vsnprintf;
# 179
using ::vsscanf;
# 181
}
# 183
namespace std { 
# 185
using __gnu_cxx::snprintf;
# 186
using __gnu_cxx::vfscanf;
# 187
using __gnu_cxx::vscanf;
# 188
using __gnu_cxx::vsnprintf;
# 189
using __gnu_cxx::vsscanf;
# 190
}
# 34 "/usr/include/errno.h" 3
extern "C" {
# 37
extern int *__errno_location() throw() __attribute((const)); 
# 45
extern char *program_invocation_name; 
# 46
extern char *program_invocation_short_name; 
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3
typedef int error_t; 
# 52 "/usr/include/errno.h" 3
}
# 46 "/usr/include/c++/9/ext/string_conversions.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 51
template< class _TRet, class _Ret = _TRet, class _CharT, class ...
# 52
_Base> _Ret 
# 54
__stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base ...), const char *
# 55
__name, const _CharT *__str, std::size_t *__idx, _Base ...
# 56
__base) 
# 57
{ 
# 58
_Ret __ret; 
# 60
_CharT *__endptr; 
# 66
const 
# 62
struct _Save_errno { 
# 63
_Save_errno() : _M_errno(*__errno_location()) { (*__errno_location()) = 0; } 
# 64
~_Save_errno() { if ((*__errno_location()) == 0) { (*__errno_location()) = (_M_errno); }  } 
# 65
int _M_errno; 
# 66
} __save_errno; 
# 68
struct _Range_chk { 
# 70
static bool _S_chk(_TRet, std::false_type) { return false; } 
# 73
static bool _S_chk(_TRet __val, std::true_type) 
# 74
{ 
# 75
return (__val < ((_TRet)__numeric_traits< int> ::__min)) || (__val > ((_TRet)__numeric_traits< int> ::__max)); 
# 77
} 
# 78
}; 
# 80
const _TRet __tmp = __convf(__str, &__endptr, __base...); 
# 82
if (__endptr == __str) { 
# 83
std::__throw_invalid_argument(__name); } else { 
# 84
if (((*__errno_location()) == 34) || _Range_chk::_S_chk(__tmp, std::is_same< _Ret, int> {})) { 
# 86
std::__throw_out_of_range(__name); } else { 
# 88
__ret = __tmp; }  }  
# 90
if (__idx) { 
# 91
(*__idx) = (__endptr - __str); }  
# 93
return __ret; 
# 94
} 
# 97
template< class _String, class _CharT = typename _String::value_type> _String 
# 99
__to_xstring(int (*__convf)(_CharT *, std::size_t, const _CharT *, __builtin_va_list), std::size_t 
# 100
__n, const _CharT *
# 101
__fmt, ...) 
# 102
{ 
# 105
_CharT *__s = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __n)); 
# 108
__builtin_va_list __args; 
# 109
__builtin_va_start((__args),__fmt); 
# 111
const int __len = __convf(__s, __n, __fmt, __args); 
# 113
__builtin_va_end(__args); 
# 115
return _String(__s, __s + __len); 
# 116
} 
# 119
}
# 6498 "/usr/include/c++/9/bits/basic_string.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 6501
inline namespace __cxx11 { 
# 6506
inline int stoi(const string &__str, size_t *__idx = 0, int __base = 10) 
# 6507
{ return __gnu_cxx::__stoa< long, int> (&std::strtol, "stoi", __str.c_str(), __idx, __base); 
# 6508
} 
# 6511
inline long stol(const string &__str, size_t *__idx = 0, int __base = 10) 
# 6512
{ return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx, __base); 
# 6513
} 
# 6516
inline unsigned long stoul(const string &__str, size_t *__idx = 0, int __base = 10) 
# 6517
{ return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx, __base); 
# 6518
} 
# 6521
inline long long stoll(const string &__str, size_t *__idx = 0, int __base = 10) 
# 6522
{ return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx, __base); 
# 6523
} 
# 6526
inline unsigned long long stoull(const string &__str, size_t *__idx = 0, int __base = 10) 
# 6527
{ return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx, __base); 
# 6528
} 
# 6532
inline float stof(const string &__str, size_t *__idx = 0) 
# 6533
{ return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); } 
# 6536
inline double stod(const string &__str, size_t *__idx = 0) 
# 6537
{ return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); } 
# 6540
inline long double stold(const string &__str, size_t *__idx = 0) 
# 6541
{ return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); } 
# 6549
inline string to_string(int __val) 
# 6550
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, (4) * sizeof(int), "%d", __val); 
# 6551
} 
# 6554
inline string to_string(unsigned __val) 
# 6555
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, (4) * sizeof(unsigned), "%u", __val); 
# 6557
} 
# 6560
inline string to_string(long __val) 
# 6561
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, (4) * sizeof(long), "%ld", __val); 
# 6562
} 
# 6565
inline string to_string(unsigned long __val) 
# 6566
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, (4) * sizeof(unsigned long), "%lu", __val); 
# 6568
} 
# 6571
inline string to_string(long long __val) 
# 6572
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, (4) * sizeof(long long), "%lld", __val); 
# 6574
} 
# 6577
inline string to_string(unsigned long long __val) 
# 6578
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, (4) * sizeof(unsigned long long), "%llu", __val); 
# 6580
} 
# 6583
inline string to_string(float __val) 
# 6584
{ 
# 6585
const int __n = (__gnu_cxx::__numeric_traits_floating< float> ::__max_exponent10 + 20); 
# 6587
return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, __n, "%f", __val); 
# 6589
} 
# 6592
inline string to_string(double __val) 
# 6593
{ 
# 6594
const int __n = (__gnu_cxx::__numeric_traits_floating< double> ::__max_exponent10 + 20); 
# 6596
return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, __n, "%f", __val); 
# 6598
} 
# 6601
inline string to_string(long double __val) 
# 6602
{ 
# 6603
const int __n = (__gnu_cxx::__numeric_traits_floating< long double> ::__max_exponent10 + 20); 
# 6605
return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, __n, "%Lf", __val); 
# 6607
} 
# 6612
inline int stoi(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 6613
{ return __gnu_cxx::__stoa< long, int> (&std::wcstol, "stoi", __str.c_str(), __idx, __base); 
# 6614
} 
# 6617
inline long stol(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 6618
{ return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx, __base); 
# 6619
} 
# 6622
inline unsigned long stoul(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 6623
{ return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx, __base); 
# 6624
} 
# 6627
inline long long stoll(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 6628
{ return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx, __base); 
# 6629
} 
# 6632
inline unsigned long long stoull(const wstring &__str, size_t *__idx = 0, int __base = 10) 
# 6633
{ return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx, __base); 
# 6634
} 
# 6638
inline float stof(const wstring &__str, size_t *__idx = 0) 
# 6639
{ return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); } 
# 6642
inline double stod(const wstring &__str, size_t *__idx = 0) 
# 6643
{ return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); } 
# 6646
inline long double stold(const wstring &__str, size_t *__idx = 0) 
# 6647
{ return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); } 
# 6652
inline wstring to_wstring(int __val) 
# 6653
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, (4) * sizeof(int), L"\x25\x64", __val); 
# 6654
} 
# 6657
inline wstring to_wstring(unsigned __val) 
# 6658
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, (4) * sizeof(unsigned), L"\x25\x75", __val); 
# 6660
} 
# 6663
inline wstring to_wstring(long __val) 
# 6664
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, (4) * sizeof(long), L"\x25\x6c\x64", __val); 
# 6665
} 
# 6668
inline wstring to_wstring(unsigned long __val) 
# 6669
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, (4) * sizeof(unsigned long), L"\x25\x6c\x75", __val); 
# 6671
} 
# 6674
inline wstring to_wstring(long long __val) 
# 6675
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, (4) * sizeof(long long), L"\x25\x6c\x6c\x64", __val); 
# 6677
} 
# 6680
inline wstring to_wstring(unsigned long long __val) 
# 6681
{ return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, (4) * sizeof(unsigned long long), L"\x25\x6c\x6c\x75", __val); 
# 6683
} 
# 6686
inline wstring to_wstring(float __val) 
# 6687
{ 
# 6688
const int __n = (__gnu_cxx::__numeric_traits_floating< float> ::__max_exponent10 + 20); 
# 6690
return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, __n, L"\x25\x66", __val); 
# 6692
} 
# 6695
inline wstring to_wstring(double __val) 
# 6696
{ 
# 6697
const int __n = (__gnu_cxx::__numeric_traits_floating< double> ::__max_exponent10 + 20); 
# 6699
return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, __n, L"\x25\x66", __val); 
# 6701
} 
# 6704
inline wstring to_wstring(long double __val) 
# 6705
{ 
# 6706
const int __n = (__gnu_cxx::__numeric_traits_floating< long double> ::__max_exponent10 + 20); 
# 6708
return __gnu_cxx::__to_xstring< basic_string< wchar_t> > (&std::vswprintf, __n, L"\x25\x4c\x66", __val); 
# 6710
} 
# 6714
}
# 6716
}
# 37 "/usr/include/c++/9/bits/functional_hash.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 49 "/usr/include/c++/9/bits/functional_hash.h" 3
template< class _Result, class _Arg> 
# 50
struct __hash_base { 
# 52
typedef _Result result_type; 
# 53
typedef _Arg argument_type; 
# 54
}; 
# 57
template< class _Tp> struct hash; 
# 60
template< class _Tp, class  = void> 
# 61
struct __poison_hash { 
# 63
static constexpr bool __enable_hash_call = false; 
# 66
private: __poison_hash(__poison_hash &&); 
# 67
~__poison_hash(); 
# 68
}; 
# 70
template< class _Tp> 
# 71
struct __poison_hash< _Tp, __void_t< __decltype((hash< _Tp> ()(declval< _Tp> ())))> >  { 
# 73
static constexpr bool __enable_hash_call = true; 
# 74
}; 
# 77
template< class _Tp, bool  = is_enum< _Tp> ::value> 
# 78
struct __hash_enum { 
# 82
private: __hash_enum(__hash_enum &&); 
# 83
~__hash_enum(); 
# 84
}; 
# 87
template< class _Tp> 
# 88
struct __hash_enum< _Tp, true>  : public __hash_base< unsigned long, _Tp>  { 
# 91
std::size_t operator()(_Tp __val) const noexcept 
# 92
{ 
# 93
using __type = typename underlying_type< _Tp> ::type; 
# 94
return hash< typename underlying_type< _Tp> ::type> {}(static_cast< __type>(__val)); 
# 95
} 
# 96
}; 
# 100
template< class _Tp> 
# 101
struct hash : public __hash_enum< _Tp>  { 
# 102
}; 
# 105
template< class _Tp> 
# 106
struct hash< _Tp *>  : public __hash_base< unsigned long, _Tp *>  { 
# 109
std::size_t operator()(_Tp *__p) const noexcept 
# 110
{ return reinterpret_cast< std::size_t>(__p); } 
# 111
}; 
# 124 "/usr/include/c++/9/bits/functional_hash.h" 3
template<> struct hash< bool>  : public __hash_base< unsigned long, bool>  { size_t operator()(bool __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 127
template<> struct hash< char>  : public __hash_base< unsigned long, char>  { size_t operator()(char __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 130
template<> struct hash< signed char>  : public __hash_base< unsigned long, signed char>  { size_t operator()(signed char __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 133
template<> struct hash< unsigned char>  : public __hash_base< unsigned long, unsigned char>  { size_t operator()(unsigned char __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 136
template<> struct hash< wchar_t>  : public __hash_base< unsigned long, wchar_t>  { size_t operator()(wchar_t __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 144
template<> struct hash< char16_t>  : public __hash_base< unsigned long, char16_t>  { size_t operator()(char16_t __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 147
template<> struct hash< char32_t>  : public __hash_base< unsigned long, char32_t>  { size_t operator()(char32_t __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 150
template<> struct hash< short>  : public __hash_base< unsigned long, short>  { size_t operator()(short __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 153
template<> struct hash< int>  : public __hash_base< unsigned long, int>  { size_t operator()(int __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 156
template<> struct hash< long>  : public __hash_base< unsigned long, long>  { size_t operator()(long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 159
template<> struct hash< long long>  : public __hash_base< unsigned long, long long>  { size_t operator()(long long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 162
template<> struct hash< unsigned short>  : public __hash_base< unsigned long, unsigned short>  { size_t operator()(unsigned short __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 165
template<> struct hash< unsigned>  : public __hash_base< unsigned long, unsigned>  { size_t operator()(unsigned __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 168
template<> struct hash< unsigned long>  : public __hash_base< unsigned long, unsigned long>  { size_t operator()(unsigned long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 171
template<> struct hash< unsigned long long>  : public __hash_base< unsigned long, unsigned long long>  { size_t operator()(unsigned long long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 174
template<> struct hash< __int128>  : public __hash_base< unsigned long, __int128>  { size_t operator()(__int128 __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 175
template<> struct hash< unsigned __int128>  : public __hash_base< unsigned long, unsigned __int128>  { size_t operator()(unsigned __int128 __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 192 "/usr/include/c++/9/bits/functional_hash.h" 3
struct _Hash_impl { 
# 195
static size_t hash(const void *__ptr, size_t __clength, size_t 
# 196
__seed = static_cast< size_t>(3339675911UL)) 
# 197
{ return _Hash_bytes(__ptr, __clength, __seed); } 
# 199
template< class _Tp> static size_t 
# 201
hash(const _Tp &__val) 
# 202
{ return hash(&__val, sizeof(__val)); } 
# 204
template< class _Tp> static size_t 
# 206
__hash_combine(const _Tp &__val, size_t __hash) 
# 207
{ return hash(&__val, sizeof(__val), __hash); } 
# 208
}; 
# 211
struct _Fnv_hash_impl { 
# 214
static size_t hash(const void *__ptr, size_t __clength, size_t 
# 215
__seed = static_cast< size_t>(2166136261UL)) 
# 216
{ return _Fnv_hash_bytes(__ptr, __clength, __seed); } 
# 218
template< class _Tp> static size_t 
# 220
hash(const _Tp &__val) 
# 221
{ return hash(&__val, sizeof(__val)); } 
# 223
template< class _Tp> static size_t 
# 225
__hash_combine(const _Tp &__val, size_t __hash) 
# 226
{ return hash(&__val, sizeof(__val), __hash); } 
# 227
}; 
# 231
template<> struct hash< float>  : public __hash_base< unsigned long, float>  { 
# 234
size_t operator()(float __val) const noexcept 
# 235
{ 
# 237
return (__val != (0.0F)) ? std::_Hash_impl::hash(__val) : (0); 
# 238
} 
# 239
}; 
# 243
template<> struct hash< double>  : public __hash_base< unsigned long, double>  { 
# 246
size_t operator()(double __val) const noexcept 
# 247
{ 
# 249
return (__val != (0.0)) ? std::_Hash_impl::hash(__val) : (0); 
# 250
} 
# 251
}; 
# 255
template<> struct hash< long double>  : public __hash_base< unsigned long, long double>  { 
# 258
__attribute((__pure__)) size_t 
# 259
operator()(long double __val) const noexcept; 
# 260
}; 
# 278 "/usr/include/c++/9/bits/functional_hash.h" 3
template< class _Hash> 
# 279
struct __is_fast_hash : public true_type { 
# 280
}; 
# 283
template<> struct __is_fast_hash< hash< long double> >  : public false_type { 
# 284
}; 
# 287
}
# 6724 "/usr/include/c++/9/bits/basic_string.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 6733
template<> struct hash< __cxx11::basic_string< char> >  : public __hash_base< unsigned long, __cxx11::basic_string< char> >  { 
# 6737
size_t operator()(const string &__s) const noexcept 
# 6738
{ return std::_Hash_impl::hash(__s.data(), __s.length()); } 
# 6739
}; 
# 6742
template<> struct __is_fast_hash< hash< __cxx11::basic_string< char> > >  : public false_type { 
# 6743
}; 
# 6748
template<> struct hash< __cxx11::basic_string< wchar_t> >  : public __hash_base< unsigned long, __cxx11::basic_string< wchar_t> >  { 
# 6752
size_t operator()(const wstring &__s) const noexcept 
# 6753
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t)); 
# 6754
} 
# 6755
}; 
# 6758
template<> struct __is_fast_hash< hash< __cxx11::basic_string< wchar_t> > >  : public false_type { 
# 6759
}; 
# 6782 "/usr/include/c++/9/bits/basic_string.h" 3
template<> struct hash< __cxx11::basic_string< char16_t> >  : public __hash_base< unsigned long, __cxx11::basic_string< char16_t> >  { 
# 6786
size_t operator()(const u16string &__s) const noexcept 
# 6787
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t)); 
# 6788
} 
# 6789
}; 
# 6792
template<> struct __is_fast_hash< hash< __cxx11::basic_string< char16_t> > >  : public false_type { 
# 6793
}; 
# 6797
template<> struct hash< __cxx11::basic_string< char32_t> >  : public __hash_base< unsigned long, __cxx11::basic_string< char32_t> >  { 
# 6801
size_t operator()(const u32string &__s) const noexcept 
# 6802
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t)); 
# 6803
} 
# 6804
}; 
# 6807
template<> struct __is_fast_hash< hash< __cxx11::basic_string< char32_t> > >  : public false_type { 
# 6808
}; 
# 6814
inline namespace literals { 
# 6816
inline namespace string_literals { 
# 6818
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
__attribute((__abi_tag__("cxx11"))) inline __cxx11::basic_string< char>  
# 6822
operator ""s(const char *__str, size_t __len) 
# 6823
{ return __cxx11::basic_string< char> {__str, __len}; } 
# 6826
__attribute((__abi_tag__("cxx11"))) inline __cxx11::basic_string< wchar_t>  
# 6828
operator ""s(const wchar_t *__str, size_t __len) 
# 6829
{ return __cxx11::basic_string< wchar_t> {__str, __len}; } 
# 6839 "/usr/include/c++/9/bits/basic_string.h" 3
__attribute((__abi_tag__("cxx11"))) inline __cxx11::basic_string< char16_t>  
# 6841
operator ""s(const char16_t *__str, size_t __len) 
# 6842
{ return __cxx11::basic_string< char16_t> {__str, __len}; } 
# 6844
__attribute((__abi_tag__("cxx11"))) inline __cxx11::basic_string< char32_t>  
# 6846
operator ""s(const char32_t *__str, size_t __len) 
# 6847
{ return __cxx11::basic_string< char32_t> {__str, __len}; } 
# 6849
#pragma GCC diagnostic pop
}
# 6851
}
# 6872 "/usr/include/c++/9/bits/basic_string.h" 3
}
# 46 "/usr/include/c++/9/bits/basic_string.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _CharT, class _Traits, class _Alloc> const typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __cxx11::basic_string< _CharT, _Traits, _Alloc> ::npos; 
# 56
template< class _CharT, class _Traits, class _Alloc> void 
# 59
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::swap(basic_string &__s) noexcept 
# 60
{ 
# 61
if (this == (&__s)) { 
# 62
return; }  
# 64
_Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator()); 
# 66
if (_M_is_local()) { 
# 67
if (__s._M_is_local()) 
# 68
{ 
# 69
if (length() && __s.length()) 
# 70
{ 
# 71
_CharT __tmp_data[_S_local_capacity + 1]; 
# 72
traits_type::copy(__tmp_data, __s._M_local_buf, _S_local_capacity + 1); 
# 74
traits_type::copy(__s._M_local_buf, _M_local_buf, _S_local_capacity + 1); 
# 76
traits_type::copy(_M_local_buf, __tmp_data, _S_local_capacity + 1); 
# 78
} else { 
# 79
if (__s.length()) 
# 80
{ 
# 81
traits_type::copy(_M_local_buf, __s._M_local_buf, _S_local_capacity + 1); 
# 83
_M_length(__s.length()); 
# 84
__s._M_set_length(0); 
# 85
return; 
# 86
} else { 
# 87
if (length()) 
# 88
{ 
# 89
traits_type::copy(__s._M_local_buf, _M_local_buf, _S_local_capacity + 1); 
# 91
__s._M_length(length()); 
# 92
_M_set_length(0); 
# 93
return; 
# 94
}  }  }  
# 95
} else 
# 97
{ 
# 98
const size_type __tmp_capacity = __s._M_allocated_capacity; 
# 99
traits_type::copy(__s._M_local_buf, _M_local_buf, _S_local_capacity + 1); 
# 101
_M_data(__s._M_data()); 
# 102
__s._M_data(__s._M_local_buf); 
# 103
_M_capacity(__tmp_capacity); 
# 104
}  } else 
# 106
{ 
# 107
const size_type __tmp_capacity = _M_allocated_capacity; 
# 108
if (__s._M_is_local()) 
# 109
{ 
# 110
traits_type::copy(_M_local_buf, __s._M_local_buf, _S_local_capacity + 1); 
# 112
__s._M_data(_M_data()); 
# 113
_M_data(_M_local_buf); 
# 114
} else 
# 116
{ 
# 117
pointer __tmp_ptr = _M_data(); 
# 118
_M_data(__s._M_data()); 
# 119
__s._M_data(__tmp_ptr); 
# 120
_M_capacity(__s._M_allocated_capacity); 
# 121
}  
# 122
__s._M_capacity(__tmp_capacity); 
# 123
}  
# 125
const size_type __tmp_length = length(); 
# 126
_M_length(__s.length()); 
# 127
__s._M_length(__tmp_length); 
# 128
} 
# 130
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::pointer 
# 133
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_create(size_type &__capacity, size_type __old_capacity) 
# 134
{ 
# 137
if (__capacity > max_size()) { 
# 138
std::__throw_length_error("basic_string::_M_create"); }  
# 143
if ((__capacity > __old_capacity) && (__capacity < (2 * __old_capacity))) 
# 144
{ 
# 145
__capacity = (2 * __old_capacity); 
# 147
if (__capacity > max_size()) { 
# 148
__capacity = max_size(); }  
# 149
}  
# 153
return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1); 
# 154
} 
# 160
template< class _CharT, class _Traits, class _Alloc> 
# 161
template< class _InIterator> void 
# 164
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(_InIterator __beg, _InIterator __end, input_iterator_tag) 
# 166
{ 
# 167
size_type __len = (0); 
# 168
size_type __capacity = ((size_type)_S_local_capacity); 
# 170
while ((__beg != __end) && (__len < __capacity)) 
# 171
{ 
# 172
(_M_data()[__len++]) = (*__beg); 
# 173
++__beg; 
# 174
}  
# 176
try 
# 177
{ 
# 178
while (__beg != __end) 
# 179
{ 
# 180
if (__len == __capacity) 
# 181
{ 
# 183
__capacity = (__len + 1); 
# 184
pointer __another = _M_create(__capacity, __len); 
# 185
this->_S_copy(__another, _M_data(), __len); 
# 186
_M_dispose(); 
# 187
_M_data(__another); 
# 188
_M_capacity(__capacity); 
# 189
}  
# 190
(_M_data()[__len++]) = (*__beg); 
# 191
++__beg; 
# 192
}  
# 193
} 
# 194
catch (...) 
# 195
{ 
# 196
_M_dispose(); 
# 197
throw; 
# 198
}  
# 200
_M_set_length(__len); 
# 201
} 
# 203
template< class _CharT, class _Traits, class _Alloc> 
# 204
template< class _InIterator> void 
# 207
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(_InIterator __beg, _InIterator __end, forward_iterator_tag) 
# 209
{ 
# 211
if (__gnu_cxx::__is_null_pointer(__beg) && (__beg != __end)) { 
# 212
std::__throw_logic_error("basic_string::_M_construct null not valid"); }  
# 215
size_type __dnew = static_cast< size_type>(std::distance(__beg, __end)); 
# 217
if (__dnew > ((size_type)_S_local_capacity)) 
# 218
{ 
# 219
_M_data(_M_create(__dnew, (size_type)0)); 
# 220
_M_capacity(__dnew); 
# 221
}  
# 224
try 
# 225
{ this->_S_copy_chars(_M_data(), __beg, __end); } 
# 226
catch (...) 
# 227
{ 
# 228
_M_dispose(); 
# 229
throw; 
# 230
}  
# 232
_M_set_length(__dnew); 
# 233
} 
# 235
template< class _CharT, class _Traits, class _Alloc> void 
# 238
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_construct(size_type __n, _CharT __c) 
# 239
{ 
# 240
if (__n > ((size_type)_S_local_capacity)) 
# 241
{ 
# 242
_M_data(_M_create(__n, (size_type)0)); 
# 243
_M_capacity(__n); 
# 244
}  
# 246
if (__n) { 
# 247
this->_S_assign(_M_data(), __n, __c); }  
# 249
_M_set_length(__n); 
# 250
} 
# 252
template< class _CharT, class _Traits, class _Alloc> void 
# 255
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_assign(const basic_string &__str) 
# 256
{ 
# 257
if (this != (&__str)) 
# 258
{ 
# 259
const size_type __rsize = __str.length(); 
# 260
const size_type __capacity = capacity(); 
# 262
if (__rsize > __capacity) 
# 263
{ 
# 264
size_type __new_capacity = __rsize; 
# 265
pointer __tmp = _M_create(__new_capacity, __capacity); 
# 266
_M_dispose(); 
# 267
_M_data(__tmp); 
# 268
_M_capacity(__new_capacity); 
# 269
}  
# 271
if (__rsize) { 
# 272
this->_S_copy(_M_data(), __str._M_data(), __rsize); }  
# 274
_M_set_length(__rsize); 
# 275
}  
# 276
} 
# 278
template< class _CharT, class _Traits, class _Alloc> void 
# 281
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::reserve(size_type __res) 
# 282
{ 
# 284
if (__res < length()) { 
# 285
__res = length(); }  
# 287
const size_type __capacity = capacity(); 
# 288
if (__res != __capacity) 
# 289
{ 
# 290
if ((__res > __capacity) || (__res > ((size_type)_S_local_capacity))) 
# 292
{ 
# 293
pointer __tmp = _M_create(__res, __capacity); 
# 294
this->_S_copy(__tmp, _M_data(), length() + 1); 
# 295
_M_dispose(); 
# 296
_M_data(__tmp); 
# 297
_M_capacity(__res); 
# 298
} else { 
# 299
if (!_M_is_local()) 
# 300
{ 
# 301
this->_S_copy(_M_local_data(), _M_data(), length() + 1); 
# 302
_M_destroy(__capacity); 
# 303
_M_data(_M_local_data()); 
# 304
}  }  
# 305
}  
# 306
} 
# 308
template< class _CharT, class _Traits, class _Alloc> void 
# 311
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_mutate(size_type __pos, size_type __len1, const _CharT *__s, size_type 
# 312
__len2) 
# 313
{ 
# 314
const size_type __how_much = (length() - __pos) - __len1; 
# 316
size_type __new_capacity = (length() + __len2) - __len1; 
# 317
pointer __r = _M_create(__new_capacity, capacity()); 
# 319
if (__pos) { 
# 320
this->_S_copy(__r, _M_data(), __pos); }  
# 321
if (__s && __len2) { 
# 322
this->_S_copy(__r + __pos, __s, __len2); }  
# 323
if (__how_much) { 
# 324
this->_S_copy((__r + __pos) + __len2, (_M_data() + __pos) + __len1, __how_much); }  
# 327
_M_dispose(); 
# 328
_M_data(__r); 
# 329
_M_capacity(__new_capacity); 
# 330
} 
# 332
template< class _CharT, class _Traits, class _Alloc> void 
# 335
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_erase(size_type __pos, size_type __n) 
# 336
{ 
# 337
const size_type __how_much = (length() - __pos) - __n; 
# 339
if (__how_much && __n) { 
# 340
this->_S_move(_M_data() + __pos, (_M_data() + __pos) + __n, __how_much); }  
# 342
_M_set_length(length() - __n); 
# 343
} 
# 345
template< class _CharT, class _Traits, class _Alloc> void 
# 348
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::resize(size_type __n, _CharT __c) 
# 349
{ 
# 350
const size_type __size = size(); 
# 351
if (__size < __n) { 
# 352
this->append(__n - __size, __c); } else { 
# 353
if (__n < __size) { 
# 354
_M_set_length(__n); }  }  
# 355
} 
# 357
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 360
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_append(const _CharT *__s, size_type __n) 
# 361
{ 
# 362
const size_type __len = __n + size(); 
# 364
if (__len <= capacity()) 
# 365
{ 
# 366
if (__n) { 
# 367
this->_S_copy(this->_M_data() + size(), __s, __n); }  
# 368
} else { 
# 370
_M_mutate(size(), (size_type)0, __s, __n); }  
# 372
_M_set_length(__len); 
# 373
return *this; 
# 374
} 
# 376
template< class _CharT, class _Traits, class _Alloc> 
# 377
template< class _InputIterator> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 380
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace_dispatch(const_iterator __i1, const_iterator __i2, _InputIterator 
# 381
__k1, _InputIterator __k2, __false_type) 
# 383
{ 
# 384
const basic_string __s(__k1, __k2); 
# 385
const size_type __n1 = __i2 - __i1; 
# 386
return _M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size()); 
# 388
} 
# 390
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 393
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace_aux(size_type __pos1, size_type __n1, size_type __n2, _CharT 
# 394
__c) 
# 395
{ 
# 396
_M_check_length(__n1, __n2, "basic_string::_M_replace_aux"); 
# 398
const size_type __old_size = size(); 
# 399
const size_type __new_size = (__old_size + __n2) - __n1; 
# 401
if (__new_size <= capacity()) 
# 402
{ 
# 403
pointer __p = this->_M_data() + __pos1; 
# 405
const size_type __how_much = (__old_size - __pos1) - __n1; 
# 406
if (__how_much && (__n1 != __n2)) { 
# 407
this->_S_move(__p + __n2, __p + __n1, __how_much); }  
# 408
} else { 
# 410
_M_mutate(__pos1, __n1, 0, __n2); }  
# 412
if (__n2) { 
# 413
this->_S_assign(this->_M_data() + __pos1, __n2, __c); }  
# 415
_M_set_length(__new_size); 
# 416
return *this; 
# 417
} 
# 419
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 422
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::_M_replace(size_type __pos, size_type __len1, const _CharT *__s, const size_type 
# 423
__len2) 
# 424
{ 
# 425
_M_check_length(__len1, __len2, "basic_string::_M_replace"); 
# 427
const size_type __old_size = size(); 
# 428
const size_type __new_size = (__old_size + __len2) - __len1; 
# 430
if (__new_size <= capacity()) 
# 431
{ 
# 432
pointer __p = this->_M_data() + __pos; 
# 434
const size_type __how_much = (__old_size - __pos) - __len1; 
# 435
if (_M_disjunct(__s)) 
# 436
{ 
# 437
if (__how_much && (__len1 != __len2)) { 
# 438
this->_S_move(__p + __len2, __p + __len1, __how_much); }  
# 439
if (__len2) { 
# 440
this->_S_copy(__p, __s, __len2); }  
# 441
} else 
# 443
{ 
# 445
if (__len2 && (__len2 <= __len1)) { 
# 446
this->_S_move(__p, __s, __len2); }  
# 447
if (__how_much && (__len1 != __len2)) { 
# 448
this->_S_move(__p + __len2, __p + __len1, __how_much); }  
# 449
if (__len2 > __len1) 
# 450
{ 
# 451
if ((__s + __len2) <= (__p + __len1)) { 
# 452
this->_S_move(__p, __s, __len2); } else { 
# 453
if (__s >= (__p + __len1)) { 
# 454
this->_S_copy(__p, (__s + __len2) - __len1, __len2); } else 
# 456
{ 
# 457
const size_type __nleft = (__p + __len1) - __s; 
# 458
this->_S_move(__p, __s, __nleft); 
# 459
this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft); 
# 461
}  }  
# 462
}  
# 463
}  
# 464
} else { 
# 466
_M_mutate(__pos, __len1, __s, __len2); }  
# 468
_M_set_length(__new_size); 
# 469
return *this; 
# 470
} 
# 472
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 475
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::copy(_CharT *__s, size_type __n, size_type __pos) const 
# 476
{ 
# 477
_M_check(__pos, "basic_string::copy"); 
# 478
__n = _M_limit(__pos, __n); 
# 479
; 
# 480
if (__n) { 
# 481
(_S_copy)(__s, _M_data() + __pos, __n); }  
# 483
return __n; 
# 484
} 
# 1156 "/usr/include/c++/9/bits/basic_string.tcc" 3
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 1158
operator+(const _CharT *__lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1159
__rhs) 
# 1160
{ 
# 1161
; 
# 1162
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1163
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1164
const __size_type __len = _Traits::length(__lhs); 
# 1165
__string_type __str; 
# 1166
__str.reserve(__len + __rhs.size()); 
# 1167
__str.append(__lhs, __len); 
# 1168
__str.append(__rhs); 
# 1169
return __str; 
# 1170
} 
# 1172
template< class _CharT, class _Traits, class _Alloc> __cxx11::basic_string< _CharT, _Traits, _Alloc>  
# 1174
operator+(_CharT __lhs, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__rhs) 
# 1175
{ 
# 1176
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1177
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1178
__string_type __str; 
# 1179
const __size_type __len = __rhs.size(); 
# 1180
__str.reserve(__len + 1); 
# 1181
__str.append((__size_type)1, __lhs); 
# 1182
__str.append(__rhs); 
# 1183
return __str; 
# 1184
} 
# 1186
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1189
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find(const _CharT *__s, size_type __pos, size_type __n) const noexcept 
# 1191
{ 
# 1192
; 
# 1193
const size_type __size = size(); 
# 1195
if (__n == 0) { 
# 1196
return (__pos <= __size) ? __pos : npos; }  
# 1197
if (__pos >= __size) { 
# 1198
return npos; }  
# 1200
const _CharT __elem0 = __s[0]; 
# 1201
const _CharT *const __data = data(); 
# 1202
const _CharT *__first = __data + __pos; 
# 1203
const _CharT *const __last = __data + __size; 
# 1204
size_type __len = __size - __pos; 
# 1206
while (__len >= __n) 
# 1207
{ 
# 1209
__first = traits_type::find(__first, (__len - __n) + 1, __elem0); 
# 1210
if (!__first) { 
# 1211
return npos; }  
# 1215
if (traits_type::compare(__first, __s, __n) == 0) { 
# 1216
return __first - __data; }  
# 1217
__len = (__last - (++__first)); 
# 1218
}  
# 1219
return npos; 
# 1220
} 
# 1222
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1225
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find(_CharT __c, size_type __pos) const noexcept 
# 1226
{ 
# 1227
size_type __ret = npos; 
# 1228
const size_type __size = size(); 
# 1229
if (__pos < __size) 
# 1230
{ 
# 1231
const _CharT *__data = _M_data(); 
# 1232
const size_type __n = __size - __pos; 
# 1233
const _CharT *__p = traits_type::find(__data + __pos, __n, __c); 
# 1234
if (__p) { 
# 1235
__ret = (__p - __data); }  
# 1236
}  
# 1237
return __ret; 
# 1238
} 
# 1240
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1243
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::rfind(const _CharT *__s, size_type __pos, size_type __n) const noexcept 
# 1245
{ 
# 1246
; 
# 1247
const size_type __size = size(); 
# 1248
if (__n <= __size) 
# 1249
{ 
# 1250
__pos = std::min((size_type)(__size - __n), __pos); 
# 1251
const _CharT *__data = _M_data(); 
# 1252
do 
# 1253
{ 
# 1254
if (traits_type::compare(__data + __pos, __s, __n) == 0) { 
# 1255
return __pos; }  
# 1256
} 
# 1257
while ((__pos--) > 0); 
# 1258
}  
# 1259
return npos; 
# 1260
} 
# 1262
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1265
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::rfind(_CharT __c, size_type __pos) const noexcept 
# 1266
{ 
# 1267
size_type __size = size(); 
# 1268
if (__size) 
# 1269
{ 
# 1270
if ((--__size) > __pos) { 
# 1271
__size = __pos; }  
# 1272
for (++__size; (__size--) > 0;) { 
# 1273
if (traits_type::eq(_M_data()[__size], __c)) { 
# 1274
return __size; }  }  
# 1275
}  
# 1276
return npos; 
# 1277
} 
# 1279
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1282
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept 
# 1284
{ 
# 1285
; 
# 1286
for (; __n && (__pos < size()); ++__pos) 
# 1287
{ 
# 1288
const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]); 
# 1289
if (__p) { 
# 1290
return __pos; }  
# 1291
}  
# 1292
return npos; 
# 1293
} 
# 1295
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1298
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept 
# 1300
{ 
# 1301
; 
# 1302
size_type __size = size(); 
# 1303
if (__size && __n) 
# 1304
{ 
# 1305
if ((--__size) > __pos) { 
# 1306
__size = __pos; }  
# 1307
do 
# 1308
{ 
# 1309
if (traits_type::find(__s, __n, _M_data()[__size])) { 
# 1310
return __size; }  
# 1311
} 
# 1312
while ((__size--) != 0); 
# 1313
}  
# 1314
return npos; 
# 1315
} 
# 1317
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1320
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept 
# 1322
{ 
# 1323
; 
# 1324
for (; __pos < size(); ++__pos) { 
# 1325
if (!traits_type::find(__s, __n, _M_data()[__pos])) { 
# 1326
return __pos; }  }  
# 1327
return npos; 
# 1328
} 
# 1330
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1333
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const noexcept 
# 1334
{ 
# 1335
for (; __pos < size(); ++__pos) { 
# 1336
if (!traits_type::eq(_M_data()[__pos], __c)) { 
# 1337
return __pos; }  }  
# 1338
return npos; 
# 1339
} 
# 1341
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1344
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const noexcept 
# 1346
{ 
# 1347
; 
# 1348
size_type __size = size(); 
# 1349
if (__size) 
# 1350
{ 
# 1351
if ((--__size) > __pos) { 
# 1352
__size = __pos; }  
# 1353
do 
# 1354
{ 
# 1355
if (!traits_type::find(__s, __n, _M_data()[__size])) { 
# 1356
return __size; }  
# 1357
} 
# 1358
while (__size--); 
# 1359
}  
# 1360
return npos; 
# 1361
} 
# 1363
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type 
# 1366
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::find_last_not_of(_CharT __c, size_type __pos) const noexcept 
# 1367
{ 
# 1368
size_type __size = size(); 
# 1369
if (__size) 
# 1370
{ 
# 1371
if ((--__size) > __pos) { 
# 1372
__size = __pos; }  
# 1373
do 
# 1374
{ 
# 1375
if (!traits_type::eq(_M_data()[__size], __c)) { 
# 1376
return __size; }  
# 1377
} 
# 1378
while (__size--); 
# 1379
}  
# 1380
return npos; 
# 1381
} 
# 1383
template< class _CharT, class _Traits, class _Alloc> int 
# 1386
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n, const basic_string &__str) const 
# 1387
{ 
# 1388
_M_check(__pos, "basic_string::compare"); 
# 1389
__n = _M_limit(__pos, __n); 
# 1390
const size_type __osize = __str.size(); 
# 1391
const size_type __len = std::min(__n, __osize); 
# 1392
int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len); 
# 1393
if (!__r) { 
# 1394
__r = (_S_compare)(__n, __osize); }  
# 1395
return __r; 
# 1396
} 
# 1398
template< class _CharT, class _Traits, class _Alloc> int 
# 1401
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos1, size_type __n1, const basic_string &__str, size_type 
# 1402
__pos2, size_type __n2) const 
# 1403
{ 
# 1404
_M_check(__pos1, "basic_string::compare"); 
# 1405
__str._M_check(__pos2, "basic_string::compare"); 
# 1406
__n1 = _M_limit(__pos1, __n1); 
# 1407
__n2 = __str._M_limit(__pos2, __n2); 
# 1408
const size_type __len = std::min(__n1, __n2); 
# 1409
int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len); 
# 1411
if (!__r) { 
# 1412
__r = (_S_compare)(__n1, __n2); }  
# 1413
return __r; 
# 1414
} 
# 1416
template< class _CharT, class _Traits, class _Alloc> int 
# 1419
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(const _CharT *__s) const noexcept 
# 1420
{ 
# 1421
; 
# 1422
const size_type __size = size(); 
# 1423
const size_type __osize = traits_type::length(__s); 
# 1424
const size_type __len = std::min(__size, __osize); 
# 1425
int __r = traits_type::compare(_M_data(), __s, __len); 
# 1426
if (!__r) { 
# 1427
__r = (_S_compare)(__size, __osize); }  
# 1428
return __r; 
# 1429
} 
# 1431
template< class _CharT, class _Traits, class _Alloc> int 
# 1434
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n1, const _CharT *__s) const 
# 1435
{ 
# 1436
; 
# 1437
_M_check(__pos, "basic_string::compare"); 
# 1438
__n1 = _M_limit(__pos, __n1); 
# 1439
const size_type __osize = traits_type::length(__s); 
# 1440
const size_type __len = std::min(__n1, __osize); 
# 1441
int __r = traits_type::compare(_M_data() + __pos, __s, __len); 
# 1442
if (!__r) { 
# 1443
__r = (_S_compare)(__n1, __osize); }  
# 1444
return __r; 
# 1445
} 
# 1447
template< class _CharT, class _Traits, class _Alloc> int 
# 1450
__cxx11::basic_string< _CharT, _Traits, _Alloc> ::compare(size_type __pos, size_type __n1, const _CharT *__s, size_type 
# 1451
__n2) const 
# 1452
{ 
# 1453
; 
# 1454
_M_check(__pos, "basic_string::compare"); 
# 1455
__n1 = _M_limit(__pos, __n1); 
# 1456
const size_type __len = std::min(__n1, __n2); 
# 1457
int __r = traits_type::compare(_M_data() + __pos, __s, __len); 
# 1458
if (!__r) { 
# 1459
__r = (_S_compare)(__n1, __n2); }  
# 1460
return __r; 
# 1461
} 
# 1464
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &
# 1466
operator>>(basic_istream< _CharT, _Traits>  &__in, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1467
__str) 
# 1468
{ 
# 1469
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1470
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1471
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1472
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1473
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1474
typedef ctype< _CharT>  __ctype_type; 
# 1475
typedef typename ctype< _CharT> ::ctype_base __ctype_base; 
# 1477
__size_type __extracted = (0); 
# 1478
typename basic_istream< _CharT, _Traits> ::ios_base::iostate __err = (__ios_base::goodbit); 
# 1479
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 1480
if (__cerb) 
# 1481
{ 
# 1482
try 
# 1483
{ 
# 1485
__str.erase(); 
# 1486
_CharT __buf[128]; 
# 1487
__size_type __len = (0); 
# 1488
const streamsize __w = __in.width(); 
# 1489
const __size_type __n = (__w > (0)) ? static_cast< __size_type>(__w) : __str.max_size(); 
# 1491
const __ctype_type &__ct = use_facet< ctype< _CharT> > (__in.getloc()); 
# 1492
const __int_type __eof = _Traits::eof(); 
# 1493
__int_type __c = __in.rdbuf()->sgetc(); 
# 1495
while ((__extracted < __n) && (!_Traits::eq_int_type(__c, __eof)) && (!__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))) 
# 1499
{ 
# 1500
if (__len == (sizeof(__buf) / sizeof(_CharT))) 
# 1501
{ 
# 1502
__str.append(__buf, sizeof(__buf) / sizeof(_CharT)); 
# 1503
__len = 0; 
# 1504
}  
# 1505
(__buf[__len++]) = _Traits::to_char_type(__c); 
# 1506
++__extracted; 
# 1507
__c = __in.rdbuf()->snextc(); 
# 1508
}  
# 1509
__str.append(__buf, __len); 
# 1511
if (_Traits::eq_int_type(__c, __eof)) { 
# 1512
__err |= __ios_base::eofbit; }  
# 1513
__in.width(0); 
# 1514
} 
# 1515
catch (__cxxabiv1::__forced_unwind &) 
# 1516
{ 
# 1517
__in._M_setstate(__ios_base::badbit); 
# 1518
throw; 
# 1519
} 
# 1520
catch (...) 
# 1521
{ 
# 1525
__in._M_setstate(__ios_base::badbit); 
# 1526
}  
# 1527
}  
# 1529
if (!__extracted) { 
# 1530
__err |= __ios_base::failbit; }  
# 1531
if (__err) { 
# 1532
__in.setstate(__err); }  
# 1533
return __in; 
# 1534
} 
# 1536
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &
# 1538
getline(basic_istream< _CharT, _Traits>  &__in, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 1539
__str, _CharT __delim) 
# 1540
{ 
# 1541
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1542
typedef __cxx11::basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 1543
typedef typename basic_istream< _CharT, _Traits> ::ios_base __ios_base; 
# 1544
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1545
typedef typename __cxx11::basic_string< _CharT, _Traits, _Alloc> ::size_type __size_type; 
# 1547
__size_type __extracted = (0); 
# 1548
const __size_type __n = __str.max_size(); 
# 1549
typename basic_istream< _CharT, _Traits> ::ios_base::iostate __err = (__ios_base::goodbit); 
# 1550
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, true); 
# 1551
if (__cerb) 
# 1552
{ 
# 1553
try 
# 1554
{ 
# 1555
__str.erase(); 
# 1556
const __int_type __idelim = _Traits::to_int_type(__delim); 
# 1557
const __int_type __eof = _Traits::eof(); 
# 1558
__int_type __c = __in.rdbuf()->sgetc(); 
# 1560
while ((__extracted < __n) && (!_Traits::eq_int_type(__c, __eof)) && (!_Traits::eq_int_type(__c, __idelim))) 
# 1563
{ 
# 1564
__str += _Traits::to_char_type(__c); 
# 1565
++__extracted; 
# 1566
__c = __in.rdbuf()->snextc(); 
# 1567
}  
# 1569
if (_Traits::eq_int_type(__c, __eof)) { 
# 1570
__err |= __ios_base::eofbit; } else { 
# 1571
if (_Traits::eq_int_type(__c, __idelim)) 
# 1572
{ 
# 1573
++__extracted; 
# 1574
__in.rdbuf()->sbumpc(); 
# 1575
} else { 
# 1577
__err |= __ios_base::failbit; }  }  
# 1578
} 
# 1579
catch (__cxxabiv1::__forced_unwind &) 
# 1580
{ 
# 1581
__in._M_setstate(__ios_base::badbit); 
# 1582
throw; 
# 1583
} 
# 1584
catch (...) 
# 1585
{ 
# 1589
__in._M_setstate(__ios_base::badbit); 
# 1590
}  
# 1591
}  
# 1592
if (!__extracted) { 
# 1593
__err |= __ios_base::failbit; }  
# 1594
if (__err) { 
# 1595
__in.setstate(__err); }  
# 1596
return __in; 
# 1597
} 
# 1608 "/usr/include/c++/9/bits/basic_string.tcc" 3
extern template class __cxx11::basic_string< char> ;
# 1616
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, __cxx11::basic_string< char>  & __str);
# 1619
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, const __cxx11::basic_string< char>  & __str);
# 1622
extern template basic_istream< char>  &getline(basic_istream< char>  & __is, __cxx11::basic_string< char>  & __str, char __delim);
# 1625
extern template basic_istream< char>  &getline(basic_istream< char>  & __is, __cxx11::basic_string< char>  & __str);
# 1631
extern template class __cxx11::basic_string< wchar_t> ;
# 1637
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t>  & __str);
# 1640
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, const __cxx11::basic_string< wchar_t>  & __str);
# 1643
extern template basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t>  & __str, wchar_t __delim);
# 1646
extern template basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t>  & __str);
# 1653
}
# 43 "/usr/include/c++/9/bits/locale_classes.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 62 "/usr/include/c++/9/bits/locale_classes.h" 3
class locale { 
# 67
public: typedef int category; 
# 70
class facet; 
# 71
class id; 
# 72
class _Impl; 
# 74
friend class facet; 
# 75
friend class _Impl; 
# 77
template< class _Facet> friend bool has_facet(const locale &) throw(); 
# 81
template< class _Facet> friend const _Facet &use_facet(const locale &); 
# 85
template< class _Cache> friend struct __use_cache; 
# 98 "/usr/include/c++/9/bits/locale_classes.h" 3
static const category none = 0; 
# 99
static const category ctype = (1L << 0); 
# 100
static const category numeric = (1L << 1); 
# 101
static const category collate = (1L << 2); 
# 102
static const category time = (1L << 3); 
# 103
static const category monetary = (1L << 4); 
# 104
static const category messages = (1L << 5); 
# 105
static const category all = (((((ctype | numeric) | collate) | time) | monetary) | messages); 
# 117 "/usr/include/c++/9/bits/locale_classes.h" 3
locale() throw(); 
# 126 "/usr/include/c++/9/bits/locale_classes.h" 3
locale(const locale & __other) throw(); 
# 137 "/usr/include/c++/9/bits/locale_classes.h" 3
explicit locale(const char * __s); 
# 151 "/usr/include/c++/9/bits/locale_classes.h" 3
locale(const locale & __base, const char * __s, category __cat); 
# 163 "/usr/include/c++/9/bits/locale_classes.h" 3
explicit locale(const string &__s) : locale(__s.c_str()) { } 
# 177 "/usr/include/c++/9/bits/locale_classes.h" 3
locale(const locale &__base, const string &__s, category __cat) : locale(__base, __s.c_str(), __cat) 
# 178
{ } 
# 192 "/usr/include/c++/9/bits/locale_classes.h" 3
locale(const locale & __base, const locale & __add, category __cat); 
# 205 "/usr/include/c++/9/bits/locale_classes.h" 3
template< class _Facet> locale(const locale & __other, _Facet * __f); 
# 209
~locale() throw(); 
# 220 "/usr/include/c++/9/bits/locale_classes.h" 3
const locale &operator=(const locale & __other) throw(); 
# 234 "/usr/include/c++/9/bits/locale_classes.h" 3
template< class _Facet> locale combine(const locale & __other) const; 
# 243
__attribute((__abi_tag__("cxx11"))) string 
# 245
name() const; 
# 255 "/usr/include/c++/9/bits/locale_classes.h" 3
bool operator==(const locale & __other) const throw(); 
# 264
bool operator!=(const locale &__other) const throw() 
# 265
{ return !this->operator==(__other); } 
# 282 "/usr/include/c++/9/bits/locale_classes.h" 3
template< class _Char, class _Traits, class _Alloc> bool operator()(const __cxx11::basic_string< _Char, _Traits, _Alloc>  & __s1, const __cxx11::basic_string< _Char, _Traits, _Alloc>  & __s2) const; 
# 299 "/usr/include/c++/9/bits/locale_classes.h" 3
static locale global(const locale & __loc); 
# 305
static const locale &classic(); 
# 309
private: _Impl *_M_impl; 
# 312
static _Impl *_S_classic; 
# 315
static _Impl *_S_global; 
# 321
static const char *const *const _S_categories; 
# 333 "/usr/include/c++/9/bits/locale_classes.h" 3
enum { _S_categories_size = (6 + 6)}; 
# 336
static __gthread_once_t _S_once; 
# 340
explicit locale(_Impl *) throw(); 
# 343
static void _S_initialize(); 
# 346
static void _S_initialize_once() throw(); 
# 349
static category _S_normalize_category(category); 
# 352
void _M_coalesce(const locale & __base, const locale & __add, category __cat); 
# 355
static const id *const _S_twinned_facets[]; 
# 357
}; 
# 371 "/usr/include/c++/9/bits/locale_classes.h" 3
class locale::facet { 
# 374
friend class locale; 
# 375
friend class _Impl; 
# 377
mutable _Atomic_word _M_refcount; 
# 380
static __c_locale _S_c_locale; 
# 383
static const char _S_c_name[2]; 
# 386
static __gthread_once_t _S_once; 
# 390
static void _S_initialize_once(); 
# 403 "/usr/include/c++/9/bits/locale_classes.h" 3
protected: explicit facet(size_t __refs = 0) throw() : _M_refcount((__refs) ? 1 : 0) 
# 404
{ } 
# 408
virtual ~facet(); 
# 411
static void _S_create_c_locale(__c_locale & __cloc, const char * __s, __c_locale __old = 0); 
# 415
static __c_locale _S_clone_c_locale(__c_locale & __cloc) throw(); 
# 418
static void _S_destroy_c_locale(__c_locale & __cloc); 
# 421
static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc, const char * __s); 
# 426
static __c_locale _S_get_c_locale(); 
# 428
__attribute((const)) static const char *
# 429
_S_get_c_name() throw(); 
# 438 "/usr/include/c++/9/bits/locale_classes.h" 3
facet(const facet &) = delete;
# 441
facet &operator=(const facet &) = delete;
# 446
private: void _M_add_reference() const throw() 
# 447
{ __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 450
void _M_remove_reference() const throw() 
# 451
{ 
# 453
; 
# 454
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1) == 1) 
# 455
{ 
# 456
; 
# 457
try 
# 458
{ delete this; } 
# 459
catch (...) 
# 460
{ }  
# 461
}  
# 462
} 
# 464
const facet *_M_sso_shim(const id *) const; 
# 465
const facet *_M_cow_shim(const id *) const; 
# 468
protected: class __shim; 
# 469
}; 
# 483 "/usr/include/c++/9/bits/locale_classes.h" 3
class locale::id { 
# 486
friend class locale; 
# 487
friend class _Impl; 
# 489
template< class _Facet> friend const _Facet &use_facet(const std::locale &); 
# 493
template< class _Facet> friend bool has_facet(const std::locale &) throw(); 
# 500
mutable size_t _M_index; 
# 503
static _Atomic_word _S_refcount; 
# 506
void operator=(const id &); 
# 508
id(const id &); 
# 514
public: id() { } 
# 517
size_t _M_id() const throw(); 
# 518
}; 
# 522
class locale::_Impl { 
# 526
friend class locale; 
# 527
friend class facet; 
# 529
template< class _Facet> friend bool has_facet(const std::locale &) throw(); 
# 533
template< class _Facet> friend const _Facet &use_facet(const std::locale &); 
# 537
template< class _Cache> friend struct __use_cache; 
# 542
_Atomic_word _M_refcount; 
# 543
const facet **_M_facets; 
# 544
size_t _M_facets_size; 
# 545
const facet **_M_caches; 
# 546
char **_M_names; 
# 547
static const id *const _S_id_ctype[]; 
# 548
static const id *const _S_id_numeric[]; 
# 549
static const id *const _S_id_collate[]; 
# 550
static const id *const _S_id_time[]; 
# 551
static const id *const _S_id_monetary[]; 
# 552
static const id *const _S_id_messages[]; 
# 553
static const id *const *const _S_facet_categories[]; 
# 556
void _M_add_reference() throw() 
# 557
{ __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 560
void _M_remove_reference() throw() 
# 561
{ 
# 563
; 
# 564
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1) == 1) 
# 565
{ 
# 566
; 
# 567
try 
# 568
{ delete this; } 
# 569
catch (...) 
# 570
{ }  
# 571
}  
# 572
} 
# 574
_Impl(const _Impl &, size_t); 
# 575
_Impl(const char *, size_t); 
# 576
_Impl(size_t) throw(); 
# 578
~_Impl() throw(); 
# 580
_Impl(const _Impl &); 
# 583
void operator=(const _Impl &); 
# 586
bool _M_check_same_name() 
# 587
{ 
# 588
bool __ret = true; 
# 589
if ((_M_names)[1]) { 
# 591
for (size_t __i = (0); __ret && (__i < ((_S_categories_size) - 1)); ++__i) { 
# 592
__ret = (__builtin_strcmp((_M_names)[__i], (_M_names)[__i + (1)]) == 0); }  }  
# 593
return __ret; 
# 594
} 
# 597
void _M_replace_categories(const _Impl *, category); 
# 600
void _M_replace_category(const _Impl *, const id *const *); 
# 603
void _M_replace_facet(const _Impl *, const id *); 
# 606
void _M_install_facet(const id *, const facet *); 
# 608
template< class _Facet> void 
# 610
_M_init_facet(_Facet *__facet) 
# 611
{ this->_M_install_facet(&_Facet::id, __facet); } 
# 613
template< class _Facet> void 
# 615
_M_init_facet_unchecked(_Facet *__facet) 
# 616
{ 
# 617
__facet->_M_add_reference(); 
# 618
((_M_facets)[(_Facet::id._M_id)()]) = __facet; 
# 619
} 
# 622
void _M_install_cache(const facet *, size_t); 
# 624
void _M_init_extra(facet **); 
# 625
void _M_init_extra(void *, void *, const char *, const char *); 
# 626
}; 
# 641 "/usr/include/c++/9/bits/locale_classes.h" 3
template< class _CharT> 
# 642
class __cxx11::collate : public locale::facet { 
# 648
public: typedef _CharT char_type; 
# 649
typedef basic_string< _CharT>  string_type; 
# 655
protected: __c_locale _M_c_locale_collate; 
# 659
public: static locale::id id; 
# 669 "/usr/include/c++/9/bits/locale_classes.h" 3
explicit collate(size_t __refs = 0) : locale::facet(__refs), _M_c_locale_collate(_S_get_c_locale()) 
# 671
{ } 
# 683 "/usr/include/c++/9/bits/locale_classes.h" 3
explicit collate(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc)) 
# 685
{ } 
# 700 "/usr/include/c++/9/bits/locale_classes.h" 3
int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *
# 701
__lo2, const _CharT *__hi2) const 
# 702
{ return do_compare(__lo1, __hi1, __lo2, __hi2); } 
# 719 "/usr/include/c++/9/bits/locale_classes.h" 3
string_type transform(const _CharT *__lo, const _CharT *__hi) const 
# 720
{ return do_transform(__lo, __hi); } 
# 733 "/usr/include/c++/9/bits/locale_classes.h" 3
long hash(const _CharT *__lo, const _CharT *__hi) const 
# 734
{ return do_hash(__lo, __hi); } 
# 738
int _M_compare(const _CharT *, const _CharT *) const throw(); 
# 741
size_t _M_transform(_CharT *, const _CharT *, size_t) const throw(); 
# 746
protected: virtual ~collate() 
# 747
{ _S_destroy_c_locale(_M_c_locale_collate); } 
# 762 "/usr/include/c++/9/bits/locale_classes.h" 3
virtual int do_compare(const _CharT * __lo1, const _CharT * __hi1, const _CharT * __lo2, const _CharT * __hi2) const; 
# 776 "/usr/include/c++/9/bits/locale_classes.h" 3
virtual string_type do_transform(const _CharT * __lo, const _CharT * __hi) const; 
# 789 "/usr/include/c++/9/bits/locale_classes.h" 3
virtual long do_hash(const _CharT * __lo, const _CharT * __hi) const; 
# 790
}; 
# 792
template< class _CharT> locale::id 
# 793
__cxx11::collate< _CharT> ::id; 
# 798
template<> int collate< char> ::_M_compare(const char *, const char *) const throw(); 
# 802
template<> size_t collate< char> ::_M_transform(char *, const char *, size_t) const throw(); 
# 807
template<> int collate< wchar_t> ::_M_compare(const wchar_t *, const wchar_t *) const throw(); 
# 811
template<> size_t collate< wchar_t> ::_M_transform(wchar_t *, const wchar_t *, size_t) const throw(); 
# 815
template< class _CharT> 
# 816
class __cxx11::collate_byname : public collate< _CharT>  { 
# 821
public: typedef _CharT char_type; 
# 822
typedef basic_string< _CharT>  string_type; 
# 826
explicit collate_byname(const char *__s, std::size_t __refs = 0) : collate< _CharT> (__refs) 
# 828
{ 
# 829
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 831
{ 
# 832
this->_S_destroy_c_locale((this->_M_c_locale_collate)); 
# 833
this->_S_create_c_locale((this->_M_c_locale_collate), __s); 
# 834
}  
# 835
} 
# 839
explicit collate_byname(const std::string &__s, std::size_t __refs = 0) : collate_byname(__s.c_str(), __refs) 
# 840
{ } 
# 845
protected: virtual ~collate_byname() { } 
# 846
}; 
# 849
}
# 39 "/usr/include/c++/9/bits/locale_classes.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _Facet> 
# 45
locale::locale(const locale &__other, _Facet *__f) 
# 46
{ 
# 47
(_M_impl) = (new _Impl(*(__other._M_impl), 1)); 
# 49
try 
# 50
{ (_M_impl)->_M_install_facet(&_Facet::id, __f); } 
# 51
catch (...) 
# 52
{ 
# 53
(_M_impl)->_M_remove_reference(); 
# 54
throw; 
# 55
}  
# 56
delete [] (((_M_impl)->_M_names)[0]); 
# 57
(((_M_impl)->_M_names)[0]) = (0); 
# 58
} 
# 60
template< class _Facet> locale 
# 63
locale::combine(const locale &__other) const 
# 64
{ 
# 65
_Impl *__tmp = new _Impl(*(_M_impl), 1); 
# 66
try 
# 67
{ 
# 68
__tmp->_M_replace_facet(__other._M_impl, &_Facet::id); 
# 69
} 
# 70
catch (...) 
# 71
{ 
# 72
__tmp->_M_remove_reference(); 
# 73
throw; 
# 74
}  
# 75
return ((locale)(__tmp)); 
# 76
} 
# 78
template< class _CharT, class _Traits, class _Alloc> bool 
# 81
locale::operator()(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__s1, const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 82
__s2) const 
# 83
{ 
# 84
typedef __cxx11::collate< _CharT>  __collate_type; 
# 85
const __collate_type &__collate = use_facet< __cxx11::collate< _CharT> > (*this); 
# 86
return (__collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0); 
# 88
} 
# 102 "/usr/include/c++/9/bits/locale_classes.tcc" 3
template< class _Facet> bool 
# 104
has_facet(const locale &__loc) throw() 
# 105
{ 
# 106
const size_t __i = (_Facet::id._M_id)(); 
# 107
const locale::facet **__facets = (__loc._M_impl)->_M_facets; 
# 108
return ((__i < ((__loc._M_impl)->_M_facets_size)) && (dynamic_cast< const _Facet *>(__facets[__i]))); 
# 114
} 
# 130 "/usr/include/c++/9/bits/locale_classes.tcc" 3
template< class _Facet> const _Facet &
# 132
use_facet(const locale &__loc) 
# 133
{ 
# 134
const size_t __i = (_Facet::id._M_id)(); 
# 135
const locale::facet **__facets = (__loc._M_impl)->_M_facets; 
# 136
if ((__i >= ((__loc._M_impl)->_M_facets_size)) || (!(__facets[__i]))) { 
# 137
__throw_bad_cast(); }  
# 139
return dynamic_cast< const _Facet &>(*(__facets[__i])); 
# 143
} 
# 147
template< class _CharT> int 
# 149
__cxx11::collate< _CharT> ::_M_compare(const _CharT *, const _CharT *) const throw() 
# 150
{ return 0; } 
# 153
template< class _CharT> size_t 
# 155
__cxx11::collate< _CharT> ::_M_transform(_CharT *, const _CharT *, size_t) const throw() 
# 156
{ return 0; } 
# 158
template< class _CharT> int 
# 161
__cxx11::collate< _CharT> ::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *
# 162
__lo2, const _CharT *__hi2) const 
# 163
{ 
# 166
const string_type __one(__lo1, __hi1); 
# 167
const string_type __two(__lo2, __hi2); 
# 169
const _CharT *__p = __one.c_str(); 
# 170
const _CharT *__pend = __one.data() + __one.length(); 
# 171
const _CharT *__q = __two.c_str(); 
# 172
const _CharT *__qend = __two.data() + __two.length(); 
# 177
for (; ;) 
# 178
{ 
# 179
const int __res = _M_compare(__p, __q); 
# 180
if (__res) { 
# 181
return __res; }  
# 183
__p += char_traits< _CharT> ::length(__p); 
# 184
__q += char_traits< _CharT> ::length(__q); 
# 185
if ((__p == __pend) && (__q == __qend)) { 
# 186
return 0; } else { 
# 187
if (__p == __pend) { 
# 188
return -1; } else { 
# 189
if (__q == __qend) { 
# 190
return 1; }  }  }  
# 192
__p++; 
# 193
__q++; 
# 194
}  
# 195
} 
# 197
template< class _CharT> typename __cxx11::collate< _CharT> ::string_type 
# 200
__cxx11::collate< _CharT> ::do_transform(const _CharT *__lo, const _CharT *__hi) const 
# 201
{ 
# 202
string_type __ret; 
# 205
const string_type __str(__lo, __hi); 
# 207
const _CharT *__p = __str.c_str(); 
# 208
const _CharT *__pend = __str.data() + __str.length(); 
# 210
size_t __len = (__hi - __lo) * 2; 
# 212
_CharT *__c = new _CharT [__len]; 
# 214
try 
# 215
{ 
# 219
for (; ;) 
# 220
{ 
# 222
size_t __res = _M_transform(__c, __p, __len); 
# 225
if (__res >= __len) 
# 226
{ 
# 227
__len = (__res + (1)); 
# 228
(delete [] __c), (__c = 0); 
# 229
__c = (new _CharT [__len]); 
# 230
__res = _M_transform(__c, __p, __len); 
# 231
}  
# 233
__ret.append(__c, __res); 
# 234
__p += char_traits< _CharT> ::length(__p); 
# 235
if (__p == __pend) { 
# 236
break; }  
# 238
__p++; 
# 239
__ret.push_back(_CharT()); 
# 240
}  
# 241
} 
# 242
catch (...) 
# 243
{ 
# 244
delete [] __c; 
# 245
throw; 
# 246
}  
# 248
delete [] __c; 
# 250
return __ret; 
# 251
} 
# 253
template< class _CharT> long 
# 256
__cxx11::collate< _CharT> ::do_hash(const _CharT *__lo, const _CharT *__hi) const 
# 257
{ 
# 258
unsigned long __val = (0); 
# 259
for (; __lo < __hi; ++__lo) { 
# 260
__val = ((*__lo) + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits_integer< unsigned long> ::__digits - 7)))); }  
# 264
return static_cast< long>(__val); 
# 265
} 
# 270
extern template class __cxx11::collate< char> ;
# 271
extern template class __cxx11::collate_byname< char> ;
# 273
extern template const __cxx11::collate< char>  &use_facet< __cxx11::collate< char> > (const locale &);
# 277
extern template bool has_facet< __cxx11::collate< char> > (const locale &) throw();
# 282
extern template class __cxx11::collate< wchar_t> ;
# 283
extern template class __cxx11::collate_byname< wchar_t> ;
# 285
extern template const __cxx11::collate< wchar_t>  &use_facet< __cxx11::collate< wchar_t> > (const locale &);
# 289
extern template bool has_facet< __cxx11::collate< wchar_t> > (const locale &) throw();
# 296
}
# 36 "/usr/include/x86_64-linux-gnu/c++/9/bits/error_constants.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 40
enum class errc { 
# 42
address_family_not_supported = 97, 
# 43
address_in_use, 
# 44
address_not_available, 
# 45
already_connected = 106, 
# 46
argument_list_too_long = 7, 
# 47
argument_out_of_domain = 33, 
# 48
bad_address = 14, 
# 49
bad_file_descriptor = 9, 
# 52
bad_message = 74, 
# 55
broken_pipe = 32, 
# 56
connection_aborted = 103, 
# 57
connection_already_in_progress = 114, 
# 58
connection_refused = 111, 
# 59
connection_reset = 104, 
# 60
cross_device_link = 18, 
# 61
destination_address_required = 89, 
# 62
device_or_resource_busy = 16, 
# 63
directory_not_empty = 39, 
# 64
executable_format_error = 8, 
# 65
file_exists = 17, 
# 66
file_too_large = 27, 
# 67
filename_too_long = 36, 
# 68
function_not_supported = 38, 
# 69
host_unreachable = 113, 
# 72
identifier_removed = 43, 
# 75
illegal_byte_sequence = 84, 
# 76
inappropriate_io_control_operation = 25, 
# 77
interrupted = 4, 
# 78
invalid_argument = 22, 
# 79
invalid_seek = 29, 
# 80
io_error = 5, 
# 81
is_a_directory = 21, 
# 82
message_size = 90, 
# 83
network_down = 100, 
# 84
network_reset = 102, 
# 85
network_unreachable = 101, 
# 86
no_buffer_space = 105, 
# 87
no_child_process = 10, 
# 90
no_link = 67, 
# 93
no_lock_available = 37, 
# 96
no_message_available = 61, 
# 99
no_message = 42, 
# 100
no_protocol_option = 92, 
# 101
no_space_on_device = 28, 
# 104
no_stream_resources = 63, 
# 107
no_such_device_or_address = 6, 
# 108
no_such_device = 19, 
# 109
no_such_file_or_directory = 2, 
# 110
no_such_process, 
# 111
not_a_directory = 20, 
# 112
not_a_socket = 88, 
# 115
not_a_stream = 60, 
# 118
not_connected = 107, 
# 119
not_enough_memory = 12, 
# 122
not_supported = 95, 
# 126
operation_canceled = 125, 
# 129
operation_in_progress = 115, 
# 130
operation_not_permitted = 1, 
# 131
operation_not_supported = 95, 
# 132
operation_would_block = 11, 
# 135
owner_dead = 130, 
# 138
permission_denied = 13, 
# 141
protocol_error = 71, 
# 144
protocol_not_supported = 93, 
# 145
read_only_file_system = 30, 
# 146
resource_deadlock_would_occur = 35, 
# 147
resource_unavailable_try_again = 11, 
# 148
result_out_of_range = 34, 
# 151
state_not_recoverable = 131, 
# 155
stream_timeout = 62, 
# 159
text_file_busy = 26, 
# 162
timed_out = 110, 
# 163
too_many_files_open_in_system = 23, 
# 164
too_many_files_open, 
# 165
too_many_links = 31, 
# 166
too_many_symbolic_link_levels = 40, 
# 169
value_too_large = 75, 
# 172
wrong_protocol_type = 91
# 173
}; 
# 176
}
# 41 "/usr/include/c++/9/stdexcept" 3
namespace std __attribute((__visibility__("default"))) { 
# 48
struct __cow_string { 
# 50
union { 
# 51
const char *_M_p; 
# 52
char _M_bytes[sizeof(const char *)]; 
# 53
}; 
# 55
__cow_string(); 
# 56
__cow_string(const string &); 
# 57
__cow_string(const char *, size_t); 
# 58
__cow_string(const __cow_string &) noexcept; 
# 59
__cow_string &operator=(const __cow_string &) noexcept; 
# 60
~__cow_string(); 
# 62
__cow_string(__cow_string &&) noexcept; 
# 63
__cow_string &operator=(__cow_string &&) noexcept; 
# 65
}; 
# 67
typedef __cxx11::basic_string< char>  __sso_string; 
# 113 "/usr/include/c++/9/stdexcept" 3
class logic_error : public exception { 
# 115
__cow_string _M_msg; 
# 120
public: explicit logic_error(const string & __arg); 
# 124
explicit logic_error(const char *); 
# 126
logic_error(logic_error &&) noexcept; 
# 127
logic_error &operator=(logic_error &&) noexcept; 
# 131
logic_error(const logic_error &) noexcept; 
# 132
logic_error &operator=(const logic_error &) noexcept; 
# 138
virtual ~logic_error() noexcept; 
# 143
virtual const char *what() const noexcept; 
# 149
}; 
# 153
class domain_error : public logic_error { 
# 156
public: explicit domain_error(const string & __arg); 
# 158
explicit domain_error(const char *); 
# 159
domain_error(const domain_error &) = default;
# 160
domain_error &operator=(const domain_error &) = default;
# 161
domain_error(domain_error &&) = default;
# 162
domain_error &operator=(domain_error &&) = default;
# 164
virtual ~domain_error() noexcept; 
# 165
}; 
# 168
class invalid_argument : public logic_error { 
# 171
public: explicit invalid_argument(const string & __arg); 
# 173
explicit invalid_argument(const char *); 
# 174
invalid_argument(const invalid_argument &) = default;
# 175
invalid_argument &operator=(const invalid_argument &) = default;
# 176
invalid_argument(invalid_argument &&) = default;
# 177
invalid_argument &operator=(invalid_argument &&) = default;
# 179
virtual ~invalid_argument() noexcept; 
# 180
}; 
# 184
class length_error : public logic_error { 
# 187
public: explicit length_error(const string & __arg); 
# 189
explicit length_error(const char *); 
# 190
length_error(const length_error &) = default;
# 191
length_error &operator=(const length_error &) = default;
# 192
length_error(length_error &&) = default;
# 193
length_error &operator=(length_error &&) = default;
# 195
virtual ~length_error() noexcept; 
# 196
}; 
# 200
class out_of_range : public logic_error { 
# 203
public: explicit out_of_range(const string & __arg); 
# 205
explicit out_of_range(const char *); 
# 206
out_of_range(const out_of_range &) = default;
# 207
out_of_range &operator=(const out_of_range &) = default;
# 208
out_of_range(out_of_range &&) = default;
# 209
out_of_range &operator=(out_of_range &&) = default;
# 211
virtual ~out_of_range() noexcept; 
# 212
}; 
# 219
class runtime_error : public exception { 
# 221
__cow_string _M_msg; 
# 226
public: explicit runtime_error(const string & __arg); 
# 230
explicit runtime_error(const char *); 
# 232
runtime_error(runtime_error &&) noexcept; 
# 233
runtime_error &operator=(runtime_error &&) noexcept; 
# 237
runtime_error(const runtime_error &) noexcept; 
# 238
runtime_error &operator=(const runtime_error &) noexcept; 
# 244
virtual ~runtime_error() noexcept; 
# 249
virtual const char *what() const noexcept; 
# 255
}; 
# 258
class range_error : public runtime_error { 
# 261
public: explicit range_error(const string & __arg); 
# 263
explicit range_error(const char *); 
# 264
range_error(const range_error &) = default;
# 265
range_error &operator=(const range_error &) = default;
# 266
range_error(range_error &&) = default;
# 267
range_error &operator=(range_error &&) = default;
# 269
virtual ~range_error() noexcept; 
# 270
}; 
# 273
class overflow_error : public runtime_error { 
# 276
public: explicit overflow_error(const string & __arg); 
# 278
explicit overflow_error(const char *); 
# 279
overflow_error(const overflow_error &) = default;
# 280
overflow_error &operator=(const overflow_error &) = default;
# 281
overflow_error(overflow_error &&) = default;
# 282
overflow_error &operator=(overflow_error &&) = default;
# 284
virtual ~overflow_error() noexcept; 
# 285
}; 
# 288
class underflow_error : public runtime_error { 
# 291
public: explicit underflow_error(const string & __arg); 
# 293
explicit underflow_error(const char *); 
# 294
underflow_error(const underflow_error &) = default;
# 295
underflow_error &operator=(const underflow_error &) = default;
# 296
underflow_error(underflow_error &&) = default;
# 297
underflow_error &operator=(underflow_error &&) = default;
# 299
virtual ~underflow_error() noexcept; 
# 300
}; 
# 305
}
# 43 "/usr/include/c++/9/system_error" 3
namespace std __attribute((__visibility__("default"))) { 
# 47
struct error_code; 
# 48
struct error_condition; 
# 49
class system_error; 
# 52
template< class _Tp> 
# 53
struct is_error_code_enum : public false_type { }; 
# 56
template< class _Tp> 
# 57
struct is_error_condition_enum : public false_type { }; 
# 60
template<> struct is_error_condition_enum< errc>  : public true_type { 
# 61
}; 
# 71 "/usr/include/c++/9/system_error" 3
inline namespace _V2 { 
# 74
class error_category { 
# 77
public: constexpr error_category() noexcept = default;
# 79
virtual ~error_category(); 
# 81
error_category(const error_category &) = delete;
# 82
error_category &operator=(const error_category &) = delete;
# 85
virtual const char *name() const noexcept = 0; 
# 95
private: 
# 93
__attribute((__abi_tag__("cxx11"))) virtual __cow_string 
# 95
_M_message(int) const; 
# 100
public: 
# 98
__attribute((__abi_tag__("cxx11"))) virtual string 
# 100
message(int) const = 0; 
# 112 "/usr/include/c++/9/system_error" 3
virtual error_condition default_error_condition(int __i) const noexcept; 
# 115
virtual bool equivalent(int __i, const error_condition & __cond) const noexcept; 
# 118
virtual bool equivalent(const error_code & __code, int __i) const noexcept; 
# 121
bool operator<(const error_category &__other) const noexcept 
# 122
{ return less< const error_category *> ()(this, &__other); } 
# 125
bool operator==(const error_category &__other) const noexcept 
# 126
{ return this == (&__other); } 
# 129
bool operator!=(const error_category &__other) const noexcept 
# 130
{ return this != (&__other); } 
# 131
}; 
# 134
__attribute((const)) const error_category &system_category() noexcept; 
# 135
__attribute((const)) const error_category &generic_category() noexcept; 
# 137
}
# 139
inline error_code make_error_code(errc) noexcept; 
# 141
template< class _Tp> struct hash; 
# 146
struct error_code { 
# 148
error_code() noexcept : _M_value(0), _M_cat(&system_category()) 
# 149
{ } 
# 151
error_code(int __v, const _V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) 
# 152
{ } 
# 154
template< class _ErrorCodeEnum, class  = typename enable_if< is_error_code_enum< _ErrorCodeEnum> ::value> ::type> 
# 156
error_code(_ErrorCodeEnum __e) noexcept 
# 157
{ (*this) = make_error_code(__e); } 
# 160
void assign(int __v, const _V2::error_category &__cat) noexcept 
# 161
{ 
# 162
(_M_value) = __v; 
# 163
(_M_cat) = (&__cat); 
# 164
} 
# 167
void clear() noexcept 
# 168
{ this->assign(0, system_category()); } 
# 171
template< class _ErrorCodeEnum> typename enable_if< is_error_code_enum< _ErrorCodeEnum> ::value, error_code &> ::type 
# 174
operator=(_ErrorCodeEnum __e) noexcept 
# 175
{ return (*this) = make_error_code(__e); } 
# 178
int value() const noexcept { return _M_value; } 
# 181
const _V2::error_category &category() const noexcept { return *(_M_cat); } 
# 184
error_condition default_error_condition() const noexcept; 
# 186
__attribute((__abi_tag__("cxx11"))) string 
# 188
message() const 
# 189
{ return this->category().message(this->value()); } 
# 191
explicit operator bool() const noexcept 
# 192
{ return (_M_value) != 0; } 
# 196
friend struct hash< error_code> ; 
# 198
private: int _M_value; 
# 199
const _V2::error_category *_M_cat; 
# 200
}; 
# 204
inline error_code make_error_code(errc __e) noexcept 
# 205
{ return error_code(static_cast< int>(__e), generic_category()); } 
# 208
inline bool operator<(const error_code &__lhs, const error_code &__rhs) noexcept 
# 209
{ 
# 210
return (((__lhs.category()) < (__rhs.category())) || (((__lhs.category()) == (__rhs.category())) && (__lhs.value() < __rhs.value()))); 
# 213
} 
# 215
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 217
operator<<(basic_ostream< _CharT, _Traits>  &__os, const error_code &__e) 
# 218
{ return (((__os << __e.category().name()) << ':') << __e.value()); } 
# 220
inline error_condition make_error_condition(errc) noexcept; 
# 224
struct error_condition { 
# 226
error_condition() noexcept : _M_value(0), _M_cat(&generic_category()) 
# 227
{ } 
# 229
error_condition(int __v, const _V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) 
# 230
{ } 
# 232
template< class _ErrorConditionEnum, class  = typename enable_if< is_error_condition_enum< _ErrorConditionEnum> ::value> ::type> 
# 234
error_condition(_ErrorConditionEnum __e) noexcept 
# 235
{ (*this) = make_error_condition(__e); } 
# 238
void assign(int __v, const _V2::error_category &__cat) noexcept 
# 239
{ 
# 240
(_M_value) = __v; 
# 241
(_M_cat) = (&__cat); 
# 242
} 
# 245
template< class _ErrorConditionEnum> typename enable_if< is_error_condition_enum< _ErrorConditionEnum> ::value, error_condition &> ::type 
# 248
operator=(_ErrorConditionEnum __e) noexcept 
# 249
{ return (*this) = make_error_condition(__e); } 
# 252
void clear() noexcept 
# 253
{ this->assign(0, generic_category()); } 
# 257
int value() const noexcept { return _M_value; } 
# 260
const _V2::error_category &category() const noexcept { return *(_M_cat); } 
# 262
__attribute((__abi_tag__("cxx11"))) string 
# 264
message() const 
# 265
{ return this->category().message(this->value()); } 
# 267
explicit operator bool() const noexcept 
# 268
{ return (_M_value) != 0; } 
# 272
private: int _M_value; 
# 273
const _V2::error_category *_M_cat; 
# 274
}; 
# 278
inline error_condition make_error_condition(errc __e) noexcept 
# 279
{ return error_condition(static_cast< int>(__e), generic_category()); } 
# 282
inline bool operator<(const error_condition &__lhs, const error_condition &
# 283
__rhs) noexcept 
# 284
{ 
# 285
return (((__lhs.category()) < (__rhs.category())) || (((__lhs.category()) == (__rhs.category())) && (__lhs.value() < __rhs.value()))); 
# 288
} 
# 292
inline bool operator==(const error_code &__lhs, const error_code &__rhs) noexcept 
# 293
{ return (((__lhs.category()) == (__rhs.category())) && (__lhs.value() == __rhs.value())); 
# 294
} 
# 297
inline bool operator==(const error_code &__lhs, const error_condition &__rhs) noexcept 
# 298
{ 
# 299
return (__lhs.category().equivalent(__lhs.value(), __rhs) || __rhs.category().equivalent(__lhs, __rhs.value())); 
# 301
} 
# 304
inline bool operator==(const error_condition &__lhs, const error_code &__rhs) noexcept 
# 305
{ 
# 306
return (__rhs.category().equivalent(__rhs.value(), __lhs) || __lhs.category().equivalent(__rhs, __lhs.value())); 
# 308
} 
# 311
inline bool operator==(const error_condition &__lhs, const error_condition &
# 312
__rhs) noexcept 
# 313
{ 
# 314
return (((__lhs.category()) == (__rhs.category())) && (__lhs.value() == __rhs.value())); 
# 316
} 
# 319
inline bool operator!=(const error_code &__lhs, const error_code &__rhs) noexcept 
# 320
{ return !(__lhs == __rhs); } 
# 323
inline bool operator!=(const error_code &__lhs, const error_condition &__rhs) noexcept 
# 324
{ return !(__lhs == __rhs); } 
# 327
inline bool operator!=(const error_condition &__lhs, const error_code &__rhs) noexcept 
# 328
{ return !(__lhs == __rhs); } 
# 331
inline bool operator!=(const error_condition &__lhs, const error_condition &
# 332
__rhs) noexcept 
# 333
{ return !(__lhs == __rhs); } 
# 341
class system_error : public runtime_error { 
# 344
error_code _M_code; 
# 347
public: system_error(error_code __ec = error_code()) : runtime_error(__ec.message()), _M_code(__ec) 
# 348
{ } 
# 350
system_error(error_code __ec, const string &__what) : runtime_error((((__what + (": "))) + (__ec.message()))), _M_code(__ec) 
# 351
{ } 
# 353
system_error(error_code __ec, const char *__what) : runtime_error((__what + (((": ") + (__ec.message()))))), _M_code(__ec) 
# 354
{ } 
# 356
system_error(int __v, const _V2::error_category &__ecat, const char *__what) : system_error(error_code(__v, __ecat), __what) 
# 357
{ } 
# 359
system_error(int __v, const _V2::error_category &__ecat) : runtime_error(error_code(__v, __ecat).message()), _M_code(__v, __ecat) 
# 361
{ } 
# 363
system_error(int __v, const _V2::error_category &__ecat, const string &__what) : runtime_error((((__what + (": "))) + (error_code(__v, __ecat).message()))), _M_code(__v, __ecat) 
# 365
{ } 
# 368
system_error(const system_error &) = default;
# 369
system_error &operator=(const system_error &) = default;
# 372
virtual ~system_error() noexcept; 
# 375
const error_code &code() const noexcept { return _M_code; } 
# 376
}; 
# 379
}
# 383
namespace std __attribute((__visibility__("default"))) { 
# 391
template<> struct hash< error_code>  : public __hash_base< unsigned long, error_code>  { 
# 395
size_t operator()(const error_code &__e) const noexcept 
# 396
{ 
# 397
const size_t __tmp = std::_Hash_impl::hash(__e._M_value); 
# 398
return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp); 
# 399
} 
# 400
}; 
# 420 "/usr/include/c++/9/system_error" 3
}
# 49 "/usr/include/c++/9/bits/ios_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 57
enum _Ios_Fmtflags { 
# 59
_S_boolalpha = (1L << 0), 
# 60
_S_dec, 
# 61
_S_fixed = (1L << 2), 
# 62
_S_hex = (1L << 3), 
# 63
_S_internal = (1L << 4), 
# 64
_S_left = (1L << 5), 
# 65
_S_oct = (1L << 6), 
# 66
_S_right = (1L << 7), 
# 67
_S_scientific = (1L << 8), 
# 68
_S_showbase = (1L << 9), 
# 69
_S_showpoint = (1L << 10), 
# 70
_S_showpos = (1L << 11), 
# 71
_S_skipws = (1L << 12), 
# 72
_S_unitbuf = (1L << 13), 
# 73
_S_uppercase = (1L << 14), 
# 74
_S_adjustfield = ((_S_left | _S_right) | _S_internal), 
# 75
_S_basefield = ((_S_dec | _S_oct) | _S_hex), 
# 76
_S_floatfield = (_S_scientific | _S_fixed), 
# 77
_S_ios_fmtflags_end = (1L << 16), 
# 78
_S_ios_fmtflags_max = 2147483647, 
# 79
_S_ios_fmtflags_min = (~2147483647)
# 80
}; 
# 83
constexpr _Ios_Fmtflags operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 84
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 87
constexpr _Ios_Fmtflags operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 88
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 91
constexpr _Ios_Fmtflags operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
# 92
{ return (_Ios_Fmtflags)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 95
constexpr _Ios_Fmtflags operator~(_Ios_Fmtflags __a) 
# 96
{ return (_Ios_Fmtflags)(~(static_cast< int>(__a))); } 
# 99
inline const _Ios_Fmtflags &operator|=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 100
{ return __a = (__a | __b); } 
# 103
inline const _Ios_Fmtflags &operator&=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 104
{ return __a = (__a & __b); } 
# 107
inline const _Ios_Fmtflags &operator^=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
# 108
{ return __a = (__a ^ __b); } 
# 111
enum _Ios_Openmode { 
# 113
_S_app = (1L << 0), 
# 114
_S_ate, 
# 115
_S_bin = (1L << 2), 
# 116
_S_in = (1L << 3), 
# 117
_S_out = (1L << 4), 
# 118
_S_trunc = (1L << 5), 
# 119
_S_ios_openmode_end = (1L << 16), 
# 120
_S_ios_openmode_max = 2147483647, 
# 121
_S_ios_openmode_min = (~2147483647)
# 122
}; 
# 125
constexpr _Ios_Openmode operator&(_Ios_Openmode __a, _Ios_Openmode __b) 
# 126
{ return (_Ios_Openmode)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 129
constexpr _Ios_Openmode operator|(_Ios_Openmode __a, _Ios_Openmode __b) 
# 130
{ return (_Ios_Openmode)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 133
constexpr _Ios_Openmode operator^(_Ios_Openmode __a, _Ios_Openmode __b) 
# 134
{ return (_Ios_Openmode)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 137
constexpr _Ios_Openmode operator~(_Ios_Openmode __a) 
# 138
{ return (_Ios_Openmode)(~(static_cast< int>(__a))); } 
# 141
inline const _Ios_Openmode &operator|=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 142
{ return __a = (__a | __b); } 
# 145
inline const _Ios_Openmode &operator&=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 146
{ return __a = (__a & __b); } 
# 149
inline const _Ios_Openmode &operator^=(_Ios_Openmode &__a, _Ios_Openmode __b) 
# 150
{ return __a = (__a ^ __b); } 
# 153
enum _Ios_Iostate { 
# 155
_S_goodbit, 
# 156
_S_badbit, 
# 157
_S_eofbit, 
# 158
_S_failbit = (1L << 2), 
# 159
_S_ios_iostate_end = (1L << 16), 
# 160
_S_ios_iostate_max = 2147483647, 
# 161
_S_ios_iostate_min = (~2147483647)
# 162
}; 
# 165
constexpr _Ios_Iostate operator&(_Ios_Iostate __a, _Ios_Iostate __b) 
# 166
{ return (_Ios_Iostate)((static_cast< int>(__a)) & (static_cast< int>(__b))); } 
# 169
constexpr _Ios_Iostate operator|(_Ios_Iostate __a, _Ios_Iostate __b) 
# 170
{ return (_Ios_Iostate)((static_cast< int>(__a)) | (static_cast< int>(__b))); } 
# 173
constexpr _Ios_Iostate operator^(_Ios_Iostate __a, _Ios_Iostate __b) 
# 174
{ return (_Ios_Iostate)((static_cast< int>(__a)) ^ (static_cast< int>(__b))); } 
# 177
constexpr _Ios_Iostate operator~(_Ios_Iostate __a) 
# 178
{ return (_Ios_Iostate)(~(static_cast< int>(__a))); } 
# 181
inline const _Ios_Iostate &operator|=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 182
{ return __a = (__a | __b); } 
# 185
inline const _Ios_Iostate &operator&=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 186
{ return __a = (__a & __b); } 
# 189
inline const _Ios_Iostate &operator^=(_Ios_Iostate &__a, _Ios_Iostate __b) 
# 190
{ return __a = (__a ^ __b); } 
# 193
enum _Ios_Seekdir { 
# 195
_S_beg, 
# 196
_S_cur, 
# 197
_S_end, 
# 198
_S_ios_seekdir_end = (1L << 16)
# 199
}; 
# 203
enum class io_errc { stream = 1}; 
# 205
template<> struct is_error_code_enum< io_errc>  : public true_type { }; 
# 207
const _V2::error_category &iostream_category() noexcept; 
# 210
inline error_code make_error_code(io_errc __e) noexcept 
# 211
{ return error_code(static_cast< int>(__e), iostream_category()); } 
# 214
inline error_condition make_error_condition(io_errc __e) noexcept 
# 215
{ return error_condition(static_cast< int>(__e), iostream_category()); } 
# 228 "/usr/include/c++/9/bits/ios_base.h" 3
class ios_base { 
# 255 "/usr/include/c++/9/bits/ios_base.h" 3
public: class __attribute((__abi_tag__("cxx11"))) failure : public system_error { 
# 259
public: explicit failure(const string & __str); 
# 263
explicit failure(const string &, const error_code &); 
# 266
explicit failure(const char *, const error_code & = io_errc::stream); 
# 270
virtual ~failure() throw(); 
# 273
virtual const char *what() const throw(); 
# 274
}; 
# 323 "/usr/include/c++/9/bits/ios_base.h" 3
typedef _Ios_Fmtflags fmtflags; 
# 326
static const fmtflags boolalpha = _S_boolalpha; 
# 329
static const fmtflags dec = _S_dec; 
# 332
static const fmtflags fixed = _S_fixed; 
# 335
static const fmtflags hex = _S_hex; 
# 340
static const fmtflags internal = _S_internal; 
# 344
static const fmtflags left = _S_left; 
# 347
static const fmtflags oct = _S_oct; 
# 351
static const fmtflags right = _S_right; 
# 354
static const fmtflags scientific = _S_scientific; 
# 358
static const fmtflags showbase = _S_showbase; 
# 362
static const fmtflags showpoint = _S_showpoint; 
# 365
static const fmtflags showpos = _S_showpos; 
# 368
static const fmtflags skipws = _S_skipws; 
# 371
static const fmtflags unitbuf = _S_unitbuf; 
# 375
static const fmtflags uppercase = _S_uppercase; 
# 378
static const fmtflags adjustfield = _S_adjustfield; 
# 381
static const fmtflags basefield = _S_basefield; 
# 384
static const fmtflags floatfield = _S_floatfield; 
# 398 "/usr/include/c++/9/bits/ios_base.h" 3
typedef _Ios_Iostate iostate; 
# 402
static const iostate badbit = _S_badbit; 
# 405
static const iostate eofbit = _S_eofbit; 
# 410
static const iostate failbit = _S_failbit; 
# 413
static const iostate goodbit = _S_goodbit; 
# 429 "/usr/include/c++/9/bits/ios_base.h" 3
typedef _Ios_Openmode openmode; 
# 432
static const openmode app = _S_app; 
# 435
static const openmode ate = _S_ate; 
# 440
static const openmode binary = _S_bin; 
# 443
static const openmode in = _S_in; 
# 446
static const openmode out = _S_out; 
# 449
static const openmode trunc = _S_trunc; 
# 461 "/usr/include/c++/9/bits/ios_base.h" 3
typedef _Ios_Seekdir seekdir; 
# 464
static const seekdir beg = _S_beg; 
# 467
static const seekdir cur = _S_cur; 
# 470
static const seekdir end = _S_end; 
# 474
typedef int io_state
# 475
 __attribute((__deprecated__("use \'std::iostate\' instead"))); 
# 476
typedef int open_mode
# 477
 __attribute((__deprecated__("use \'std::openmode\' instead"))); 
# 478
typedef int seek_dir
# 479
 __attribute((__deprecated__("use \'std::seekdir\' instead"))); 
# 481
typedef std::streampos streampos
# 482
 __attribute((__deprecated__("use \'std::streampos\' instead"))); 
# 483
typedef std::streamoff streamoff
# 484
 __attribute((__deprecated__("use \'std::streamoff\' instead"))); 
# 494 "/usr/include/c++/9/bits/ios_base.h" 3
enum event { 
# 496
erase_event, 
# 497
imbue_event, 
# 498
copyfmt_event
# 499
}; 
# 511 "/usr/include/c++/9/bits/ios_base.h" 3
typedef void (*event_callback)(event __e, ios_base & __b, int __i); 
# 524 "/usr/include/c++/9/bits/ios_base.h" 3
void register_callback(event_callback __fn, int __index); 
# 527
protected: streamsize _M_precision; 
# 528
streamsize _M_width; 
# 529
fmtflags _M_flags; 
# 530
iostate _M_exception; 
# 531
iostate _M_streambuf_state; 
# 535
struct _Callback_list { 
# 538
_Callback_list *_M_next; 
# 539
event_callback _M_fn; 
# 540
int _M_index; 
# 541
_Atomic_word _M_refcount; 
# 543
_Callback_list(event_callback __fn, int __index, _Callback_list *
# 544
__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) 
# 545
{ } 
# 548
void _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 
# 552
int _M_remove_reference() 
# 553
{ 
# 555
; 
# 556
int __res = __gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1); 
# 557
if (__res == 0) 
# 558
{ 
# 559
; 
# 560
}  
# 561
return __res; 
# 562
} 
# 563
}; 
# 565
_Callback_list *_M_callbacks; 
# 568
void _M_call_callbacks(event __ev) throw(); 
# 571
void _M_dispose_callbacks() throw(); 
# 574
struct _Words { 
# 576
void *_M_pword; 
# 577
long _M_iword; 
# 578
_Words() : _M_pword((0)), _M_iword((0)) { } 
# 579
}; 
# 582
_Words _M_word_zero; 
# 586
enum { _S_local_word_size = 8}; 
# 587
_Words _M_local_word[_S_local_word_size]; 
# 590
int _M_word_size; 
# 591
_Words *_M_word; 
# 594
_Words &_M_grow_words(int __index, bool __iword); 
# 597
locale _M_ios_locale; 
# 600
void _M_init() throw(); 
# 608
public: class Init { 
# 610
friend class ios_base; 
# 612
public: Init(); 
# 613
~Init(); 
# 616
Init(const Init &) = default;
# 617
Init &operator=(const Init &) = default;
# 621
private: static _Atomic_word _S_refcount; 
# 622
static bool _S_synced_with_stdio; 
# 623
}; 
# 631
fmtflags flags() const 
# 632
{ return _M_flags; } 
# 642 "/usr/include/c++/9/bits/ios_base.h" 3
fmtflags flags(fmtflags __fmtfl) 
# 643
{ 
# 644
fmtflags __old = _M_flags; 
# 645
(_M_flags) = __fmtfl; 
# 646
return __old; 
# 647
} 
# 658 "/usr/include/c++/9/bits/ios_base.h" 3
fmtflags setf(fmtflags __fmtfl) 
# 659
{ 
# 660
fmtflags __old = _M_flags; 
# 661
((_M_flags) |= __fmtfl); 
# 662
return __old; 
# 663
} 
# 675 "/usr/include/c++/9/bits/ios_base.h" 3
fmtflags setf(fmtflags __fmtfl, fmtflags __mask) 
# 676
{ 
# 677
fmtflags __old = _M_flags; 
# 678
((_M_flags) &= ((~__mask))); 
# 679
((_M_flags) |= ((__fmtfl & __mask))); 
# 680
return __old; 
# 681
} 
# 690
void unsetf(fmtflags __mask) 
# 691
{ ((_M_flags) &= ((~__mask))); } 
# 701 "/usr/include/c++/9/bits/ios_base.h" 3
streamsize precision() const 
# 702
{ return _M_precision; } 
# 710
streamsize precision(streamsize __prec) 
# 711
{ 
# 712
streamsize __old = _M_precision; 
# 713
(_M_precision) = __prec; 
# 714
return __old; 
# 715
} 
# 724
streamsize width() const 
# 725
{ return _M_width; } 
# 733
streamsize width(streamsize __wide) 
# 734
{ 
# 735
streamsize __old = _M_width; 
# 736
(_M_width) = __wide; 
# 737
return __old; 
# 738
} 
# 752 "/usr/include/c++/9/bits/ios_base.h" 3
static bool sync_with_stdio(bool __sync = true); 
# 764 "/usr/include/c++/9/bits/ios_base.h" 3
locale imbue(const locale & __loc) throw(); 
# 775 "/usr/include/c++/9/bits/ios_base.h" 3
locale getloc() const 
# 776
{ return _M_ios_locale; } 
# 786 "/usr/include/c++/9/bits/ios_base.h" 3
const locale &_M_getloc() const 
# 787
{ return _M_ios_locale; } 
# 805 "/usr/include/c++/9/bits/ios_base.h" 3
static int xalloc() throw(); 
# 821 "/usr/include/c++/9/bits/ios_base.h" 3
long &iword(int __ix) 
# 822
{ 
# 823
_Words &__word = (((unsigned)__ix) < ((unsigned)(_M_word_size))) ? (_M_word)[__ix] : this->_M_grow_words(__ix, true); 
# 825
return __word._M_iword; 
# 826
} 
# 842 "/usr/include/c++/9/bits/ios_base.h" 3
void *&pword(int __ix) 
# 843
{ 
# 844
_Words &__word = (((unsigned)__ix) < ((unsigned)(_M_word_size))) ? (_M_word)[__ix] : this->_M_grow_words(__ix, false); 
# 846
return __word._M_pword; 
# 847
} 
# 858 "/usr/include/c++/9/bits/ios_base.h" 3
virtual ~ios_base(); 
# 861
protected: ios_base() throw(); 
# 873 "/usr/include/c++/9/bits/ios_base.h" 3
public: ios_base(const ios_base &) = delete;
# 876
ios_base &operator=(const ios_base &) = delete;
# 880
protected: void _M_move(ios_base &) noexcept; 
# 883
void _M_swap(ios_base & __rhs) noexcept; 
# 885
}; 
# 890
inline ios_base &boolalpha(ios_base &__base) 
# 891
{ 
# 892
__base.setf(ios_base::boolalpha); 
# 893
return __base; 
# 894
} 
# 898
inline ios_base &noboolalpha(ios_base &__base) 
# 899
{ 
# 900
__base.unsetf(ios_base::boolalpha); 
# 901
return __base; 
# 902
} 
# 906
inline ios_base &showbase(ios_base &__base) 
# 907
{ 
# 908
__base.setf(ios_base::showbase); 
# 909
return __base; 
# 910
} 
# 914
inline ios_base &noshowbase(ios_base &__base) 
# 915
{ 
# 916
__base.unsetf(ios_base::showbase); 
# 917
return __base; 
# 918
} 
# 922
inline ios_base &showpoint(ios_base &__base) 
# 923
{ 
# 924
__base.setf(ios_base::showpoint); 
# 925
return __base; 
# 926
} 
# 930
inline ios_base &noshowpoint(ios_base &__base) 
# 931
{ 
# 932
__base.unsetf(ios_base::showpoint); 
# 933
return __base; 
# 934
} 
# 938
inline ios_base &showpos(ios_base &__base) 
# 939
{ 
# 940
__base.setf(ios_base::showpos); 
# 941
return __base; 
# 942
} 
# 946
inline ios_base &noshowpos(ios_base &__base) 
# 947
{ 
# 948
__base.unsetf(ios_base::showpos); 
# 949
return __base; 
# 950
} 
# 954
inline ios_base &skipws(ios_base &__base) 
# 955
{ 
# 956
__base.setf(ios_base::skipws); 
# 957
return __base; 
# 958
} 
# 962
inline ios_base &noskipws(ios_base &__base) 
# 963
{ 
# 964
__base.unsetf(ios_base::skipws); 
# 965
return __base; 
# 966
} 
# 970
inline ios_base &uppercase(ios_base &__base) 
# 971
{ 
# 972
__base.setf(ios_base::uppercase); 
# 973
return __base; 
# 974
} 
# 978
inline ios_base &nouppercase(ios_base &__base) 
# 979
{ 
# 980
__base.unsetf(ios_base::uppercase); 
# 981
return __base; 
# 982
} 
# 986
inline ios_base &unitbuf(ios_base &__base) 
# 987
{ 
# 988
__base.setf(ios_base::unitbuf); 
# 989
return __base; 
# 990
} 
# 994
inline ios_base &nounitbuf(ios_base &__base) 
# 995
{ 
# 996
__base.unsetf(ios_base::unitbuf); 
# 997
return __base; 
# 998
} 
# 1003
inline ios_base &internal(ios_base &__base) 
# 1004
{ 
# 1005
__base.setf(ios_base::internal, ios_base::adjustfield); 
# 1006
return __base; 
# 1007
} 
# 1011
inline ios_base &left(ios_base &__base) 
# 1012
{ 
# 1013
__base.setf(ios_base::left, ios_base::adjustfield); 
# 1014
return __base; 
# 1015
} 
# 1019
inline ios_base &right(ios_base &__base) 
# 1020
{ 
# 1021
__base.setf(ios_base::right, ios_base::adjustfield); 
# 1022
return __base; 
# 1023
} 
# 1028
inline ios_base &dec(ios_base &__base) 
# 1029
{ 
# 1030
__base.setf(ios_base::dec, ios_base::basefield); 
# 1031
return __base; 
# 1032
} 
# 1036
inline ios_base &hex(ios_base &__base) 
# 1037
{ 
# 1038
__base.setf(ios_base::hex, ios_base::basefield); 
# 1039
return __base; 
# 1040
} 
# 1044
inline ios_base &oct(ios_base &__base) 
# 1045
{ 
# 1046
__base.setf(ios_base::oct, ios_base::basefield); 
# 1047
return __base; 
# 1048
} 
# 1053
inline ios_base &fixed(ios_base &__base) 
# 1054
{ 
# 1055
__base.setf(ios_base::fixed, ios_base::floatfield); 
# 1056
return __base; 
# 1057
} 
# 1061
inline ios_base &scientific(ios_base &__base) 
# 1062
{ 
# 1063
__base.setf(ios_base::scientific, ios_base::floatfield); 
# 1064
return __base; 
# 1065
} 
# 1073
inline ios_base &hexfloat(ios_base &__base) 
# 1074
{ 
# 1075
__base.setf((ios_base::fixed | ios_base::scientific), ios_base::floatfield); 
# 1076
return __base; 
# 1077
} 
# 1081
inline ios_base &defaultfloat(ios_base &__base) 
# 1082
{ 
# 1083
__base.unsetf(ios_base::floatfield); 
# 1084
return __base; 
# 1085
} 
# 1089
}
# 45 "/usr/include/c++/9/streambuf" 3
namespace std __attribute((__visibility__("default"))) { 
# 51
template< class _CharT, class _Traits> streamsize __copy_streambufs_eof(basic_streambuf< _CharT, _Traits>  *, basic_streambuf< _CharT, _Traits>  *, bool &); 
# 121 "/usr/include/c++/9/streambuf" 3
template< class _CharT, class _Traits> 
# 122
class basic_streambuf { 
# 131
public: typedef _CharT char_type; 
# 132
typedef _Traits traits_type; 
# 133
typedef typename _Traits::int_type int_type; 
# 134
typedef typename _Traits::pos_type pos_type; 
# 135
typedef typename _Traits::off_type off_type; 
# 140
typedef basic_streambuf __streambuf_type; 
# 143
friend class basic_ios< char_type, traits_type> ; 
# 144
friend class basic_istream< char_type, traits_type> ; 
# 145
friend class basic_ostream< char_type, traits_type> ; 
# 146
friend class istreambuf_iterator< char_type, traits_type> ; 
# 147
friend class ostreambuf_iterator< char_type, traits_type> ; 
# 150
friend streamsize __copy_streambufs_eof<> (basic_streambuf< _CharT, _Traits>  *, basic_streambuf< _CharT, _Traits>  *, bool &); 
# 152
template< bool _IsMove, class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, _CharT2 *> ::__type __copy_move_a2(std::istreambuf_iterator< _CharT2> , std::istreambuf_iterator< _CharT2> , _CharT2 *); 
# 158
template< class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, istreambuf_iterator< _CharT2> > ::__type find(std::istreambuf_iterator< _CharT2> , std::istreambuf_iterator< _CharT2> , const _CharT2 &); 
# 164
template< class _CharT2, class _Distance> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, void> ::__type advance(std::istreambuf_iterator< _CharT2>  &, _Distance); 
# 169
template< class _CharT2, class _Traits2> friend basic_istream< _CharT2, _Traits2>  &operator>>(std::basic_istream< _CharT2, _Traits2>  &, _CharT2 *); 
# 173
template< class _CharT2, class _Traits2, class _Alloc> friend basic_istream< _CharT2, _Traits2>  &operator>>(std::basic_istream< _CharT2, _Traits2>  &, std::__cxx11::basic_string< _CharT2, _Traits2, _Alloc>  &); 
# 178
template< class _CharT2, class _Traits2, class _Alloc> friend basic_istream< _CharT2, _Traits2>  &getline(std::basic_istream< _CharT2, _Traits2>  &, std::__cxx11::basic_string< _CharT2, _Traits2, _Alloc>  &, _CharT2); 
# 191
protected: char_type *_M_in_beg; 
# 192
char_type *_M_in_cur; 
# 193
char_type *_M_in_end; 
# 194
char_type *_M_out_beg; 
# 195
char_type *_M_out_cur; 
# 196
char_type *_M_out_end; 
# 199
locale _M_buf_locale; 
# 204
public: virtual ~basic_streambuf() 
# 205
{ } 
# 216 "/usr/include/c++/9/streambuf" 3
locale pubimbue(const locale &__loc) 
# 217
{ 
# 218
locale __tmp(getloc()); 
# 219
imbue(__loc); 
# 220
((_M_buf_locale) = __loc); 
# 221
return __tmp; 
# 222
} 
# 233 "/usr/include/c++/9/streambuf" 3
locale getloc() const 
# 234
{ return _M_buf_locale; } 
# 246 "/usr/include/c++/9/streambuf" 3
basic_streambuf *pubsetbuf(char_type *__s, streamsize __n) 
# 247
{ return setbuf(__s, __n); } 
# 258 "/usr/include/c++/9/streambuf" 3
pos_type pubseekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode 
# 259
__mode = (ios_base::in | ios_base::out)) 
# 260
{ return seekoff(__off, __way, __mode); } 
# 270 "/usr/include/c++/9/streambuf" 3
pos_type pubseekpos(pos_type __sp, ios_base::openmode 
# 271
__mode = (ios_base::in | ios_base::out)) 
# 272
{ return seekpos(__sp, __mode); } 
# 278
int pubsync() { return sync(); } 
# 291 "/usr/include/c++/9/streambuf" 3
streamsize in_avail() 
# 292
{ 
# 293
const streamsize __ret = egptr() - gptr(); 
# 294
return (__ret) ? __ret : showmanyc(); 
# 295
} 
# 305 "/usr/include/c++/9/streambuf" 3
int_type snextc() 
# 306
{ 
# 307
int_type __ret = traits_type::eof(); 
# 308
if (__builtin_expect(!traits_type::eq_int_type(sbumpc(), __ret), true)) { 
# 310
__ret = sgetc(); }  
# 311
return __ret; 
# 312
} 
# 323 "/usr/include/c++/9/streambuf" 3
int_type sbumpc() 
# 324
{ 
# 325
int_type __ret; 
# 326
if (__builtin_expect(gptr() < egptr(), true)) 
# 327
{ 
# 328
__ret = traits_type::to_int_type(*gptr()); 
# 329
gbump(1); 
# 330
} else { 
# 332
__ret = uflow(); }  
# 333
return __ret; 
# 334
} 
# 345 "/usr/include/c++/9/streambuf" 3
int_type sgetc() 
# 346
{ 
# 347
int_type __ret; 
# 348
if (__builtin_expect(gptr() < egptr(), true)) { 
# 349
__ret = traits_type::to_int_type(*gptr()); } else { 
# 351
__ret = underflow(); }  
# 352
return __ret; 
# 353
} 
# 364 "/usr/include/c++/9/streambuf" 3
streamsize sgetn(char_type *__s, streamsize __n) 
# 365
{ return xsgetn(__s, __n); } 
# 379 "/usr/include/c++/9/streambuf" 3
int_type sputbackc(char_type __c) 
# 380
{ 
# 381
int_type __ret; 
# 382
const bool __testpos = eback() < gptr(); 
# 383
if (__builtin_expect((!__testpos) || (!traits_type::eq(__c, gptr()[-1])), false)) { 
# 385
__ret = pbackfail(traits_type::to_int_type(__c)); } else 
# 387
{ 
# 388
gbump(-1); 
# 389
__ret = traits_type::to_int_type(*gptr()); 
# 390
}  
# 391
return __ret; 
# 392
} 
# 404 "/usr/include/c++/9/streambuf" 3
int_type sungetc() 
# 405
{ 
# 406
int_type __ret; 
# 407
if (__builtin_expect(eback() < gptr(), true)) 
# 408
{ 
# 409
gbump(-1); 
# 410
__ret = traits_type::to_int_type(*gptr()); 
# 411
} else { 
# 413
__ret = pbackfail(); }  
# 414
return __ret; 
# 415
} 
# 431 "/usr/include/c++/9/streambuf" 3
int_type sputc(char_type __c) 
# 432
{ 
# 433
int_type __ret; 
# 434
if (__builtin_expect(pptr() < epptr(), true)) 
# 435
{ 
# 436
(*pptr()) = __c; 
# 437
pbump(1); 
# 438
__ret = traits_type::to_int_type(__c); 
# 439
} else { 
# 441
__ret = overflow(traits_type::to_int_type(__c)); }  
# 442
return __ret; 
# 443
} 
# 457 "/usr/include/c++/9/streambuf" 3
streamsize sputn(const char_type *__s, streamsize __n) 
# 458
{ return xsputn(__s, __n); } 
# 470 "/usr/include/c++/9/streambuf" 3
protected: basic_streambuf() : _M_in_beg((0)), _M_in_cur((0)), _M_in_end((0)), _M_out_beg((0)), _M_out_cur((0)), _M_out_end((0)), _M_buf_locale(locale()) 
# 474
{ } 
# 489 "/usr/include/c++/9/streambuf" 3
char_type *eback() const { return _M_in_beg; } 
# 492
char_type *gptr() const { return _M_in_cur; } 
# 495
char_type *egptr() const { return _M_in_end; } 
# 505 "/usr/include/c++/9/streambuf" 3
void gbump(int __n) { (_M_in_cur) += __n; } 
# 516 "/usr/include/c++/9/streambuf" 3
void setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) 
# 517
{ 
# 518
(_M_in_beg) = __gbeg; 
# 519
(_M_in_cur) = __gnext; 
# 520
(_M_in_end) = __gend; 
# 521
} 
# 536 "/usr/include/c++/9/streambuf" 3
char_type *pbase() const { return _M_out_beg; } 
# 539
char_type *pptr() const { return _M_out_cur; } 
# 542
char_type *epptr() const { return _M_out_end; } 
# 552 "/usr/include/c++/9/streambuf" 3
void pbump(int __n) { (_M_out_cur) += __n; } 
# 562 "/usr/include/c++/9/streambuf" 3
void setp(char_type *__pbeg, char_type *__pend) 
# 563
{ 
# 564
(_M_out_beg) = ((_M_out_cur) = __pbeg); 
# 565
(_M_out_end) = __pend; 
# 566
} 
# 583 "/usr/include/c++/9/streambuf" 3
virtual void imbue(const locale &__loc __attribute((__unused__))) 
# 584
{ } 
# 598 "/usr/include/c++/9/streambuf" 3
virtual basic_streambuf *setbuf(char_type *, streamsize) 
# 599
{ return this; } 
# 609 "/usr/include/c++/9/streambuf" 3
virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = (ios_base::in | ios_base::out)) 
# 611
{ return (pos_type)((off_type)(-1)); } 
# 621 "/usr/include/c++/9/streambuf" 3
virtual pos_type seekpos(pos_type, ios_base::openmode = (ios_base::in | ios_base::out)) 
# 623
{ return (pos_type)((off_type)(-1)); } 
# 634 "/usr/include/c++/9/streambuf" 3
virtual int sync() { return 0; } 
# 656 "/usr/include/c++/9/streambuf" 3
virtual streamsize showmanyc() { return 0; } 
# 672 "/usr/include/c++/9/streambuf" 3
virtual streamsize xsgetn(char_type * __s, streamsize __n); 
# 694 "/usr/include/c++/9/streambuf" 3
virtual int_type underflow() 
# 695
{ return traits_type::eof(); } 
# 707 "/usr/include/c++/9/streambuf" 3
virtual int_type uflow() 
# 708
{ 
# 709
int_type __ret = traits_type::eof(); 
# 710
const bool __testeof = traits_type::eq_int_type(underflow(), __ret); 
# 712
if (!__testeof) 
# 713
{ 
# 714
__ret = traits_type::to_int_type(*gptr()); 
# 715
gbump(1); 
# 716
}  
# 717
return __ret; 
# 718
} 
# 731 "/usr/include/c++/9/streambuf" 3
virtual int_type pbackfail(int_type __c __attribute((__unused__)) = traits_type::eof()) 
# 732
{ return traits_type::eof(); } 
# 749 "/usr/include/c++/9/streambuf" 3
virtual streamsize xsputn(const char_type * __s, streamsize __n); 
# 775 "/usr/include/c++/9/streambuf" 3
virtual int_type overflow(int_type __c __attribute((__unused__)) = traits_type::eof()) 
# 776
{ return traits_type::eof(); } 
# 791 "/usr/include/c++/9/streambuf" 3
public: 
# 789
__attribute((__deprecated__("use \'std::basic_streambuf::sbumpc\' instead"))) void 
# 791
stossc() 
# 792
{ 
# 793
if (gptr() < egptr()) { 
# 794
gbump(1); } else { 
# 796
uflow(); }  
# 797
} 
# 802
void __safe_gbump(streamsize __n) { (_M_in_cur) += __n; } 
# 805
void __safe_pbump(streamsize __n) { (_M_out_cur) += __n; } 
# 812
protected: basic_streambuf(const basic_streambuf &); 
# 815
basic_streambuf &operator=(const basic_streambuf &); 
# 819
void swap(basic_streambuf &__sb) 
# 820
{ 
# 821
std::swap(_M_in_beg, __sb._M_in_beg); 
# 822
std::swap(_M_in_cur, __sb._M_in_cur); 
# 823
std::swap(_M_in_end, __sb._M_in_end); 
# 824
std::swap(_M_out_beg, __sb._M_out_beg); 
# 825
std::swap(_M_out_cur, __sb._M_out_cur); 
# 826
std::swap(_M_out_end, __sb._M_out_end); 
# 827
std::swap(_M_buf_locale, __sb._M_buf_locale); 
# 828
} 
# 830
}; 
# 833
template < typename _CharT, typename _Traits >
    std :: basic_streambuf < _CharT, _Traits > ::
    basic_streambuf ( const basic_streambuf & ) = default;
# 837
template < typename _CharT, typename _Traits >
    std :: basic_streambuf < _CharT, _Traits > &
    std :: basic_streambuf < _CharT, _Traits > ::
    operator = ( const basic_streambuf & ) = default;
# 846
template<> streamsize __copy_streambufs_eof(basic_streambuf< char>  * __sbin, basic_streambuf< char>  * __sbout, bool & __ineof); 
# 851
template<> streamsize __copy_streambufs_eof(basic_streambuf< wchar_t>  * __sbin, basic_streambuf< wchar_t>  * __sbout, bool & __ineof); 
# 858
}
# 39 "/usr/include/c++/9/bits/streambuf.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _CharT, class _Traits> streamsize 
# 46
basic_streambuf< _CharT, _Traits> ::xsgetn(char_type *__s, streamsize __n) 
# 47
{ 
# 48
streamsize __ret = (0); 
# 49
while (__ret < __n) 
# 50
{ 
# 51
const streamsize __buf_len = egptr() - gptr(); 
# 52
if (__buf_len) 
# 53
{ 
# 54
const streamsize __remaining = __n - __ret; 
# 55
const streamsize __len = std::min(__buf_len, __remaining); 
# 56
traits_type::copy(__s, gptr(), __len); 
# 57
__ret += __len; 
# 58
__s += __len; 
# 59
__safe_gbump(__len); 
# 60
}  
# 62
if (__ret < __n) 
# 63
{ 
# 64
const int_type __c = uflow(); 
# 65
if (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 66
{ 
# 67
traits_type::assign(*(__s++), traits_type::to_char_type(__c)); 
# 68
++__ret; 
# 69
} else { 
# 71
break; }  
# 72
}  
# 73
}  
# 74
return __ret; 
# 75
} 
# 77
template< class _CharT, class _Traits> streamsize 
# 80
basic_streambuf< _CharT, _Traits> ::xsputn(const char_type *__s, streamsize __n) 
# 81
{ 
# 82
streamsize __ret = (0); 
# 83
while (__ret < __n) 
# 84
{ 
# 85
const streamsize __buf_len = epptr() - pptr(); 
# 86
if (__buf_len) 
# 87
{ 
# 88
const streamsize __remaining = __n - __ret; 
# 89
const streamsize __len = std::min(__buf_len, __remaining); 
# 90
traits_type::copy(pptr(), __s, __len); 
# 91
__ret += __len; 
# 92
__s += __len; 
# 93
__safe_pbump(__len); 
# 94
}  
# 96
if (__ret < __n) 
# 97
{ 
# 98
int_type __c = overflow(traits_type::to_int_type(*__s)); 
# 99
if (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 100
{ 
# 101
++__ret; 
# 102
++__s; 
# 103
} else { 
# 105
break; }  
# 106
}  
# 107
}  
# 108
return __ret; 
# 109
} 
# 114
template< class _CharT, class _Traits> streamsize 
# 116
__copy_streambufs_eof(basic_streambuf< _CharT, _Traits>  *__sbin, basic_streambuf< _CharT, _Traits>  *
# 117
__sbout, bool &
# 118
__ineof) 
# 119
{ 
# 120
streamsize __ret = (0); 
# 121
__ineof = true; 
# 122
typename _Traits::int_type __c = __sbin->sgetc(); 
# 123
while (!_Traits::eq_int_type(__c, _Traits::eof())) 
# 124
{ 
# 125
__c = __sbout->sputc(_Traits::to_char_type(__c)); 
# 126
if (_Traits::eq_int_type(__c, _Traits::eof())) 
# 127
{ 
# 128
__ineof = false; 
# 129
break; 
# 130
}  
# 131
++__ret; 
# 132
__c = __sbin->snextc(); 
# 133
}  
# 134
return __ret; 
# 135
} 
# 137
template< class _CharT, class _Traits> inline streamsize 
# 139
__copy_streambufs(basic_streambuf< _CharT, _Traits>  *__sbin, basic_streambuf< _CharT, _Traits>  *
# 140
__sbout) 
# 141
{ 
# 142
bool __ineof; 
# 143
return __copy_streambufs_eof(__sbin, __sbout, __ineof); 
# 144
} 
# 149
extern template class basic_streambuf< char> ;
# 150
extern template streamsize __copy_streambufs(basic_streambuf< char>  * __sbin, basic_streambuf< char>  * __sbout);
# 154
extern template streamsize __copy_streambufs_eof<> (basic_streambuf< char>  *, basic_streambuf< char>  *, bool &);
# 160
extern template class basic_streambuf< wchar_t> ;
# 161
extern template streamsize __copy_streambufs(basic_streambuf< wchar_t>  * __sbin, basic_streambuf< wchar_t>  * __sbout);
# 165
extern template streamsize __copy_streambufs_eof<> (basic_streambuf< wchar_t>  *, basic_streambuf< wchar_t>  *, bool &);
# 173
}
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3
typedef unsigned long wctype_t; 
# 57 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3
enum { 
# 58
__ISwupper, 
# 59
__ISwlower, 
# 60
__ISwalpha, 
# 61
__ISwdigit, 
# 62
__ISwxdigit, 
# 63
__ISwspace, 
# 64
__ISwprint, 
# 65
__ISwgraph, 
# 66
__ISwblank, 
# 67
__ISwcntrl, 
# 68
__ISwpunct, 
# 69
__ISwalnum, 
# 71
_ISwupper = ((__ISwupper < 8) ? (int)((1UL << __ISwupper) << 24) : ((__ISwupper < 16) ? (int)((1UL << __ISwupper) << 8) : ((__ISwupper < 24) ? (int)((1UL << __ISwupper) >> 8) : ((int)((1UL << __ISwupper) >> 24))))), 
# 72
_ISwlower = ((__ISwlower < 8) ? (int)((1UL << __ISwlower) << 24) : ((__ISwlower < 16) ? (int)((1UL << __ISwlower) << 8) : ((__ISwlower < 24) ? (int)((1UL << __ISwlower) >> 8) : ((int)((1UL << __ISwlower) >> 24))))), 
# 73
_ISwalpha = ((__ISwalpha < 8) ? (int)((1UL << __ISwalpha) << 24) : ((__ISwalpha < 16) ? (int)((1UL << __ISwalpha) << 8) : ((__ISwalpha < 24) ? (int)((1UL << __ISwalpha) >> 8) : ((int)((1UL << __ISwalpha) >> 24))))), 
# 74
_ISwdigit = ((__ISwdigit < 8) ? (int)((1UL << __ISwdigit) << 24) : ((__ISwdigit < 16) ? (int)((1UL << __ISwdigit) << 8) : ((__ISwdigit < 24) ? (int)((1UL << __ISwdigit) >> 8) : ((int)((1UL << __ISwdigit) >> 24))))), 
# 75
_ISwxdigit = ((__ISwxdigit < 8) ? (int)((1UL << __ISwxdigit) << 24) : ((__ISwxdigit < 16) ? (int)((1UL << __ISwxdigit) << 8) : ((__ISwxdigit < 24) ? (int)((1UL << __ISwxdigit) >> 8) : ((int)((1UL << __ISwxdigit) >> 24))))), 
# 76
_ISwspace = ((__ISwspace < 8) ? (int)((1UL << __ISwspace) << 24) : ((__ISwspace < 16) ? (int)((1UL << __ISwspace) << 8) : ((__ISwspace < 24) ? (int)((1UL << __ISwspace) >> 8) : ((int)((1UL << __ISwspace) >> 24))))), 
# 77
_ISwprint = ((__ISwprint < 8) ? (int)((1UL << __ISwprint) << 24) : ((__ISwprint < 16) ? (int)((1UL << __ISwprint) << 8) : ((__ISwprint < 24) ? (int)((1UL << __ISwprint) >> 8) : ((int)((1UL << __ISwprint) >> 24))))), 
# 78
_ISwgraph = ((__ISwgraph < 8) ? (int)((1UL << __ISwgraph) << 24) : ((__ISwgraph < 16) ? (int)((1UL << __ISwgraph) << 8) : ((__ISwgraph < 24) ? (int)((1UL << __ISwgraph) >> 8) : ((int)((1UL << __ISwgraph) >> 24))))), 
# 79
_ISwblank = ((__ISwblank < 8) ? (int)((1UL << __ISwblank) << 24) : ((__ISwblank < 16) ? (int)((1UL << __ISwblank) << 8) : ((__ISwblank < 24) ? (int)((1UL << __ISwblank) >> 8) : ((int)((1UL << __ISwblank) >> 24))))), 
# 80
_ISwcntrl = ((__ISwcntrl < 8) ? (int)((1UL << __ISwcntrl) << 24) : ((__ISwcntrl < 16) ? (int)((1UL << __ISwcntrl) << 8) : ((__ISwcntrl < 24) ? (int)((1UL << __ISwcntrl) >> 8) : ((int)((1UL << __ISwcntrl) >> 24))))), 
# 81
_ISwpunct = ((__ISwpunct < 8) ? (int)((1UL << __ISwpunct) << 24) : ((__ISwpunct < 16) ? (int)((1UL << __ISwpunct) << 8) : ((__ISwpunct < 24) ? (int)((1UL << __ISwpunct) >> 8) : ((int)((1UL << __ISwpunct) >> 24))))), 
# 82
_ISwalnum = ((__ISwalnum < 8) ? (int)((1UL << __ISwalnum) << 24) : ((__ISwalnum < 16) ? (int)((1UL << __ISwalnum) << 8) : ((__ISwalnum < 24) ? (int)((1UL << __ISwalnum) >> 8) : ((int)((1UL << __ISwalnum) >> 24)))))
# 83
}; 
# 87
extern "C" {
# 95
extern int iswalnum(wint_t __wc) throw(); 
# 101
extern int iswalpha(wint_t __wc) throw(); 
# 104
extern int iswcntrl(wint_t __wc) throw(); 
# 108
extern int iswdigit(wint_t __wc) throw(); 
# 112
extern int iswgraph(wint_t __wc) throw(); 
# 117
extern int iswlower(wint_t __wc) throw(); 
# 120
extern int iswprint(wint_t __wc) throw(); 
# 125
extern int iswpunct(wint_t __wc) throw(); 
# 130
extern int iswspace(wint_t __wc) throw(); 
# 135
extern int iswupper(wint_t __wc) throw(); 
# 140
extern int iswxdigit(wint_t __wc) throw(); 
# 146
extern int iswblank(wint_t __wc) throw(); 
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3
extern wctype_t wctype(const char * __property) throw(); 
# 159
extern int iswctype(wint_t __wc, wctype_t __desc) throw(); 
# 166
extern wint_t towlower(wint_t __wc) throw(); 
# 169
extern wint_t towupper(wint_t __wc) throw(); 
# 171
}
# 44 "/usr/include/wctype.h" 3
extern "C" {
# 48
typedef const __int32_t *wctrans_t; 
# 52
extern wctrans_t wctrans(const char * __property) throw(); 
# 55
extern wint_t towctrans(wint_t __wc, wctrans_t __desc) throw(); 
# 63
extern int iswalnum_l(wint_t __wc, locale_t __locale) throw(); 
# 69
extern int iswalpha_l(wint_t __wc, locale_t __locale) throw(); 
# 72
extern int iswcntrl_l(wint_t __wc, locale_t __locale) throw(); 
# 76
extern int iswdigit_l(wint_t __wc, locale_t __locale) throw(); 
# 80
extern int iswgraph_l(wint_t __wc, locale_t __locale) throw(); 
# 85
extern int iswlower_l(wint_t __wc, locale_t __locale) throw(); 
# 88
extern int iswprint_l(wint_t __wc, locale_t __locale) throw(); 
# 93
extern int iswpunct_l(wint_t __wc, locale_t __locale) throw(); 
# 98
extern int iswspace_l(wint_t __wc, locale_t __locale) throw(); 
# 103
extern int iswupper_l(wint_t __wc, locale_t __locale) throw(); 
# 108
extern int iswxdigit_l(wint_t __wc, locale_t __locale) throw(); 
# 113
extern int iswblank_l(wint_t __wc, locale_t __locale) throw(); 
# 117
extern wctype_t wctype_l(const char * __property, locale_t __locale) throw(); 
# 122
extern int iswctype_l(wint_t __wc, wctype_t __desc, locale_t __locale) throw(); 
# 130
extern wint_t towlower_l(wint_t __wc, locale_t __locale) throw(); 
# 133
extern wint_t towupper_l(wint_t __wc, locale_t __locale) throw(); 
# 137
extern wctrans_t wctrans_l(const char * __property, locale_t __locale) throw(); 
# 141
extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, locale_t __locale) throw(); 
# 146
}
# 80 "/usr/include/c++/9/cwctype" 3
namespace std { 
# 82
using ::wctrans_t;
# 83
using ::wctype_t;
# 86
using ::iswalnum;
# 87
using ::iswalpha;
# 89
using ::iswblank;
# 91
using ::iswcntrl;
# 92
using ::iswctype;
# 93
using ::iswdigit;
# 94
using ::iswgraph;
# 95
using ::iswlower;
# 96
using ::iswprint;
# 97
using ::iswpunct;
# 98
using ::iswspace;
# 99
using ::iswupper;
# 100
using ::iswxdigit;
# 101
using ::towctrans;
# 102
using ::towlower;
# 103
using ::towupper;
# 104
using ::wctrans;
# 105
using ::wctype;
# 106
}
# 36 "/usr/include/x86_64-linux-gnu/c++/9/bits/ctype_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
struct ctype_base { 
# 44
typedef const int *__to_type; 
# 48
typedef unsigned short mask; 
# 49
static const mask upper = (_ISupper); 
# 50
static const mask lower = (_ISlower); 
# 51
static const mask alpha = (_ISalpha); 
# 52
static const mask digit = (_ISdigit); 
# 53
static const mask xdigit = (_ISxdigit); 
# 54
static const mask space = (_ISspace); 
# 55
static const mask print = (_ISprint); 
# 56
static const mask graph = (((_ISalpha) | (_ISdigit)) | (_ISpunct)); 
# 57
static const mask cntrl = (_IScntrl); 
# 58
static const mask punct = (_ISpunct); 
# 59
static const mask alnum = ((_ISalpha) | (_ISdigit)); 
# 61
static const mask blank = (_ISblank); 
# 63
}; 
# 66
}
# 38 "/usr/include/c++/9/bits/streambuf_iterator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 49 "/usr/include/c++/9/bits/streambuf_iterator.h" 3
template< class _CharT, class _Traits> 
# 50
class istreambuf_iterator : public iterator< input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT>  { 
# 64
public: typedef _CharT char_type; 
# 65
typedef _Traits traits_type; 
# 66
typedef typename _Traits::int_type int_type; 
# 67
typedef basic_streambuf< _CharT, _Traits>  streambuf_type; 
# 68
typedef basic_istream< _CharT, _Traits>  istream_type; 
# 71
template< class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, ostreambuf_iterator< _CharT2> > ::__type copy(std::istreambuf_iterator< _CharT2> , std::istreambuf_iterator< _CharT2> , std::ostreambuf_iterator< _CharT2> ); 
# 77
template< bool _IsMove, class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, _CharT2 *> ::__type __copy_move_a2(std::istreambuf_iterator< _CharT2> , std::istreambuf_iterator< _CharT2> , _CharT2 *); 
# 83
template< class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, istreambuf_iterator< _CharT2> > ::__type find(std::istreambuf_iterator< _CharT2> , std::istreambuf_iterator< _CharT2> , const _CharT2 &); 
# 89
template< class _CharT2, class _Distance> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, void> ::__type advance(std::istreambuf_iterator< _CharT2>  &, _Distance); 
# 102
private: mutable streambuf_type *_M_sbuf; 
# 103
int_type _M_c; 
# 107
public: constexpr istreambuf_iterator() noexcept : _M_sbuf((0)), _M_c(traits_type::eof()) 
# 108
{ } 
# 111
istreambuf_iterator(const istreambuf_iterator &) noexcept = default;
# 113
~istreambuf_iterator() = default;
# 117
istreambuf_iterator(istream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) 
# 118
{ } 
# 121
istreambuf_iterator(streambuf_type *__s) noexcept : _M_sbuf(__s), _M_c(traits_type::eof()) 
# 122
{ } 
# 126
istreambuf_iterator &operator=(const istreambuf_iterator &) noexcept = default;
# 133
char_type operator*() const 
# 134
{ 
# 135
int_type __c = _M_get(); 
# 144 "/usr/include/c++/9/bits/streambuf_iterator.h" 3
return traits_type::to_char_type(__c); 
# 145
} 
# 149
istreambuf_iterator &operator++() 
# 150
{ 
# 154
; 
# 156
(_M_sbuf)->sbumpc(); 
# 157
(_M_c) = traits_type::eof(); 
# 158
return *this; 
# 159
} 
# 163
istreambuf_iterator operator++(int) 
# 164
{ 
# 168
; 
# 170
istreambuf_iterator __old = *this; 
# 171
(__old._M_c) = (_M_sbuf)->sbumpc(); 
# 172
(_M_c) = traits_type::eof(); 
# 173
return __old; 
# 174
} 
# 181
bool equal(const istreambuf_iterator &__b) const 
# 182
{ return _M_at_eof() == __b._M_at_eof(); } 
# 186
private: int_type _M_get() const 
# 187
{ 
# 188
int_type __ret = _M_c; 
# 189
if ((_M_sbuf) && (_S_is_eof)(__ret) && (_S_is_eof)(__ret = (_M_sbuf)->sgetc())) { 
# 190
(_M_sbuf) = 0; }  
# 191
return __ret; 
# 192
} 
# 195
bool _M_at_eof() const 
# 196
{ return (_S_is_eof)(_M_get()); } 
# 199
static bool _S_is_eof(int_type __c) 
# 200
{ 
# 201
const int_type __eof = traits_type::eof(); 
# 202
return traits_type::eq_int_type(__c, __eof); 
# 203
} 
# 204
}; 
# 206
template< class _CharT, class _Traits> inline bool 
# 208
operator==(const istreambuf_iterator< _CharT, _Traits>  &__a, const istreambuf_iterator< _CharT, _Traits>  &
# 209
__b) 
# 210
{ return __a.equal(__b); } 
# 212
template< class _CharT, class _Traits> inline bool 
# 214
operator!=(const istreambuf_iterator< _CharT, _Traits>  &__a, const istreambuf_iterator< _CharT, _Traits>  &
# 215
__b) 
# 216
{ return !__a.equal(__b); } 
# 219
template< class _CharT, class _Traits> 
# 220
class ostreambuf_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 227
public: typedef _CharT char_type; 
# 228
typedef _Traits traits_type; 
# 229
typedef basic_streambuf< _CharT, _Traits>  streambuf_type; 
# 230
typedef basic_ostream< _CharT, _Traits>  ostream_type; 
# 233
template< class _CharT2> friend typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, ostreambuf_iterator< _CharT2> > ::__type copy(std::istreambuf_iterator< _CharT2> , std::istreambuf_iterator< _CharT2> , std::ostreambuf_iterator< _CharT2> ); 
# 240
private: streambuf_type *_M_sbuf; 
# 241
bool _M_failed; 
# 245
public: ostreambuf_iterator(ostream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_failed((!(_M_sbuf))) 
# 246
{ } 
# 249
ostreambuf_iterator(streambuf_type *__s) noexcept : _M_sbuf(__s), _M_failed((!(_M_sbuf))) 
# 250
{ } 
# 254
ostreambuf_iterator &operator=(_CharT __c) 
# 255
{ 
# 256
if ((!(_M_failed)) && _Traits::eq_int_type((_M_sbuf)->sputc(__c), _Traits::eof())) { 
# 258
(_M_failed) = true; }  
# 259
return *this; 
# 260
} 
# 264
ostreambuf_iterator &operator*() 
# 265
{ return *this; } 
# 269
ostreambuf_iterator &operator++(int) 
# 270
{ return *this; } 
# 274
ostreambuf_iterator &operator++() 
# 275
{ return *this; } 
# 279
bool failed() const noexcept 
# 280
{ return _M_failed; } 
# 283
ostreambuf_iterator &_M_put(const _CharT *__ws, streamsize __len) 
# 284
{ 
# 285
if ((__builtin_expect(!(_M_failed), true)) && (__builtin_expect((this->_M_sbuf)->sputn(__ws, __len) != __len, false))) { 
# 288
(_M_failed) = true; }  
# 289
return *this; 
# 290
} 
# 291
}; 
# 294
template< class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT> > ::__type 
# 297
copy(istreambuf_iterator< _CharT>  __first, istreambuf_iterator< _CharT>  
# 298
__last, ostreambuf_iterator< _CharT>  
# 299
__result) 
# 300
{ 
# 301
if ((__first._M_sbuf) && (!(__last._M_sbuf)) && (!(__result._M_failed))) 
# 302
{ 
# 303
bool __ineof; 
# 304
__copy_streambufs_eof((__first._M_sbuf), (__result._M_sbuf), __ineof); 
# 305
if (!__ineof) { 
# 306
(__result._M_failed) = true; }  
# 307
}  
# 308
return __result; 
# 309
} 
# 311
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT> > ::__type 
# 314
__copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator< _CharT>  
# 315
__result) 
# 316
{ 
# 317
const streamsize __num = __last - __first; 
# 318
if (__num > (0)) { 
# 319
__result._M_put(__first, __num); }  
# 320
return __result; 
# 321
} 
# 323
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, ostreambuf_iterator< _CharT> > ::__type 
# 326
__copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator< _CharT>  
# 327
__result) 
# 328
{ 
# 329
const streamsize __num = __last - __first; 
# 330
if (__num > (0)) { 
# 331
__result._M_put(__first, __num); }  
# 332
return __result; 
# 333
} 
# 335
template< bool _IsMove, class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, _CharT *> ::__type 
# 338
__copy_move_a2(istreambuf_iterator< _CharT>  __first, istreambuf_iterator< _CharT>  
# 339
__last, _CharT *__result) 
# 340
{ 
# 341
typedef istreambuf_iterator< _CharT>  __is_iterator_type; 
# 342
typedef typename istreambuf_iterator< _CharT> ::traits_type traits_type; 
# 343
typedef typename istreambuf_iterator< _CharT> ::streambuf_type streambuf_type; 
# 344
typedef typename istreambuf_iterator< _CharT> ::traits_type::int_type int_type; 
# 346
if ((__first._M_sbuf) && (!(__last._M_sbuf))) 
# 347
{ 
# 348
streambuf_type *__sb = ((__first._M_sbuf)); 
# 349
int_type __c = __sb->sgetc(); 
# 350
while (!traits_type::eq_int_type(__c, traits_type::eof())) 
# 351
{ 
# 352
const streamsize __n = __sb->egptr() - __sb->gptr(); 
# 353
if (__n > (1)) 
# 354
{ 
# 355
traits_type::copy(__result, __sb->gptr(), __n); 
# 356
__sb->__safe_gbump(__n); 
# 357
__result += __n; 
# 358
__c = __sb->underflow(); 
# 359
} else 
# 361
{ 
# 362
(*(__result++)) = traits_type::to_char_type(__c); 
# 363
__c = __sb->snextc(); 
# 364
}  
# 365
}  
# 366
}  
# 367
return __result; 
# 368
} 
# 370
template< class _CharT> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, istreambuf_iterator< _CharT> > ::__type 
# 373
find(istreambuf_iterator< _CharT>  __first, istreambuf_iterator< _CharT>  
# 374
__last, const _CharT &__val) 
# 375
{ 
# 376
typedef istreambuf_iterator< _CharT>  __is_iterator_type; 
# 377
typedef typename istreambuf_iterator< _CharT> ::traits_type traits_type; 
# 378
typedef typename istreambuf_iterator< _CharT> ::streambuf_type streambuf_type; 
# 379
typedef typename istreambuf_iterator< _CharT> ::traits_type::int_type int_type; 
# 380
const int_type __eof = traits_type::eof(); 
# 382
if ((__first._M_sbuf) && (!(__last._M_sbuf))) 
# 383
{ 
# 384
const int_type __ival = traits_type::to_int_type(__val); 
# 385
streambuf_type *__sb = ((__first._M_sbuf)); 
# 386
int_type __c = __sb->sgetc(); 
# 387
while ((!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __ival))) 
# 389
{ 
# 390
streamsize __n = __sb->egptr() - __sb->gptr(); 
# 391
if (__n > (1)) 
# 392
{ 
# 393
const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val); 
# 395
if (__p) { 
# 396
__n = (__p - __sb->gptr()); }  
# 397
__sb->__safe_gbump(__n); 
# 398
__c = __sb->sgetc(); 
# 399
} else { 
# 401
__c = __sb->snextc(); }  
# 402
}  
# 404
(__first._M_c) = __eof; 
# 405
}  
# 407
return __first; 
# 408
} 
# 410
template< class _CharT, class _Distance> typename __gnu_cxx::__enable_if< __is_char< _CharT> ::__value, void> ::__type 
# 413
advance(istreambuf_iterator< _CharT>  &__i, _Distance __n) 
# 414
{ 
# 415
if (__n == 0) { 
# 416
return; }  
# 418
; 
# 421
; 
# 423
typedef istreambuf_iterator< _CharT>  __is_iterator_type; 
# 424
typedef typename istreambuf_iterator< _CharT> ::traits_type traits_type; 
# 425
typedef typename istreambuf_iterator< _CharT> ::streambuf_type streambuf_type; 
# 426
typedef typename istreambuf_iterator< _CharT> ::traits_type::int_type int_type; 
# 427
const int_type __eof = traits_type::eof(); 
# 429
streambuf_type *__sb = ((__i._M_sbuf)); 
# 430
while (__n > 0) 
# 431
{ 
# 432
streamsize __size = __sb->egptr() - __sb->gptr(); 
# 433
if (__size > __n) 
# 434
{ 
# 435
__sb->__safe_gbump(__n); 
# 436
break; 
# 437
}  
# 439
__sb->__safe_gbump(__size); 
# 440
__n -= __size; 
# 441
if (traits_type::eq_int_type(__sb->underflow(), __eof)) 
# 442
{ 
# 445
; 
# 446
break; 
# 447
}  
# 448
}  
# 450
(__i._M_c) = __eof; 
# 451
} 
# 456
}
# 50 "/usr/include/c++/9/bits/locale_facets.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71 "/usr/include/c++/9/bits/locale_facets.h" 3
template< class _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const __c_locale &) throw(); 
# 79
template<> void __convert_to_v(const char *, float &, ios_base::iostate &, const __c_locale &) throw(); 
# 84
template<> void __convert_to_v(const char *, double &, ios_base::iostate &, const __c_locale &) throw(); 
# 89
template<> void __convert_to_v(const char *, long double &, ios_base::iostate &, const __c_locale &) throw(); 
# 94
template< class _CharT, class _Traits> 
# 95
struct __pad { 
# 98
static void _S_pad(ios_base & __io, _CharT __fill, _CharT * __news, const _CharT * __olds, streamsize __newlen, streamsize __oldlen); 
# 100
}; 
# 107
template< class _CharT> _CharT *__add_grouping(_CharT * __s, _CharT __sep, const char * __gbeg, size_t __gsize, const _CharT * __first, const _CharT * __last); 
# 116
template< class _CharT> inline ostreambuf_iterator< _CharT>  
# 119
__write(ostreambuf_iterator< _CharT>  __s, const _CharT *__ws, int __len) 
# 120
{ 
# 121
__s._M_put(__ws, __len); 
# 122
return __s; 
# 123
} 
# 126
template< class _CharT, class _OutIter> inline _OutIter 
# 129
__write(_OutIter __s, const _CharT *__ws, int __len) 
# 130
{ 
# 131
for (int __j = 0; __j < __len; (__j++), (++__s)) { 
# 132
(*__s) = (__ws[__j]); }  
# 133
return __s; 
# 134
} 
# 149 "/usr/include/c++/9/bits/locale_facets.h" 3
template< class _CharT> 
# 150
class __ctype_abstract_base : public locale::facet, public ctype_base { 
# 155
public: typedef _CharT char_type; 
# 169 "/usr/include/c++/9/bits/locale_facets.h" 3
bool is(mask __m, char_type __c) const 
# 170
{ return this->do_is(__m, __c); } 
# 186 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *is(const char_type *__lo, const char_type *__hi, mask *__vec) const 
# 187
{ return this->do_is(__lo, __hi, __vec); } 
# 202 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *scan_is(mask __m, const char_type *__lo, const char_type *__hi) const 
# 203
{ return do_scan_is(__m, __lo, __hi); } 
# 218 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *scan_not(mask __m, const char_type *__lo, const char_type *__hi) const 
# 219
{ return do_scan_not(__m, __lo, __hi); } 
# 232 "/usr/include/c++/9/bits/locale_facets.h" 3
char_type toupper(char_type __c) const 
# 233
{ return this->do_toupper(__c); } 
# 247 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *toupper(char_type *__lo, const char_type *__hi) const 
# 248
{ return this->do_toupper(__lo, __hi); } 
# 261 "/usr/include/c++/9/bits/locale_facets.h" 3
char_type tolower(char_type __c) const 
# 262
{ return this->do_tolower(__c); } 
# 276 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *tolower(char_type *__lo, const char_type *__hi) const 
# 277
{ return this->do_tolower(__lo, __hi); } 
# 293 "/usr/include/c++/9/bits/locale_facets.h" 3
char_type widen(char __c) const 
# 294
{ return this->do_widen(__c); } 
# 312 "/usr/include/c++/9/bits/locale_facets.h" 3
const char *widen(const char *__lo, const char *__hi, char_type *__to) const 
# 313
{ return this->do_widen(__lo, __hi, __to); } 
# 331 "/usr/include/c++/9/bits/locale_facets.h" 3
char narrow(char_type __c, char __dfault) const 
# 332
{ return this->do_narrow(__c, __dfault); } 
# 353 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *narrow(const char_type *__lo, const char_type *__hi, char 
# 354
__dfault, char *__to) const 
# 355
{ return this->do_narrow(__lo, __hi, __dfault, __to); } 
# 359
protected: explicit __ctype_abstract_base(size_t __refs = 0) : locale::facet(__refs) { } 
# 362
virtual ~__ctype_abstract_base() { } 
# 378 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual bool do_is(mask __m, char_type __c) const = 0; 
# 397 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const = 0; 
# 416 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const = 0; 
# 435 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const = 0; 
# 453 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_toupper(char_type __c) const = 0; 
# 470 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const = 0; 
# 486 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_tolower(char_type __c) const = 0; 
# 503 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const = 0; 
# 522 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_widen(char __c) const = 0; 
# 543 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __to) const = 0; 
# 564 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char do_narrow(char_type __c, char __dfault) const = 0; 
# 589 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const = 0; 
# 591
}; 
# 611 "/usr/include/c++/9/bits/locale_facets.h" 3
template< class _CharT> 
# 612
class ctype : public __ctype_abstract_base< _CharT>  { 
# 616
public: typedef _CharT char_type; 
# 617
typedef typename __ctype_abstract_base< _CharT> ::mask mask; 
# 620
static std::locale::id id; 
# 623
explicit ctype(std::size_t __refs = 0) : __ctype_abstract_base< _CharT> (__refs) { } 
# 627
protected: virtual ~ctype(); 
# 630
virtual bool do_is(mask __m, char_type __c) const; 
# 633
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const; 
# 636
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 639
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 643
virtual char_type do_toupper(char_type __c) const; 
# 646
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 649
virtual char_type do_tolower(char_type __c) const; 
# 652
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 655
virtual char_type do_widen(char __c) const; 
# 658
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __dest) const; 
# 661
virtual char do_narrow(char_type, char __dfault) const; 
# 664
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const; 
# 666
}; 
# 668
template< class _CharT> locale::id 
# 669
ctype< _CharT> ::id; 
# 681 "/usr/include/c++/9/bits/locale_facets.h" 3
template<> class ctype< char>  : public locale::facet, public ctype_base { 
# 686
public: typedef char char_type; 
# 690
protected: __c_locale _M_c_locale_ctype; 
# 691
bool _M_del; 
# 692
__to_type _M_toupper; 
# 693
__to_type _M_tolower; 
# 694
const mask *_M_table; 
# 695
mutable char _M_widen_ok; 
# 696
mutable char _M_widen[1 + (static_cast< unsigned char>(-1))]; 
# 697
mutable char _M_narrow[1 + (static_cast< unsigned char>(-1))]; 
# 698
mutable char _M_narrow_ok; 
# 703
public: static locale::id id; 
# 705
static const size_t table_size = (1 + (static_cast< unsigned char>(-1))); 
# 718 "/usr/include/c++/9/bits/locale_facets.h" 3
explicit ctype(const mask * __table = 0, bool __del = false, size_t __refs = 0); 
# 731 "/usr/include/c++/9/bits/locale_facets.h" 3
explicit ctype(__c_locale __cloc, const mask * __table = 0, bool __del = false, size_t __refs = 0); 
# 744 "/usr/include/c++/9/bits/locale_facets.h" 3
inline bool is(mask __m, char __c) const; 
# 759 "/usr/include/c++/9/bits/locale_facets.h" 3
inline const char *is(const char * __lo, const char * __hi, mask * __vec) const; 
# 773 "/usr/include/c++/9/bits/locale_facets.h" 3
inline const char *scan_is(mask __m, const char * __lo, const char * __hi) const; 
# 787 "/usr/include/c++/9/bits/locale_facets.h" 3
inline const char *scan_not(mask __m, const char * __lo, const char * __hi) const; 
# 802 "/usr/include/c++/9/bits/locale_facets.h" 3
char_type toupper(char_type __c) const 
# 803
{ return this->do_toupper(__c); } 
# 819 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *toupper(char_type *__lo, const char_type *__hi) const 
# 820
{ return this->do_toupper(__lo, __hi); } 
# 835 "/usr/include/c++/9/bits/locale_facets.h" 3
char_type tolower(char_type __c) const 
# 836
{ return this->do_tolower(__c); } 
# 852 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *tolower(char_type *__lo, const char_type *__hi) const 
# 853
{ return this->do_tolower(__lo, __hi); } 
# 872 "/usr/include/c++/9/bits/locale_facets.h" 3
char_type widen(char __c) const 
# 873
{ 
# 874
if (_M_widen_ok) { 
# 875
return (_M_widen)[static_cast< unsigned char>(__c)]; }  
# 876
this->_M_widen_init(); 
# 877
return this->do_widen(__c); 
# 878
} 
# 899 "/usr/include/c++/9/bits/locale_facets.h" 3
const char *widen(const char *__lo, const char *__hi, char_type *__to) const 
# 900
{ 
# 901
if ((_M_widen_ok) == 1) 
# 902
{ 
# 903
if (__builtin_expect(__hi != __lo, true)) { 
# 904
__builtin_memcpy(__to, __lo, __hi - __lo); }  
# 905
return __hi; 
# 906
}  
# 907
if (!(_M_widen_ok)) { 
# 908
this->_M_widen_init(); }  
# 909
return this->do_widen(__lo, __hi, __to); 
# 910
} 
# 931 "/usr/include/c++/9/bits/locale_facets.h" 3
char narrow(char_type __c, char __dfault) const 
# 932
{ 
# 933
if ((_M_narrow)[static_cast< unsigned char>(__c)]) { 
# 934
return (_M_narrow)[static_cast< unsigned char>(__c)]; }  
# 935
const char __t = this->do_narrow(__c, __dfault); 
# 936
if (__t != __dfault) { 
# 937
((_M_narrow)[static_cast< unsigned char>(__c)]) = __t; }  
# 938
return __t; 
# 939
} 
# 964 "/usr/include/c++/9/bits/locale_facets.h" 3
const char_type *narrow(const char_type *__lo, const char_type *__hi, char 
# 965
__dfault, char *__to) const 
# 966
{ 
# 967
if (__builtin_expect((_M_narrow_ok) == 1, true)) 
# 968
{ 
# 969
if (__builtin_expect(__hi != __lo, true)) { 
# 970
__builtin_memcpy(__to, __lo, __hi - __lo); }  
# 971
return __hi; 
# 972
}  
# 973
if (!(_M_narrow_ok)) { 
# 974
this->_M_narrow_init(); }  
# 975
return this->do_narrow(__lo, __hi, __dfault, __to); 
# 976
} 
# 983
const mask *table() const throw() 
# 984
{ return _M_table; } 
# 988
static const mask *classic_table() throw(); 
# 998
protected: virtual ~ctype(); 
# 1014 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_toupper(char_type __c) const; 
# 1031 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 1047 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_tolower(char_type __c) const; 
# 1064 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 1084 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_widen(char __c) const 
# 1085
{ return __c; } 
# 1107 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const 
# 1108
{ 
# 1109
if (__builtin_expect(__hi != __lo, true)) { 
# 1110
__builtin_memcpy(__to, __lo, __hi - __lo); }  
# 1111
return __hi; 
# 1112
} 
# 1134 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char do_narrow(char_type __c, char __dfault __attribute((__unused__))) const 
# 1135
{ return __c; } 
# 1160 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char 
# 1161
__dfault __attribute((__unused__)), char *__to) const 
# 1162
{ 
# 1163
if (__builtin_expect(__hi != __lo, true)) { 
# 1164
__builtin_memcpy(__to, __lo, __hi - __lo); }  
# 1165
return __hi; 
# 1166
} 
# 1169
private: void _M_narrow_init() const; 
# 1170
void _M_widen_init() const; 
# 1171
}; 
# 1186 "/usr/include/c++/9/bits/locale_facets.h" 3
template<> class ctype< wchar_t>  : public __ctype_abstract_base< wchar_t>  { 
# 1191
public: typedef wchar_t char_type; 
# 1192
typedef wctype_t __wmask_type; 
# 1195
protected: __c_locale _M_c_locale_ctype; 
# 1198
bool _M_narrow_ok; 
# 1199
char _M_narrow[128]; 
# 1200
wint_t _M_widen[1 + (static_cast< unsigned char>(-1))]; 
# 1203
mask _M_bit[16]; 
# 1204
__wmask_type _M_wmask[16]; 
# 1209
public: static locale::id id; 
# 1219 "/usr/include/c++/9/bits/locale_facets.h" 3
explicit ctype(size_t __refs = 0); 
# 1230 "/usr/include/c++/9/bits/locale_facets.h" 3
explicit ctype(__c_locale __cloc, size_t __refs = 0); 
# 1234
protected: __wmask_type _M_convert_to_wmask(const mask __m) const throw(); 
# 1238
virtual ~ctype(); 
# 1254 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual bool do_is(mask __m, char_type __c) const; 
# 1273 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const; 
# 1291 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 1309 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 1326 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_toupper(char_type __c) const; 
# 1343 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 1359 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_tolower(char_type __c) const; 
# 1376 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 1396 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_widen(char __c) const; 
# 1418 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __to) const; 
# 1441 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char do_narrow(char_type __c, char __dfault) const; 
# 1467 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const; 
# 1472
void _M_initialize_ctype() throw(); 
# 1473
}; 
# 1477
template< class _CharT> 
# 1478
class ctype_byname : public ctype< _CharT>  { 
# 1481
public: typedef typename ctype< _CharT> ::mask mask; 
# 1484
explicit ctype_byname(const char * __s, std::size_t __refs = 0); 
# 1488
explicit ctype_byname(const std::string &__s, std::size_t __refs = 0) : ctype_byname(__s.c_str(), __refs) 
# 1489
{ } 
# 1494
protected: virtual ~ctype_byname() { } 
# 1495
}; 
# 1499
template<> class ctype_byname< char>  : public ctype< char>  { 
# 1503
public: explicit ctype_byname(const char * __s, size_t __refs = 0); 
# 1507
explicit ctype_byname(const string & __s, size_t __refs = 0); 
# 1512
protected: virtual ~ctype_byname(); 
# 1513
}; 
# 1517
template<> class ctype_byname< wchar_t>  : public ctype< wchar_t>  { 
# 1521
public: explicit ctype_byname(const char * __s, size_t __refs = 0); 
# 1525
explicit ctype_byname(const string & __s, size_t __refs = 0); 
# 1530
protected: virtual ~ctype_byname(); 
# 1531
}; 
# 1535
}
# 37 "/usr/include/x86_64-linux-gnu/c++/9/bits/ctype_inline.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
inline bool ctype< char> ::is(mask __m, char __c) const 
# 44
{ return ((_M_table)[static_cast< unsigned char>(__c)]) & __m; } 
# 48
inline const char *ctype< char> ::is(const char *__low, const char *__high, mask *__vec) const 
# 49
{ 
# 50
while (__low < __high) { 
# 51
(*(__vec++)) = ((_M_table)[static_cast< unsigned char>(*(__low++))]); }  
# 52
return __high; 
# 53
} 
# 57
inline const char *ctype< char> ::scan_is(mask __m, const char *__low, const char *__high) const 
# 58
{ 
# 59
while ((__low < __high) && (!(((_M_table)[static_cast< unsigned char>(*__low)]) & __m))) { 
# 61
++__low; }  
# 62
return __low; 
# 63
} 
# 67
inline const char *ctype< char> ::scan_not(mask __m, const char *__low, const char *__high) const 
# 68
{ 
# 69
while ((__low < __high) && ((((_M_table)[static_cast< unsigned char>(*__low)]) & __m) != 0)) { 
# 71
++__low; }  
# 72
return __low; 
# 73
} 
# 76
}
# 1540 "/usr/include/c++/9/bits/locale_facets.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 1545
class __num_base { 
# 1551
public: enum { 
# 1552
_S_ominus, 
# 1553
_S_oplus, 
# 1554
_S_ox, 
# 1555
_S_oX, 
# 1556
_S_odigits, 
# 1557
_S_odigits_end = (_S_odigits + 16), 
# 1558
_S_oudigits = _S_odigits_end, 
# 1559
_S_oudigits_end = (_S_oudigits + 16), 
# 1560
_S_oe = (_S_odigits + 14), 
# 1561
_S_oE = (_S_oudigits + 14), 
# 1562
_S_oend = _S_oudigits_end
# 1563
}; 
# 1570
static const char *_S_atoms_out; 
# 1574
static const char *_S_atoms_in; 
# 1577
enum { 
# 1578
_S_iminus, 
# 1579
_S_iplus, 
# 1580
_S_ix, 
# 1581
_S_iX, 
# 1582
_S_izero, 
# 1583
_S_ie = (_S_izero + 14), 
# 1584
_S_iE = (_S_izero + 20), 
# 1585
_S_iend = 26
# 1586
}; 
# 1591
static void _S_format_float(const ios_base & __io, char * __fptr, char __mod) throw(); 
# 1592
}; 
# 1594
template< class _CharT> 
# 1595
struct __numpunct_cache : public locale::facet { 
# 1597
const char *_M_grouping; 
# 1598
size_t _M_grouping_size; 
# 1599
bool _M_use_grouping; 
# 1600
const _CharT *_M_truename; 
# 1601
size_t _M_truename_size; 
# 1602
const _CharT *_M_falsename; 
# 1603
size_t _M_falsename_size; 
# 1604
_CharT _M_decimal_point; 
# 1605
_CharT _M_thousands_sep; 
# 1611
_CharT _M_atoms_out[__num_base::_S_oend]; 
# 1617
_CharT _M_atoms_in[__num_base::_S_iend]; 
# 1619
bool _M_allocated; 
# 1621
__numpunct_cache(size_t __refs = 0) : locale::facet(__refs), _M_grouping((0)), _M_grouping_size((0)), _M_use_grouping(false), _M_truename((0)), _M_truename_size((0)), _M_falsename((0)), _M_falsename_size((0)), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false) 
# 1627
{ } 
# 1629
virtual ~__numpunct_cache(); 
# 1632
void _M_cache(const locale & __loc); 
# 1636
private: __numpunct_cache &operator=(const __numpunct_cache &); 
# 1639
explicit __numpunct_cache(const __numpunct_cache &); 
# 1640
}; 
# 1642
template< class _CharT> 
# 1643
__numpunct_cache< _CharT> ::~__numpunct_cache() 
# 1644
{ 
# 1645
if (_M_allocated) 
# 1646
{ 
# 1647
delete [] (_M_grouping); 
# 1648
delete [] (_M_truename); 
# 1649
delete [] (_M_falsename); 
# 1650
}  
# 1651
} 
# 1653
inline namespace __cxx11 { 
# 1669 "/usr/include/c++/9/bits/locale_facets.h" 3
template< class _CharT> 
# 1670
class numpunct : public locale::facet { 
# 1676
public: typedef _CharT char_type; 
# 1677
typedef basic_string< _CharT>  string_type; 
# 1679
typedef __numpunct_cache< _CharT>  __cache_type; 
# 1682
protected: __cache_type *_M_data; 
# 1686
public: static locale::id id; 
# 1694
explicit numpunct(size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1696
{ _M_initialize_numpunct(); } 
# 1708 "/usr/include/c++/9/bits/locale_facets.h" 3
explicit numpunct(__cache_type *__cache, size_t __refs = 0) : locale::facet(__refs), _M_data(__cache) 
# 1710
{ _M_initialize_numpunct(); } 
# 1722 "/usr/include/c++/9/bits/locale_facets.h" 3
explicit numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1724
{ _M_initialize_numpunct(__cloc); } 
# 1736 "/usr/include/c++/9/bits/locale_facets.h" 3
char_type decimal_point() const 
# 1737
{ return do_decimal_point(); } 
# 1749 "/usr/include/c++/9/bits/locale_facets.h" 3
char_type thousands_sep() const 
# 1750
{ return do_thousands_sep(); } 
# 1780 "/usr/include/c++/9/bits/locale_facets.h" 3
string grouping() const 
# 1781
{ return do_grouping(); } 
# 1793 "/usr/include/c++/9/bits/locale_facets.h" 3
string_type truename() const 
# 1794
{ return do_truename(); } 
# 1806 "/usr/include/c++/9/bits/locale_facets.h" 3
string_type falsename() const 
# 1807
{ return do_falsename(); } 
# 1812
protected: virtual ~numpunct(); 
# 1823 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_decimal_point() const 
# 1824
{ return (_M_data)->_M_decimal_point; } 
# 1835 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual char_type do_thousands_sep() const 
# 1836
{ return (_M_data)->_M_thousands_sep; } 
# 1848 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual string do_grouping() const 
# 1849
{ return (_M_data)->_M_grouping; } 
# 1861 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual string_type do_truename() const 
# 1862
{ return (_M_data)->_M_truename; } 
# 1874 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual string_type do_falsename() const 
# 1875
{ return (_M_data)->_M_falsename; } 
# 1879
void _M_initialize_numpunct(__c_locale __cloc = 0); 
# 1880
}; 
# 1882
template< class _CharT> locale::id 
# 1883
numpunct< _CharT> ::id; 
# 1886
template<> numpunct< char> ::~numpunct(); 
# 1890
template<> void numpunct< char> ::_M_initialize_numpunct(__c_locale __cloc); 
# 1894
template<> numpunct< wchar_t> ::~numpunct(); 
# 1898
template<> void numpunct< wchar_t> ::_M_initialize_numpunct(__c_locale __cloc); 
# 1902
template< class _CharT> 
# 1903
class numpunct_byname : public numpunct< _CharT>  { 
# 1906
public: typedef _CharT char_type; 
# 1907
typedef basic_string< _CharT>  string_type; 
# 1910
explicit numpunct_byname(const char *__s, std::size_t __refs = 0) : numpunct< _CharT> (__refs) 
# 1912
{ 
# 1913
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 1915
{ 
# 1916
std::__c_locale __tmp; 
# 1917
this->_S_create_c_locale(__tmp, __s); 
# 1918
this->_M_initialize_numpunct(__tmp); 
# 1919
this->_S_destroy_c_locale(__tmp); 
# 1920
}  
# 1921
} 
# 1925
explicit numpunct_byname(const std::string &__s, std::size_t __refs = 0) : numpunct_byname(__s.c_str(), __refs) 
# 1926
{ } 
# 1931
protected: virtual ~numpunct_byname() { } 
# 1932
}; 
# 1934
}
# 1951 "/usr/include/c++/9/bits/locale_facets.h" 3
template< class _CharT, class _InIter> 
# 1952
class num_get : public locale::facet { 
# 1958
public: typedef _CharT char_type; 
# 1959
typedef _InIter iter_type; 
# 1963
static locale::id id; 
# 1973 "/usr/include/c++/9/bits/locale_facets.h" 3
explicit num_get(size_t __refs = 0) : locale::facet(__refs) { } 
# 1999 "/usr/include/c++/9/bits/locale_facets.h" 3
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2000
__err, bool &__v) const 
# 2001
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2036 "/usr/include/c++/9/bits/locale_facets.h" 3
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2037
__err, long &__v) const 
# 2038
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2041
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2042
__err, unsigned short &__v) const 
# 2043
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2046
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2047
__err, unsigned &__v) const 
# 2048
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2051
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2052
__err, unsigned long &__v) const 
# 2053
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2057
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2058
__err, long long &__v) const 
# 2059
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2062
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2063
__err, unsigned long long &__v) const 
# 2064
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2096 "/usr/include/c++/9/bits/locale_facets.h" 3
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2097
__err, float &__v) const 
# 2098
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2101
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2102
__err, double &__v) const 
# 2103
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2106
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2107
__err, long double &__v) const 
# 2108
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2139 "/usr/include/c++/9/bits/locale_facets.h" 3
iter_type get(iter_type __in, iter_type __end, ios_base &__io, ios_base::iostate &
# 2140
__err, void *&__v) const 
# 2141
{ return this->do_get(__in, __end, __io, __err, __v); } 
# 2145
protected: virtual ~num_get() { } 
# 2147
__attribute((__abi_tag__("cxx11"))) iter_type 
# 2149
_M_extract_float(iter_type, iter_type, ios_base &, ios_base::iostate &, string &) const; 
# 2152
template< class _ValueT> 
# 2153
__attribute((__abi_tag__("cxx11"))) iter_type 
# 2152
_M_extract_int(iter_type, iter_type, ios_base &, ios_base::iostate &, _ValueT &) const; 
# 2158
template< class _CharT2> typename __gnu_cxx::__enable_if< __is_char< _CharT2> ::__value, int> ::__type 
# 2160
_M_find(const _CharT2 *, size_t __len, _CharT2 __c) const 
# 2161
{ 
# 2162
int __ret = (-1); 
# 2163
if (__len <= (10)) 
# 2164
{ 
# 2165
if ((__c >= ((_CharT2)'0')) && (__c < ((_CharT2)(((_CharT2)'0') + __len)))) { 
# 2166
__ret = (__c - ((_CharT2)'0')); }  
# 2167
} else 
# 2169
{ 
# 2170
if ((__c >= ((_CharT2)'0')) && (__c <= ((_CharT2)'9'))) { 
# 2171
__ret = (__c - ((_CharT2)'0')); } else { 
# 2172
if ((__c >= ((_CharT2)'a')) && (__c <= ((_CharT2)'f'))) { 
# 2173
__ret = (10 + (__c - ((_CharT2)'a'))); } else { 
# 2174
if ((__c >= ((_CharT2)'A')) && (__c <= ((_CharT2)'F'))) { 
# 2175
__ret = (10 + (__c - ((_CharT2)'A'))); }  }  }  
# 2176
}  
# 2177
return __ret; 
# 2178
} 
# 2180
template< class _CharT2> typename __gnu_cxx::__enable_if< !__is_char< _CharT2> ::__value, int> ::__type 
# 2183
_M_find(const _CharT2 *__zero, size_t __len, _CharT2 __c) const 
# 2184
{ 
# 2185
int __ret = (-1); 
# 2186
const char_type *__q = char_traits< _CharT2> ::find(__zero, __len, __c); 
# 2187
if (__q) 
# 2188
{ 
# 2189
__ret = (__q - __zero); 
# 2190
if (__ret > 15) { 
# 2191
__ret -= 6; }  
# 2192
}  
# 2193
return __ret; 
# 2194
} 
# 2212 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, bool &) const; 
# 2215
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2216
__err, long &__v) const 
# 2217
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2220
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2221
__err, unsigned short &__v) const 
# 2222
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2225
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2226
__err, unsigned &__v) const 
# 2227
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2230
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2231
__err, unsigned long &__v) const 
# 2232
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2236
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2237
__err, long long &__v) const 
# 2238
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2241
virtual iter_type do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 2242
__err, unsigned long long &__v) const 
# 2243
{ return _M_extract_int(__beg, __end, __io, __err, __v); } 
# 2247
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, float &) const; 
# 2250
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, double &) const; 
# 2260
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, long double &) const; 
# 2265
virtual iter_type do_get(iter_type, iter_type, ios_base &, ios_base::iostate &, void *&) const; 
# 2274 "/usr/include/c++/9/bits/locale_facets.h" 3
}; 
# 2276
template< class _CharT, class _InIter> locale::id 
# 2277
num_get< _CharT, _InIter> ::id; 
# 2292 "/usr/include/c++/9/bits/locale_facets.h" 3
template< class _CharT, class _OutIter> 
# 2293
class num_put : public locale::facet { 
# 2299
public: typedef _CharT char_type; 
# 2300
typedef _OutIter iter_type; 
# 2304
static locale::id id; 
# 2314 "/usr/include/c++/9/bits/locale_facets.h" 3
explicit num_put(size_t __refs = 0) : locale::facet(__refs) { } 
# 2332 "/usr/include/c++/9/bits/locale_facets.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const 
# 2333
{ return this->do_put(__s, __io, __fill, __v); } 
# 2374 "/usr/include/c++/9/bits/locale_facets.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long __v) const 
# 2375
{ return this->do_put(__s, __io, __fill, __v); } 
# 2378
iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long 
# 2379
__v) const 
# 2380
{ return this->do_put(__s, __io, __fill, __v); } 
# 2384
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long long __v) const 
# 2385
{ return this->do_put(__s, __io, __fill, __v); } 
# 2388
iter_type put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long 
# 2389
__v) const 
# 2390
{ return this->do_put(__s, __io, __fill, __v); } 
# 2437 "/usr/include/c++/9/bits/locale_facets.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, double __v) const 
# 2438
{ return this->do_put(__s, __io, __fill, __v); } 
# 2441
iter_type put(iter_type __s, ios_base &__io, char_type __fill, long double 
# 2442
__v) const 
# 2443
{ return this->do_put(__s, __io, __fill, __v); } 
# 2462 "/usr/include/c++/9/bits/locale_facets.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, const void *
# 2463
__v) const 
# 2464
{ return this->do_put(__s, __io, __fill, __v); } 
# 2467
protected: template< class _ValueT> iter_type _M_insert_float(iter_type, ios_base & __io, char_type __fill, char __mod, _ValueT __v) const; 
# 2473
void _M_group_float(const char * __grouping, size_t __grouping_size, char_type __sep, const char_type * __p, char_type * __new, char_type * __cs, int & __len) const; 
# 2477
template< class _ValueT> iter_type _M_insert_int(iter_type, ios_base & __io, char_type __fill, _ValueT __v) const; 
# 2483
void _M_group_int(const char * __grouping, size_t __grouping_size, char_type __sep, ios_base & __io, char_type * __new, char_type * __cs, int & __len) const; 
# 2488
void _M_pad(char_type __fill, streamsize __w, ios_base & __io, char_type * __new, const char_type * __cs, int & __len) const; 
# 2493
virtual ~num_put() { } 
# 2510 "/usr/include/c++/9/bits/locale_facets.h" 3
virtual iter_type do_put(iter_type __s, ios_base & __io, char_type __fill, bool __v) const; 
# 2513
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long __v) const 
# 2514
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2517
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long 
# 2518
__v) const 
# 2519
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2523
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, long long 
# 2524
__v) const 
# 2525
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2528
virtual iter_type do_put(iter_type __s, ios_base &__io, char_type __fill, unsigned long long 
# 2529
__v) const 
# 2530
{ return _M_insert_int(__s, __io, __fill, __v); } 
# 2534
virtual iter_type do_put(iter_type, ios_base &, char_type, double) const; 
# 2542
virtual iter_type do_put(iter_type, ios_base &, char_type, long double) const; 
# 2546
virtual iter_type do_put(iter_type, ios_base &, char_type, const void *) const; 
# 2554
}; 
# 2556
template< class _CharT, class _OutIter> locale::id 
# 2557
num_put< _CharT, _OutIter> ::id; 
# 2567
template< class _CharT> inline bool 
# 2569
isspace(_CharT __c, const locale &__loc) 
# 2570
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::space, __c); } 
# 2573
template< class _CharT> inline bool 
# 2575
isprint(_CharT __c, const locale &__loc) 
# 2576
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::print, __c); } 
# 2579
template< class _CharT> inline bool 
# 2581
iscntrl(_CharT __c, const locale &__loc) 
# 2582
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::cntrl, __c); } 
# 2585
template< class _CharT> inline bool 
# 2587
isupper(_CharT __c, const locale &__loc) 
# 2588
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::upper, __c); } 
# 2591
template< class _CharT> inline bool 
# 2593
islower(_CharT __c, const locale &__loc) 
# 2594
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::lower, __c); } 
# 2597
template< class _CharT> inline bool 
# 2599
isalpha(_CharT __c, const locale &__loc) 
# 2600
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::alpha, __c); } 
# 2603
template< class _CharT> inline bool 
# 2605
isdigit(_CharT __c, const locale &__loc) 
# 2606
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::digit, __c); } 
# 2609
template< class _CharT> inline bool 
# 2611
ispunct(_CharT __c, const locale &__loc) 
# 2612
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::punct, __c); } 
# 2615
template< class _CharT> inline bool 
# 2617
isxdigit(_CharT __c, const locale &__loc) 
# 2618
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::xdigit, __c); } 
# 2621
template< class _CharT> inline bool 
# 2623
isalnum(_CharT __c, const locale &__loc) 
# 2624
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::alnum, __c); } 
# 2627
template< class _CharT> inline bool 
# 2629
isgraph(_CharT __c, const locale &__loc) 
# 2630
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::graph, __c); } 
# 2634
template< class _CharT> inline bool 
# 2636
isblank(_CharT __c, const locale &__loc) 
# 2637
{ return use_facet< ctype< _CharT> > (__loc).is(ctype_base::blank, __c); } 
# 2641
template< class _CharT> inline _CharT 
# 2643
toupper(_CharT __c, const locale &__loc) 
# 2644
{ return use_facet< ctype< _CharT> > (__loc).toupper(__c); } 
# 2647
template< class _CharT> inline _CharT 
# 2649
tolower(_CharT __c, const locale &__loc) 
# 2650
{ return use_facet< ctype< _CharT> > (__loc).tolower(__c); } 
# 2653
}
# 35 "/usr/include/c++/9/bits/locale_facets.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
template< class _Facet> 
# 42
struct __use_cache { 
# 45
const _Facet *operator()(const locale & __loc) const; 
# 46
}; 
# 49
template< class _CharT> 
# 50
struct __use_cache< __numpunct_cache< _CharT> >  { 
# 53
const __numpunct_cache< _CharT>  *operator()(const locale &__loc) const 
# 54
{ 
# 55
const size_t __i = (numpunct< _CharT> ::id._M_id)(); 
# 56
const locale::facet **__caches = (__loc._M_impl)->_M_caches; 
# 57
if (!(__caches[__i])) 
# 58
{ 
# 59
__numpunct_cache< _CharT>  *__tmp = (0); 
# 60
try 
# 61
{ 
# 62
__tmp = (new __numpunct_cache< _CharT> ); 
# 63
__tmp->_M_cache(__loc); 
# 64
} 
# 65
catch (...) 
# 66
{ 
# 67
delete __tmp; 
# 68
throw; 
# 69
}  
# 70
(__loc._M_impl)->_M_install_cache(__tmp, __i); 
# 71
}  
# 72
return static_cast< const __numpunct_cache< _CharT>  *>(__caches[__i]); 
# 73
} 
# 74
}; 
# 76
template< class _CharT> void 
# 78
__numpunct_cache< _CharT> ::_M_cache(const locale &__loc) 
# 79
{ 
# 80
const __cxx11::numpunct< _CharT>  &__np = use_facet< __cxx11::numpunct< _CharT> > (__loc); 
# 82
char *__grouping = (0); 
# 83
_CharT *__truename = (0); 
# 84
_CharT *__falsename = (0); 
# 85
try 
# 86
{ 
# 87
const string &__g = __np.grouping(); 
# 88
(_M_grouping_size) = __g.size(); 
# 89
__grouping = (new char [_M_grouping_size]); 
# 90
__g.copy(__grouping, _M_grouping_size); 
# 91
(_M_use_grouping) = ((_M_grouping_size) && ((static_cast< signed char>(__grouping[0])) > 0) && ((__grouping[0]) != __gnu_cxx::__numeric_traits_integer< char> ::__max)); 
# 96
const __cxx11::basic_string< _CharT>  &__tn = __np.truename(); 
# 97
(_M_truename_size) = __tn.size(); 
# 98
__truename = (new _CharT [_M_truename_size]); 
# 99
__tn.copy(__truename, _M_truename_size); 
# 101
const __cxx11::basic_string< _CharT>  &__fn = __np.falsename(); 
# 102
(_M_falsename_size) = __fn.size(); 
# 103
__falsename = (new _CharT [_M_falsename_size]); 
# 104
__fn.copy(__falsename, _M_falsename_size); 
# 106
(_M_decimal_point) = __np.decimal_point(); 
# 107
(_M_thousands_sep) = __np.thousands_sep(); 
# 109
const ctype< _CharT>  &__ct = use_facet< ctype< _CharT> > (__loc); 
# 110
__ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out); 
# 113
__ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in); 
# 117
(_M_grouping) = __grouping; 
# 118
(_M_truename) = __truename; 
# 119
(_M_falsename) = __falsename; 
# 120
(_M_allocated) = true; 
# 121
} 
# 122
catch (...) 
# 123
{ 
# 124
delete [] __grouping; 
# 125
delete [] __truename; 
# 126
delete [] __falsename; 
# 127
throw; 
# 128
}  
# 129
} 
# 139 "/usr/include/c++/9/bits/locale_facets.tcc" 3
__attribute((__pure__)) bool 
# 140
__verify_grouping(const char * __grouping, size_t __grouping_size, const string & __grouping_tmp) throw(); 
# 145
template< class _CharT, class _InIter> 
# 146
__attribute((__abi_tag__("cxx11"))) _InIter 
# 149
num_get< _CharT, _InIter> ::_M_extract_float(_InIter __beg, _InIter __end, ios_base &__io, ios_base::iostate &
# 150
__err, string &__xtrc) const 
# 151
{ 
# 152
typedef char_traits< _CharT>  __traits_type; 
# 153
typedef __numpunct_cache< _CharT>  __cache_type; 
# 154
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 155
const locale &__loc = __io._M_getloc(); 
# 156
const __cache_type *__lc = __uc(__loc); 
# 157
const _CharT *__lit = ((__lc->_M_atoms_in)); 
# 158
char_type __c = char_type(); 
# 161
bool __testeof = __beg == __end; 
# 164
if (!__testeof) 
# 165
{ 
# 166
__c = (*__beg); 
# 167
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 168
if ((__plus || (__c == (__lit[__num_base::_S_iminus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) 
# 171
{ 
# 172
(__xtrc += (__plus ? '+' : '-')); 
# 173
if ((++__beg) != __end) { 
# 174
__c = (*__beg); } else { 
# 176
__testeof = true; }  
# 177
}  
# 178
}  
# 181
bool __found_mantissa = false; 
# 182
int __sep_pos = 0; 
# 183
while (!__testeof) 
# 184
{ 
# 185
if (((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) || (__c == (__lc->_M_decimal_point))) { 
# 187
break; } else { 
# 188
if (__c == (__lit[__num_base::_S_izero])) 
# 189
{ 
# 190
if (!__found_mantissa) 
# 191
{ 
# 192
(__xtrc += ('0')); 
# 193
__found_mantissa = true; 
# 194
}  
# 195
++__sep_pos; 
# 197
if ((++__beg) != __end) { 
# 198
__c = (*__beg); } else { 
# 200
__testeof = true; }  
# 201
} else { 
# 203
break; }  }  
# 204
}  
# 207
bool __found_dec = false; 
# 208
bool __found_sci = false; 
# 209
string __found_grouping; 
# 210
if (__lc->_M_use_grouping) { 
# 211
__found_grouping.reserve(32); }  
# 212
const char_type *__lit_zero = __lit + __num_base::_S_izero; 
# 214
if (!(__lc->_M_allocated)) { 
# 216
while (!__testeof) 
# 217
{ 
# 218
const int __digit = _M_find(__lit_zero, 10, __c); 
# 219
if (__digit != (-1)) 
# 220
{ 
# 221
(__xtrc += (('0') + __digit)); 
# 222
__found_mantissa = true; 
# 223
} else { 
# 224
if ((__c == (__lc->_M_decimal_point)) && (!__found_dec) && (!__found_sci)) 
# 226
{ 
# 227
(__xtrc += ('.')); 
# 228
__found_dec = true; 
# 229
} else { 
# 230
if (((__c == (__lit[__num_base::_S_ie])) || (__c == (__lit[__num_base::_S_iE]))) && (!__found_sci) && __found_mantissa) 
# 233
{ 
# 235
(__xtrc += ('e')); 
# 236
__found_sci = true; 
# 239
if ((++__beg) != __end) 
# 240
{ 
# 241
__c = (*__beg); 
# 242
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 243
if (__plus || (__c == (__lit[__num_base::_S_iminus]))) { 
# 244
(__xtrc += (__plus ? '+' : '-')); } else { 
# 246
continue; }  
# 247
} else 
# 249
{ 
# 250
__testeof = true; 
# 251
break; 
# 252
}  
# 253
} else { 
# 255
break; }  }  }  
# 257
if ((++__beg) != __end) { 
# 258
__c = (*__beg); } else { 
# 260
__testeof = true; }  
# 261
}   } else { 
# 263
while (!__testeof) 
# 264
{ 
# 267
if ((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) 
# 268
{ 
# 269
if ((!__found_dec) && (!__found_sci)) 
# 270
{ 
# 273
if (__sep_pos) 
# 274
{ 
# 275
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 276
__sep_pos = 0; 
# 277
} else 
# 279
{ 
# 282
__xtrc.clear(); 
# 283
break; 
# 284
}  
# 285
} else { 
# 287
break; }  
# 288
} else { 
# 289
if (__c == (__lc->_M_decimal_point)) 
# 290
{ 
# 291
if ((!__found_dec) && (!__found_sci)) 
# 292
{ 
# 296
if (__found_grouping.size()) { 
# 297
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 298
(__xtrc += ('.')); 
# 299
__found_dec = true; 
# 300
} else { 
# 302
break; }  
# 303
} else 
# 305
{ 
# 306
const char_type *__q = __traits_type::find(__lit_zero, 10, __c); 
# 308
if (__q) 
# 309
{ 
# 310
__xtrc += ('0' + (__q - __lit_zero)); 
# 311
__found_mantissa = true; 
# 312
++__sep_pos; 
# 313
} else { 
# 314
if (((__c == (__lit[__num_base::_S_ie])) || (__c == (__lit[__num_base::_S_iE]))) && (!__found_sci) && __found_mantissa) 
# 317
{ 
# 319
if ((__found_grouping.size()) && (!__found_dec)) { 
# 320
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 321
(__xtrc += ('e')); 
# 322
__found_sci = true; 
# 325
if ((++__beg) != __end) 
# 326
{ 
# 327
__c = (*__beg); 
# 328
const bool __plus = __c == (__lit[__num_base::_S_iplus]); 
# 329
if ((__plus || (__c == (__lit[__num_base::_S_iminus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) { 
# 333
(__xtrc += (__plus ? '+' : '-')); } else { 
# 335
continue; }  
# 336
} else 
# 338
{ 
# 339
__testeof = true; 
# 340
break; 
# 341
}  
# 342
} else { 
# 344
break; }  }  
# 345
}  }  
# 347
if ((++__beg) != __end) { 
# 348
__c = (*__beg); } else { 
# 350
__testeof = true; }  
# 351
}   }  
# 355
if (__found_grouping.size()) 
# 356
{ 
# 358
if ((!__found_dec) && (!__found_sci)) { 
# 359
(__found_grouping += (static_cast< char>(__sep_pos))); }  
# 361
if (!std::__verify_grouping((__lc->_M_grouping), (__lc->_M_grouping_size), __found_grouping)) { 
# 364
__err = ios_base::failbit; }  
# 365
}  
# 367
return __beg; 
# 368
} 
# 370
template< class _CharT, class _InIter> 
# 371
template< class _ValueT> 
# 372
__attribute((__abi_tag__("cxx11"))) _InIter 
# 375
num_get< _CharT, _InIter> ::_M_extract_int(_InIter __beg, _InIter __end, ios_base &__io, ios_base::iostate &
# 376
__err, _ValueT &__v) const 
# 377
{ 
# 378
typedef char_traits< _CharT>  __traits_type; 
# 379
using __gnu_cxx::__add_unsigned;
# 380
typedef typename __gnu_cxx::__add_unsigned< _ValueT> ::__type __unsigned_type; 
# 381
typedef __numpunct_cache< _CharT>  __cache_type; 
# 382
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 383
const locale &__loc = __io._M_getloc(); 
# 384
const __cache_type *__lc = __uc(__loc); 
# 385
const _CharT *__lit = ((__lc->_M_atoms_in)); 
# 386
char_type __c = char_type(); 
# 389
const ios_base::fmtflags __basefield = ((__io.flags()) & ios_base::basefield); 
# 391
const bool __oct = __basefield == ios_base::oct; 
# 392
int __base = __oct ? 8 : ((__basefield == ios_base::hex) ? 16 : 10); 
# 395
bool __testeof = __beg == __end; 
# 398
bool __negative = false; 
# 399
if (!__testeof) 
# 400
{ 
# 401
__c = (*__beg); 
# 402
__negative = (__c == (__lit[__num_base::_S_iminus])); 
# 403
if ((__negative || (__c == (__lit[__num_base::_S_iplus]))) && (!((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)))) && (!(__c == (__lc->_M_decimal_point)))) 
# 406
{ 
# 407
if ((++__beg) != __end) { 
# 408
__c = (*__beg); } else { 
# 410
__testeof = true; }  
# 411
}  
# 412
}  
# 416
bool __found_zero = false; 
# 417
int __sep_pos = 0; 
# 418
while (!__testeof) 
# 419
{ 
# 420
if (((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) || (__c == (__lc->_M_decimal_point))) { 
# 422
break; } else { 
# 423
if ((__c == (__lit[__num_base::_S_izero])) && ((!__found_zero) || (__base == 10))) 
# 425
{ 
# 426
__found_zero = true; 
# 427
++__sep_pos; 
# 428
if (__basefield == 0) { 
# 429
__base = 8; }  
# 430
if (__base == 8) { 
# 431
__sep_pos = 0; }  
# 432
} else { 
# 433
if (__found_zero && ((__c == (__lit[__num_base::_S_ix])) || (__c == (__lit[__num_base::_S_iX])))) 
# 436
{ 
# 437
if (__basefield == 0) { 
# 438
__base = 16; }  
# 439
if (__base == 16) 
# 440
{ 
# 441
__found_zero = false; 
# 442
__sep_pos = 0; 
# 443
} else { 
# 445
break; }  
# 446
} else { 
# 448
break; }  }  }  
# 450
if ((++__beg) != __end) 
# 451
{ 
# 452
__c = (*__beg); 
# 453
if (!__found_zero) { 
# 454
break; }  
# 455
} else { 
# 457
__testeof = true; }  
# 458
}  
# 462
const size_t __len = (__base == 16) ? (__num_base::_S_iend) - (__num_base::_S_izero) : __base; 
# 466
typedef __gnu_cxx::__numeric_traits< _ValueT>  __num_traits; 
# 467
string __found_grouping; 
# 468
if (__lc->_M_use_grouping) { 
# 469
__found_grouping.reserve(32); }  
# 470
bool __testfail = false; 
# 471
bool __testoverflow = false; 
# 472
const __unsigned_type __max = (__negative && __num_traits::__is_signed) ? -(static_cast< __unsigned_type>(__num_traits::__min)) : __num_traits::__max; 
# 476
const __unsigned_type __smax = __max / __base; 
# 477
__unsigned_type __result = (0); 
# 478
int __digit = 0; 
# 479
const char_type *__lit_zero = __lit + __num_base::_S_izero; 
# 481
if (!(__lc->_M_allocated)) { 
# 483
while (!__testeof) 
# 484
{ 
# 485
__digit = _M_find(__lit_zero, __len, __c); 
# 486
if (__digit == (-1)) { 
# 487
break; }  
# 489
if (__result > __smax) { 
# 490
__testoverflow = true; } else 
# 492
{ 
# 493
__result *= __base; 
# 494
__testoverflow |= (__result > (__max - __digit)); 
# 495
__result += __digit; 
# 496
++__sep_pos; 
# 497
}  
# 499
if ((++__beg) != __end) { 
# 500
__c = (*__beg); } else { 
# 502
__testeof = true; }  
# 503
}  } else { 
# 505
while (!__testeof) 
# 506
{ 
# 509
if ((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep))) 
# 510
{ 
# 513
if (__sep_pos) 
# 514
{ 
# 515
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 516
__sep_pos = 0; 
# 517
} else 
# 519
{ 
# 520
__testfail = true; 
# 521
break; 
# 522
}  
# 523
} else { 
# 524
if (__c == (__lc->_M_decimal_point)) { 
# 525
break; } else 
# 527
{ 
# 528
const char_type *__q = __traits_type::find(__lit_zero, __len, __c); 
# 530
if (!__q) { 
# 531
break; }  
# 533
__digit = (__q - __lit_zero); 
# 534
if (__digit > 15) { 
# 535
__digit -= 6; }  
# 536
if (__result > __smax) { 
# 537
__testoverflow = true; } else 
# 539
{ 
# 540
__result *= __base; 
# 541
__testoverflow |= (__result > (__max - __digit)); 
# 542
__result += __digit; 
# 543
++__sep_pos; 
# 544
}  
# 545
}  }  
# 547
if ((++__beg) != __end) { 
# 548
__c = (*__beg); } else { 
# 550
__testeof = true; }  
# 551
}  }  
# 555
if (__found_grouping.size()) 
# 556
{ 
# 558
(__found_grouping += (static_cast< char>(__sep_pos))); 
# 560
if (!std::__verify_grouping((__lc->_M_grouping), (__lc->_M_grouping_size), __found_grouping)) { 
# 563
__err = ios_base::failbit; }  
# 564
}  
# 568
if (((!__sep_pos) && (!__found_zero) && (!(__found_grouping.size()))) || __testfail) 
# 570
{ 
# 571
__v = 0; 
# 572
__err = ios_base::failbit; 
# 573
} else { 
# 574
if (__testoverflow) 
# 575
{ 
# 576
if (__negative && __num_traits::__is_signed) { 
# 577
__v = __num_traits::__min; } else { 
# 579
__v = __num_traits::__max; }  
# 580
__err = ios_base::failbit; 
# 581
} else { 
# 583
__v = (__negative ? -__result : __result); }  }  
# 585
if (__testeof) { 
# 586
(__err |= ios_base::eofbit); }  
# 587
return __beg; 
# 588
} 
# 592
template< class _CharT, class _InIter> _InIter 
# 595
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 596
__err, bool &__v) const 
# 597
{ 
# 598
if (!(((__io.flags()) & ios_base::boolalpha))) 
# 599
{ 
# 603
long __l = (-1); 
# 604
__beg = _M_extract_int(__beg, __end, __io, __err, __l); 
# 605
if ((__l == (0)) || (__l == (1))) { 
# 606
__v = ((bool)__l); } else 
# 608
{ 
# 611
__v = true; 
# 612
__err = ios_base::failbit; 
# 613
if (__beg == __end) { 
# 614
(__err |= ios_base::eofbit); }  
# 615
}  
# 616
} else 
# 618
{ 
# 620
typedef __numpunct_cache< _CharT>  __cache_type; 
# 621
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 622
const locale &__loc = __io._M_getloc(); 
# 623
const __cache_type *__lc = __uc(__loc); 
# 625
bool __testf = true; 
# 626
bool __testt = true; 
# 627
bool __donef = (__lc->_M_falsename_size) == 0; 
# 628
bool __donet = (__lc->_M_truename_size) == 0; 
# 629
bool __testeof = false; 
# 630
size_t __n = (0); 
# 631
while ((!__donef) || (!__donet)) 
# 632
{ 
# 633
if (__beg == __end) 
# 634
{ 
# 635
__testeof = true; 
# 636
break; 
# 637
}  
# 639
const char_type __c = (*__beg); 
# 641
if (!__donef) { 
# 642
__testf = (__c == ((__lc->_M_falsename)[__n])); }  
# 644
if ((!__testf) && __donet) { 
# 645
break; }  
# 647
if (!__donet) { 
# 648
__testt = (__c == ((__lc->_M_truename)[__n])); }  
# 650
if ((!__testt) && __donef) { 
# 651
break; }  
# 653
if ((!__testt) && (!__testf)) { 
# 654
break; }  
# 656
++__n; 
# 657
++__beg; 
# 659
__donef = ((!__testf) || (__n >= (__lc->_M_falsename_size))); 
# 660
__donet = ((!__testt) || (__n >= (__lc->_M_truename_size))); 
# 661
}  
# 662
if (__testf && (__n == (__lc->_M_falsename_size)) && __n) 
# 663
{ 
# 664
__v = false; 
# 665
if (__testt && (__n == (__lc->_M_truename_size))) { 
# 666
__err = ios_base::failbit; } else { 
# 668
__err = (__testeof ? ios_base::eofbit : ios_base::goodbit); }  
# 669
} else { 
# 670
if (__testt && (__n == (__lc->_M_truename_size)) && __n) 
# 671
{ 
# 672
__v = true; 
# 673
__err = (__testeof ? ios_base::eofbit : ios_base::goodbit); 
# 674
} else 
# 676
{ 
# 679
__v = false; 
# 680
__err = ios_base::failbit; 
# 681
if (__testeof) { 
# 682
(__err |= ios_base::eofbit); }  
# 683
}  }  
# 684
}  
# 685
return __beg; 
# 686
} 
# 688
template< class _CharT, class _InIter> _InIter 
# 691
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 692
__err, float &__v) const 
# 693
{ 
# 694
string __xtrc; 
# 695
__xtrc.reserve(32); 
# 696
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 697
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 698
if (__beg == __end) { 
# 699
(__err |= ios_base::eofbit); }  
# 700
return __beg; 
# 701
} 
# 703
template< class _CharT, class _InIter> _InIter 
# 706
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 707
__err, double &__v) const 
# 708
{ 
# 709
string __xtrc; 
# 710
__xtrc.reserve(32); 
# 711
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 712
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 713
if (__beg == __end) { 
# 714
(__err |= ios_base::eofbit); }  
# 715
return __beg; 
# 716
} 
# 735 "/usr/include/c++/9/bits/locale_facets.tcc" 3
template< class _CharT, class _InIter> _InIter 
# 738
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 739
__err, long double &__v) const 
# 740
{ 
# 741
string __xtrc; 
# 742
__xtrc.reserve(32); 
# 743
__beg = _M_extract_float(__beg, __end, __io, __err, __xtrc); 
# 744
std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale()); 
# 745
if (__beg == __end) { 
# 746
(__err |= ios_base::eofbit); }  
# 747
return __beg; 
# 748
} 
# 750
template< class _CharT, class _InIter> _InIter 
# 753
num_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 754
__err, void *&__v) const 
# 755
{ 
# 757
typedef ios_base::fmtflags fmtflags; 
# 758
const fmtflags __fmt = __io.flags(); 
# 759
__io.flags((((__fmt & ((~ios_base::basefield)))) | ios_base::hex)); 
# 763
typedef __gnu_cxx::__conditional_type< sizeof(void *) <= sizeof(unsigned long), unsigned long, unsigned long long> ::__type _UIntPtrType; 
# 765
_UIntPtrType __ul; 
# 766
__beg = _M_extract_int(__beg, __end, __io, __err, __ul); 
# 769
__io.flags(__fmt); 
# 771
__v = (reinterpret_cast< void *>(__ul)); 
# 772
return __beg; 
# 773
} 
# 777
template< class _CharT, class _OutIter> void 
# 780
num_put< _CharT, _OutIter> ::_M_pad(_CharT __fill, streamsize __w, ios_base &__io, _CharT *
# 781
__new, const _CharT *__cs, int &__len) const 
# 782
{ 
# 785
__pad< _CharT, char_traits< _CharT> > ::_S_pad(__io, __fill, __new, __cs, __w, __len); 
# 787
__len = (static_cast< int>(__w)); 
# 788
} 
# 792
template< class _CharT, class _ValueT> int 
# 794
__int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags 
# 795
__flags, bool __dec) 
# 796
{ 
# 797
_CharT *__buf = __bufend; 
# 798
if (__builtin_expect(__dec, true)) 
# 799
{ 
# 801
do 
# 802
{ 
# 803
(*(--__buf)) = (__lit[(__v % 10) + __num_base::_S_odigits]); 
# 804
__v /= 10; 
# 805
} 
# 806
while (__v != 0); 
# 807
} else { 
# 808
if (((__flags & ios_base::basefield)) == ios_base::oct) 
# 809
{ 
# 811
do 
# 812
{ 
# 813
(*(--__buf)) = (__lit[(__v & 7) + __num_base::_S_odigits]); 
# 814
__v >>= 3; 
# 815
} 
# 816
while (__v != 0); 
# 817
} else 
# 819
{ 
# 821
const bool __uppercase = (__flags & ios_base::uppercase); 
# 822
const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits; 
# 824
do 
# 825
{ 
# 826
(*(--__buf)) = (__lit[(__v & 15) + __case_offset]); 
# 827
__v >>= 4; 
# 828
} 
# 829
while (__v != 0); 
# 830
}  }  
# 831
return __bufend - __buf; 
# 832
} 
# 836
template< class _CharT, class _OutIter> void 
# 839
num_put< _CharT, _OutIter> ::_M_group_int(const char *__grouping, size_t __grouping_size, _CharT __sep, ios_base &, _CharT *
# 840
__new, _CharT *__cs, int &__len) const 
# 841
{ 
# 842
_CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len); 
# 844
__len = (__p - __new); 
# 845
} 
# 847
template< class _CharT, class _OutIter> 
# 848
template< class _ValueT> _OutIter 
# 851
num_put< _CharT, _OutIter> ::_M_insert_int(_OutIter __s, ios_base &__io, _CharT __fill, _ValueT 
# 852
__v) const 
# 853
{ 
# 854
using __gnu_cxx::__add_unsigned;
# 855
typedef typename __gnu_cxx::__add_unsigned< _ValueT> ::__type __unsigned_type; 
# 856
typedef __numpunct_cache< _CharT>  __cache_type; 
# 857
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 858
const locale &__loc = __io._M_getloc(); 
# 859
const __cache_type *__lc = __uc(__loc); 
# 860
const _CharT *__lit = ((__lc->_M_atoms_out)); 
# 861
const ios_base::fmtflags __flags = __io.flags(); 
# 864
const int __ilen = ((5) * sizeof(_ValueT)); 
# 865
_CharT *__cs = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen)); 
# 870
const ios_base::fmtflags __basefield = (__flags & ios_base::basefield); 
# 871
const bool __dec = (__basefield != ios_base::oct) && (__basefield != ios_base::hex); 
# 873
const __unsigned_type __u = ((__v > 0) || (!__dec)) ? (__unsigned_type)__v : (-((__unsigned_type)__v)); 
# 876
int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec); 
# 877
__cs += (__ilen - __len); 
# 880
if (__lc->_M_use_grouping) 
# 881
{ 
# 884
_CharT *__cs2 = static_cast< _CharT *>(__builtin_alloca((sizeof(_CharT) * (__len + 1)) * (2))); 
# 887
_M_group_int((__lc->_M_grouping), (__lc->_M_grouping_size), (__lc->_M_thousands_sep), __io, __cs2 + 2, __cs, __len); 
# 889
__cs = (__cs2 + 2); 
# 890
}  
# 893
if (__builtin_expect(__dec, true)) 
# 894
{ 
# 896
if (__v >= 0) 
# 897
{ 
# 898
if (((bool)(__flags & ios_base::showpos)) && __gnu_cxx::template __numeric_traits< _ValueT> ::__is_signed) { 
# 900
((*(--__cs)) = (__lit[__num_base::_S_oplus])), (++__len); }  
# 901
} else { 
# 903
((*(--__cs)) = (__lit[__num_base::_S_ominus])), (++__len); }  
# 904
} else { 
# 905
if (((bool)(__flags & ios_base::showbase)) && __v) 
# 906
{ 
# 907
if (__basefield == ios_base::oct) { 
# 908
((*(--__cs)) = (__lit[__num_base::_S_odigits])), (++__len); } else 
# 910
{ 
# 912
const bool __uppercase = (__flags & ios_base::uppercase); 
# 913
(*(--__cs)) = (__lit[(__num_base::_S_ox) + __uppercase]); 
# 915
(*(--__cs)) = (__lit[__num_base::_S_odigits]); 
# 916
__len += 2; 
# 917
}  
# 918
}  }  
# 921
const streamsize __w = __io.width(); 
# 922
if (__w > (static_cast< streamsize>(__len))) 
# 923
{ 
# 924
_CharT *__cs3 = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __w)); 
# 926
_M_pad(__fill, __w, __io, __cs3, __cs, __len); 
# 927
__cs = __cs3; 
# 928
}  
# 929
__io.width(0); 
# 933
return std::__write(__s, __cs, __len); 
# 934
} 
# 936
template< class _CharT, class _OutIter> void 
# 939
num_put< _CharT, _OutIter> ::_M_group_float(const char *__grouping, size_t __grouping_size, _CharT 
# 940
__sep, const _CharT *__p, _CharT *__new, _CharT *
# 941
__cs, int &__len) const 
# 942
{ 
# 946
const int __declen = (__p) ? __p - __cs : __len; 
# 947
_CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen); 
# 952
int __newlen = __p2 - __new; 
# 953
if (__p) 
# 954
{ 
# 955
char_traits< _CharT> ::copy(__p2, __p, __len - __declen); 
# 956
__newlen += (__len - __declen); 
# 957
}  
# 958
__len = __newlen; 
# 959
} 
# 971 "/usr/include/c++/9/bits/locale_facets.tcc" 3
template< class _CharT, class _OutIter> 
# 972
template< class _ValueT> _OutIter 
# 975
num_put< _CharT, _OutIter> ::_M_insert_float(_OutIter __s, ios_base &__io, _CharT __fill, char __mod, _ValueT 
# 976
__v) const 
# 977
{ 
# 978
typedef __numpunct_cache< _CharT>  __cache_type; 
# 979
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 980
const locale &__loc = __io._M_getloc(); 
# 981
const __cache_type *__lc = __uc(__loc); 
# 984
const streamsize __prec = (__io.precision() < (0)) ? 6 : __io.precision(); 
# 986
const int __max_digits = (__gnu_cxx::template __numeric_traits< _ValueT> ::__digits10); 
# 990
int __len; 
# 992
char __fbuf[16]; 
# 993
__num_base::_S_format_float(__io, __fbuf, __mod); 
# 997
const bool __use_prec = (((__io.flags()) & ios_base::floatfield)) != ios_base::floatfield; 
# 1002
int __cs_size = (__max_digits * 3); 
# 1003
char *__cs = static_cast< char *>(__builtin_alloca(__cs_size)); 
# 1004
if (__use_prec) { 
# 1005
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v); } else { 
# 1008
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v); }  
# 1012
if (__len >= __cs_size) 
# 1013
{ 
# 1014
__cs_size = (__len + 1); 
# 1015
__cs = (static_cast< char *>(__builtin_alloca(__cs_size))); 
# 1016
if (__use_prec) { 
# 1017
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v); } else { 
# 1020
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v); }  
# 1022
}  
# 1044 "/usr/include/c++/9/bits/locale_facets.tcc" 3
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1046
_CharT *__ws = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __len)); 
# 1048
__ctype.widen(__cs, __cs + __len, __ws); 
# 1051
_CharT *__wp = (0); 
# 1052
const char *__p = char_traits< char> ::find(__cs, __len, '.'); 
# 1053
if (__p) 
# 1054
{ 
# 1055
__wp = (__ws + (__p - __cs)); 
# 1056
(*__wp) = (__lc->_M_decimal_point); 
# 1057
}  
# 1062
if ((__lc->_M_use_grouping) && ((__wp || (__len < 3)) || (((__cs[1]) <= ('9')) && ((__cs[2]) <= ('9')) && ((__cs[1]) >= ('0')) && ((__cs[2]) >= ('0'))))) 
# 1065
{ 
# 1068
_CharT *__ws2 = static_cast< _CharT *>(__builtin_alloca((sizeof(_CharT) * __len) * (2))); 
# 1071
streamsize __off = (0); 
# 1072
if (((__cs[0]) == ('-')) || ((__cs[0]) == ('+'))) 
# 1073
{ 
# 1074
__off = (1); 
# 1075
(__ws2[0]) = (__ws[0]); 
# 1076
__len -= 1; 
# 1077
}  
# 1079
_M_group_float((__lc->_M_grouping), (__lc->_M_grouping_size), (__lc->_M_thousands_sep), __wp, __ws2 + __off, __ws + __off, __len); 
# 1082
__len += __off; 
# 1084
__ws = __ws2; 
# 1085
}  
# 1088
const streamsize __w = __io.width(); 
# 1089
if (__w > (static_cast< streamsize>(__len))) 
# 1090
{ 
# 1091
_CharT *__ws3 = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __w)); 
# 1093
_M_pad(__fill, __w, __io, __ws3, __ws, __len); 
# 1094
__ws = __ws3; 
# 1095
}  
# 1096
__io.width(0); 
# 1100
return std::__write(__s, __ws, __len); 
# 1101
} 
# 1103
template< class _CharT, class _OutIter> _OutIter 
# 1106
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, bool __v) const 
# 1107
{ 
# 1108
const ios_base::fmtflags __flags = __io.flags(); 
# 1109
if (((__flags & ios_base::boolalpha)) == 0) 
# 1110
{ 
# 1111
const long __l = __v; 
# 1112
__s = _M_insert_int(__s, __io, __fill, __l); 
# 1113
} else 
# 1115
{ 
# 1116
typedef __numpunct_cache< _CharT>  __cache_type; 
# 1117
__use_cache< __numpunct_cache< _CharT> >  __uc; 
# 1118
const locale &__loc = __io._M_getloc(); 
# 1119
const __cache_type *__lc = __uc(__loc); 
# 1121
const _CharT *__name = __v ? __lc->_M_truename : (__lc->_M_falsename); 
# 1123
int __len = __v ? __lc->_M_truename_size : (__lc->_M_falsename_size); 
# 1126
const streamsize __w = __io.width(); 
# 1127
if (__w > (static_cast< streamsize>(__len))) 
# 1128
{ 
# 1129
const streamsize __plen = __w - __len; 
# 1130
_CharT *__ps = static_cast< _CharT *>(__builtin_alloca(sizeof(_CharT) * __plen)); 
# 1134
char_traits< _CharT> ::assign(__ps, __plen, __fill); 
# 1135
__io.width(0); 
# 1137
if (((__flags & ios_base::adjustfield)) == ios_base::left) 
# 1138
{ 
# 1139
__s = std::__write(__s, __name, __len); 
# 1140
__s = std::__write(__s, __ps, __plen); 
# 1141
} else 
# 1143
{ 
# 1144
__s = std::__write(__s, __ps, __plen); 
# 1145
__s = std::__write(__s, __name, __len); 
# 1146
}  
# 1147
return __s; 
# 1148
}  
# 1149
__io.width(0); 
# 1150
__s = std::__write(__s, __name, __len); 
# 1151
}  
# 1152
return __s; 
# 1153
} 
# 1155
template< class _CharT, class _OutIter> _OutIter 
# 1158
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, double __v) const 
# 1159
{ return _M_insert_float(__s, __io, __fill, ((char)0), __v); } 
# 1169 "/usr/include/c++/9/bits/locale_facets.tcc" 3
template< class _CharT, class _OutIter> _OutIter 
# 1172
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, long double 
# 1173
__v) const 
# 1174
{ return _M_insert_float(__s, __io, __fill, 'L', __v); } 
# 1176
template< class _CharT, class _OutIter> _OutIter 
# 1179
num_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type __fill, const void *
# 1180
__v) const 
# 1181
{ 
# 1182
const ios_base::fmtflags __flags = __io.flags(); 
# 1183
const ios_base::fmtflags __fmt = (~((ios_base::basefield | ios_base::uppercase))); 
# 1185
__io.flags((((__flags & __fmt)) | ((ios_base::hex | ios_base::showbase)))); 
# 1189
typedef __gnu_cxx::__conditional_type< sizeof(void *) <= sizeof(unsigned long), unsigned long, unsigned long long> ::__type _UIntPtrType; 
# 1191
__s = _M_insert_int(__s, __io, __fill, reinterpret_cast< _UIntPtrType>(__v)); 
# 1193
__io.flags(__flags); 
# 1194
return __s; 
# 1195
} 
# 1206 "/usr/include/c++/9/bits/locale_facets.tcc" 3
template< class _CharT, class _Traits> void 
# 1208
__pad< _CharT, _Traits> ::_S_pad(ios_base &__io, _CharT __fill, _CharT *
# 1209
__news, const _CharT *__olds, streamsize 
# 1210
__newlen, streamsize __oldlen) 
# 1211
{ 
# 1212
const size_t __plen = static_cast< size_t>(__newlen - __oldlen); 
# 1213
const ios_base::fmtflags __adjust = ((__io.flags()) & ios_base::adjustfield); 
# 1216
if (__adjust == ios_base::left) 
# 1217
{ 
# 1218
_Traits::copy(__news, __olds, __oldlen); 
# 1219
_Traits::assign(__news + __oldlen, __plen, __fill); 
# 1220
return; 
# 1221
}  
# 1223
size_t __mod = (0); 
# 1224
if (__adjust == ios_base::internal) 
# 1225
{ 
# 1229
const locale &__loc = __io._M_getloc(); 
# 1230
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1232
if ((__ctype.widen('-') == (__olds[0])) || (__ctype.widen('+') == (__olds[0]))) 
# 1234
{ 
# 1235
(__news[0]) = (__olds[0]); 
# 1236
__mod = (1); 
# 1237
++__news; 
# 1238
} else { 
# 1239
if ((__ctype.widen('0') == (__olds[0])) && (__oldlen > (1)) && ((__ctype.widen('x') == (__olds[1])) || (__ctype.widen('X') == (__olds[1])))) 
# 1243
{ 
# 1244
(__news[0]) = (__olds[0]); 
# 1245
(__news[1]) = (__olds[1]); 
# 1246
__mod = (2); 
# 1247
__news += 2; 
# 1248
}  }  
# 1250
}  
# 1251
_Traits::assign(__news, __plen, __fill); 
# 1252
_Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod); 
# 1253
} 
# 1255
template< class _CharT> _CharT *
# 1257
__add_grouping(_CharT *__s, _CharT __sep, const char *
# 1258
__gbeg, size_t __gsize, const _CharT *
# 1259
__first, const _CharT *__last) 
# 1260
{ 
# 1261
size_t __idx = (0); 
# 1262
size_t __ctr = (0); 
# 1264
while (((__last - __first) > (__gbeg[__idx])) && ((static_cast< signed char>(__gbeg[__idx])) > 0) && ((__gbeg[__idx]) != __gnu_cxx::__numeric_traits_integer< char> ::__max)) 
# 1267
{ 
# 1268
__last -= (__gbeg[__idx]); 
# 1269
(__idx < (__gsize - (1))) ? ++__idx : (++__ctr); 
# 1270
}  
# 1272
while (__first != __last) { 
# 1273
(*(__s++)) = (*(__first++)); }  
# 1275
while (__ctr--) 
# 1276
{ 
# 1277
(*(__s++)) = __sep; 
# 1278
for (char __i = __gbeg[__idx]; __i > 0; --__i) { 
# 1279
(*(__s++)) = (*(__first++)); }  
# 1280
}  
# 1282
while (__idx--) 
# 1283
{ 
# 1284
(*(__s++)) = __sep; 
# 1285
for (char __i = __gbeg[__idx]; __i > 0; --__i) { 
# 1286
(*(__s++)) = (*(__first++)); }  
# 1287
}  
# 1289
return __s; 
# 1290
} 
# 1295
extern template class __cxx11::numpunct< char> ;
# 1296
extern template class __cxx11::numpunct_byname< char> ;
# 1297
extern template class num_get< char> ;
# 1298
extern template class num_put< char> ;
# 1301
extern template const ctype< char>  &use_facet< ctype< char> > (const locale &);
# 1305
extern template const __cxx11::numpunct< char>  &use_facet< __cxx11::numpunct< char> > (const locale &);
# 1309
extern template const num_put< char>  &use_facet< num_put< char> > (const locale &);
# 1313
extern template const num_get< char>  &use_facet< num_get< char> > (const locale &);
# 1317
extern template bool has_facet< ctype< char> > (const locale &) throw();
# 1321
extern template bool has_facet< __cxx11::numpunct< char> > (const locale &) throw();
# 1325
extern template bool has_facet< num_put< char> > (const locale &) throw();
# 1329
extern template bool has_facet< num_get< char> > (const locale &) throw();
# 1334
extern template class __cxx11::numpunct< wchar_t> ;
# 1335
extern template class __cxx11::numpunct_byname< wchar_t> ;
# 1336
extern template class num_get< wchar_t> ;
# 1337
extern template class num_put< wchar_t> ;
# 1340
extern template const ctype< wchar_t>  &use_facet< ctype< wchar_t> > (const locale &);
# 1344
extern template const __cxx11::numpunct< wchar_t>  &use_facet< __cxx11::numpunct< wchar_t> > (const locale &);
# 1348
extern template const num_put< wchar_t>  &use_facet< num_put< wchar_t> > (const locale &);
# 1352
extern template const num_get< wchar_t>  &use_facet< num_get< wchar_t> > (const locale &);
# 1356
extern template bool has_facet< ctype< wchar_t> > (const locale &) throw();
# 1360
extern template bool has_facet< __cxx11::numpunct< wchar_t> > (const locale &) throw();
# 1364
extern template bool has_facet< num_put< wchar_t> > (const locale &) throw();
# 1368
extern template bool has_facet< num_get< wchar_t> > (const locale &) throw();
# 1375
}
# 41 "/usr/include/c++/9/bits/basic_ios.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _Facet> inline const _Facet &
# 47
__check_facet(const _Facet *__f) 
# 48
{ 
# 49
if (!__f) { 
# 50
__throw_bad_cast(); }  
# 51
return *__f; 
# 52
} 
# 66 "/usr/include/c++/9/bits/basic_ios.h" 3
template< class _CharT, class _Traits> 
# 67
class basic_ios : public ios_base { 
# 76
public: typedef _CharT char_type; 
# 77
typedef typename _Traits::int_type int_type; 
# 78
typedef typename _Traits::pos_type pos_type; 
# 79
typedef typename _Traits::off_type off_type; 
# 80
typedef _Traits traits_type; 
# 87
typedef ctype< _CharT>  __ctype_type; 
# 89
typedef num_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  __num_put_type; 
# 91
typedef num_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  __num_get_type; 
# 96
protected: basic_ostream< _CharT, _Traits>  *_M_tie; 
# 97
mutable char_type _M_fill; 
# 98
mutable bool _M_fill_init; 
# 99
basic_streambuf< _CharT, _Traits>  *_M_streambuf; 
# 102
const __ctype_type *_M_ctype; 
# 104
const __num_put_type *_M_num_put; 
# 106
const __num_get_type *_M_num_get; 
# 117 "/usr/include/c++/9/bits/basic_ios.h" 3
public: explicit operator bool() const 
# 118
{ return !fail(); } 
# 125
bool operator!() const 
# 126
{ return fail(); } 
# 137 "/usr/include/c++/9/bits/basic_ios.h" 3
iostate rdstate() const 
# 138
{ return _M_streambuf_state; } 
# 148 "/usr/include/c++/9/bits/basic_ios.h" 3
void clear(iostate __state = goodbit); 
# 157
void setstate(iostate __state) 
# 158
{ clear(((rdstate()) | __state)); } 
# 164
void _M_setstate(iostate __state) 
# 165
{ 
# 168
((_M_streambuf_state) |= __state); 
# 169
if (((exceptions()) & __state)) { 
# 170
throw; }  
# 171
} 
# 180
bool good() const 
# 181
{ return (rdstate()) == 0; } 
# 190
bool eof() const 
# 191
{ return (((rdstate()) & eofbit)) != 0; } 
# 201 "/usr/include/c++/9/bits/basic_ios.h" 3
bool fail() const 
# 202
{ return (((rdstate()) & ((badbit | failbit)))) != 0; } 
# 211
bool bad() const 
# 212
{ return (((rdstate()) & badbit)) != 0; } 
# 222 "/usr/include/c++/9/bits/basic_ios.h" 3
iostate exceptions() const 
# 223
{ return _M_exception; } 
# 257 "/usr/include/c++/9/bits/basic_ios.h" 3
void exceptions(iostate __except) 
# 258
{ 
# 259
(_M_exception) = __except; 
# 260
clear(_M_streambuf_state); 
# 261
} 
# 270
explicit basic_ios(basic_streambuf< _CharT, _Traits>  *__sb) : ios_base(), _M_tie((0)), _M_fill(), _M_fill_init(false), _M_streambuf((0)), _M_ctype((0)), _M_num_put((0)), _M_num_get((0)) 
# 273
{ init(__sb); } 
# 282
virtual ~basic_ios() { } 
# 295 "/usr/include/c++/9/bits/basic_ios.h" 3
basic_ostream< _CharT, _Traits>  *tie() const 
# 296
{ return _M_tie; } 
# 307 "/usr/include/c++/9/bits/basic_ios.h" 3
basic_ostream< _CharT, _Traits>  *tie(basic_ostream< _CharT, _Traits>  *__tiestr) 
# 308
{ 
# 309
basic_ostream< _CharT, _Traits>  *__old = _M_tie; 
# 310
(_M_tie) = __tiestr; 
# 311
return __old; 
# 312
} 
# 321
basic_streambuf< _CharT, _Traits>  *rdbuf() const 
# 322
{ return _M_streambuf; } 
# 347 "/usr/include/c++/9/bits/basic_ios.h" 3
basic_streambuf< _CharT, _Traits>  *rdbuf(basic_streambuf< _CharT, _Traits>  * __sb); 
# 361 "/usr/include/c++/9/bits/basic_ios.h" 3
basic_ios &copyfmt(const basic_ios & __rhs); 
# 370
char_type fill() const 
# 371
{ 
# 372
if (!(_M_fill_init)) 
# 373
{ 
# 374
(_M_fill) = widen(' '); 
# 375
(_M_fill_init) = true; 
# 376
}  
# 377
return _M_fill; 
# 378
} 
# 390 "/usr/include/c++/9/bits/basic_ios.h" 3
char_type fill(char_type __ch) 
# 391
{ 
# 392
char_type __old = this->fill(); 
# 393
(_M_fill) = __ch; 
# 394
return __old; 
# 395
} 
# 410 "/usr/include/c++/9/bits/basic_ios.h" 3
locale imbue(const locale & __loc); 
# 430 "/usr/include/c++/9/bits/basic_ios.h" 3
char narrow(char_type __c, char __dfault) const 
# 431
{ return __check_facet(_M_ctype).narrow(__c, __dfault); } 
# 449 "/usr/include/c++/9/bits/basic_ios.h" 3
char_type widen(char __c) const 
# 450
{ return __check_facet(_M_ctype).widen(__c); } 
# 460
protected: basic_ios() : ios_base(), _M_tie((0)), _M_fill(char_type()), _M_fill_init(false), _M_streambuf((0)), _M_ctype((0)), _M_num_put((0)), _M_num_get((0)) 
# 463
{ } 
# 472
void init(basic_streambuf< _CharT, _Traits>  * __sb); 
# 475
basic_ios(const basic_ios &) = delete;
# 476
basic_ios &operator=(const basic_ios &) = delete;
# 479
void move(basic_ios &__rhs) 
# 480
{ 
# 481
this->ios_base::_M_move(__rhs); 
# 482
_M_cache_locale(_M_ios_locale); 
# 483
this->tie(__rhs.tie(nullptr)); 
# 484
(_M_fill) = (__rhs._M_fill); 
# 485
(_M_fill_init) = (__rhs._M_fill_init); 
# 486
(_M_streambuf) = nullptr; 
# 487
} 
# 490
void move(basic_ios &&__rhs) 
# 491
{ this->move(__rhs); } 
# 494
void swap(basic_ios &__rhs) noexcept 
# 495
{ 
# 496
this->ios_base::_M_swap(__rhs); 
# 497
_M_cache_locale(_M_ios_locale); 
# 498
__rhs._M_cache_locale(__rhs._M_ios_locale); 
# 499
std::swap(_M_tie, __rhs._M_tie); 
# 500
std::swap(_M_fill, __rhs._M_fill); 
# 501
std::swap(_M_fill_init, __rhs._M_fill_init); 
# 502
} 
# 505
void set_rdbuf(basic_streambuf< _CharT, _Traits>  *__sb) 
# 506
{ (_M_streambuf) = __sb; } 
# 510
void _M_cache_locale(const locale & __loc); 
# 511
}; 
# 514
}
# 35 "/usr/include/c++/9/bits/basic_ios.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 39
template< class _CharT, class _Traits> void 
# 41
basic_ios< _CharT, _Traits> ::clear(iostate __state) 
# 42
{ 
# 43
if (this->rdbuf()) { 
# 44
(_M_streambuf_state) = __state; } else { 
# 46
(_M_streambuf_state) = (__state | badbit); }  
# 47
if (((exceptions()) & (rdstate()))) { 
# 48
__throw_ios_failure("basic_ios::clear"); }  
# 49
} 
# 51
template< class _CharT, class _Traits> basic_streambuf< _CharT, _Traits>  *
# 53
basic_ios< _CharT, _Traits> ::rdbuf(basic_streambuf< _CharT, _Traits>  *__sb) 
# 54
{ 
# 55
basic_streambuf< _CharT, _Traits>  *__old = _M_streambuf; 
# 56
(_M_streambuf) = __sb; 
# 57
clear(); 
# 58
return __old; 
# 59
} 
# 61
template< class _CharT, class _Traits> basic_ios< _CharT, _Traits>  &
# 63
basic_ios< _CharT, _Traits> ::copyfmt(const basic_ios &__rhs) 
# 64
{ 
# 67
if (this != (&__rhs)) 
# 68
{ 
# 73
_Words *__words = ((__rhs._M_word_size) <= (_S_local_word_size)) ? _M_local_word : (new _Words [__rhs._M_word_size]); 
# 77
_Callback_list *__cb = __rhs._M_callbacks; 
# 78
if (__cb) { 
# 79
__cb->_M_add_reference(); }  
# 80
this->ios_base::_M_call_callbacks(erase_event); 
# 81
if ((_M_word) != (_M_local_word)) 
# 82
{ 
# 83
delete [] (_M_word); 
# 84
(_M_word) = (0); 
# 85
}  
# 86
this->ios_base::_M_dispose_callbacks(); 
# 89
(_M_callbacks) = __cb; 
# 90
for (int __i = 0; __i < (__rhs._M_word_size); ++__i) { 
# 91
(__words[__i]) = ((__rhs._M_word)[__i]); }  
# 92
(_M_word) = __words; 
# 93
(_M_word_size) = (__rhs._M_word_size); 
# 95
this->flags(__rhs.flags()); 
# 96
this->width(__rhs.width()); 
# 97
this->precision(__rhs.precision()); 
# 98
this->tie(__rhs.tie()); 
# 99
this->fill(__rhs.fill()); 
# 100
((_M_ios_locale) = (__rhs.getloc())); 
# 101
_M_cache_locale(_M_ios_locale); 
# 103
this->ios_base::_M_call_callbacks(copyfmt_event); 
# 106
exceptions(__rhs.exceptions()); 
# 107
}  
# 108
return *this; 
# 109
} 
# 112
template< class _CharT, class _Traits> locale 
# 114
basic_ios< _CharT, _Traits> ::imbue(const locale &__loc) 
# 115
{ 
# 116
locale __old(this->getloc()); 
# 117
this->ios_base::imbue(__loc); 
# 118
_M_cache_locale(__loc); 
# 119
if (this->rdbuf() != 0) { 
# 120
this->rdbuf()->pubimbue(__loc); }  
# 121
return __old; 
# 122
} 
# 124
template< class _CharT, class _Traits> void 
# 126
basic_ios< _CharT, _Traits> ::init(basic_streambuf< _CharT, _Traits>  *__sb) 
# 127
{ 
# 129
this->ios_base::_M_init(); 
# 132
_M_cache_locale(_M_ios_locale); 
# 146 "/usr/include/c++/9/bits/basic_ios.tcc" 3
(_M_fill) = _CharT(); 
# 147
(_M_fill_init) = false; 
# 149
(_M_tie) = 0; 
# 150
(_M_exception) = goodbit; 
# 151
(_M_streambuf) = __sb; 
# 152
(_M_streambuf_state) = ((__sb) ? goodbit : badbit); 
# 153
} 
# 155
template< class _CharT, class _Traits> void 
# 157
basic_ios< _CharT, _Traits> ::_M_cache_locale(const locale &__loc) 
# 158
{ 
# 159
if (__builtin_expect(has_facet< __ctype_type> (__loc), true)) { 
# 160
(_M_ctype) = std::__addressof(use_facet< __ctype_type> (__loc)); } else { 
# 162
(_M_ctype) = 0; }  
# 164
if (__builtin_expect(has_facet< __num_put_type> (__loc), true)) { 
# 165
(_M_num_put) = std::__addressof(use_facet< __num_put_type> (__loc)); } else { 
# 167
(_M_num_put) = 0; }  
# 169
if (__builtin_expect(has_facet< __num_get_type> (__loc), true)) { 
# 170
(_M_num_get) = std::__addressof(use_facet< __num_get_type> (__loc)); } else { 
# 172
(_M_num_get) = 0; }  
# 173
} 
# 178
extern template class basic_ios< char> ;
# 181
extern template class basic_ios< wchar_t> ;
# 186
}
# 41 "/usr/include/c++/9/ostream" 3
namespace std __attribute((__visibility__("default"))) { 
# 57 "/usr/include/c++/9/ostream" 3
template< class _CharT, class _Traits> 
# 58
class basic_ostream : virtual public basic_ios< _CharT, _Traits>  { 
# 62
public: typedef _CharT char_type; 
# 63
typedef typename _Traits::int_type int_type; 
# 64
typedef typename _Traits::pos_type pos_type; 
# 65
typedef typename _Traits::off_type off_type; 
# 66
typedef _Traits traits_type; 
# 69
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 70
typedef basic_ios< _CharT, _Traits>  __ios_type; 
# 71
typedef basic_ostream __ostream_type; 
# 73
typedef num_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  __num_put_type; 
# 74
typedef ctype< _CharT>  __ctype_type; 
# 84 "/usr/include/c++/9/ostream" 3
explicit basic_ostream(__streambuf_type *__sb) 
# 85
{ this->init(__sb); } 
# 93
virtual ~basic_ostream() { } 
# 96
class sentry; 
# 97
friend class sentry; 
# 108 "/usr/include/c++/9/ostream" 3
__ostream_type &operator<<(__ostream_type &(*__pf)(__ostream_type &)) 
# 109
{ 
# 113
return __pf(*this); 
# 114
} 
# 117
__ostream_type &operator<<(__ios_type &(*__pf)(__ios_type &)) 
# 118
{ 
# 122
__pf(*this); 
# 123
return *this; 
# 124
} 
# 127
__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &)) 
# 128
{ 
# 132
__pf(*this); 
# 133
return *this; 
# 134
} 
# 166 "/usr/include/c++/9/ostream" 3
__ostream_type &operator<<(long __n) 
# 167
{ return _M_insert(__n); } 
# 170
__ostream_type &operator<<(unsigned long __n) 
# 171
{ return _M_insert(__n); } 
# 174
__ostream_type &operator<<(bool __n) 
# 175
{ return _M_insert(__n); } 
# 178
__ostream_type &operator<<(short __n); 
# 181
__ostream_type &operator<<(unsigned short __n) 
# 182
{ 
# 185
return _M_insert(static_cast< unsigned long>(__n)); 
# 186
} 
# 189
__ostream_type &operator<<(int __n); 
# 192
__ostream_type &operator<<(unsigned __n) 
# 193
{ 
# 196
return _M_insert(static_cast< unsigned long>(__n)); 
# 197
} 
# 201
__ostream_type &operator<<(long long __n) 
# 202
{ return _M_insert(__n); } 
# 205
__ostream_type &operator<<(unsigned long long __n) 
# 206
{ return _M_insert(__n); } 
# 220 "/usr/include/c++/9/ostream" 3
__ostream_type &operator<<(double __f) 
# 221
{ return _M_insert(__f); } 
# 224
__ostream_type &operator<<(float __f) 
# 225
{ 
# 228
return _M_insert(static_cast< double>(__f)); 
# 229
} 
# 232
__ostream_type &operator<<(long double __f) 
# 233
{ return _M_insert(__f); } 
# 245 "/usr/include/c++/9/ostream" 3
__ostream_type &operator<<(const void *__p) 
# 246
{ return _M_insert(__p); } 
# 276 "/usr/include/c++/9/ostream" 3
__ostream_type &operator<<(__streambuf_type * __sb); 
# 309 "/usr/include/c++/9/ostream" 3
__ostream_type &put(char_type __c); 
# 317
void _M_write(const char_type *__s, std::streamsize __n) 
# 318
{ 
# 319
const std::streamsize __put = this->rdbuf()->sputn(__s, __n); 
# 320
if (__put != __n) { 
# 321
this->setstate(ios_base::badbit); }  
# 322
} 
# 341 "/usr/include/c++/9/ostream" 3
__ostream_type &write(const char_type * __s, std::streamsize __n); 
# 354 "/usr/include/c++/9/ostream" 3
__ostream_type &flush(); 
# 364 "/usr/include/c++/9/ostream" 3
pos_type tellp(); 
# 375 "/usr/include/c++/9/ostream" 3
__ostream_type &seekp(pos_type); 
# 387 "/usr/include/c++/9/ostream" 3
__ostream_type &seekp(off_type, std::ios_base::seekdir); 
# 390
protected: basic_ostream() 
# 391
{ this->init(0); } 
# 395
basic_ostream(basic_iostream< _CharT, _Traits>  &) { } 
# 397
basic_ostream(const basic_ostream &) = delete;
# 399
basic_ostream(basic_ostream &&__rhs) : __ios_type() 
# 401
{ __ios_type::move(__rhs); } 
# 405
basic_ostream &operator=(const basic_ostream &) = delete;
# 408
basic_ostream &operator=(basic_ostream &&__rhs) 
# 409
{ 
# 410
swap(__rhs); 
# 411
return *this; 
# 412
} 
# 415
void swap(basic_ostream &__rhs) 
# 416
{ __ios_type::swap(__rhs); } 
# 419
template< class _ValueT> __ostream_type &_M_insert(_ValueT __v); 
# 422
}; 
# 431 "/usr/include/c++/9/ostream" 3
template< class _CharT, class _Traits> 
# 432
class basic_ostream< _CharT, _Traits> ::sentry { 
# 435
bool _M_ok; 
# 436
basic_ostream &_M_os; 
# 451 "/usr/include/c++/9/ostream" 3
public: explicit sentry(basic_ostream & __os); 
# 453
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 462
~sentry() 
# 463
{ 
# 465
if (((bool)((_M_os).flags() & ios_base::unitbuf)) && (!uncaught_exception())) 
# 466
{ 
# 468
if ((_M_os).rdbuf() && ((_M_os).rdbuf()->pubsync() == (-1))) { 
# 469
(_M_os).setstate(ios_base::badbit); }  
# 470
}  
# 471
} 
#pragma GCC diagnostic pop
# 484 "/usr/include/c++/9/ostream" 3
explicit operator bool() const 
# 485
{ return _M_ok; } 
# 486
}; 
# 504 "/usr/include/c++/9/ostream" 3
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 506
operator<<(basic_ostream< _CharT, _Traits>  &__out, _CharT __c) 
# 507
{ return __ostream_insert(__out, &__c, 1); } 
# 509
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 511
operator<<(basic_ostream< _CharT, _Traits>  &__out, char __c) 
# 512
{ return (__out << __out.widen(__c)); } 
# 515
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 517
operator<<(basic_ostream< char, _Traits>  &__out, char __c) 
# 518
{ return __ostream_insert(__out, &__c, 1); } 
# 521
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 523
operator<<(basic_ostream< char, _Traits>  &__out, signed char __c) 
# 524
{ return (__out << (static_cast< char>(__c))); } 
# 526
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 528
operator<<(basic_ostream< char, _Traits>  &__out, unsigned char __c) 
# 529
{ return (__out << (static_cast< char>(__c))); } 
# 546 "/usr/include/c++/9/ostream" 3
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 548
operator<<(basic_ostream< _CharT, _Traits>  &__out, const _CharT *__s) 
# 549
{ 
# 550
if (!__s) { 
# 551
__out.setstate(ios_base::badbit); } else { 
# 553
__ostream_insert(__out, __s, static_cast< streamsize>(_Traits::length(__s))); }  
# 555
return __out; 
# 556
} 
# 558
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &operator<<(basic_ostream< _CharT, _Traits>  & __out, const char * __s); 
# 563
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 565
operator<<(basic_ostream< char, _Traits>  &__out, const char *__s) 
# 566
{ 
# 567
if (!__s) { 
# 568
__out.setstate(ios_base::badbit); } else { 
# 570
__ostream_insert(__out, __s, static_cast< streamsize>(_Traits::length(__s))); }  
# 572
return __out; 
# 573
} 
# 576
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 578
operator<<(basic_ostream< char, _Traits>  &__out, const signed char *__s) 
# 579
{ return (__out << (reinterpret_cast< const char *>(__s))); } 
# 581
template< class _Traits> inline basic_ostream< char, _Traits>  &
# 583
operator<<(basic_ostream< char, _Traits>  &__out, const unsigned char *__s) 
# 584
{ return (__out << (reinterpret_cast< const char *>(__s))); } 
# 597 "/usr/include/c++/9/ostream" 3
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 599
endl(basic_ostream< _CharT, _Traits>  &__os) 
# 600
{ return flush(__os.put(__os.widen('\n'))); } 
# 609 "/usr/include/c++/9/ostream" 3
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 611
ends(basic_ostream< _CharT, _Traits>  &__os) 
# 612
{ return __os.put(_CharT()); } 
# 619
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 621
flush(basic_ostream< _CharT, _Traits>  &__os) 
# 622
{ return __os.flush(); } 
# 625
template< class _Ch, class _Up> basic_ostream< _Ch, _Up>  &__is_convertible_to_basic_ostream_test(basic_ostream< _Ch, _Up>  *); 
# 629
template< class _Tp, class  = void> 
# 630
struct __is_convertible_to_basic_ostream_impl { 
# 632
using __ostream_type = void; 
# 633
}; 
# 635
template< class _Tp> using __do_is_convertible_to_basic_ostream_impl = __decltype((__is_convertible_to_basic_ostream_test(declval< typename remove_reference< _Tp> ::type *> ()))); 
# 640
template< class _Tp> 
# 641
struct __is_convertible_to_basic_ostream_impl< _Tp, __void_t< __do_is_convertible_to_basic_ostream_impl< _Tp> > >  { 
# 645
using __ostream_type = __do_is_convertible_to_basic_ostream_impl< _Tp> ; 
# 647
}; 
# 649
template< class _Tp> 
# 650
struct __is_convertible_to_basic_ostream : public __is_convertible_to_basic_ostream_impl< _Tp>  { 
# 654
using type = __not_< is_void< typename __is_convertible_to_basic_ostream_impl< _Tp> ::__ostream_type> > ; 
# 656
static constexpr bool value = (type::value); 
# 657
}; 
# 659
template< class _Ostream, class _Tp, class  = void> 
# 660
struct __is_insertable : public false_type { }; 
# 662
template< class _Ostream, class _Tp> 
# 663
struct __is_insertable< _Ostream, _Tp, __void_t< __decltype((declval< _Ostream &> () << declval< const _Tp &> ()))> >  : public true_type { 
# 666
}; 
# 668
template< class _Ostream> using __rvalue_ostream_type = typename __is_convertible_to_basic_ostream< _Ostream> ::__ostream_type; 
# 683 "/usr/include/c++/9/ostream" 3
template< class _Ostream, class _Tp> inline typename enable_if< __and_< __not_< is_lvalue_reference< _Ostream> > , __is_convertible_to_basic_ostream< _Ostream> , __is_insertable< __rvalue_ostream_type< _Ostream> , const _Tp &> > ::value, __rvalue_ostream_type< _Ostream> > ::type 
# 691
operator<<(_Ostream &&__os, const _Tp &__x) 
# 692
{ 
# 693
__rvalue_ostream_type< _Ostream>  __ret_os = __os; 
# 694
__ret_os << __x; 
# 695
return __ret_os; 
# 696
} 
# 700
}
# 41 "/usr/include/c++/9/bits/ostream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _CharT, class _Traits> 
# 47
basic_ostream< _CharT, _Traits> ::sentry::sentry(basic_ostream &__os) : _M_ok(false), _M_os(__os) 
# 49
{ 
# 51
if (__os.tie() && __os.good()) { 
# 52
__os.tie()->flush(); }  
# 54
if (__os.good()) { 
# 55
(_M_ok) = true; } else { 
# 57
__os.setstate(ios_base::failbit); }  
# 58
} 
# 60
template< class _CharT, class _Traits> 
# 61
template< class _ValueT> basic_ostream< _CharT, _Traits>  &
# 64
basic_ostream< _CharT, _Traits> ::_M_insert(_ValueT __v) 
# 65
{ 
# 66
sentry __cerb(*this); 
# 67
if (__cerb) 
# 68
{ 
# 69
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 70
try 
# 71
{ 
# 72
const __num_put_type &__np = __check_facet((this->_M_num_put)); 
# 73
if (__np.put(*this, *this, this->fill(), __v).failed()) { 
# 74
(__err |= std::ios_base::badbit); }  
# 75
} 
# 76
catch (__cxxabiv1::__forced_unwind &) 
# 77
{ 
# 78
this->_M_setstate(ios_base::badbit); 
# 79
throw; 
# 80
} 
# 81
catch (...) 
# 82
{ this->_M_setstate(ios_base::badbit); }  
# 83
if (__err) { 
# 84
this->setstate(__err); }  
# 85
}  
# 86
return *this; 
# 87
} 
# 89
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 92
basic_ostream< _CharT, _Traits> ::operator<<(short __n) 
# 93
{ 
# 96
const std::ios_base::fmtflags __fmt = this->flags() & ios_base::basefield; 
# 97
if ((__fmt == std::ios_base::oct) || (__fmt == std::ios_base::hex)) { 
# 98
return _M_insert(static_cast< long>(static_cast< unsigned short>(__n))); } else { 
# 100
return _M_insert(static_cast< long>(__n)); }  
# 101
} 
# 103
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 106
basic_ostream< _CharT, _Traits> ::operator<<(int __n) 
# 107
{ 
# 110
const std::ios_base::fmtflags __fmt = this->flags() & ios_base::basefield; 
# 111
if ((__fmt == std::ios_base::oct) || (__fmt == std::ios_base::hex)) { 
# 112
return _M_insert(static_cast< long>(static_cast< unsigned>(__n))); } else { 
# 114
return _M_insert(static_cast< long>(__n)); }  
# 115
} 
# 117
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 120
basic_ostream< _CharT, _Traits> ::operator<<(__streambuf_type *__sbin) 
# 121
{ 
# 122
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 123
sentry __cerb(*this); 
# 124
if (__cerb && __sbin) 
# 125
{ 
# 126
try 
# 127
{ 
# 128
if (!__copy_streambufs(__sbin, this->rdbuf())) { 
# 129
(__err |= std::ios_base::failbit); }  
# 130
} 
# 131
catch (__cxxabiv1::__forced_unwind &) 
# 132
{ 
# 133
this->_M_setstate(ios_base::badbit); 
# 134
throw; 
# 135
} 
# 136
catch (...) 
# 137
{ this->_M_setstate(ios_base::failbit); }  
# 138
} else { 
# 139
if (!__sbin) { 
# 140
(__err |= std::ios_base::badbit); }  }  
# 141
if (__err) { 
# 142
this->setstate(__err); }  
# 143
return *this; 
# 144
} 
# 146
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 149
basic_ostream< _CharT, _Traits> ::put(char_type __c) 
# 150
{ 
# 157
sentry __cerb(*this); 
# 158
if (__cerb) 
# 159
{ 
# 160
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 161
try 
# 162
{ 
# 163
const int_type __put = this->rdbuf()->sputc(__c); 
# 164
if (traits_type::eq_int_type(__put, traits_type::eof())) { 
# 165
(__err |= std::ios_base::badbit); }  
# 166
} 
# 167
catch (__cxxabiv1::__forced_unwind &) 
# 168
{ 
# 169
this->_M_setstate(ios_base::badbit); 
# 170
throw; 
# 171
} 
# 172
catch (...) 
# 173
{ this->_M_setstate(ios_base::badbit); }  
# 174
if (__err) { 
# 175
this->setstate(__err); }  
# 176
}  
# 177
return *this; 
# 178
} 
# 180
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 183
basic_ostream< _CharT, _Traits> ::write(const _CharT *__s, std::streamsize __n) 
# 184
{ 
# 192
sentry __cerb(*this); 
# 193
if (__cerb) 
# 194
{ 
# 195
try 
# 196
{ _M_write(__s, __n); } 
# 197
catch (__cxxabiv1::__forced_unwind &) 
# 198
{ 
# 199
this->_M_setstate(ios_base::badbit); 
# 200
throw; 
# 201
} 
# 202
catch (...) 
# 203
{ this->_M_setstate(ios_base::badbit); }  
# 204
}  
# 205
return *this; 
# 206
} 
# 208
template< class _CharT, class _Traits> typename basic_ostream< _CharT, _Traits> ::__ostream_type &
# 211
basic_ostream< _CharT, _Traits> ::flush() 
# 212
{ 
# 216
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 217
try 
# 218
{ 
# 219
if (this->rdbuf() && (this->rdbuf()->pubsync() == (-1))) { 
# 220
(__err |= std::ios_base::badbit); }  
# 221
} 
# 222
catch (__cxxabiv1::__forced_unwind &) 
# 223
{ 
# 224
this->_M_setstate(ios_base::badbit); 
# 225
throw; 
# 226
} 
# 227
catch (...) 
# 228
{ this->_M_setstate(ios_base::badbit); }  
# 229
if (__err) { 
# 230
this->setstate(__err); }  
# 231
return *this; 
# 232
} 
# 234
template< class _CharT, class _Traits> typename basic_ostream< _CharT, _Traits> ::pos_type 
# 237
basic_ostream< _CharT, _Traits> ::tellp() 
# 238
{ 
# 239
pos_type __ret = ((pos_type)(-1)); 
# 240
try 
# 241
{ 
# 242
if (!this->fail()) { 
# 243
__ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out); }  
# 244
} 
# 245
catch (__cxxabiv1::__forced_unwind &) 
# 246
{ 
# 247
this->_M_setstate(ios_base::badbit); 
# 248
throw; 
# 249
} 
# 250
catch (...) 
# 251
{ this->_M_setstate(ios_base::badbit); }  
# 252
return __ret; 
# 253
} 
# 255
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 258
basic_ostream< _CharT, _Traits> ::seekp(pos_type __pos) 
# 259
{ 
# 260
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 261
try 
# 262
{ 
# 263
if (!this->fail()) 
# 264
{ 
# 267
const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out); 
# 271
if (__p == ((pos_type)((off_type)(-1)))) { 
# 272
(__err |= std::ios_base::failbit); }  
# 273
}  
# 274
} 
# 275
catch (__cxxabiv1::__forced_unwind &) 
# 276
{ 
# 277
this->_M_setstate(ios_base::badbit); 
# 278
throw; 
# 279
} 
# 280
catch (...) 
# 281
{ this->_M_setstate(ios_base::badbit); }  
# 282
if (__err) { 
# 283
this->setstate(__err); }  
# 284
return *this; 
# 285
} 
# 287
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 290
basic_ostream< _CharT, _Traits> ::seekp(off_type __off, std::ios_base::seekdir __dir) 
# 291
{ 
# 292
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 293
try 
# 294
{ 
# 295
if (!this->fail()) 
# 296
{ 
# 299
const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::out); 
# 303
if (__p == ((pos_type)((off_type)(-1)))) { 
# 304
(__err |= std::ios_base::failbit); }  
# 305
}  
# 306
} 
# 307
catch (__cxxabiv1::__forced_unwind &) 
# 308
{ 
# 309
this->_M_setstate(ios_base::badbit); 
# 310
throw; 
# 311
} 
# 312
catch (...) 
# 313
{ this->_M_setstate(ios_base::badbit); }  
# 314
if (__err) { 
# 315
this->setstate(__err); }  
# 316
return *this; 
# 317
} 
# 319
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 321
operator<<(basic_ostream< _CharT, _Traits>  &__out, const char *__s) 
# 322
{ 
# 323
if (!__s) { 
# 324
__out.setstate(ios_base::badbit); } else 
# 326
{ 
# 329
const size_t __clen = char_traits< char> ::length(__s); 
# 330
try 
# 331
{ 
# 332
struct __ptr_guard { 
# 334
_CharT *__p; 
# 335
__ptr_guard(_CharT *__ip) : __p(__ip) { } 
# 336
~__ptr_guard() { delete [] (__p); } 
# 337
_CharT *__get() { return __p; } 
# 338
} __pg(new _CharT [__clen]); 
# 340
_CharT *__ws = __pg.__get(); 
# 341
for (size_t __i = (0); __i < __clen; ++__i) { 
# 342
(__ws[__i]) = __out.widen(__s[__i]); }  
# 343
__ostream_insert(__out, __ws, __clen); 
# 344
} 
# 345
catch (__cxxabiv1::__forced_unwind &) 
# 346
{ 
# 347
__out._M_setstate(ios_base::badbit); 
# 348
throw; 
# 349
} 
# 350
catch (...) 
# 351
{ __out._M_setstate(ios_base::badbit); }  
# 352
}  
# 353
return __out; 
# 354
} 
# 359
extern template class basic_ostream< char> ;
# 360
extern template basic_ostream< char>  &endl(basic_ostream< char>  & __os);
# 361
extern template basic_ostream< char>  &ends(basic_ostream< char>  & __os);
# 362
extern template basic_ostream< char>  &flush(basic_ostream< char>  & __os);
# 363
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, char __c);
# 364
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, unsigned char __c);
# 365
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, signed char __c);
# 366
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, const char * __s);
# 367
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, const unsigned char * __s);
# 368
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, const signed char * __s);
# 370
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(long __v);
# 371
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(unsigned long __v);
# 372
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(bool __v);
# 374
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(long long __v);
# 375
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(unsigned long long __v);
# 377
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(double __v);
# 378
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(long double __v);
# 379
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(const void * __v);
# 382
extern template class basic_ostream< wchar_t> ;
# 383
extern template basic_ostream< wchar_t>  &endl(basic_ostream< wchar_t>  & __os);
# 384
extern template basic_ostream< wchar_t>  &ends(basic_ostream< wchar_t>  & __os);
# 385
extern template basic_ostream< wchar_t>  &flush(basic_ostream< wchar_t>  & __os);
# 386
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __out, wchar_t __c);
# 387
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __out, char __c);
# 388
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __out, const wchar_t * __s);
# 389
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __out, const char * __s);
# 391
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(long __v);
# 392
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(unsigned long __v);
# 393
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(bool __v);
# 395
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(long long __v);
# 396
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(unsigned long long __v);
# 398
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(double __v);
# 399
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(long double __v);
# 400
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(const void * __v);
# 405
}
# 41 "/usr/include/c++/9/istream" 3
namespace std __attribute((__visibility__("default"))) { 
# 57 "/usr/include/c++/9/istream" 3
template< class _CharT, class _Traits> 
# 58
class basic_istream : virtual public basic_ios< _CharT, _Traits>  { 
# 62
public: typedef _CharT char_type; 
# 63
typedef typename _Traits::int_type int_type; 
# 64
typedef typename _Traits::pos_type pos_type; 
# 65
typedef typename _Traits::off_type off_type; 
# 66
typedef _Traits traits_type; 
# 69
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 70
typedef basic_ios< _CharT, _Traits>  __ios_type; 
# 71
typedef basic_istream __istream_type; 
# 73
typedef num_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  __num_get_type; 
# 74
typedef ctype< _CharT>  __ctype_type; 
# 82
protected: std::streamsize _M_gcount; 
# 93
public: explicit basic_istream(__streambuf_type *__sb) : _M_gcount(((std::streamsize)0)) 
# 95
{ this->init(__sb); } 
# 103
virtual ~basic_istream() 
# 104
{ (_M_gcount) = ((std::streamsize)0); } 
# 107
class sentry; 
# 108
friend class sentry; 
# 120 "/usr/include/c++/9/istream" 3
__istream_type &operator>>(__istream_type &(*__pf)(__istream_type &)) 
# 121
{ return __pf(*this); } 
# 124
__istream_type &operator>>(__ios_type &(*__pf)(__ios_type &)) 
# 125
{ 
# 126
__pf(*this); 
# 127
return *this; 
# 128
} 
# 131
__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &)) 
# 132
{ 
# 133
__pf(*this); 
# 134
return *this; 
# 135
} 
# 168 "/usr/include/c++/9/istream" 3
__istream_type &operator>>(bool &__n) 
# 169
{ return _M_extract(__n); } 
# 172
__istream_type &operator>>(short & __n); 
# 175
__istream_type &operator>>(unsigned short &__n) 
# 176
{ return _M_extract(__n); } 
# 179
__istream_type &operator>>(int & __n); 
# 182
__istream_type &operator>>(unsigned &__n) 
# 183
{ return _M_extract(__n); } 
# 186
__istream_type &operator>>(long &__n) 
# 187
{ return _M_extract(__n); } 
# 190
__istream_type &operator>>(unsigned long &__n) 
# 191
{ return _M_extract(__n); } 
# 195
__istream_type &operator>>(long long &__n) 
# 196
{ return _M_extract(__n); } 
# 199
__istream_type &operator>>(unsigned long long &__n) 
# 200
{ return _M_extract(__n); } 
# 214 "/usr/include/c++/9/istream" 3
__istream_type &operator>>(float &__f) 
# 215
{ return _M_extract(__f); } 
# 218
__istream_type &operator>>(double &__f) 
# 219
{ return _M_extract(__f); } 
# 222
__istream_type &operator>>(long double &__f) 
# 223
{ return _M_extract(__f); } 
# 235 "/usr/include/c++/9/istream" 3
__istream_type &operator>>(void *&__p) 
# 236
{ return _M_extract(__p); } 
# 259 "/usr/include/c++/9/istream" 3
__istream_type &operator>>(__streambuf_type * __sb); 
# 269 "/usr/include/c++/9/istream" 3
std::streamsize gcount() const 
# 270
{ return _M_gcount; } 
# 302 "/usr/include/c++/9/istream" 3
int_type get(); 
# 316 "/usr/include/c++/9/istream" 3
__istream_type &get(char_type & __c); 
# 343 "/usr/include/c++/9/istream" 3
__istream_type &get(char_type * __s, std::streamsize __n, char_type __delim); 
# 354 "/usr/include/c++/9/istream" 3
__istream_type &get(char_type *__s, std::streamsize __n) 
# 355
{ return this->get(__s, __n, this->widen('\n')); } 
# 377 "/usr/include/c++/9/istream" 3
__istream_type &get(__streambuf_type & __sb, char_type __delim); 
# 387 "/usr/include/c++/9/istream" 3
__istream_type &get(__streambuf_type &__sb) 
# 388
{ return this->get(__sb, this->widen('\n')); } 
# 416 "/usr/include/c++/9/istream" 3
__istream_type &getline(char_type * __s, std::streamsize __n, char_type __delim); 
# 427 "/usr/include/c++/9/istream" 3
__istream_type &getline(char_type *__s, std::streamsize __n) 
# 428
{ return this->getline(__s, __n, this->widen('\n')); } 
# 451 "/usr/include/c++/9/istream" 3
__istream_type &ignore(std::streamsize __n, int_type __delim); 
# 454
__istream_type &ignore(std::streamsize __n); 
# 457
__istream_type &ignore(); 
# 468 "/usr/include/c++/9/istream" 3
int_type peek(); 
# 486 "/usr/include/c++/9/istream" 3
__istream_type &read(char_type * __s, std::streamsize __n); 
# 505 "/usr/include/c++/9/istream" 3
std::streamsize readsome(char_type * __s, std::streamsize __n); 
# 522 "/usr/include/c++/9/istream" 3
__istream_type &putback(char_type __c); 
# 538 "/usr/include/c++/9/istream" 3
__istream_type &unget(); 
# 556 "/usr/include/c++/9/istream" 3
int sync(); 
# 571 "/usr/include/c++/9/istream" 3
pos_type tellg(); 
# 586 "/usr/include/c++/9/istream" 3
__istream_type &seekg(pos_type); 
# 602 "/usr/include/c++/9/istream" 3
__istream_type &seekg(off_type, std::ios_base::seekdir); 
# 606
protected: basic_istream() : _M_gcount(((std::streamsize)0)) 
# 608
{ this->init(0); } 
# 611
basic_istream(const basic_istream &) = delete;
# 613
basic_istream(basic_istream &&__rhs) : __ios_type(), _M_gcount(__rhs._M_gcount) 
# 615
{ 
# 616
__ios_type::move(__rhs); 
# 617
(__rhs._M_gcount) = (0); 
# 618
} 
# 622
basic_istream &operator=(const basic_istream &) = delete;
# 625
basic_istream &operator=(basic_istream &&__rhs) 
# 626
{ 
# 627
swap(__rhs); 
# 628
return *this; 
# 629
} 
# 632
void swap(basic_istream &__rhs) 
# 633
{ 
# 634
__ios_type::swap(__rhs); 
# 635
std::swap(_M_gcount, __rhs._M_gcount); 
# 636
} 
# 639
template< class _ValueT> __istream_type &_M_extract(_ValueT & __v); 
# 642
}; 
# 648
template<> basic_istream< char>  &basic_istream< char> ::getline(char_type * __s, streamsize __n, char_type __delim); 
# 653
template<> basic_istream< char>  &basic_istream< char> ::ignore(streamsize __n); 
# 658
template<> basic_istream< char>  &basic_istream< char> ::ignore(streamsize __n, int_type __delim); 
# 664
template<> basic_istream< wchar_t>  &basic_istream< wchar_t> ::getline(char_type * __s, streamsize __n, char_type __delim); 
# 669
template<> basic_istream< wchar_t>  &basic_istream< wchar_t> ::ignore(streamsize __n); 
# 674
template<> basic_istream< wchar_t>  &basic_istream< wchar_t> ::ignore(streamsize __n, int_type __delim); 
# 685 "/usr/include/c++/9/istream" 3
template< class _CharT, class _Traits> 
# 686
class basic_istream< _CharT, _Traits> ::sentry { 
# 689
bool _M_ok; 
# 693
public: typedef _Traits traits_type; 
# 694
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 695
typedef basic_istream __istream_type; 
# 696
typedef typename basic_istream< _CharT, _Traits> ::__ctype_type __ctype_type; 
# 697
typedef typename _Traits::int_type __int_type; 
# 722 "/usr/include/c++/9/istream" 3
explicit sentry(basic_istream & __is, bool __noskipws = false); 
# 734 "/usr/include/c++/9/istream" 3
explicit operator bool() const 
# 735
{ return _M_ok; } 
# 736
}; 
# 750 "/usr/include/c++/9/istream" 3
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __in, _CharT & __c); 
# 754
template< class _Traits> inline basic_istream< char, _Traits>  &
# 756
operator>>(basic_istream< char, _Traits>  &__in, unsigned char &__c) 
# 757
{ return (__in >> (reinterpret_cast< char &>(__c))); } 
# 759
template< class _Traits> inline basic_istream< char, _Traits>  &
# 761
operator>>(basic_istream< char, _Traits>  &__in, signed char &__c) 
# 762
{ return (__in >> (reinterpret_cast< char &>(__c))); } 
# 792 "/usr/include/c++/9/istream" 3
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &operator>>(basic_istream< _CharT, _Traits>  & __in, _CharT * __s); 
# 799
template<> basic_istream< char>  &operator>>(basic_istream< char>  & __in, char * __s); 
# 801
template< class _Traits> inline basic_istream< char, _Traits>  &
# 803
operator>>(basic_istream< char, _Traits>  &__in, unsigned char *__s) 
# 804
{ return (__in >> (reinterpret_cast< char *>(__s))); } 
# 806
template< class _Traits> inline basic_istream< char, _Traits>  &
# 808
operator>>(basic_istream< char, _Traits>  &__in, signed char *__s) 
# 809
{ return (__in >> (reinterpret_cast< char *>(__s))); } 
# 823 "/usr/include/c++/9/istream" 3
template< class _CharT, class _Traits> 
# 824
class basic_iostream : public basic_istream< _CharT, _Traits> , public basic_ostream< _CharT, _Traits>  { 
# 832
public: typedef _CharT char_type; 
# 833
typedef typename _Traits::int_type int_type; 
# 834
typedef typename _Traits::pos_type pos_type; 
# 835
typedef typename _Traits::off_type off_type; 
# 836
typedef _Traits traits_type; 
# 839
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 840
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 849
explicit basic_iostream(basic_streambuf< _CharT, _Traits>  *__sb) : __istream_type(__sb), __ostream_type(__sb) 
# 850
{ } 
# 856
virtual ~basic_iostream() { } 
# 859
protected: basic_iostream() : __istream_type(), __ostream_type() 
# 860
{ } 
# 863
basic_iostream(const basic_iostream &) = delete;
# 865
basic_iostream(basic_iostream &&__rhs) : __istream_type(std::move(__rhs)), __ostream_type(*this) 
# 867
{ } 
# 871
basic_iostream &operator=(const basic_iostream &) = delete;
# 874
basic_iostream &operator=(basic_iostream &&__rhs) 
# 875
{ 
# 876
swap(__rhs); 
# 877
return *this; 
# 878
} 
# 881
void swap(basic_iostream &__rhs) 
# 882
{ __istream_type::swap(__rhs); } 
# 884
}; 
# 906 "/usr/include/c++/9/istream" 3
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &ws(basic_istream< _CharT, _Traits>  & __is); 
# 911
template< class _Ch, class _Up> basic_istream< _Ch, _Up>  &__is_convertible_to_basic_istream_test(basic_istream< _Ch, _Up>  *); 
# 915
template< class _Tp, class  = void> 
# 916
struct __is_convertible_to_basic_istream_impl { 
# 918
using __istream_type = void; 
# 919
}; 
# 921
template< class _Tp> using __do_is_convertible_to_basic_istream_impl = __decltype((__is_convertible_to_basic_istream_test(declval< typename remove_reference< _Tp> ::type *> ()))); 
# 926
template< class _Tp> 
# 927
struct __is_convertible_to_basic_istream_impl< _Tp, __void_t< __do_is_convertible_to_basic_istream_impl< _Tp> > >  { 
# 931
using __istream_type = __do_is_convertible_to_basic_istream_impl< _Tp> ; 
# 933
}; 
# 935
template< class _Tp> 
# 936
struct __is_convertible_to_basic_istream : public __is_convertible_to_basic_istream_impl< _Tp>  { 
# 940
using type = __not_< is_void< typename __is_convertible_to_basic_istream_impl< _Tp> ::__istream_type> > ; 
# 942
static constexpr bool value = (type::value); 
# 943
}; 
# 945
template< class _Istream, class _Tp, class  = void> 
# 946
struct __is_extractable : public false_type { }; 
# 948
template< class _Istream, class _Tp> 
# 949
struct __is_extractable< _Istream, _Tp, __void_t< __decltype((declval< _Istream &> () >> declval< _Tp> ()))> >  : public true_type { 
# 952
}; 
# 954
template< class _Istream> using __rvalue_istream_type = typename __is_convertible_to_basic_istream< _Istream> ::__istream_type; 
# 972 "/usr/include/c++/9/istream" 3
template< class _Istream, class _Tp> inline typename enable_if< __and_< __not_< is_lvalue_reference< _Istream> > , __is_convertible_to_basic_istream< _Istream> , __is_extractable< __rvalue_istream_type< _Istream> , _Tp &&> > ::value, __rvalue_istream_type< _Istream> > ::type 
# 980
operator>>(_Istream &&__is, _Tp &&__x) 
# 981
{ 
# 982
__rvalue_istream_type< _Istream>  __ret_is = __is; 
# 983
__ret_is >> std::forward< _Tp> (__x); 
# 984
return __ret_is; 
# 985
} 
# 989
}
# 41 "/usr/include/c++/9/bits/istream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _CharT, class _Traits> 
# 47
basic_istream< _CharT, _Traits> ::sentry::sentry(basic_istream &__in, bool __noskip) : _M_ok(false) 
# 48
{ 
# 49
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 50
if (__in.good()) { 
# 51
try 
# 52
{ 
# 53
if (__in.tie()) { 
# 54
__in.tie()->flush(); }  
# 55
if ((!__noskip) && ((bool)(__in.flags() & ios_base::skipws))) 
# 56
{ 
# 57
const __int_type __eof = traits_type::eof(); 
# 58
__streambuf_type *__sb = __in.rdbuf(); 
# 59
__int_type __c = __sb->sgetc(); 
# 61
const __ctype_type &__ct = __check_facet((__in._M_ctype)); 
# 62
while ((!traits_type::eq_int_type(__c, __eof)) && __ct.is(ctype_base::space, traits_type::to_char_type(__c))) { 
# 65
__c = __sb->snextc(); }  
# 70
if (traits_type::eq_int_type(__c, __eof)) { 
# 71
(__err |= std::ios_base::eofbit); }  
# 72
}  
# 73
} 
# 74
catch (__cxxabiv1::__forced_unwind &) 
# 75
{ 
# 76
__in._M_setstate(ios_base::badbit); 
# 77
throw; 
# 78
} 
# 79
catch (...) 
# 80
{ __in._M_setstate(ios_base::badbit); }  }  
# 82
if (__in.good() && (__err == std::ios_base::goodbit)) { 
# 83
(_M_ok) = true; } else 
# 85
{ 
# 86
(__err |= std::ios_base::failbit); 
# 87
__in.setstate(__err); 
# 88
}  
# 89
} 
# 91
template< class _CharT, class _Traits> 
# 92
template< class _ValueT> basic_istream< _CharT, _Traits>  &
# 95
basic_istream< _CharT, _Traits> ::_M_extract(_ValueT &__v) 
# 96
{ 
# 97
sentry __cerb(*this, false); 
# 98
if (__cerb) 
# 99
{ 
# 100
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 101
try 
# 102
{ 
# 103
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 104
__ng.get(*this, 0, *this, __err, __v); 
# 105
} 
# 106
catch (__cxxabiv1::__forced_unwind &) 
# 107
{ 
# 108
this->_M_setstate(ios_base::badbit); 
# 109
throw; 
# 110
} 
# 111
catch (...) 
# 112
{ this->_M_setstate(ios_base::badbit); }  
# 113
if (__err) { 
# 114
this->setstate(__err); }  
# 115
}  
# 116
return *this; 
# 117
} 
# 119
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 122
basic_istream< _CharT, _Traits> ::operator>>(short &__n) 
# 123
{ 
# 126
sentry __cerb(*this, false); 
# 127
if (__cerb) 
# 128
{ 
# 129
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 130
try 
# 131
{ 
# 132
long __l; 
# 133
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 134
__ng.get(*this, 0, *this, __err, __l); 
# 138
if (__l < __gnu_cxx::__numeric_traits_integer< short> ::__min) 
# 139
{ 
# 140
(__err |= std::ios_base::failbit); 
# 141
__n = __gnu_cxx::__numeric_traits_integer< short> ::__min; 
# 142
} else { 
# 143
if (__l > __gnu_cxx::__numeric_traits_integer< short> ::__max) 
# 144
{ 
# 145
(__err |= std::ios_base::failbit); 
# 146
__n = __gnu_cxx::__numeric_traits_integer< short> ::__max; 
# 147
} else { 
# 149
__n = ((short)__l); }  }  
# 150
} 
# 151
catch (__cxxabiv1::__forced_unwind &) 
# 152
{ 
# 153
this->_M_setstate(ios_base::badbit); 
# 154
throw; 
# 155
} 
# 156
catch (...) 
# 157
{ this->_M_setstate(ios_base::badbit); }  
# 158
if (__err) { 
# 159
this->setstate(__err); }  
# 160
}  
# 161
return *this; 
# 162
} 
# 164
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 167
basic_istream< _CharT, _Traits> ::operator>>(int &__n) 
# 168
{ 
# 171
sentry __cerb(*this, false); 
# 172
if (__cerb) 
# 173
{ 
# 174
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 175
try 
# 176
{ 
# 177
long __l; 
# 178
const __num_get_type &__ng = __check_facet((this->_M_num_get)); 
# 179
__ng.get(*this, 0, *this, __err, __l); 
# 183
if (__l < __gnu_cxx::__numeric_traits_integer< int> ::__min) 
# 184
{ 
# 185
(__err |= std::ios_base::failbit); 
# 186
__n = __gnu_cxx::__numeric_traits_integer< int> ::__min; 
# 187
} else { 
# 188
if (__l > __gnu_cxx::__numeric_traits_integer< int> ::__max) 
# 189
{ 
# 190
(__err |= std::ios_base::failbit); 
# 191
__n = __gnu_cxx::__numeric_traits_integer< int> ::__max; 
# 192
} else { 
# 194
__n = ((int)__l); }  }  
# 195
} 
# 196
catch (__cxxabiv1::__forced_unwind &) 
# 197
{ 
# 198
this->_M_setstate(ios_base::badbit); 
# 199
throw; 
# 200
} 
# 201
catch (...) 
# 202
{ this->_M_setstate(ios_base::badbit); }  
# 203
if (__err) { 
# 204
this->setstate(__err); }  
# 205
}  
# 206
return *this; 
# 207
} 
# 209
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 212
basic_istream< _CharT, _Traits> ::operator>>(__streambuf_type *__sbout) 
# 213
{ 
# 214
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 215
sentry __cerb(*this, false); 
# 216
if (__cerb && __sbout) 
# 217
{ 
# 218
try 
# 219
{ 
# 220
bool __ineof; 
# 221
if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof)) { 
# 222
(__err |= std::ios_base::failbit); }  
# 223
if (__ineof) { 
# 224
(__err |= std::ios_base::eofbit); }  
# 225
} 
# 226
catch (__cxxabiv1::__forced_unwind &) 
# 227
{ 
# 228
this->_M_setstate(ios_base::failbit); 
# 229
throw; 
# 230
} 
# 231
catch (...) 
# 232
{ this->_M_setstate(ios_base::failbit); }  
# 233
} else { 
# 234
if (!__sbout) { 
# 235
(__err |= std::ios_base::failbit); }  }  
# 236
if (__err) { 
# 237
this->setstate(__err); }  
# 238
return *this; 
# 239
} 
# 241
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::int_type 
# 244
basic_istream< _CharT, _Traits> ::get() 
# 245
{ 
# 246
const int_type __eof = traits_type::eof(); 
# 247
int_type __c = __eof; 
# 248
(_M_gcount) = (0); 
# 249
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 250
sentry __cerb(*this, true); 
# 251
if (__cerb) 
# 252
{ 
# 253
try 
# 254
{ 
# 255
__c = this->rdbuf()->sbumpc(); 
# 257
if (!traits_type::eq_int_type(__c, __eof)) { 
# 258
(_M_gcount) = (1); } else { 
# 260
(__err |= std::ios_base::eofbit); }  
# 261
} 
# 262
catch (__cxxabiv1::__forced_unwind &) 
# 263
{ 
# 264
this->_M_setstate(ios_base::badbit); 
# 265
throw; 
# 266
} 
# 267
catch (...) 
# 268
{ this->_M_setstate(ios_base::badbit); }  
# 269
}  
# 270
if (!(_M_gcount)) { 
# 271
(__err |= std::ios_base::failbit); }  
# 272
if (__err) { 
# 273
this->setstate(__err); }  
# 274
return __c; 
# 275
} 
# 277
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 280
basic_istream< _CharT, _Traits> ::get(char_type &__c) 
# 281
{ 
# 282
(_M_gcount) = (0); 
# 283
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 284
sentry __cerb(*this, true); 
# 285
if (__cerb) 
# 286
{ 
# 287
try 
# 288
{ 
# 289
const int_type __cb = this->rdbuf()->sbumpc(); 
# 291
if (!traits_type::eq_int_type(__cb, traits_type::eof())) 
# 292
{ 
# 293
(_M_gcount) = (1); 
# 294
__c = traits_type::to_char_type(__cb); 
# 295
} else { 
# 297
(__err |= std::ios_base::eofbit); }  
# 298
} 
# 299
catch (__cxxabiv1::__forced_unwind &) 
# 300
{ 
# 301
this->_M_setstate(ios_base::badbit); 
# 302
throw; 
# 303
} 
# 304
catch (...) 
# 305
{ this->_M_setstate(ios_base::badbit); }  
# 306
}  
# 307
if (!(_M_gcount)) { 
# 308
(__err |= std::ios_base::failbit); }  
# 309
if (__err) { 
# 310
this->setstate(__err); }  
# 311
return *this; 
# 312
} 
# 314
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 317
basic_istream< _CharT, _Traits> ::get(char_type *__s, std::streamsize __n, char_type __delim) 
# 318
{ 
# 319
(_M_gcount) = (0); 
# 320
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 321
sentry __cerb(*this, true); 
# 322
if (__cerb) 
# 323
{ 
# 324
try 
# 325
{ 
# 326
const int_type __idelim = traits_type::to_int_type(__delim); 
# 327
const int_type __eof = traits_type::eof(); 
# 328
__streambuf_type *__sb = this->rdbuf(); 
# 329
int_type __c = __sb->sgetc(); 
# 331
while ((((_M_gcount) + (1)) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim))) 
# 334
{ 
# 335
(*(__s++)) = traits_type::to_char_type(__c); 
# 336
++(_M_gcount); 
# 337
__c = __sb->snextc(); 
# 338
}  
# 339
if (traits_type::eq_int_type(__c, __eof)) { 
# 340
(__err |= std::ios_base::eofbit); }  
# 341
} 
# 342
catch (__cxxabiv1::__forced_unwind &) 
# 343
{ 
# 344
this->_M_setstate(ios_base::badbit); 
# 345
throw; 
# 346
} 
# 347
catch (...) 
# 348
{ this->_M_setstate(ios_base::badbit); }  
# 349
}  
# 352
if (__n > (0)) { 
# 353
(*__s) = char_type(); }  
# 354
if (!(_M_gcount)) { 
# 355
(__err |= std::ios_base::failbit); }  
# 356
if (__err) { 
# 357
this->setstate(__err); }  
# 358
return *this; 
# 359
} 
# 361
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 364
basic_istream< _CharT, _Traits> ::get(__streambuf_type &__sb, char_type __delim) 
# 365
{ 
# 366
(_M_gcount) = (0); 
# 367
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 368
sentry __cerb(*this, true); 
# 369
if (__cerb) 
# 370
{ 
# 371
try 
# 372
{ 
# 373
const int_type __idelim = traits_type::to_int_type(__delim); 
# 374
const int_type __eof = traits_type::eof(); 
# 375
__streambuf_type *__this_sb = this->rdbuf(); 
# 376
int_type __c = __this_sb->sgetc(); 
# 377
char_type __c2 = traits_type::to_char_type(__c); 
# 379
while ((!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim)) && (!traits_type::eq_int_type(__sb.sputc(__c2), __eof))) 
# 382
{ 
# 383
++(_M_gcount); 
# 384
__c = __this_sb->snextc(); 
# 385
__c2 = traits_type::to_char_type(__c); 
# 386
}  
# 387
if (traits_type::eq_int_type(__c, __eof)) { 
# 388
(__err |= std::ios_base::eofbit); }  
# 389
} 
# 390
catch (__cxxabiv1::__forced_unwind &) 
# 391
{ 
# 392
this->_M_setstate(ios_base::badbit); 
# 393
throw; 
# 394
} 
# 395
catch (...) 
# 396
{ this->_M_setstate(ios_base::badbit); }  
# 397
}  
# 398
if (!(_M_gcount)) { 
# 399
(__err |= std::ios_base::failbit); }  
# 400
if (__err) { 
# 401
this->setstate(__err); }  
# 402
return *this; 
# 403
} 
# 405
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 408
basic_istream< _CharT, _Traits> ::getline(char_type *__s, std::streamsize __n, char_type __delim) 
# 409
{ 
# 410
(_M_gcount) = (0); 
# 411
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 412
sentry __cerb(*this, true); 
# 413
if (__cerb) 
# 414
{ 
# 415
try 
# 416
{ 
# 417
const int_type __idelim = traits_type::to_int_type(__delim); 
# 418
const int_type __eof = traits_type::eof(); 
# 419
__streambuf_type *__sb = this->rdbuf(); 
# 420
int_type __c = __sb->sgetc(); 
# 422
while ((((_M_gcount) + (1)) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __idelim))) 
# 425
{ 
# 426
(*(__s++)) = traits_type::to_char_type(__c); 
# 427
__c = __sb->snextc(); 
# 428
++(_M_gcount); 
# 429
}  
# 430
if (traits_type::eq_int_type(__c, __eof)) { 
# 431
(__err |= std::ios_base::eofbit); } else 
# 433
{ 
# 434
if (traits_type::eq_int_type(__c, __idelim)) 
# 435
{ 
# 436
__sb->sbumpc(); 
# 437
++(_M_gcount); 
# 438
} else { 
# 440
(__err |= std::ios_base::failbit); }  
# 441
}  
# 442
} 
# 443
catch (__cxxabiv1::__forced_unwind &) 
# 444
{ 
# 445
this->_M_setstate(ios_base::badbit); 
# 446
throw; 
# 447
} 
# 448
catch (...) 
# 449
{ this->_M_setstate(ios_base::badbit); }  
# 450
}  
# 453
if (__n > (0)) { 
# 454
(*__s) = char_type(); }  
# 455
if (!(_M_gcount)) { 
# 456
(__err |= std::ios_base::failbit); }  
# 457
if (__err) { 
# 458
this->setstate(__err); }  
# 459
return *this; 
# 460
} 
# 465
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::__istream_type &
# 468
basic_istream< _CharT, _Traits> ::ignore() 
# 469
{ 
# 470
(_M_gcount) = (0); 
# 471
sentry __cerb(*this, true); 
# 472
if (__cerb) 
# 473
{ 
# 474
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 475
try 
# 476
{ 
# 477
const int_type __eof = traits_type::eof(); 
# 478
__streambuf_type *__sb = this->rdbuf(); 
# 480
if (traits_type::eq_int_type(__sb->sbumpc(), __eof)) { 
# 481
(__err |= std::ios_base::eofbit); } else { 
# 483
(_M_gcount) = (1); }  
# 484
} 
# 485
catch (__cxxabiv1::__forced_unwind &) 
# 486
{ 
# 487
this->_M_setstate(ios_base::badbit); 
# 488
throw; 
# 489
} 
# 490
catch (...) 
# 491
{ this->_M_setstate(ios_base::badbit); }  
# 492
if (__err) { 
# 493
this->setstate(__err); }  
# 494
}  
# 495
return *this; 
# 496
} 
# 498
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 501
basic_istream< _CharT, _Traits> ::ignore(std::streamsize __n) 
# 502
{ 
# 503
(_M_gcount) = (0); 
# 504
sentry __cerb(*this, true); 
# 505
if (__cerb && (__n > (0))) 
# 506
{ 
# 507
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 508
try 
# 509
{ 
# 510
const int_type __eof = traits_type::eof(); 
# 511
__streambuf_type *__sb = this->rdbuf(); 
# 512
int_type __c = __sb->sgetc(); 
# 521 "/usr/include/c++/9/bits/istream.tcc" 3
bool __large_ignore = false; 
# 522
while (true) 
# 523
{ 
# 524
while (((_M_gcount) < __n) && (!traits_type::eq_int_type(__c, __eof))) 
# 526
{ 
# 527
++(_M_gcount); 
# 528
__c = __sb->snextc(); 
# 529
}  
# 530
if ((__n == __gnu_cxx::__numeric_traits_integer< long> ::__max) && (!traits_type::eq_int_type(__c, __eof))) 
# 532
{ 
# 533
(_M_gcount) = __gnu_cxx::__numeric_traits_integer< long> ::__min; 
# 535
__large_ignore = true; 
# 536
} else { 
# 538
break; }  
# 539
}  
# 541
if (__large_ignore) { 
# 542
(_M_gcount) = __gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 544
if (traits_type::eq_int_type(__c, __eof)) { 
# 545
(__err |= std::ios_base::eofbit); }  
# 546
} 
# 547
catch (__cxxabiv1::__forced_unwind &) 
# 548
{ 
# 549
this->_M_setstate(ios_base::badbit); 
# 550
throw; 
# 551
} 
# 552
catch (...) 
# 553
{ this->_M_setstate(ios_base::badbit); }  
# 554
if (__err) { 
# 555
this->setstate(__err); }  
# 556
}  
# 557
return *this; 
# 558
} 
# 560
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 563
basic_istream< _CharT, _Traits> ::ignore(std::streamsize __n, int_type __delim) 
# 564
{ 
# 565
(_M_gcount) = (0); 
# 566
sentry __cerb(*this, true); 
# 567
if (__cerb && (__n > (0))) 
# 568
{ 
# 569
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 570
try 
# 571
{ 
# 572
const int_type __eof = traits_type::eof(); 
# 573
__streambuf_type *__sb = this->rdbuf(); 
# 574
int_type __c = __sb->sgetc(); 
# 577
bool __large_ignore = false; 
# 578
while (true) 
# 579
{ 
# 580
while (((_M_gcount) < __n) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __delim))) 
# 583
{ 
# 584
++(_M_gcount); 
# 585
__c = __sb->snextc(); 
# 586
}  
# 587
if ((__n == __gnu_cxx::__numeric_traits_integer< long> ::__max) && (!traits_type::eq_int_type(__c, __eof)) && (!traits_type::eq_int_type(__c, __delim))) 
# 590
{ 
# 591
(_M_gcount) = __gnu_cxx::__numeric_traits_integer< long> ::__min; 
# 593
__large_ignore = true; 
# 594
} else { 
# 596
break; }  
# 597
}  
# 599
if (__large_ignore) { 
# 600
(_M_gcount) = __gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 602
if (traits_type::eq_int_type(__c, __eof)) { 
# 603
(__err |= std::ios_base::eofbit); } else { 
# 604
if (traits_type::eq_int_type(__c, __delim)) 
# 605
{ 
# 606
if ((_M_gcount) < __gnu_cxx::__numeric_traits_integer< long> ::__max) { 
# 608
++(_M_gcount); }  
# 609
__sb->sbumpc(); 
# 610
}  }  
# 611
} 
# 612
catch (__cxxabiv1::__forced_unwind &) 
# 613
{ 
# 614
this->_M_setstate(ios_base::badbit); 
# 615
throw; 
# 616
} 
# 617
catch (...) 
# 618
{ this->_M_setstate(ios_base::badbit); }  
# 619
if (__err) { 
# 620
this->setstate(__err); }  
# 621
}  
# 622
return *this; 
# 623
} 
# 625
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::int_type 
# 628
basic_istream< _CharT, _Traits> ::peek() 
# 629
{ 
# 630
int_type __c = traits_type::eof(); 
# 631
(_M_gcount) = (0); 
# 632
sentry __cerb(*this, true); 
# 633
if (__cerb) 
# 634
{ 
# 635
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 636
try 
# 637
{ 
# 638
__c = this->rdbuf()->sgetc(); 
# 639
if (traits_type::eq_int_type(__c, traits_type::eof())) { 
# 640
(__err |= std::ios_base::eofbit); }  
# 641
} 
# 642
catch (__cxxabiv1::__forced_unwind &) 
# 643
{ 
# 644
this->_M_setstate(ios_base::badbit); 
# 645
throw; 
# 646
} 
# 647
catch (...) 
# 648
{ this->_M_setstate(ios_base::badbit); }  
# 649
if (__err) { 
# 650
this->setstate(__err); }  
# 651
}  
# 652
return __c; 
# 653
} 
# 655
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 658
basic_istream< _CharT, _Traits> ::read(char_type *__s, std::streamsize __n) 
# 659
{ 
# 660
(_M_gcount) = (0); 
# 661
sentry __cerb(*this, true); 
# 662
if (__cerb) 
# 663
{ 
# 664
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 665
try 
# 666
{ 
# 667
(_M_gcount) = this->rdbuf()->sgetn(__s, __n); 
# 668
if ((_M_gcount) != __n) { 
# 669
(__err |= ((std::ios_base::eofbit | std::ios_base::failbit))); }  
# 670
} 
# 671
catch (__cxxabiv1::__forced_unwind &) 
# 672
{ 
# 673
this->_M_setstate(ios_base::badbit); 
# 674
throw; 
# 675
} 
# 676
catch (...) 
# 677
{ this->_M_setstate(ios_base::badbit); }  
# 678
if (__err) { 
# 679
this->setstate(__err); }  
# 680
}  
# 681
return *this; 
# 682
} 
# 684
template< class _CharT, class _Traits> streamsize 
# 687
basic_istream< _CharT, _Traits> ::readsome(char_type *__s, std::streamsize __n) 
# 688
{ 
# 689
(_M_gcount) = (0); 
# 690
sentry __cerb(*this, true); 
# 691
if (__cerb) 
# 692
{ 
# 693
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 694
try 
# 695
{ 
# 697
const std::streamsize __num = this->rdbuf()->in_avail(); 
# 698
if (__num > (0)) { 
# 699
(_M_gcount) = this->rdbuf()->sgetn(__s, std::min(__num, __n)); } else { 
# 700
if (__num == (-1)) { 
# 701
(__err |= std::ios_base::eofbit); }  }  
# 702
} 
# 703
catch (__cxxabiv1::__forced_unwind &) 
# 704
{ 
# 705
this->_M_setstate(ios_base::badbit); 
# 706
throw; 
# 707
} 
# 708
catch (...) 
# 709
{ this->_M_setstate(ios_base::badbit); }  
# 710
if (__err) { 
# 711
this->setstate(__err); }  
# 712
}  
# 713
return _M_gcount; 
# 714
} 
# 716
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 719
basic_istream< _CharT, _Traits> ::putback(char_type __c) 
# 720
{ 
# 723
(_M_gcount) = (0); 
# 725
this->clear(this->rdstate() & (~std::ios_base::eofbit)); 
# 726
sentry __cerb(*this, true); 
# 727
if (__cerb) 
# 728
{ 
# 729
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 730
try 
# 731
{ 
# 732
const int_type __eof = traits_type::eof(); 
# 733
__streambuf_type *__sb = this->rdbuf(); 
# 734
if ((!__sb) || traits_type::eq_int_type(__sb->sputbackc(__c), __eof)) { 
# 736
(__err |= std::ios_base::badbit); }  
# 737
} 
# 738
catch (__cxxabiv1::__forced_unwind &) 
# 739
{ 
# 740
this->_M_setstate(ios_base::badbit); 
# 741
throw; 
# 742
} 
# 743
catch (...) 
# 744
{ this->_M_setstate(ios_base::badbit); }  
# 745
if (__err) { 
# 746
this->setstate(__err); }  
# 747
}  
# 748
return *this; 
# 749
} 
# 751
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::__istream_type &
# 754
basic_istream< _CharT, _Traits> ::unget() 
# 755
{ 
# 758
(_M_gcount) = (0); 
# 760
this->clear(this->rdstate() & (~std::ios_base::eofbit)); 
# 761
sentry __cerb(*this, true); 
# 762
if (__cerb) 
# 763
{ 
# 764
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 765
try 
# 766
{ 
# 767
const int_type __eof = traits_type::eof(); 
# 768
__streambuf_type *__sb = this->rdbuf(); 
# 769
if ((!__sb) || traits_type::eq_int_type(__sb->sungetc(), __eof)) { 
# 771
(__err |= std::ios_base::badbit); }  
# 772
} 
# 773
catch (__cxxabiv1::__forced_unwind &) 
# 774
{ 
# 775
this->_M_setstate(ios_base::badbit); 
# 776
throw; 
# 777
} 
# 778
catch (...) 
# 779
{ this->_M_setstate(ios_base::badbit); }  
# 780
if (__err) { 
# 781
this->setstate(__err); }  
# 782
}  
# 783
return *this; 
# 784
} 
# 786
template< class _CharT, class _Traits> int 
# 789
basic_istream< _CharT, _Traits> ::sync() 
# 790
{ 
# 793
int __ret = (-1); 
# 794
sentry __cerb(*this, true); 
# 795
if (__cerb) 
# 796
{ 
# 797
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 798
try 
# 799
{ 
# 800
__streambuf_type *__sb = this->rdbuf(); 
# 801
if (__sb) 
# 802
{ 
# 803
if (__sb->pubsync() == (-1)) { 
# 804
(__err |= std::ios_base::badbit); } else { 
# 806
__ret = 0; }  
# 807
}  
# 808
} 
# 809
catch (__cxxabiv1::__forced_unwind &) 
# 810
{ 
# 811
this->_M_setstate(ios_base::badbit); 
# 812
throw; 
# 813
} 
# 814
catch (...) 
# 815
{ this->_M_setstate(ios_base::badbit); }  
# 816
if (__err) { 
# 817
this->setstate(__err); }  
# 818
}  
# 819
return __ret; 
# 820
} 
# 822
template< class _CharT, class _Traits> typename basic_istream< _CharT, _Traits> ::pos_type 
# 825
basic_istream< _CharT, _Traits> ::tellg() 
# 826
{ 
# 829
pos_type __ret = ((pos_type)(-1)); 
# 830
sentry __cerb(*this, true); 
# 831
if (__cerb) 
# 832
{ 
# 833
try 
# 834
{ 
# 835
if (!this->fail()) { 
# 836
__ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in); }  
# 838
} 
# 839
catch (__cxxabiv1::__forced_unwind &) 
# 840
{ 
# 841
this->_M_setstate(ios_base::badbit); 
# 842
throw; 
# 843
} 
# 844
catch (...) 
# 845
{ this->_M_setstate(ios_base::badbit); }  
# 846
}  
# 847
return __ret; 
# 848
} 
# 850
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 853
basic_istream< _CharT, _Traits> ::seekg(pos_type __pos) 
# 854
{ 
# 858
this->clear(this->rdstate() & (~std::ios_base::eofbit)); 
# 859
sentry __cerb(*this, true); 
# 860
if (__cerb) 
# 861
{ 
# 862
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 863
try 
# 864
{ 
# 865
if (!this->fail()) 
# 866
{ 
# 868
const pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in); 
# 872
if (__p == ((pos_type)((off_type)(-1)))) { 
# 873
(__err |= std::ios_base::failbit); }  
# 874
}  
# 875
} 
# 876
catch (__cxxabiv1::__forced_unwind &) 
# 877
{ 
# 878
this->_M_setstate(ios_base::badbit); 
# 879
throw; 
# 880
} 
# 881
catch (...) 
# 882
{ this->_M_setstate(ios_base::badbit); }  
# 883
if (__err) { 
# 884
this->setstate(__err); }  
# 885
}  
# 886
return *this; 
# 887
} 
# 889
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 892
basic_istream< _CharT, _Traits> ::seekg(off_type __off, std::ios_base::seekdir __dir) 
# 893
{ 
# 897
this->clear(this->rdstate() & (~std::ios_base::eofbit)); 
# 898
sentry __cerb(*this, true); 
# 899
if (__cerb) 
# 900
{ 
# 901
std::ios_base::iostate __err = std::ios_base::goodbit; 
# 902
try 
# 903
{ 
# 904
if (!this->fail()) 
# 905
{ 
# 907
const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::in); 
# 911
if (__p == ((pos_type)((off_type)(-1)))) { 
# 912
(__err |= std::ios_base::failbit); }  
# 913
}  
# 914
} 
# 915
catch (__cxxabiv1::__forced_unwind &) 
# 916
{ 
# 917
this->_M_setstate(ios_base::badbit); 
# 918
throw; 
# 919
} 
# 920
catch (...) 
# 921
{ this->_M_setstate(ios_base::badbit); }  
# 922
if (__err) { 
# 923
this->setstate(__err); }  
# 924
}  
# 925
return *this; 
# 926
} 
# 929
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 931
operator>>(basic_istream< _CharT, _Traits>  &__in, _CharT &__c) 
# 932
{ 
# 933
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 934
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 936
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 937
if (__cerb) 
# 938
{ 
# 939
ios_base::iostate __err = ios_base::goodbit; 
# 940
try 
# 941
{ 
# 942
const __int_type __cb = __in.rdbuf()->sbumpc(); 
# 943
if (!_Traits::eq_int_type(__cb, _Traits::eof())) { 
# 944
__c = _Traits::to_char_type(__cb); } else { 
# 946
(__err |= ((ios_base::eofbit | ios_base::failbit))); }  
# 947
} 
# 948
catch (__cxxabiv1::__forced_unwind &) 
# 949
{ 
# 950
__in._M_setstate(ios_base::badbit); 
# 951
throw; 
# 952
} 
# 953
catch (...) 
# 954
{ __in._M_setstate(ios_base::badbit); }  
# 955
if (__err) { 
# 956
__in.setstate(__err); }  
# 957
}  
# 958
return __in; 
# 959
} 
# 961
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 963
operator>>(basic_istream< _CharT, _Traits>  &__in, _CharT *__s) 
# 964
{ 
# 965
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 966
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 967
typedef typename _Traits::int_type int_type; 
# 968
typedef _CharT char_type; 
# 969
typedef ctype< _CharT>  __ctype_type; 
# 971
streamsize __extracted = (0); 
# 972
ios_base::iostate __err = ios_base::goodbit; 
# 973
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__in, false); 
# 974
if (__cerb) 
# 975
{ 
# 976
try 
# 977
{ 
# 979
streamsize __num = __in.width(); 
# 980
if (__num <= (0)) { 
# 981
__num = __gnu_cxx::__numeric_traits_integer< long> ::__max; }  
# 983
const __ctype_type &__ct = use_facet< ctype< _CharT> > (__in.getloc()); 
# 985
const int_type __eof = _Traits::eof(); 
# 986
__streambuf_type *__sb = __in.rdbuf(); 
# 987
int_type __c = __sb->sgetc(); 
# 989
while ((__extracted < (__num - (1))) && (!_Traits::eq_int_type(__c, __eof)) && (!__ct.is(ctype_base::space, _Traits::to_char_type(__c)))) 
# 993
{ 
# 994
(*(__s++)) = _Traits::to_char_type(__c); 
# 995
++__extracted; 
# 996
__c = __sb->snextc(); 
# 997
}  
# 998
if (_Traits::eq_int_type(__c, __eof)) { 
# 999
(__err |= ios_base::eofbit); }  
# 1003
(*__s) = char_type(); 
# 1004
__in.width(0); 
# 1005
} 
# 1006
catch (__cxxabiv1::__forced_unwind &) 
# 1007
{ 
# 1008
__in._M_setstate(ios_base::badbit); 
# 1009
throw; 
# 1010
} 
# 1011
catch (...) 
# 1012
{ __in._M_setstate(ios_base::badbit); }  
# 1013
}  
# 1014
if (!__extracted) { 
# 1015
(__err |= ios_base::failbit); }  
# 1016
if (__err) { 
# 1017
__in.setstate(__err); }  
# 1018
return __in; 
# 1019
} 
# 1022
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 1024
ws(basic_istream< _CharT, _Traits>  &__in) 
# 1025
{ 
# 1026
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 1027
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 1028
typedef typename basic_istream< _CharT, _Traits> ::int_type __int_type; 
# 1029
typedef ctype< _CharT>  __ctype_type; 
# 1031
const __ctype_type &__ct = use_facet< ctype< _CharT> > (__in.getloc()); 
# 1032
const __int_type __eof = _Traits::eof(); 
# 1033
__streambuf_type *__sb = __in.rdbuf(); 
# 1034
__int_type __c = __sb->sgetc(); 
# 1036
while ((!_Traits::eq_int_type(__c, __eof)) && __ct.is(ctype_base::space, _Traits::to_char_type(__c))) { 
# 1038
__c = __sb->snextc(); }  
# 1040
if (_Traits::eq_int_type(__c, __eof)) { 
# 1041
__in.setstate(ios_base::eofbit); }  
# 1042
return __in; 
# 1043
} 
# 1048
extern template class basic_istream< char> ;
# 1049
extern template basic_istream< char>  &ws(basic_istream< char>  & __is);
# 1050
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, char & __c);
# 1051
extern template basic_istream< char>  &operator>>(basic_istream< char>  &, char *);
# 1052
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, unsigned char & __c);
# 1053
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, signed char & __c);
# 1054
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, unsigned char * __s);
# 1055
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, signed char * __s);
# 1057
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(unsigned short & __v);
# 1058
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(unsigned & __v);
# 1059
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(long & __v);
# 1060
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(unsigned long & __v);
# 1061
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(bool & __v);
# 1063
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(long long & __v);
# 1064
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(unsigned long long & __v);
# 1066
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(float & __v);
# 1067
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(double & __v);
# 1068
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(long double & __v);
# 1069
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(void *& __v);
# 1071
extern template class basic_iostream< char> ;
# 1074
extern template class basic_istream< wchar_t> ;
# 1075
extern template basic_istream< wchar_t>  &ws(basic_istream< wchar_t>  & __is);
# 1076
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __in, wchar_t & __c);
# 1077
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  &, wchar_t *);
# 1079
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(unsigned short & __v);
# 1080
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(unsigned & __v);
# 1081
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(long & __v);
# 1082
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(unsigned long & __v);
# 1083
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(bool & __v);
# 1085
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(long long & __v);
# 1086
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(unsigned long long & __v);
# 1088
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(float & __v);
# 1089
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(double & __v);
# 1090
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(long double & __v);
# 1091
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(void *& __v);
# 1093
extern template class basic_iostream< wchar_t> ;
# 1098
}
# 42 "/usr/include/c++/9/iostream" 3
namespace std __attribute((__visibility__("default"))) { 
# 60 "/usr/include/c++/9/iostream" 3
extern istream cin; 
# 61
extern ostream cout; 
# 62
extern ostream cerr; 
# 63
extern ostream clog; 
# 66
extern wistream wcin; 
# 67
extern wostream wcout; 
# 68
extern wostream wcerr; 
# 69
extern wostream wclog; 
# 74
static ios_base::Init __ioinit; 
# 77
}
# 52 "/usr/include/c++/9/cstddef" 3
extern "C++" {
# 55
namespace std { 
# 58
using ::max_align_t;
# 59
}
# 197 "/usr/include/c++/9/cstddef" 3
}
# 38 "/usr/include/opencv4/opencv2/core/hal/interface.h" 3
extern "C" { typedef uint32_t uint; }
# 48 "/usr/include/opencv4/opencv2/core/hal/interface.h" 3
typedef signed char schar; 
# 51
typedef unsigned char uchar; 
# 52
extern "C" { typedef unsigned short ushort; }
# 61 "/usr/include/opencv4/opencv2/core/hal/interface.h" 3
typedef int64_t int64; 
# 62
typedef uint64_t uint64; 
# 272 "/usr/include/opencv4/opencv2/core/cvdef.h" 3
enum CpuFeatures { 
# 273
CPU_MMX = 1, 
# 274
CPU_SSE, 
# 275
CPU_SSE2, 
# 276
CPU_SSE3, 
# 277
CPU_SSSE3, 
# 278
CPU_SSE4_1, 
# 279
CPU_SSE4_2, 
# 280
CPU_POPCNT, 
# 281
CPU_FP16, 
# 282
CPU_AVX, 
# 283
CPU_AVX2, 
# 284
CPU_FMA3, 
# 286
CPU_AVX_512F, 
# 287
CPU_AVX_512BW, 
# 288
CPU_AVX_512CD, 
# 289
CPU_AVX_512DQ, 
# 290
CPU_AVX_512ER, 
# 291
CPU_AVX_512IFMA512, 
# 292
CPU_AVX_512IFMA = 18, 
# 293
CPU_AVX_512PF, 
# 294
CPU_AVX_512VBMI, 
# 295
CPU_AVX_512VL, 
# 296
CPU_AVX_512VBMI2, 
# 297
CPU_AVX_512VNNI, 
# 298
CPU_AVX_512BITALG, 
# 299
CPU_AVX_512VPOPCNTDQ, 
# 300
CPU_AVX_5124VNNIW, 
# 301
CPU_AVX_5124FMAPS, 
# 303
CPU_NEON = 100, 
# 305
CPU_MSA = 150, 
# 307
CPU_VSX = 200, 
# 308
CPU_VSX3, 
# 310
CPU_AVX512_SKX = 256, 
# 311
CPU_AVX512_COMMON, 
# 312
CPU_AVX512_KNL, 
# 313
CPU_AVX512_KNM, 
# 314
CPU_AVX512_CNL, 
# 315
CPU_AVX512_CLX, 
# 316
CPU_AVX512_ICL, 
# 318
CPU_MAX_FEATURE = 512
# 319
}; 
# 345 "/usr/include/opencv4/opencv2/core/cvdef.h" 3
typedef 
# 337
union Cv16suf { 
# 339
short i; 
# 340
ushort u; 
# 345
} Cv16suf; 
# 353
typedef 
# 347
union Cv32suf { 
# 349
int i; 
# 350
unsigned u; 
# 351
float f; 
# 353
} Cv32suf; 
# 361
typedef 
# 355
union Cv64suf { 
# 357
int64 i; 
# 358
uint64 u; 
# 359
double f; 
# 361
} Cv64suf; 
# 67 "/usr/include/c++/9/bits/stl_relops.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
namespace rel_ops { 
# 85 "/usr/include/c++/9/bits/stl_relops.h" 3
template< class _Tp> inline bool 
# 87
operator!=(const _Tp &__x, const _Tp &__y) 
# 88
{ return !(__x == __y); } 
# 98 "/usr/include/c++/9/bits/stl_relops.h" 3
template< class _Tp> inline bool 
# 100
operator>(const _Tp &__x, const _Tp &__y) 
# 101
{ return __y < __x; } 
# 111 "/usr/include/c++/9/bits/stl_relops.h" 3
template< class _Tp> inline bool 
# 113
operator<=(const _Tp &__x, const _Tp &__y) 
# 114
{ return !(__y < __x); } 
# 124 "/usr/include/c++/9/bits/stl_relops.h" 3
template< class _Tp> inline bool 
# 126
operator>=(const _Tp &__x, const _Tp &__y) 
# 127
{ return !(__x < __y); } 
# 128
}
# 131
}
# 78 "/usr/include/c++/9/utility" 3
namespace std __attribute((__visibility__("default"))) { 
# 83
template< class _Tp> struct tuple_size; 
# 90
template< class _Tp, class 
# 91
_Up = typename remove_cv< _Tp> ::type, class 
# 92
 = typename enable_if< is_same< _Tp, _Up> ::value> ::type, size_t 
# 93
 = tuple_size< _Tp> ::value> using __enable_if_has_tuple_size = _Tp; 
# 96
template< class _Tp> 
# 97
struct tuple_size< const __enable_if_has_tuple_size< _Tp> >  : public std::tuple_size< _Tp>  { 
# 98
}; 
# 100
template< class _Tp> 
# 101
struct tuple_size< volatile __enable_if_has_tuple_size< _Tp> >  : public std::tuple_size< _Tp>  { 
# 102
}; 
# 104
template< class _Tp> 
# 105
struct tuple_size< const volatile __enable_if_has_tuple_size< _Tp> >  : public std::tuple_size< _Tp>  { 
# 106
}; 
# 109
template< size_t __i, class _Tp> struct tuple_element; 
# 113
template< size_t __i, class _Tp> using __tuple_element_t = typename tuple_element< __i, _Tp> ::type; 
# 116
template< size_t __i, class _Tp> 
# 117
struct tuple_element< __i, const _Tp>  { 
# 119
typedef typename add_const< __tuple_element_t< __i, _Tp> > ::type type; 
# 120
}; 
# 122
template< size_t __i, class _Tp> 
# 123
struct tuple_element< __i, volatile _Tp>  { 
# 125
typedef typename add_volatile< __tuple_element_t< __i, _Tp> > ::type type; 
# 126
}; 
# 128
template< size_t __i, class _Tp> 
# 129
struct tuple_element< __i, const volatile _Tp>  { 
# 131
typedef typename add_cv< __tuple_element_t< __i, _Tp> > ::type type; 
# 132
}; 
# 140
template< size_t __i, class _Tp> using tuple_element_t = typename tuple_element< __i, _Tp> ::type; 
# 147
template< class _T1, class _T2> 
# 148
struct __is_tuple_like_impl< pair< _T1, _T2> >  : public true_type { 
# 149
}; 
# 152
template< class _Tp1, class _Tp2> 
# 153
struct tuple_size< pair< _Tp1, _Tp2> >  : public integral_constant< unsigned long, 2UL>  { 
# 154
}; 
# 157
template< class _Tp1, class _Tp2> 
# 158
struct tuple_element< 0, pair< _Tp1, _Tp2> >  { 
# 159
typedef _Tp1 type; }; 
# 162
template< class _Tp1, class _Tp2> 
# 163
struct tuple_element< 1, pair< _Tp1, _Tp2> >  { 
# 164
typedef _Tp2 type; }; 
# 166
template< size_t _Int> struct __pair_get; 
# 170
template<> struct __pair_get< 0UL>  { 
# 172
template< class _Tp1, class _Tp2> static constexpr _Tp1 &
# 174
__get(pair< _Tp1, _Tp2>  &__pair) noexcept 
# 175
{ return __pair.first; } 
# 177
template< class _Tp1, class _Tp2> static constexpr _Tp1 &&
# 179
__move_get(pair< _Tp1, _Tp2>  &&__pair) noexcept 
# 180
{ return std::forward< _Tp1> ((__pair.first)); } 
# 182
template< class _Tp1, class _Tp2> static constexpr const _Tp1 &
# 184
__const_get(const pair< _Tp1, _Tp2>  &__pair) noexcept 
# 185
{ return __pair.first; } 
# 187
template< class _Tp1, class _Tp2> static constexpr const _Tp1 &&
# 189
__const_move_get(const pair< _Tp1, _Tp2>  &&__pair) noexcept 
# 190
{ return std::forward< const _Tp1> ((__pair.first)); } 
# 191
}; 
# 194
template<> struct __pair_get< 1UL>  { 
# 196
template< class _Tp1, class _Tp2> static constexpr _Tp2 &
# 198
__get(pair< _Tp1, _Tp2>  &__pair) noexcept 
# 199
{ return __pair.second; } 
# 201
template< class _Tp1, class _Tp2> static constexpr _Tp2 &&
# 203
__move_get(pair< _Tp1, _Tp2>  &&__pair) noexcept 
# 204
{ return std::forward< _Tp2> ((__pair.second)); } 
# 206
template< class _Tp1, class _Tp2> static constexpr const _Tp2 &
# 208
__const_get(const pair< _Tp1, _Tp2>  &__pair) noexcept 
# 209
{ return __pair.second; } 
# 211
template< class _Tp1, class _Tp2> static constexpr const _Tp2 &&
# 213
__const_move_get(const pair< _Tp1, _Tp2>  &&__pair) noexcept 
# 214
{ return std::forward< const _Tp2> ((__pair.second)); } 
# 215
}; 
# 217
template< size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element< _Int, pair< _Tp1, _Tp2> > ::type &
# 219
get(pair< _Tp1, _Tp2>  &__in) noexcept 
# 220
{ return __pair_get< _Int> ::__get(__in); } 
# 222
template< size_t _Int, class _Tp1, class _Tp2> constexpr typename tuple_element< _Int, pair< _Tp1, _Tp2> > ::type &&
# 224
get(pair< _Tp1, _Tp2>  &&__in) noexcept 
# 225
{ return __pair_get< _Int> ::__move_get(std::move(__in)); } 
# 227
template< size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element< _Int, pair< _Tp1, _Tp2> > ::type &
# 229
get(const pair< _Tp1, _Tp2>  &__in) noexcept 
# 230
{ return __pair_get< _Int> ::__const_get(__in); } 
# 232
template< size_t _Int, class _Tp1, class _Tp2> constexpr const typename tuple_element< _Int, pair< _Tp1, _Tp2> > ::type &&
# 234
get(const pair< _Tp1, _Tp2>  &&__in) noexcept 
# 235
{ return __pair_get< _Int> ::__const_move_get(std::move(__in)); } 
# 241
template< class _Tp, class _Up> constexpr _Tp &
# 243
get(pair< _Tp, _Up>  &__p) noexcept 
# 244
{ return __p.first; } 
# 246
template< class _Tp, class _Up> constexpr const _Tp &
# 248
get(const pair< _Tp, _Up>  &__p) noexcept 
# 249
{ return __p.first; } 
# 251
template< class _Tp, class _Up> constexpr _Tp &&
# 253
get(pair< _Tp, _Up>  &&__p) noexcept 
# 254
{ return std::move((__p.first)); } 
# 256
template< class _Tp, class _Up> constexpr const _Tp &&
# 258
get(const pair< _Tp, _Up>  &&__p) noexcept 
# 259
{ return std::move((__p.first)); } 
# 261
template< class _Tp, class _Up> constexpr _Tp &
# 263
get(pair< _Up, _Tp>  &__p) noexcept 
# 264
{ return __p.second; } 
# 266
template< class _Tp, class _Up> constexpr const _Tp &
# 268
get(const pair< _Up, _Tp>  &__p) noexcept 
# 269
{ return __p.second; } 
# 271
template< class _Tp, class _Up> constexpr _Tp &&
# 273
get(pair< _Up, _Tp>  &&__p) noexcept 
# 274
{ return std::move((__p.second)); } 
# 276
template< class _Tp, class _Up> constexpr const _Tp &&
# 278
get(const pair< _Up, _Tp>  &&__p) noexcept 
# 279
{ return std::move((__p.second)); } 
# 284
template< class _Tp, class _Up = _Tp> inline _Tp 
# 286
exchange(_Tp &__obj, _Up &&__new_val) 
# 287
{ return std::__exchange(__obj, std::forward< _Up> (__new_val)); } 
# 292
template< size_t ..._Indexes> struct _Index_tuple { }; 
# 301 "/usr/include/c++/9/utility" 3
template< size_t _Num> 
# 302
struct _Build_index_tuple { 
# 310
using __type = _Index_tuple< __integer_pack(_Num)...> ; 
# 312
}; 
# 319
template< class _Tp, _Tp ..._Idx> 
# 320
struct integer_sequence { 
# 322
typedef _Tp value_type; 
# 323
static constexpr size_t size() noexcept { return sizeof...(_Idx); } 
# 324
}; 
# 327
template< class _Tp, _Tp _Num> using make_integer_sequence = integer_sequence< _Tp, __integer_pack(_Num)...> ; 
# 338
template< size_t ..._Idx> using index_sequence = integer_sequence< unsigned long, _Idx...> ; 
# 342
template< size_t _Num> using make_index_sequence = make_integer_sequence< unsigned long, _Num> ; 
# 346
template< class ..._Types> using index_sequence_for = make_index_sequence< sizeof...(_Types)> ; 
# 397 "/usr/include/c++/9/utility" 3
}
# 43 "/usr/include/c++/9/array" 3
namespace std __attribute((__visibility__("default"))) { 
# 47
template< class _Tp, size_t _Nm> 
# 48
struct __array_traits { 
# 50
typedef _Tp _Type[_Nm]; 
# 51
typedef __is_swappable< _Tp>  _Is_swappable; 
# 52
typedef __is_nothrow_swappable< _Tp>  _Is_nothrow_swappable; 
# 55
static constexpr _Tp &_S_ref(const _Type &__t, size_t __n) noexcept 
# 56
{ return const_cast< _Tp &>(__t[__n]); } 
# 59
static constexpr _Tp *_S_ptr(const _Type &__t) noexcept 
# 60
{ return const_cast< _Tp *>(__t); } 
# 61
}; 
# 63
template< class _Tp> 
# 64
struct __array_traits< _Tp, 0>  { 
# 66
struct _Type { }; 
# 67
typedef true_type _Is_swappable; 
# 68
typedef true_type _Is_nothrow_swappable; 
# 71
static constexpr _Tp &_S_ref(const _Type &, size_t) noexcept 
# 72
{ return *(static_cast< _Tp *>(nullptr)); } 
# 75
static constexpr _Tp *_S_ptr(const _Type &) noexcept 
# 76
{ return nullptr; } 
# 77
}; 
# 93 "/usr/include/c++/9/array" 3
template< class _Tp, size_t _Nm> 
# 94
struct array { 
# 96
typedef _Tp value_type; 
# 97
typedef value_type *pointer; 
# 98
typedef const value_type *const_pointer; 
# 99
typedef value_type &reference; 
# 100
typedef const value_type &const_reference; 
# 101
typedef value_type *iterator; 
# 102
typedef const value_type *const_iterator; 
# 103
typedef size_t size_type; 
# 104
typedef ptrdiff_t difference_type; 
# 105
typedef std::reverse_iterator< iterator>  reverse_iterator; 
# 106
typedef std::reverse_iterator< const_iterator>  const_reverse_iterator; 
# 109
typedef __array_traits< _Tp, _Nm>  _AT_Type; 
# 110
typename __array_traits< _Tp, _Nm> ::_Type _M_elems; 
# 116
void fill(const value_type &__u) 
# 117
{ std::fill_n(begin(), size(), __u); } 
# 120
void swap(array &__other) noexcept(_AT_Type::_Is_nothrow_swappable::value) 
# 122
{ std::swap_ranges(begin(), end(), __other.begin()); } 
# 126
iterator begin() noexcept 
# 127
{ return (iterator)data(); } 
# 130
const_iterator begin() const noexcept 
# 131
{ return (const_iterator)data(); } 
# 134
iterator end() noexcept 
# 135
{ return (iterator)(data() + _Nm); } 
# 138
const_iterator end() const noexcept 
# 139
{ return (const_iterator)(data() + _Nm); } 
# 142
reverse_iterator rbegin() noexcept 
# 143
{ return ((std::reverse_iterator< iterator> )(end())); } 
# 146
const_reverse_iterator rbegin() const noexcept 
# 147
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 150
reverse_iterator rend() noexcept 
# 151
{ return ((std::reverse_iterator< iterator> )(begin())); } 
# 154
const_reverse_iterator rend() const noexcept 
# 155
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 158
const_iterator cbegin() const noexcept 
# 159
{ return (const_iterator)data(); } 
# 162
const_iterator cend() const noexcept 
# 163
{ return (const_iterator)(data() + _Nm); } 
# 166
const_reverse_iterator crbegin() const noexcept 
# 167
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 170
const_reverse_iterator crend() const noexcept 
# 171
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 175
constexpr size_type size() const noexcept { return _Nm; } 
# 178
constexpr size_type max_size() const noexcept { return _Nm; } 
# 181
constexpr bool empty() const noexcept { return size() == 0; } 
# 185
reference operator[](size_type __n) noexcept 
# 186
{ return _AT_Type::_S_ref(_M_elems, __n); } 
# 189
constexpr const_reference operator[](size_type __n) const noexcept 
# 190
{ return _AT_Type::_S_ref(_M_elems, __n); } 
# 193
reference at(size_type __n) 
# 194
{ 
# 195
if (__n >= _Nm) { 
# 196
std::__throw_out_of_range_fmt("array::at: __n (which is %zu) >= _Nm (which is %zu)", __n, _Nm); }  
# 199
return _AT_Type::_S_ref(_M_elems, __n); 
# 200
} 
# 203
constexpr const_reference at(size_type __n) const 
# 204
{ 
# 207
return (__n < _Nm) ? _AT_Type::_S_ref(_M_elems, __n) : (std::__throw_out_of_range_fmt("array::at: __n (which is %zu) >= _Nm (which is %zu)", __n, _Nm), _AT_Type::_S_ref(_M_elems, 0)); 
# 212
} 
# 215
reference front() noexcept 
# 216
{ return *begin(); } 
# 219
constexpr const_reference front() const noexcept 
# 220
{ return _AT_Type::_S_ref(_M_elems, 0); } 
# 223
reference back() noexcept 
# 224
{ return (_Nm) ? *(end() - 1) : (*end()); } 
# 227
constexpr const_reference back() const noexcept 
# 228
{ 
# 229
return (_Nm) ? _AT_Type::_S_ref(_M_elems, _Nm - (1)) : _AT_Type::_S_ref(_M_elems, 0); 
# 231
} 
# 234
pointer data() noexcept 
# 235
{ return _AT_Type::_S_ptr(_M_elems); } 
# 238
const_pointer data() const noexcept 
# 239
{ return _AT_Type::_S_ptr(_M_elems); } 
# 240
}; 
# 250 "/usr/include/c++/9/array" 3
template< class _Tp, size_t _Nm> inline bool 
# 252
operator==(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 253
{ return std::equal(__one.begin(), __one.end(), __two.begin()); } 
# 255
template< class _Tp, size_t _Nm> inline bool 
# 257
operator!=(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 258
{ return !(__one == __two); } 
# 260
template< class _Tp, size_t _Nm> inline bool 
# 262
operator<(const array< _Tp, _Nm>  &__a, const array< _Tp, _Nm>  &__b) 
# 263
{ 
# 264
return std::lexicographical_compare(__a.begin(), __a.end(), __b.begin(), __b.end()); 
# 266
} 
# 268
template< class _Tp, size_t _Nm> inline bool 
# 270
operator>(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 271
{ return __two < __one; } 
# 273
template< class _Tp, size_t _Nm> inline bool 
# 275
operator<=(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 276
{ return !(__one > __two); } 
# 278
template< class _Tp, size_t _Nm> inline bool 
# 280
operator>=(const array< _Tp, _Nm>  &__one, const array< _Tp, _Nm>  &__two) 
# 281
{ return !(__one < __two); } 
# 284
template< class _Tp, size_t _Nm> inline typename enable_if< __array_traits< _Tp, _Nm> ::_Is_swappable::value> ::type 
# 294
swap(array< _Tp, _Nm>  &__one, array< _Tp, _Nm>  &__two) noexcept(noexcept(__one.swap(__two))) 
# 296
{ __one.swap(__two); } 
# 299
template < typename _Tp, std :: size_t _Nm >
    typename enable_if <
      ! std :: __array_traits < _Tp, _Nm > :: _Is_swappable :: value > :: type
    swap ( array < _Tp, _Nm > &, array < _Tp, _Nm > & ) = delete;
# 305
template< size_t _Int, class _Tp, size_t _Nm> constexpr _Tp &
# 307
get(array< _Tp, _Nm>  &__arr) noexcept 
# 308
{ 
# 309
static_assert((_Int < _Nm), "array index is within bounds");
# 310
return std::template __array_traits< _Tp, _Nm> ::_S_ref((__arr._M_elems), _Int); 
# 312
} 
# 314
template< size_t _Int, class _Tp, size_t _Nm> constexpr _Tp &&
# 316
get(array< _Tp, _Nm>  &&__arr) noexcept 
# 317
{ 
# 318
static_assert((_Int < _Nm), "array index is within bounds");
# 319
return std::move(std::get< _Int> (__arr)); 
# 320
} 
# 322
template< size_t _Int, class _Tp, size_t _Nm> constexpr const _Tp &
# 324
get(const array< _Tp, _Nm>  &__arr) noexcept 
# 325
{ 
# 326
static_assert((_Int < _Nm), "array index is within bounds");
# 327
return std::template __array_traits< _Tp, _Nm> ::_S_ref((__arr._M_elems), _Int); 
# 329
} 
# 331
template< size_t _Int, class _Tp, size_t _Nm> constexpr const _Tp &&
# 333
get(const array< _Tp, _Nm>  &&__arr) noexcept 
# 334
{ 
# 335
static_assert((_Int < _Nm), "array index is within bounds");
# 336
return std::move(std::get< _Int> (__arr)); 
# 337
} 
# 340
}
# 342
namespace std __attribute((__visibility__("default"))) { 
# 349
template< class _Tp> struct tuple_size; 
# 353
template< class _Tp, size_t _Nm> 
# 354
struct tuple_size< array< _Tp, _Nm> >  : public integral_constant< unsigned long, _Nm>  { 
# 355
}; 
# 358
template< size_t _Int, class _Tp> struct tuple_element; 
# 362
template< size_t _Int, class _Tp, size_t _Nm> 
# 363
struct tuple_element< _Int, array< _Tp, _Nm> >  { 
# 365
static_assert((_Int < _Nm), "index is out of bounds");
# 366
typedef _Tp type; 
# 367
}; 
# 369
template< class _Tp, size_t _Nm> 
# 370
struct __is_tuple_like_impl< array< _Tp, _Nm> >  : public true_type { 
# 371
}; 
# 374
}
# 753 "/usr/include/opencv4/opencv2/core/cvdef.h" 3
namespace cv { 
# 754
using std::int8_t;
# 755
using std::uint8_t;
# 756
using std::int16_t;
# 757
using std::uint16_t;
# 758
using std::int32_t;
# 759
using std::uint32_t;
# 760
using std::int64_t;
# 761
using std::uint64_t;
# 762
}
# 781 "/usr/include/opencv4/opencv2/core/cvdef.h" 3
namespace cv { 
# 784
class float16_t { 
# 816 "/usr/include/opencv4/opencv2/core/cvdef.h" 3
public: float16_t() : w((0)) { } 
# 817
explicit float16_t(float x) 
# 818
{ 
# 823
Cv32suf in; 
# 824
(in.f) = x; 
# 825
unsigned sign = (in.u) & 2147483648U; 
# 826
(in.u) ^= sign; 
# 828
if ((in.u) >= (1199570944)) { 
# 829
(w) = ((ushort)(((in.u) > (2139095040)) ? 32256 : 31744)); } else 
# 831
{ 
# 832
if ((in.u) < (947912704)) 
# 833
{ 
# 834
(in.f) += (0.5F); 
# 835
(w) = ((ushort)((in.u) - (1056964608))); 
# 836
} else 
# 838
{ 
# 839
unsigned t = (in.u) + 3355447295U; 
# 840
(w) = ((ushort)((t + (((in.u) >> 13) & (1))) >> 13)); 
# 841
}  
# 842
}  
# 844
(w) = ((ushort)((w) | (sign >> 16))); 
# 846
} 
# 848
operator float() const 
# 849
{ 
# 855
Cv32suf out; 
# 857
unsigned t = (((w) & 32767) << 13) + 939524096; 
# 858
unsigned sign = ((w) & 32768) << 16; 
# 859
unsigned e = (w) & 31744; 
# 861
(out.u) = (t + (1 << 23)); 
# 862
(out.u) = (((e >= (31744)) ? t + (939524096) : ((e == (0)) ? (static_cast< void>((out.f) -= (6.1035156E-5F))), (out.u) : t)) | sign); 
# 864
return out.f; 
# 866
} 
# 868
static float16_t fromBits(ushort b) 
# 869
{ 
# 870
float16_t result; 
# 871
(result.w) = b; 
# 872
return result; 
# 873
} 
# 874
static float16_t zero() 
# 875
{ 
# 876
float16_t result; 
# 877
(result.w) = ((ushort)0); 
# 878
return result; 
# 879
} 
# 880
ushort bits() const { return w; } 
# 882
protected: ushort w; 
# 885
}; 
# 887
}
# 42 "/usr/include/c++/9/bits/algorithmfwd.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 195 "/usr/include/c++/9/bits/algorithmfwd.h" 3
template< class _IIter, class _Predicate> inline bool all_of(_IIter, _IIter, _Predicate); 
# 199
template< class _IIter, class _Predicate> inline bool any_of(_IIter, _IIter, _Predicate); 
# 204
template< class _FIter, class _Tp> bool binary_search(_FIter, _FIter, const _Tp &); 
# 208
template< class _FIter, class _Tp, class _Compare> bool binary_search(_FIter, _FIter, const _Tp &, _Compare); 
# 224 "/usr/include/c++/9/bits/algorithmfwd.h" 3
template< class _IIter, class _OIter> inline _OIter copy(_IIter, _IIter, _OIter); 
# 228
template< class _BIter1, class _BIter2> inline _BIter2 copy_backward(_BIter1, _BIter1, _BIter2); 
# 233
template< class _IIter, class _OIter, class _Predicate> _OIter copy_if(_IIter, _IIter, _OIter, _Predicate); 
# 237
template< class _IIter, class _Size, class _OIter> inline _OIter copy_n(_IIter, _Size, _OIter); 
# 245
template< class _FIter, class _Tp> inline pair< _FIter, _FIter>  equal_range(_FIter, _FIter, const _Tp &); 
# 249
template< class _FIter, class _Tp, class _Compare> inline pair< _FIter, _FIter>  equal_range(_FIter, _FIter, const _Tp &, _Compare); 
# 253
template< class _FIter, class _Tp> inline void fill(_FIter, _FIter, const _Tp &); 
# 257
template< class _OIter, class _Size, class _Tp> inline _OIter fill_n(_OIter, _Size, const _Tp &); 
# 263
template< class _FIter1, class _FIter2> inline _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2); 
# 267
template< class _FIter1, class _FIter2, class _BinaryPredicate> inline _FIter1 find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate); 
# 275
template< class _IIter, class _Predicate> inline _IIter find_if_not(_IIter, _IIter, _Predicate); 
# 284
template< class _IIter1, class _IIter2> inline bool includes(_IIter1, _IIter1, _IIter2, _IIter2); 
# 288
template< class _IIter1, class _IIter2, class _Compare> inline bool includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare); 
# 292
template< class _BIter> inline void inplace_merge(_BIter, _BIter, _BIter); 
# 296
template< class _BIter, class _Compare> inline void inplace_merge(_BIter, _BIter, _BIter, _Compare); 
# 301
template< class _RAIter> inline bool is_heap(_RAIter, _RAIter); 
# 305
template< class _RAIter, class _Compare> inline bool is_heap(_RAIter, _RAIter, _Compare); 
# 309
template< class _RAIter> inline _RAIter is_heap_until(_RAIter, _RAIter); 
# 313
template< class _RAIter, class _Compare> inline _RAIter is_heap_until(_RAIter, _RAIter, _Compare); 
# 317
template< class _IIter, class _Predicate> inline bool is_partitioned(_IIter, _IIter, _Predicate); 
# 321
template< class _FIter1, class _FIter2> inline bool is_permutation(_FIter1, _FIter1, _FIter2); 
# 325
template< class _FIter1, class _FIter2, class 
# 326
_BinaryPredicate> inline bool 
# 325
is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate); 
# 330
template< class _FIter> inline bool is_sorted(_FIter, _FIter); 
# 334
template< class _FIter, class _Compare> inline bool is_sorted(_FIter, _FIter, _Compare); 
# 338
template< class _FIter> inline _FIter is_sorted_until(_FIter, _FIter); 
# 342
template< class _FIter, class _Compare> inline _FIter is_sorted_until(_FIter, _FIter, _Compare); 
# 347
template< class _FIter1, class _FIter2> inline void iter_swap(_FIter1, _FIter2); 
# 351
template< class _FIter, class _Tp> inline _FIter lower_bound(_FIter, _FIter, const _Tp &); 
# 355
template< class _FIter, class _Tp, class _Compare> inline _FIter lower_bound(_FIter, _FIter, const _Tp &, _Compare); 
# 359
template< class _RAIter> inline void make_heap(_RAIter, _RAIter); 
# 363
template< class _RAIter, class _Compare> inline void make_heap(_RAIter, _RAIter, _Compare); 
# 367
template< class _Tp> constexpr const _Tp &max(const _Tp &, const _Tp &); 
# 372
template< class _Tp, class _Compare> constexpr const _Tp &max(const _Tp &, const _Tp &, _Compare); 
# 380
template< class _Tp> constexpr const _Tp &min(const _Tp &, const _Tp &); 
# 385
template< class _Tp, class _Compare> constexpr const _Tp &min(const _Tp &, const _Tp &, _Compare); 
# 393
template< class _Tp> constexpr pair< const _Tp &, const _Tp &>  minmax(const _Tp &, const _Tp &); 
# 398
template< class _Tp, class _Compare> constexpr pair< const _Tp &, const _Tp &>  minmax(const _Tp &, const _Tp &, _Compare); 
# 403
template< class _FIter> constexpr pair< _FIter, _FIter>  minmax_element(_FIter, _FIter); 
# 408
template< class _FIter, class _Compare> constexpr pair< _FIter, _FIter>  minmax_element(_FIter, _FIter, _Compare); 
# 413
template< class _Tp> constexpr _Tp min(initializer_list< _Tp> ); 
# 418
template< class _Tp, class _Compare> constexpr _Tp min(initializer_list< _Tp> , _Compare); 
# 423
template< class _Tp> constexpr _Tp max(initializer_list< _Tp> ); 
# 428
template< class _Tp, class _Compare> constexpr _Tp max(initializer_list< _Tp> , _Compare); 
# 433
template< class _Tp> constexpr pair< _Tp, _Tp>  minmax(initializer_list< _Tp> ); 
# 438
template< class _Tp, class _Compare> constexpr pair< _Tp, _Tp>  minmax(initializer_list< _Tp> , _Compare); 
# 446
template< class _BIter> inline bool next_permutation(_BIter, _BIter); 
# 450
template< class _BIter, class _Compare> inline bool next_permutation(_BIter, _BIter, _Compare); 
# 455
template< class _IIter, class _Predicate> inline bool none_of(_IIter, _IIter, _Predicate); 
# 463
template< class _IIter, class _RAIter> inline _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter); 
# 467
template< class _IIter, class _RAIter, class _Compare> inline _RAIter partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare); 
# 474
template< class _IIter, class _OIter1, class 
# 475
_OIter2, class _Predicate> pair< _OIter1, _OIter2>  
# 474
partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate); 
# 479
template< class _FIter, class _Predicate> _FIter partition_point(_FIter, _FIter, _Predicate); 
# 484
template< class _RAIter> inline void pop_heap(_RAIter, _RAIter); 
# 488
template< class _RAIter, class _Compare> inline void pop_heap(_RAIter, _RAIter, _Compare); 
# 492
template< class _BIter> inline bool prev_permutation(_BIter, _BIter); 
# 496
template< class _BIter, class _Compare> inline bool prev_permutation(_BIter, _BIter, _Compare); 
# 500
template< class _RAIter> inline void push_heap(_RAIter, _RAIter); 
# 504
template< class _RAIter, class _Compare> inline void push_heap(_RAIter, _RAIter, _Compare); 
# 510
template< class _FIter, class _Tp> inline _FIter remove(_FIter, _FIter, const _Tp &); 
# 514
template< class _FIter, class _Predicate> inline _FIter remove_if(_FIter, _FIter, _Predicate); 
# 518
template< class _IIter, class _OIter, class _Tp> inline _OIter remove_copy(_IIter, _IIter, _OIter, const _Tp &); 
# 522
template< class _IIter, class _OIter, class _Predicate> inline _OIter remove_copy_if(_IIter, _IIter, _OIter, _Predicate); 
# 528
template< class _IIter, class _OIter, class _Tp> inline _OIter replace_copy(_IIter, _IIter, _OIter, const _Tp &, const _Tp &); 
# 532
template< class _Iter, class _OIter, class _Predicate, class _Tp> inline _OIter replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp &); 
# 538
template< class _BIter> inline void reverse(_BIter, _BIter); 
# 542
template< class _BIter, class _OIter> _OIter reverse_copy(_BIter, _BIter, _OIter); 
# 546
inline namespace _V2 { 
# 548
template< class _FIter> inline _FIter rotate(_FIter, _FIter, _FIter); 
# 551
}
# 553
template< class _FIter, class _OIter> inline _OIter rotate_copy(_FIter, _FIter, _FIter, _OIter); 
# 565 "/usr/include/c++/9/bits/algorithmfwd.h" 3
template< class _RAIter, class _UGenerator> void shuffle(_RAIter, _RAIter, _UGenerator &&); 
# 570
template< class _RAIter> inline void sort_heap(_RAIter, _RAIter); 
# 574
template< class _RAIter, class _Compare> inline void sort_heap(_RAIter, _RAIter, _Compare); 
# 578
template< class _BIter, class _Predicate> inline _BIter stable_partition(_BIter, _BIter, _Predicate); 
# 594 "/usr/include/c++/9/bits/algorithmfwd.h" 3
template< class _FIter1, class _FIter2> _FIter2 swap_ranges(_FIter1, _FIter1, _FIter2); 
# 600
template< class _FIter> inline _FIter unique(_FIter, _FIter); 
# 604
template< class _FIter, class _BinaryPredicate> inline _FIter unique(_FIter, _FIter, _BinaryPredicate); 
# 610
template< class _FIter, class _Tp> inline _FIter upper_bound(_FIter, _FIter, const _Tp &); 
# 614
template< class _FIter, class _Tp, class _Compare> inline _FIter upper_bound(_FIter, _FIter, const _Tp &, _Compare); 
# 620
template< class _FIter> inline _FIter adjacent_find(_FIter, _FIter); 
# 624
template< class _FIter, class _BinaryPredicate> inline _FIter adjacent_find(_FIter, _FIter, _BinaryPredicate); 
# 628
template< class _IIter, class _Tp> inline typename iterator_traits< _IIter> ::difference_type count(_IIter, _IIter, const _Tp &); 
# 632
template< class _IIter, class _Predicate> inline typename iterator_traits< _IIter> ::difference_type count_if(_IIter, _IIter, _Predicate); 
# 636
template< class _IIter1, class _IIter2> inline bool equal(_IIter1, _IIter1, _IIter2); 
# 640
template< class _IIter1, class _IIter2, class _BinaryPredicate> inline bool equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate); 
# 644
template< class _IIter, class _Tp> inline _IIter find(_IIter, _IIter, const _Tp &); 
# 648
template< class _FIter1, class _FIter2> _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2); 
# 652
template< class _FIter1, class _FIter2, class _BinaryPredicate> _FIter1 find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate); 
# 656
template< class _IIter, class _Predicate> inline _IIter find_if(_IIter, _IIter, _Predicate); 
# 660
template< class _IIter, class _Funct> _Funct for_each(_IIter, _IIter, _Funct); 
# 664
template< class _FIter, class _Generator> void generate(_FIter, _FIter, _Generator); 
# 668
template< class _OIter, class _Size, class _Generator> _OIter generate_n(_OIter, _Size, _Generator); 
# 672
template< class _IIter1, class _IIter2> inline bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2); 
# 676
template< class _IIter1, class _IIter2, class _Compare> inline bool lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare); 
# 680
template< class _FIter> constexpr _FIter max_element(_FIter, _FIter); 
# 685
template< class _FIter, class _Compare> constexpr _FIter max_element(_FIter, _FIter, _Compare); 
# 690
template< class _IIter1, class _IIter2, class _OIter> inline _OIter merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 694
template< class _IIter1, class _IIter2, class _OIter, class 
# 695
_Compare> inline _OIter 
# 694
merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 699
template< class _FIter> constexpr _FIter min_element(_FIter, _FIter); 
# 704
template< class _FIter, class _Compare> constexpr _FIter min_element(_FIter, _FIter, _Compare); 
# 709
template< class _IIter1, class _IIter2> inline pair< _IIter1, _IIter2>  mismatch(_IIter1, _IIter1, _IIter2); 
# 713
template< class _IIter1, class _IIter2, class _BinaryPredicate> inline pair< _IIter1, _IIter2>  mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate); 
# 717
template< class _RAIter> inline void nth_element(_RAIter, _RAIter, _RAIter); 
# 721
template< class _RAIter, class _Compare> inline void nth_element(_RAIter, _RAIter, _RAIter, _Compare); 
# 725
template< class _RAIter> inline void partial_sort(_RAIter, _RAIter, _RAIter); 
# 729
template< class _RAIter, class _Compare> inline void partial_sort(_RAIter, _RAIter, _RAIter, _Compare); 
# 733
template< class _BIter, class _Predicate> inline _BIter partition(_BIter, _BIter, _Predicate); 
# 737
template< class _RAIter> inline void random_shuffle(_RAIter, _RAIter); 
# 741
template< class _RAIter, class _Generator> void random_shuffle(_RAIter, _RAIter, _Generator &&); 
# 750
template< class _FIter, class _Tp> void replace(_FIter, _FIter, const _Tp &, const _Tp &); 
# 754
template< class _FIter, class _Predicate, class _Tp> void replace_if(_FIter, _FIter, _Predicate, const _Tp &); 
# 758
template< class _FIter1, class _FIter2> inline _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2); 
# 762
template< class _FIter1, class _FIter2, class _BinaryPredicate> inline _FIter1 search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate); 
# 766
template< class _FIter, class _Size, class _Tp> inline _FIter search_n(_FIter, _FIter, _Size, const _Tp &); 
# 770
template< class _FIter, class _Size, class _Tp, class 
# 771
_BinaryPredicate> inline _FIter 
# 770
search_n(_FIter, _FIter, _Size, const _Tp &, _BinaryPredicate); 
# 775
template< class _IIter1, class _IIter2, class _OIter> inline _OIter set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 779
template< class _IIter1, class _IIter2, class _OIter, class 
# 780
_Compare> inline _OIter 
# 779
set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 784
template< class _IIter1, class _IIter2, class _OIter> inline _OIter set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 788
template< class _IIter1, class _IIter2, class _OIter, class 
# 789
_Compare> inline _OIter 
# 788
set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 793
template< class _IIter1, class _IIter2, class _OIter> inline _OIter set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 797
template< class _IIter1, class _IIter2, class _OIter, class 
# 798
_Compare> inline _OIter 
# 797
set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 803
template< class _IIter1, class _IIter2, class _OIter> inline _OIter set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter); 
# 807
template< class _IIter1, class _IIter2, class _OIter, class 
# 808
_Compare> inline _OIter 
# 807
set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare); 
# 812
template< class _RAIter> inline void sort(_RAIter, _RAIter); 
# 816
template< class _RAIter, class _Compare> inline void sort(_RAIter, _RAIter, _Compare); 
# 820
template< class _RAIter> inline void stable_sort(_RAIter, _RAIter); 
# 824
template< class _RAIter, class _Compare> inline void stable_sort(_RAIter, _RAIter, _Compare); 
# 828
template< class _IIter, class _OIter, class _UnaryOperation> _OIter transform(_IIter, _IIter, _OIter, _UnaryOperation); 
# 832
template< class _IIter1, class _IIter2, class _OIter, class 
# 833
_BinaryOperation> _OIter 
# 832
transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation); 
# 837
template< class _IIter, class _OIter> inline _OIter unique_copy(_IIter, _IIter, _OIter); 
# 841
template< class _IIter, class _OIter, class _BinaryPredicate> inline _OIter unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate); 
# 847
}
# 62 "/usr/include/c++/9/bits/stl_heap.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< class _RandomAccessIterator, class _Distance, class 
# 72
_Compare> _Distance 
# 74
__is_heap_until(_RandomAccessIterator __first, _Distance __n, _Compare &
# 75
__comp) 
# 76
{ 
# 77
_Distance __parent = (0); 
# 78
for (_Distance __child = (1); __child < __n; ++__child) 
# 79
{ 
# 80
if (__comp(__first + __parent, __first + __child)) { 
# 81
return __child; }  
# 82
if ((__child & 1) == 0) { 
# 83
++__parent; }  
# 84
}  
# 85
return __n; 
# 86
} 
# 90
template< class _RandomAccessIterator, class _Distance> inline bool 
# 92
__is_heap(_RandomAccessIterator __first, _Distance __n) 
# 93
{ 
# 94
__gnu_cxx::__ops::_Iter_less_iter __comp; 
# 95
return std::__is_heap_until(__first, __n, __comp) == __n; 
# 96
} 
# 98
template< class _RandomAccessIterator, class _Compare, class 
# 99
_Distance> inline bool 
# 101
__is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n) 
# 102
{ 
# 103
typedef __decltype(__comp) _Cmp; 
# 104
__gnu_cxx::__ops::_Iter_comp_iter< __decltype(__comp)>  __cmp(std::move(__comp)); 
# 105
return std::__is_heap_until(__first, __n, __cmp) == __n; 
# 106
} 
# 108
template< class _RandomAccessIterator> inline bool 
# 110
__is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 111
{ return std::__is_heap(__first, std::distance(__first, __last)); } 
# 113
template< class _RandomAccessIterator, class _Compare> inline bool 
# 115
__is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 116
__comp) 
# 117
{ 
# 118
return std::__is_heap(__first, std::move(__comp), std::distance(__first, __last)); 
# 120
} 
# 125
template< class _RandomAccessIterator, class _Distance, class _Tp, class 
# 126
_Compare> void 
# 128
__push_heap(_RandomAccessIterator __first, _Distance 
# 129
__holeIndex, _Distance __topIndex, _Tp __value, _Compare &
# 130
__comp) 
# 131
{ 
# 132
_Distance __parent = (__holeIndex - 1) / 2; 
# 133
while ((__holeIndex > __topIndex) && __comp(__first + __parent, __value)) 
# 134
{ 
# 135
(*(__first + __holeIndex)) = std::move(*(__first + __parent)); 
# 136
__holeIndex = __parent; 
# 137
__parent = ((__holeIndex - 1) / 2); 
# 138
}  
# 139
(*(__first + __holeIndex)) = std::move(__value); 
# 140
} 
# 152 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline void 
# 154
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 155
{ 
# 157
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 159
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 165
; 
# 166
; 
# 167
; 
# 169
__gnu_cxx::__ops::_Iter_less_val __comp; 
# 170
_ValueType __value = std::move(*(__last - 1)); 
# 171
std::__push_heap(__first, (_DistanceType)((__last - __first) - 1), (_DistanceType)0, std::move(__value), __comp); 
# 173
} 
# 187 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 189
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 190
__comp) 
# 191
{ 
# 193
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 195
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 200
; 
# 201
; 
# 202
; 
# 205
__decltype((__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))) __cmp(std::move(__comp)); 
# 206
_ValueType __value = std::move(*(__last - 1)); 
# 207
std::__push_heap(__first, (_DistanceType)((__last - __first) - 1), (_DistanceType)0, std::move(__value), __cmp); 
# 209
} 
# 211
template< class _RandomAccessIterator, class _Distance, class 
# 212
_Tp, class _Compare> void 
# 214
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, _Distance 
# 215
__len, _Tp __value, _Compare __comp) 
# 216
{ 
# 217
const _Distance __topIndex = __holeIndex; 
# 218
_Distance __secondChild = __holeIndex; 
# 219
while (__secondChild < ((__len - 1) / 2)) 
# 220
{ 
# 221
__secondChild = (2 * (__secondChild + 1)); 
# 222
if (__comp(__first + __secondChild, __first + (__secondChild - 1))) { 
# 224
__secondChild--; }  
# 225
(*(__first + __holeIndex)) = std::move(*(__first + __secondChild)); 
# 226
__holeIndex = __secondChild; 
# 227
}  
# 228
if (((__len & 1) == 0) && (__secondChild == ((__len - 2) / 2))) 
# 229
{ 
# 230
__secondChild = (2 * (__secondChild + 1)); 
# 231
(*(__first + __holeIndex)) = std::move(*(__first + (__secondChild - 1))); 
# 233
__holeIndex = (__secondChild - 1); 
# 234
}  
# 236
__decltype((__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))) __cmp(std::move(__comp)); 
# 237
std::__push_heap(__first, __holeIndex, __topIndex, std::move(__value), __cmp); 
# 239
} 
# 241
template< class _RandomAccessIterator, class _Compare> inline void 
# 243
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator 
# 244
__result, _Compare &__comp) 
# 245
{ 
# 247
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 249
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 251
_ValueType __value = std::move(*__result); 
# 252
(*__result) = std::move(*__first); 
# 253
std::__adjust_heap(__first, (_DistanceType)0, (_DistanceType)(__last - __first), std::move(__value), __comp); 
# 256
} 
# 269 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline void 
# 271
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 272
{ 
# 278
; 
# 279
; 
# 280
; 
# 281
; 
# 283
if ((__last - __first) > 1) 
# 284
{ 
# 285
--__last; 
# 286
__gnu_cxx::__ops::_Iter_less_iter __comp; 
# 287
std::__pop_heap(__first, __last, __last, __comp); 
# 288
}  
# 289
} 
# 302 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 304
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator 
# 305
__last, _Compare __comp) 
# 306
{ 
# 310
; 
# 311
; 
# 312
; 
# 313
; 
# 315
if ((__last - __first) > 1) 
# 316
{ 
# 317
typedef __decltype(__comp) _Cmp; 
# 318
__gnu_cxx::__ops::_Iter_comp_iter< __decltype(__comp)>  __cmp(std::move(__comp)); 
# 319
--__last; 
# 320
std::__pop_heap(__first, __last, __last, __cmp); 
# 321
}  
# 322
} 
# 324
template< class _RandomAccessIterator, class _Compare> void 
# 326
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &
# 327
__comp) 
# 328
{ 
# 330
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 332
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 334
if ((__last - __first) < 2) { 
# 335
return; }  
# 337
const _DistanceType __len = __last - __first; 
# 338
_DistanceType __parent = (__len - 2) / 2; 
# 339
while (true) 
# 340
{ 
# 341
_ValueType __value = std::move(*(__first + __parent)); 
# 342
std::__adjust_heap(__first, __parent, __len, std::move(__value), __comp); 
# 344
if (__parent == 0) { 
# 345
return; }  
# 346
__parent--; 
# 347
}  
# 348
} 
# 358 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline void 
# 360
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 361
{ 
# 367
; 
# 368
; 
# 370
__gnu_cxx::__ops::_Iter_less_iter __comp; 
# 371
std::__make_heap(__first, __last, __comp); 
# 372
} 
# 384 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 386
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 387
__comp) 
# 388
{ 
# 392
; 
# 393
; 
# 395
typedef __decltype(__comp) _Cmp; 
# 396
__gnu_cxx::__ops::_Iter_comp_iter< __decltype(__comp)>  __cmp(std::move(__comp)); 
# 397
std::__make_heap(__first, __last, __cmp); 
# 398
} 
# 400
template< class _RandomAccessIterator, class _Compare> void 
# 402
__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare &
# 403
__comp) 
# 404
{ 
# 405
while ((__last - __first) > 1) 
# 406
{ 
# 407
--__last; 
# 408
std::__pop_heap(__first, __last, __last, __comp); 
# 409
}  
# 410
} 
# 420 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline void 
# 422
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 423
{ 
# 429
; 
# 430
; 
# 431
; 
# 433
__gnu_cxx::__ops::_Iter_less_iter __comp; 
# 434
std::__sort_heap(__first, __last, __comp); 
# 435
} 
# 447 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 449
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 450
__comp) 
# 451
{ 
# 455
; 
# 456
; 
# 457
; 
# 459
typedef __decltype(__comp) _Cmp; 
# 460
__gnu_cxx::__ops::_Iter_comp_iter< __decltype(__comp)>  __cmp(std::move(__comp)); 
# 461
std::__sort_heap(__first, __last, __cmp); 
# 462
} 
# 475 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline _RandomAccessIterator 
# 477
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 478
{ 
# 484
; 
# 485
; 
# 487
__gnu_cxx::__ops::_Iter_less_iter __comp; 
# 488
return __first + std::__is_heap_until(__first, std::distance(__first, __last), __comp); 
# 490
} 
# 503 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline _RandomAccessIterator 
# 505
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 506
__comp) 
# 507
{ 
# 511
; 
# 512
; 
# 514
typedef __decltype(__comp) _Cmp; 
# 515
__gnu_cxx::__ops::_Iter_comp_iter< __decltype(__comp)>  __cmp(std::move(__comp)); 
# 516
return __first + std::__is_heap_until(__first, std::distance(__first, __last), __cmp); 
# 518
} 
# 527 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator> inline bool 
# 529
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 530
{ return std::is_heap_until(__first, __last) == __last; } 
# 540 "/usr/include/c++/9/bits/stl_heap.h" 3
template< class _RandomAccessIterator, class _Compare> inline bool 
# 542
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 543
__comp) 
# 544
{ 
# 548
; 
# 549
; 
# 551
const auto __dist = std::distance(__first, __last); 
# 552
typedef __decltype(__comp) _Cmp; 
# 553
__gnu_cxx::__ops::_Iter_comp_iter< __decltype(__comp)>  __cmp(std::move(__comp)); 
# 554
return std::__is_heap_until(__first, __dist, __cmp) == __dist; 
# 555
} 
# 559
}
# 63 "/usr/include/c++/9/bits/stl_construct.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 72
template< class _T1, class ..._Args> inline void 
# 74
_Construct(_T1 *__p, _Args &&...__args) 
# 75
{ ::new (static_cast< void *>(__p)) _T1(std::forward< _Args> (__args)...); } 
# 87 "/usr/include/c++/9/bits/stl_construct.h" 3
template< class _T1> inline void 
# 89
_Construct_novalue(_T1 *__p) 
# 90
{ ::new (static_cast< void *>(__p)) _T1; } 
# 95
template< class _Tp> inline void 
# 97
_Destroy(_Tp *__pointer) 
# 98
{ __pointer->~_Tp(); } 
# 100
template< bool > 
# 101
struct _Destroy_aux { 
# 103
template< class _ForwardIterator> static void 
# 105
__destroy(_ForwardIterator __first, _ForwardIterator __last) 
# 106
{ 
# 107
for (; __first != __last; ++__first) { 
# 108
std::_Destroy(std::__addressof(*__first)); }  
# 109
} 
# 110
}; 
# 113
template<> struct _Destroy_aux< true>  { 
# 115
template< class _ForwardIterator> static void 
# 117
__destroy(_ForwardIterator, _ForwardIterator) { } 
# 118
}; 
# 125
template< class _ForwardIterator> inline void 
# 127
_Destroy(_ForwardIterator __first, _ForwardIterator __last) 
# 128
{ 
# 130
typedef typename iterator_traits< _ForwardIterator> ::value_type _Value_type; 
# 133
static_assert((is_destructible< typename iterator_traits< _ForwardIterator> ::value_type> ::value), "value type is destructible");
# 136
std::template _Destroy_aux< __has_trivial_destructor(_Value_type)> ::__destroy(__first, __last); 
# 138
} 
# 140
template< bool > 
# 141
struct _Destroy_n_aux { 
# 143
template< class _ForwardIterator, class _Size> static _ForwardIterator 
# 145
__destroy_n(_ForwardIterator __first, _Size __count) 
# 146
{ 
# 147
for (; __count > 0; ((void)(++__first)), (--__count)) { 
# 148
std::_Destroy(std::__addressof(*__first)); }  
# 149
return __first; 
# 150
} 
# 151
}; 
# 154
template<> struct _Destroy_n_aux< true>  { 
# 156
template< class _ForwardIterator, class _Size> static _ForwardIterator 
# 158
__destroy_n(_ForwardIterator __first, _Size __count) 
# 159
{ 
# 160
std::advance(__first, __count); 
# 161
return __first; 
# 162
} 
# 163
}; 
# 170
template< class _ForwardIterator, class _Size> inline _ForwardIterator 
# 172
_Destroy_n(_ForwardIterator __first, _Size __count) 
# 173
{ 
# 175
typedef typename iterator_traits< _ForwardIterator> ::value_type _Value_type; 
# 178
static_assert((is_destructible< typename iterator_traits< _ForwardIterator> ::value_type> ::value), "value type is destructible");
# 181
return std::template _Destroy_n_aux< __has_trivial_destructor(_Value_type)> ::__destroy_n(__first, __count); 
# 183
} 
# 191
template< class _ForwardIterator, class _Allocator> void 
# 193
_Destroy(_ForwardIterator __first, _ForwardIterator __last, _Allocator &
# 194
__alloc) 
# 195
{ 
# 196
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 197
for (; __first != __last; ++__first) { 
# 198
__traits::destroy(__alloc, std::__addressof(*__first)); }  
# 199
} 
# 201
template< class _ForwardIterator, class _Tp> inline void 
# 203
_Destroy(_ForwardIterator __first, _ForwardIterator __last, allocator< _Tp>  &) 
# 205
{ 
# 206
_Destroy(__first, __last); 
# 207
} 
# 233 "/usr/include/c++/9/bits/stl_construct.h" 3
}
# 62 "/usr/include/c++/9/bits/stl_tempbuf.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 83 "/usr/include/c++/9/bits/stl_tempbuf.h" 3
template< class _Tp> pair< _Tp *, long>  
# 85
get_temporary_buffer(ptrdiff_t __len) noexcept 
# 86
{ 
# 87
const ptrdiff_t __max = (__gnu_cxx::__numeric_traits_integer< streamsize> ::__max / sizeof(_Tp)); 
# 89
if (__len > __max) { 
# 90
__len = __max; }  
# 92
while (__len > (0)) 
# 93
{ 
# 94
_Tp *__tmp = static_cast< _Tp *>(::operator new(__len * sizeof(_Tp), std::nothrow)); 
# 96
if (__tmp != 0) { 
# 97
return pair< _Tp *, long> (__tmp, __len); }  
# 98
__len /= (2); 
# 99
}  
# 100
return pair< _Tp *, ptrdiff_t> (static_cast< _Tp *>(0), 0); 
# 101
} 
# 110 "/usr/include/c++/9/bits/stl_tempbuf.h" 3
template< class _Tp> inline void 
# 112
return_temporary_buffer(_Tp *__p) 
# 113
{ ::operator delete(__p); } 
# 121
template< class _ForwardIterator, class _Tp> 
# 122
class _Temporary_buffer { 
# 128
public: typedef _Tp value_type; 
# 129
typedef value_type *pointer; 
# 130
typedef pointer iterator; 
# 131
typedef ptrdiff_t size_type; 
# 134
protected: size_type _M_original_len; 
# 135
size_type _M_len; 
# 136
pointer _M_buffer; 
# 141
public: size_type size() const 
# 142
{ return _M_len; } 
# 146
size_type requested_size() const 
# 147
{ return _M_original_len; } 
# 151
iterator begin() 
# 152
{ return _M_buffer; } 
# 156
iterator end() 
# 157
{ return (_M_buffer) + (_M_len); } 
# 163
_Temporary_buffer(_ForwardIterator __seed, size_type __original_len); 
# 165
~_Temporary_buffer() 
# 166
{ 
# 167
std::_Destroy(_M_buffer, (_M_buffer) + (_M_len)); 
# 168
std::return_temporary_buffer(_M_buffer); 
# 169
} 
# 173
private: _Temporary_buffer(const _Temporary_buffer &); 
# 176
void operator=(const _Temporary_buffer &); 
# 177
}; 
# 180
template< bool > 
# 181
struct __uninitialized_construct_buf_dispatch { 
# 183
template< class _Pointer, class _ForwardIterator> static void 
# 185
__ucr(_Pointer __first, _Pointer __last, _ForwardIterator 
# 186
__seed) 
# 187
{ 
# 188
if (__first == __last) { 
# 189
return; }  
# 191
_Pointer __cur = __first; 
# 192
try 
# 193
{ 
# 194
std::_Construct(std::__addressof(*__first), std::move(*__seed)); 
# 196
_Pointer __prev = __cur; 
# 197
++__cur; 
# 198
for (; __cur != __last; (++__cur), (++__prev)) { 
# 199
std::_Construct(std::__addressof(*__cur), std::move(*__prev)); }  
# 201
(*__seed) = std::move(*__prev); 
# 202
} 
# 203
catch (...) 
# 204
{ 
# 205
std::_Destroy(__first, __cur); 
# 206
throw; 
# 207
}  
# 208
} 
# 209
}; 
# 212
template<> struct __uninitialized_construct_buf_dispatch< true>  { 
# 214
template< class _Pointer, class _ForwardIterator> static void 
# 216
__ucr(_Pointer, _Pointer, _ForwardIterator) { } 
# 217
}; 
# 229 "/usr/include/c++/9/bits/stl_tempbuf.h" 3
template< class _Pointer, class _ForwardIterator> inline void 
# 231
__uninitialized_construct_buf(_Pointer __first, _Pointer __last, _ForwardIterator 
# 232
__seed) 
# 233
{ 
# 235
typedef typename iterator_traits< _Pointer> ::value_type _ValueType; 
# 237
std::template __uninitialized_construct_buf_dispatch< __has_trivial_constructor(_ValueType)> ::__ucr(__first, __last, __seed); 
# 240
} 
# 242
template< class _ForwardIterator, class _Tp> 
# 244
_Temporary_buffer< _ForwardIterator, _Tp> ::_Temporary_buffer(_ForwardIterator __seed, size_type __original_len) : _M_original_len(__original_len), _M_len((0)), _M_buffer((0)) 
# 246
{ 
# 247
try 
# 248
{ 
# 249
pair< _Tp *, long>  __p(std::get_temporary_buffer< value_type> (_M_original_len)); 
# 251
(_M_buffer) = (__p.first); 
# 252
(_M_len) = (__p.second); 
# 253
if (_M_buffer) { 
# 254
std::__uninitialized_construct_buf(_M_buffer, (_M_buffer) + (_M_len), __seed); }  
# 256
} 
# 257
catch (...) 
# 258
{ 
# 259
std::return_temporary_buffer(_M_buffer); 
# 260
(_M_buffer) = 0; 
# 261
(_M_len) = (0); 
# 262
throw; 
# 263
}  
# 264
} 
# 267
}
# 158 "/usr/include/c++/9/limits" 3
namespace std __attribute((__visibility__("default"))) { 
# 167
enum float_round_style { 
# 169
round_indeterminate = (-1), 
# 170
round_toward_zero = 0, 
# 171
round_to_nearest, 
# 172
round_toward_infinity, 
# 173
round_toward_neg_infinity
# 174
}; 
# 182
enum float_denorm_style { 
# 185
denorm_indeterminate = (-1), 
# 187
denorm_absent = 0, 
# 189
denorm_present
# 190
}; 
# 202 "/usr/include/c++/9/limits" 3
struct __numeric_limits_base { 
# 206
static constexpr bool is_specialized = false; 
# 211
static constexpr int digits = 0; 
# 214
static constexpr int digits10 = 0; 
# 219
static constexpr int max_digits10 = 0; 
# 223
static constexpr bool is_signed = false; 
# 226
static constexpr bool is_integer = false; 
# 231
static constexpr bool is_exact = false; 
# 235
static constexpr int radix = 0; 
# 239
static constexpr int min_exponent = 0; 
# 243
static constexpr int min_exponent10 = 0; 
# 248
static constexpr int max_exponent = 0; 
# 252
static constexpr int max_exponent10 = 0; 
# 255
static constexpr bool has_infinity = false; 
# 259
static constexpr bool has_quiet_NaN = false; 
# 263
static constexpr bool has_signaling_NaN = false; 
# 266
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 270
static constexpr bool has_denorm_loss = false; 
# 274
static constexpr bool is_iec559 = false; 
# 279
static constexpr bool is_bounded = false; 
# 288 "/usr/include/c++/9/limits" 3
static constexpr bool is_modulo = false; 
# 291
static constexpr bool traps = false; 
# 294
static constexpr bool tinyness_before = false; 
# 299
static constexpr float_round_style round_style = round_toward_zero; 
# 301
}; 
# 311 "/usr/include/c++/9/limits" 3
template< class _Tp> 
# 312
struct numeric_limits : public __numeric_limits_base { 
# 317
static constexpr _Tp min() noexcept { return _Tp(); } 
# 321
static constexpr _Tp max() noexcept { return _Tp(); } 
# 327
static constexpr _Tp lowest() noexcept { return _Tp(); } 
# 333
static constexpr _Tp epsilon() noexcept { return _Tp(); } 
# 337
static constexpr _Tp round_error() noexcept { return _Tp(); } 
# 341
static constexpr _Tp infinity() noexcept { return _Tp(); } 
# 346
static constexpr _Tp quiet_NaN() noexcept { return _Tp(); } 
# 351
static constexpr _Tp signaling_NaN() noexcept { return _Tp(); } 
# 357
static constexpr _Tp denorm_min() noexcept { return _Tp(); } 
# 358
}; 
# 363
template< class _Tp> 
# 364
struct numeric_limits< const _Tp>  : public std::numeric_limits< _Tp>  { 
# 365
}; 
# 367
template< class _Tp> 
# 368
struct numeric_limits< volatile _Tp>  : public std::numeric_limits< _Tp>  { 
# 369
}; 
# 371
template< class _Tp> 
# 372
struct numeric_limits< const volatile _Tp>  : public std::numeric_limits< _Tp>  { 
# 373
}; 
# 384 "/usr/include/c++/9/limits" 3
template<> struct numeric_limits< bool>  { 
# 386
static constexpr bool is_specialized = true; 
# 389
static constexpr bool min() noexcept { return false; } 
# 392
static constexpr bool max() noexcept { return true; } 
# 396
static constexpr bool lowest() noexcept { return min(); } 
# 398
static constexpr int digits = 1; 
# 399
static constexpr int digits10 = 0; 
# 401
static constexpr int max_digits10 = 0; 
# 403
static constexpr bool is_signed = false; 
# 404
static constexpr bool is_integer = true; 
# 405
static constexpr bool is_exact = true; 
# 406
static constexpr int radix = 2; 
# 409
static constexpr bool epsilon() noexcept { return false; } 
# 412
static constexpr bool round_error() noexcept { return false; } 
# 414
static constexpr int min_exponent = 0; 
# 415
static constexpr int min_exponent10 = 0; 
# 416
static constexpr int max_exponent = 0; 
# 417
static constexpr int max_exponent10 = 0; 
# 419
static constexpr bool has_infinity = false; 
# 420
static constexpr bool has_quiet_NaN = false; 
# 421
static constexpr bool has_signaling_NaN = false; 
# 422
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 424
static constexpr bool has_denorm_loss = false; 
# 427
static constexpr bool infinity() noexcept { return false; } 
# 430
static constexpr bool quiet_NaN() noexcept { return false; } 
# 433
static constexpr bool signaling_NaN() noexcept { return false; } 
# 436
static constexpr bool denorm_min() noexcept { return false; } 
# 438
static constexpr bool is_iec559 = false; 
# 439
static constexpr bool is_bounded = true; 
# 440
static constexpr bool is_modulo = false; 
# 445
static constexpr bool traps = true; 
# 446
static constexpr bool tinyness_before = false; 
# 447
static constexpr float_round_style round_style = round_toward_zero; 
# 449
}; 
# 453
template<> struct numeric_limits< char>  { 
# 455
static constexpr bool is_specialized = true; 
# 458
static constexpr char min() noexcept { return ((((char)(-1)) < 0) ? (-((((char)(-1)) < 0) ? (((((char)1) << (((sizeof(char) * (8)) - (((char)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char)0)))) - 1 : ((char)0)); } 
# 461
static constexpr char max() noexcept { return ((((char)(-1)) < 0) ? (((((char)1) << (((sizeof(char) * (8)) - (((char)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char)0))); } 
# 465
static constexpr char lowest() noexcept { return min(); } 
# 468
static constexpr int digits = ((sizeof(char) * (8)) - (((char)(-1)) < 0)); 
# 469
static constexpr int digits10 = ((((sizeof(char) * (8)) - (((char)(-1)) < 0)) * (643L)) / (2136)); 
# 471
static constexpr int max_digits10 = 0; 
# 473
static constexpr bool is_signed = (((char)(-1)) < 0); 
# 474
static constexpr bool is_integer = true; 
# 475
static constexpr bool is_exact = true; 
# 476
static constexpr int radix = 2; 
# 479
static constexpr char epsilon() noexcept { return 0; } 
# 482
static constexpr char round_error() noexcept { return 0; } 
# 484
static constexpr int min_exponent = 0; 
# 485
static constexpr int min_exponent10 = 0; 
# 486
static constexpr int max_exponent = 0; 
# 487
static constexpr int max_exponent10 = 0; 
# 489
static constexpr bool has_infinity = false; 
# 490
static constexpr bool has_quiet_NaN = false; 
# 491
static constexpr bool has_signaling_NaN = false; 
# 492
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 494
static constexpr bool has_denorm_loss = false; 
# 497
static constexpr char infinity() noexcept { return ((char)0); } 
# 500
static constexpr char quiet_NaN() noexcept { return ((char)0); } 
# 503
static constexpr char signaling_NaN() noexcept { return ((char)0); } 
# 506
static constexpr char denorm_min() noexcept { return static_cast< char>(0); } 
# 508
static constexpr bool is_iec559 = false; 
# 509
static constexpr bool is_bounded = true; 
# 510
static constexpr bool is_modulo = (!is_signed); 
# 512
static constexpr bool traps = true; 
# 513
static constexpr bool tinyness_before = false; 
# 514
static constexpr float_round_style round_style = round_toward_zero; 
# 516
}; 
# 520
template<> struct numeric_limits< signed char>  { 
# 522
static constexpr bool is_specialized = true; 
# 525
static constexpr signed char min() noexcept { return (-127) - 1; } 
# 528
static constexpr signed char max() noexcept { return 127; } 
# 532
static constexpr signed char lowest() noexcept { return min(); } 
# 535
static constexpr int digits = ((sizeof(signed char) * (8)) - (((signed char)(-1)) < 0)); 
# 536
static constexpr int digits10 = ((((sizeof(signed char) * (8)) - (((signed char)(-1)) < 0)) * (643L)) / (2136)); 
# 539
static constexpr int max_digits10 = 0; 
# 541
static constexpr bool is_signed = true; 
# 542
static constexpr bool is_integer = true; 
# 543
static constexpr bool is_exact = true; 
# 544
static constexpr int radix = 2; 
# 547
static constexpr signed char epsilon() noexcept { return 0; } 
# 550
static constexpr signed char round_error() noexcept { return 0; } 
# 552
static constexpr int min_exponent = 0; 
# 553
static constexpr int min_exponent10 = 0; 
# 554
static constexpr int max_exponent = 0; 
# 555
static constexpr int max_exponent10 = 0; 
# 557
static constexpr bool has_infinity = false; 
# 558
static constexpr bool has_quiet_NaN = false; 
# 559
static constexpr bool has_signaling_NaN = false; 
# 560
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 562
static constexpr bool has_denorm_loss = false; 
# 565
static constexpr signed char infinity() noexcept { return static_cast< signed char>(0); } 
# 568
static constexpr signed char quiet_NaN() noexcept { return static_cast< signed char>(0); } 
# 571
static constexpr signed char signaling_NaN() noexcept 
# 572
{ return static_cast< signed char>(0); } 
# 575
static constexpr signed char denorm_min() noexcept 
# 576
{ return static_cast< signed char>(0); } 
# 578
static constexpr bool is_iec559 = false; 
# 579
static constexpr bool is_bounded = true; 
# 580
static constexpr bool is_modulo = false; 
# 582
static constexpr bool traps = true; 
# 583
static constexpr bool tinyness_before = false; 
# 584
static constexpr float_round_style round_style = round_toward_zero; 
# 586
}; 
# 590
template<> struct numeric_limits< unsigned char>  { 
# 592
static constexpr bool is_specialized = true; 
# 595
static constexpr unsigned char min() noexcept { return 0; } 
# 598
static constexpr unsigned char max() noexcept { return ((127) * 2U) + (1); } 
# 602
static constexpr unsigned char lowest() noexcept { return min(); } 
# 605
static constexpr int digits = ((sizeof(unsigned char) * (8)) - (((unsigned char)(-1)) < 0)); 
# 607
static constexpr int digits10 = ((((sizeof(unsigned char) * (8)) - (((unsigned char)(-1)) < 0)) * (643L)) / (2136)); 
# 610
static constexpr int max_digits10 = 0; 
# 612
static constexpr bool is_signed = false; 
# 613
static constexpr bool is_integer = true; 
# 614
static constexpr bool is_exact = true; 
# 615
static constexpr int radix = 2; 
# 618
static constexpr unsigned char epsilon() noexcept { return 0; } 
# 621
static constexpr unsigned char round_error() noexcept { return 0; } 
# 623
static constexpr int min_exponent = 0; 
# 624
static constexpr int min_exponent10 = 0; 
# 625
static constexpr int max_exponent = 0; 
# 626
static constexpr int max_exponent10 = 0; 
# 628
static constexpr bool has_infinity = false; 
# 629
static constexpr bool has_quiet_NaN = false; 
# 630
static constexpr bool has_signaling_NaN = false; 
# 631
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 633
static constexpr bool has_denorm_loss = false; 
# 636
static constexpr unsigned char infinity() noexcept 
# 637
{ return static_cast< unsigned char>(0); } 
# 640
static constexpr unsigned char quiet_NaN() noexcept 
# 641
{ return static_cast< unsigned char>(0); } 
# 644
static constexpr unsigned char signaling_NaN() noexcept 
# 645
{ return static_cast< unsigned char>(0); } 
# 648
static constexpr unsigned char denorm_min() noexcept 
# 649
{ return static_cast< unsigned char>(0); } 
# 651
static constexpr bool is_iec559 = false; 
# 652
static constexpr bool is_bounded = true; 
# 653
static constexpr bool is_modulo = true; 
# 655
static constexpr bool traps = true; 
# 656
static constexpr bool tinyness_before = false; 
# 657
static constexpr float_round_style round_style = round_toward_zero; 
# 659
}; 
# 663
template<> struct numeric_limits< wchar_t>  { 
# 665
static constexpr bool is_specialized = true; 
# 668
static constexpr wchar_t min() noexcept { return ((((wchar_t)(-1)) < 0) ? (-((((wchar_t)(-1)) < 0) ? (((((wchar_t)1) << (((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((wchar_t)0)))) - 1 : ((wchar_t)0)); } 
# 671
static constexpr wchar_t max() noexcept { return ((((wchar_t)(-1)) < 0) ? (((((wchar_t)1) << (((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((wchar_t)0))); } 
# 675
static constexpr wchar_t lowest() noexcept { return min(); } 
# 678
static constexpr int digits = ((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)); 
# 679
static constexpr int digits10 = ((((sizeof(wchar_t) * (8)) - (((wchar_t)(-1)) < 0)) * (643L)) / (2136)); 
# 682
static constexpr int max_digits10 = 0; 
# 684
static constexpr bool is_signed = (((wchar_t)(-1)) < 0); 
# 685
static constexpr bool is_integer = true; 
# 686
static constexpr bool is_exact = true; 
# 687
static constexpr int radix = 2; 
# 690
static constexpr wchar_t epsilon() noexcept { return 0; } 
# 693
static constexpr wchar_t round_error() noexcept { return 0; } 
# 695
static constexpr int min_exponent = 0; 
# 696
static constexpr int min_exponent10 = 0; 
# 697
static constexpr int max_exponent = 0; 
# 698
static constexpr int max_exponent10 = 0; 
# 700
static constexpr bool has_infinity = false; 
# 701
static constexpr bool has_quiet_NaN = false; 
# 702
static constexpr bool has_signaling_NaN = false; 
# 703
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 705
static constexpr bool has_denorm_loss = false; 
# 708
static constexpr wchar_t infinity() noexcept { return ((wchar_t)0); } 
# 711
static constexpr wchar_t quiet_NaN() noexcept { return ((wchar_t)0); } 
# 714
static constexpr wchar_t signaling_NaN() noexcept { return ((wchar_t)0); } 
# 717
static constexpr wchar_t denorm_min() noexcept { return ((wchar_t)0); } 
# 719
static constexpr bool is_iec559 = false; 
# 720
static constexpr bool is_bounded = true; 
# 721
static constexpr bool is_modulo = (!is_signed); 
# 723
static constexpr bool traps = true; 
# 724
static constexpr bool tinyness_before = false; 
# 725
static constexpr float_round_style round_style = round_toward_zero; 
# 727
}; 
# 797 "/usr/include/c++/9/limits" 3
template<> struct numeric_limits< char16_t>  { 
# 799
static constexpr bool is_specialized = true; 
# 802
static constexpr char16_t min() noexcept { return ((((char16_t)(-1)) < 0) ? (-((((char16_t)(-1)) < 0) ? (((((char16_t)1) << (((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char16_t)0)))) - 1 : ((char16_t)0)); } 
# 805
static constexpr char16_t max() noexcept { return ((((char16_t)(-1)) < 0) ? (((((char16_t)1) << (((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)) - (1))) - 1) << 1) + 1 : (~((char16_t)0))); } 
# 808
static constexpr char16_t lowest() noexcept { return min(); } 
# 810
static constexpr int digits = ((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)); 
# 811
static constexpr int digits10 = ((((sizeof(char16_t) * (8)) - (((char16_t)(-1)) < 0)) * (643L)) / (2136)); 
# 812
static constexpr int max_digits10 = 0; 
# 813
static constexpr bool is_signed = (((char16_t)(-1)) < 0); 
# 814
static constexpr bool is_integer = true; 
# 815
static constexpr bool is_exact = true; 
# 816
static constexpr int radix = 2; 
# 819
static constexpr char16_t epsilon() noexcept { return 0; } 
# 822
static constexpr char16_t round_error() noexcept { return 0; } 
# 824
static constexpr int min_exponent = 0; 
# 825
static constexpr int min_exponent10 = 0; 
# 826
static constexpr int max_exponent = 0; 
# 827
static constexpr int max_exponent10 = 0; 
# 829
static constexpr bool has_infinity = false; 
# 830
static constexpr bool has_quiet_NaN = false; 
# 831
static constexpr bool has_signaling_NaN = false; 
# 832
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 833
static constexpr bool has_denorm_loss = false; 
# 836
static constexpr char16_t infinity() noexcept { return ((char16_t)0); } 
# 839
static constexpr char16_t quiet_NaN() noexcept { return ((char16_t)0); } 
# 842
static constexpr char16_t signaling_NaN() noexcept { return ((char16_t)0); } 
# 845
static constexpr char16_t denorm_min() noexcept { return ((char16_t)0); } 
# 847
static constexpr bool is_iec559 = false; 
# 848
static constexpr bool is_bounded = true; 
# 849
static constexpr bool is_modulo = (!is_signed); 
# 851
static constexpr bool traps = true; 
# 852
static constexpr bool tinyness_before = false; 
# 853
static constexpr float_round_style round_style = round_toward_zero; 
# 854
}; 
# 858
template<> struct numeric_limits< char32_t>  { 
# 860
static constexpr bool is_specialized = true; 
# 863
static constexpr char32_t min() noexcept { return ((((char32_t)(-1)) < (0)) ? (-((((char32_t)(-1)) < (0)) ? (((((char32_t)1) << (((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))) - (1))) - (1)) << 1) + (1) : (~((char32_t)0)))) - (1) : ((char32_t)0)); } 
# 866
static constexpr char32_t max() noexcept { return ((((char32_t)(-1)) < (0)) ? (((((char32_t)1) << (((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))) - (1))) - (1)) << 1) + (1) : (~((char32_t)0))); } 
# 869
static constexpr char32_t lowest() noexcept { return min(); } 
# 871
static constexpr int digits = ((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))); 
# 872
static constexpr int digits10 = ((((sizeof(char32_t) * (8)) - (((char32_t)(-1)) < (0))) * (643L)) / (2136)); 
# 873
static constexpr int max_digits10 = 0; 
# 874
static constexpr bool is_signed = (((char32_t)(-1)) < (0)); 
# 875
static constexpr bool is_integer = true; 
# 876
static constexpr bool is_exact = true; 
# 877
static constexpr int radix = 2; 
# 880
static constexpr char32_t epsilon() noexcept { return 0; } 
# 883
static constexpr char32_t round_error() noexcept { return 0; } 
# 885
static constexpr int min_exponent = 0; 
# 886
static constexpr int min_exponent10 = 0; 
# 887
static constexpr int max_exponent = 0; 
# 888
static constexpr int max_exponent10 = 0; 
# 890
static constexpr bool has_infinity = false; 
# 891
static constexpr bool has_quiet_NaN = false; 
# 892
static constexpr bool has_signaling_NaN = false; 
# 893
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 894
static constexpr bool has_denorm_loss = false; 
# 897
static constexpr char32_t infinity() noexcept { return ((char32_t)0); } 
# 900
static constexpr char32_t quiet_NaN() noexcept { return ((char32_t)0); } 
# 903
static constexpr char32_t signaling_NaN() noexcept { return ((char32_t)0); } 
# 906
static constexpr char32_t denorm_min() noexcept { return ((char32_t)0); } 
# 908
static constexpr bool is_iec559 = false; 
# 909
static constexpr bool is_bounded = true; 
# 910
static constexpr bool is_modulo = (!is_signed); 
# 912
static constexpr bool traps = true; 
# 913
static constexpr bool tinyness_before = false; 
# 914
static constexpr float_round_style round_style = round_toward_zero; 
# 915
}; 
# 920
template<> struct numeric_limits< short>  { 
# 922
static constexpr bool is_specialized = true; 
# 925
static constexpr short min() noexcept { return (-32767) - 1; } 
# 928
static constexpr short max() noexcept { return 32767; } 
# 932
static constexpr short lowest() noexcept { return min(); } 
# 935
static constexpr int digits = ((sizeof(short) * (8)) - (((short)(-1)) < 0)); 
# 936
static constexpr int digits10 = ((((sizeof(short) * (8)) - (((short)(-1)) < 0)) * (643L)) / (2136)); 
# 938
static constexpr int max_digits10 = 0; 
# 940
static constexpr bool is_signed = true; 
# 941
static constexpr bool is_integer = true; 
# 942
static constexpr bool is_exact = true; 
# 943
static constexpr int radix = 2; 
# 946
static constexpr short epsilon() noexcept { return 0; } 
# 949
static constexpr short round_error() noexcept { return 0; } 
# 951
static constexpr int min_exponent = 0; 
# 952
static constexpr int min_exponent10 = 0; 
# 953
static constexpr int max_exponent = 0; 
# 954
static constexpr int max_exponent10 = 0; 
# 956
static constexpr bool has_infinity = false; 
# 957
static constexpr bool has_quiet_NaN = false; 
# 958
static constexpr bool has_signaling_NaN = false; 
# 959
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 961
static constexpr bool has_denorm_loss = false; 
# 964
static constexpr short infinity() noexcept { return ((short)0); } 
# 967
static constexpr short quiet_NaN() noexcept { return ((short)0); } 
# 970
static constexpr short signaling_NaN() noexcept { return ((short)0); } 
# 973
static constexpr short denorm_min() noexcept { return ((short)0); } 
# 975
static constexpr bool is_iec559 = false; 
# 976
static constexpr bool is_bounded = true; 
# 977
static constexpr bool is_modulo = false; 
# 979
static constexpr bool traps = true; 
# 980
static constexpr bool tinyness_before = false; 
# 981
static constexpr float_round_style round_style = round_toward_zero; 
# 983
}; 
# 987
template<> struct numeric_limits< unsigned short>  { 
# 989
static constexpr bool is_specialized = true; 
# 992
static constexpr unsigned short min() noexcept { return 0; } 
# 995
static constexpr unsigned short max() noexcept { return ((32767) * 2U) + (1); } 
# 999
static constexpr unsigned short lowest() noexcept { return min(); } 
# 1002
static constexpr int digits = ((sizeof(unsigned short) * (8)) - (((unsigned short)(-1)) < 0)); 
# 1004
static constexpr int digits10 = ((((sizeof(unsigned short) * (8)) - (((unsigned short)(-1)) < 0)) * (643L)) / (2136)); 
# 1007
static constexpr int max_digits10 = 0; 
# 1009
static constexpr bool is_signed = false; 
# 1010
static constexpr bool is_integer = true; 
# 1011
static constexpr bool is_exact = true; 
# 1012
static constexpr int radix = 2; 
# 1015
static constexpr unsigned short epsilon() noexcept { return 0; } 
# 1018
static constexpr unsigned short round_error() noexcept { return 0; } 
# 1020
static constexpr int min_exponent = 0; 
# 1021
static constexpr int min_exponent10 = 0; 
# 1022
static constexpr int max_exponent = 0; 
# 1023
static constexpr int max_exponent10 = 0; 
# 1025
static constexpr bool has_infinity = false; 
# 1026
static constexpr bool has_quiet_NaN = false; 
# 1027
static constexpr bool has_signaling_NaN = false; 
# 1028
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1030
static constexpr bool has_denorm_loss = false; 
# 1033
static constexpr unsigned short infinity() noexcept 
# 1034
{ return static_cast< unsigned short>(0); } 
# 1037
static constexpr unsigned short quiet_NaN() noexcept 
# 1038
{ return static_cast< unsigned short>(0); } 
# 1041
static constexpr unsigned short signaling_NaN() noexcept 
# 1042
{ return static_cast< unsigned short>(0); } 
# 1045
static constexpr unsigned short denorm_min() noexcept 
# 1046
{ return static_cast< unsigned short>(0); } 
# 1048
static constexpr bool is_iec559 = false; 
# 1049
static constexpr bool is_bounded = true; 
# 1050
static constexpr bool is_modulo = true; 
# 1052
static constexpr bool traps = true; 
# 1053
static constexpr bool tinyness_before = false; 
# 1054
static constexpr float_round_style round_style = round_toward_zero; 
# 1056
}; 
# 1060
template<> struct numeric_limits< int>  { 
# 1062
static constexpr bool is_specialized = true; 
# 1065
static constexpr int min() noexcept { return (-2147483647) - 1; } 
# 1068
static constexpr int max() noexcept { return 2147483647; } 
# 1072
static constexpr int lowest() noexcept { return min(); } 
# 1075
static constexpr int digits = ((sizeof(int) * (8)) - (((int)(-1)) < 0)); 
# 1076
static constexpr int digits10 = ((((sizeof(int) * (8)) - (((int)(-1)) < 0)) * (643L)) / (2136)); 
# 1078
static constexpr int max_digits10 = 0; 
# 1080
static constexpr bool is_signed = true; 
# 1081
static constexpr bool is_integer = true; 
# 1082
static constexpr bool is_exact = true; 
# 1083
static constexpr int radix = 2; 
# 1086
static constexpr int epsilon() noexcept { return 0; } 
# 1089
static constexpr int round_error() noexcept { return 0; } 
# 1091
static constexpr int min_exponent = 0; 
# 1092
static constexpr int min_exponent10 = 0; 
# 1093
static constexpr int max_exponent = 0; 
# 1094
static constexpr int max_exponent10 = 0; 
# 1096
static constexpr bool has_infinity = false; 
# 1097
static constexpr bool has_quiet_NaN = false; 
# 1098
static constexpr bool has_signaling_NaN = false; 
# 1099
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1101
static constexpr bool has_denorm_loss = false; 
# 1104
static constexpr int infinity() noexcept { return static_cast< int>(0); } 
# 1107
static constexpr int quiet_NaN() noexcept { return static_cast< int>(0); } 
# 1110
static constexpr int signaling_NaN() noexcept { return static_cast< int>(0); } 
# 1113
static constexpr int denorm_min() noexcept { return static_cast< int>(0); } 
# 1115
static constexpr bool is_iec559 = false; 
# 1116
static constexpr bool is_bounded = true; 
# 1117
static constexpr bool is_modulo = false; 
# 1119
static constexpr bool traps = true; 
# 1120
static constexpr bool tinyness_before = false; 
# 1121
static constexpr float_round_style round_style = round_toward_zero; 
# 1123
}; 
# 1127
template<> struct numeric_limits< unsigned>  { 
# 1129
static constexpr bool is_specialized = true; 
# 1132
static constexpr unsigned min() noexcept { return 0; } 
# 1135
static constexpr unsigned max() noexcept { return ((2147483647) * 2U) + (1); } 
# 1139
static constexpr unsigned lowest() noexcept { return min(); } 
# 1142
static constexpr int digits = ((sizeof(unsigned) * (8)) - (((unsigned)(-1)) < (0))); 
# 1144
static constexpr int digits10 = ((((sizeof(unsigned) * (8)) - (((unsigned)(-1)) < (0))) * (643L)) / (2136)); 
# 1147
static constexpr int max_digits10 = 0; 
# 1149
static constexpr bool is_signed = false; 
# 1150
static constexpr bool is_integer = true; 
# 1151
static constexpr bool is_exact = true; 
# 1152
static constexpr int radix = 2; 
# 1155
static constexpr unsigned epsilon() noexcept { return 0; } 
# 1158
static constexpr unsigned round_error() noexcept { return 0; } 
# 1160
static constexpr int min_exponent = 0; 
# 1161
static constexpr int min_exponent10 = 0; 
# 1162
static constexpr int max_exponent = 0; 
# 1163
static constexpr int max_exponent10 = 0; 
# 1165
static constexpr bool has_infinity = false; 
# 1166
static constexpr bool has_quiet_NaN = false; 
# 1167
static constexpr bool has_signaling_NaN = false; 
# 1168
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1170
static constexpr bool has_denorm_loss = false; 
# 1173
static constexpr unsigned infinity() noexcept { return static_cast< unsigned>(0); } 
# 1176
static constexpr unsigned quiet_NaN() noexcept 
# 1177
{ return static_cast< unsigned>(0); } 
# 1180
static constexpr unsigned signaling_NaN() noexcept 
# 1181
{ return static_cast< unsigned>(0); } 
# 1184
static constexpr unsigned denorm_min() noexcept 
# 1185
{ return static_cast< unsigned>(0); } 
# 1187
static constexpr bool is_iec559 = false; 
# 1188
static constexpr bool is_bounded = true; 
# 1189
static constexpr bool is_modulo = true; 
# 1191
static constexpr bool traps = true; 
# 1192
static constexpr bool tinyness_before = false; 
# 1193
static constexpr float_round_style round_style = round_toward_zero; 
# 1195
}; 
# 1199
template<> struct numeric_limits< long>  { 
# 1201
static constexpr bool is_specialized = true; 
# 1204
static constexpr long min() noexcept { return (-9223372036854775807L) - (1); } 
# 1207
static constexpr long max() noexcept { return 9223372036854775807L; } 
# 1211
static constexpr long lowest() noexcept { return min(); } 
# 1214
static constexpr int digits = ((sizeof(long) * (8)) - (((long)(-1)) < (0))); 
# 1215
static constexpr int digits10 = ((((sizeof(long) * (8)) - (((long)(-1)) < (0))) * (643L)) / (2136)); 
# 1217
static constexpr int max_digits10 = 0; 
# 1219
static constexpr bool is_signed = true; 
# 1220
static constexpr bool is_integer = true; 
# 1221
static constexpr bool is_exact = true; 
# 1222
static constexpr int radix = 2; 
# 1225
static constexpr long epsilon() noexcept { return 0; } 
# 1228
static constexpr long round_error() noexcept { return 0; } 
# 1230
static constexpr int min_exponent = 0; 
# 1231
static constexpr int min_exponent10 = 0; 
# 1232
static constexpr int max_exponent = 0; 
# 1233
static constexpr int max_exponent10 = 0; 
# 1235
static constexpr bool has_infinity = false; 
# 1236
static constexpr bool has_quiet_NaN = false; 
# 1237
static constexpr bool has_signaling_NaN = false; 
# 1238
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1240
static constexpr bool has_denorm_loss = false; 
# 1243
static constexpr long infinity() noexcept { return static_cast< long>(0); } 
# 1246
static constexpr long quiet_NaN() noexcept { return static_cast< long>(0); } 
# 1249
static constexpr long signaling_NaN() noexcept { return static_cast< long>(0); } 
# 1252
static constexpr long denorm_min() noexcept { return static_cast< long>(0); } 
# 1254
static constexpr bool is_iec559 = false; 
# 1255
static constexpr bool is_bounded = true; 
# 1256
static constexpr bool is_modulo = false; 
# 1258
static constexpr bool traps = true; 
# 1259
static constexpr bool tinyness_before = false; 
# 1260
static constexpr float_round_style round_style = round_toward_zero; 
# 1262
}; 
# 1266
template<> struct numeric_limits< unsigned long>  { 
# 1268
static constexpr bool is_specialized = true; 
# 1271
static constexpr unsigned long min() noexcept { return 0; } 
# 1274
static constexpr unsigned long max() noexcept { return ((9223372036854775807L) * 2UL) + (1); } 
# 1278
static constexpr unsigned long lowest() noexcept { return min(); } 
# 1281
static constexpr int digits = ((sizeof(unsigned long) * (8)) - (((unsigned long)(-1)) < (0))); 
# 1283
static constexpr int digits10 = ((((sizeof(unsigned long) * (8)) - (((unsigned long)(-1)) < (0))) * (643L)) / (2136)); 
# 1286
static constexpr int max_digits10 = 0; 
# 1288
static constexpr bool is_signed = false; 
# 1289
static constexpr bool is_integer = true; 
# 1290
static constexpr bool is_exact = true; 
# 1291
static constexpr int radix = 2; 
# 1294
static constexpr unsigned long epsilon() noexcept { return 0; } 
# 1297
static constexpr unsigned long round_error() noexcept { return 0; } 
# 1299
static constexpr int min_exponent = 0; 
# 1300
static constexpr int min_exponent10 = 0; 
# 1301
static constexpr int max_exponent = 0; 
# 1302
static constexpr int max_exponent10 = 0; 
# 1304
static constexpr bool has_infinity = false; 
# 1305
static constexpr bool has_quiet_NaN = false; 
# 1306
static constexpr bool has_signaling_NaN = false; 
# 1307
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1309
static constexpr bool has_denorm_loss = false; 
# 1312
static constexpr unsigned long infinity() noexcept 
# 1313
{ return static_cast< unsigned long>(0); } 
# 1316
static constexpr unsigned long quiet_NaN() noexcept 
# 1317
{ return static_cast< unsigned long>(0); } 
# 1320
static constexpr unsigned long signaling_NaN() noexcept 
# 1321
{ return static_cast< unsigned long>(0); } 
# 1324
static constexpr unsigned long denorm_min() noexcept 
# 1325
{ return static_cast< unsigned long>(0); } 
# 1327
static constexpr bool is_iec559 = false; 
# 1328
static constexpr bool is_bounded = true; 
# 1329
static constexpr bool is_modulo = true; 
# 1331
static constexpr bool traps = true; 
# 1332
static constexpr bool tinyness_before = false; 
# 1333
static constexpr float_round_style round_style = round_toward_zero; 
# 1335
}; 
# 1339
template<> struct numeric_limits< long long>  { 
# 1341
static constexpr bool is_specialized = true; 
# 1344
static constexpr long long min() noexcept { return (-9223372036854775807LL) - (1); } 
# 1347
static constexpr long long max() noexcept { return 9223372036854775807LL; } 
# 1351
static constexpr long long lowest() noexcept { return min(); } 
# 1354
static constexpr int digits = ((sizeof(long long) * (8)) - (((long long)(-1)) < (0))); 
# 1356
static constexpr int digits10 = ((((sizeof(long long) * (8)) - (((long long)(-1)) < (0))) * (643L)) / (2136)); 
# 1359
static constexpr int max_digits10 = 0; 
# 1361
static constexpr bool is_signed = true; 
# 1362
static constexpr bool is_integer = true; 
# 1363
static constexpr bool is_exact = true; 
# 1364
static constexpr int radix = 2; 
# 1367
static constexpr long long epsilon() noexcept { return 0; } 
# 1370
static constexpr long long round_error() noexcept { return 0; } 
# 1372
static constexpr int min_exponent = 0; 
# 1373
static constexpr int min_exponent10 = 0; 
# 1374
static constexpr int max_exponent = 0; 
# 1375
static constexpr int max_exponent10 = 0; 
# 1377
static constexpr bool has_infinity = false; 
# 1378
static constexpr bool has_quiet_NaN = false; 
# 1379
static constexpr bool has_signaling_NaN = false; 
# 1380
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1382
static constexpr bool has_denorm_loss = false; 
# 1385
static constexpr long long infinity() noexcept { return static_cast< long long>(0); } 
# 1388
static constexpr long long quiet_NaN() noexcept { return static_cast< long long>(0); } 
# 1391
static constexpr long long signaling_NaN() noexcept 
# 1392
{ return static_cast< long long>(0); } 
# 1395
static constexpr long long denorm_min() noexcept { return static_cast< long long>(0); } 
# 1397
static constexpr bool is_iec559 = false; 
# 1398
static constexpr bool is_bounded = true; 
# 1399
static constexpr bool is_modulo = false; 
# 1401
static constexpr bool traps = true; 
# 1402
static constexpr bool tinyness_before = false; 
# 1403
static constexpr float_round_style round_style = round_toward_zero; 
# 1405
}; 
# 1409
template<> struct numeric_limits< unsigned long long>  { 
# 1411
static constexpr bool is_specialized = true; 
# 1414
static constexpr unsigned long long min() noexcept { return 0; } 
# 1417
static constexpr unsigned long long max() noexcept { return ((9223372036854775807LL) * 2ULL) + (1); } 
# 1421
static constexpr unsigned long long lowest() noexcept { return min(); } 
# 1424
static constexpr int digits = ((sizeof(unsigned long long) * (8)) - (((unsigned long long)(-1)) < (0))); 
# 1426
static constexpr int digits10 = ((((sizeof(unsigned long long) * (8)) - (((unsigned long long)(-1)) < (0))) * (643L)) / (2136)); 
# 1429
static constexpr int max_digits10 = 0; 
# 1431
static constexpr bool is_signed = false; 
# 1432
static constexpr bool is_integer = true; 
# 1433
static constexpr bool is_exact = true; 
# 1434
static constexpr int radix = 2; 
# 1437
static constexpr unsigned long long epsilon() noexcept { return 0; } 
# 1440
static constexpr unsigned long long round_error() noexcept { return 0; } 
# 1442
static constexpr int min_exponent = 0; 
# 1443
static constexpr int min_exponent10 = 0; 
# 1444
static constexpr int max_exponent = 0; 
# 1445
static constexpr int max_exponent10 = 0; 
# 1447
static constexpr bool has_infinity = false; 
# 1448
static constexpr bool has_quiet_NaN = false; 
# 1449
static constexpr bool has_signaling_NaN = false; 
# 1450
static constexpr float_denorm_style has_denorm = denorm_absent; 
# 1452
static constexpr bool has_denorm_loss = false; 
# 1455
static constexpr unsigned long long infinity() noexcept 
# 1456
{ return static_cast< unsigned long long>(0); } 
# 1459
static constexpr unsigned long long quiet_NaN() noexcept 
# 1460
{ return static_cast< unsigned long long>(0); } 
# 1463
static constexpr unsigned long long signaling_NaN() noexcept 
# 1464
{ return static_cast< unsigned long long>(0); } 
# 1467
static constexpr unsigned long long denorm_min() noexcept 
# 1468
{ return static_cast< unsigned long long>(0); } 
# 1470
static constexpr bool is_iec559 = false; 
# 1471
static constexpr bool is_bounded = true; 
# 1472
static constexpr bool is_modulo = true; 
# 1474
static constexpr bool traps = true; 
# 1475
static constexpr bool tinyness_before = false; 
# 1476
static constexpr float_round_style round_style = round_toward_zero; 
# 1478
}; 
# 1636 "/usr/include/c++/9/limits" 3
template<> struct numeric_limits< __int128>  { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return ((((__int128)(-1)) < (0)) ? (-((((__int128)(-1)) < (0)) ? (((((__int128)1) << ((128 - (((__int128)(-1)) < (0))) - 1)) - (1)) << 1) + (1) : (~((__int128)0)))) - (1) : ((__int128)0)); } static constexpr __int128 max() noexcept { return ((((__int128)(-1)) < (0)) ? (((((__int128)1) << ((128 - (((__int128)(-1)) < (0))) - 1)) - (1)) << 1) + (1) : (~((__int128)0))); } static constexpr int digits = (128 - 1); static constexpr int digits10 = (((128 - 1) * 643L) / (2136)); static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast< __int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast< __int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast< __int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast< __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits< unsigned __int128>  { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return ((((unsigned __int128)(-1)) < (0)) ? (((((unsigned __int128)1) << ((128 - (((unsigned __int128)(-1)) < (0))) - 1)) - (1)) << 1) + (1) : (~((unsigned __int128)0))); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = (((128) * 643L) / (2136)); static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast< unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast< unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast< unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast< unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; 
# 1660 "/usr/include/c++/9/limits" 3
template<> struct numeric_limits< float>  { 
# 1662
static constexpr bool is_specialized = true; 
# 1665
static constexpr float min() noexcept { return (1.1754944E-38F); } 
# 1668
static constexpr float max() noexcept { return (3.4028235E38F); } 
# 1672
static constexpr float lowest() noexcept { return -(3.4028235E38F); } 
# 1675
static constexpr int digits = 24; 
# 1676
static constexpr int digits10 = 6; 
# 1678
static constexpr int max_digits10 = ((2) + (((24) * 643L) / (2136))); 
# 1681
static constexpr bool is_signed = true; 
# 1682
static constexpr bool is_integer = false; 
# 1683
static constexpr bool is_exact = false; 
# 1684
static constexpr int radix = 2; 
# 1687
static constexpr float epsilon() noexcept { return (1.1920929E-7F); } 
# 1690
static constexpr float round_error() noexcept { return (0.5F); } 
# 1692
static constexpr int min_exponent = (-125); 
# 1693
static constexpr int min_exponent10 = (-37); 
# 1694
static constexpr int max_exponent = 128; 
# 1695
static constexpr int max_exponent10 = 38; 
# 1697
static constexpr bool has_infinity = (1); 
# 1698
static constexpr bool has_quiet_NaN = (1); 
# 1699
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
# 1700
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1702
static constexpr bool has_denorm_loss = false; 
# 1706
static constexpr float infinity() noexcept { return __builtin_huge_valf(); } 
# 1709
static constexpr float quiet_NaN() noexcept { return __builtin_nanf(""); } 
# 1712
static constexpr float signaling_NaN() noexcept { return __builtin_nansf(""); } 
# 1715
static constexpr float denorm_min() noexcept { return (1.4E-45F); } 
# 1717
static constexpr bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1719
static constexpr bool is_bounded = true; 
# 1720
static constexpr bool is_modulo = false; 
# 1722
static constexpr bool traps = false; 
# 1723
static constexpr bool tinyness_before = false; 
# 1725
static constexpr float_round_style round_style = round_to_nearest; 
# 1727
}; 
# 1735
template<> struct numeric_limits< double>  { 
# 1737
static constexpr bool is_specialized = true; 
# 1740
static constexpr double min() noexcept { return (double)(2.2250738585072013831E-308L); } 
# 1743
static constexpr double max() noexcept { return (double)(1.7976931348623157081E308L); } 
# 1747
static constexpr double lowest() noexcept { return -((double)(1.7976931348623157081E308L)); } 
# 1750
static constexpr int digits = 53; 
# 1751
static constexpr int digits10 = 15; 
# 1753
static constexpr int max_digits10 = ((2) + (((53) * 643L) / (2136))); 
# 1756
static constexpr bool is_signed = true; 
# 1757
static constexpr bool is_integer = false; 
# 1758
static constexpr bool is_exact = false; 
# 1759
static constexpr int radix = 2; 
# 1762
static constexpr double epsilon() noexcept { return (double)(2.2204460492503130808E-16L); } 
# 1765
static constexpr double round_error() noexcept { return (0.5); } 
# 1767
static constexpr int min_exponent = (-1021); 
# 1768
static constexpr int min_exponent10 = (-307); 
# 1769
static constexpr int max_exponent = 1024; 
# 1770
static constexpr int max_exponent10 = 308; 
# 1772
static constexpr bool has_infinity = (1); 
# 1773
static constexpr bool has_quiet_NaN = (1); 
# 1774
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
# 1775
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1777
static constexpr bool has_denorm_loss = false; 
# 1781
static constexpr double infinity() noexcept { return __builtin_huge_val(); } 
# 1784
static constexpr double quiet_NaN() noexcept { return __builtin_nan(""); } 
# 1787
static constexpr double signaling_NaN() noexcept { return __builtin_nans(""); } 
# 1790
static constexpr double denorm_min() noexcept { return (double)(4.940656458412465442E-324L); } 
# 1792
static constexpr bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1794
static constexpr bool is_bounded = true; 
# 1795
static constexpr bool is_modulo = false; 
# 1797
static constexpr bool traps = false; 
# 1798
static constexpr bool tinyness_before = false; 
# 1800
static constexpr float_round_style round_style = round_to_nearest; 
# 1802
}; 
# 1810
template<> struct numeric_limits< long double>  { 
# 1812
static constexpr bool is_specialized = true; 
# 1815
static constexpr long double min() noexcept { return (3.3621031431120935063E-4932L); } 
# 1818
static constexpr long double max() noexcept { return (1.189731495357231765E4932L); } 
# 1822
static constexpr long double lowest() noexcept { return -(1.189731495357231765E4932L); } 
# 1825
static constexpr int digits = 64; 
# 1826
static constexpr int digits10 = 18; 
# 1828
static constexpr int max_digits10 = ((2) + (((64) * 643L) / (2136))); 
# 1831
static constexpr bool is_signed = true; 
# 1832
static constexpr bool is_integer = false; 
# 1833
static constexpr bool is_exact = false; 
# 1834
static constexpr int radix = 2; 
# 1837
static constexpr long double epsilon() noexcept { return (1.084202172485504434E-19L); } 
# 1840
static constexpr long double round_error() noexcept { return (0.5L); } 
# 1842
static constexpr int min_exponent = (-16381); 
# 1843
static constexpr int min_exponent10 = (-4931); 
# 1844
static constexpr int max_exponent = 16384; 
# 1845
static constexpr int max_exponent10 = 4932; 
# 1847
static constexpr bool has_infinity = (1); 
# 1848
static constexpr bool has_quiet_NaN = (1); 
# 1849
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
# 1850
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 
# 1852
static constexpr bool has_denorm_loss = false; 
# 1856
static constexpr long double infinity() noexcept { return __builtin_huge_vall(); } 
# 1859
static constexpr long double quiet_NaN() noexcept { return __builtin_nanl(""); } 
# 1862
static constexpr long double signaling_NaN() noexcept { return __builtin_nansl(""); } 
# 1865
static constexpr long double denorm_min() noexcept { return (3.6E-4951L); } 
# 1867
static constexpr bool is_iec559 = (has_infinity && has_quiet_NaN && (has_denorm == (denorm_present))); 
# 1869
static constexpr bool is_bounded = true; 
# 1870
static constexpr bool is_modulo = false; 
# 1872
static constexpr bool traps = false; 
# 1873
static constexpr bool tinyness_before = false; 
# 1875
static constexpr float_round_style round_style = round_to_nearest; 
# 1877
}; 
# 1884
}
# 37 "/usr/include/c++/9/bits/uniform_int_dist.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
namespace __detail { 
# 44
template< class _Tp> inline bool 
# 46
_Power_of_2(_Tp __x) 
# 47
{ 
# 48
return ((__x - 1) & __x) == 0; 
# 49
} 
# 50
}
# 57
template< class _IntType = int> 
# 58
class uniform_int_distribution { 
# 60
static_assert((std::template is_integral< _IntType> ::value), "template argument must be an integral type");
# 65
public: typedef _IntType result_type; 
# 67
struct param_type { 
# 69
typedef uniform_int_distribution distribution_type; 
# 71
param_type() : param_type(0) { } 
# 74
explicit param_type(_IntType __a, _IntType 
# 75
__b = numeric_limits< _IntType> ::max()) : _M_a(__a), _M_b(__b) 
# 77
{ 
# 78
; 
# 79
} 
# 82
result_type a() const 
# 83
{ return _M_a; } 
# 86
result_type b() const 
# 87
{ return _M_b; } 
# 90
friend inline bool operator==(const param_type &__p1, const param_type &__p2) 
# 91
{ return ((__p1._M_a) == (__p2._M_a)) && ((__p1._M_b) == (__p2._M_b)); } 
# 94
friend inline bool operator!=(const param_type &__p1, const param_type &__p2) 
# 95
{ return !(__p1 == __p2); } 
# 98
private: _IntType _M_a; 
# 99
_IntType _M_b; 
# 100
}; 
# 106
uniform_int_distribution() : uniform_int_distribution(0) { } 
# 112
explicit uniform_int_distribution(_IntType __a, _IntType 
# 113
__b = numeric_limits< _IntType> ::max()) : _M_param(__a, __b) 
# 115
{ } 
# 118
explicit uniform_int_distribution(const param_type &__p) : _M_param(__p) 
# 120
{ } 
# 128
void reset() { } 
# 131
result_type a() const 
# 132
{ return (_M_param).a(); } 
# 135
result_type b() const 
# 136
{ return (_M_param).b(); } 
# 142
param_type param() const 
# 143
{ return _M_param; } 
# 150
void param(const param_type &__param) 
# 151
{ (_M_param) = __param; } 
# 157
result_type min() const 
# 158
{ return a(); } 
# 164
result_type max() const 
# 165
{ return b(); } 
# 170
template< class _UniformRandomNumberGenerator> result_type 
# 172
operator()(_UniformRandomNumberGenerator &__urng) 
# 173
{ return this->operator()(__urng, _M_param); } 
# 175
template< class _UniformRandomNumberGenerator> result_type operator()(_UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 180
template< class _ForwardIterator, class 
# 181
_UniformRandomNumberGenerator> void 
# 183
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 184
__urng) 
# 185
{ this->__generate(__f, __t, __urng, _M_param); } 
# 187
template< class _ForwardIterator, class 
# 188
_UniformRandomNumberGenerator> void 
# 190
__generate(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 191
__urng, const param_type &
# 192
__p) 
# 193
{ this->__generate_impl(__f, __t, __urng, __p); } 
# 195
template< class _UniformRandomNumberGenerator> void 
# 197
__generate(result_type *__f, result_type *__t, _UniformRandomNumberGenerator &
# 198
__urng, const param_type &
# 199
__p) 
# 200
{ this->__generate_impl(__f, __t, __urng, __p); } 
# 207
friend inline bool operator==(const uniform_int_distribution< _IntType>  &__d1, const uniform_int_distribution< _IntType>  &
# 208
__d2) 
# 209
{ return (__d1._M_param) == (__d2._M_param); } 
# 212
private: template< class _ForwardIterator, class 
# 213
_UniformRandomNumberGenerator> void 
# 212
__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator & __urng, const param_type & __p); 
# 219
param_type _M_param; 
# 220
}; 
# 222
template< class _IntType> 
# 223
template< class _UniformRandomNumberGenerator> typename uniform_int_distribution< _IntType> ::result_type 
# 226
uniform_int_distribution< _IntType> ::operator()(_UniformRandomNumberGenerator &__urng, const param_type &
# 227
__param) 
# 228
{ 
# 230
typedef typename _UniformRandomNumberGenerator::result_type _Gresult_type; 
# 231
typedef typename make_unsigned< result_type> ::type __utype; 
# 233
typedef typename common_type< typename _UniformRandomNumberGenerator::result_type, typename make_unsigned< result_type> ::type> ::type __uctype; 
# 235
const __uctype __urngmin = __urng.min(); 
# 236
const __uctype __urngmax = __urng.max(); 
# 237
const __uctype __urngrange = __urngmax - __urngmin; 
# 238
const __uctype __urange = ((__uctype)__param.b()) - ((__uctype)__param.a()); 
# 241
__uctype __ret; 
# 243
if (__urngrange > __urange) 
# 244
{ 
# 246
const __uctype __uerange = __urange + 1; 
# 247
const __uctype __scaling = __urngrange / __uerange; 
# 248
const __uctype __past = __uerange * __scaling; 
# 249
do { 
# 250
__ret = (((__uctype)__urng()) - __urngmin); } 
# 251
while (__ret >= __past); 
# 252
__ret /= __scaling; 
# 253
} else { 
# 254
if (__urngrange < __urange) 
# 255
{ 
# 271 "/usr/include/c++/9/bits/uniform_int_dist.h" 3
__uctype __tmp; 
# 272
do 
# 273
{ 
# 274
const __uctype __uerngrange = __urngrange + 1; 
# 275
__tmp = (__uerngrange * operator()(__urng, param_type(0, __urange / __uerngrange))); 
# 277
__ret = (__tmp + (((__uctype)__urng()) - __urngmin)); 
# 278
} 
# 279
while ((__ret > __urange) || (__ret < __tmp)); 
# 280
} else { 
# 282
__ret = (((__uctype)__urng()) - __urngmin); }  }  
# 284
return __ret + __param.a(); 
# 285
} 
# 288
template< class _IntType> 
# 289
template< class _ForwardIterator, class 
# 290
_UniformRandomNumberGenerator> void 
# 293
uniform_int_distribution< _IntType> ::__generate_impl(_ForwardIterator __f, _ForwardIterator __t, _UniformRandomNumberGenerator &
# 294
__urng, const param_type &
# 295
__param) 
# 296
{ 
# 299
typedef typename _UniformRandomNumberGenerator::result_type _Gresult_type; 
# 300
typedef typename make_unsigned< result_type> ::type __utype; 
# 302
typedef typename common_type< typename _UniformRandomNumberGenerator::result_type, typename make_unsigned< result_type> ::type> ::type __uctype; 
# 304
const __uctype __urngmin = __urng.min(); 
# 305
const __uctype __urngmax = __urng.max(); 
# 306
const __uctype __urngrange = __urngmax - __urngmin; 
# 307
const __uctype __urange = ((__uctype)__param.b()) - ((__uctype)__param.a()); 
# 310
__uctype __ret; 
# 312
if (__urngrange > __urange) 
# 313
{ 
# 314
if (__detail::_Power_of_2(__urngrange + 1) && __detail::_Power_of_2(__urange + 1)) 
# 316
{ 
# 317
while (__f != __t) 
# 318
{ 
# 319
__ret = (((__uctype)__urng()) - __urngmin); 
# 320
(*(__f++)) = ((__ret & __urange) + __param.a()); 
# 321
}  
# 322
} else 
# 324
{ 
# 326
const __uctype __uerange = __urange + 1; 
# 327
const __uctype __scaling = __urngrange / __uerange; 
# 328
const __uctype __past = __uerange * __scaling; 
# 329
while (__f != __t) 
# 330
{ 
# 331
do { 
# 332
__ret = (((__uctype)__urng()) - __urngmin); } 
# 333
while (__ret >= __past); 
# 334
(*(__f++)) = ((__ret / __scaling) + __param.a()); 
# 335
}  
# 336
}  
# 337
} else { 
# 338
if (__urngrange < __urange) 
# 339
{ 
# 355 "/usr/include/c++/9/bits/uniform_int_dist.h" 3
__uctype __tmp; 
# 356
while (__f != __t) 
# 357
{ 
# 358
do 
# 359
{ 
# 360
const __uctype __uerngrange = __urngrange + 1; 
# 361
__tmp = (__uerngrange * operator()(__urng, param_type(0, __urange / __uerngrange))); 
# 363
__ret = (__tmp + (((__uctype)__urng()) - __urngmin)); 
# 364
} 
# 365
while ((__ret > __urange) || (__ret < __tmp)); 
# 366
(*(__f++)) = __ret; 
# 367
}  
# 368
} else { 
# 370
while (__f != __t) { 
# 371
(*(__f++)) = ((((__uctype)__urng()) - __urngmin) + __param.a()); }  }  }  
# 372
} 
# 377
}
# 71 "/usr/include/c++/9/bits/stl_algo.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 76
template< class _Iterator, class _Compare> void 
# 78
__move_median_to_first(_Iterator __result, _Iterator __a, _Iterator __b, _Iterator 
# 79
__c, _Compare __comp) 
# 80
{ 
# 81
if (__comp(__a, __b)) 
# 82
{ 
# 83
if (__comp(__b, __c)) { 
# 84
std::iter_swap(__result, __b); } else { 
# 85
if (__comp(__a, __c)) { 
# 86
std::iter_swap(__result, __c); } else { 
# 88
std::iter_swap(__result, __a); }  }  
# 89
} else { 
# 90
if (__comp(__a, __c)) { 
# 91
std::iter_swap(__result, __a); } else { 
# 92
if (__comp(__b, __c)) { 
# 93
std::iter_swap(__result, __c); } else { 
# 95
std::iter_swap(__result, __b); }  }  }  
# 96
} 
# 99
template< class _InputIterator, class _Predicate> inline _InputIterator 
# 101
__find_if(_InputIterator __first, _InputIterator __last, _Predicate 
# 102
__pred, input_iterator_tag) 
# 103
{ 
# 104
while ((__first != __last) && (!__pred(__first))) { 
# 105
++__first; }  
# 106
return __first; 
# 107
} 
# 110
template< class _RandomAccessIterator, class _Predicate> _RandomAccessIterator 
# 112
__find_if(_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate 
# 113
__pred, random_access_iterator_tag) 
# 114
{ 
# 116
typename iterator_traits< _RandomAccessIterator> ::difference_type __trip_count = (__last - __first) >> 2; 
# 118
for (; __trip_count > 0; --__trip_count) 
# 119
{ 
# 120
if (__pred(__first)) { 
# 121
return __first; }  
# 122
++__first; 
# 124
if (__pred(__first)) { 
# 125
return __first; }  
# 126
++__first; 
# 128
if (__pred(__first)) { 
# 129
return __first; }  
# 130
++__first; 
# 132
if (__pred(__first)) { 
# 133
return __first; }  
# 134
++__first; 
# 135
}  
# 137
switch (__last - __first) 
# 138
{ 
# 139
case 3:  
# 140
if (__pred(__first)) { 
# 141
return __first; }  
# 142
++__first; 
# 143
case 2:  
# 144
if (__pred(__first)) { 
# 145
return __first; }  
# 146
++__first; 
# 147
case 1:  
# 148
if (__pred(__first)) { 
# 149
return __first; }  
# 150
++__first; 
# 151
case 0:  
# 152
default:  
# 153
return __last; 
# 154
}  
# 155
} 
# 157
template< class _Iterator, class _Predicate> inline _Iterator 
# 159
__find_if(_Iterator __first, _Iterator __last, _Predicate __pred) 
# 160
{ 
# 161
return __find_if(__first, __last, __pred, std::__iterator_category(__first)); 
# 163
} 
# 166
template< class _InputIterator, class _Predicate> inline _InputIterator 
# 168
__find_if_not(_InputIterator __first, _InputIterator __last, _Predicate 
# 169
__pred) 
# 170
{ 
# 171
return std::__find_if(__first, __last, __gnu_cxx::__ops::__negate(__pred), std::__iterator_category(__first)); 
# 174
} 
# 179
template< class _InputIterator, class _Predicate, class _Distance> _InputIterator 
# 181
__find_if_not_n(_InputIterator __first, _Distance &__len, _Predicate __pred) 
# 182
{ 
# 183
for (; __len; (--__len), ((void)(++__first))) { 
# 184
if (!__pred(__first)) { 
# 185
break; }  }  
# 186
return __first; 
# 187
} 
# 202 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 203
_BinaryPredicate> _ForwardIterator1 
# 205
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 206
__first2, _ForwardIterator2 __last2, _BinaryPredicate 
# 207
__predicate) 
# 208
{ 
# 210
if ((__first1 == __last1) || (__first2 == __last2)) { 
# 211
return __first1; }  
# 214
_ForwardIterator2 __p1(__first2); 
# 215
if ((++__p1) == __last2) { 
# 216
return std::__find_if(__first1, __last1, __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2)); }  
# 220
_ForwardIterator2 __p; 
# 221
_ForwardIterator1 __current = __first1; 
# 223
for (; ;) 
# 224
{ 
# 225
__first1 = std::__find_if(__first1, __last1, __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2)); 
# 229
if (__first1 == __last1) { 
# 230
return __last1; }  
# 232
__p = __p1; 
# 233
__current = __first1; 
# 234
if ((++__current) == __last1) { 
# 235
return __last1; }  
# 237
while (__predicate(__current, __p)) 
# 238
{ 
# 239
if ((++__p) == __last2) { 
# 240
return __first1; }  
# 241
if ((++__current) == __last1) { 
# 242
return __last1; }  
# 243
}  
# 244
++__first1; 
# 245
}  
# 246
return __first1; 
# 247
} 
# 254
template< class _ForwardIterator, class _Integer, class 
# 255
_UnaryPredicate> _ForwardIterator 
# 257
__search_n_aux(_ForwardIterator __first, _ForwardIterator __last, _Integer 
# 258
__count, _UnaryPredicate __unary_pred, forward_iterator_tag) 
# 260
{ 
# 261
__first = std::__find_if(__first, __last, __unary_pred); 
# 262
while (__first != __last) 
# 263
{ 
# 265
typename iterator_traits< _ForwardIterator> ::difference_type __n = __count; 
# 266
_ForwardIterator __i = __first; 
# 267
++__i; 
# 268
while ((__i != __last) && (__n != 1) && __unary_pred(__i)) 
# 269
{ 
# 270
++__i; 
# 271
--__n; 
# 272
}  
# 273
if (__n == 1) { 
# 274
return __first; }  
# 275
if (__i == __last) { 
# 276
return __last; }  
# 277
__first = std::__find_if(++__i, __last, __unary_pred); 
# 278
}  
# 279
return __last; 
# 280
} 
# 286
template< class _RandomAccessIter, class _Integer, class 
# 287
_UnaryPredicate> _RandomAccessIter 
# 289
__search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last, _Integer 
# 290
__count, _UnaryPredicate __unary_pred, random_access_iterator_tag) 
# 292
{ 
# 294
typedef typename iterator_traits< _RandomAccessIter> ::difference_type _DistanceType; 
# 296
_DistanceType __tailSize = __last - __first; 
# 297
_DistanceType __remainder = __count; 
# 299
while (__remainder <= __tailSize) 
# 300
{ 
# 301
__first += __remainder; 
# 302
__tailSize -= __remainder; 
# 305
_RandomAccessIter __backTrack = __first; 
# 306
while (__unary_pred(--__backTrack)) 
# 307
{ 
# 308
if ((--__remainder) == 0) { 
# 309
return (__first - __count); }  
# 310
}  
# 311
__remainder = ((__count + 1) - (__first - __backTrack)); 
# 312
}  
# 313
return __last; 
# 314
} 
# 316
template< class _ForwardIterator, class _Integer, class 
# 317
_UnaryPredicate> _ForwardIterator 
# 319
__search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer 
# 320
__count, _UnaryPredicate 
# 321
__unary_pred) 
# 322
{ 
# 323
if (__count <= 0) { 
# 324
return __first; }  
# 326
if (__count == 1) { 
# 327
return std::__find_if(__first, __last, __unary_pred); }  
# 329
return std::__search_n_aux(__first, __last, __count, __unary_pred, std::__iterator_category(__first)); 
# 331
} 
# 334
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 335
_BinaryPredicate> _ForwardIterator1 
# 337
__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 338
__first2, _ForwardIterator2 __last2, forward_iterator_tag, forward_iterator_tag, _BinaryPredicate 
# 340
__comp) 
# 341
{ 
# 342
if (__first2 == __last2) { 
# 343
return __last1; }  
# 345
_ForwardIterator1 __result = __last1; 
# 346
while (1) 
# 347
{ 
# 348
_ForwardIterator1 __new_result = std::__search(__first1, __last1, __first2, __last2, __comp); 
# 350
if (__new_result == __last1) { 
# 351
return __result; } else 
# 353
{ 
# 354
__result = __new_result; 
# 355
__first1 = __new_result; 
# 356
++__first1; 
# 357
}  
# 358
}  
# 359
} 
# 362
template< class _BidirectionalIterator1, class _BidirectionalIterator2, class 
# 363
_BinaryPredicate> _BidirectionalIterator1 
# 365
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 
# 366
__last1, _BidirectionalIterator2 
# 367
__first2, _BidirectionalIterator2 
# 368
__last2, bidirectional_iterator_tag, bidirectional_iterator_tag, _BinaryPredicate 
# 370
__comp) 
# 371
{ 
# 378
typedef reverse_iterator< _BidirectionalIterator1>  _RevIterator1; 
# 379
typedef reverse_iterator< _BidirectionalIterator2>  _RevIterator2; 
# 381
_RevIterator1 __rlast1(__first1); 
# 382
_RevIterator2 __rlast2(__first2); 
# 383
_RevIterator1 __rresult = std::__search(((reverse_iterator< _BidirectionalIterator1> )(__last1)), __rlast1, ((reverse_iterator< _BidirectionalIterator2> )(__last2)), __rlast2, __comp); 
# 387
if (__rresult == __rlast1) { 
# 388
return __last1; } else 
# 390
{ 
# 391
_BidirectionalIterator1 __result = __rresult.base(); 
# 392
std::advance(__result, -std::distance(__first2, __last2)); 
# 393
return __result; 
# 394
}  
# 395
} 
# 423 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 
# 425
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 426
__first2, _ForwardIterator2 __last2) 
# 427
{ 
# 434
; 
# 435
; 
# 437
return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 441
} 
# 471 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 472
_BinaryPredicate> inline _ForwardIterator1 
# 474
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 475
__first2, _ForwardIterator2 __last2, _BinaryPredicate 
# 476
__comp) 
# 477
{ 
# 484
; 
# 485
; 
# 487
return std::__find_end(__first1, __last1, __first2, __last2, std::__iterator_category(__first1), std::__iterator_category(__first2), __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 491
} 
# 506 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline bool 
# 508
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 509
{ return __last == std::find_if_not(__first, __last, __pred); } 
# 523 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline bool 
# 525
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 526
{ return __last == std::find_if(__first, __last, __pred); } 
# 541 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline bool 
# 543
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 544
{ return !std::none_of(__first, __last, __pred); } 
# 556 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline _InputIterator 
# 558
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate 
# 559
__pred) 
# 560
{ 
# 565
; 
# 566
return std::__find_if_not(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 568
} 
# 580 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline bool 
# 582
is_partitioned(_InputIterator __first, _InputIterator __last, _Predicate 
# 583
__pred) 
# 584
{ 
# 585
__first = std::find_if_not(__first, __last, __pred); 
# 586
if (__first == __last) { 
# 587
return true; }  
# 588
++__first; 
# 589
return std::none_of(__first, __last, __pred); 
# 590
} 
# 601 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate> _ForwardIterator 
# 603
partition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 604
__pred) 
# 605
{ 
# 612
; 
# 615
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 617
_DistanceType __len = std::distance(__first, __last); 
# 618
_DistanceType __half; 
# 619
_ForwardIterator __middle; 
# 621
while (__len > 0) 
# 622
{ 
# 623
__half = (__len >> 1); 
# 624
__middle = __first; 
# 625
std::advance(__middle, __half); 
# 626
if (__pred(*__middle)) 
# 627
{ 
# 628
__first = __middle; 
# 629
++__first; 
# 630
__len = ((__len - __half) - 1); 
# 631
} else { 
# 633
__len = __half; }  
# 634
}  
# 635
return __first; 
# 636
} 
# 639
template< class _InputIterator, class _OutputIterator, class 
# 640
_Predicate> _OutputIterator 
# 642
__remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 643
__result, _Predicate __pred) 
# 644
{ 
# 645
for (; __first != __last; ++__first) { 
# 646
if (!__pred(__first)) 
# 647
{ 
# 648
(*__result) = (*__first); 
# 649
++__result; 
# 650
}  }  
# 651
return __result; 
# 652
} 
# 668 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class _Tp> inline _OutputIterator 
# 670
remove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 671
__result, const _Tp &__value) 
# 672
{ 
# 679
; 
# 681
return std::__remove_copy_if(__first, __last, __result, __gnu_cxx::__ops::__iter_equals_val(__value)); 
# 683
} 
# 700 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 701
_Predicate> inline _OutputIterator 
# 703
remove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 704
__result, _Predicate __pred) 
# 705
{ 
# 712
; 
# 714
return std::__remove_copy_if(__first, __last, __result, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 716
} 
# 734 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 735
_Predicate> _OutputIterator 
# 737
copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 738
__result, _Predicate __pred) 
# 739
{ 
# 746
; 
# 748
for (; __first != __last; ++__first) { 
# 749
if (__pred(*__first)) 
# 750
{ 
# 751
(*__result) = (*__first); 
# 752
++__result; 
# 753
}  }  
# 754
return __result; 
# 755
} 
# 757
template< class _InputIterator, class _Size, class _OutputIterator> _OutputIterator 
# 759
__copy_n(_InputIterator __first, _Size __n, _OutputIterator 
# 760
__result, input_iterator_tag) 
# 761
{ 
# 762
if (__n > 0) 
# 763
{ 
# 764
while (true) 
# 765
{ 
# 766
(*__result) = (*__first); 
# 767
++__result; 
# 768
if ((--__n) > 0) { 
# 769
++__first; } else { 
# 771
break; }  
# 772
}  
# 773
}  
# 774
return __result; 
# 775
} 
# 777
template< class _RandomAccessIterator, class _Size, class 
# 778
_OutputIterator> inline _OutputIterator 
# 780
__copy_n(_RandomAccessIterator __first, _Size __n, _OutputIterator 
# 781
__result, random_access_iterator_tag) 
# 782
{ return std::copy(__first, __first + __n, __result); } 
# 797 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Size, class _OutputIterator> inline _OutputIterator 
# 799
copy_n(_InputIterator __first, _Size __n, _OutputIterator __result) 
# 800
{ 
# 806
if (__n <= 0) { 
# 807
return __result; }  
# 809
; 
# 810
; 
# 812
return std::__copy_n(__first, __n, __result, std::__iterator_category(__first)); 
# 814
} 
# 831 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator1, class 
# 832
_OutputIterator2, class _Predicate> pair< _OutputIterator1, _OutputIterator2>  
# 834
partition_copy(_InputIterator __first, _InputIterator __last, _OutputIterator1 
# 835
__out_true, _OutputIterator2 __out_false, _Predicate 
# 836
__pred) 
# 837
{ 
# 846
; 
# 848
for (; __first != __last; ++__first) { 
# 849
if (__pred(*__first)) 
# 850
{ 
# 851
(*__out_true) = (*__first); 
# 852
++__out_true; 
# 853
} else 
# 855
{ 
# 856
(*__out_false) = (*__first); 
# 857
++__out_false; 
# 858
}  }  
# 860
return pair< _OutputIterator1, _OutputIterator2> (__out_true, __out_false); 
# 861
} 
# 864
template< class _ForwardIterator, class _Predicate> _ForwardIterator 
# 866
__remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 867
__pred) 
# 868
{ 
# 869
__first = std::__find_if(__first, __last, __pred); 
# 870
if (__first == __last) { 
# 871
return __first; }  
# 872
_ForwardIterator __result = __first; 
# 873
++__first; 
# 874
for (; __first != __last; ++__first) { 
# 875
if (!__pred(__first)) 
# 876
{ 
# 877
(*__result) = std::move(*__first); 
# 878
++__result; 
# 879
}  }  
# 880
return __result; 
# 881
} 
# 900 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 902
remove(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 903
__value) 
# 904
{ 
# 910
; 
# 912
return std::__remove_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__value)); 
# 914
} 
# 933 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate> inline _ForwardIterator 
# 935
remove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 936
__pred) 
# 937
{ 
# 943
; 
# 945
return std::__remove_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 947
} 
# 949
template< class _ForwardIterator, class _BinaryPredicate> _ForwardIterator 
# 951
__adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate 
# 952
__binary_pred) 
# 953
{ 
# 954
if (__first == __last) { 
# 955
return __last; }  
# 956
_ForwardIterator __next = __first; 
# 957
while ((++__next) != __last) 
# 958
{ 
# 959
if (__binary_pred(__first, __next)) { 
# 960
return __first; }  
# 961
__first = __next; 
# 962
}  
# 963
return __last; 
# 964
} 
# 966
template< class _ForwardIterator, class _BinaryPredicate> _ForwardIterator 
# 968
__unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate 
# 969
__binary_pred) 
# 970
{ 
# 972
__first = std::__adjacent_find(__first, __last, __binary_pred); 
# 973
if (__first == __last) { 
# 974
return __last; }  
# 977
_ForwardIterator __dest = __first; 
# 978
++__first; 
# 979
while ((++__first) != __last) { 
# 980
if (!__binary_pred(__dest, __first)) { 
# 981
(*(++__dest)) = std::move(*__first); }  }  
# 982
return ++__dest; 
# 983
} 
# 999 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 1001
unique(_ForwardIterator __first, _ForwardIterator __last) 
# 1002
{ 
# 1008
; 
# 1010
return std::__unique(__first, __last, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 1012
} 
# 1029 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _BinaryPredicate> inline _ForwardIterator 
# 1031
unique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate 
# 1032
__binary_pred) 
# 1033
{ 
# 1040
; 
# 1042
return std::__unique(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred)); 
# 1044
} 
# 1052
template< class _ForwardIterator, class _OutputIterator, class 
# 1053
_BinaryPredicate> _OutputIterator 
# 1055
__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator 
# 1056
__result, _BinaryPredicate __binary_pred, forward_iterator_tag, output_iterator_tag) 
# 1058
{ 
# 1064
_ForwardIterator __next = __first; 
# 1065
(*__result) = (*__first); 
# 1066
while ((++__next) != __last) { 
# 1067
if (!__binary_pred(__first, __next)) 
# 1068
{ 
# 1069
__first = __next; 
# 1070
(*(++__result)) = (*__first); 
# 1071
}  }  
# 1072
return ++__result; 
# 1073
} 
# 1081
template< class _InputIterator, class _OutputIterator, class 
# 1082
_BinaryPredicate> _OutputIterator 
# 1084
__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 1085
__result, _BinaryPredicate __binary_pred, input_iterator_tag, output_iterator_tag) 
# 1087
{ 
# 1093
typename iterator_traits< _InputIterator> ::value_type __value = (*__first); 
# 1095
__decltype((__gnu_cxx::__ops::__iter_comp_val(__binary_pred))) __rebound_pred = __gnu_cxx::__ops::__iter_comp_val(__binary_pred); 
# 1097
(*__result) = __value; 
# 1098
while ((++__first) != __last) { 
# 1099
if (!__rebound_pred(__first, __value)) 
# 1100
{ 
# 1101
__value = (*__first); 
# 1102
(*(++__result)) = __value; 
# 1103
}  }  
# 1104
return ++__result; 
# 1105
} 
# 1113
template< class _InputIterator, class _ForwardIterator, class 
# 1114
_BinaryPredicate> _ForwardIterator 
# 1116
__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 1117
__result, _BinaryPredicate __binary_pred, input_iterator_tag, forward_iterator_tag) 
# 1119
{ 
# 1124
(*__result) = (*__first); 
# 1125
while ((++__first) != __last) { 
# 1126
if (!__binary_pred(__result, __first)) { 
# 1127
(*(++__result)) = (*__first); }  }  
# 1128
return ++__result; 
# 1129
} 
# 1136
template< class _BidirectionalIterator> void 
# 1138
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag) 
# 1140
{ 
# 1141
while (true) { 
# 1142
if ((__first == __last) || (__first == (--__last))) { 
# 1143
return; } else 
# 1145
{ 
# 1146
std::iter_swap(__first, __last); 
# 1147
++__first; 
# 1148
}  }  
# 1149
} 
# 1156
template< class _RandomAccessIterator> void 
# 1158
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag) 
# 1160
{ 
# 1161
if (__first == __last) { 
# 1162
return; }  
# 1163
--__last; 
# 1164
while (__first < __last) 
# 1165
{ 
# 1166
std::iter_swap(__first, __last); 
# 1167
++__first; 
# 1168
--__last; 
# 1169
}  
# 1170
} 
# 1184 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator> inline void 
# 1186
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last) 
# 1187
{ 
# 1191
; 
# 1192
std::__reverse(__first, __last, std::__iterator_category(__first)); 
# 1193
} 
# 1211 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _OutputIterator> _OutputIterator 
# 1213
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator 
# 1214
__result) 
# 1215
{ 
# 1221
; 
# 1223
while (__first != __last) 
# 1224
{ 
# 1225
--__last; 
# 1226
(*__result) = (*__last); 
# 1227
++__result; 
# 1228
}  
# 1229
return __result; 
# 1230
} 
# 1236
template< class _EuclideanRingElement> _EuclideanRingElement 
# 1238
__gcd(_EuclideanRingElement __m, _EuclideanRingElement __n) 
# 1239
{ 
# 1240
while (__n != 0) 
# 1241
{ 
# 1242
_EuclideanRingElement __t = __m % __n; 
# 1243
__m = __n; 
# 1244
__n = __t; 
# 1245
}  
# 1246
return __m; 
# 1247
} 
# 1249
inline namespace _V2 { 
# 1253
template< class _ForwardIterator> _ForwardIterator 
# 1255
__rotate(_ForwardIterator __first, _ForwardIterator 
# 1256
__middle, _ForwardIterator 
# 1257
__last, forward_iterator_tag) 
# 1259
{ 
# 1260
if (__first == __middle) { 
# 1261
return __last; } else { 
# 1262
if (__last == __middle) { 
# 1263
return __first; }  }  
# 1265
_ForwardIterator __first2 = __middle; 
# 1266
do 
# 1267
{ 
# 1268
std::iter_swap(__first, __first2); 
# 1269
++__first; 
# 1270
++__first2; 
# 1271
if (__first == __middle) { 
# 1272
__middle = __first2; }  
# 1273
} 
# 1274
while (__first2 != __last); 
# 1276
_ForwardIterator __ret = __first; 
# 1278
__first2 = __middle; 
# 1280
while (__first2 != __last) 
# 1281
{ 
# 1282
std::iter_swap(__first, __first2); 
# 1283
++__first; 
# 1284
++__first2; 
# 1285
if (__first == __middle) { 
# 1286
__middle = __first2; } else { 
# 1287
if (__first2 == __last) { 
# 1288
__first2 = __middle; }  }  
# 1289
}  
# 1290
return __ret; 
# 1291
} 
# 1294
template< class _BidirectionalIterator> _BidirectionalIterator 
# 1296
__rotate(_BidirectionalIterator __first, _BidirectionalIterator 
# 1297
__middle, _BidirectionalIterator 
# 1298
__last, bidirectional_iterator_tag) 
# 1300
{ 
# 1305
if (__first == __middle) { 
# 1306
return __last; } else { 
# 1307
if (__last == __middle) { 
# 1308
return __first; }  }  
# 1310
std::__reverse(__first, __middle, bidirectional_iterator_tag()); 
# 1311
std::__reverse(__middle, __last, bidirectional_iterator_tag()); 
# 1313
while ((__first != __middle) && (__middle != __last)) 
# 1314
{ 
# 1315
std::iter_swap(__first, --__last); 
# 1316
++__first; 
# 1317
}  
# 1319
if (__first == __middle) 
# 1320
{ 
# 1321
std::__reverse(__middle, __last, bidirectional_iterator_tag()); 
# 1322
return __last; 
# 1323
} else 
# 1325
{ 
# 1326
std::__reverse(__first, __middle, bidirectional_iterator_tag()); 
# 1327
return __first; 
# 1328
}  
# 1329
} 
# 1332
template< class _RandomAccessIterator> _RandomAccessIterator 
# 1334
__rotate(_RandomAccessIterator __first, _RandomAccessIterator 
# 1335
__middle, _RandomAccessIterator 
# 1336
__last, random_access_iterator_tag) 
# 1338
{ 
# 1343
if (__first == __middle) { 
# 1344
return __last; } else { 
# 1345
if (__last == __middle) { 
# 1346
return __first; }  }  
# 1349
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _Distance; 
# 1351
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 1353
_Distance __n = __last - __first; 
# 1354
_Distance __k = __middle - __first; 
# 1356
if (__k == (__n - __k)) 
# 1357
{ 
# 1358
std::swap_ranges(__first, __middle, __middle); 
# 1359
return __middle; 
# 1360
}  
# 1362
_RandomAccessIterator __p = __first; 
# 1363
_RandomAccessIterator __ret = __first + (__last - __middle); 
# 1365
for (; ;) 
# 1366
{ 
# 1367
if (__k < (__n - __k)) 
# 1368
{ 
# 1369
if (__is_pod(_ValueType) && (__k == 1)) 
# 1370
{ 
# 1371
_ValueType __t = std::move(*__p); 
# 1372
std::move(__p + 1, __p + __n, __p); 
# 1373
(*((__p + __n) - 1)) = std::move(__t); 
# 1374
return __ret; 
# 1375
}  
# 1376
_RandomAccessIterator __q = __p + __k; 
# 1377
for (_Distance __i = (0); __i < (__n - __k); ++__i) 
# 1378
{ 
# 1379
std::iter_swap(__p, __q); 
# 1380
++__p; 
# 1381
++__q; 
# 1382
}  
# 1383
__n %= __k; 
# 1384
if (__n == 0) { 
# 1385
return __ret; }  
# 1386
std::swap(__n, __k); 
# 1387
__k = (__n - __k); 
# 1388
} else 
# 1390
{ 
# 1391
__k = (__n - __k); 
# 1392
if (__is_pod(_ValueType) && (__k == 1)) 
# 1393
{ 
# 1394
_ValueType __t = std::move(*((__p + __n) - 1)); 
# 1395
std::move_backward(__p, (__p + __n) - 1, __p + __n); 
# 1396
(*__p) = std::move(__t); 
# 1397
return __ret; 
# 1398
}  
# 1399
_RandomAccessIterator __q = __p + __n; 
# 1400
__p = (__q - __k); 
# 1401
for (_Distance __i = (0); __i < (__n - __k); ++__i) 
# 1402
{ 
# 1403
--__p; 
# 1404
--__q; 
# 1405
std::iter_swap(__p, __q); 
# 1406
}  
# 1407
__n %= __k; 
# 1408
if (__n == 0) { 
# 1409
return __ret; }  
# 1410
std::swap(__n, __k); 
# 1411
}  
# 1412
}  
# 1413
} 
# 1438 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 1440
rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator 
# 1441
__last) 
# 1442
{ 
# 1446
; 
# 1447
; 
# 1449
return std::__rotate(__first, __middle, __last, std::__iterator_category(__first)); 
# 1451
} 
# 1453
}
# 1475 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _OutputIterator> inline _OutputIterator 
# 1477
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator 
# 1478
__last, _OutputIterator __result) 
# 1479
{ 
# 1484
; 
# 1485
; 
# 1487
return std::copy(__first, __middle, std::copy(__middle, __last, __result)); 
# 1489
} 
# 1492
template< class _ForwardIterator, class _Predicate> _ForwardIterator 
# 1494
__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 1495
__pred, forward_iterator_tag) 
# 1496
{ 
# 1497
if (__first == __last) { 
# 1498
return __first; }  
# 1500
while (__pred(*__first)) { 
# 1501
if ((++__first) == __last) { 
# 1502
return __first; }  }  
# 1504
_ForwardIterator __next = __first; 
# 1506
while ((++__next) != __last) { 
# 1507
if (__pred(*__next)) 
# 1508
{ 
# 1509
std::iter_swap(__first, __next); 
# 1510
++__first; 
# 1511
}  }  
# 1513
return __first; 
# 1514
} 
# 1517
template< class _BidirectionalIterator, class _Predicate> _BidirectionalIterator 
# 1519
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate 
# 1520
__pred, bidirectional_iterator_tag) 
# 1521
{ 
# 1522
while (true) 
# 1523
{ 
# 1524
while (true) { 
# 1525
if (__first == __last) { 
# 1526
return __first; } else { 
# 1527
if (__pred(*__first)) { 
# 1528
++__first; } else { 
# 1530
break; }  }  }  
# 1531
--__last; 
# 1532
while (true) { 
# 1533
if (__first == __last) { 
# 1534
return __first; } else { 
# 1535
if (!((bool)__pred(*__last))) { 
# 1536
--__last; } else { 
# 1538
break; }  }  }  
# 1539
std::iter_swap(__first, __last); 
# 1540
++__first; 
# 1541
}  
# 1542
} 
# 1552 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Pointer, class _Predicate, class 
# 1553
_Distance> _ForwardIterator 
# 1555
__stable_partition_adaptive(_ForwardIterator __first, _ForwardIterator 
# 1556
__last, _Predicate 
# 1557
__pred, _Distance __len, _Pointer 
# 1558
__buffer, _Distance 
# 1559
__buffer_size) 
# 1560
{ 
# 1561
if (__len == 1) { 
# 1562
return __first; }  
# 1564
if (__len <= __buffer_size) 
# 1565
{ 
# 1566
_ForwardIterator __result1 = __first; 
# 1567
_Pointer __result2 = __buffer; 
# 1572
(*__result2) = std::move(*__first); 
# 1573
++__result2; 
# 1574
++__first; 
# 1575
for (; __first != __last; ++__first) { 
# 1576
if (__pred(__first)) 
# 1577
{ 
# 1578
(*__result1) = std::move(*__first); 
# 1579
++__result1; 
# 1580
} else 
# 1582
{ 
# 1583
(*__result2) = std::move(*__first); 
# 1584
++__result2; 
# 1585
}  }  
# 1587
std::move(__buffer, __result2, __result1); 
# 1588
return __result1; 
# 1589
}  
# 1591
_ForwardIterator __middle = __first; 
# 1592
std::advance(__middle, __len / 2); 
# 1593
_ForwardIterator __left_split = std::__stable_partition_adaptive(__first, __middle, __pred, __len / 2, __buffer, __buffer_size); 
# 1600
_Distance __right_len = __len - (__len / 2); 
# 1601
_ForwardIterator __right_split = std::__find_if_not_n(__middle, __right_len, __pred); 
# 1604
if (__right_len) { 
# 1605
__right_split = std::__stable_partition_adaptive(__right_split, __last, __pred, __right_len, __buffer, __buffer_size); }  
# 1610
return std::rotate(__left_split, __middle, __right_split); 
# 1611
} 
# 1613
template< class _ForwardIterator, class _Predicate> _ForwardIterator 
# 1615
__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 1616
__pred) 
# 1617
{ 
# 1618
__first = std::__find_if_not(__first, __last, __pred); 
# 1620
if (__first == __last) { 
# 1621
return __first; }  
# 1624
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 1626
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 1629
_Temporary_buffer< _ForwardIterator, typename iterator_traits< _ForwardIterator> ::value_type>  __buf(__first, std::distance(__first, __last)); 
# 1630
return std::__stable_partition_adaptive(__first, __last, __pred, (_DistanceType)__buf.requested_size(), __buf.begin(), (_DistanceType)__buf.size()); 
# 1635
} 
# 1654 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate> inline _ForwardIterator 
# 1656
stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 1657
__pred) 
# 1658
{ 
# 1664
; 
# 1666
return std::__stable_partition(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 1668
} 
# 1671
template< class _RandomAccessIterator, class _Compare> void 
# 1673
__heap_select(_RandomAccessIterator __first, _RandomAccessIterator 
# 1674
__middle, _RandomAccessIterator 
# 1675
__last, _Compare __comp) 
# 1676
{ 
# 1677
std::__make_heap(__first, __middle, __comp); 
# 1678
for (_RandomAccessIterator __i = __middle; __i < __last; ++__i) { 
# 1679
if (__comp(__i, __first)) { 
# 1680
std::__pop_heap(__first, __middle, __i, __comp); }  }  
# 1681
} 
# 1685
template< class _InputIterator, class _RandomAccessIterator, class 
# 1686
_Compare> _RandomAccessIterator 
# 1688
__partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator 
# 1689
__result_first, _RandomAccessIterator 
# 1690
__result_last, _Compare 
# 1691
__comp) 
# 1692
{ 
# 1694
typedef typename iterator_traits< _InputIterator> ::value_type _InputValueType; 
# 1695
typedef iterator_traits< _RandomAccessIterator>  _RItTraits; 
# 1696
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 1698
if (__result_first == __result_last) { 
# 1699
return __result_last; }  
# 1700
_RandomAccessIterator __result_real_last = __result_first; 
# 1701
while ((__first != __last) && (__result_real_last != __result_last)) 
# 1702
{ 
# 1703
(*__result_real_last) = (*__first); 
# 1704
++__result_real_last; 
# 1705
++__first; 
# 1706
}  
# 1708
std::__make_heap(__result_first, __result_real_last, __comp); 
# 1709
while (__first != __last) 
# 1710
{ 
# 1711
if (__comp(__first, __result_first)) { 
# 1712
std::__adjust_heap(__result_first, (_DistanceType)0, (_DistanceType)(__result_real_last - __result_first), (_InputValueType)(*__first), __comp); }  
# 1716
++__first; 
# 1717
}  
# 1718
std::__sort_heap(__result_first, __result_real_last, __comp); 
# 1719
return __result_real_last; 
# 1720
} 
# 1740 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _RandomAccessIterator> inline _RandomAccessIterator 
# 1742
partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator 
# 1743
__result_first, _RandomAccessIterator 
# 1744
__result_last) 
# 1745
{ 
# 1760 "/usr/include/c++/9/bits/stl_algo.h" 3
; 
# 1761
; 
# 1762
; 
# 1764
return std::__partial_sort_copy(__first, __last, __result_first, __result_last, __gnu_cxx::__ops::__iter_less_iter()); 
# 1767
} 
# 1789 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _RandomAccessIterator, class 
# 1790
_Compare> inline _RandomAccessIterator 
# 1792
partial_sort_copy(_InputIterator __first, _InputIterator __last, _RandomAccessIterator 
# 1793
__result_first, _RandomAccessIterator 
# 1794
__result_last, _Compare 
# 1795
__comp) 
# 1796
{ 
# 1814 "/usr/include/c++/9/bits/stl_algo.h" 3
; 
# 1815
; 
# 1816
; 
# 1818
return std::__partial_sort_copy(__first, __last, __result_first, __result_last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 1821
} 
# 1824
template< class _RandomAccessIterator, class _Compare> void 
# 1826
__unguarded_linear_insert(_RandomAccessIterator __last, _Compare 
# 1827
__comp) 
# 1828
{ 
# 1830
typename iterator_traits< _RandomAccessIterator> ::value_type __val = std::move(*__last); 
# 1831
_RandomAccessIterator __next = __last; 
# 1832
--__next; 
# 1833
while (__comp(__val, __next)) 
# 1834
{ 
# 1835
(*__last) = std::move(*__next); 
# 1836
__last = __next; 
# 1837
--__next; 
# 1838
}  
# 1839
(*__last) = std::move(__val); 
# 1840
} 
# 1843
template< class _RandomAccessIterator, class _Compare> void 
# 1845
__insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 1846
__last, _Compare __comp) 
# 1847
{ 
# 1848
if (__first == __last) { return; }  
# 1850
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) 
# 1851
{ 
# 1852
if (__comp(__i, __first)) 
# 1853
{ 
# 1855
typename iterator_traits< _RandomAccessIterator> ::value_type __val = std::move(*__i); 
# 1856
std::move_backward(__first, __i, __i + 1); 
# 1857
(*__first) = std::move(__val); 
# 1858
} else { 
# 1860
std::__unguarded_linear_insert(__i, __gnu_cxx::__ops::__val_comp_iter(__comp)); }  
# 1862
}  
# 1863
} 
# 1866
template< class _RandomAccessIterator, class _Compare> inline void 
# 1868
__unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 1869
__last, _Compare __comp) 
# 1870
{ 
# 1871
for (_RandomAccessIterator __i = __first; __i != __last; ++__i) { 
# 1872
std::__unguarded_linear_insert(__i, __gnu_cxx::__ops::__val_comp_iter(__comp)); }  
# 1874
} 
# 1880
enum { _S_threshold = 16}; 
# 1883
template< class _RandomAccessIterator, class _Compare> void 
# 1885
__final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 1886
__last, _Compare __comp) 
# 1887
{ 
# 1888
if ((__last - __first) > ((int)_S_threshold)) 
# 1889
{ 
# 1890
std::__insertion_sort(__first, __first + ((int)_S_threshold), __comp); 
# 1891
std::__unguarded_insertion_sort(__first + ((int)_S_threshold), __last, __comp); 
# 1893
} else { 
# 1895
std::__insertion_sort(__first, __last, __comp); }  
# 1896
} 
# 1899
template< class _RandomAccessIterator, class _Compare> _RandomAccessIterator 
# 1901
__unguarded_partition(_RandomAccessIterator __first, _RandomAccessIterator 
# 1902
__last, _RandomAccessIterator 
# 1903
__pivot, _Compare __comp) 
# 1904
{ 
# 1905
while (true) 
# 1906
{ 
# 1907
while (__comp(__first, __pivot)) { 
# 1908
++__first; }  
# 1909
--__last; 
# 1910
while (__comp(__pivot, __last)) { 
# 1911
--__last; }  
# 1912
if (!(__first < __last)) { 
# 1913
return __first; }  
# 1914
std::iter_swap(__first, __last); 
# 1915
++__first; 
# 1916
}  
# 1917
} 
# 1920
template< class _RandomAccessIterator, class _Compare> inline _RandomAccessIterator 
# 1922
__unguarded_partition_pivot(_RandomAccessIterator __first, _RandomAccessIterator 
# 1923
__last, _Compare __comp) 
# 1924
{ 
# 1925
_RandomAccessIterator __mid = __first + ((__last - __first) / 2); 
# 1926
std::__move_median_to_first(__first, __first + 1, __mid, __last - 1, __comp); 
# 1928
return std::__unguarded_partition(__first + 1, __last, __first, __comp); 
# 1929
} 
# 1931
template< class _RandomAccessIterator, class _Compare> inline void 
# 1933
__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 1934
__middle, _RandomAccessIterator 
# 1935
__last, _Compare 
# 1936
__comp) 
# 1937
{ 
# 1938
std::__heap_select(__first, __middle, __last, __comp); 
# 1939
std::__sort_heap(__first, __middle, __comp); 
# 1940
} 
# 1943
template< class _RandomAccessIterator, class _Size, class _Compare> void 
# 1945
__introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator 
# 1946
__last, _Size 
# 1947
__depth_limit, _Compare __comp) 
# 1948
{ 
# 1949
while ((__last - __first) > ((int)_S_threshold)) 
# 1950
{ 
# 1951
if (__depth_limit == 0) 
# 1952
{ 
# 1953
std::__partial_sort(__first, __last, __last, __comp); 
# 1954
return; 
# 1955
}  
# 1956
--__depth_limit; 
# 1957
_RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp); 
# 1959
std::__introsort_loop(__cut, __last, __depth_limit, __comp); 
# 1960
__last = __cut; 
# 1961
}  
# 1962
} 
# 1966
template< class _RandomAccessIterator, class _Compare> inline void 
# 1968
__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 1969
__comp) 
# 1970
{ 
# 1971
if (__first != __last) 
# 1972
{ 
# 1973
std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2, __comp); 
# 1976
std::__final_insertion_sort(__first, __last, __comp); 
# 1977
}  
# 1978
} 
# 1980
template< class _RandomAccessIterator, class _Size, class _Compare> void 
# 1982
__introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator 
# 1983
__last, _Size __depth_limit, _Compare 
# 1984
__comp) 
# 1985
{ 
# 1986
while ((__last - __first) > 3) 
# 1987
{ 
# 1988
if (__depth_limit == 0) 
# 1989
{ 
# 1990
std::__heap_select(__first, __nth + 1, __last, __comp); 
# 1992
std::iter_swap(__first, __nth); 
# 1993
return; 
# 1994
}  
# 1995
--__depth_limit; 
# 1996
_RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp); 
# 1998
if (__cut <= __nth) { 
# 1999
__first = __cut; } else { 
# 2001
__last = __cut; }  
# 2002
}  
# 2003
std::__insertion_sort(__first, __last, __comp); 
# 2004
} 
# 2026 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp, class _Compare> inline _ForwardIterator 
# 2028
lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2029
__val, _Compare __comp) 
# 2030
{ 
# 2036
; 
# 2038
return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 2040
} 
# 2042
template< class _ForwardIterator, class _Tp, class _Compare> _ForwardIterator 
# 2044
__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2045
__val, _Compare __comp) 
# 2046
{ 
# 2048
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 2050
_DistanceType __len = std::distance(__first, __last); 
# 2052
while (__len > 0) 
# 2053
{ 
# 2054
_DistanceType __half = __len >> 1; 
# 2055
_ForwardIterator __middle = __first; 
# 2056
std::advance(__middle, __half); 
# 2057
if (__comp(__val, __middle)) { 
# 2058
__len = __half; } else 
# 2060
{ 
# 2061
__first = __middle; 
# 2062
++__first; 
# 2063
__len = ((__len - __half) - 1); 
# 2064
}  
# 2065
}  
# 2066
return __first; 
# 2067
} 
# 2080 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 2082
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2083
__val) 
# 2084
{ 
# 2089
; 
# 2091
return std::__upper_bound(__first, __last, __val, __gnu_cxx::__ops::__val_less_iter()); 
# 2093
} 
# 2110 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp, class _Compare> inline _ForwardIterator 
# 2112
upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2113
__val, _Compare __comp) 
# 2114
{ 
# 2120
; 
# 2122
return std::__upper_bound(__first, __last, __val, __gnu_cxx::__ops::__val_comp_iter(__comp)); 
# 2124
} 
# 2126
template< class _ForwardIterator, class _Tp, class 
# 2127
_CompareItTp, class _CompareTpIt> pair< _ForwardIterator, _ForwardIterator>  
# 2129
__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2130
__val, _CompareItTp 
# 2131
__comp_it_val, _CompareTpIt __comp_val_it) 
# 2132
{ 
# 2134
typedef typename iterator_traits< _ForwardIterator> ::difference_type _DistanceType; 
# 2136
_DistanceType __len = std::distance(__first, __last); 
# 2138
while (__len > 0) 
# 2139
{ 
# 2140
_DistanceType __half = __len >> 1; 
# 2141
_ForwardIterator __middle = __first; 
# 2142
std::advance(__middle, __half); 
# 2143
if (__comp_it_val(__middle, __val)) 
# 2144
{ 
# 2145
__first = __middle; 
# 2146
++__first; 
# 2147
__len = ((__len - __half) - 1); 
# 2148
} else { 
# 2149
if (__comp_val_it(__val, __middle)) { 
# 2150
__len = __half; } else 
# 2152
{ 
# 2153
_ForwardIterator __left = std::__lower_bound(__first, __middle, __val, __comp_it_val); 
# 2155
std::advance(__first, __len); 
# 2156
_ForwardIterator __right = std::__upper_bound(++__middle, __first, __val, __comp_val_it); 
# 2158
return pair< _ForwardIterator, _ForwardIterator> (__left, __right); 
# 2159
}  }  
# 2160
}  
# 2161
return pair< _ForwardIterator, _ForwardIterator> (__first, __first); 
# 2162
} 
# 2181 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> inline pair< _ForwardIterator, _ForwardIterator>  
# 2183
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2184
__val) 
# 2185
{ 
# 2192
; 
# 2193
; 
# 2195
return std::__equal_range(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val(), __gnu_cxx::__ops::__val_less_iter()); 
# 2198
} 
# 2217 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp, class _Compare> inline pair< _ForwardIterator, _ForwardIterator>  
# 2219
equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2220
__val, _Compare __comp) 
# 2221
{ 
# 2229
; 
# 2231
; 
# 2233
return std::__equal_range(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp), __gnu_cxx::__ops::__val_comp_iter(__comp)); 
# 2236
} 
# 2250 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> bool 
# 2252
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2253
__val) 
# 2254
{ 
# 2259
; 
# 2260
; 
# 2262
_ForwardIterator __i = std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val()); 
# 2265
return (__i != __last) && (!(__val < (*__i))); 
# 2266
} 
# 2283 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp, class _Compare> bool 
# 2285
binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 2286
__val, _Compare __comp) 
# 2287
{ 
# 2293
; 
# 2295
; 
# 2297
_ForwardIterator __i = std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 2300
return (__i != __last) && (!((bool)__comp(__val, *__i))); 
# 2301
} 
# 2306
template< class _InputIterator1, class _InputIterator2, class 
# 2307
_OutputIterator, class _Compare> void 
# 2309
__move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 2310
__first2, _InputIterator2 __last2, _OutputIterator 
# 2311
__result, _Compare __comp) 
# 2312
{ 
# 2313
while ((__first1 != __last1) && (__first2 != __last2)) 
# 2314
{ 
# 2315
if (__comp(__first2, __first1)) 
# 2316
{ 
# 2317
(*__result) = std::move(*__first2); 
# 2318
++__first2; 
# 2319
} else 
# 2321
{ 
# 2322
(*__result) = std::move(*__first1); 
# 2323
++__first1; 
# 2324
}  
# 2325
++__result; 
# 2326
}  
# 2327
if (__first1 != __last1) { 
# 2328
std::move(__first1, __last1, __result); }  
# 2329
} 
# 2332
template< class _BidirectionalIterator1, class _BidirectionalIterator2, class 
# 2333
_BidirectionalIterator3, class _Compare> void 
# 2335
__move_merge_adaptive_backward(_BidirectionalIterator1 __first1, _BidirectionalIterator1 
# 2336
__last1, _BidirectionalIterator2 
# 2337
__first2, _BidirectionalIterator2 
# 2338
__last2, _BidirectionalIterator3 
# 2339
__result, _Compare 
# 2340
__comp) 
# 2341
{ 
# 2342
if (__first1 == __last1) 
# 2343
{ 
# 2344
std::move_backward(__first2, __last2, __result); 
# 2345
return; 
# 2346
} else { 
# 2347
if (__first2 == __last2) { 
# 2348
return; }  }  
# 2350
--__last1; 
# 2351
--__last2; 
# 2352
while (true) 
# 2353
{ 
# 2354
if (__comp(__last2, __last1)) 
# 2355
{ 
# 2356
(*(--__result)) = std::move(*__last1); 
# 2357
if (__first1 == __last1) 
# 2358
{ 
# 2359
std::move_backward(__first2, ++__last2, __result); 
# 2360
return; 
# 2361
}  
# 2362
--__last1; 
# 2363
} else 
# 2365
{ 
# 2366
(*(--__result)) = std::move(*__last2); 
# 2367
if (__first2 == __last2) { 
# 2368
return; }  
# 2369
--__last2; 
# 2370
}  
# 2371
}  
# 2372
} 
# 2375
template< class _BidirectionalIterator1, class _BidirectionalIterator2, class 
# 2376
_Distance> _BidirectionalIterator1 
# 2378
__rotate_adaptive(_BidirectionalIterator1 __first, _BidirectionalIterator1 
# 2379
__middle, _BidirectionalIterator1 
# 2380
__last, _Distance 
# 2381
__len1, _Distance __len2, _BidirectionalIterator2 
# 2382
__buffer, _Distance 
# 2383
__buffer_size) 
# 2384
{ 
# 2385
_BidirectionalIterator2 __buffer_end; 
# 2386
if ((__len1 > __len2) && (__len2 <= __buffer_size)) 
# 2387
{ 
# 2388
if (__len2) 
# 2389
{ 
# 2390
__buffer_end = std::move(__middle, __last, __buffer); 
# 2391
std::move_backward(__first, __middle, __last); 
# 2392
return std::move(__buffer, __buffer_end, __first); 
# 2393
} else { 
# 2395
return __first; }  
# 2396
} else { 
# 2397
if (__len1 <= __buffer_size) 
# 2398
{ 
# 2399
if (__len1) 
# 2400
{ 
# 2401
__buffer_end = std::move(__first, __middle, __buffer); 
# 2402
std::move(__middle, __last, __first); 
# 2403
return std::move_backward(__buffer, __buffer_end, __last); 
# 2404
} else { 
# 2406
return __last; }  
# 2407
} else { 
# 2409
return std::rotate(__first, __middle, __last); }  }  
# 2410
} 
# 2413
template< class _BidirectionalIterator, class _Distance, class 
# 2414
_Pointer, class _Compare> void 
# 2416
__merge_adaptive(_BidirectionalIterator __first, _BidirectionalIterator 
# 2417
__middle, _BidirectionalIterator 
# 2418
__last, _Distance 
# 2419
__len1, _Distance __len2, _Pointer 
# 2420
__buffer, _Distance __buffer_size, _Compare 
# 2421
__comp) 
# 2422
{ 
# 2423
if ((__len1 <= __len2) && (__len1 <= __buffer_size)) 
# 2424
{ 
# 2425
_Pointer __buffer_end = std::move(__first, __middle, __buffer); 
# 2426
std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last, __first, __comp); 
# 2428
} else { 
# 2429
if (__len2 <= __buffer_size) 
# 2430
{ 
# 2431
_Pointer __buffer_end = std::move(__middle, __last, __buffer); 
# 2432
std::__move_merge_adaptive_backward(__first, __middle, __buffer, __buffer_end, __last, __comp); 
# 2434
} else 
# 2436
{ 
# 2437
_BidirectionalIterator __first_cut = __first; 
# 2438
_BidirectionalIterator __second_cut = __middle; 
# 2439
_Distance __len11 = (0); 
# 2440
_Distance __len22 = (0); 
# 2441
if (__len1 > __len2) 
# 2442
{ 
# 2443
__len11 = (__len1 / 2); 
# 2444
std::advance(__first_cut, __len11); 
# 2445
__second_cut = std::__lower_bound(__middle, __last, *__first_cut, __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 2448
__len22 = std::distance(__middle, __second_cut); 
# 2449
} else 
# 2451
{ 
# 2452
__len22 = (__len2 / 2); 
# 2453
std::advance(__second_cut, __len22); 
# 2454
__first_cut = std::__upper_bound(__first, __middle, *__second_cut, __gnu_cxx::__ops::__val_comp_iter(__comp)); 
# 2457
__len11 = std::distance(__first, __first_cut); 
# 2458
}  
# 2460
_BidirectionalIterator __new_middle = std::__rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11, __len22, __buffer, __buffer_size); 
# 2464
std::__merge_adaptive(__first, __first_cut, __new_middle, __len11, __len22, __buffer, __buffer_size, __comp); 
# 2466
std::__merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __buffer, __buffer_size, __comp); 
# 2470
}  }  
# 2471
} 
# 2474
template< class _BidirectionalIterator, class _Distance, class 
# 2475
_Compare> void 
# 2477
__merge_without_buffer(_BidirectionalIterator __first, _BidirectionalIterator 
# 2478
__middle, _BidirectionalIterator 
# 2479
__last, _Distance 
# 2480
__len1, _Distance __len2, _Compare 
# 2481
__comp) 
# 2482
{ 
# 2483
if ((__len1 == 0) || (__len2 == 0)) { 
# 2484
return; }  
# 2486
if ((__len1 + __len2) == 2) 
# 2487
{ 
# 2488
if (__comp(__middle, __first)) { 
# 2489
std::iter_swap(__first, __middle); }  
# 2490
return; 
# 2491
}  
# 2493
_BidirectionalIterator __first_cut = __first; 
# 2494
_BidirectionalIterator __second_cut = __middle; 
# 2495
_Distance __len11 = (0); 
# 2496
_Distance __len22 = (0); 
# 2497
if (__len1 > __len2) 
# 2498
{ 
# 2499
__len11 = (__len1 / 2); 
# 2500
std::advance(__first_cut, __len11); 
# 2501
__second_cut = std::__lower_bound(__middle, __last, *__first_cut, __gnu_cxx::__ops::__iter_comp_val(__comp)); 
# 2504
__len22 = std::distance(__middle, __second_cut); 
# 2505
} else 
# 2507
{ 
# 2508
__len22 = (__len2 / 2); 
# 2509
std::advance(__second_cut, __len22); 
# 2510
__first_cut = std::__upper_bound(__first, __middle, *__second_cut, __gnu_cxx::__ops::__val_comp_iter(__comp)); 
# 2513
__len11 = std::distance(__first, __first_cut); 
# 2514
}  
# 2516
_BidirectionalIterator __new_middle = std::rotate(__first_cut, __middle, __second_cut); 
# 2518
std::__merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22, __comp); 
# 2520
std::__merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11, __len2 - __len22, __comp); 
# 2522
} 
# 2524
template< class _BidirectionalIterator, class _Compare> void 
# 2526
__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator 
# 2527
__middle, _BidirectionalIterator 
# 2528
__last, _Compare 
# 2529
__comp) 
# 2530
{ 
# 2532
typedef typename iterator_traits< _BidirectionalIterator> ::value_type _ValueType; 
# 2534
typedef typename iterator_traits< _BidirectionalIterator> ::difference_type _DistanceType; 
# 2536
if ((__first == __middle) || (__middle == __last)) { 
# 2537
return; }  
# 2539
const _DistanceType __len1 = std::distance(__first, __middle); 
# 2540
const _DistanceType __len2 = std::distance(__middle, __last); 
# 2542
typedef _Temporary_buffer< _BidirectionalIterator, typename iterator_traits< _BidirectionalIterator> ::value_type>  _TmpBuf; 
# 2543
_TmpBuf __buf(__first, __len1 + __len2); 
# 2545
if (__buf.begin() == 0) { 
# 2546
std::__merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp); } else { 
# 2549
std::__merge_adaptive(__first, __middle, __last, __len1, __len2, __buf.begin(), (_DistanceType)__buf.size(), __comp); }  
# 2552
} 
# 2572 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator> inline void 
# 2574
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator 
# 2575
__middle, _BidirectionalIterator 
# 2576
__last) 
# 2577
{ 
# 2583
; 
# 2584
; 
# 2585
; 
# 2587
std::__inplace_merge(__first, __middle, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 2589
} 
# 2613 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _Compare> inline void 
# 2615
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator 
# 2616
__middle, _BidirectionalIterator 
# 2617
__last, _Compare 
# 2618
__comp) 
# 2619
{ 
# 2626
; 
# 2627
; 
# 2628
; 
# 2630
std::__inplace_merge(__first, __middle, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 2632
} 
# 2636
template< class _InputIterator, class _OutputIterator, class 
# 2637
_Compare> _OutputIterator 
# 2639
__move_merge(_InputIterator __first1, _InputIterator __last1, _InputIterator 
# 2640
__first2, _InputIterator __last2, _OutputIterator 
# 2641
__result, _Compare __comp) 
# 2642
{ 
# 2643
while ((__first1 != __last1) && (__first2 != __last2)) 
# 2644
{ 
# 2645
if (__comp(__first2, __first1)) 
# 2646
{ 
# 2647
(*__result) = std::move(*__first2); 
# 2648
++__first2; 
# 2649
} else 
# 2651
{ 
# 2652
(*__result) = std::move(*__first1); 
# 2653
++__first1; 
# 2654
}  
# 2655
++__result; 
# 2656
}  
# 2657
return std::move(__first2, __last2, std::move(__first1, __last1, __result)); 
# 2660
} 
# 2662
template< class _RandomAccessIterator1, class _RandomAccessIterator2, class 
# 2663
_Distance, class _Compare> void 
# 2665
__merge_sort_loop(_RandomAccessIterator1 __first, _RandomAccessIterator1 
# 2666
__last, _RandomAccessIterator2 
# 2667
__result, _Distance __step_size, _Compare 
# 2668
__comp) 
# 2669
{ 
# 2670
const _Distance __two_step = 2 * __step_size; 
# 2672
while ((__last - __first) >= __two_step) 
# 2673
{ 
# 2674
__result = std::__move_merge(__first, __first + __step_size, __first + __step_size, __first + __two_step, __result, __comp); 
# 2678
__first += __two_step; 
# 2679
}  
# 2680
__step_size = std::min((_Distance)(__last - __first), __step_size); 
# 2682
std::__move_merge(__first, __first + __step_size, __first + __step_size, __last, __result, __comp); 
# 2684
} 
# 2686
template< class _RandomAccessIterator, class _Distance, class 
# 2687
_Compare> void 
# 2689
__chunk_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 2690
__last, _Distance 
# 2691
__chunk_size, _Compare __comp) 
# 2692
{ 
# 2693
while ((__last - __first) >= __chunk_size) 
# 2694
{ 
# 2695
std::__insertion_sort(__first, __first + __chunk_size, __comp); 
# 2696
__first += __chunk_size; 
# 2697
}  
# 2698
std::__insertion_sort(__first, __last, __comp); 
# 2699
} 
# 2701
enum { _S_chunk_size = 7}; 
# 2703
template< class _RandomAccessIterator, class _Pointer, class _Compare> void 
# 2705
__merge_sort_with_buffer(_RandomAccessIterator __first, _RandomAccessIterator 
# 2706
__last, _Pointer 
# 2707
__buffer, _Compare __comp) 
# 2708
{ 
# 2710
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _Distance; 
# 2712
const _Distance __len = __last - __first; 
# 2713
const _Pointer __buffer_last = __buffer + __len; 
# 2715
_Distance __step_size = (_S_chunk_size); 
# 2716
std::__chunk_insertion_sort(__first, __last, __step_size, __comp); 
# 2718
while (__step_size < __len) 
# 2719
{ 
# 2720
std::__merge_sort_loop(__first, __last, __buffer, __step_size, __comp); 
# 2722
__step_size *= 2; 
# 2723
std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp); 
# 2725
__step_size *= 2; 
# 2726
}  
# 2727
} 
# 2729
template< class _RandomAccessIterator, class _Pointer, class 
# 2730
_Distance, class _Compare> void 
# 2732
__stable_sort_adaptive(_RandomAccessIterator __first, _RandomAccessIterator 
# 2733
__last, _Pointer 
# 2734
__buffer, _Distance __buffer_size, _Compare 
# 2735
__comp) 
# 2736
{ 
# 2737
const _Distance __len = ((__last - __first) + 1) / 2; 
# 2738
const _RandomAccessIterator __middle = __first + __len; 
# 2739
if (__len > __buffer_size) 
# 2740
{ 
# 2741
std::__stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, __comp); 
# 2743
std::__stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, __comp); 
# 2745
} else 
# 2747
{ 
# 2748
std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp); 
# 2749
std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp); 
# 2750
}  
# 2751
std::__merge_adaptive(__first, __middle, __last, (_Distance)(__middle - __first), (_Distance)(__last - __middle), __buffer, __buffer_size, __comp); 
# 2756
} 
# 2759
template< class _RandomAccessIterator, class _Compare> void 
# 2761
__inplace_stable_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 2762
__last, _Compare __comp) 
# 2763
{ 
# 2764
if ((__last - __first) < 15) 
# 2765
{ 
# 2766
std::__insertion_sort(__first, __last, __comp); 
# 2767
return; 
# 2768
}  
# 2769
_RandomAccessIterator __middle = __first + ((__last - __first) / 2); 
# 2770
std::__inplace_stable_sort(__first, __middle, __comp); 
# 2771
std::__inplace_stable_sort(__middle, __last, __comp); 
# 2772
std::__merge_without_buffer(__first, __middle, __last, __middle - __first, __last - __middle, __comp); 
# 2776
} 
# 2785 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 2786
_Compare> bool 
# 2788
__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 2789
__first2, _InputIterator2 __last2, _Compare 
# 2790
__comp) 
# 2791
{ 
# 2792
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 2793
if (__comp(__first2, __first1)) { 
# 2794
return false; } else { 
# 2795
if (__comp(__first1, __first2)) { 
# 2796
++__first1; } else 
# 2798
{ 
# 2799
++__first1; 
# 2800
++__first2; 
# 2801
}  }  }  
# 2803
return __first2 == __last2; 
# 2804
} 
# 2824 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2> inline bool 
# 2826
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 2827
__first2, _InputIterator2 __last2) 
# 2828
{ 
# 2838
; 
# 2839
; 
# 2840
; 
# 2841
; 
# 2843
return std::__includes(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter()); 
# 2845
} 
# 2868 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 2869
_Compare> inline bool 
# 2871
includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 2872
__first2, _InputIterator2 __last2, _Compare 
# 2873
__comp) 
# 2874
{ 
# 2884
; 
# 2885
; 
# 2886
; 
# 2887
; 
# 2889
return std::__includes(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 2891
} 
# 2903 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _Compare> bool 
# 2905
__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 2906
__last, _Compare __comp) 
# 2907
{ 
# 2908
if (__first == __last) { 
# 2909
return false; }  
# 2910
_BidirectionalIterator __i = __first; 
# 2911
++__i; 
# 2912
if (__i == __last) { 
# 2913
return false; }  
# 2914
__i = __last; 
# 2915
--__i; 
# 2917
for (; ;) 
# 2918
{ 
# 2919
_BidirectionalIterator __ii = __i; 
# 2920
--__i; 
# 2921
if (__comp(__i, __ii)) 
# 2922
{ 
# 2923
_BidirectionalIterator __j = __last; 
# 2924
while (!__comp(__i, --__j)) 
# 2925
{ }  
# 2926
std::iter_swap(__i, __j); 
# 2927
std::__reverse(__ii, __last, std::__iterator_category(__first)); 
# 2929
return true; 
# 2930
}  
# 2931
if (__i == __first) 
# 2932
{ 
# 2933
std::__reverse(__first, __last, std::__iterator_category(__first)); 
# 2935
return false; 
# 2936
}  
# 2937
}  
# 2938
} 
# 2952 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator> inline bool 
# 2954
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 2955
__last) 
# 2956
{ 
# 2962
; 
# 2963
; 
# 2965
return std::__next_permutation(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 2967
} 
# 2984 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _Compare> inline bool 
# 2986
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 2987
__last, _Compare __comp) 
# 2988
{ 
# 2995
; 
# 2996
; 
# 2998
return std::__next_permutation(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 3000
} 
# 3002
template< class _BidirectionalIterator, class _Compare> bool 
# 3004
__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 3005
__last, _Compare __comp) 
# 3006
{ 
# 3007
if (__first == __last) { 
# 3008
return false; }  
# 3009
_BidirectionalIterator __i = __first; 
# 3010
++__i; 
# 3011
if (__i == __last) { 
# 3012
return false; }  
# 3013
__i = __last; 
# 3014
--__i; 
# 3016
for (; ;) 
# 3017
{ 
# 3018
_BidirectionalIterator __ii = __i; 
# 3019
--__i; 
# 3020
if (__comp(__ii, __i)) 
# 3021
{ 
# 3022
_BidirectionalIterator __j = __last; 
# 3023
while (!__comp(--__j, __i)) 
# 3024
{ }  
# 3025
std::iter_swap(__i, __j); 
# 3026
std::__reverse(__ii, __last, std::__iterator_category(__first)); 
# 3028
return true; 
# 3029
}  
# 3030
if (__i == __first) 
# 3031
{ 
# 3032
std::__reverse(__first, __last, std::__iterator_category(__first)); 
# 3034
return false; 
# 3035
}  
# 3036
}  
# 3037
} 
# 3052 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator> inline bool 
# 3054
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 3055
__last) 
# 3056
{ 
# 3062
; 
# 3063
; 
# 3065
return std::__prev_permutation(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 3067
} 
# 3084 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _BidirectionalIterator, class _Compare> inline bool 
# 3086
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator 
# 3087
__last, _Compare __comp) 
# 3088
{ 
# 3095
; 
# 3096
; 
# 3098
return std::__prev_permutation(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 3100
} 
# 3105
template< class _InputIterator, class _OutputIterator, class 
# 3106
_Predicate, class _Tp> _OutputIterator 
# 3108
__replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 3109
__result, _Predicate 
# 3110
__pred, const _Tp &__new_value) 
# 3111
{ 
# 3112
for (; __first != __last; (++__first), ((void)(++__result))) { 
# 3113
if (__pred(__first)) { 
# 3114
(*__result) = __new_value; } else { 
# 3116
(*__result) = (*__first); }  }  
# 3117
return __result; 
# 3118
} 
# 3134 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class _Tp> inline _OutputIterator 
# 3136
replace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 3137
__result, const _Tp &
# 3138
__old_value, const _Tp &__new_value) 
# 3139
{ 
# 3146
; 
# 3148
return std::__replace_copy_if(__first, __last, __result, __gnu_cxx::__ops::__iter_equals_val(__old_value), __new_value); 
# 3151
} 
# 3168 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 3169
_Predicate, class _Tp> inline _OutputIterator 
# 3171
replace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 3172
__result, _Predicate 
# 3173
__pred, const _Tp &__new_value) 
# 3174
{ 
# 3181
; 
# 3183
return std::__replace_copy_if(__first, __last, __result, __gnu_cxx::__ops::__pred_iter(__pred), __new_value); 
# 3186
} 
# 3188
template< class _InputIterator, class _Predicate> typename iterator_traits< _InputIterator> ::difference_type 
# 3190
__count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 3191
{ 
# 3192
typename iterator_traits< _InputIterator> ::difference_type __n = (0); 
# 3193
for (; __first != __last; ++__first) { 
# 3194
if (__pred(__first)) { 
# 3195
++__n; }  }  
# 3196
return __n; 
# 3197
} 
# 3207 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator> inline bool 
# 3209
is_sorted(_ForwardIterator __first, _ForwardIterator __last) 
# 3210
{ return std::is_sorted_until(__first, __last) == __last; } 
# 3221 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> inline bool 
# 3223
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3224
__comp) 
# 3225
{ return std::is_sorted_until(__first, __last, __comp) == __last; } 
# 3227
template< class _ForwardIterator, class _Compare> _ForwardIterator 
# 3229
__is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3230
__comp) 
# 3231
{ 
# 3232
if (__first == __last) { 
# 3233
return __last; }  
# 3235
_ForwardIterator __next = __first; 
# 3236
for (++__next; __next != __last; (__first = __next), ((void)(++__next))) { 
# 3237
if (__comp(__next, __first)) { 
# 3238
return __next; }  }  
# 3239
return __next; 
# 3240
} 
# 3250 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 3252
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last) 
# 3253
{ 
# 3258
; 
# 3259
; 
# 3261
return std::__is_sorted_until(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 3263
} 
# 3274 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> inline _ForwardIterator 
# 3276
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3277
__comp) 
# 3278
{ 
# 3284
; 
# 3285
; 
# 3287
return std::__is_sorted_until(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 3289
} 
# 3299 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _Tp> constexpr pair< const _Tp &, const _Tp &>  
# 3302
minmax(const _Tp &__a, const _Tp &__b) 
# 3303
{ 
# 3307
return (__b < __a) ? pair< const _Tp &, const _Tp &> (__b, __a) : pair< const _Tp &, const _Tp &> (__a, __b); 
# 3309
} 
# 3320 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _Tp, class _Compare> constexpr pair< const _Tp &, const _Tp &>  
# 3323
minmax(const _Tp &__a, const _Tp &__b, _Compare __comp) 
# 3324
{ 
# 3325
return (__comp(__b, __a)) ? pair< const _Tp &, const _Tp &> (__b, __a) : pair< const _Tp &, const _Tp &> (__a, __b); 
# 3327
} 
# 3329
template< class _ForwardIterator, class _Compare> constexpr pair< _ForwardIterator, _ForwardIterator>  
# 3332
__minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3333
__comp) 
# 3334
{ 
# 3335
_ForwardIterator __next = __first; 
# 3336
if ((__first == __last) || ((++__next) == __last)) { 
# 3338
return std::make_pair(__first, __first); }  
# 3340
_ForwardIterator __min{}, __max{}; 
# 3341
if (__comp(__next, __first)) 
# 3342
{ 
# 3343
__min = __next; 
# 3344
__max = __first; 
# 3345
} else 
# 3347
{ 
# 3348
__min = __first; 
# 3349
__max = __next; 
# 3350
}  
# 3352
__first = __next; 
# 3353
++__first; 
# 3355
while (__first != __last) 
# 3356
{ 
# 3357
__next = __first; 
# 3358
if ((++__next) == __last) 
# 3359
{ 
# 3360
if (__comp(__first, __min)) { 
# 3361
__min = __first; } else { 
# 3362
if (!__comp(__first, __max)) { 
# 3363
__max = __first; }  }  
# 3364
break; 
# 3365
}  
# 3367
if (__comp(__next, __first)) 
# 3368
{ 
# 3369
if (__comp(__next, __min)) { 
# 3370
__min = __next; }  
# 3371
if (!__comp(__first, __max)) { 
# 3372
__max = __first; }  
# 3373
} else 
# 3375
{ 
# 3376
if (__comp(__first, __min)) { 
# 3377
__min = __first; }  
# 3378
if (!__comp(__next, __max)) { 
# 3379
__max = __next; }  
# 3380
}  
# 3382
__first = __next; 
# 3383
++__first; 
# 3384
}  
# 3386
return std::make_pair(__min, __max); 
# 3387
} 
# 3400 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator> constexpr pair< _ForwardIterator, _ForwardIterator>  
# 3403
minmax_element(_ForwardIterator __first, _ForwardIterator __last) 
# 3404
{ 
# 3409
; 
# 3410
; 
# 3412
return std::__minmax_element(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 3414
} 
# 3428 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> constexpr pair< _ForwardIterator, _ForwardIterator>  
# 3431
minmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 3432
__comp) 
# 3433
{ 
# 3439
; 
# 3440
; 
# 3442
return std::__minmax_element(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 3444
} 
# 3447
template< class _Tp> constexpr _Tp 
# 3450
min(initializer_list< _Tp>  __l) 
# 3451
{ return *std::min_element(__l.begin(), __l.end()); } 
# 3453
template< class _Tp, class _Compare> constexpr _Tp 
# 3456
min(initializer_list< _Tp>  __l, _Compare __comp) 
# 3457
{ return *std::min_element(__l.begin(), __l.end(), __comp); } 
# 3459
template< class _Tp> constexpr _Tp 
# 3462
max(initializer_list< _Tp>  __l) 
# 3463
{ return *std::max_element(__l.begin(), __l.end()); } 
# 3465
template< class _Tp, class _Compare> constexpr _Tp 
# 3468
max(initializer_list< _Tp>  __l, _Compare __comp) 
# 3469
{ return *std::max_element(__l.begin(), __l.end(), __comp); } 
# 3471
template< class _Tp> constexpr pair< _Tp, _Tp>  
# 3474
minmax(initializer_list< _Tp>  __l) 
# 3475
{ 
# 3476
pair< const _Tp *, const _Tp *>  __p = std::minmax_element(__l.begin(), __l.end()); 
# 3478
return std::make_pair(*(__p.first), *(__p.second)); 
# 3479
} 
# 3481
template< class _Tp, class _Compare> constexpr pair< _Tp, _Tp>  
# 3484
minmax(initializer_list< _Tp>  __l, _Compare __comp) 
# 3485
{ 
# 3486
pair< const _Tp *, const _Tp *>  __p = std::minmax_element(__l.begin(), __l.end(), __comp); 
# 3488
return std::make_pair(*(__p.first), *(__p.second)); 
# 3489
} 
# 3491
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 3492
_BinaryPredicate> bool 
# 3494
__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3495
__first2, _BinaryPredicate __pred) 
# 3496
{ 
# 3499
for (; __first1 != __last1; (++__first1), ((void)(++__first2))) { 
# 3500
if (!__pred(__first1, __first2)) { 
# 3501
break; }  }  
# 3503
if (__first1 == __last1) { 
# 3504
return true; }  
# 3508
_ForwardIterator2 __last2 = __first2; 
# 3509
std::advance(__last2, std::distance(__first1, __last1)); 
# 3510
for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) 
# 3511
{ 
# 3512
if (__scan != std::__find_if(__first1, __scan, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))) { 
# 3514
continue; }  
# 3516
auto __matches = std::__count_if(__first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)); 
# 3519
if ((0 == __matches) || (std::__count_if(__scan, __last1, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)) != __matches)) { 
# 3523
return false; }  
# 3524
}   
# 3525
return true; 
# 3526
} 
# 3540 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline bool 
# 3542
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3543
__first2) 
# 3544
{ 
# 3551
; 
# 3553
return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 3555
} 
# 3571 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 3572
_BinaryPredicate> inline bool 
# 3574
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3575
__first2, _BinaryPredicate __pred) 
# 3576
{ 
# 3583
; 
# 3585
return std::__is_permutation(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__pred)); 
# 3587
} 
# 3590
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 3591
_BinaryPredicate> bool 
# 3593
__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3594
__first2, _ForwardIterator2 __last2, _BinaryPredicate 
# 3595
__pred) 
# 3596
{ 
# 3597
using _Cat1 = typename iterator_traits< _ForwardIterator1> ::iterator_category; 
# 3599
using _Cat2 = typename iterator_traits< _ForwardIterator2> ::iterator_category; 
# 3601
using _It1_is_RA = is_same< typename iterator_traits< _ForwardIterator1> ::iterator_category, random_access_iterator_tag> ; 
# 3602
using _It2_is_RA = is_same< typename iterator_traits< _ForwardIterator2> ::iterator_category, random_access_iterator_tag> ; 
# 3603
constexpr bool __ra_iters = (_It1_is_RA() && _It2_is_RA()); 
# 3604
if (__ra_iters) 
# 3605
{ 
# 3606
auto __d1 = std::distance(__first1, __last1); 
# 3607
auto __d2 = std::distance(__first2, __last2); 
# 3608
if (__d1 != __d2) { 
# 3609
return false; }  
# 3610
}  
# 3614
for (; (__first1 != __last1) && (__first2 != __last2); (++__first1), ((void)(++__first2))) { 
# 3616
if (!__pred(__first1, __first2)) { 
# 3617
break; }  }  
# 3619
if (__ra_iters) 
# 3620
{ 
# 3621
if (__first1 == __last1) { 
# 3622
return true; }  
# 3623
} else 
# 3625
{ 
# 3626
auto __d1 = std::distance(__first1, __last1); 
# 3627
auto __d2 = std::distance(__first2, __last2); 
# 3628
if ((__d1 == 0) && (__d2 == 0)) { 
# 3629
return true; }  
# 3630
if (__d1 != __d2) { 
# 3631
return false; }  
# 3632
}  
# 3634
for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan) 
# 3635
{ 
# 3636
if (__scan != std::__find_if(__first1, __scan, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))) { 
# 3638
continue; }  
# 3640
auto __matches = std::__count_if(__first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)); 
# 3642
if ((0 == __matches) || (std::__count_if(__scan, __last1, __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)) != __matches)) { 
# 3646
return false; }  
# 3647
}   
# 3648
return true; 
# 3649
} 
# 3664 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline bool 
# 3666
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3667
__first2, _ForwardIterator2 __last2) 
# 3668
{ 
# 3669
; 
# 3670
; 
# 3672
return std::__is_permutation(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 3675
} 
# 3691 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 3692
_BinaryPredicate> inline bool 
# 3694
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 3695
__first2, _ForwardIterator2 __last2, _BinaryPredicate 
# 3696
__pred) 
# 3697
{ 
# 3698
; 
# 3699
; 
# 3701
return std::__is_permutation(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__pred)); 
# 3703
} 
# 3767 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _IntType, class _UniformRandomBitGenerator> pair< _IntType, _IntType>  
# 3769
__gen_two_uniform_ints(_IntType __b0, _IntType __b1, _UniformRandomBitGenerator &&
# 3770
__g) 
# 3771
{ 
# 3772
_IntType __x = uniform_int_distribution< _IntType> {0, (__b0 * __b1) - 1}(__g); 
# 3774
return std::make_pair(__x / __b1, __x % __b1); 
# 3775
} 
# 3789 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class 
# 3790
_UniformRandomNumberGenerator> void 
# 3792
shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator &&
# 3793
__g) 
# 3794
{ 
# 3798
; 
# 3800
if (__first == __last) { 
# 3801
return; }  
# 3804
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 3806
typedef typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type __ud_type; 
# 3807
typedef uniform_int_distribution< typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type>  __distr_type; 
# 3808
typedef typename uniform_int_distribution< typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type> ::param_type __p_type; 
# 3811
typedef typename remove_reference< _UniformRandomNumberGenerator> ::type _Gen; 
# 3813
typedef typename common_type< typename remove_reference< _UniformRandomNumberGenerator> ::type::result_type, typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type> ::type __uc_type; 
# 3815
const __uc_type __urngrange = __g.max() - __g.min(); 
# 3816
const __uc_type __urange = (__uc_type)(__last - __first); 
# 3818
if ((__urngrange / __urange) >= __urange) 
# 3820
{ 
# 3821
_RandomAccessIterator __i = __first + 1; 
# 3827
if ((__urange % 2) == 0) 
# 3828
{ 
# 3829
__distr_type __d{0, 1}; 
# 3830
std::iter_swap(__i++, __first + __d(__g)); 
# 3831
}  
# 3837
while (__i != __last) 
# 3838
{ 
# 3839
const __uc_type __swap_range = ((__uc_type)(__i - __first)) + 1; 
# 3841
const pair< typename common_type< typename remove_reference< _UniformRandomNumberGenerator> ::type::result_type, typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type> ::type, typename common_type< typename remove_reference< _UniformRandomNumberGenerator> ::type::result_type, typename make_unsigned< typename iterator_traits< _RandomAccessIterator> ::difference_type> ::type> ::type>  __pospos = __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g); 
# 3844
std::iter_swap(__i++, __first + (__pospos.first)); 
# 3845
std::iter_swap(__i++, __first + (__pospos.second)); 
# 3846
}  
# 3848
return; 
# 3849
}  
# 3851
__distr_type __d; 
# 3853
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) { 
# 3854
std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first))); }  
# 3855
} 
# 3874 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Function> _Function 
# 3876
for_each(_InputIterator __first, _InputIterator __last, _Function __f) 
# 3877
{ 
# 3880
; 
# 3881
for (; __first != __last; ++__first) { 
# 3882
__f(*__first); }  
# 3883
return __f; 
# 3884
} 
# 3934 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Tp> inline _InputIterator 
# 3936
find(_InputIterator __first, _InputIterator __last, const _Tp &
# 3937
__val) 
# 3938
{ 
# 3943
; 
# 3944
return std::__find_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__val)); 
# 3946
} 
# 3958 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline _InputIterator 
# 3960
find_if(_InputIterator __first, _InputIterator __last, _Predicate 
# 3961
__pred) 
# 3962
{ 
# 3967
; 
# 3969
return std::__find_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 3971
} 
# 3989 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _ForwardIterator> _InputIterator 
# 3991
find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator 
# 3992
__first2, _ForwardIterator __last2) 
# 3993
{ 
# 4000
; 
# 4001
; 
# 4003
for (; __first1 != __last1; ++__first1) { 
# 4004
for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter) { 
# 4005
if ((*__first1) == (*__iter)) { 
# 4006
return __first1; }  }  }  
# 4007
return __last1; 
# 4008
} 
# 4029 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _ForwardIterator, class 
# 4030
_BinaryPredicate> _InputIterator 
# 4032
find_first_of(_InputIterator __first1, _InputIterator __last1, _ForwardIterator 
# 4033
__first2, _ForwardIterator __last2, _BinaryPredicate 
# 4034
__comp) 
# 4035
{ 
# 4042
; 
# 4043
; 
# 4045
for (; __first1 != __last1; ++__first1) { 
# 4046
for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter) { 
# 4047
if (__comp(*__first1, *__iter)) { 
# 4048
return __first1; }  }  }  
# 4049
return __last1; 
# 4050
} 
# 4061 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator> inline _ForwardIterator 
# 4063
adjacent_find(_ForwardIterator __first, _ForwardIterator __last) 
# 4064
{ 
# 4069
; 
# 4071
return std::__adjacent_find(__first, __last, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 4073
} 
# 4086 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _BinaryPredicate> inline _ForwardIterator 
# 4088
adjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate 
# 4089
__binary_pred) 
# 4090
{ 
# 4096
; 
# 4098
return std::__adjacent_find(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred)); 
# 4100
} 
# 4111 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Tp> inline typename iterator_traits< _InputIterator> ::difference_type 
# 4113
count(_InputIterator __first, _InputIterator __last, const _Tp &__value) 
# 4114
{ 
# 4119
; 
# 4121
return std::__count_if(__first, __last, __gnu_cxx::__ops::__iter_equals_val(__value)); 
# 4123
} 
# 4134 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _Predicate> inline typename iterator_traits< _InputIterator> ::difference_type 
# 4136
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) 
# 4137
{ 
# 4142
; 
# 4144
return std::__count_if(__first, __last, __gnu_cxx::__ops::__pred_iter(__pred)); 
# 4146
} 
# 4174 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2> inline _ForwardIterator1 
# 4176
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 4177
__first2, _ForwardIterator2 __last2) 
# 4178
{ 
# 4185
; 
# 4186
; 
# 4188
return std::__search(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter()); 
# 4190
} 
# 4213 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator1, class _ForwardIterator2, class 
# 4214
_BinaryPredicate> inline _ForwardIterator1 
# 4216
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 
# 4217
__first2, _ForwardIterator2 __last2, _BinaryPredicate 
# 4218
__predicate) 
# 4219
{ 
# 4226
; 
# 4227
; 
# 4229
return std::__search(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__predicate)); 
# 4231
} 
# 4248 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Integer, class _Tp> inline _ForwardIterator 
# 4250
search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer 
# 4251
__count, const _Tp &__val) 
# 4252
{ 
# 4257
; 
# 4259
return std::__search_n(__first, __last, __count, __gnu_cxx::__ops::__iter_equals_val(__val)); 
# 4261
} 
# 4281 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Integer, class _Tp, class 
# 4282
_BinaryPredicate> inline _ForwardIterator 
# 4284
search_n(_ForwardIterator __first, _ForwardIterator __last, _Integer 
# 4285
__count, const _Tp &__val, _BinaryPredicate 
# 4286
__binary_pred) 
# 4287
{ 
# 4292
; 
# 4294
return std::__search_n(__first, __last, __count, __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val)); 
# 4296
} 
# 4329 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 4330
_UnaryOperation> _OutputIterator 
# 4332
transform(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 4333
__result, _UnaryOperation __unary_op) 
# 4334
{ 
# 4340
; 
# 4342
for (; __first != __last; (++__first), ((void)(++__result))) { 
# 4343
(*__result) = __unary_op(*__first); }  
# 4344
return __result; 
# 4345
} 
# 4366 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 4367
_OutputIterator, class _BinaryOperation> _OutputIterator 
# 4369
transform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4370
__first2, _OutputIterator __result, _BinaryOperation 
# 4371
__binary_op) 
# 4372
{ 
# 4379
; 
# 4381
for (; __first1 != __last1; ((++__first1), ((void)(++__first2))), (++__result)) { 
# 4382
(*__result) = __binary_op(*__first1, *__first2); }  
# 4383
return __result; 
# 4384
} 
# 4399 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Tp> void 
# 4401
replace(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 4402
__old_value, const _Tp &__new_value) 
# 4403
{ 
# 4411
; 
# 4413
for (; __first != __last; ++__first) { 
# 4414
if ((*__first) == __old_value) { 
# 4415
(*__first) = __new_value; }  }  
# 4416
} 
# 4431 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate, class _Tp> void 
# 4433
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 4434
__pred, const _Tp &__new_value) 
# 4435
{ 
# 4443
; 
# 4445
for (; __first != __last; ++__first) { 
# 4446
if (__pred(*__first)) { 
# 4447
(*__first) = __new_value; }  }  
# 4448
} 
# 4463 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Generator> void 
# 4465
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator 
# 4466
__gen) 
# 4467
{ 
# 4472
; 
# 4474
for (; __first != __last; ++__first) { 
# 4475
(*__first) = __gen(); }  
# 4476
} 
# 4494 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _OutputIterator, class _Size, class _Generator> _OutputIterator 
# 4496
generate_n(_OutputIterator __first, _Size __n, _Generator __gen) 
# 4497
{ 
# 4503
for (__decltype((__n + 0)) __niter = __n; __niter > 0; (--__niter), ((void)(++__first))) { 
# 4505
(*__first) = __gen(); }  
# 4506
return __first; 
# 4507
} 
# 4530 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator> inline _OutputIterator 
# 4532
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 4533
__result) 
# 4534
{ 
# 4541
; 
# 4543
if (__first == __last) { 
# 4544
return __result; }  
# 4545
return std::__unique_copy(__first, __last, __result, __gnu_cxx::__ops::__iter_equal_to_iter(), std::__iterator_category(__first), std::__iterator_category(__result)); 
# 4549
} 
# 4570 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator, class _OutputIterator, class 
# 4571
_BinaryPredicate> inline _OutputIterator 
# 4573
unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator 
# 4574
__result, _BinaryPredicate 
# 4575
__binary_pred) 
# 4576
{ 
# 4581
; 
# 4583
if (__first == __last) { 
# 4584
return __result; }  
# 4585
return std::__unique_copy(__first, __last, __result, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred), std::__iterator_category(__first), std::__iterator_category(__result)); 
# 4589
} 
# 4603 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4605
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 4606
{ 
# 4610
; 
# 4612
if (__first != __last) { 
# 4613
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) 
# 4614
{ 
# 4616
_RandomAccessIterator __j = __first + (std::rand() % ((__i - __first) + 1)); 
# 4618
if (__i != __j) { 
# 4619
std::iter_swap(__i, __j); }  
# 4620
}  }  
# 4621
} 
# 4638 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _RandomNumberGenerator> void 
# 4640
random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &&
# 4642
__rand) 
# 4646
{ 
# 4650
; 
# 4652
if (__first == __last) { 
# 4653
return; }  
# 4654
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) 
# 4655
{ 
# 4656
_RandomAccessIterator __j = __first + __rand((__i - __first) + 1); 
# 4657
if (__i != __j) { 
# 4658
std::iter_swap(__i, __j); }  
# 4659
}  
# 4660
} 
# 4678 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Predicate> inline _ForwardIterator 
# 4680
partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate 
# 4681
__pred) 
# 4682
{ 
# 4688
; 
# 4690
return std::__partition(__first, __last, __pred, std::__iterator_category(__first)); 
# 4692
} 
# 4711 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4713
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 4714
__middle, _RandomAccessIterator 
# 4715
__last) 
# 4716
{ 
# 4722
; 
# 4723
; 
# 4724
; 
# 4726
std::__partial_sort(__first, __middle, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 4728
} 
# 4749 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 4751
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator 
# 4752
__middle, _RandomAccessIterator 
# 4753
__last, _Compare 
# 4754
__comp) 
# 4755
{ 
# 4762
; 
# 4763
; 
# 4764
; 
# 4766
std::__partial_sort(__first, __middle, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 4768
} 
# 4785 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4787
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator 
# 4788
__last) 
# 4789
{ 
# 4795
; 
# 4796
; 
# 4797
; 
# 4799
if ((__first == __last) || (__nth == __last)) { 
# 4800
return; }  
# 4802
std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __gnu_cxx::__ops::__iter_less_iter()); 
# 4805
} 
# 4824 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 4826
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator 
# 4827
__last, _Compare __comp) 
# 4828
{ 
# 4835
; 
# 4836
; 
# 4837
; 
# 4839
if ((__first == __last) || (__nth == __last)) { 
# 4840
return; }  
# 4842
std::__introselect(__first, __nth, __last, std::__lg(__last - __first) * 2, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 4845
} 
# 4861 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 4863
sort(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 4864
{ 
# 4870
; 
# 4871
; 
# 4873
std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 4874
} 
# 4891 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 4893
sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 4894
__comp) 
# 4895
{ 
# 4902
; 
# 4903
; 
# 4905
std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 4906
} 
# 4908
template< class _InputIterator1, class _InputIterator2, class 
# 4909
_OutputIterator, class _Compare> _OutputIterator 
# 4911
__merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4912
__first2, _InputIterator2 __last2, _OutputIterator 
# 4913
__result, _Compare __comp) 
# 4914
{ 
# 4915
while ((__first1 != __last1) && (__first2 != __last2)) 
# 4916
{ 
# 4917
if (__comp(__first2, __first1)) 
# 4918
{ 
# 4919
(*__result) = (*__first2); 
# 4920
++__first2; 
# 4921
} else 
# 4923
{ 
# 4924
(*__result) = (*__first1); 
# 4925
++__first1; 
# 4926
}  
# 4927
++__result; 
# 4928
}  
# 4929
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result)); 
# 4931
} 
# 4952 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 4953
_OutputIterator> inline _OutputIterator 
# 4955
merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 4956
__first2, _InputIterator2 __last2, _OutputIterator 
# 4957
__result) 
# 4958
{ 
# 4969
; 
# 4970
; 
# 4971
; 
# 4972
; 
# 4974
return std::__merge(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 4977
} 
# 5002 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5003
_OutputIterator, class _Compare> inline _OutputIterator 
# 5005
merge(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5006
__first2, _InputIterator2 __last2, _OutputIterator 
# 5007
__result, _Compare __comp) 
# 5008
{ 
# 5019
; 
# 5020
; 
# 5021
; 
# 5022
; 
# 5024
return std::__merge(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5027
} 
# 5029
template< class _RandomAccessIterator, class _Compare> inline void 
# 5031
__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 5032
__comp) 
# 5033
{ 
# 5035
typedef typename iterator_traits< _RandomAccessIterator> ::value_type _ValueType; 
# 5037
typedef typename iterator_traits< _RandomAccessIterator> ::difference_type _DistanceType; 
# 5039
typedef _Temporary_buffer< _RandomAccessIterator, typename iterator_traits< _RandomAccessIterator> ::value_type>  _TmpBuf; 
# 5040
_TmpBuf __buf(__first, std::distance(__first, __last)); 
# 5042
if (__buf.begin() == 0) { 
# 5043
std::__inplace_stable_sort(__first, __last, __comp); } else { 
# 5045
std::__stable_sort_adaptive(__first, __last, __buf.begin(), (_DistanceType)__buf.size(), __comp); }  
# 5047
} 
# 5066 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator> inline void 
# 5068
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) 
# 5069
{ 
# 5075
; 
# 5076
; 
# 5078
std::__stable_sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 5080
} 
# 5100 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _RandomAccessIterator, class _Compare> inline void 
# 5102
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare 
# 5103
__comp) 
# 5104
{ 
# 5111
; 
# 5112
; 
# 5114
std::__stable_sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5116
} 
# 5118
template< class _InputIterator1, class _InputIterator2, class 
# 5119
_OutputIterator, class 
# 5120
_Compare> _OutputIterator 
# 5122
__set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5123
__first2, _InputIterator2 __last2, _OutputIterator 
# 5124
__result, _Compare __comp) 
# 5125
{ 
# 5126
while ((__first1 != __last1) && (__first2 != __last2)) 
# 5127
{ 
# 5128
if (__comp(__first1, __first2)) 
# 5129
{ 
# 5130
(*__result) = (*__first1); 
# 5131
++__first1; 
# 5132
} else { 
# 5133
if (__comp(__first2, __first1)) 
# 5134
{ 
# 5135
(*__result) = (*__first2); 
# 5136
++__first2; 
# 5137
} else 
# 5139
{ 
# 5140
(*__result) = (*__first1); 
# 5141
++__first1; 
# 5142
++__first2; 
# 5143
}  }  
# 5144
++__result; 
# 5145
}  
# 5146
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result)); 
# 5148
} 
# 5169 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5170
_OutputIterator> inline _OutputIterator 
# 5172
set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5173
__first2, _InputIterator2 __last2, _OutputIterator 
# 5174
__result) 
# 5175
{ 
# 5189
; 
# 5190
; 
# 5191
; 
# 5192
; 
# 5194
return std::__set_union(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 5197
} 
# 5219 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5220
_OutputIterator, class _Compare> inline _OutputIterator 
# 5222
set_union(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5223
__first2, _InputIterator2 __last2, _OutputIterator 
# 5224
__result, _Compare __comp) 
# 5225
{ 
# 5239
; 
# 5240
; 
# 5241
; 
# 5242
; 
# 5244
return std::__set_union(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5247
} 
# 5249
template< class _InputIterator1, class _InputIterator2, class 
# 5250
_OutputIterator, class 
# 5251
_Compare> _OutputIterator 
# 5253
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5254
__first2, _InputIterator2 __last2, _OutputIterator 
# 5255
__result, _Compare __comp) 
# 5256
{ 
# 5257
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 5258
if (__comp(__first1, __first2)) { 
# 5259
++__first1; } else { 
# 5260
if (__comp(__first2, __first1)) { 
# 5261
++__first2; } else 
# 5263
{ 
# 5264
(*__result) = (*__first1); 
# 5265
++__first1; 
# 5266
++__first2; 
# 5267
++__result; 
# 5268
}  }  }  
# 5269
return __result; 
# 5270
} 
# 5290 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5291
_OutputIterator> inline _OutputIterator 
# 5293
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5294
__first2, _InputIterator2 __last2, _OutputIterator 
# 5295
__result) 
# 5296
{ 
# 5308
; 
# 5309
; 
# 5310
; 
# 5311
; 
# 5313
return std::__set_intersection(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 5316
} 
# 5339 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5340
_OutputIterator, class _Compare> inline _OutputIterator 
# 5342
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5343
__first2, _InputIterator2 __last2, _OutputIterator 
# 5344
__result, _Compare __comp) 
# 5345
{ 
# 5357
; 
# 5358
; 
# 5359
; 
# 5360
; 
# 5362
return std::__set_intersection(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5365
} 
# 5367
template< class _InputIterator1, class _InputIterator2, class 
# 5368
_OutputIterator, class 
# 5369
_Compare> _OutputIterator 
# 5371
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5372
__first2, _InputIterator2 __last2, _OutputIterator 
# 5373
__result, _Compare __comp) 
# 5374
{ 
# 5375
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 5376
if (__comp(__first1, __first2)) 
# 5377
{ 
# 5378
(*__result) = (*__first1); 
# 5379
++__first1; 
# 5380
++__result; 
# 5381
} else { 
# 5382
if (__comp(__first2, __first1)) { 
# 5383
++__first2; } else 
# 5385
{ 
# 5386
++__first1; 
# 5387
++__first2; 
# 5388
}  }  }  
# 5389
return std::copy(__first1, __last1, __result); 
# 5390
} 
# 5412 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5413
_OutputIterator> inline _OutputIterator 
# 5415
set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5416
__first2, _InputIterator2 __last2, _OutputIterator 
# 5417
__result) 
# 5418
{ 
# 5430
; 
# 5431
; 
# 5432
; 
# 5433
; 
# 5435
return std::__set_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 5438
} 
# 5463 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5464
_OutputIterator, class _Compare> inline _OutputIterator 
# 5466
set_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5467
__first2, _InputIterator2 __last2, _OutputIterator 
# 5468
__result, _Compare __comp) 
# 5469
{ 
# 5481
; 
# 5482
; 
# 5483
; 
# 5484
; 
# 5486
return std::__set_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5489
} 
# 5491
template< class _InputIterator1, class _InputIterator2, class 
# 5492
_OutputIterator, class 
# 5493
_Compare> _OutputIterator 
# 5495
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 
# 5496
__last1, _InputIterator2 
# 5497
__first2, _InputIterator2 
# 5498
__last2, _OutputIterator 
# 5499
__result, _Compare 
# 5500
__comp) 
# 5501
{ 
# 5502
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 5503
if (__comp(__first1, __first2)) 
# 5504
{ 
# 5505
(*__result) = (*__first1); 
# 5506
++__first1; 
# 5507
++__result; 
# 5508
} else { 
# 5509
if (__comp(__first2, __first1)) 
# 5510
{ 
# 5511
(*__result) = (*__first2); 
# 5512
++__first2; 
# 5513
++__result; 
# 5514
} else 
# 5516
{ 
# 5517
++__first1; 
# 5518
++__first2; 
# 5519
}  }  }  
# 5520
return std::copy(__first2, __last2, std::copy(__first1, __last1, __result)); 
# 5522
} 
# 5542 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5543
_OutputIterator> inline _OutputIterator 
# 5545
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5546
__first2, _InputIterator2 __last2, _OutputIterator 
# 5547
__result) 
# 5548
{ 
# 5562
; 
# 5563
; 
# 5564
; 
# 5565
; 
# 5567
return std::__set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_less_iter()); 
# 5570
} 
# 5593 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 5594
_OutputIterator, class _Compare> inline _OutputIterator 
# 5596
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 
# 5597
__first2, _InputIterator2 __last2, _OutputIterator 
# 5598
__result, _Compare 
# 5599
__comp) 
# 5600
{ 
# 5614
; 
# 5615
; 
# 5616
; 
# 5617
; 
# 5619
return std::__set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5622
} 
# 5624
template< class _ForwardIterator, class _Compare> constexpr _ForwardIterator 
# 5627
__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 5628
__comp) 
# 5629
{ 
# 5630
if (__first == __last) { 
# 5631
return __first; }  
# 5632
_ForwardIterator __result = __first; 
# 5633
while ((++__first) != __last) { 
# 5634
if (__comp(__first, __result)) { 
# 5635
__result = __first; }  }  
# 5636
return __result; 
# 5637
} 
# 5646 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator> constexpr _ForwardIterator 
# 5649
min_element(_ForwardIterator __first, _ForwardIterator __last) 
# 5650
{ 
# 5655
; 
# 5656
; 
# 5658
return std::__min_element(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 5660
} 
# 5671 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> constexpr _ForwardIterator 
# 5674
min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 5675
__comp) 
# 5676
{ 
# 5682
; 
# 5683
; 
# 5685
return std::__min_element(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5687
} 
# 5689
template< class _ForwardIterator, class _Compare> constexpr _ForwardIterator 
# 5692
__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 5693
__comp) 
# 5694
{ 
# 5695
if (__first == __last) { return __first; }  
# 5696
_ForwardIterator __result = __first; 
# 5697
while ((++__first) != __last) { 
# 5698
if (__comp(__result, __first)) { 
# 5699
__result = __first; }  }  
# 5700
return __result; 
# 5701
} 
# 5710 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator> constexpr _ForwardIterator 
# 5713
max_element(_ForwardIterator __first, _ForwardIterator __last) 
# 5714
{ 
# 5719
; 
# 5720
; 
# 5722
return std::__max_element(__first, __last, __gnu_cxx::__ops::__iter_less_iter()); 
# 5724
} 
# 5735 "/usr/include/c++/9/bits/stl_algo.h" 3
template< class _ForwardIterator, class _Compare> constexpr _ForwardIterator 
# 5738
max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare 
# 5739
__comp) 
# 5740
{ 
# 5746
; 
# 5747
; 
# 5749
return std::__max_element(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp)); 
# 5751
} 
# 5755
template< class _InputIterator, class _RandomAccessIterator, class 
# 5756
_Size, class _UniformRandomBitGenerator> _RandomAccessIterator 
# 5758
__sample(_InputIterator __first, _InputIterator __last, input_iterator_tag, _RandomAccessIterator 
# 5759
__out, random_access_iterator_tag, _Size 
# 5760
__n, _UniformRandomBitGenerator &&__g) 
# 5761
{ 
# 5762
using __distrib_type = uniform_int_distribution< _Size> ; 
# 5763
using __param_type = typename uniform_int_distribution< _Size> ::param_type; 
# 5764
__distrib_type __d{}; 
# 5765
_Size __sample_sz = (0); 
# 5766
while ((__first != __last) && (__sample_sz != __n)) 
# 5767
{ 
# 5768
(__out[__sample_sz++]) = (*__first); 
# 5769
++__first; 
# 5770
}  
# 5771
for (auto __pop_sz = __sample_sz; __first != __last; (++__first), ((void)(++__pop_sz))) 
# 5773
{ 
# 5774
const auto __k = __d(__g, __param_type{0, __pop_sz}); 
# 5775
if (__k < __n) { 
# 5776
(__out[__k]) = (*__first); }  
# 5777
}  
# 5778
return __out + __sample_sz; 
# 5779
} 
# 5782
template< class _ForwardIterator, class _OutputIterator, class _Cat, class 
# 5783
_Size, class _UniformRandomBitGenerator> _OutputIterator 
# 5785
__sample(_ForwardIterator __first, _ForwardIterator __last, forward_iterator_tag, _OutputIterator 
# 5787
__out, _Cat, _Size 
# 5788
__n, _UniformRandomBitGenerator &&__g) 
# 5789
{ 
# 5790
using __distrib_type = uniform_int_distribution< _Size> ; 
# 5791
using __param_type = typename uniform_int_distribution< _Size> ::param_type; 
# 5792
using _USize = make_unsigned_t< _Size> ; 
# 5793
using _Gen = remove_reference_t< _UniformRandomBitGenerator> ; 
# 5794
using __uc_type = common_type_t< typename remove_reference< _UniformRandomBitGenerator> ::type::result_type, make_unsigned_t< _Size> > ; 
# 5796
if (__first == __last) { 
# 5797
return __out; }  
# 5799
__distrib_type __d{}; 
# 5800
_Size __unsampled_sz = std::distance(__first, __last); 
# 5801
__n = std::min(__n, __unsampled_sz); 
# 5806
const __uc_type __urngrange = __g.max() - __g.min(); 
# 5807
if ((__urngrange / ((__uc_type)__unsampled_sz)) >= ((__uc_type)__unsampled_sz)) 
# 5810
{ 
# 5811
while ((__n != 0) && (__unsampled_sz >= 2)) 
# 5812
{ 
# 5813
const pair< _Size, _Size>  __p = __gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g); 
# 5816
--__unsampled_sz; 
# 5817
if ((__p.first) < __n) 
# 5818
{ 
# 5819
(*(__out++)) = (*__first); 
# 5820
--__n; 
# 5821
}  
# 5823
++__first; 
# 5825
if (__n == 0) { break; }  
# 5827
--__unsampled_sz; 
# 5828
if ((__p.second) < __n) 
# 5829
{ 
# 5830
(*(__out++)) = (*__first); 
# 5831
--__n; 
# 5832
}  
# 5834
++__first; 
# 5835
}  
# 5836
}  
# 5840
for (; __n != 0; ++__first) { 
# 5841
if (__d(__g, __param_type{0, --__unsampled_sz}) < __n) 
# 5842
{ 
# 5843
(*(__out++)) = (*__first); 
# 5844
--__n; 
# 5845
}  }  
# 5846
return __out; 
# 5847
} 
# 5883 "/usr/include/c++/9/bits/stl_algo.h" 3
}
# 71 "/usr/include/c++/9/cstring" 3
extern "C++" {
# 73
namespace std __attribute((__visibility__("default"))) { 
# 77
using ::memchr;
# 78
using ::memcmp;
# 79
using ::memcpy;
# 80
using ::memmove;
# 81
using ::memset;
# 82
using ::strcat;
# 83
using ::strcmp;
# 84
using ::strcoll;
# 85
using ::strcpy;
# 86
using ::strcspn;
# 87
using ::strerror;
# 88
using ::strlen;
# 89
using ::strncat;
# 90
using ::strncmp;
# 91
using ::strncpy;
# 92
using ::strspn;
# 93
using ::strtok;
# 94
using ::strxfrm;
# 95
using ::strchr;
# 96
using ::strpbrk;
# 97
using ::strrchr;
# 98
using ::strstr;
# 123 "/usr/include/c++/9/cstring" 3
}
# 124
}
# 64 "/usr/include/opencv4/opencv2/core/cvstd.hpp" 3
namespace cv { 
# 66
static inline uchar abs(uchar a) { return a; } 
# 67
static inline ushort abs(ushort a) { return a; } 
# 68
static inline unsigned abs(unsigned a) { return a; } 
# 69
static inline uint64 abs(uint64 a) { return a; } 
# 71
using std::min;
# 72
using std::max;
# 73
using std::abs;
# 74
using std::swap;
# 75
using std::sqrt;
# 76
using std::exp;
# 77
using std::pow;
# 78
using std::log;
# 79
}
# 67 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< bool _TrivialValueTypes> 
# 72
struct __uninitialized_copy { 
# 74
template< class _InputIterator, class _ForwardIterator> static _ForwardIterator 
# 76
__uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 77
__result) 
# 78
{ 
# 79
_ForwardIterator __cur = __result; 
# 80
try 
# 81
{ 
# 82
for (; __first != __last; (++__first), ((void)(++__cur))) { 
# 83
std::_Construct(std::__addressof(*__cur), *__first); }  
# 84
return __cur; 
# 85
} 
# 86
catch (...) 
# 87
{ 
# 88
std::_Destroy(__result, __cur); 
# 89
throw; 
# 90
}  
# 91
} 
# 92
}; 
# 95
template<> struct __uninitialized_copy< true>  { 
# 97
template< class _InputIterator, class _ForwardIterator> static _ForwardIterator 
# 99
__uninit_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 100
__result) 
# 101
{ return std::copy(__first, __last, __result); } 
# 102
}; 
# 113 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
template< class _InputIterator, class _ForwardIterator> inline _ForwardIterator 
# 115
uninitialized_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 116
__result) 
# 117
{ 
# 119
typedef typename iterator_traits< _InputIterator> ::value_type _ValueType1; 
# 121
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType2; 
# 127
static_assert((is_constructible< typename iterator_traits< _ForwardIterator> ::value_type, __decltype((*__first))> ::value), "result type must be constructible from value type of input range");
# 130
typedef typename iterator_traits< _InputIterator> ::reference _RefType1; 
# 131
typedef typename iterator_traits< _ForwardIterator> ::reference _RefType2; 
# 134
const bool __assignable = (is_assignable< typename iterator_traits< _ForwardIterator> ::reference, typename iterator_traits< _InputIterator> ::reference> ::value); 
# 137
return std::template __uninitialized_copy< __is_trivial(_ValueType1) && __is_trivial(_ValueType2) && __assignable> ::__uninit_copy(__first, __last, __result); 
# 141
} 
# 144
template< bool _TrivialValueType> 
# 145
struct __uninitialized_fill { 
# 147
template< class _ForwardIterator, class _Tp> static void 
# 149
__uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 150
__x) 
# 151
{ 
# 152
_ForwardIterator __cur = __first; 
# 153
try 
# 154
{ 
# 155
for (; __cur != __last; ++__cur) { 
# 156
std::_Construct(std::__addressof(*__cur), __x); }  
# 157
} 
# 158
catch (...) 
# 159
{ 
# 160
std::_Destroy(__first, __cur); 
# 161
throw; 
# 162
}  
# 163
} 
# 164
}; 
# 167
template<> struct __uninitialized_fill< true>  { 
# 169
template< class _ForwardIterator, class _Tp> static void 
# 171
__uninit_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 172
__x) 
# 173
{ std::fill(__first, __last, __x); } 
# 174
}; 
# 185 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
template< class _ForwardIterator, class _Tp> inline void 
# 187
uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 188
__x) 
# 189
{ 
# 191
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 197
static_assert((is_constructible< typename iterator_traits< _ForwardIterator> ::value_type, const _Tp &> ::value), "result type must be constructible from input type");
# 202
const bool __assignable = (is_copy_assignable< typename iterator_traits< _ForwardIterator> ::value_type> ::value); 
# 205
std::template __uninitialized_fill< __is_trivial(_ValueType) && __assignable> ::__uninit_fill(__first, __last, __x); 
# 207
} 
# 210
template< bool _TrivialValueType> 
# 211
struct __uninitialized_fill_n { 
# 213
template< class _ForwardIterator, class _Size, class _Tp> static _ForwardIterator 
# 215
__uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &
# 216
__x) 
# 217
{ 
# 218
_ForwardIterator __cur = __first; 
# 219
try 
# 220
{ 
# 221
for (; __n > 0; (--__n), ((void)(++__cur))) { 
# 222
std::_Construct(std::__addressof(*__cur), __x); }  
# 223
return __cur; 
# 224
} 
# 225
catch (...) 
# 226
{ 
# 227
std::_Destroy(__first, __cur); 
# 228
throw; 
# 229
}  
# 230
} 
# 231
}; 
# 234
template<> struct __uninitialized_fill_n< true>  { 
# 236
template< class _ForwardIterator, class _Size, class _Tp> static _ForwardIterator 
# 238
__uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp &
# 239
__x) 
# 240
{ return std::fill_n(__first, __n, __x); } 
# 241
}; 
# 254 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
template< class _ForwardIterator, class _Size, class _Tp> inline _ForwardIterator 
# 256
uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp &__x) 
# 257
{ 
# 259
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 265
static_assert((is_constructible< typename iterator_traits< _ForwardIterator> ::value_type, const _Tp &> ::value), "result type must be constructible from input type");
# 270
const bool __assignable = (is_copy_assignable< typename iterator_traits< _ForwardIterator> ::value_type> ::value); 
# 272
return __uninitialized_fill_n< __is_trivial(_ValueType) && __assignable> ::__uninit_fill_n(__first, __n, __x); 
# 274
} 
# 282
template< class _InputIterator, class _ForwardIterator, class 
# 283
_Allocator> _ForwardIterator 
# 285
__uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 286
__result, _Allocator &__alloc) 
# 287
{ 
# 288
_ForwardIterator __cur = __result; 
# 289
try 
# 290
{ 
# 291
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 292
for (; __first != __last; (++__first), ((void)(++__cur))) { 
# 293
__traits::construct(__alloc, std::__addressof(*__cur), *__first); }  
# 294
return __cur; 
# 295
} 
# 296
catch (...) 
# 297
{ 
# 298
std::_Destroy(__result, __cur, __alloc); 
# 299
throw; 
# 300
}  
# 301
} 
# 303
template< class _InputIterator, class _ForwardIterator, class _Tp> inline _ForwardIterator 
# 305
__uninitialized_copy_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 306
__result, allocator< _Tp>  &) 
# 307
{ return std::uninitialized_copy(__first, __last, __result); } 
# 309
template< class _InputIterator, class _ForwardIterator, class 
# 310
_Allocator> inline _ForwardIterator 
# 312
__uninitialized_move_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 313
__result, _Allocator &__alloc) 
# 314
{ 
# 315
return std::__uninitialized_copy_a(std::make_move_iterator(__first), std::make_move_iterator(__last), __result, __alloc); 
# 318
} 
# 320
template< class _InputIterator, class _ForwardIterator, class 
# 321
_Allocator> inline _ForwardIterator 
# 323
__uninitialized_move_if_noexcept_a(_InputIterator __first, _InputIterator 
# 324
__last, _ForwardIterator 
# 325
__result, _Allocator &
# 326
__alloc) 
# 327
{ 
# 328
return std::__uninitialized_copy_a(std::__make_move_if_noexcept_iterator(__first), std::__make_move_if_noexcept_iterator(__last), __result, __alloc); 
# 331
} 
# 333
template< class _ForwardIterator, class _Tp, class _Allocator> void 
# 335
__uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 336
__x, _Allocator &__alloc) 
# 337
{ 
# 338
_ForwardIterator __cur = __first; 
# 339
try 
# 340
{ 
# 341
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 342
for (; __cur != __last; ++__cur) { 
# 343
__traits::construct(__alloc, std::__addressof(*__cur), __x); }  
# 344
} 
# 345
catch (...) 
# 346
{ 
# 347
std::_Destroy(__first, __cur, __alloc); 
# 348
throw; 
# 349
}  
# 350
} 
# 352
template< class _ForwardIterator, class _Tp, class _Tp2> inline void 
# 354
__uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &
# 355
__x, allocator< _Tp2>  &) 
# 356
{ std::uninitialized_fill(__first, __last, __x); } 
# 358
template< class _ForwardIterator, class _Size, class _Tp, class 
# 359
_Allocator> _ForwardIterator 
# 361
__uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &
# 362
__x, _Allocator &__alloc) 
# 363
{ 
# 364
_ForwardIterator __cur = __first; 
# 365
try 
# 366
{ 
# 367
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 368
for (; __n > 0; (--__n), ((void)(++__cur))) { 
# 369
__traits::construct(__alloc, std::__addressof(*__cur), __x); }  
# 370
return __cur; 
# 371
} 
# 372
catch (...) 
# 373
{ 
# 374
std::_Destroy(__first, __cur, __alloc); 
# 375
throw; 
# 376
}  
# 377
} 
# 379
template< class _ForwardIterator, class _Size, class _Tp, class 
# 380
_Tp2> inline _ForwardIterator 
# 382
__uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, const _Tp &
# 383
__x, allocator< _Tp2>  &) 
# 384
{ return std::uninitialized_fill_n(__first, __n, __x); } 
# 396 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
template< class _InputIterator1, class _InputIterator2, class 
# 397
_ForwardIterator, class _Allocator> inline _ForwardIterator 
# 399
__uninitialized_copy_move(_InputIterator1 __first1, _InputIterator1 
# 400
__last1, _InputIterator2 
# 401
__first2, _InputIterator2 
# 402
__last2, _ForwardIterator 
# 403
__result, _Allocator &
# 404
__alloc) 
# 405
{ 
# 406
_ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1, __result, __alloc); 
# 409
try 
# 410
{ 
# 411
return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc); 
# 412
} 
# 413
catch (...) 
# 414
{ 
# 415
std::_Destroy(__result, __mid, __alloc); 
# 416
throw; 
# 417
}  
# 418
} 
# 424
template< class _InputIterator1, class _InputIterator2, class 
# 425
_ForwardIterator, class _Allocator> inline _ForwardIterator 
# 427
__uninitialized_move_copy(_InputIterator1 __first1, _InputIterator1 
# 428
__last1, _InputIterator2 
# 429
__first2, _InputIterator2 
# 430
__last2, _ForwardIterator 
# 431
__result, _Allocator &
# 432
__alloc) 
# 433
{ 
# 434
_ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1, __result, __alloc); 
# 437
try 
# 438
{ 
# 439
return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc); 
# 440
} 
# 441
catch (...) 
# 442
{ 
# 443
std::_Destroy(__result, __mid, __alloc); 
# 444
throw; 
# 445
}  
# 446
} 
# 451
template< class _ForwardIterator, class _Tp, class _InputIterator, class 
# 452
_Allocator> inline _ForwardIterator 
# 454
__uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &
# 455
__x, _InputIterator __first, _InputIterator 
# 456
__last, _Allocator &__alloc) 
# 457
{ 
# 458
std::__uninitialized_fill_a(__result, __mid, __x, __alloc); 
# 459
try 
# 460
{ 
# 461
return std::__uninitialized_move_a(__first, __last, __mid, __alloc); 
# 462
} 
# 463
catch (...) 
# 464
{ 
# 465
std::_Destroy(__result, __mid, __alloc); 
# 466
throw; 
# 467
}  
# 468
} 
# 473
template< class _InputIterator, class _ForwardIterator, class _Tp, class 
# 474
_Allocator> inline void 
# 476
__uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1, _ForwardIterator 
# 477
__first2, _ForwardIterator 
# 478
__last2, const _Tp &__x, _Allocator &
# 479
__alloc) 
# 480
{ 
# 481
_ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1, __first2, __alloc); 
# 484
try 
# 485
{ 
# 486
std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc); 
# 487
} 
# 488
catch (...) 
# 489
{ 
# 490
std::_Destroy(__first2, __mid2, __alloc); 
# 491
throw; 
# 492
}  
# 493
} 
# 499
template< bool _TrivialValueType> 
# 500
struct __uninitialized_default_1 { 
# 502
template< class _ForwardIterator> static void 
# 504
__uninit_default(_ForwardIterator __first, _ForwardIterator __last) 
# 505
{ 
# 506
_ForwardIterator __cur = __first; 
# 507
try 
# 508
{ 
# 509
for (; __cur != __last; ++__cur) { 
# 510
std::_Construct(std::__addressof(*__cur)); }  
# 511
} 
# 512
catch (...) 
# 513
{ 
# 514
std::_Destroy(__first, __cur); 
# 515
throw; 
# 516
}  
# 517
} 
# 518
}; 
# 521
template<> struct __uninitialized_default_1< true>  { 
# 523
template< class _ForwardIterator> static void 
# 525
__uninit_default(_ForwardIterator __first, _ForwardIterator __last) 
# 526
{ 
# 528
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 530
std::fill(__first, __last, _ValueType()); 
# 531
} 
# 532
}; 
# 534
template< bool _TrivialValueType> 
# 535
struct __uninitialized_default_n_1 { 
# 537
template< class _ForwardIterator, class _Size> static _ForwardIterator 
# 539
__uninit_default_n(_ForwardIterator __first, _Size __n) 
# 540
{ 
# 541
_ForwardIterator __cur = __first; 
# 542
try 
# 543
{ 
# 544
for (; __n > 0; (--__n), ((void)(++__cur))) { 
# 545
std::_Construct(std::__addressof(*__cur)); }  
# 546
return __cur; 
# 547
} 
# 548
catch (...) 
# 549
{ 
# 550
std::_Destroy(__first, __cur); 
# 551
throw; 
# 552
}  
# 553
} 
# 554
}; 
# 557
template<> struct __uninitialized_default_n_1< true>  { 
# 559
template< class _ForwardIterator, class _Size> static _ForwardIterator 
# 561
__uninit_default_n(_ForwardIterator __first, _Size __n) 
# 562
{ 
# 564
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 566
return std::fill_n(__first, __n, _ValueType()); 
# 567
} 
# 568
}; 
# 573
template< class _ForwardIterator> inline void 
# 575
__uninitialized_default(_ForwardIterator __first, _ForwardIterator 
# 576
__last) 
# 577
{ 
# 579
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 581
const bool __assignable = (is_copy_assignable< typename iterator_traits< _ForwardIterator> ::value_type> ::value); 
# 583
std::template __uninitialized_default_1< __is_trivial(_ValueType) && __assignable> ::__uninit_default(__first, __last); 
# 586
} 
# 590
template< class _ForwardIterator, class _Size> inline _ForwardIterator 
# 592
__uninitialized_default_n(_ForwardIterator __first, _Size __n) 
# 593
{ 
# 595
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 597
const bool __assignable = (is_copy_assignable< typename iterator_traits< _ForwardIterator> ::value_type> ::value); 
# 599
return __uninitialized_default_n_1< __is_trivial(_ValueType) && __assignable> ::__uninit_default_n(__first, __n); 
# 602
} 
# 608
template< class _ForwardIterator, class _Allocator> void 
# 610
__uninitialized_default_a(_ForwardIterator __first, _ForwardIterator 
# 611
__last, _Allocator &
# 612
__alloc) 
# 613
{ 
# 614
_ForwardIterator __cur = __first; 
# 615
try 
# 616
{ 
# 617
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 618
for (; __cur != __last; ++__cur) { 
# 619
__traits::construct(__alloc, std::__addressof(*__cur)); }  
# 620
} 
# 621
catch (...) 
# 622
{ 
# 623
std::_Destroy(__first, __cur, __alloc); 
# 624
throw; 
# 625
}  
# 626
} 
# 628
template< class _ForwardIterator, class _Tp> inline void 
# 630
__uninitialized_default_a(_ForwardIterator __first, _ForwardIterator 
# 631
__last, allocator< _Tp>  &) 
# 633
{ std::__uninitialized_default(__first, __last); } 
# 639
template< class _ForwardIterator, class _Size, class _Allocator> _ForwardIterator 
# 641
__uninitialized_default_n_a(_ForwardIterator __first, _Size __n, _Allocator &
# 642
__alloc) 
# 643
{ 
# 644
_ForwardIterator __cur = __first; 
# 645
try 
# 646
{ 
# 647
typedef __gnu_cxx::__alloc_traits< _Allocator>  __traits; 
# 648
for (; __n > 0; (--__n), ((void)(++__cur))) { 
# 649
__traits::construct(__alloc, std::__addressof(*__cur)); }  
# 650
return __cur; 
# 651
} 
# 652
catch (...) 
# 653
{ 
# 654
std::_Destroy(__first, __cur, __alloc); 
# 655
throw; 
# 656
}  
# 657
} 
# 659
template< class _ForwardIterator, class _Size, class _Tp> inline _ForwardIterator 
# 661
__uninitialized_default_n_a(_ForwardIterator __first, _Size __n, allocator< _Tp>  &) 
# 663
{ return std::__uninitialized_default_n(__first, __n); } 
# 665
template< bool _TrivialValueType> 
# 666
struct __uninitialized_default_novalue_1 { 
# 668
template< class _ForwardIterator> static void 
# 670
__uninit_default_novalue(_ForwardIterator __first, _ForwardIterator 
# 671
__last) 
# 672
{ 
# 673
_ForwardIterator __cur = __first; 
# 674
try 
# 675
{ 
# 676
for (; __cur != __last; ++__cur) { 
# 677
std::_Construct_novalue(std::__addressof(*__cur)); }  
# 678
} 
# 679
catch (...) 
# 680
{ 
# 681
std::_Destroy(__first, __cur); 
# 682
throw; 
# 683
}  
# 684
} 
# 685
}; 
# 688
template<> struct __uninitialized_default_novalue_1< true>  { 
# 690
template< class _ForwardIterator> static void 
# 692
__uninit_default_novalue(_ForwardIterator __first, _ForwardIterator 
# 693
__last) 
# 694
{ 
# 695
} 
# 696
}; 
# 698
template< bool _TrivialValueType> 
# 699
struct __uninitialized_default_novalue_n_1 { 
# 701
template< class _ForwardIterator, class _Size> static _ForwardIterator 
# 703
__uninit_default_novalue_n(_ForwardIterator __first, _Size __n) 
# 704
{ 
# 705
_ForwardIterator __cur = __first; 
# 706
try 
# 707
{ 
# 708
for (; __n > 0; (--__n), ((void)(++__cur))) { 
# 709
std::_Construct_novalue(std::__addressof(*__cur)); }  
# 710
return __cur; 
# 711
} 
# 712
catch (...) 
# 713
{ 
# 714
std::_Destroy(__first, __cur); 
# 715
throw; 
# 716
}  
# 717
} 
# 718
}; 
# 721
template<> struct __uninitialized_default_novalue_n_1< true>  { 
# 723
template< class _ForwardIterator, class _Size> static _ForwardIterator 
# 725
__uninit_default_novalue_n(_ForwardIterator __first, _Size __n) 
# 726
{ return std::next(__first, __n); } 
# 727
}; 
# 732
template< class _ForwardIterator> inline void 
# 734
__uninitialized_default_novalue(_ForwardIterator __first, _ForwardIterator 
# 735
__last) 
# 736
{ 
# 738
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 740
std::template __uninitialized_default_novalue_1< is_trivially_default_constructible< typename iterator_traits< _ForwardIterator> ::value_type> ::value> ::__uninit_default_novalue(__first, __last); 
# 743
} 
# 747
template< class _ForwardIterator, class _Size> inline _ForwardIterator 
# 749
__uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n) 
# 750
{ 
# 752
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType; 
# 754
return __uninitialized_default_novalue_n_1< is_trivially_default_constructible< typename iterator_traits< _ForwardIterator> ::value_type> ::value> ::__uninit_default_novalue_n(__first, __n); 
# 757
} 
# 759
template< class _InputIterator, class _Size, class 
# 760
_ForwardIterator> _ForwardIterator 
# 762
__uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator 
# 763
__result, input_iterator_tag) 
# 764
{ 
# 765
_ForwardIterator __cur = __result; 
# 766
try 
# 767
{ 
# 768
for (; __n > 0; ((--__n), ((void)(++__first))), (++__cur)) { 
# 769
std::_Construct(std::__addressof(*__cur), *__first); }  
# 770
return __cur; 
# 771
} 
# 772
catch (...) 
# 773
{ 
# 774
std::_Destroy(__result, __cur); 
# 775
throw; 
# 776
}  
# 777
} 
# 779
template< class _RandomAccessIterator, class _Size, class 
# 780
_ForwardIterator> inline _ForwardIterator 
# 782
__uninitialized_copy_n(_RandomAccessIterator __first, _Size __n, _ForwardIterator 
# 783
__result, random_access_iterator_tag) 
# 785
{ return std::uninitialized_copy(__first, __first + __n, __result); } 
# 787
template< class _InputIterator, class _Size, class 
# 788
_ForwardIterator> pair< _InputIterator, _ForwardIterator>  
# 790
__uninitialized_copy_n_pair(_InputIterator __first, _Size __n, _ForwardIterator 
# 791
__result, input_iterator_tag) 
# 792
{ 
# 793
_ForwardIterator __cur = __result; 
# 794
try 
# 795
{ 
# 796
for (; __n > 0; ((--__n), ((void)(++__first))), (++__cur)) { 
# 797
std::_Construct(std::__addressof(*__cur), *__first); }  
# 798
return {__first, __cur}; 
# 799
} 
# 800
catch (...) 
# 801
{ 
# 802
std::_Destroy(__result, __cur); 
# 803
throw; 
# 804
}  
# 805
} 
# 807
template< class _RandomAccessIterator, class _Size, class 
# 808
_ForwardIterator> inline pair< _RandomAccessIterator, _ForwardIterator>  
# 810
__uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n, _ForwardIterator 
# 811
__result, random_access_iterator_tag) 
# 813
{ 
# 814
auto __second_res = uninitialized_copy(__first, __first + __n, __result); 
# 815
auto __first_res = std::next(__first, __n); 
# 816
return {__first_res, __second_res}; 
# 817
} 
# 828 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
template< class _InputIterator, class _Size, class _ForwardIterator> inline _ForwardIterator 
# 830
uninitialized_copy_n(_InputIterator __first, _Size __n, _ForwardIterator 
# 831
__result) 
# 832
{ return std::__uninitialized_copy_n(__first, __n, __result, std::__iterator_category(__first)); 
# 833
} 
# 835
template< class _InputIterator, class _Size, class _ForwardIterator> inline pair< _InputIterator, _ForwardIterator>  
# 837
__uninitialized_copy_n_pair(_InputIterator __first, _Size __n, _ForwardIterator 
# 838
__result) 
# 839
{ 
# 840
return std::__uninitialized_copy_n_pair(__first, __n, __result, std::__iterator_category(__first)); 
# 843
} 
# 903 "/usr/include/c++/9/bits/stl_uninitialized.h" 3
template< class _Tp, class _Up, class _Allocator> inline void 
# 905
__relocate_object_a(_Tp *__dest, _Up *__orig, _Allocator &__alloc) noexcept(noexcept(std::template allocator_traits< _Allocator> ::construct(__alloc, __dest, std::move(*__orig))) && noexcept(std::template allocator_traits< _Allocator> ::destroy(__alloc, std::__addressof(*__orig)))) 
# 910
{ 
# 911
typedef allocator_traits< _Allocator>  __traits; 
# 912
__traits::construct(__alloc, __dest, std::move(*__orig)); 
# 913
__traits::destroy(__alloc, std::__addressof(*__orig)); 
# 914
} 
# 918
template< class _Tp, class  = void> 
# 919
struct __is_bitwise_relocatable : public is_trivial< _Tp>  { 
# 920
}; 
# 922
template< class _Tp, class _Up> inline __enable_if_t< __is_bitwise_relocatable< _Tp> ::value, _Tp *>  
# 924
__relocate_a_1(_Tp *__first, _Tp *__last, _Tp *
# 925
__result, allocator< _Up>  &) noexcept 
# 926
{ 
# 927
ptrdiff_t __count = __last - __first; 
# 928
if (__count > (0)) { 
# 929
__builtin_memmove(__result, __first, __count * sizeof(_Tp)); }  
# 930
return __result + __count; 
# 931
} 
# 933
template< class _InputIterator, class _ForwardIterator, class 
# 934
_Allocator> inline _ForwardIterator 
# 936
__relocate_a_1(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 937
__result, _Allocator &__alloc) noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result), std::addressof(*__first), __alloc))) 
# 941
{ 
# 943
typedef typename iterator_traits< _InputIterator> ::value_type _ValueType; 
# 945
typedef typename iterator_traits< _ForwardIterator> ::value_type _ValueType2; 
# 946
static_assert((std::template is_same< typename iterator_traits< _InputIterator> ::value_type, typename iterator_traits< _ForwardIterator> ::value_type> ::value), "relocation is only possible for values of the same type");
# 948
_ForwardIterator __cur = __result; 
# 949
for (; __first != __last; (++__first), ((void)(++__cur))) { 
# 950
std::__relocate_object_a(std::__addressof(*__cur), std::__addressof(*__first), __alloc); }  
# 952
return __cur; 
# 953
} 
# 955
template< class _InputIterator, class _ForwardIterator, class 
# 956
_Allocator> inline _ForwardIterator 
# 958
__relocate_a(_InputIterator __first, _InputIterator __last, _ForwardIterator 
# 959
__result, _Allocator &__alloc) noexcept(noexcept(__relocate_a_1(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result), __alloc))) 
# 963
{ 
# 964
return __relocate_a_1(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result), __alloc); 
# 967
} 
# 971
}
# 59 "/usr/include/c++/9/bits/stl_raw_storage_iter.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 67
template< class _OutputIterator, class _Tp> 
# 68
class raw_storage_iterator : public iterator< output_iterator_tag, void, void, void, void>  { 
# 72
protected: _OutputIterator _M_iter; 
# 76
public: explicit raw_storage_iterator(_OutputIterator __x) : _M_iter(__x) 
# 77
{ } 
# 80
raw_storage_iterator &operator*() { return *this; } 
# 83
raw_storage_iterator &operator=(const _Tp &__element) 
# 84
{ 
# 85
std::_Construct(std::__addressof(*(_M_iter)), __element); 
# 86
return *this; 
# 87
} 
# 93
raw_storage_iterator &operator=(_Tp &&__element) 
# 94
{ 
# 95
std::_Construct(std::__addressof(*(_M_iter)), std::move(__element)); 
# 96
return *this; 
# 97
} 
# 101
raw_storage_iterator &operator++() 
# 102
{ 
# 103
++(_M_iter); 
# 104
return *this; 
# 105
} 
# 108
raw_storage_iterator operator++(int) 
# 109
{ 
# 110
raw_storage_iterator __tmp = *this; 
# 111
++(_M_iter); 
# 112
return __tmp; 
# 113
} 
# 117
_OutputIterator base() const { return _M_iter; } 
# 118
}; 
# 121
}
# 40 "/usr/include/c++/9/ext/concurrence.h" 3
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 49
enum _Lock_policy { _S_single, _S_mutex, _S_atomic}; 
# 53
static const _Lock_policy __default_lock_policy = _S_atomic; 
# 64
class __concurrence_lock_error : public std::exception { 
# 68
public: virtual const char *what() const throw() 
# 69
{ return "__gnu_cxx::__concurrence_lock_error"; } 
# 70
}; 
# 72
class __concurrence_unlock_error : public std::exception { 
# 76
public: virtual const char *what() const throw() 
# 77
{ return "__gnu_cxx::__concurrence_unlock_error"; } 
# 78
}; 
# 80
class __concurrence_broadcast_error : public std::exception { 
# 84
public: virtual const char *what() const throw() 
# 85
{ return "__gnu_cxx::__concurrence_broadcast_error"; } 
# 86
}; 
# 88
class __concurrence_wait_error : public std::exception { 
# 92
public: virtual const char *what() const throw() 
# 93
{ return "__gnu_cxx::__concurrence_wait_error"; } 
# 94
}; 
# 98
inline void __throw_concurrence_lock_error() 
# 99
{ throw __concurrence_lock_error(); } 
# 102
inline void __throw_concurrence_unlock_error() 
# 103
{ throw __concurrence_unlock_error(); } 
# 107
inline void __throw_concurrence_broadcast_error() 
# 108
{ throw __concurrence_broadcast_error(); } 
# 111
inline void __throw_concurrence_wait_error() 
# 112
{ throw __concurrence_wait_error(); } 
# 115
class __mutex { 
# 119
__gthread_mutex_t _M_mutex = {{0, (0), 0, (0), (PTHREAD_MUTEX_TIMED_NP), (0), (0), {(0), (0)}}}; 
# 124
__mutex(const __mutex &); 
# 125
__mutex &operator=(const __mutex &); 
# 128
public: __mutex() 
# 129
{ 
# 134
} 
# 144 "/usr/include/c++/9/ext/concurrence.h" 3
void lock() 
# 145
{ 
# 147
if (__gthread_active_p()) 
# 148
{ 
# 149
if (__gthread_mutex_lock(&(_M_mutex)) != 0) { 
# 150
__throw_concurrence_lock_error(); }  
# 151
}  
# 153
} 
# 155
void unlock() 
# 156
{ 
# 158
if (__gthread_active_p()) 
# 159
{ 
# 160
if (__gthread_mutex_unlock(&(_M_mutex)) != 0) { 
# 161
__throw_concurrence_unlock_error(); }  
# 162
}  
# 164
} 
# 166
__gthread_mutex_t *gthread_mutex() 
# 167
{ return &(_M_mutex); } 
# 168
}; 
# 170
class __recursive_mutex { 
# 174
__gthread_recursive_mutex_t _M_mutex = {{0, (0), 0, (0), (PTHREAD_MUTEX_RECURSIVE_NP), (0), (0), {(0), (0)}}}; 
# 179
__recursive_mutex(const __recursive_mutex &); 
# 180
__recursive_mutex &operator=(const __recursive_mutex &); 
# 183
public: __recursive_mutex() 
# 184
{ 
# 189
} 
# 199 "/usr/include/c++/9/ext/concurrence.h" 3
void lock() 
# 200
{ 
# 202
if (__gthread_active_p()) 
# 203
{ 
# 204
if (__gthread_recursive_mutex_lock(&(_M_mutex)) != 0) { 
# 205
__throw_concurrence_lock_error(); }  
# 206
}  
# 208
} 
# 210
void unlock() 
# 211
{ 
# 213
if (__gthread_active_p()) 
# 214
{ 
# 215
if (__gthread_recursive_mutex_unlock(&(_M_mutex)) != 0) { 
# 216
__throw_concurrence_unlock_error(); }  
# 217
}  
# 219
} 
# 221
__gthread_recursive_mutex_t *gthread_recursive_mutex() 
# 222
{ return &(_M_mutex); } 
# 223
}; 
# 228
class __scoped_lock { 
# 231
public: typedef __mutex __mutex_type; 
# 234
private: __mutex_type &_M_device; 
# 236
__scoped_lock(const __scoped_lock &); 
# 237
__scoped_lock &operator=(const __scoped_lock &); 
# 240
public: explicit __scoped_lock(__mutex_type &__name) : _M_device(__name) 
# 241
{ (_M_device).lock(); } 
# 243
~__scoped_lock() throw() 
# 244
{ (_M_device).unlock(); } 
# 245
}; 
# 248
class __cond { 
# 252
__gthread_cond_t _M_cond = {{{(0)}, {(0)}, {(0), (0)}, {(0), (0)}, (0), (0), {(0), (0)}}}; 
# 257
__cond(const __cond &); 
# 258
__cond &operator=(const __cond &); 
# 261
public: __cond() 
# 262
{ 
# 267
} 
# 277 "/usr/include/c++/9/ext/concurrence.h" 3
void broadcast() 
# 278
{ 
# 280
if (__gthread_active_p()) 
# 281
{ 
# 282
if (__gthread_cond_broadcast(&(_M_cond)) != 0) { 
# 283
__throw_concurrence_broadcast_error(); }  
# 284
}  
# 286
} 
# 288
void wait(__mutex *mutex) 
# 289
{ 
# 291
{ 
# 292
if (__gthread_cond_wait(&(_M_cond), mutex->gthread_mutex()) != 0) { 
# 293
__throw_concurrence_wait_error(); }  
# 294
} 
# 296
} 
# 298
void wait_recursive(__recursive_mutex *mutex) 
# 299
{ 
# 301
{ 
# 302
if (__gthread_cond_wait_recursive(&(_M_cond), mutex->gthread_recursive_mutex()) != 0) { 
# 305
__throw_concurrence_wait_error(); }  
# 306
} 
# 308
} 
# 309
}; 
# 313
}
# 35 "/usr/include/c++/9/bits/uses_allocator.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 40
struct __erased_type { }; 
# 45
template< class _Alloc, class _Tp> using __is_erased_or_convertible = __or_< is_convertible< _Alloc, _Tp> , is_same< _Tp, __erased_type> > ; 
# 50
struct allocator_arg_t { explicit allocator_arg_t() = default;}; 
# 52
constexpr allocator_arg_t allocator_arg = allocator_arg_t(); 
# 55
template< class _Tp, class _Alloc, class  = __void_t< > > 
# 56
struct __uses_allocator_helper : public false_type { 
# 57
}; 
# 59
template< class _Tp, class _Alloc> 
# 60
struct __uses_allocator_helper< _Tp, _Alloc, __void_t< typename _Tp::allocator_type> >  : public __or_< is_convertible< _Alloc, typename _Tp::allocator_type> , is_same< typename _Tp::allocator_type, __erased_type> > ::type { 
# 63
}; 
# 66
template< class _Tp, class _Alloc> 
# 67
struct uses_allocator : public __uses_allocator_helper< _Tp, _Alloc> ::type { 
# 69
}; 
# 71
struct __uses_alloc_base { }; 
# 73
struct __uses_alloc0 : public __uses_alloc_base { 
# 75
struct _Sink { void operator=(const void *) { } } _M_a; 
# 76
}; 
# 78
template< class _Alloc> 
# 79
struct __uses_alloc1 : public __uses_alloc_base { const _Alloc *_M_a; }; 
# 81
template< class _Alloc> 
# 82
struct __uses_alloc2 : public __uses_alloc_base { const _Alloc *_M_a; }; 
# 84
template< bool , class _Tp, class _Alloc, class ..._Args> struct __uses_alloc; 
# 87
template< class _Tp, class _Alloc, class ..._Args> 
# 88
struct __uses_alloc< true, _Tp, _Alloc, _Args...>  : public conditional< is_constructible< _Tp, allocator_arg_t, const _Alloc &, _Args...> ::value, __uses_alloc1< _Alloc> , __uses_alloc2< _Alloc> > ::type { 
# 96
static_assert((__or_< is_constructible< _Tp, std::allocator_arg_t, const _Alloc &, _Args...> , is_constructible< _Tp, _Args..., const _Alloc &> > ::value), "construction with an allocator must be possible if uses_allocator is true");
# 101
}; 
# 103
template< class _Tp, class _Alloc, class ..._Args> 
# 104
struct __uses_alloc< false, _Tp, _Alloc, _Args...>  : public __uses_alloc0 { 
# 105
}; 
# 107
template< class _Tp, class _Alloc, class ..._Args> using __uses_alloc_t = __uses_alloc< uses_allocator< _Tp, _Alloc> ::value, _Tp, _Alloc, _Args...> ; 
# 111
template< class _Tp, class _Alloc, class ..._Args> inline __uses_alloc_t< _Tp, _Alloc, _Args...>  
# 113
__use_alloc(const _Alloc &__a) 
# 114
{ 
# 115
__uses_alloc_t< _Tp, _Alloc, _Args...>  __ret; 
# 116
(__ret._M_a) = std::__addressof(__a); 
# 117
return __ret; 
# 118
} 
# 120
template < typename _Tp, typename _Alloc, typename ... _Args >
    void
    __use_alloc ( const _Alloc && ) = delete;
# 130
template< template< class ...>  class _Predicate, class 
# 131
_Tp, class _Alloc, class ..._Args> 
# 132
struct __is_uses_allocator_predicate : public conditional< uses_allocator< _Tp, _Alloc> ::value, __or_< _Predicate< _Tp, allocator_arg_t, _Alloc, _Args...> , _Predicate< _Tp, _Args..., _Alloc> > , _Predicate< _Tp, _Args...> > ::type { 
# 136
}; 
# 138
template< class _Tp, class _Alloc, class ..._Args> 
# 139
struct __is_uses_allocator_constructible : public __is_uses_allocator_predicate< is_constructible, _Tp, _Alloc, _Args...>  { 
# 141
}; 
# 144
template< class _Tp, class _Alloc, class ..._Args> constexpr bool 
# 145
__is_uses_allocator_constructible_v = (__is_uses_allocator_constructible< _Tp, _Alloc, _Args...> ::value); 
# 149
template< class _Tp, class _Alloc, class ..._Args> 
# 150
struct __is_nothrow_uses_allocator_constructible : public __is_uses_allocator_predicate< is_nothrow_constructible, _Tp, _Alloc, _Args...>  { 
# 153
}; 
# 157
template< class _Tp, class _Alloc, class ..._Args> constexpr bool 
# 159
__is_nothrow_uses_allocator_constructible_v = (__is_nothrow_uses_allocator_constructible< _Tp, _Alloc, _Args...> ::value); 
# 163
template< class _Tp, class ..._Args> void 
# 164
__uses_allocator_construct_impl(__uses_alloc0 __a, _Tp *__ptr, _Args &&...
# 165
__args) 
# 166
{ ::new ((void *)__ptr) _Tp(std::forward< _Args> (__args)...); } 
# 168
template< class _Tp, class _Alloc, class ..._Args> void 
# 169
__uses_allocator_construct_impl(__uses_alloc1< _Alloc>  __a, _Tp *__ptr, _Args &&...
# 170
__args) 
# 171
{ 
# 172
::new ((void *)__ptr) _Tp(allocator_arg, *(__a._M_a), std::forward< _Args> (__args)...); 
# 174
} 
# 176
template< class _Tp, class _Alloc, class ..._Args> void 
# 177
__uses_allocator_construct_impl(__uses_alloc2< _Alloc>  __a, _Tp *__ptr, _Args &&...
# 178
__args) 
# 179
{ ::new ((void *)__ptr) _Tp(std::forward< _Args> (__args)..., *(__a._M_a)); } 
# 181
template< class _Tp, class _Alloc, class ..._Args> void 
# 182
__uses_allocator_construct(const _Alloc &__a, _Tp *__ptr, _Args &&...
# 183
__args) 
# 184
{ 
# 185
std::__uses_allocator_construct_impl(std::__use_alloc< _Tp, _Alloc, _Args...> (__a), __ptr, std::forward< _Args> (__args)...); 
# 188
} 
# 191
}
# 41 "/usr/include/c++/9/bits/invoke.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52 "/usr/include/c++/9/bits/invoke.h" 3
template< class _Tp, class _Up = typename __inv_unwrap< _Tp> ::type> constexpr _Up &&
# 54
__invfwd(typename remove_reference< _Tp> ::type &__t) noexcept 
# 55
{ return static_cast< _Up &&>(__t); } 
# 57
template< class _Res, class _Fn, class ..._Args> constexpr _Res 
# 59
__invoke_impl(__invoke_other, _Fn &&__f, _Args &&...__args) 
# 60
{ return std::forward< _Fn> (__f)(std::forward< _Args> (__args)...); } 
# 62
template< class _Res, class _MemFun, class _Tp, class ..._Args> constexpr _Res 
# 64
__invoke_impl(__invoke_memfun_ref, _MemFun &&__f, _Tp &&__t, _Args &&...
# 65
__args) 
# 66
{ return (__invfwd< _Tp> (__t).*__f)(std::forward< _Args> (__args)...); } 
# 68
template< class _Res, class _MemFun, class _Tp, class ..._Args> constexpr _Res 
# 70
__invoke_impl(__invoke_memfun_deref, _MemFun &&__f, _Tp &&__t, _Args &&...
# 71
__args) 
# 72
{ 
# 73
return ((*std::forward< _Tp> (__t)).*__f)(std::forward< _Args> (__args)...); 
# 74
} 
# 76
template< class _Res, class _MemPtr, class _Tp> constexpr _Res 
# 78
__invoke_impl(__invoke_memobj_ref, _MemPtr &&__f, _Tp &&__t) 
# 79
{ return __invfwd< _Tp> (__t).*__f; } 
# 81
template< class _Res, class _MemPtr, class _Tp> constexpr _Res 
# 83
__invoke_impl(__invoke_memobj_deref, _MemPtr &&__f, _Tp &&__t) 
# 84
{ return (*std::forward< _Tp> (__t)).*__f; } 
# 87
template< class _Callable, class ..._Args> constexpr typename __invoke_result< _Callable, _Args...> ::type 
# 89
__invoke(_Callable &&__fn, _Args &&...__args) noexcept(__is_nothrow_invocable< _Callable, _Args...> ::value) 
# 91
{ 
# 92
using __result = __invoke_result< _Callable, _Args...> ; 
# 93
using __type = typename __invoke_result< _Callable, _Args...> ::type; 
# 94
using __tag = typename __invoke_result< _Callable, _Args...> ::__invoke_type; 
# 95
return std::__invoke_impl< typename __invoke_result< _Callable, _Args...> ::type> (__tag{}, std::forward< _Callable> (__fn), std::forward< _Args> (__args)...); 
# 97
} 
# 100
}
# 43 "/usr/include/c++/9/tuple" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class ..._Elements> class tuple; 
# 55
template< class _Tp> 
# 56
struct __is_empty_non_tuple : public is_empty< _Tp>  { }; 
# 59
template< class _El0, class ..._El> 
# 60
struct __is_empty_non_tuple< tuple< _El0, _El...> >  : public false_type { }; 
# 63
template< class _Tp> using __empty_not_final = typename conditional< __is_final(_Tp), integral_constant< bool, false> , __is_empty_non_tuple< _Tp> > ::type; 
# 68
template< size_t _Idx, class _Head, bool 
# 69
 = __empty_not_final< _Head> ::value> struct _Head_base; 
# 72
template< size_t _Idx, class _Head> 
# 73
struct _Head_base< _Idx, _Head, true>  : public _Head { 
# 76
constexpr _Head_base() : _Head() 
# 77
{ } 
# 79
constexpr _Head_base(const _Head &__h) : _Head(__h) 
# 80
{ } 
# 82
constexpr _Head_base(const std::_Head_base< _Idx, _Head, true>  &) = default;
# 83
constexpr _Head_base(std::_Head_base< _Idx, _Head, true>  &&) = default;
# 85
template< class _UHead> constexpr 
# 86
_Head_base(_UHead &&__h) : _Head(std::forward< _UHead> (__h)) 
# 87
{ } 
# 89
_Head_base(std::allocator_arg_t, std::__uses_alloc0) : _Head() 
# 90
{ } 
# 92
template< class _Alloc> 
# 93
_Head_base(std::allocator_arg_t, __uses_alloc1< _Alloc>  __a) : _Head(allocator_arg, *(__a._M_a)) 
# 94
{ } 
# 96
template< class _Alloc> 
# 97
_Head_base(std::allocator_arg_t, __uses_alloc2< _Alloc>  __a) : _Head(*(__a._M_a)) 
# 98
{ } 
# 100
template< class _UHead> 
# 101
_Head_base(std::__uses_alloc0, _UHead &&__uhead) : _Head(std::forward< _UHead> (__uhead)) 
# 102
{ } 
# 104
template< class _Alloc, class _UHead> 
# 105
_Head_base(__uses_alloc1< _Alloc>  __a, _UHead &&__uhead) : _Head(allocator_arg, *(__a._M_a), std::forward< _UHead> (__uhead)) 
# 106
{ } 
# 108
template< class _Alloc, class _UHead> 
# 109
_Head_base(__uses_alloc2< _Alloc>  __a, _UHead &&__uhead) : _Head(std::forward< _UHead> (__uhead), *(__a._M_a)) 
# 110
{ } 
# 113
static constexpr _Head &_M_head(std::_Head_base< _Idx, _Head, true>  &__b) noexcept { return __b; } 
# 116
static constexpr const _Head &_M_head(const std::_Head_base< _Idx, _Head, true>  &__b) noexcept { return __b; } 
# 117
}; 
# 119
template< size_t _Idx, class _Head> 
# 120
struct _Head_base< _Idx, _Head, false>  { 
# 122
constexpr _Head_base() : _M_head_impl() 
# 123
{ } 
# 125
constexpr _Head_base(const _Head &__h) : _M_head_impl(__h) 
# 126
{ } 
# 128
constexpr _Head_base(const std::_Head_base< _Idx, _Head, false>  &) = default;
# 129
constexpr _Head_base(std::_Head_base< _Idx, _Head, false>  &&) = default;
# 131
template< class _UHead> constexpr 
# 132
_Head_base(_UHead &&__h) : _M_head_impl(std::forward< _UHead> (__h)) 
# 133
{ } 
# 135
_Head_base(allocator_arg_t, __uses_alloc0) : _M_head_impl() 
# 136
{ } 
# 138
template< class _Alloc> 
# 139
_Head_base(allocator_arg_t, __uses_alloc1< _Alloc>  __a) : _M_head_impl(allocator_arg, *(__a._M_a)) 
# 140
{ } 
# 142
template< class _Alloc> 
# 143
_Head_base(allocator_arg_t, __uses_alloc2< _Alloc>  __a) : _M_head_impl(*(__a._M_a)) 
# 144
{ } 
# 146
template< class _UHead> 
# 147
_Head_base(__uses_alloc0, _UHead &&__uhead) : _M_head_impl(std::forward< _UHead> (__uhead)) 
# 148
{ } 
# 150
template< class _Alloc, class _UHead> 
# 151
_Head_base(__uses_alloc1< _Alloc>  __a, _UHead &&__uhead) : _M_head_impl(allocator_arg, *(__a._M_a), std::forward< _UHead> (__uhead)) 
# 153
{ } 
# 155
template< class _Alloc, class _UHead> 
# 156
_Head_base(__uses_alloc2< _Alloc>  __a, _UHead &&__uhead) : _M_head_impl(std::forward< _UHead> (__uhead), *(__a._M_a)) 
# 157
{ } 
# 160
static constexpr _Head &_M_head(std::_Head_base< _Idx, _Head, false>  &__b) noexcept { return __b._M_head_impl; } 
# 163
static constexpr const _Head &_M_head(const std::_Head_base< _Idx, _Head, false>  &__b) noexcept { return __b._M_head_impl; } 
# 165
_Head _M_head_impl; 
# 166
}; 
# 176 "/usr/include/c++/9/tuple" 3
template< size_t _Idx, class ..._Elements> struct _Tuple_impl; 
# 184
template< size_t _Idx, class _Head, class ..._Tail> 
# 185
struct _Tuple_impl< _Idx, _Head, _Tail...>  : public std::_Tuple_impl< _Idx + (1), _Tail...> , private _Head_base< _Idx, _Head>  { 
# 189
template< std::size_t , class ...> friend struct _Tuple_impl; 
# 191
typedef std::_Tuple_impl< _Idx + (1), _Tail...>  _Inherited; 
# 192
typedef _Head_base< _Idx, _Head>  _Base; 
# 195
static constexpr _Head &_M_head(std::_Tuple_impl< _Idx, _Head, _Tail...>  &__t) noexcept { return _Base::_M_head(__t); } 
# 198
static constexpr const _Head &_M_head(const std::_Tuple_impl< _Idx, _Head, _Tail...>  &__t) noexcept { return _Base::_M_head(__t); } 
# 201
static constexpr _Inherited &_M_tail(std::_Tuple_impl< _Idx, _Head, _Tail...>  &__t) noexcept { return __t; } 
# 204
static constexpr const _Inherited &_M_tail(const std::_Tuple_impl< _Idx, _Head, _Tail...>  &__t) noexcept { return __t; } 
# 206
constexpr _Tuple_impl() : _Inherited(), _Base() 
# 207
{ } 
# 210
constexpr explicit _Tuple_impl(const _Head &__head, const _Tail &...__tail) : _Inherited(__tail...), _Base(__head) 
# 211
{ } 
# 213
template< class _UHead, class ..._UTail, class  = typename enable_if< sizeof...(_Tail) == sizeof...(_UTail)> ::type> constexpr explicit 
# 216
_Tuple_impl(_UHead &&__head, _UTail &&...__tail) : _Inherited(std::forward< _UTail> (__tail)...), _Base(std::forward< _UHead> (__head)) 
# 218
{ } 
# 220
constexpr _Tuple_impl(const std::_Tuple_impl< _Idx, _Head, _Tail...>  &) = default;
# 224
std::_Tuple_impl< _Idx, _Head, _Tail...>  &operator=(const std::_Tuple_impl< _Idx, _Head, _Tail...>  &) = delete;
# 227
constexpr _Tuple_impl(std::_Tuple_impl< _Idx, _Head, _Tail...>  &&__in) noexcept(__and_< is_nothrow_move_constructible< _Head> , is_nothrow_move_constructible< _Inherited> > ::value) : _Inherited(std::move(_M_tail(__in))), _Base(std::forward< _Head> (_M_head(__in))) 
# 231
{ } 
# 233
template< class ..._UElements> constexpr 
# 234
_Tuple_impl(const std::_Tuple_impl< _Idx, _UElements...>  &__in) : _Inherited(_Tuple_impl< _Idx, _UElements...> ::_M_tail(__in)), _Base(_Tuple_impl< _Idx, _UElements...> ::_M_head(__in)) 
# 236
{ } 
# 238
template< class _UHead, class ..._UTails> constexpr 
# 239
_Tuple_impl(std::_Tuple_impl< _Idx, _UHead, _UTails...>  &&__in) : _Inherited(std::move(_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_tail(__in))), _Base(std::forward< _UHead> (_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_head(__in))) 
# 243
{ } 
# 245
template< class _Alloc> 
# 246
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a), _Base(__tag, __use_alloc< _Head> (__a)) 
# 248
{ } 
# 250
template< class _Alloc> 
# 251
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, const _Head &
# 252
__head, const _Tail &...__tail) : _Inherited(__tag, __a, __tail...), _Base(__use_alloc< _Head, _Alloc, _Head> (__a), __head) 
# 254
{ } 
# 256
template< class _Alloc, class _UHead, class ..._UTail, class 
# 257
 = typename enable_if< sizeof...(_Tail) == sizeof...(_UTail)> ::type> 
# 259
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&
# 260
__head, _UTail &&...__tail) : _Inherited(__tag, __a, std::forward< _UTail> (__tail)...), _Base(__use_alloc< _Head, _Alloc, _UHead> (__a), std::forward< _UHead> (__head)) 
# 263
{ } 
# 265
template< class _Alloc> 
# 266
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, const std::_Tuple_impl< _Idx, _Head, _Tail...>  &
# 267
__in) : _Inherited(__tag, __a, _M_tail(__in)), _Base(__use_alloc< _Head, _Alloc, _Head> (__a), _M_head(__in)) 
# 269
{ } 
# 271
template< class _Alloc> 
# 272
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, std::_Tuple_impl< _Idx, _Head, _Tail...>  &&
# 273
__in) : _Inherited(__tag, __a, std::move(_M_tail(__in))), _Base(__use_alloc< _Head, _Alloc, _Head> (__a), std::forward< _Head> (_M_head(__in))) 
# 276
{ } 
# 278
template< class _Alloc, class _UHead, class ..._UTails> 
# 279
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, const std::_Tuple_impl< _Idx, _UHead, _UTails...>  &
# 280
__in) : _Inherited(__tag, __a, _Tuple_impl< _Idx, _UHead, _UTails...> ::_M_tail(__in)), _Base(__use_alloc< _Head, _Alloc, const _UHead &> (__a), _Tuple_impl< _Idx, _UHead, _UTails...> ::_M_head(__in)) 
# 284
{ } 
# 286
template< class _Alloc, class _UHead, class ..._UTails> 
# 287
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, std::_Tuple_impl< _Idx, _UHead, _UTails...>  &&
# 288
__in) : _Inherited(__tag, __a, std::move(_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_tail(__in))), _Base(__use_alloc< _Head, _Alloc, _UHead> (__a), std::forward< _UHead> (_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_head(__in))) 
# 293
{ } 
# 295
template< class ..._UElements> void 
# 297
_M_assign(const std::_Tuple_impl< _Idx, _UElements...>  &__in) 
# 298
{ 
# 299
_M_head(*this) = _Tuple_impl< _Idx, _UElements...> ::_M_head(__in); 
# 300
_M_tail(*this)._M_assign(_Tuple_impl< _Idx, _UElements...> ::_M_tail(__in)); 
# 302
} 
# 304
template< class _UHead, class ..._UTails> void 
# 306
_M_assign(std::_Tuple_impl< _Idx, _UHead, _UTails...>  &&__in) 
# 307
{ 
# 308
_M_head(*this) = std::forward< _UHead> (_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_head(__in)); 
# 310
_M_tail(*this)._M_assign(std::move(_Tuple_impl< _Idx, _UHead, _UTails...> ::_M_tail(__in))); 
# 312
} 
# 316
protected: void _M_swap(std::_Tuple_impl< _Idx, _Head, _Tail...>  &__in) 
# 317
{ 
# 318
using std::swap;
# 319
swap(_M_head(*this), _M_head(__in)); 
# 320
_Inherited::_M_swap(_M_tail(__in)); 
# 321
} 
# 322
}; 
# 325
template< size_t _Idx, class _Head> 
# 326
struct _Tuple_impl< _Idx, _Head>  : private _Head_base< _Idx, _Head>  { 
# 329
template< std::size_t , class ...> friend struct _Tuple_impl; 
# 331
typedef _Head_base< _Idx, _Head>  _Base; 
# 334
static constexpr _Head &_M_head(std::_Tuple_impl< _Idx, _Head>  &__t) noexcept { return _Base::_M_head(__t); } 
# 337
static constexpr const _Head &_M_head(const std::_Tuple_impl< _Idx, _Head>  &__t) noexcept { return _Base::_M_head(__t); } 
# 339
constexpr _Tuple_impl() : _Base() 
# 340
{ } 
# 343
constexpr explicit _Tuple_impl(const _Head &__head) : _Base(__head) 
# 344
{ } 
# 346
template< class _UHead> constexpr explicit 
# 348
_Tuple_impl(_UHead &&__head) : _Base(std::forward< _UHead> (__head)) 
# 349
{ } 
# 351
constexpr _Tuple_impl(const std::_Tuple_impl< _Idx, _Head>  &) = default;
# 355
std::_Tuple_impl< _Idx, _Head>  &operator=(const std::_Tuple_impl< _Idx, _Head>  &) = delete;
# 358
constexpr _Tuple_impl(std::_Tuple_impl< _Idx, _Head>  &&__in) noexcept(is_nothrow_move_constructible< _Head> ::value) : _Base(std::forward< _Head> (_M_head(__in))) 
# 360
{ } 
# 362
template< class _UHead> constexpr 
# 363
_Tuple_impl(const std::_Tuple_impl< _Idx, _UHead>  &__in) : _Base(_Tuple_impl< _Idx, _UHead> ::_M_head(__in)) 
# 364
{ } 
# 366
template< class _UHead> constexpr 
# 367
_Tuple_impl(std::_Tuple_impl< _Idx, _UHead>  &&__in) : _Base(std::forward< _UHead> (_Tuple_impl< _Idx, _UHead> ::_M_head(__in))) 
# 369
{ } 
# 371
template< class _Alloc> 
# 372
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a) : _Base(__tag, __use_alloc< _Head> (__a)) 
# 373
{ } 
# 375
template< class _Alloc> 
# 376
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, const _Head &
# 377
__head) : _Base(__use_alloc< _Head, _Alloc, _Head> (__a), __head) 
# 378
{ } 
# 380
template< class _Alloc, class _UHead> 
# 381
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, _UHead &&
# 382
__head) : _Base(__use_alloc< _Head, _Alloc, _UHead> (__a), std::forward< _UHead> (__head)) 
# 384
{ } 
# 386
template< class _Alloc> 
# 387
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, const std::_Tuple_impl< _Idx, _Head>  &
# 388
__in) : _Base(__use_alloc< _Head, _Alloc, _Head> (__a), _M_head(__in)) 
# 389
{ } 
# 391
template< class _Alloc> 
# 392
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, std::_Tuple_impl< _Idx, _Head>  &&
# 393
__in) : _Base(__use_alloc< _Head, _Alloc, _Head> (__a), std::forward< _Head> (_M_head(__in))) 
# 395
{ } 
# 397
template< class _Alloc, class _UHead> 
# 398
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, const std::_Tuple_impl< _Idx, _UHead>  &
# 399
__in) : _Base(__use_alloc< _Head, _Alloc, const _UHead &> (__a), _Tuple_impl< _Idx, _UHead> ::_M_head(__in)) 
# 401
{ } 
# 403
template< class _Alloc, class _UHead> 
# 404
_Tuple_impl(std::allocator_arg_t __tag, const _Alloc &__a, std::_Tuple_impl< _Idx, _UHead>  &&
# 405
__in) : _Base(__use_alloc< _Head, _Alloc, _UHead> (__a), std::forward< _UHead> (_Tuple_impl< _Idx, _UHead> ::_M_head(__in))) 
# 408
{ } 
# 410
template< class _UHead> void 
# 412
_M_assign(const std::_Tuple_impl< _Idx, _UHead>  &__in) 
# 413
{ 
# 414
_M_head(*this) = _Tuple_impl< _Idx, _UHead> ::_M_head(__in); 
# 415
} 
# 417
template< class _UHead> void 
# 419
_M_assign(std::_Tuple_impl< _Idx, _UHead>  &&__in) 
# 420
{ 
# 421
_M_head(*this) = std::forward< _UHead> (_Tuple_impl< _Idx, _UHead> ::_M_head(__in)); 
# 423
} 
# 427
protected: void _M_swap(std::_Tuple_impl< _Idx, _Head>  &__in) 
# 428
{ 
# 429
using std::swap;
# 430
swap(_M_head(*this), _M_head(__in)); 
# 431
} 
# 432
}; 
# 436
template< bool , class ..._Elements> 
# 437
struct _TC { 
# 439
template< class ..._UElements> static constexpr bool 
# 440
_ConstructibleTuple() 
# 441
{ 
# 442
return __and_< is_constructible< _Elements, const _UElements &> ...> ::value; 
# 443
} 
# 445
template< class ..._UElements> static constexpr bool 
# 446
_ImplicitlyConvertibleTuple() 
# 447
{ 
# 448
return __and_< is_convertible< const _UElements &, _Elements> ...> ::value; 
# 449
} 
# 451
template< class ..._UElements> static constexpr bool 
# 452
_MoveConstructibleTuple() 
# 453
{ 
# 454
return __and_< is_constructible< _Elements, _UElements &&> ...> ::value; 
# 455
} 
# 457
template< class ..._UElements> static constexpr bool 
# 458
_ImplicitlyMoveConvertibleTuple() 
# 459
{ 
# 460
return __and_< is_convertible< _UElements &&, _Elements> ...> ::value; 
# 461
} 
# 463
template< class _SrcTuple> static constexpr bool 
# 464
_NonNestedTuple() 
# 465
{ 
# 466
return __and_< __not_< is_same< tuple< _Elements...> , __remove_cvref_t< _SrcTuple> > > , __not_< is_convertible< _SrcTuple, _Elements...> > , __not_< is_constructible< _Elements..., _SrcTuple> > > ::value; 
# 471
} 
# 473
template< class ..._UElements> static constexpr bool 
# 474
_NotSameTuple() 
# 475
{ 
# 476
return __not_< is_same< tuple< _Elements...> , __remove_cvref_t< _UElements> ...> > ::value; 
# 478
} 
# 479
}; 
# 481
template< class ..._Elements> 
# 482
struct _TC< false, _Elements...>  { 
# 484
template< class ..._UElements> static constexpr bool 
# 485
_ConstructibleTuple() 
# 486
{ 
# 487
return false; 
# 488
} 
# 490
template< class ..._UElements> static constexpr bool 
# 491
_ImplicitlyConvertibleTuple() 
# 492
{ 
# 493
return false; 
# 494
} 
# 496
template< class ..._UElements> static constexpr bool 
# 497
_MoveConstructibleTuple() 
# 498
{ 
# 499
return false; 
# 500
} 
# 502
template< class ..._UElements> static constexpr bool 
# 503
_ImplicitlyMoveConvertibleTuple() 
# 504
{ 
# 505
return false; 
# 506
} 
# 508
template< class ..._UElements> static constexpr bool 
# 509
_NonNestedTuple() 
# 510
{ 
# 511
return true; 
# 512
} 
# 514
template< class ..._UElements> static constexpr bool 
# 515
_NotSameTuple() 
# 516
{ 
# 517
return true; 
# 518
} 
# 519
}; 
# 522
template< class ..._Elements> 
# 523
class tuple : public _Tuple_impl< 0UL, _Elements...>  { 
# 525
typedef _Tuple_impl< 0UL, _Elements...>  _Inherited; 
# 529
template< class _Dummy> 
# 530
struct _TC2 { 
# 532
static constexpr bool _DefaultConstructibleTuple() 
# 533
{ 
# 534
return __and_< is_default_constructible< _Elements> ...> ::value; 
# 535
} 
# 536
static constexpr bool _ImplicitlyDefaultConstructibleTuple() 
# 537
{ 
# 538
return __and_< __is_implicitly_default_constructible< _Elements> ...> ::value; 
# 540
} 
# 541
}; 
# 543
template< class ..._UElements> static constexpr std::__enable_if_t< sizeof...(_UElements) == sizeof...(_Elements), bool>  
# 546
__assignable() 
# 547
{ return __and_< is_assignable< _Elements &, _UElements> ...> ::value; } 
# 549
template< class ..._UElements> static constexpr bool 
# 550
__nothrow_assignable() 
# 551
{ 
# 552
return __and_< is_nothrow_assignable< _Elements &, _UElements> ...> ::value; 
# 554
} 
# 561
public: 
# 557
template< class _Dummy = void, typename enable_if< _TC2< _Dummy> ::_ImplicitlyDefaultConstructibleTuple(), bool> ::type 
# 560
 = true> constexpr 
# 561
tuple() : _Inherited() 
# 562
{ } 
# 564
template< class _Dummy = void, typename enable_if< _TC2< _Dummy> ::_DefaultConstructibleTuple() && (!_TC2< _Dummy> ::_ImplicitlyDefaultConstructibleTuple()), bool> ::type 
# 570
 = false> constexpr explicit 
# 571
tuple() : _Inherited() 
# 572
{ } 
# 576
template< class _Dummy> using _TCC = _TC< is_same< _Dummy, void> ::value, _Elements...> ; 
# 580
template< class _Dummy = void, typename enable_if< _TC< is_same< _Dummy, void> ::value, _Elements...> ::template _ConstructibleTuple< _Elements...> () && _TC< is_same< _Dummy, void> ::value, _Elements...> ::template _ImplicitlyConvertibleTuple< _Elements...> () && (sizeof...(_Elements) >= (1)), bool> ::type 
# 587
 = true> constexpr 
# 588
tuple(const _Elements &...__elements) : _Inherited(__elements...) 
# 589
{ } 
# 591
template< class _Dummy = void, typename enable_if< _TC< is_same< _Dummy, void> ::value, _Elements...> ::template _ConstructibleTuple< _Elements...> () && (!_TC< is_same< _Dummy, void> ::value, _Elements...> ::template _ImplicitlyConvertibleTuple< _Elements...> ()) && (sizeof...(_Elements) >= (1)), bool> ::type 
# 598
 = false> constexpr explicit 
# 599
tuple(const _Elements &...__elements) : _Inherited(__elements...) 
# 600
{ } 
# 604
template< class ..._UElements> using _TMC = _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ; 
# 612
template< class ..._UElements> using _TMCT = _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple, tuple< _UElements...> > ::value), _Elements...> ; 
# 618
template< class ..._UElements, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ::template _MoveConstructibleTuple< _UElements...> () && _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ::template _ImplicitlyMoveConvertibleTuple< _UElements...> () && (sizeof...(_Elements) >= (1)), bool> ::type 
# 625
 = true> constexpr 
# 626
tuple(_UElements &&...__elements) : _Inherited(std::forward< _UElements> (__elements)...) 
# 627
{ } 
# 629
template< class ..._UElements, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ::template _MoveConstructibleTuple< _UElements...> () && (!_TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ::template _ImplicitlyMoveConvertibleTuple< _UElements...> ()) && (sizeof...(_Elements) >= (1)), bool> ::type 
# 636
 = false> constexpr explicit 
# 637
tuple(_UElements &&...__elements) : _Inherited(std::forward< _UElements> (__elements)...) 
# 638
{ } 
# 640
constexpr tuple(const tuple &) = default;
# 642
constexpr tuple(tuple &&) = default;
# 646
template< class _Dummy> using _TNTC = _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ; 
# 650
template< class ..._UElements, class _Dummy = void, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ConstructibleTuple< _UElements...> () && _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ImplicitlyConvertibleTuple< _UElements...> () && _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ::template _NonNestedTuple< const tuple< _UElements...>  &> (), bool> ::type 
# 657
 = true> constexpr 
# 658
tuple(const tuple< _UElements...>  &__in) : _Inherited(static_cast< const _Tuple_impl< 0, _UElements...>  &>(__in)) 
# 660
{ } 
# 662
template< class ..._UElements, class _Dummy = void, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ConstructibleTuple< _UElements...> () && (!_TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ImplicitlyConvertibleTuple< _UElements...> ()) && _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ::template _NonNestedTuple< const tuple< _UElements...>  &> (), bool> ::type 
# 669
 = false> constexpr explicit 
# 670
tuple(const tuple< _UElements...>  &__in) : _Inherited(static_cast< const _Tuple_impl< 0, _UElements...>  &>(__in)) 
# 672
{ } 
# 674
template< class ..._UElements, class _Dummy = void, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _MoveConstructibleTuple< _UElements...> () && _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ImplicitlyMoveConvertibleTuple< _UElements...> () && _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ::template _NonNestedTuple< tuple< _UElements...>  &&> (), bool> ::type 
# 681
 = true> constexpr 
# 682
tuple(tuple< _UElements...>  &&__in) : _Inherited(static_cast< _Tuple_impl< 0, _UElements...>  &&>(__in)) 
# 683
{ } 
# 685
template< class ..._UElements, class _Dummy = void, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _MoveConstructibleTuple< _UElements...> () && (!_TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ImplicitlyMoveConvertibleTuple< _UElements...> ()) && _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ::template _NonNestedTuple< tuple< _UElements...>  &&> (), bool> ::type 
# 692
 = false> constexpr explicit 
# 693
tuple(tuple< _UElements...>  &&__in) : _Inherited(static_cast< _Tuple_impl< 0, _UElements...>  &&>(__in)) 
# 694
{ } 
# 698
template< class _Alloc> 
# 699
tuple(std::allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a) 
# 700
{ } 
# 702
template< class _Alloc, class _Dummy = void, typename enable_if< _TC< is_same< _Dummy, void> ::value, _Elements...> ::template _ConstructibleTuple< _Elements...> () && _TC< is_same< _Dummy, void> ::value, _Elements...> ::template _ImplicitlyConvertibleTuple< _Elements...> (), bool> ::type 
# 708
 = true> 
# 709
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const _Elements &...
# 710
__elements) : _Inherited(__tag, __a, __elements...) 
# 711
{ } 
# 713
template< class _Alloc, class _Dummy = void, typename enable_if< _TC< is_same< _Dummy, void> ::value, _Elements...> ::template _ConstructibleTuple< _Elements...> () && (!_TC< is_same< _Dummy, void> ::value, _Elements...> ::template _ImplicitlyConvertibleTuple< _Elements...> ()), bool> ::type 
# 719
 = false> explicit 
# 720
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const _Elements &...
# 721
__elements) : _Inherited(__tag, __a, __elements...) 
# 722
{ } 
# 724
template< class _Alloc, class ..._UElements, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ::template _MoveConstructibleTuple< _UElements...> () && _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ::template _ImplicitlyMoveConvertibleTuple< _UElements...> (), bool> ::type 
# 729
 = true> 
# 730
tuple(std::allocator_arg_t __tag, const _Alloc &__a, _UElements &&...
# 731
__elements) : _Inherited(__tag, __a, std::forward< _UElements> (__elements)...) 
# 733
{ } 
# 735
template< class _Alloc, class ..._UElements, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ::template _MoveConstructibleTuple< _UElements...> () && (!_TC< (sizeof...(_Elements) == sizeof...(_UElements)) && _TC< sizeof...(_UElements) == (1), _Elements...> ::template _NotSameTuple< _UElements...> (), _Elements...> ::template _ImplicitlyMoveConvertibleTuple< _UElements...> ()), bool> ::type 
# 740
 = false> explicit 
# 741
tuple(std::allocator_arg_t __tag, const _Alloc &__a, _UElements &&...
# 742
__elements) : _Inherited(__tag, __a, std::forward< _UElements> (__elements)...) 
# 744
{ } 
# 746
template< class _Alloc> 
# 747
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const tuple &__in) : _Inherited(__tag, __a, static_cast< const _Inherited &>(__in)) 
# 748
{ } 
# 750
template< class _Alloc> 
# 751
tuple(std::allocator_arg_t __tag, const _Alloc &__a, tuple &&__in) : _Inherited(__tag, __a, static_cast< _Inherited &&>(__in)) 
# 752
{ } 
# 754
template< class _Alloc, class _Dummy = void, class ...
# 755
_UElements, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ConstructibleTuple< _UElements...> () && _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ImplicitlyConvertibleTuple< _UElements...> () && _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ::template _NonNestedTuple< const tuple< _UElements...>  &> (), bool> ::type 
# 762
 = true> 
# 763
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const tuple< _UElements...>  &
# 764
__in) : _Inherited(__tag, __a, static_cast< const _Tuple_impl< 0, _UElements...>  &>(__in)) 
# 767
{ } 
# 769
template< class _Alloc, class _Dummy = void, class ...
# 770
_UElements, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ConstructibleTuple< _UElements...> () && (!_TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ImplicitlyConvertibleTuple< _UElements...> ()) && _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ::template _NonNestedTuple< const tuple< _UElements...>  &> (), bool> ::type 
# 777
 = false> explicit 
# 778
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const tuple< _UElements...>  &
# 779
__in) : _Inherited(__tag, __a, static_cast< const _Tuple_impl< 0, _UElements...>  &>(__in)) 
# 782
{ } 
# 784
template< class _Alloc, class _Dummy = void, class ...
# 785
_UElements, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _MoveConstructibleTuple< _UElements...> () && _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ImplicitlyMoveConvertibleTuple< _UElements...> () && _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ::template _NonNestedTuple< tuple< _UElements...>  &&> (), bool> ::type 
# 792
 = true> 
# 793
tuple(std::allocator_arg_t __tag, const _Alloc &__a, tuple< _UElements...>  &&
# 794
__in) : _Inherited(__tag, __a, static_cast< _Tuple_impl< 0, _UElements...>  &&>(__in)) 
# 797
{ } 
# 799
template< class _Alloc, class _Dummy = void, class ...
# 800
_UElements, typename enable_if< _TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _MoveConstructibleTuple< _UElements...> () && (!_TC< (sizeof...(_Elements) == sizeof...(_UElements)) && (!is_same< tuple< _Elements...> , tuple< _UElements...> > ::value), _Elements...> ::template _ImplicitlyMoveConvertibleTuple< _UElements...> ()) && _TC< is_same< _Dummy, void> ::value && (sizeof...(_Elements) == (1)), _Elements...> ::template _NonNestedTuple< tuple< _UElements...>  &&> (), bool> ::type 
# 807
 = false> explicit 
# 808
tuple(std::allocator_arg_t __tag, const _Alloc &__a, tuple< _UElements...>  &&
# 809
__in) : _Inherited(__tag, __a, static_cast< _Tuple_impl< 0, _UElements...>  &&>(__in)) 
# 812
{ } 
# 817
tuple &operator=(typename conditional< __assignable< const _Elements &...> (), const tuple &, const std::__nonesuch_no_braces &> ::type 
# 819
__in) noexcept(__nothrow_assignable< const _Elements &...> ()) 
# 821
{ 
# 822
this->_M_assign(__in); 
# 823
return *this; 
# 824
} 
# 827
tuple &operator=(typename conditional< __assignable< _Elements...> (), tuple &&, std::__nonesuch_no_braces &&> ::type 
# 829
__in) noexcept(__nothrow_assignable< _Elements...> ()) 
# 831
{ 
# 832
this->_M_assign(std::move(__in)); 
# 833
return *this; 
# 834
} 
# 836
template< class ..._UElements> std::__enable_if_t< __assignable< const _UElements &...> (), tuple &>  
# 838
operator=(const tuple< _UElements...>  &__in) noexcept(__nothrow_assignable< const _UElements &...> ()) 
# 840
{ 
# 841
this->_M_assign(__in); 
# 842
return *this; 
# 843
} 
# 845
template< class ..._UElements> std::__enable_if_t< __assignable< _UElements...> (), tuple &>  
# 847
operator=(tuple< _UElements...>  &&__in) noexcept(__nothrow_assignable< _UElements...> ()) 
# 849
{ 
# 850
this->_M_assign(std::move(__in)); 
# 851
return *this; 
# 852
} 
# 856
void swap(tuple &__in) noexcept(__and_< __is_nothrow_swappable< _Elements> ...> ::value) 
# 858
{ _Inherited::_M_swap(__in); } 
# 859
}; 
# 876 "/usr/include/c++/9/tuple" 3
template<> class tuple< >  { 
# 879
public: void swap(std::tuple< >  &) noexcept { } 
# 882
tuple() = default;
# 884
template< class _Alloc> 
# 885
tuple(allocator_arg_t, const _Alloc &) { } 
# 886
template< class _Alloc> 
# 887
tuple(allocator_arg_t, const _Alloc &, const std::tuple< >  &) { } 
# 888
}; 
# 892
template< class _T1, class _T2> 
# 893
class tuple< _T1, _T2>  : public _Tuple_impl< 0UL, _T1, _T2>  { 
# 895
typedef _Tuple_impl< 0UL, _T1, _T2>  _Inherited; 
# 897
template< class _U1, class _U2> static constexpr bool 
# 898
__assignable() 
# 899
{ 
# 900
return __and_< is_assignable< _T1 &, _U1> , is_assignable< _T2 &, _U2> > ::value; 
# 902
} 
# 904
template< class _U1, class _U2> static constexpr bool 
# 905
__nothrow_assignable() 
# 906
{ 
# 907
return __and_< is_nothrow_assignable< _T1 &, _U1> , is_nothrow_assignable< _T2 &, _U2> > ::value; 
# 909
} 
# 918
public: 
# 912
template< class _U1 = _T1, class 
# 913
_U2 = _T2, typename enable_if< __and_< __is_implicitly_default_constructible< _U1> , __is_implicitly_default_constructible< _U2> > ::value, bool> ::type 
# 917
 = true> constexpr 
# 918
tuple() : _Inherited() 
# 919
{ } 
# 921
template< class _U1 = _T1, class 
# 922
_U2 = _T2, typename enable_if< __and_< is_default_constructible< _U1> , is_default_constructible< _U2> , __not_< __and_< __is_implicitly_default_constructible< _U1> , __is_implicitly_default_constructible< _U2> > > > ::value, bool> ::type 
# 930
 = false> constexpr explicit 
# 931
tuple() : _Inherited() 
# 932
{ } 
# 936
template< class _Dummy> using _TCC = _TC< is_same< _Dummy, void> ::value, _T1, _T2> ; 
# 939
template< class _Dummy = void, typename enable_if< _TC< is_same< _Dummy, void> ::value, _T1, _T2> ::template _ConstructibleTuple< _T1, _T2> () && _TC< is_same< _Dummy, void> ::value, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _T1, _T2> (), bool> ::type 
# 944
 = true> constexpr 
# 945
tuple(const _T1 &__a1, const _T2 &__a2) : _Inherited(__a1, __a2) 
# 946
{ } 
# 948
template< class _Dummy = void, typename enable_if< _TC< is_same< _Dummy, void> ::value, _T1, _T2> ::template _ConstructibleTuple< _T1, _T2> () && (!_TC< is_same< _Dummy, void> ::value, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _T1, _T2> ()), bool> ::type 
# 953
 = false> constexpr explicit 
# 954
tuple(const _T1 &__a1, const _T2 &__a2) : _Inherited(__a1, __a2) 
# 955
{ } 
# 959
using _TMC = _TC< true, _T1, _T2> ; 
# 961
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> () && (!is_same< std::__remove_cvref_t< _U1> , std::allocator_arg_t> ::value), bool> ::type 
# 967
 = true> constexpr 
# 968
tuple(_U1 &&__a1, _U2 &&__a2) : _Inherited(std::forward< _U1> (__a1), std::forward< _U2> (__a2)) 
# 969
{ } 
# 971
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> ()) && (!is_same< std::__remove_cvref_t< _U1> , std::allocator_arg_t> ::value), bool> ::type 
# 977
 = false> constexpr explicit 
# 978
tuple(_U1 &&__a1, _U2 &&__a2) : _Inherited(std::forward< _U1> (__a1), std::forward< _U2> (__a2)) 
# 979
{ } 
# 981
constexpr tuple(const std::tuple< _T1, _T2>  &) = default;
# 983
constexpr tuple(std::tuple< _T1, _T2>  &&) = default;
# 985
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _ConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _U1, _U2> (), bool> ::type 
# 990
 = true> constexpr 
# 991
tuple(const std::tuple< _U1, _U2>  &__in) : _Inherited(static_cast< const _Tuple_impl< 0, _U1, _U2>  &>(__in)) 
# 992
{ } 
# 994
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _ConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 999
 = false> constexpr explicit 
# 1000
tuple(const std::tuple< _U1, _U2>  &__in) : _Inherited(static_cast< const _Tuple_impl< 0, _U1, _U2>  &>(__in)) 
# 1001
{ } 
# 1003
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> (), bool> ::type 
# 1008
 = true> constexpr 
# 1009
tuple(std::tuple< _U1, _U2>  &&__in) : _Inherited(static_cast< _Tuple_impl< 0, _U1, _U2>  &&>(__in)) 
# 1010
{ } 
# 1012
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 1017
 = false> constexpr explicit 
# 1018
tuple(std::tuple< _U1, _U2>  &&__in) : _Inherited(static_cast< _Tuple_impl< 0, _U1, _U2>  &&>(__in)) 
# 1019
{ } 
# 1021
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _ConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _U1, _U2> (), bool> ::type 
# 1026
 = true> constexpr 
# 1027
tuple(const pair< _U1, _U2>  &__in) : _Inherited((__in.first), (__in.second)) 
# 1028
{ } 
# 1030
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _ConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 1035
 = false> constexpr explicit 
# 1036
tuple(const pair< _U1, _U2>  &__in) : _Inherited((__in.first), (__in.second)) 
# 1037
{ } 
# 1039
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> (), bool> ::type 
# 1044
 = true> constexpr 
# 1045
tuple(pair< _U1, _U2>  &&__in) : _Inherited(std::forward< _U1> ((__in.first)), std::forward< _U2> ((__in.second))) 
# 1047
{ } 
# 1049
template< class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 1054
 = false> constexpr explicit 
# 1055
tuple(pair< _U1, _U2>  &&__in) : _Inherited(std::forward< _U1> ((__in.first)), std::forward< _U2> ((__in.second))) 
# 1057
{ } 
# 1061
template< class _Alloc> 
# 1062
tuple(std::allocator_arg_t __tag, const _Alloc &__a) : _Inherited(__tag, __a) 
# 1063
{ } 
# 1065
template< class _Alloc, class _Dummy = void, typename enable_if< _TC< is_same< _Dummy, void> ::value, _T1, _T2> ::template _ConstructibleTuple< _T1, _T2> () && _TC< is_same< _Dummy, void> ::value, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _T1, _T2> (), bool> ::type 
# 1071
 = true> 
# 1073
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const _T1 &
# 1074
__a1, const _T2 &__a2) : _Inherited(__tag, __a, __a1, __a2) 
# 1075
{ } 
# 1077
template< class _Alloc, class _Dummy = void, typename enable_if< _TC< is_same< _Dummy, void> ::value, _T1, _T2> ::template _ConstructibleTuple< _T1, _T2> () && (!_TC< is_same< _Dummy, void> ::value, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _T1, _T2> ()), bool> ::type 
# 1083
 = false> explicit 
# 1085
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const _T1 &
# 1086
__a1, const _T2 &__a2) : _Inherited(__tag, __a, __a1, __a2) 
# 1087
{ } 
# 1089
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> (), bool> ::type 
# 1094
 = true> 
# 1095
tuple(std::allocator_arg_t __tag, const _Alloc &__a, _U1 &&__a1, _U2 &&__a2) : _Inherited(__tag, __a, std::forward< _U1> (__a1), std::forward< _U2> (__a2)) 
# 1097
{ } 
# 1099
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 1104
 = false> explicit 
# 1105
tuple(std::allocator_arg_t __tag, const _Alloc &__a, _U1 &&
# 1106
__a1, _U2 &&__a2) : _Inherited(__tag, __a, std::forward< _U1> (__a1), std::forward< _U2> (__a2)) 
# 1108
{ } 
# 1110
template< class _Alloc> 
# 1111
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const std::tuple< _T1, _T2>  &__in) : _Inherited(__tag, __a, static_cast< const _Inherited &>(__in)) 
# 1112
{ } 
# 1114
template< class _Alloc> 
# 1115
tuple(std::allocator_arg_t __tag, const _Alloc &__a, std::tuple< _T1, _T2>  &&__in) : _Inherited(__tag, __a, static_cast< _Inherited &&>(__in)) 
# 1116
{ } 
# 1118
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _ConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _U1, _U2> (), bool> ::type 
# 1123
 = true> 
# 1124
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const std::tuple< _U1, _U2>  &
# 1125
__in) : _Inherited(__tag, __a, static_cast< const _Tuple_impl< 0, _U1, _U2>  &>(__in)) 
# 1128
{ } 
# 1130
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _ConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 1135
 = false> explicit 
# 1136
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const std::tuple< _U1, _U2>  &
# 1137
__in) : _Inherited(__tag, __a, static_cast< const _Tuple_impl< 0, _U1, _U2>  &>(__in)) 
# 1140
{ } 
# 1142
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> (), bool> ::type 
# 1147
 = true> 
# 1148
tuple(std::allocator_arg_t __tag, const _Alloc &__a, std::tuple< _U1, _U2>  &&__in) : _Inherited(__tag, __a, static_cast< _Tuple_impl< 0, _U1, _U2>  &&>(__in)) 
# 1150
{ } 
# 1152
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 1157
 = false> explicit 
# 1158
tuple(std::allocator_arg_t __tag, const _Alloc &__a, std::tuple< _U1, _U2>  &&
# 1159
__in) : _Inherited(__tag, __a, static_cast< _Tuple_impl< 0, _U1, _U2>  &&>(__in)) 
# 1161
{ } 
# 1163
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _ConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _U1, _U2> (), bool> ::type 
# 1168
 = true> 
# 1169
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const pair< _U1, _U2>  &
# 1170
__in) : _Inherited(__tag, __a, (__in.first), (__in.second)) 
# 1171
{ } 
# 1173
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _ConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 1178
 = false> explicit 
# 1179
tuple(std::allocator_arg_t __tag, const _Alloc &__a, const pair< _U1, _U2>  &
# 1180
__in) : _Inherited(__tag, __a, (__in.first), (__in.second)) 
# 1181
{ } 
# 1183
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && _TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> (), bool> ::type 
# 1188
 = true> 
# 1189
tuple(std::allocator_arg_t __tag, const _Alloc &__a, pair< _U1, _U2>  &&__in) : _Inherited(__tag, __a, std::forward< _U1> ((__in.first)), std::forward< _U2> ((__in.second))) 
# 1191
{ } 
# 1193
template< class _Alloc, class _U1, class _U2, typename enable_if< _TC< true, _T1, _T2> ::template _MoveConstructibleTuple< _U1, _U2> () && (!_TC< true, _T1, _T2> ::template _ImplicitlyMoveConvertibleTuple< _U1, _U2> ()), bool> ::type 
# 1198
 = false> explicit 
# 1199
tuple(std::allocator_arg_t __tag, const _Alloc &__a, pair< _U1, _U2>  &&
# 1200
__in) : _Inherited(__tag, __a, std::forward< _U1> ((__in.first)), std::forward< _U2> ((__in.second))) 
# 1202
{ } 
# 1205
std::tuple< _T1, _T2>  &operator=(typename conditional< __assignable< const _T1 &, const _T2 &> (), const std::tuple< _T1, _T2>  &, const std::__nonesuch_no_braces &> ::type 
# 1207
__in) noexcept(__nothrow_assignable< const _T1 &, const _T2 &> ()) 
# 1209
{ 
# 1210
this->_M_assign(__in); 
# 1211
return *this; 
# 1212
} 
# 1215
std::tuple< _T1, _T2>  &operator=(typename conditional< __assignable< _T1, _T2> (), std::tuple< _T1, _T2>  &&, std::__nonesuch_no_braces &&> ::type 
# 1217
__in) noexcept(__nothrow_assignable< _T1, _T2> ()) 
# 1219
{ 
# 1220
this->_M_assign(std::move(__in)); 
# 1221
return *this; 
# 1222
} 
# 1224
template< class _U1, class _U2> std::__enable_if_t< __assignable< const _U1 &, const _U2 &> (), std::tuple< _T1, _T2>  &>  
# 1226
operator=(const std::tuple< _U1, _U2>  &__in) noexcept(__nothrow_assignable< const _U1 &, const _U2 &> ()) 
# 1228
{ 
# 1229
this->_M_assign(__in); 
# 1230
return *this; 
# 1231
} 
# 1233
template< class _U1, class _U2> std::__enable_if_t< __assignable< _U1, _U2> (), std::tuple< _T1, _T2>  &>  
# 1235
operator=(std::tuple< _U1, _U2>  &&__in) noexcept(__nothrow_assignable< _U1, _U2> ()) 
# 1237
{ 
# 1238
this->_M_assign(std::move(__in)); 
# 1239
return *this; 
# 1240
} 
# 1242
template< class _U1, class _U2> std::__enable_if_t< __assignable< const _U1 &, const _U2 &> (), std::tuple< _T1, _T2>  &>  
# 1244
operator=(const pair< _U1, _U2>  &__in) noexcept(__nothrow_assignable< const _U1 &, const _U2 &> ()) 
# 1246
{ 
# 1247
this->_M_head(*this) = (__in.first); 
# 1248
this->_M_tail(*this)._M_head(*this) = (__in.second); 
# 1249
return *this; 
# 1250
} 
# 1252
template< class _U1, class _U2> std::__enable_if_t< __assignable< _U1, _U2> (), std::tuple< _T1, _T2>  &>  
# 1254
operator=(pair< _U1, _U2>  &&__in) noexcept(__nothrow_assignable< _U1, _U2> ()) 
# 1256
{ 
# 1257
this->_M_head(*this) = std::forward< _U1> ((__in.first)); 
# 1258
this->_M_tail(*this)._M_head(*this) = std::forward< _U2> ((__in.second)); 
# 1259
return *this; 
# 1260
} 
# 1263
void swap(std::tuple< _T1, _T2>  &__in) noexcept(__and_< __is_nothrow_swappable< _T1> , __is_nothrow_swappable< _T2> > ::value) 
# 1266
{ _Inherited::_M_swap(__in); } 
# 1267
}; 
# 1271
template< class ..._Elements> 
# 1272
struct tuple_size< tuple< _Elements...> >  : public integral_constant< unsigned long, sizeof...(_Elements)>  { 
# 1273
}; 
# 1284 "/usr/include/c++/9/tuple" 3
template< size_t __i, class _Head, class ..._Tail> 
# 1285
struct tuple_element< __i, tuple< _Head, _Tail...> >  : public std::tuple_element< __i - (1), tuple< _Tail...> >  { 
# 1286
}; 
# 1291
template< class _Head, class ..._Tail> 
# 1292
struct tuple_element< 0, tuple< _Head, _Tail...> >  { 
# 1294
typedef _Head type; 
# 1295
}; 
# 1300
template< size_t __i> 
# 1301
struct tuple_element< __i, tuple< > >  { 
# 1303
static_assert((__i < integral_constant< size_t, 0UL> ::value), "tuple index is in range");
# 1305
}; 
# 1307
template< size_t __i, class _Head, class ..._Tail> constexpr _Head &
# 1309
__get_helper(_Tuple_impl< __i, _Head, _Tail...>  &__t) noexcept 
# 1310
{ return _Tuple_impl< __i, _Head, _Tail...> ::_M_head(__t); } 
# 1312
template< size_t __i, class _Head, class ..._Tail> constexpr const _Head &
# 1314
__get_helper(const _Tuple_impl< __i, _Head, _Tail...>  &__t) noexcept 
# 1315
{ return _Tuple_impl< __i, _Head, _Tail...> ::_M_head(__t); } 
# 1318
template< size_t __i, class ..._Elements> constexpr __tuple_element_t< __i, tuple< _Elements...> >  &
# 1320
get(tuple< _Elements...>  &__t) noexcept 
# 1321
{ return std::__get_helper< __i> (__t); } 
# 1324
template< size_t __i, class ..._Elements> constexpr const __tuple_element_t< __i, tuple< _Elements...> >  &
# 1326
get(const tuple< _Elements...>  &__t) noexcept 
# 1327
{ return std::__get_helper< __i> (__t); } 
# 1330
template< size_t __i, class ..._Elements> constexpr __tuple_element_t< __i, tuple< _Elements...> >  &&
# 1332
get(tuple< _Elements...>  &&__t) noexcept 
# 1333
{ 
# 1334
typedef __tuple_element_t< __i, tuple< _Elements...> >  __element_type; 
# 1335
return std::forward< __tuple_element_t< __i, tuple< _Elements...> >  &&> (std::get< __i> (__t)); 
# 1336
} 
# 1339
template< size_t __i, class ..._Elements> constexpr const __tuple_element_t< __i, tuple< _Elements...> >  &&
# 1341
get(const tuple< _Elements...>  &&__t) noexcept 
# 1342
{ 
# 1343
typedef __tuple_element_t< __i, tuple< _Elements...> >  __element_type; 
# 1344
return std::forward< const __tuple_element_t< __i, tuple< _Elements...> >  &&> (std::get< __i> (__t)); 
# 1345
} 
# 1351
template< class _Head, size_t __i, class ..._Tail> constexpr _Head &
# 1353
__get_helper2(_Tuple_impl< __i, _Head, _Tail...>  &__t) noexcept 
# 1354
{ return _Tuple_impl< __i, _Head, _Tail...> ::_M_head(__t); } 
# 1356
template< class _Head, size_t __i, class ..._Tail> constexpr const _Head &
# 1358
__get_helper2(const _Tuple_impl< __i, _Head, _Tail...>  &__t) noexcept 
# 1359
{ return _Tuple_impl< __i, _Head, _Tail...> ::_M_head(__t); } 
# 1362
template< class _Tp, class ..._Types> constexpr _Tp &
# 1364
get(tuple< _Types...>  &__t) noexcept 
# 1365
{ return std::__get_helper2< _Tp> (__t); } 
# 1368
template< class _Tp, class ..._Types> constexpr _Tp &&
# 1370
get(tuple< _Types...>  &&__t) noexcept 
# 1371
{ return std::forward< _Tp &&> (std::__get_helper2< _Tp> (__t)); } 
# 1374
template< class _Tp, class ..._Types> constexpr const _Tp &
# 1376
get(const tuple< _Types...>  &__t) noexcept 
# 1377
{ return std::__get_helper2< _Tp> (__t); } 
# 1381
template< class _Tp, class ..._Types> constexpr const _Tp &&
# 1383
get(const tuple< _Types...>  &&__t) noexcept 
# 1384
{ return std::forward< const _Tp &&> (std::__get_helper2< _Tp> (__t)); } 
# 1388
template< class _Tp, class _Up, size_t __i, size_t __size> 
# 1389
struct __tuple_compare { 
# 1392
static constexpr bool __eq(const _Tp &__t, const _Up &__u) 
# 1393
{ 
# 1394
return ((bool)(std::get< __i> (__t) == std::get< __i> (__u))) && __tuple_compare< _Tp, _Up, __i + (1), __size> ::__eq(__t, __u); 
# 1396
} 
# 1399
static constexpr bool __less(const _Tp &__t, const _Up &__u) 
# 1400
{ 
# 1401
return ((bool)(std::get< __i> (__t) < std::get< __i> (__u))) || ((!((bool)(std::get< __i> (__u) < std::get< __i> (__t)))) && __tuple_compare< _Tp, _Up, __i + (1), __size> ::__less(__t, __u)); 
# 1404
} 
# 1405
}; 
# 1407
template< class _Tp, class _Up, size_t __size> 
# 1408
struct __tuple_compare< _Tp, _Up, __size, __size>  { 
# 1411
static constexpr bool __eq(const _Tp &, const _Up &) { return true; } 
# 1414
static constexpr bool __less(const _Tp &, const _Up &) { return false; } 
# 1415
}; 
# 1417
template< class ..._TElements, class ..._UElements> constexpr bool 
# 1419
operator==(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 1420
__u) 
# 1421
{ 
# 1422
static_assert((sizeof...(_TElements) == sizeof...(_UElements)), "tuple objects can only be compared if they have equal sizes.");
# 1424
using __compare = __tuple_compare< tuple< _TElements...> , tuple< _UElements...> , 0, sizeof...(_TElements)> ; 
# 1427
return __compare::__eq(__t, __u); 
# 1428
} 
# 1430
template< class ..._TElements, class ..._UElements> constexpr bool 
# 1432
operator<(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 1433
__u) 
# 1434
{ 
# 1435
static_assert((sizeof...(_TElements) == sizeof...(_UElements)), "tuple objects can only be compared if they have equal sizes.");
# 1437
using __compare = __tuple_compare< tuple< _TElements...> , tuple< _UElements...> , 0, sizeof...(_TElements)> ; 
# 1440
return __compare::__less(__t, __u); 
# 1441
} 
# 1443
template< class ..._TElements, class ..._UElements> constexpr bool 
# 1445
operator!=(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 1446
__u) 
# 1447
{ return !(__t == __u); } 
# 1449
template< class ..._TElements, class ..._UElements> constexpr bool 
# 1451
operator>(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 1452
__u) 
# 1453
{ return __u < __t; } 
# 1455
template< class ..._TElements, class ..._UElements> constexpr bool 
# 1457
operator<=(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 1458
__u) 
# 1459
{ return !(__u < __t); } 
# 1461
template< class ..._TElements, class ..._UElements> constexpr bool 
# 1463
operator>=(const tuple< _TElements...>  &__t, const tuple< _UElements...>  &
# 1464
__u) 
# 1465
{ return !(__t < __u); } 
# 1468
template< class ..._Elements> constexpr tuple< typename __decay_and_strip< _Elements> ::__type...>  
# 1470
make_tuple(_Elements &&...__args) 
# 1471
{ 
# 1473
typedef tuple< typename __decay_and_strip< _Elements> ::__type...>  __result_type; 
# 1474
return __result_type(std::forward< _Elements> (__args)...); 
# 1475
} 
# 1480
template< class ..._Elements> constexpr tuple< _Elements &&...>  
# 1482
forward_as_tuple(_Elements &&...__args) noexcept 
# 1483
{ return tuple< _Elements &&...> (std::forward< _Elements> (__args)...); } 
# 1485
template< size_t , class , class , size_t > struct __make_tuple_impl; 
# 1488
template< size_t _Idx, class _Tuple, class ..._Tp, size_t _Nm> 
# 1489
struct __make_tuple_impl< _Idx, tuple< _Tp...> , _Tuple, _Nm>  : public std::__make_tuple_impl< _Idx + (1), tuple< _Tp..., __tuple_element_t< _Idx, _Tuple> > , _Tuple, _Nm>  { 
# 1493
}; 
# 1495
template< size_t _Nm, class _Tuple, class ..._Tp> 
# 1496
struct __make_tuple_impl< _Nm, tuple< _Tp...> , _Tuple, _Nm>  { 
# 1498
typedef tuple< _Tp...>  __type; 
# 1499
}; 
# 1501
template< class _Tuple> 
# 1502
struct __do_make_tuple : public __make_tuple_impl< 0UL, tuple< > , _Tuple, tuple_size< _Tuple> ::value>  { 
# 1504
}; 
# 1507
template< class _Tuple> 
# 1508
struct __make_tuple : public __do_make_tuple< __remove_cvref_t< _Tuple> >  { 
# 1510
}; 
# 1513
template< class ...> struct __combine_tuples; 
# 1517
template<> struct __combine_tuples< >  { 
# 1519
typedef tuple< >  __type; 
# 1520
}; 
# 1522
template< class ..._Ts> 
# 1523
struct __combine_tuples< tuple< _Ts...> >  { 
# 1525
typedef tuple< _Ts...>  __type; 
# 1526
}; 
# 1528
template< class ..._T1s, class ..._T2s, class ..._Rem> 
# 1529
struct __combine_tuples< tuple< _T1s...> , tuple< _T2s...> , _Rem...>  { 
# 1532
typedef typename std::__combine_tuples< tuple< _T1s..., _T2s...> , _Rem...> ::__type __type; 
# 1533
}; 
# 1536
template< class ..._Tpls> 
# 1537
struct __tuple_cat_result { 
# 1540
typedef typename __combine_tuples< typename __make_tuple< _Tpls> ::__type...> ::__type __type; 
# 1541
}; 
# 1545
template< class ...> struct __make_1st_indices; 
# 1549
template<> struct __make_1st_indices< >  { 
# 1551
typedef _Index_tuple< >  __type; 
# 1552
}; 
# 1554
template< class _Tp, class ..._Tpls> 
# 1555
struct __make_1st_indices< _Tp, _Tpls...>  { 
# 1558
typedef typename _Build_index_tuple< tuple_size< typename remove_reference< _Tp> ::type> ::value> ::__type __type; 
# 1559
}; 
# 1564
template< class _Ret, class _Indices, class ..._Tpls> struct __tuple_concater; 
# 1567
template< class _Ret, size_t ..._Is, class _Tp, class ..._Tpls> 
# 1568
struct __tuple_concater< _Ret, _Index_tuple< _Is...> , _Tp, _Tpls...>  { 
# 1570
template< class ..._Us> static constexpr _Ret 
# 1572
_S_do(_Tp &&__tp, _Tpls &&...__tps, _Us &&...__us) 
# 1573
{ 
# 1574
typedef typename __make_1st_indices< _Tpls...> ::__type __idx; 
# 1575
typedef std::__tuple_concater< _Ret, typename __make_1st_indices< _Tpls...> ::__type, _Tpls...>  __next; 
# 1576
return __next::_S_do(std::forward< _Tpls> (__tps)..., std::forward< _Us> (__us)..., std::get< _Is> (std::forward< _Tp> (__tp))...); 
# 1579
} 
# 1580
}; 
# 1582
template< class _Ret> 
# 1583
struct __tuple_concater< _Ret, _Index_tuple< > >  { 
# 1585
template< class ..._Us> static constexpr _Ret 
# 1587
_S_do(_Us &&...__us) 
# 1588
{ 
# 1589
return _Ret(std::forward< _Us> (__us)...); 
# 1590
} 
# 1591
}; 
# 1594
template< class ..._Tpls, class  = typename enable_if< __and_< __is_tuple_like< _Tpls> ...> ::value> ::type> constexpr auto 
# 1597
tuple_cat(_Tpls &&...__tpls)->typename __tuple_cat_result< _Tpls...> ::__type 
# 1599
{ 
# 1600
typedef typename __tuple_cat_result< _Tpls...> ::__type __ret; 
# 1601
typedef typename __make_1st_indices< _Tpls...> ::__type __idx; 
# 1602
typedef __tuple_concater< typename __tuple_cat_result< _Tpls...> ::__type, typename __make_1st_indices< _Tpls...> ::__type, _Tpls...>  __concater; 
# 1603
return __concater::_S_do(std::forward< _Tpls> (__tpls)...); 
# 1604
} 
# 1609
template< class ..._Elements> constexpr tuple< _Elements &...>  
# 1611
tie(_Elements &...__args) noexcept 
# 1612
{ return tuple< _Elements &...> (__args...); } 
# 1615
template< class ..._Elements> inline typename enable_if< __and_< __is_swappable< _Elements> ...> ::value> ::type 
# 1624
swap(tuple< _Elements...>  &__x, tuple< _Elements...>  &__y) noexcept(noexcept(__x.swap(__y))) 
# 1626
{ __x.swap(__y); } 
# 1629
template < typename ... _Elements >
    typename enable_if < ! __and_ < __is_swappable < _Elements > ... > :: value > :: type
    swap ( tuple < _Elements ... > &, tuple < _Elements ... > & ) = delete;
# 1638
struct _Swallow_assign { 
# 1640
template< class _Tp> constexpr const _Swallow_assign &
# 1642
operator=(const _Tp &) const 
# 1643
{ return *this; } 
# 1644
}; 
# 1648
constexpr _Swallow_assign ignore{}; 
# 1651
template< class ..._Types, class _Alloc> 
# 1652
struct uses_allocator< tuple< _Types...> , _Alloc>  : public true_type { }; 
# 1655
template< class _T1, class _T2> 
# 1656
template< class ..._Args1, class ..._Args2> inline 
# 1659
pair< _T1, _T2> ::pair(std::piecewise_construct_t, tuple< _Args1...>  
# 1660
__first, tuple< _Args2...>  __second) : pair(__first, __second, typename _Build_index_tuple< sizeof...(_Args1)> ::__type(), typename _Build_index_tuple< sizeof...(_Args2)> ::__type()) 
# 1664
{ } 
# 1666
template< class _T1, class _T2> 
# 1667
template< class ..._Args1, size_t ..._Indexes1, class ...
# 1668
_Args2, size_t ..._Indexes2> inline 
# 1671
pair< _T1, _T2> ::pair(tuple< _Args1...>  &__tuple1, tuple< _Args2...>  &__tuple2, _Index_tuple< _Indexes1...> , _Index_tuple< _Indexes2...> ) : first(std::forward< _Args1> (std::get< _Indexes1> (__tuple1))...), second(std::forward< _Args2> (std::get< _Indexes2> (__tuple2))...) 
# 1675
{ } 
# 1719 "/usr/include/c++/9/tuple" 3
}
# 41 "/usr/include/c++/9/bits/unique_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 51
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template< class > class auto_ptr; 
#pragma GCC diagnostic pop
# 58
template< class _Tp> 
# 59
struct default_delete { 
# 62
constexpr default_delete() noexcept = default;
# 69
template< class _Up, class  = typename enable_if< is_convertible< _Up *, _Tp *> ::value> ::type> 
# 71
default_delete(const default_delete< _Up>  &) noexcept { } 
# 75
void operator()(_Tp *__ptr) const 
# 76
{ 
# 77
static_assert((!is_void< _Tp> ::value), "can\'t delete pointer to incomplete type");
# 79
static_assert((sizeof(_Tp) > (0)), "can\'t delete pointer to incomplete type");
# 81
delete __ptr; 
# 82
} 
# 83
}; 
# 88
template< class _Tp> 
# 89
struct default_delete< _Tp []>  { 
# 93
constexpr default_delete() noexcept = default;
# 104 "/usr/include/c++/9/bits/unique_ptr.h" 3
template< class _Up, class  = typename enable_if< is_convertible< _Up (*)[], _Tp (*)[]> ::value> ::type> 
# 106
default_delete(const std::default_delete< _Up []>  &) noexcept { } 
# 109
template< class _Up> typename enable_if< is_convertible< _Up (*)[], _Tp (*)[]> ::value> ::type 
# 111
operator()(_Up *__ptr) const 
# 112
{ 
# 113
static_assert((sizeof(_Tp) > (0)), "can\'t delete pointer to incomplete type");
# 115
delete [] __ptr; 
# 116
} 
# 117
}; 
# 119
template< class _Tp, class _Dp> 
# 120
class __uniq_ptr_impl { 
# 122
template< class _Up, class _Ep, class  = void> 
# 123
struct _Ptr { 
# 125
using type = _Up *; 
# 126
}; 
# 128
template< class _Up, class _Ep> 
# 130
struct _Ptr< _Up, _Ep, __void_t< typename remove_reference< _Ep> ::type::pointer> >  { 
# 132
using type = typename remove_reference< _Ep> ::type::pointer; 
# 133
}; 
# 136
public: using _DeleterConstraint = enable_if< __and_< __not_< is_pointer< _Dp> > , is_default_constructible< _Dp> > ::value> ; 
# 140
using pointer = typename _Ptr< _Tp, _Dp> ::type; 
# 142
static_assert((!is_rvalue_reference< _Dp> ::value), "unique_ptr\'s deleter type must be a function object type or an lvalue reference type");
# 146
__uniq_ptr_impl() = default;
# 147
__uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; } 
# 149
template< class _Del> 
# 150
__uniq_ptr_impl(pointer __p, _Del &&__d) : _M_t(__p, std::forward< _Del> (__d)) 
# 151
{ } 
# 153
pointer &_M_ptr() { return std::get< 0> (_M_t); } 
# 154
pointer _M_ptr() const { return std::get< 0> (_M_t); } 
# 155
_Dp &_M_deleter() { return std::get< 1> (_M_t); } 
# 156
const _Dp &_M_deleter() const { return std::get< 1> (_M_t); } 
# 159
void swap(__uniq_ptr_impl &__rhs) noexcept 
# 160
{ 
# 161
using std::swap;
# 162
swap(_M_ptr(), __rhs._M_ptr()); 
# 163
swap(_M_deleter(), __rhs._M_deleter()); 
# 164
} 
# 167
private: tuple< pointer, _Dp>  _M_t; 
# 168
}; 
# 171
template< class _Tp, class _Dp = default_delete< _Tp> > 
# 172
class unique_ptr { 
# 174
template< class _Up> using _DeleterConstraint = typename __uniq_ptr_impl< _Tp, _Up> ::_DeleterConstraint::type; 
# 178
__uniq_ptr_impl< _Tp, _Dp>  _M_t; 
# 181
public: using pointer = typename __uniq_ptr_impl< _Tp, _Dp> ::pointer; 
# 182
using element_type = _Tp; 
# 183
using deleter_type = _Dp; 
# 189
private: 
# 188
template< class _Up, class _Ep> using __safe_conversion_up = __and_< is_convertible< typename unique_ptr< _Up, _Ep> ::pointer, pointer> , __not_< is_array< _Up> > > ; 
# 199
public: 
# 198
template< class _Del = _Dp, class  = _DeleterConstraint< _Del> > constexpr 
# 199
unique_ptr() noexcept : _M_t() 
# 201
{ } 
# 209
template< class _Del = _Dp, class  = _DeleterConstraint< _Del> > explicit 
# 211
unique_ptr(pointer __p) noexcept : _M_t(__p) 
# 213
{ } 
# 222 "/usr/include/c++/9/bits/unique_ptr.h" 3
template< class _Del = deleter_type, class 
# 223
 = _Require< is_copy_constructible< _Del> > > 
# 224
unique_ptr(pointer __p, const deleter_type &__d) noexcept : _M_t(__p, __d) 
# 225
{ } 
# 234 "/usr/include/c++/9/bits/unique_ptr.h" 3
template< class _Del = deleter_type, class 
# 235
 = _Require< is_move_constructible< _Del> > > 
# 236
unique_ptr(pointer __p, __enable_if_t< !is_lvalue_reference< _Del> ::value, _Del &&>  
# 238
__d) noexcept : _M_t(__p, std::move(__d)) 
# 240
{ } 
# 242
template < typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference < _Del > :: type >
 unique_ptr ( pointer,
     __enable_if_t < is_lvalue_reference < _Del > :: value,
     _DelUnref && > ) = delete;
# 249
template< class _Del = _Dp, class  = _DeleterConstraint< _Del> > constexpr 
# 250
unique_ptr(nullptr_t) noexcept : _M_t() 
# 252
{ } 
# 257
unique_ptr(unique_ptr &&__u) noexcept : _M_t(__u.release(), std::forward< deleter_type> (__u.get_deleter())) 
# 258
{ } 
# 266
template< class _Up, class _Ep, class  = _Require< __safe_conversion_up< _Up, _Ep> , typename conditional< is_reference< _Dp> ::value, is_same< _Ep, _Dp> , is_convertible< _Ep, _Dp> > ::type> > 
# 271
unique_ptr(unique_ptr< _Up, _Ep>  &&__u) noexcept : _M_t(__u.release(), std::forward< _Ep> (__u.get_deleter())) 
# 273
{ } 
# 276
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 279
template< class _Up, class  = _Require< is_convertible< _Up *, _Tp *> , is_same< _Dp, default_delete< _Tp> > > > inline unique_ptr(auto_ptr< _Up>  && __u) noexcept; 
# 282
#pragma GCC diagnostic pop
# 286
~unique_ptr() noexcept 
# 287
{ 
# 288
static_assert((__is_invocable< deleter_type &, pointer> ::value), "unique_ptr\'s deleter must be invocable with a pointer");
# 290
auto &__ptr = (_M_t)._M_ptr(); 
# 291
if (__ptr != nullptr) { 
# 292
get_deleter()(std::move(__ptr)); }  
# 293
__ptr = pointer(); 
# 294
} 
# 305 "/usr/include/c++/9/bits/unique_ptr.h" 3
unique_ptr &operator=(unique_ptr &&__u) noexcept 
# 306
{ 
# 307
reset(__u.release()); 
# 308
get_deleter() = std::forward< deleter_type> (__u.get_deleter()); 
# 309
return *this; 
# 310
} 
# 319 "/usr/include/c++/9/bits/unique_ptr.h" 3
template< class _Up, class _Ep> typename enable_if< __and_< __safe_conversion_up< _Up, _Ep> , is_assignable< deleter_type &, _Ep &&> > ::value, unique_ptr &> ::type 
# 325
operator=(unique_ptr< _Up, _Ep>  &&__u) noexcept 
# 326
{ 
# 327
reset(__u.release()); 
# 328
get_deleter() = std::forward< _Ep> (__u.get_deleter()); 
# 329
return *this; 
# 330
} 
# 334
unique_ptr &operator=(nullptr_t) noexcept 
# 335
{ 
# 336
reset(); 
# 337
return *this; 
# 338
} 
# 344
typename add_lvalue_reference< element_type> ::type operator*() const 
# 345
{ 
# 346
; 
# 347
return *get(); 
# 348
} 
# 352
pointer operator->() const noexcept 
# 353
{ 
# 354
; 
# 355
return get(); 
# 356
} 
# 360
pointer get() const noexcept 
# 361
{ return (_M_t)._M_ptr(); } 
# 365
deleter_type &get_deleter() noexcept 
# 366
{ return (_M_t)._M_deleter(); } 
# 370
const deleter_type &get_deleter() const noexcept 
# 371
{ return (_M_t)._M_deleter(); } 
# 374
explicit operator bool() const noexcept 
# 375
{ return (get() == pointer()) ? false : true; } 
# 381
pointer release() noexcept 
# 382
{ 
# 383
pointer __p = get(); 
# 384
(_M_t)._M_ptr() = pointer(); 
# 385
return __p; 
# 386
} 
# 395
void reset(pointer __p = pointer()) noexcept 
# 396
{ 
# 397
static_assert((__is_invocable< deleter_type &, pointer> ::value), "unique_ptr\'s deleter must be invocable with a pointer");
# 399
using std::swap;
# 400
swap((_M_t)._M_ptr(), __p); 
# 401
if (__p != pointer()) { 
# 402
get_deleter()(std::move(__p)); }  
# 403
} 
# 407
void swap(unique_ptr &__u) noexcept 
# 408
{ 
# 409
static_assert((__is_swappable< _Dp> ::value), "deleter must be swappable");
# 410
(_M_t).swap(__u._M_t); 
# 411
} 
# 414
unique_ptr(const unique_ptr &) = delete;
# 415
unique_ptr &operator=(const unique_ptr &) = delete;
# 416
}; 
# 422
template< class _Tp, class _Dp> 
# 423
class unique_ptr< _Tp [], _Dp>  { 
# 425
template< class _Up> using _DeleterConstraint = typename __uniq_ptr_impl< _Tp, _Up> ::_DeleterConstraint::type; 
# 429
__uniq_ptr_impl< _Tp, _Dp>  _M_t; 
# 431
template< class _Up> using __remove_cv = typename remove_cv< _Up> ::type; 
# 435
template< class _Up> using __is_derived_Tp = __and_< is_base_of< _Tp, _Up> , __not_< is_same< __remove_cv< _Tp> , __remove_cv< _Up> > > > ; 
# 441
public: using pointer = typename __uniq_ptr_impl< _Tp, _Dp> ::pointer; 
# 442
using element_type = _Tp; 
# 443
using deleter_type = _Dp; 
# 447
template< class _Up, class _Ep, class 
# 448
_UPtr = std::unique_ptr< _Up, _Ep> , class 
# 449
_UP_pointer = typename _UPtr::pointer, class 
# 450
_UP_element_type = typename _UPtr::element_type> using __safe_conversion_up = __and_< is_array< _Up> , is_same< pointer, element_type *> , is_same< _UP_pointer, _UP_element_type *> , is_convertible< _UP_element_type (*)[], element_type (*)[]> > ; 
# 459
template< class _Up> using __safe_conversion_raw = __and_< __or_< __or_< is_same< _Up, pointer> , is_same< _Up, nullptr_t> > , __and_< is_pointer< _Up> , is_same< pointer, element_type *> , is_convertible< typename remove_pointer< _Up> ::type (*)[], element_type (*)[]> > > > ; 
# 475
template< class _Del = _Dp, class  = _DeleterConstraint< _Del> > constexpr 
# 476
unique_ptr() noexcept : _M_t() 
# 478
{ } 
# 487 "/usr/include/c++/9/bits/unique_ptr.h" 3
template< class _Up, class 
# 488
_Vp = _Dp, class 
# 489
 = _DeleterConstraint< _Vp> , class 
# 490
 = typename enable_if< __safe_conversion_raw< _Up> ::value, bool> ::type> explicit 
# 493
unique_ptr(_Up __p) noexcept : _M_t(__p) 
# 495
{ } 
# 505 "/usr/include/c++/9/bits/unique_ptr.h" 3
template< class _Up, class _Del = deleter_type, class 
# 506
 = _Require< __safe_conversion_raw< _Up> , is_copy_constructible< _Del> > > 
# 508
unique_ptr(_Up __p, const deleter_type &__d) noexcept : _M_t(__p, __d) 
# 509
{ } 
# 519 "/usr/include/c++/9/bits/unique_ptr.h" 3
template< class _Up, class _Del = deleter_type, class 
# 520
 = _Require< __safe_conversion_raw< _Up> , is_move_constructible< _Del> > > 
# 522
unique_ptr(_Up __p, __enable_if_t< !is_lvalue_reference< _Del> ::value, _Del &&>  
# 524
__d) noexcept : _M_t(std::move(__p), std::move(__d)) 
# 526
{ } 
# 528
template < typename _Up, typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference < _Del > :: type,
        typename = _Require < __safe_conversion_raw < _Up > > >
 unique_ptr ( _Up,
     __enable_if_t < is_lvalue_reference < _Del > :: value,
     _DelUnref && > ) = delete;
# 536
unique_ptr(std::unique_ptr< _Tp [], _Dp>  &&__u) noexcept : _M_t(__u.release(), std::forward< deleter_type> (__u.get_deleter())) 
# 537
{ } 
# 540
template< class _Del = _Dp, class  = _DeleterConstraint< _Del> > constexpr 
# 541
unique_ptr(nullptr_t) noexcept : _M_t() 
# 543
{ } 
# 545
template< class _Up, class _Ep, class  = _Require< __safe_conversion_up< _Up, _Ep> , typename conditional< is_reference< _Dp> ::value, is_same< _Ep, _Dp> , is_convertible< _Ep, _Dp> > ::type> > 
# 550
unique_ptr(std::unique_ptr< _Up, _Ep>  &&__u) noexcept : _M_t(__u.release(), std::forward< _Ep> (__u.get_deleter())) 
# 552
{ } 
# 555
~unique_ptr() 
# 556
{ 
# 557
auto &__ptr = (_M_t)._M_ptr(); 
# 558
if (__ptr != nullptr) { 
# 559
get_deleter()(__ptr); }  
# 560
__ptr = pointer(); 
# 561
} 
# 572 "/usr/include/c++/9/bits/unique_ptr.h" 3
std::unique_ptr< _Tp [], _Dp>  &operator=(std::unique_ptr< _Tp [], _Dp>  &&__u) noexcept 
# 573
{ 
# 574
reset(__u.release()); 
# 575
get_deleter() = std::forward< deleter_type> (__u.get_deleter()); 
# 576
return *this; 
# 577
} 
# 586 "/usr/include/c++/9/bits/unique_ptr.h" 3
template< class _Up, class _Ep> typename enable_if< __and_< __safe_conversion_up< _Up, _Ep> , is_assignable< deleter_type &, _Ep &&> > ::value, std::unique_ptr< _Tp [], _Dp>  &> ::type 
# 592
operator=(std::unique_ptr< _Up, _Ep>  &&__u) noexcept 
# 593
{ 
# 594
reset(__u.release()); 
# 595
get_deleter() = std::forward< _Ep> (__u.get_deleter()); 
# 596
return *this; 
# 597
} 
# 601
std::unique_ptr< _Tp [], _Dp>  &operator=(nullptr_t) noexcept 
# 602
{ 
# 603
reset(); 
# 604
return *this; 
# 605
} 
# 611
typename add_lvalue_reference< element_type> ::type operator[](size_t __i) const 
# 612
{ 
# 613
; 
# 614
return get()[__i]; 
# 615
} 
# 619
pointer get() const noexcept 
# 620
{ return (_M_t)._M_ptr(); } 
# 624
deleter_type &get_deleter() noexcept 
# 625
{ return (_M_t)._M_deleter(); } 
# 629
const deleter_type &get_deleter() const noexcept 
# 630
{ return (_M_t)._M_deleter(); } 
# 633
explicit operator bool() const noexcept 
# 634
{ return (get() == pointer()) ? false : true; } 
# 640
pointer release() noexcept 
# 641
{ 
# 642
pointer __p = get(); 
# 643
(_M_t)._M_ptr() = pointer(); 
# 644
return __p; 
# 645
} 
# 653
template< class _Up, class 
# 654
 = _Require< __or_< is_same< _Up, pointer> , __and_< is_same< pointer, element_type *> , is_pointer< _Up> , is_convertible< typename remove_pointer< _Up> ::type (*)[], element_type (*)[]> > > > > void 
# 666
reset(_Up __p) noexcept 
# 667
{ 
# 668
pointer __ptr = __p; 
# 669
using std::swap;
# 670
swap((_M_t)._M_ptr(), __ptr); 
# 671
if (__ptr != nullptr) { 
# 672
get_deleter()(__ptr); }  
# 673
} 
# 675
void reset(nullptr_t = nullptr) noexcept 
# 676
{ 
# 677
reset(pointer()); 
# 678
} 
# 682
void swap(std::unique_ptr< _Tp [], _Dp>  &__u) noexcept 
# 683
{ 
# 684
static_assert((__is_swappable< _Dp> ::value), "deleter must be swappable");
# 685
(_M_t).swap(__u._M_t); 
# 686
} 
# 689
unique_ptr(const std::unique_ptr< _Tp [], _Dp>  &) = delete;
# 690
std::unique_ptr< _Tp [], _Dp>  &operator=(const std::unique_ptr< _Tp [], _Dp>  &) = delete;
# 691
}; 
# 693
template< class _Tp, class _Dp> inline typename enable_if< __is_swappable< _Dp> ::value> ::type 
# 701
swap(unique_ptr< _Tp, _Dp>  &__x, unique_ptr< _Tp, _Dp>  &
# 702
__y) noexcept 
# 703
{ __x.swap(__y); } 
# 706
template < typename _Tp, typename _Dp >
    typename enable_if < ! __is_swappable < _Dp > :: value > :: type
    swap ( unique_ptr < _Tp, _Dp > &,
  unique_ptr < _Tp, _Dp > & ) = delete;
# 712
template< class _Tp, class _Dp, class 
# 713
_Up, class _Ep> inline bool 
# 715
operator==(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 716
__y) 
# 717
{ return __x.get() == __y.get(); } 
# 719
template< class _Tp, class _Dp> inline bool 
# 721
operator==(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) noexcept 
# 722
{ return !__x; } 
# 724
template< class _Tp, class _Dp> inline bool 
# 726
operator==(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) noexcept 
# 727
{ return !__x; } 
# 729
template< class _Tp, class _Dp, class 
# 730
_Up, class _Ep> inline bool 
# 732
operator!=(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 733
__y) 
# 734
{ return __x.get() != __y.get(); } 
# 736
template< class _Tp, class _Dp> inline bool 
# 738
operator!=(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) noexcept 
# 739
{ return (bool)__x; } 
# 741
template< class _Tp, class _Dp> inline bool 
# 743
operator!=(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) noexcept 
# 744
{ return (bool)__x; } 
# 746
template< class _Tp, class _Dp, class 
# 747
_Up, class _Ep> inline bool 
# 749
operator<(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 750
__y) 
# 751
{ 
# 754
typedef typename common_type< typename unique_ptr< _Tp, _Dp> ::pointer, typename unique_ptr< _Up, _Ep> ::pointer> ::type _CT; 
# 755
return less< typename common_type< typename unique_ptr< _Tp, _Dp> ::pointer, typename unique_ptr< _Up, _Ep> ::pointer> ::type> ()(__x.get(), __y.get()); 
# 756
} 
# 758
template< class _Tp, class _Dp> inline bool 
# 760
operator<(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) 
# 761
{ return less< typename unique_ptr< _Tp, _Dp> ::pointer> ()(__x.get(), nullptr); 
# 762
} 
# 764
template< class _Tp, class _Dp> inline bool 
# 766
operator<(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) 
# 767
{ return less< typename unique_ptr< _Tp, _Dp> ::pointer> ()(nullptr, __x.get()); 
# 768
} 
# 770
template< class _Tp, class _Dp, class 
# 771
_Up, class _Ep> inline bool 
# 773
operator<=(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 774
__y) 
# 775
{ return !(__y < __x); } 
# 777
template< class _Tp, class _Dp> inline bool 
# 779
operator<=(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) 
# 780
{ return !(nullptr < __x); } 
# 782
template< class _Tp, class _Dp> inline bool 
# 784
operator<=(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) 
# 785
{ return !(__x < nullptr); } 
# 787
template< class _Tp, class _Dp, class 
# 788
_Up, class _Ep> inline bool 
# 790
operator>(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 791
__y) 
# 792
{ return (__y < __x); } 
# 794
template< class _Tp, class _Dp> inline bool 
# 796
operator>(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) 
# 797
{ return less< typename unique_ptr< _Tp, _Dp> ::pointer> ()(nullptr, __x.get()); 
# 798
} 
# 800
template< class _Tp, class _Dp> inline bool 
# 802
operator>(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) 
# 803
{ return less< typename unique_ptr< _Tp, _Dp> ::pointer> ()(__x.get(), nullptr); 
# 804
} 
# 806
template< class _Tp, class _Dp, class 
# 807
_Up, class _Ep> inline bool 
# 809
operator>=(const unique_ptr< _Tp, _Dp>  &__x, const unique_ptr< _Up, _Ep>  &
# 810
__y) 
# 811
{ return !(__x < __y); } 
# 813
template< class _Tp, class _Dp> inline bool 
# 815
operator>=(const unique_ptr< _Tp, _Dp>  &__x, nullptr_t) 
# 816
{ return !(__x < nullptr); } 
# 818
template< class _Tp, class _Dp> inline bool 
# 820
operator>=(nullptr_t, const unique_ptr< _Tp, _Dp>  &__x) 
# 821
{ return !(nullptr < __x); } 
# 824
template< class _Tp, class _Dp> 
# 825
struct hash< unique_ptr< _Tp, _Dp> >  : public __hash_base< unsigned long, unique_ptr< _Tp, _Dp> > , private __poison_hash< typename unique_ptr< _Tp, _Dp> ::pointer>  { 
# 830
std::size_t operator()(const unique_ptr< _Tp, _Dp>  &__u) const noexcept 
# 831
{ 
# 832
typedef unique_ptr< _Tp, _Dp>  _UP; 
# 833
return std::hash< typename unique_ptr< _Tp, _Dp> ::pointer> ()(__u.get()); 
# 834
} 
# 835
}; 
# 841
template< class _Tp> 
# 842
struct _MakeUniq { 
# 843
typedef unique_ptr< _Tp>  __single_object; }; 
# 845
template< class _Tp> 
# 846
struct _MakeUniq< _Tp []>  { 
# 847
typedef unique_ptr< _Tp []>  __array; }; 
# 849
template< class _Tp, size_t _Bound> 
# 850
struct _MakeUniq< _Tp [_Bound]>  { 
# 851
struct __invalid_type { }; }; 
# 854
template< class _Tp, class ..._Args> inline typename _MakeUniq< _Tp> ::__single_object 
# 856
make_unique(_Args &&...__args) 
# 857
{ return ((unique_ptr< _Tp> )(new _Tp(std::forward< _Args> (__args)...))); } 
# 860
template< class _Tp> inline typename _MakeUniq< _Tp> ::__array 
# 862
make_unique(size_t __num) 
# 863
{ return ((unique_ptr< _Tp> )(new remove_extent_t< _Tp>  [__num]())); } 
# 866
template < typename _Tp, typename ... _Args >
    inline typename _MakeUniq < _Tp > :: __invalid_type
    make_unique ( _Args && ... ) = delete;
# 888 "/usr/include/c++/9/bits/unique_ptr.h" 3
}
# 40 "/usr/include/c++/9/bits/allocated_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
template< class _Alloc> 
# 46
struct __allocated_ptr { 
# 48
using pointer = typename allocator_traits< _Alloc> ::pointer; 
# 49
using value_type = typename allocator_traits< _Alloc> ::value_type; 
# 52
__allocated_ptr(_Alloc &__a, pointer __ptr) noexcept : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr) 
# 54
{ } 
# 57
template< class _Ptr, class 
# 58
_Req = _Require< is_same< _Ptr, value_type *> > > 
# 59
__allocated_ptr(_Alloc &__a, _Ptr __ptr) : _M_alloc(std::__addressof(__a)), _M_ptr(pointer_traits< pointer> ::pointer_to(*__ptr)) 
# 62
{ } 
# 65
__allocated_ptr(__allocated_ptr &&__gd) noexcept : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr) 
# 67
{ (__gd._M_ptr) = nullptr; } 
# 70
~__allocated_ptr() 
# 71
{ 
# 72
if ((_M_ptr) != nullptr) { 
# 73
std::template allocator_traits< _Alloc> ::deallocate(*(_M_alloc), _M_ptr, 1); }  
# 74
} 
# 78
__allocated_ptr &operator=(nullptr_t) noexcept 
# 79
{ 
# 80
(_M_ptr) = nullptr; 
# 81
return *this; 
# 82
} 
# 85
value_type *get() { return std::__to_address(_M_ptr); } 
# 88
private: _Alloc *_M_alloc; 
# 89
pointer _M_ptr; 
# 90
}; 
# 93
template< class _Alloc> __allocated_ptr< _Alloc>  
# 95
__allocate_guarded(_Alloc &__a) 
# 96
{ 
# 97
return {__a, std::template allocator_traits< _Alloc> ::allocate(__a, 1)}; 
# 98
} 
# 101
}
# 43 "/usr/include/c++/9/bits/refwrap.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _Res, class ..._ArgTypes> 
# 53
struct _Maybe_unary_or_binary_function { }; 
# 56
template< class _Res, class _T1> 
# 57
struct _Maybe_unary_or_binary_function< _Res, _T1>  : public unary_function< _T1, _Res>  { 
# 58
}; 
# 61
template< class _Res, class _T1, class _T2> 
# 62
struct _Maybe_unary_or_binary_function< _Res, _T1, _T2>  : public binary_function< _T1, _T2, _Res>  { 
# 63
}; 
# 65
template< class _Signature> struct _Mem_fn_traits; 
# 68
template< class _Res, class _Class, class ..._ArgTypes> 
# 69
struct _Mem_fn_traits_base { 
# 71
using __result_type = _Res; 
# 72
using __maybe_type = _Maybe_unary_or_binary_function< _Res, _Class *, _ArgTypes...> ; 
# 74
using __arity = integral_constant< size_t, sizeof...(_ArgTypes)> ; 
# 75
}; 
# 97 "/usr/include/c++/9/bits/refwrap.h" 3
template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...)>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...)>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) volatile>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) volatile>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const volatile>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const volatile>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __vararg = std::true_type; }; 
# 98
template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) &>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) &>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const &>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const &>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) volatile &>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) volatile &>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const volatile &>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const volatile &>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __vararg = std::true_type; }; 
# 99
template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) &&>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) &&>  : public _Mem_fn_traits_base< _Res, _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const &&>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const &&>  : public _Mem_fn_traits_base< _Res, const _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) volatile &&>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) volatile &&>  : public _Mem_fn_traits_base< _Res, volatile _Class, _ArgTypes...>  { using __vararg = std::true_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ...) const volatile &&>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __vararg = std::false_type; }; template< class _Res, class _Class, class ..._ArgTypes> struct _Mem_fn_traits< _Res (_Class::*)(_ArgTypes ..., ...) const volatile &&>  : public _Mem_fn_traits_base< _Res, const volatile _Class, _ArgTypes...>  { using __vararg = std::true_type; }; 
# 111 "/usr/include/c++/9/bits/refwrap.h" 3
template< class _Functor, class  = __void_t< > > 
# 112
struct _Maybe_get_result_type { 
# 113
}; 
# 115
template< class _Functor> 
# 116
struct _Maybe_get_result_type< _Functor, __void_t< typename _Functor::result_type> >  { 
# 118
typedef typename _Functor::result_type result_type; }; 
# 124
template< class _Functor> 
# 125
struct _Weak_result_type_impl : public _Maybe_get_result_type< _Functor>  { 
# 127
}; 
# 130
template< class _Res, class ..._ArgTypes> 
# 131
struct _Weak_result_type_impl< _Res (_ArgTypes ...)>  { 
# 132
typedef _Res result_type; }; 
# 135
template< class _Res, class ..._ArgTypes> 
# 136
struct _Weak_result_type_impl< _Res (_ArgTypes ..., ...)>  { 
# 137
typedef _Res result_type; }; 
# 140
template< class _Res, class ..._ArgTypes> 
# 141
struct _Weak_result_type_impl< _Res (*)(_ArgTypes ...)>  { 
# 142
typedef _Res result_type; }; 
# 145
template< class _Res, class ..._ArgTypes> 
# 147
struct _Weak_result_type_impl< _Res (*)(_ArgTypes ..., ...)>  { 
# 148
typedef _Res result_type; }; 
# 151
template< class _Functor, bool 
# 152
 = is_member_function_pointer< _Functor> ::value> 
# 153
struct _Weak_result_type_memfun : public _Weak_result_type_impl< _Functor>  { 
# 155
}; 
# 158
template< class _MemFunPtr> 
# 159
struct _Weak_result_type_memfun< _MemFunPtr, true>  { 
# 161
using result_type = typename _Mem_fn_traits< _MemFunPtr> ::__result_type; 
# 162
}; 
# 165
template< class _Func, class _Class> 
# 166
struct _Weak_result_type_memfun< _Func (_Class::*), false>  { 
# 167
}; 
# 173
template< class _Functor> 
# 174
struct _Weak_result_type : public _Weak_result_type_memfun< typename remove_cv< _Functor> ::type>  { 
# 176
}; 
# 180
template< class _Tp, class  = __void_t< > > 
# 181
struct _Refwrap_base_arg1 { 
# 182
}; 
# 185
template< class _Tp> 
# 186
struct _Refwrap_base_arg1< _Tp, __void_t< typename _Tp::argument_type> >  { 
# 189
typedef typename _Tp::argument_type argument_type; 
# 190
}; 
# 193
template< class _Tp, class  = __void_t< > > 
# 194
struct _Refwrap_base_arg2 { 
# 195
}; 
# 198
template< class _Tp> 
# 199
struct _Refwrap_base_arg2< _Tp, __void_t< typename _Tp::first_argument_type, typename _Tp::second_argument_type> >  { 
# 203
typedef typename _Tp::first_argument_type first_argument_type; 
# 204
typedef typename _Tp::second_argument_type second_argument_type; 
# 205
}; 
# 213
template< class _Tp> 
# 214
struct _Reference_wrapper_base : public _Weak_result_type< _Tp> , public _Refwrap_base_arg1< _Tp> , public _Refwrap_base_arg2< _Tp>  { 
# 216
}; 
# 219
template< class _Res, class _T1> 
# 220
struct _Reference_wrapper_base< _Res (_T1)>  : public unary_function< _T1, _Res>  { 
# 222
}; 
# 224
template< class _Res, class _T1> 
# 225
struct _Reference_wrapper_base< _Res (_T1) const>  : public unary_function< _T1, _Res>  { 
# 227
}; 
# 229
template< class _Res, class _T1> 
# 230
struct _Reference_wrapper_base< _Res (_T1) volatile>  : public unary_function< _T1, _Res>  { 
# 232
}; 
# 234
template< class _Res, class _T1> 
# 235
struct _Reference_wrapper_base< _Res (_T1) const volatile>  : public unary_function< _T1, _Res>  { 
# 237
}; 
# 240
template< class _Res, class _T1, class _T2> 
# 241
struct _Reference_wrapper_base< _Res (_T1, _T2)>  : public binary_function< _T1, _T2, _Res>  { 
# 243
}; 
# 245
template< class _Res, class _T1, class _T2> 
# 246
struct _Reference_wrapper_base< _Res (_T1, _T2) const>  : public binary_function< _T1, _T2, _Res>  { 
# 248
}; 
# 250
template< class _Res, class _T1, class _T2> 
# 251
struct _Reference_wrapper_base< _Res (_T1, _T2) volatile>  : public binary_function< _T1, _T2, _Res>  { 
# 253
}; 
# 255
template< class _Res, class _T1, class _T2> 
# 256
struct _Reference_wrapper_base< _Res (_T1, _T2) const volatile>  : public binary_function< _T1, _T2, _Res>  { 
# 258
}; 
# 261
template< class _Res, class _T1> 
# 262
struct _Reference_wrapper_base< _Res (*)(_T1)>  : public unary_function< _T1, _Res>  { 
# 264
}; 
# 267
template< class _Res, class _T1, class _T2> 
# 268
struct _Reference_wrapper_base< _Res (*)(_T1, _T2)>  : public binary_function< _T1, _T2, _Res>  { 
# 270
}; 
# 272
template< class _Tp, bool  = is_member_function_pointer< _Tp> ::value> 
# 273
struct _Reference_wrapper_base_memfun : public _Reference_wrapper_base< _Tp>  { 
# 275
}; 
# 277
template< class _MemFunPtr> 
# 278
struct _Reference_wrapper_base_memfun< _MemFunPtr, true>  : public _Mem_fn_traits< _MemFunPtr> ::__maybe_type { 
# 281
using result_type = typename _Mem_fn_traits< _MemFunPtr> ::__result_type; 
# 282
}; 
# 290
template< class _Tp> 
# 291
class reference_wrapper : public _Reference_wrapper_base_memfun< typename remove_cv< _Tp> ::type>  { 
# 298
_Tp *_M_data; 
# 300
static _Tp *_S_fun(_Tp &__r) noexcept { return std::__addressof(__r); } 
# 301
static void _S_fun(_Tp &&) = delete;
# 303
template< class _Up, class _Up2 = std::__remove_cvref_t< _Up> > using __not_same = typename enable_if< !is_same< reference_wrapper, _Up2> ::value> ::type; 
# 308
public: typedef _Tp type; 
# 313
template< class _Up, class  = __not_same< _Up> , class 
# 314
 = __decltype((reference_wrapper< _Tp> ::_S_fun(std::declval< _Up> ())))> 
# 315
reference_wrapper(_Up &&__uref) noexcept(noexcept(reference_wrapper< _Tp> ::_S_fun(std::declval< _Up> ()))) : _M_data(reference_wrapper< _Tp> ::_S_fun(std::forward< _Up> (__uref))) 
# 318
{ } 
# 320
reference_wrapper(const reference_wrapper &) = default;
# 323
reference_wrapper &operator=(const reference_wrapper &) = default;
# 325
operator _Tp &() const noexcept 
# 326
{ return get(); } 
# 329
_Tp &get() const noexcept 
# 330
{ return *(_M_data); } 
# 332
template< class ..._Args> typename result_of< _Tp &(_Args && ...)> ::type 
# 334
operator()(_Args &&...__args) const 
# 335
{ 
# 340
return std::__invoke(get(), std::forward< _Args> (__args)...); 
# 341
} 
# 342
}; 
# 350
template< class _Tp> inline reference_wrapper< _Tp>  
# 352
ref(_Tp &__t) noexcept 
# 353
{ return ((reference_wrapper< _Tp> )(__t)); } 
# 356
template< class _Tp> inline reference_wrapper< const _Tp>  
# 358
cref(const _Tp &__t) noexcept 
# 359
{ return ((reference_wrapper< const _Tp> )(__t)); } 
# 361
template < typename _Tp >
    void ref ( const _Tp && ) = delete;
# 364
template < typename _Tp >
    void cref ( const _Tp && ) = delete;
# 368
template< class _Tp> inline reference_wrapper< _Tp>  
# 370
ref(reference_wrapper< _Tp>  __t) noexcept 
# 371
{ return __t; } 
# 374
template< class _Tp> inline reference_wrapper< const _Tp>  
# 376
cref(reference_wrapper< _Tp>  __t) noexcept 
# 377
{ return {__t.get()}; } 
# 382
}
# 40 "/usr/include/c++/9/ext/aligned_buffer.h" 3
namespace __gnu_cxx { 
# 46
template< class _Tp> 
# 47
struct __aligned_membuf { 
# 54
struct _Tp2 { _Tp _M_t; }; 
# 56
alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)]; 
# 58
__aligned_membuf() = default;
# 61
__aligned_membuf(std::nullptr_t) { } 
# 64
void *_M_addr() noexcept 
# 65
{ return static_cast< void *>(&(_M_storage)); } 
# 68
const void *_M_addr() const noexcept 
# 69
{ return static_cast< const void *>(&(_M_storage)); } 
# 72
_Tp *_M_ptr() noexcept 
# 73
{ return static_cast< _Tp *>(_M_addr()); } 
# 76
const _Tp *_M_ptr() const noexcept 
# 77
{ return static_cast< const _Tp *>(_M_addr()); } 
# 78
}; 
# 89 "/usr/include/c++/9/ext/aligned_buffer.h" 3
template< class _Tp> 
# 90
struct __aligned_buffer : public std::aligned_storage< sizeof(_Tp), __alignof__(_Tp)>  { 
# 94
typename std::aligned_storage< sizeof(_Tp), __alignof__(_Tp)> ::type _M_storage; 
# 96
__aligned_buffer() = default;
# 99
__aligned_buffer(std::nullptr_t) { } 
# 102
void *_M_addr() noexcept 
# 103
{ 
# 104
return static_cast< void *>(&(_M_storage)); 
# 105
} 
# 108
const void *_M_addr() const noexcept 
# 109
{ 
# 110
return static_cast< const void *>(&(_M_storage)); 
# 111
} 
# 114
_Tp *_M_ptr() noexcept 
# 115
{ return static_cast< _Tp *>(_M_addr()); } 
# 118
const _Tp *_M_ptr() const noexcept 
# 119
{ return static_cast< const _Tp *>(_M_addr()); } 
# 120
}; 
# 123
}
# 58 "/usr/include/c++/9/bits/shared_ptr_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 63
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template< class > class auto_ptr; 
#pragma GCC diagnostic pop
# 73
class bad_weak_ptr : public exception { 
# 76
public: virtual const char *what() const noexcept; 
# 78
virtual ~bad_weak_ptr() noexcept; 
# 79
}; 
# 83
inline void __throw_bad_weak_ptr() 
# 84
{ throw bad_weak_ptr(); } 
# 86
using __gnu_cxx::_Lock_policy;
# 87
using __gnu_cxx::__default_lock_policy;
# 88
using __gnu_cxx::_S_single;
# 89
using __gnu_cxx::_S_mutex;
# 90
using __gnu_cxx::_S_atomic;
# 93
template< __gnu_cxx::_Lock_policy _Lp> 
# 94
class _Mutex_base { 
# 98
protected: enum { _S_need_barriers}; 
# 99
}; 
# 102
template<> class _Mutex_base< __gnu_cxx::_S_mutex>  : public __gnu_cxx::__mutex { 
# 109
protected: enum { _S_need_barriers = 1}; 
# 110
}; 
# 112
template< __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> 
# 113
class _Sp_counted_base : public _Mutex_base< _Lp>  { 
# 117
public: _Sp_counted_base() noexcept : _M_use_count(1), _M_weak_count(1) 
# 118
{ } 
# 121
virtual ~_Sp_counted_base() noexcept 
# 122
{ } 
# 127
virtual void _M_dispose() noexcept = 0; 
# 131
virtual void _M_destroy() noexcept 
# 132
{ delete this; } 
# 135
virtual void *_M_get_deleter(const std::type_info &) noexcept = 0; 
# 138
void _M_add_ref_copy() 
# 139
{ __gnu_cxx::__atomic_add_dispatch(&(_M_use_count), 1); } 
# 142
void _M_add_ref_lock(); 
# 145
bool _M_add_ref_lock_nothrow(); 
# 148
void _M_release() noexcept 
# 149
{ 
# 151
; 
# 152
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_use_count), -1) == 1) 
# 153
{ 
# 154
; 
# 155
_M_dispose(); 
# 160
if (_Mutex_base< _Lp> ::_S_need_barriers) 
# 161
{ 
# 162
__atomic_thread_fence(4); 
# 163
}  
# 166
; 
# 167
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_weak_count), -1) == 1) 
# 169
{ 
# 170
; 
# 171
_M_destroy(); 
# 172
}  
# 173
}  
# 174
} 
# 177
void _M_weak_add_ref() noexcept 
# 178
{ __gnu_cxx::__atomic_add_dispatch(&(_M_weak_count), 1); } 
# 181
void _M_weak_release() noexcept 
# 182
{ 
# 184
; 
# 185
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_weak_count), -1) == 1) 
# 186
{ 
# 187
; 
# 188
if (_Mutex_base< _Lp> ::_S_need_barriers) 
# 189
{ 
# 192
__atomic_thread_fence(4); 
# 193
}  
# 194
_M_destroy(); 
# 195
}  
# 196
} 
# 199
long _M_get_use_count() const noexcept 
# 200
{ 
# 203
return __atomic_load_n(&(_M_use_count), 0); 
# 204
} 
# 207
private: _Sp_counted_base(const _Sp_counted_base &) = delete;
# 208
_Sp_counted_base &operator=(const _Sp_counted_base &) = delete;
# 210
::_Atomic_word _M_use_count; 
# 211
::_Atomic_word _M_weak_count; 
# 212
}; 
# 217
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_lock() 
# 218
{ 
# 219
if ((_M_use_count) == 0) { 
# 220
__throw_bad_weak_ptr(); }  
# 221
++(_M_use_count); 
# 222
} 
# 227
template<> inline void _Sp_counted_base< __gnu_cxx::_S_mutex> ::_M_add_ref_lock() 
# 228
{ 
# 229
__gnu_cxx::__scoped_lock sentry(*this); 
# 230
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_use_count), 1) == 0) 
# 231
{ 
# 232
(_M_use_count) = 0; 
# 233
__throw_bad_weak_ptr(); 
# 234
}  
# 235
} 
# 240
template<> inline void _Sp_counted_base< __gnu_cxx::_S_atomic> ::_M_add_ref_lock() 
# 241
{ 
# 243
_Atomic_word __count = this->_M_get_use_count(); 
# 244
do 
# 245
{ 
# 246
if (__count == 0) { 
# 247
__throw_bad_weak_ptr(); }  
# 250
} 
# 251
while (!__atomic_compare_exchange_n(&(_M_use_count), &__count, __count + 1, true, 4, 0)); 
# 254
} 
# 259
template<> inline bool _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_lock_nothrow() 
# 260
{ 
# 261
if ((_M_use_count) == 0) { 
# 262
return false; }  
# 263
++(_M_use_count); 
# 264
return true; 
# 265
} 
# 270
template<> inline bool _Sp_counted_base< __gnu_cxx::_S_mutex> ::_M_add_ref_lock_nothrow() 
# 271
{ 
# 272
__gnu_cxx::__scoped_lock sentry(*this); 
# 273
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_use_count), 1) == 0) 
# 274
{ 
# 275
(_M_use_count) = 0; 
# 276
return false; 
# 277
}  
# 278
return true; 
# 279
} 
# 284
template<> inline bool _Sp_counted_base< __gnu_cxx::_S_atomic> ::_M_add_ref_lock_nothrow() 
# 285
{ 
# 287
_Atomic_word __count = this->_M_get_use_count(); 
# 288
do 
# 289
{ 
# 290
if (__count == 0) { 
# 291
return false; }  
# 294
} 
# 295
while (!__atomic_compare_exchange_n(&(_M_use_count), &__count, __count + 1, true, 4, 0)); 
# 298
return true; 
# 299
} 
# 303
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_add_ref_copy() 
# 304
{ ++(_M_use_count); } 
# 308
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_release() noexcept 
# 309
{ 
# 310
if ((--(_M_use_count)) == 0) 
# 311
{ 
# 312
this->_M_dispose(); 
# 313
if ((--(_M_weak_count)) == 0) { 
# 314
this->_M_destroy(); }  
# 315
}  
# 316
} 
# 320
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_weak_add_ref() noexcept 
# 321
{ ++(_M_weak_count); } 
# 325
template<> inline void _Sp_counted_base< __gnu_cxx::_S_single> ::_M_weak_release() noexcept 
# 326
{ 
# 327
if ((--(_M_weak_count)) == 0) { 
# 328
this->_M_destroy(); }  
# 329
} 
# 333
template<> inline long _Sp_counted_base< __gnu_cxx::_S_single> ::_M_get_use_count() const noexcept 
# 334
{ return _M_use_count; } 
# 338
template< class _Tp, __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __shared_ptr; 
# 341
template< class _Tp, __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __weak_ptr; 
# 344
template< class _Tp, __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __enable_shared_from_this; 
# 347
template< class _Tp> class shared_ptr; 
# 350
template< class _Tp> class weak_ptr; 
# 353
template< class _Tp> struct owner_less; 
# 356
template< class _Tp> class enable_shared_from_this; 
# 359
template< __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __weak_count; 
# 362
template< __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic> class __shared_count; 
# 367
template< class _Ptr, __gnu_cxx::_Lock_policy _Lp> 
# 368
class _Sp_counted_ptr __final : public _Sp_counted_base< _Lp>  { 
# 372
public: explicit _Sp_counted_ptr(_Ptr __p) noexcept : _M_ptr(__p) 
# 373
{ } 
# 376
virtual void _M_dispose() noexcept 
# 377
{ delete (_M_ptr); } 
# 380
virtual void _M_destroy() noexcept 
# 381
{ delete this; } 
# 384
virtual void *_M_get_deleter(const std::type_info &) noexcept 
# 385
{ return nullptr; } 
# 387
_Sp_counted_ptr(const _Sp_counted_ptr &) = delete;
# 388
_Sp_counted_ptr &operator=(const _Sp_counted_ptr &) = delete;
# 391
private: _Ptr _M_ptr; 
# 392
}; 
# 396
template<> inline void _Sp_counted_ptr< nullptr_t, __gnu_cxx::_S_single> ::_M_dispose() noexcept { } 
# 400
template<> inline void _Sp_counted_ptr< nullptr_t, __gnu_cxx::_S_mutex> ::_M_dispose() noexcept { } 
# 404
template<> inline void _Sp_counted_ptr< nullptr_t, __gnu_cxx::_S_atomic> ::_M_dispose() noexcept { } 
# 406
template< int _Nm, class _Tp, bool 
# 407
__use_ebo = (!__is_final(_Tp)) && __is_empty(_Tp)> struct _Sp_ebo_helper; 
# 411
template< int _Nm, class _Tp> 
# 412
struct _Sp_ebo_helper< _Nm, _Tp, true>  : private _Tp { 
# 414
explicit _Sp_ebo_helper(const _Tp &__tp) : _Tp(__tp) { } 
# 415
explicit _Sp_ebo_helper(_Tp &&__tp) : _Tp(std::move(__tp)) { } 
# 418
static _Tp &_S_get(std::_Sp_ebo_helper< _Nm, _Tp, true>  &__eboh) { return static_cast< _Tp &>(__eboh); } 
# 419
}; 
# 422
template< int _Nm, class _Tp> 
# 423
struct _Sp_ebo_helper< _Nm, _Tp, false>  { 
# 425
explicit _Sp_ebo_helper(const _Tp &__tp) : _M_tp(__tp) { } 
# 426
explicit _Sp_ebo_helper(_Tp &&__tp) : _M_tp(std::move(__tp)) { } 
# 429
static _Tp &_S_get(std::_Sp_ebo_helper< _Nm, _Tp, false>  &__eboh) 
# 430
{ return __eboh._M_tp; } 
# 433
private: _Tp _M_tp; 
# 434
}; 
# 437
template< class _Ptr, class _Deleter, class _Alloc, __gnu_cxx::_Lock_policy _Lp> 
# 438
class _Sp_counted_deleter __final : public _Sp_counted_base< _Lp>  { 
# 440
class _Impl : private _Sp_ebo_helper< 0, _Deleter> , private _Sp_ebo_helper< 1, _Alloc>  { 
# 442
typedef _Sp_ebo_helper< 0, _Deleter>  _Del_base; 
# 443
typedef _Sp_ebo_helper< 1, _Alloc>  _Alloc_base; 
# 446
public: _Impl(_Ptr __p, _Deleter __d, const _Alloc &__a) noexcept : _Del_base(std::move(__d)), _Alloc_base(__a), _M_ptr(__p) 
# 448
{ } 
# 450
_Deleter &_M_del() noexcept { return _Del_base::_S_get(*this); } 
# 451
_Alloc &_M_alloc() noexcept { return _Alloc_base::_S_get(*this); } 
# 453
_Ptr _M_ptr; 
# 454
}; 
# 457
public: using __allocator_type = std::__alloc_rebind< _Alloc, _Sp_counted_deleter> ; 
# 460
_Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept : _M_impl(__p, std::move(__d), _Alloc()) 
# 461
{ } 
# 464
_Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc &__a) noexcept : _M_impl(__p, std::move(__d), __a) 
# 465
{ } 
# 467
~_Sp_counted_deleter() noexcept { } 
# 470
virtual void _M_dispose() noexcept 
# 471
{ (_M_impl)._M_del()(((_M_impl)._M_ptr)); } 
# 474
virtual void _M_destroy() noexcept 
# 475
{ 
# 476
__allocator_type __a((_M_impl)._M_alloc()); 
# 477
__allocated_ptr< __allocator_type>  __guard_ptr{__a, this}; 
# 478
this->~_Sp_counted_deleter(); 
# 479
} 
# 482
virtual void *_M_get_deleter(const std::type_info &__ti) noexcept 
# 483
{ 
# 487
return (__ti == (typeid(_Deleter))) ? std::__addressof((_M_impl)._M_del()) : nullptr; 
# 493
} 
# 496
private: _Impl _M_impl; 
# 497
}; 
# 501
struct _Sp_make_shared_tag { 
# 504
template< class _Tp, class _Alloc, __gnu_cxx::_Lock_policy _Lp> friend class _Sp_counted_ptr_inplace; 
# 508
private: static const type_info &_S_ti() noexcept __attribute((__visibility__("default"))) 
# 509
{ 
# 510
alignas(type_info) static constexpr char __tag[sizeof(type_info)] = {}; 
# 511
return reinterpret_cast< const type_info &>(__tag); 
# 512
} 
# 514
static bool _S_eq(const type_info &) noexcept; 
# 515
}; 
# 517
template< class _Alloc> 
# 518
struct _Sp_alloc_shared_tag { 
# 520
const _Alloc &_M_a; 
# 521
}; 
# 523
template< class _Tp, class _Alloc, __gnu_cxx::_Lock_policy _Lp> 
# 524
class _Sp_counted_ptr_inplace __final : public _Sp_counted_base< _Lp>  { 
# 526
class _Impl : private _Sp_ebo_helper< 0, _Alloc>  { 
# 528
typedef _Sp_ebo_helper< 0, _Alloc>  _A_base; 
# 531
public: explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { } 
# 533
_Alloc &_M_alloc() noexcept { return _A_base::_S_get(*this); } 
# 535
__gnu_cxx::__aligned_buffer< _Tp>  _M_storage; 
# 536
}; 
# 539
public: using __allocator_type = std::__alloc_rebind< _Alloc, _Sp_counted_ptr_inplace> ; 
# 542
template< class ..._Args> 
# 543
_Sp_counted_ptr_inplace(_Alloc __a, _Args &&...__args) : _M_impl(__a) 
# 545
{ 
# 548
allocator_traits< _Alloc> ::construct(__a, _M_ptr(), std::forward< _Args> (__args)...); 
# 550
} 
# 552
~_Sp_counted_ptr_inplace() noexcept { } 
# 555
virtual void _M_dispose() noexcept 
# 556
{ 
# 557
allocator_traits< _Alloc> ::destroy((_M_impl)._M_alloc(), _M_ptr()); 
# 558
} 
# 562
virtual void _M_destroy() noexcept 
# 563
{ 
# 564
__allocator_type __a((_M_impl)._M_alloc()); 
# 565
__allocated_ptr< __allocator_type>  __guard_ptr{__a, this}; 
# 566
this->~_Sp_counted_ptr_inplace(); 
# 567
} 
# 570
friend class __shared_count< _Lp> ; 
# 575
private: virtual void *_M_get_deleter(const std::type_info &__ti) noexcept override 
# 576
{ 
# 577
auto __ptr = const_cast< typename remove_cv< _Tp> ::type *>(_M_ptr()); 
# 582
if (((&__ti) == (&_Sp_make_shared_tag::_S_ti())) || (__ti == (typeid(std::_Sp_make_shared_tag)))) { 
# 590
return __ptr; }  
# 591
return nullptr; 
# 592
} 
# 594
_Tp *_M_ptr() noexcept { return ((_M_impl)._M_storage)._M_ptr(); } 
# 596
_Impl _M_impl; 
# 597
}; 
# 600
struct __sp_array_delete { 
# 602
template< class _Yp> void 
# 603
operator()(_Yp *__p) const { delete [] __p; } 
# 604
}; 
# 606
template< __gnu_cxx::_Lock_policy _Lp> 
# 607
class __shared_count { 
# 609
template< class _Tp> 
# 610
struct __not_alloc_shared_tag { using type = void; }; 
# 612
template< class _Tp> 
# 613
struct __not_alloc_shared_tag< _Sp_alloc_shared_tag< _Tp> >  { }; 
# 616
public: constexpr __shared_count() noexcept : _M_pi((0)) 
# 617
{ } 
# 619
template< class _Ptr> explicit 
# 621
__shared_count(_Ptr __p) : _M_pi((0)) 
# 622
{ 
# 623
try 
# 624
{ 
# 625
(_M_pi) = (new _Sp_counted_ptr< _Ptr, _Lp> (__p)); 
# 626
} 
# 627
catch (...) 
# 628
{ 
# 629
delete __p; 
# 630
throw; 
# 631
}  
# 632
} 
# 634
template< class _Ptr> 
# 635
__shared_count(_Ptr __p, false_type) : __shared_count(__p) 
# 637
{ } 
# 639
template< class _Ptr> 
# 640
__shared_count(_Ptr __p, true_type) : __shared_count(__p, __sp_array_delete{}, allocator< void> ()) 
# 642
{ } 
# 644
template< class _Ptr, class _Deleter, class 
# 645
 = typename __not_alloc_shared_tag< _Deleter> ::type> 
# 646
__shared_count(_Ptr __p, _Deleter __d) : __shared_count(__p, std::move(__d), allocator< void> ()) 
# 648
{ } 
# 650
template< class _Ptr, class _Deleter, class _Alloc, class 
# 651
 = typename __not_alloc_shared_tag< _Deleter> ::type> 
# 652
__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi((0)) 
# 653
{ 
# 654
typedef _Sp_counted_deleter< _Ptr, _Deleter, _Alloc, _Lp>  _Sp_cd_type; 
# 655
try 
# 656
{ 
# 657
typename _Sp_counted_deleter< _Ptr, _Deleter, _Alloc, _Lp> ::__allocator_type __a2(__a); 
# 658
auto __guard = std::__allocate_guarded(__a2); 
# 659
_Sp_cd_type *__mem = __guard.get(); 
# 660
::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a)); 
# 661
(_M_pi) = __mem; 
# 662
__guard = nullptr; 
# 663
} 
# 664
catch (...) 
# 665
{ 
# 666
__d(__p); 
# 667
throw; 
# 668
}  
# 669
} 
# 671
template< class _Tp, class _Alloc, class ..._Args> 
# 672
__shared_count(_Tp *&__p, _Sp_alloc_shared_tag< _Alloc>  __a, _Args &&...
# 673
__args) 
# 674
{ 
# 675
typedef _Sp_counted_ptr_inplace< _Tp, _Alloc, _Lp>  _Sp_cp_type; 
# 676
typename _Sp_counted_ptr_inplace< _Tp, _Alloc, _Lp> ::__allocator_type __a2((__a._M_a)); 
# 677
auto __guard = std::__allocate_guarded(__a2); 
# 678
_Sp_cp_type *__mem = __guard.get(); 
# 679
auto __pi = ((::new (__mem) _Sp_cp_type((__a._M_a), std::forward< _Args> (__args)...))); 
# 681
__guard = nullptr; 
# 682
(_M_pi) = __pi; 
# 683
__p = (__pi->_M_ptr)(); 
# 684
} 
# 687
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 690
template< class _Tp> inline explicit __shared_count(auto_ptr< _Tp>  && __r); 
# 693
#pragma GCC diagnostic pop
# 697
template< class _Tp, class _Del> explicit 
# 699
__shared_count(unique_ptr< _Tp, _Del>  &&__r) : _M_pi((0)) 
# 700
{ 
# 703
if (__r.get() == nullptr) { 
# 704
return; }  
# 706
using _Ptr = typename unique_ptr< _Tp, _Del> ::pointer; 
# 707
using _Del2 = typename conditional< is_reference< _Del> ::value, reference_wrapper< typename remove_reference< _Del> ::type> , _Del> ::type; 
# 710
using _Sp_cd_type = _Sp_counted_deleter< typename unique_ptr< _Tp, _Del> ::pointer, typename conditional< is_reference< _Del> ::value, reference_wrapper< typename remove_reference< _Del> ::type> , _Del> ::type, allocator< void> , _Lp> ; 
# 712
using _Alloc = allocator< _Sp_counted_deleter< typename unique_ptr< _Tp, _Del> ::pointer, typename conditional< is_reference< _Del> ::value, reference_wrapper< typename remove_reference< _Del> ::type> , _Del> ::type, allocator< void> , _Lp> > ; 
# 713
using _Alloc_traits = allocator_traits< allocator< _Sp_counted_deleter< typename unique_ptr< _Tp, _Del> ::pointer, typename conditional< is_reference< _Del> ::value, reference_wrapper< typename remove_reference< _Del> ::type> , _Del> ::type, allocator< void> , _Lp> > > ; 
# 714
_Alloc __a; 
# 715
_Sp_cd_type *__mem = _Alloc_traits::allocate(__a, 1); 
# 716
_Alloc_traits::construct(__a, __mem, __r.release(), __r.get_deleter()); 
# 718
(_M_pi) = __mem; 
# 719
} 
# 722
inline explicit __shared_count(const __weak_count< _Lp>  & __r); 
# 725
inline explicit __shared_count(const __weak_count< _Lp>  & __r, nothrow_t); 
# 727
~__shared_count() noexcept 
# 728
{ 
# 729
if ((_M_pi) != nullptr) { 
# 730
(_M_pi)->_M_release(); }  
# 731
} 
# 733
__shared_count(const __shared_count &__r) noexcept : _M_pi(__r._M_pi) 
# 735
{ 
# 736
if ((_M_pi) != 0) { 
# 737
(_M_pi)->_M_add_ref_copy(); }  
# 738
} 
# 741
__shared_count &operator=(const __shared_count &__r) noexcept 
# 742
{ 
# 743
_Sp_counted_base< _Lp>  *__tmp = __r._M_pi; 
# 744
if (__tmp != (_M_pi)) 
# 745
{ 
# 746
if (__tmp != 0) { 
# 747
__tmp->_M_add_ref_copy(); }  
# 748
if ((_M_pi) != 0) { 
# 749
(_M_pi)->_M_release(); }  
# 750
(_M_pi) = __tmp; 
# 751
}  
# 752
return *this; 
# 753
} 
# 756
void _M_swap(__shared_count &__r) noexcept 
# 757
{ 
# 758
_Sp_counted_base< _Lp>  *__tmp = __r._M_pi; 
# 759
(__r._M_pi) = (_M_pi); 
# 760
(_M_pi) = __tmp; 
# 761
} 
# 764
long _M_get_use_count() const noexcept 
# 765
{ return ((_M_pi) != 0) ? (_M_pi)->_M_get_use_count() : 0; } 
# 768
bool _M_unique() const noexcept 
# 769
{ return _M_get_use_count() == (1); } 
# 772
void *_M_get_deleter(const type_info &__ti) const noexcept 
# 773
{ return (_M_pi) ? (_M_pi)->_M_get_deleter(__ti) : nullptr; } 
# 776
bool _M_less(const __shared_count &__rhs) const noexcept 
# 777
{ return less< _Sp_counted_base< _Lp>  *> ()(this->_M_pi, __rhs._M_pi); } 
# 780
bool _M_less(const __weak_count< _Lp>  &__rhs) const noexcept 
# 781
{ return less< _Sp_counted_base< _Lp>  *> ()(this->_M_pi, (__rhs._M_pi)); } 
# 785
friend inline bool operator==(const __shared_count< _Lp>  &__a, const __shared_count< _Lp>  &__b) noexcept 
# 786
{ return (__a._M_pi) == (__b._M_pi); } 
# 789
friend class __weak_count< _Lp> ; 
# 791
private: _Sp_counted_base< _Lp>  *_M_pi; 
# 792
}; 
# 795
template< __gnu_cxx::_Lock_policy _Lp> 
# 796
class __weak_count { 
# 799
public: constexpr __weak_count() noexcept : _M_pi((nullptr)) 
# 800
{ } 
# 802
__weak_count(const __shared_count< _Lp>  &__r) noexcept : _M_pi(((__r._M_pi))) 
# 804
{ 
# 805
if ((_M_pi) != nullptr) { 
# 806
(_M_pi)->_M_weak_add_ref(); }  
# 807
} 
# 809
__weak_count(const __weak_count &__r) noexcept : _M_pi(__r._M_pi) 
# 811
{ 
# 812
if ((_M_pi) != nullptr) { 
# 813
(_M_pi)->_M_weak_add_ref(); }  
# 814
} 
# 816
__weak_count(__weak_count &&__r) noexcept : _M_pi(__r._M_pi) 
# 818
{ (__r._M_pi) = nullptr; } 
# 820
~__weak_count() noexcept 
# 821
{ 
# 822
if ((_M_pi) != nullptr) { 
# 823
(_M_pi)->_M_weak_release(); }  
# 824
} 
# 827
__weak_count &operator=(const __shared_count< _Lp>  &__r) noexcept 
# 828
{ 
# 829
_Sp_counted_base< _Lp>  *__tmp = ((__r._M_pi)); 
# 830
if (__tmp != nullptr) { 
# 831
__tmp->_M_weak_add_ref(); }  
# 832
if ((_M_pi) != nullptr) { 
# 833
(_M_pi)->_M_weak_release(); }  
# 834
(_M_pi) = __tmp; 
# 835
return *this; 
# 836
} 
# 839
__weak_count &operator=(const __weak_count &__r) noexcept 
# 840
{ 
# 841
_Sp_counted_base< _Lp>  *__tmp = __r._M_pi; 
# 842
if (__tmp != nullptr) { 
# 843
__tmp->_M_weak_add_ref(); }  
# 844
if ((_M_pi) != nullptr) { 
# 845
(_M_pi)->_M_weak_release(); }  
# 846
(_M_pi) = __tmp; 
# 847
return *this; 
# 848
} 
# 851
__weak_count &operator=(__weak_count &&__r) noexcept 
# 852
{ 
# 853
if ((_M_pi) != nullptr) { 
# 854
(_M_pi)->_M_weak_release(); }  
# 855
(_M_pi) = (__r._M_pi); 
# 856
(__r._M_pi) = nullptr; 
# 857
return *this; 
# 858
} 
# 861
void _M_swap(__weak_count &__r) noexcept 
# 862
{ 
# 863
_Sp_counted_base< _Lp>  *__tmp = __r._M_pi; 
# 864
(__r._M_pi) = (_M_pi); 
# 865
(_M_pi) = __tmp; 
# 866
} 
# 869
long _M_get_use_count() const noexcept 
# 870
{ return ((_M_pi) != nullptr) ? (_M_pi)->_M_get_use_count() : 0; } 
# 873
bool _M_less(const __weak_count &__rhs) const noexcept 
# 874
{ return less< _Sp_counted_base< _Lp>  *> ()(this->_M_pi, __rhs._M_pi); } 
# 877
bool _M_less(const __shared_count< _Lp>  &__rhs) const noexcept 
# 878
{ return less< _Sp_counted_base< _Lp>  *> ()(this->_M_pi, (__rhs._M_pi)); } 
# 882
friend inline bool operator==(const __weak_count< _Lp>  &__a, const __weak_count< _Lp>  &__b) noexcept 
# 883
{ return (__a._M_pi) == (__b._M_pi); } 
# 886
friend class __shared_count< _Lp> ; 
# 888
private: _Sp_counted_base< _Lp>  *_M_pi; 
# 889
}; 
# 892
template< __gnu_cxx::_Lock_policy _Lp> inline 
# 894
__shared_count< _Lp> ::__shared_count(const __weak_count< _Lp>  &__r) : _M_pi(((__r._M_pi))) 
# 896
{ 
# 897
if ((_M_pi) != nullptr) { 
# 898
(_M_pi)->_M_add_ref_lock(); } else { 
# 900
__throw_bad_weak_ptr(); }  
# 901
} 
# 904
template< __gnu_cxx::_Lock_policy _Lp> inline 
# 907
__shared_count< _Lp> ::__shared_count(const __weak_count< _Lp>  &__r, nothrow_t) : _M_pi(((__r._M_pi))) 
# 909
{ 
# 910
if ((_M_pi) != nullptr) { 
# 911
if (!(_M_pi)->_M_add_ref_lock_nothrow()) { 
# 912
(_M_pi) = nullptr; }  }  
# 913
} 
# 921
template< class _Yp_ptr, class _Tp_ptr> 
# 922
struct __sp_compatible_with : public false_type { 
# 924
}; 
# 926
template< class _Yp, class _Tp> 
# 927
struct __sp_compatible_with< _Yp *, _Tp *>  : public is_convertible< _Yp *, _Tp *> ::type { 
# 929
}; 
# 931
template< class _Up, size_t _Nm> 
# 932
struct __sp_compatible_with< _Up (*)[_Nm], _Up (*)[]>  : public true_type { 
# 934
}; 
# 936
template< class _Up, size_t _Nm> 
# 937
struct __sp_compatible_with< _Up (*)[_Nm], const _Up (*)[]>  : public true_type { 
# 939
}; 
# 941
template< class _Up, size_t _Nm> 
# 942
struct __sp_compatible_with< _Up (*)[_Nm], volatile _Up (*)[]>  : public true_type { 
# 944
}; 
# 946
template< class _Up, size_t _Nm> 
# 947
struct __sp_compatible_with< _Up (*)[_Nm], const volatile _Up (*)[]>  : public true_type { 
# 949
}; 
# 952
template< class _Up, size_t _Nm, class _Yp, class  = void> 
# 953
struct __sp_is_constructible_arrN : public false_type { 
# 955
}; 
# 957
template< class _Up, size_t _Nm, class _Yp> 
# 958
struct __sp_is_constructible_arrN< _Up, _Nm, _Yp, __void_t< _Yp [_Nm]> >  : public is_convertible< _Yp (*)[_Nm], _Up (*)[_Nm]> ::type { 
# 960
}; 
# 963
template< class _Up, class _Yp, class  = void> 
# 964
struct __sp_is_constructible_arr : public false_type { 
# 966
}; 
# 968
template< class _Up, class _Yp> 
# 969
struct __sp_is_constructible_arr< _Up, _Yp, __void_t< _Yp []> >  : public is_convertible< _Yp (*)[], _Up (*)[]> ::type { 
# 971
}; 
# 974
template< class _Tp, class _Yp> struct __sp_is_constructible; 
# 978
template< class _Up, size_t _Nm, class _Yp> 
# 979
struct __sp_is_constructible< _Up [_Nm], _Yp>  : public __sp_is_constructible_arrN< _Up, _Nm, _Yp> ::type { 
# 981
}; 
# 984
template< class _Up, class _Yp> 
# 985
struct __sp_is_constructible< _Up [], _Yp>  : public __sp_is_constructible_arr< _Up, _Yp> ::type { 
# 987
}; 
# 990
template< class _Tp, class _Yp> 
# 991
struct __sp_is_constructible : public is_convertible< _Yp *, _Tp *> ::type { 
# 993
}; 
# 997
template< class _Tp, __gnu_cxx::_Lock_policy _Lp, bool 
# 998
 = is_array< _Tp> ::value, bool  = is_void< _Tp> ::value> 
# 999
class __shared_ptr_access { 
# 1002
public: using element_type = _Tp; 
# 1005
element_type &operator*() const noexcept 
# 1006
{ 
# 1007
; 
# 1008
return *_M_get(); 
# 1009
} 
# 1012
element_type *operator->() const noexcept 
# 1013
{ 
# 1014
; 
# 1015
return _M_get(); 
# 1016
} 
# 1020
private: element_type *_M_get() const noexcept 
# 1021
{ return (static_cast< const __shared_ptr< _Tp, _Lp>  *>(this))->get(); } 
# 1022
}; 
# 1025
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1026
class __shared_ptr_access< _Tp, _Lp, false, true>  { 
# 1029
public: using element_type = _Tp; 
# 1032
element_type *operator->() const noexcept 
# 1033
{ 
# 1034
auto __ptr = (static_cast< const __shared_ptr< _Tp, _Lp>  *>(this))->get(); 
# 1035
; 
# 1036
return __ptr; 
# 1037
} 
# 1038
}; 
# 1041
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1042
class __shared_ptr_access< _Tp, _Lp, true, false>  { 
# 1045
public: using element_type = typename remove_extent< _Tp> ::type; 
# 1048
[[__deprecated__("shared_ptr<T[]>::operator* is absent from C++17")]] element_type &
# 1050
operator*() const noexcept 
# 1051
{ 
# 1052
; 
# 1053
return *_M_get(); 
# 1054
} 
# 1056
[[__deprecated__("shared_ptr<T[]>::operator-> is absent from C++17")]] element_type *
# 1058
operator->() const noexcept 
# 1059
{ 
# 1060
; 
# 1061
return _M_get(); 
# 1062
} 
# 1066
element_type &operator[](ptrdiff_t __i) const 
# 1067
{ 
# 1068
; 
# 1069
; 
# 1070
return _M_get()[__i]; 
# 1071
} 
# 1075
private: element_type *_M_get() const noexcept 
# 1076
{ return (static_cast< const __shared_ptr< _Tp, _Lp>  *>(this))->get(); } 
# 1077
}; 
# 1079
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1080
class __shared_ptr : public __shared_ptr_access< _Tp, _Lp>  { 
# 1084
public: using element_type = typename remove_extent< _Tp> ::type; 
# 1089
private: 
# 1088
template< class _Yp> using _SafeConv = typename enable_if< __sp_is_constructible< _Tp, _Yp> ::value> ::type; 
# 1093
template< class _Yp, class _Res = void> using _Compatible = typename enable_if< __sp_compatible_with< _Yp *, _Tp *> ::value, _Res> ::type; 
# 1098
template< class _Yp> using _Assignable = _Compatible< _Yp, __shared_ptr &> ; 
# 1102
template< class _Yp, class _Del, class _Res = void, class 
# 1103
_Ptr = typename unique_ptr< _Yp, _Del> ::pointer> using _UniqCompatible = typename enable_if< __and_< __sp_compatible_with< _Yp *, _Tp *> , is_convertible< _Ptr, element_type *> > ::value, _Res> ::type; 
# 1109
template< class _Yp, class _Del> using _UniqAssignable = _UniqCompatible< _Yp, _Del, __shared_ptr &> ; 
# 1118
public: constexpr __shared_ptr() noexcept : _M_ptr((0)), _M_refcount() 
# 1120
{ } 
# 1122
template< class _Yp, class  = _SafeConv< _Yp> > explicit 
# 1124
__shared_ptr(_Yp *__p) : _M_ptr(__p), _M_refcount(__p, typename is_array< _Tp> ::type()) 
# 1126
{ 
# 1127
static_assert((!is_void< _Yp> ::value), "incomplete type");
# 1128
static_assert((sizeof(_Yp) > (0)), "incomplete type");
# 1129
_M_enable_shared_from_this_with(__p); 
# 1130
} 
# 1132
template< class _Yp, class _Deleter, class  = _SafeConv< _Yp> > 
# 1133
__shared_ptr(_Yp *__p, _Deleter __d) : _M_ptr(__p), _M_refcount(__p, std::move(__d)) 
# 1135
{ 
# 1136
static_assert((__is_invocable< _Deleter &, _Yp *&> ::value), "deleter expression d(p) is well-formed");
# 1138
_M_enable_shared_from_this_with(__p); 
# 1139
} 
# 1141
template< class _Yp, class _Deleter, class _Alloc, class 
# 1142
 = _SafeConv< _Yp> > 
# 1143
__shared_ptr(_Yp *__p, _Deleter __d, _Alloc __a) : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a)) 
# 1145
{ 
# 1146
static_assert((__is_invocable< _Deleter &, _Yp *&> ::value), "deleter expression d(p) is well-formed");
# 1148
_M_enable_shared_from_this_with(__p); 
# 1149
} 
# 1151
template< class _Deleter> 
# 1152
__shared_ptr(std::nullptr_t __p, _Deleter __d) : _M_ptr((0)), _M_refcount(__p, std::move(__d)) 
# 1154
{ } 
# 1156
template< class _Deleter, class _Alloc> 
# 1157
__shared_ptr(std::nullptr_t __p, _Deleter __d, _Alloc __a) : _M_ptr((0)), _M_refcount(__p, std::move(__d), std::move(__a)) 
# 1159
{ } 
# 1161
template< class _Yp> 
# 1162
__shared_ptr(const __shared_ptr< _Yp, _Lp>  &__r, element_type *
# 1163
__p) noexcept : _M_ptr(__p), _M_refcount((__r._M_refcount)) 
# 1165
{ } 
# 1167
__shared_ptr(const __shared_ptr &) noexcept = default;
# 1168
__shared_ptr &operator=(const __shared_ptr &) noexcept = default;
# 1169
~__shared_ptr() = default;
# 1171
template< class _Yp, class  = _Compatible< _Yp> > 
# 1172
__shared_ptr(const __shared_ptr< _Yp, _Lp>  &__r) noexcept : _M_ptr(((__r._M_ptr))), _M_refcount((__r._M_refcount)) 
# 1174
{ } 
# 1176
__shared_ptr(__shared_ptr &&__r) noexcept : _M_ptr(__r._M_ptr), _M_refcount() 
# 1178
{ 
# 1179
(_M_refcount)._M_swap(__r._M_refcount); 
# 1180
(__r._M_ptr) = 0; 
# 1181
} 
# 1183
template< class _Yp, class  = _Compatible< _Yp> > 
# 1184
__shared_ptr(__shared_ptr< _Yp, _Lp>  &&__r) noexcept : _M_ptr(((__r._M_ptr))), _M_refcount() 
# 1186
{ 
# 1187
(_M_refcount)._M_swap((__r._M_refcount)); 
# 1188
(__r._M_ptr) = 0; 
# 1189
} 
# 1191
template< class _Yp, class  = _Compatible< _Yp> > explicit 
# 1192
__shared_ptr(const __weak_ptr< _Yp, _Lp>  &__r) : _M_refcount((__r._M_refcount)) 
# 1194
{ 
# 1197
(_M_ptr) = (__r._M_ptr); 
# 1198
} 
# 1201
template< class _Yp, class _Del, class 
# 1202
 = _UniqCompatible< _Yp, _Del> > 
# 1203
__shared_ptr(unique_ptr< _Yp, _Del>  &&__r) : _M_ptr(__r.get()), _M_refcount() 
# 1205
{ 
# 1206
auto __raw = __to_address(__r.get()); 
# 1207
(_M_refcount) = ((__shared_count< _Lp> )(std::move(__r))); 
# 1208
_M_enable_shared_from_this_with(__raw); 
# 1209
} 
# 1219
protected: 
# 1214
template< class _Tp1, class _Del, typename enable_if< __and_< __not_< is_array< _Tp> > , is_array< _Tp1> , is_convertible< typename unique_ptr< _Tp1, _Del> ::pointer, _Tp *> > ::value, bool> ::type 
# 1218
 = true> 
# 1219
__shared_ptr(unique_ptr< _Tp1, _Del>  &&__r, std::__sp_array_delete) : _M_ptr(__r.get()), _M_refcount() 
# 1221
{ 
# 1222
auto __raw = __to_address(__r.get()); 
# 1223
(_M_refcount) = ((__shared_count< _Lp> )(std::move(__r))); 
# 1224
_M_enable_shared_from_this_with(__raw); 
# 1225
} 
# 1230
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 1233
public: template< class _Yp, class  = _Compatible< _Yp> > inline __shared_ptr(auto_ptr< _Yp>  && __r); 
# 1235
#pragma GCC diagnostic pop
# 1238
constexpr __shared_ptr(std::nullptr_t) noexcept : __shared_ptr() { } 
# 1240
template< class _Yp> _Assignable< _Yp>  
# 1242
operator=(const __shared_ptr< _Yp, _Lp>  &__r) noexcept 
# 1243
{ 
# 1244
(_M_ptr) = (__r._M_ptr); 
# 1245
(_M_refcount) = (__r._M_refcount); 
# 1246
return *this; 
# 1247
} 
# 1250
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template< class _Yp> _Assignable< _Yp>  
# 1254
operator=(auto_ptr< _Yp>  &&__r) 
# 1255
{ 
# 1256
((__shared_ptr)(std::move(__r))).swap(*this); 
# 1257
return *this; 
# 1258
} 
#pragma GCC diagnostic pop
# 1263
__shared_ptr &operator=(__shared_ptr &&__r) noexcept 
# 1264
{ 
# 1265
((__shared_ptr)(std::move(__r))).swap(*this); 
# 1266
return *this; 
# 1267
} 
# 1269
template< class _Yp> _Assignable< _Yp>  
# 1271
operator=(__shared_ptr< _Yp, _Lp>  &&__r) noexcept 
# 1272
{ 
# 1273
((__shared_ptr)(std::move(__r))).swap(*this); 
# 1274
return *this; 
# 1275
} 
# 1277
template< class _Yp, class _Del> _UniqAssignable< _Yp, _Del>  
# 1279
operator=(unique_ptr< _Yp, _Del>  &&__r) 
# 1280
{ 
# 1281
((__shared_ptr)(std::move(__r))).swap(*this); 
# 1282
return *this; 
# 1283
} 
# 1286
void reset() noexcept 
# 1287
{ __shared_ptr().swap(*this); } 
# 1289
template< class _Yp> _SafeConv< _Yp>  
# 1291
reset(_Yp *__p) 
# 1292
{ 
# 1294
; 
# 1295
((__shared_ptr)(__p)).swap(*this); 
# 1296
} 
# 1298
template< class _Yp, class _Deleter> _SafeConv< _Yp>  
# 1300
reset(_Yp *__p, _Deleter __d) 
# 1301
{ __shared_ptr(__p, std::move(__d)).swap(*this); } 
# 1303
template< class _Yp, class _Deleter, class _Alloc> _SafeConv< _Yp>  
# 1305
reset(_Yp *__p, _Deleter __d, _Alloc __a) 
# 1306
{ __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); } 
# 1309
element_type *get() const noexcept 
# 1310
{ return _M_ptr; } 
# 1312
explicit operator bool() const 
# 1313
{ return ((_M_ptr) == 0) ? false : true; } 
# 1316
bool unique() const noexcept 
# 1317
{ return (_M_refcount)._M_unique(); } 
# 1320
long use_count() const noexcept 
# 1321
{ return (_M_refcount)._M_get_use_count(); } 
# 1324
void swap(__shared_ptr &__other) noexcept 
# 1325
{ 
# 1326
std::swap(_M_ptr, __other._M_ptr); 
# 1327
(_M_refcount)._M_swap(__other._M_refcount); 
# 1328
} 
# 1330
template< class _Tp1> bool 
# 1332
owner_before(const __shared_ptr< _Tp1, _Lp>  &__rhs) const noexcept 
# 1333
{ return (_M_refcount)._M_less((__rhs._M_refcount)); } 
# 1335
template< class _Tp1> bool 
# 1337
owner_before(const __weak_ptr< _Tp1, _Lp>  &__rhs) const noexcept 
# 1338
{ return (_M_refcount)._M_less((__rhs._M_refcount)); } 
# 1343
protected: 
# 1342
template< class _Alloc, class ..._Args> 
# 1343
__shared_ptr(_Sp_alloc_shared_tag< _Alloc>  __tag, _Args &&...__args) : _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward< _Args> (__args)...) 
# 1345
{ _M_enable_shared_from_this_with(_M_ptr); } 
# 1347
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1, class _Alloc, class ...
# 1348
_Args> friend __shared_ptr< _Tp1, _Lp1>  
# 1347
__allocate_shared(const _Alloc & __a, _Args && ...__args); 
# 1354
__shared_ptr(const __weak_ptr< _Tp, _Lp>  &__r, std::nothrow_t) : _M_refcount((__r._M_refcount), std::nothrow) 
# 1356
{ 
# 1357
(_M_ptr) = (((_M_refcount)._M_get_use_count()) ? __r._M_ptr : nullptr); 
# 1358
} 
# 1360
friend class __weak_ptr< _Tp, _Lp> ; 
# 1365
private: 
# 1364
template< class _Yp> using __esft_base_t = __decltype((__enable_shared_from_this_base(std::declval< const __shared_count< _Lp>  &> (), std::declval< _Yp *> ()))); 
# 1370
template< class _Yp, class  = void> 
# 1371
struct __has_esft_base : public std::false_type { 
# 1372
}; 
# 1374
template< class _Yp> 
# 1375
struct __has_esft_base< _Yp, std::__void_t< __esft_base_t< _Yp> > >  : public __not_< is_array< _Tp> >  { 
# 1376
}; 
# 1378
template< class _Yp, class _Yp2 = typename remove_cv< _Yp> ::type> typename enable_if< __has_esft_base< _Yp2> ::value> ::type 
# 1380
_M_enable_shared_from_this_with(_Yp *__p) noexcept 
# 1381
{ 
# 1382
if (auto __base = __enable_shared_from_this_base(_M_refcount, __p)) { 
# 1383
(__base->_M_weak_assign)(const_cast< _Yp2 *>(__p), _M_refcount); }  
# 1384
} 
# 1386
template< class _Yp, class _Yp2 = typename remove_cv< _Yp> ::type> typename enable_if< !__has_esft_base< _Yp2> ::value> ::type 
# 1388
_M_enable_shared_from_this_with(_Yp *) noexcept 
# 1389
{ } 
# 1392
void *_M_get_deleter(const std::type_info &__ti) const noexcept 
# 1393
{ return (_M_refcount)._M_get_deleter(__ti); } 
# 1395
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend class __shared_ptr; 
# 1396
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend class __weak_ptr; 
# 1398
template< class _Del, class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend _Del *get_deleter(const std::__shared_ptr< _Tp1, _Lp1>  &) noexcept; 
# 1401
template< class _Del, class _Tp1> friend _Del *get_deleter(const std::shared_ptr< _Tp1>  &) noexcept; 
# 1404
element_type *_M_ptr; 
# 1405
__shared_count< _Lp>  _M_refcount; 
# 1406
}; 
# 1410
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1412
operator==(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1413
__b) noexcept 
# 1414
{ return __a.get() == __b.get(); } 
# 1416
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1418
operator==(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1419
{ return !__a; } 
# 1421
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1423
operator==(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1424
{ return !__a; } 
# 1426
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1428
operator!=(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1429
__b) noexcept 
# 1430
{ return __a.get() != __b.get(); } 
# 1432
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1434
operator!=(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1435
{ return (bool)__a; } 
# 1437
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1439
operator!=(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1440
{ return (bool)__a; } 
# 1442
template< class _Tp, class _Up, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1444
operator<(const __shared_ptr< _Tp, _Lp>  &__a, const __shared_ptr< _Up, _Lp>  &
# 1445
__b) noexcept 
# 1446
{ 
# 1447
using _Tp_elt = typename __shared_ptr< _Tp, _Lp> ::element_type; 
# 1448
using _Up_elt = typename __shared_ptr< _Up, _Lp> ::element_type; 
# 1449
using _Vp = typename common_type< typename __shared_ptr< _Tp, _Lp> ::element_type *, typename __shared_ptr< _Up, _Lp> ::element_type *> ::type; 
# 1450
return less< typename common_type< typename __shared_ptr< _Tp, _Lp> ::element_type *, typename __shared_ptr< _Up, _Lp> ::element_type *> ::type> ()(__a.get(), __b.get()); 
# 1451
} 
# 1453
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1455
operator<(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1456
{ 
# 1457
using _Tp_elt = typename __shared_ptr< _Tp, _Lp> ::element_type; 
# 1458
return less< typename __shared_ptr< _Tp, _Lp> ::element_type *> ()(__a.get(), nullptr); 
# 1459
} 
# 1461
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1463
operator<(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1464
{ 
# 1465
using _Tp_elt = typename __shared_ptr< _Tp, _Lp> ::element_type; 
# 1466
return less< typename __shared_ptr< _Tp, _Lp> ::element_type *> ()(nullptr, __a.get()); 
# 1467
} 
# 1469
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1471
operator<=(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1472
__b) noexcept 
# 1473
{ return !(__b < __a); } 
# 1475
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1477
operator<=(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1478
{ return !(nullptr < __a); } 
# 1480
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1482
operator<=(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1483
{ return !(__a < nullptr); } 
# 1485
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1487
operator>(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1488
__b) noexcept 
# 1489
{ return (__b < __a); } 
# 1491
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1493
operator>(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1494
{ return nullptr < __a; } 
# 1496
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1498
operator>(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1499
{ return __a < nullptr; } 
# 1501
template< class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1503
operator>=(const __shared_ptr< _Tp1, _Lp>  &__a, const __shared_ptr< _Tp2, _Lp>  &
# 1504
__b) noexcept 
# 1505
{ return !(__a < __b); } 
# 1507
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1509
operator>=(const __shared_ptr< _Tp, _Lp>  &__a, nullptr_t) noexcept 
# 1510
{ return !(__a < nullptr); } 
# 1512
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 1514
operator>=(nullptr_t, const __shared_ptr< _Tp, _Lp>  &__a) noexcept 
# 1515
{ return !(nullptr < __a); } 
# 1518
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline void 
# 1520
swap(__shared_ptr< _Tp, _Lp>  &__a, __shared_ptr< _Tp, _Lp>  &__b) noexcept 
# 1521
{ __a.swap(__b); } 
# 1530 "/usr/include/c++/9/bits/shared_ptr_base.h" 3
template< class _Tp, class _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 1532
static_pointer_cast(const __shared_ptr< _Tp1, _Lp>  &__r) noexcept 
# 1533
{ 
# 1534
using _Sp = __shared_ptr< _Tp, _Lp> ; 
# 1535
return _Sp(__r, static_cast< typename __shared_ptr< _Tp, _Lp> ::element_type *>(__r.get())); 
# 1536
} 
# 1543
template< class _Tp, class _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 1545
const_pointer_cast(const __shared_ptr< _Tp1, _Lp>  &__r) noexcept 
# 1546
{ 
# 1547
using _Sp = __shared_ptr< _Tp, _Lp> ; 
# 1548
return _Sp(__r, const_cast< typename __shared_ptr< _Tp, _Lp> ::element_type *>(__r.get())); 
# 1549
} 
# 1556
template< class _Tp, class _Tp1, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 1558
dynamic_pointer_cast(const __shared_ptr< _Tp1, _Lp>  &__r) noexcept 
# 1559
{ 
# 1560
using _Sp = __shared_ptr< _Tp, _Lp> ; 
# 1561
if (auto *__p = dynamic_cast< typename __shared_ptr< _Tp, _Lp> ::element_type *>(__r.get())) { 
# 1562
return _Sp(__r, __p); }  
# 1563
return _Sp(); 
# 1564
} 
# 1576 "/usr/include/c++/9/bits/shared_ptr_base.h" 3
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1577
class __weak_ptr { 
# 1579
template< class _Yp, class _Res = void> using _Compatible = typename enable_if< __sp_compatible_with< _Yp *, _Tp *> ::value, _Res> ::type; 
# 1584
template< class _Yp> using _Assignable = _Compatible< _Yp, __weak_ptr &> ; 
# 1588
public: using element_type = typename remove_extent< _Tp> ::type; 
# 1590
constexpr __weak_ptr() noexcept : _M_ptr((nullptr)), _M_refcount() 
# 1592
{ } 
# 1594
__weak_ptr(const __weak_ptr &) noexcept = default;
# 1596
~__weak_ptr() = default;
# 1612 "/usr/include/c++/9/bits/shared_ptr_base.h" 3
template< class _Yp, class  = _Compatible< _Yp> > 
# 1613
__weak_ptr(const __weak_ptr< _Yp, _Lp>  &__r) noexcept : _M_refcount((__r._M_refcount)) 
# 1615
{ (_M_ptr) = __r.lock().get(); } 
# 1617
template< class _Yp, class  = _Compatible< _Yp> > 
# 1618
__weak_ptr(const __shared_ptr< _Yp, _Lp>  &__r) noexcept : _M_ptr(((__r._M_ptr))), _M_refcount((__r._M_refcount)) 
# 1620
{ } 
# 1622
__weak_ptr(__weak_ptr &&__r) noexcept : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount)) 
# 1624
{ (__r._M_ptr) = nullptr; } 
# 1626
template< class _Yp, class  = _Compatible< _Yp> > 
# 1627
__weak_ptr(__weak_ptr< _Yp, _Lp>  &&__r) noexcept : _M_ptr(__r.lock().get()), _M_refcount(std::move((__r._M_refcount))) 
# 1629
{ (__r._M_ptr) = nullptr; } 
# 1632
__weak_ptr &operator=(const __weak_ptr & __r) noexcept = default;
# 1634
template< class _Yp> _Assignable< _Yp>  
# 1636
operator=(const __weak_ptr< _Yp, _Lp>  &__r) noexcept 
# 1637
{ 
# 1638
(_M_ptr) = __r.lock().get(); 
# 1639
(_M_refcount) = (__r._M_refcount); 
# 1640
return *this; 
# 1641
} 
# 1643
template< class _Yp> _Assignable< _Yp>  
# 1645
operator=(const __shared_ptr< _Yp, _Lp>  &__r) noexcept 
# 1646
{ 
# 1647
(_M_ptr) = (__r._M_ptr); 
# 1648
(_M_refcount) = (__r._M_refcount); 
# 1649
return *this; 
# 1650
} 
# 1653
__weak_ptr &operator=(__weak_ptr &&__r) noexcept 
# 1654
{ 
# 1655
(_M_ptr) = (__r._M_ptr); 
# 1656
(_M_refcount) = std::move(__r._M_refcount); 
# 1657
(__r._M_ptr) = nullptr; 
# 1658
return *this; 
# 1659
} 
# 1661
template< class _Yp> _Assignable< _Yp>  
# 1663
operator=(__weak_ptr< _Yp, _Lp>  &&__r) noexcept 
# 1664
{ 
# 1665
(_M_ptr) = __r.lock().get(); 
# 1666
(_M_refcount) = std::move((__r._M_refcount)); 
# 1667
(__r._M_ptr) = nullptr; 
# 1668
return *this; 
# 1669
} 
# 1672
__shared_ptr< _Tp, _Lp>  lock() const noexcept 
# 1673
{ return __shared_ptr< element_type, _Lp> (*this, std::nothrow); } 
# 1676
long use_count() const noexcept 
# 1677
{ return (_M_refcount)._M_get_use_count(); } 
# 1680
bool expired() const noexcept 
# 1681
{ return (_M_refcount)._M_get_use_count() == 0; } 
# 1683
template< class _Tp1> bool 
# 1685
owner_before(const __shared_ptr< _Tp1, _Lp>  &__rhs) const noexcept 
# 1686
{ return (_M_refcount)._M_less((__rhs._M_refcount)); } 
# 1688
template< class _Tp1> bool 
# 1690
owner_before(const __weak_ptr< _Tp1, _Lp>  &__rhs) const noexcept 
# 1691
{ return (_M_refcount)._M_less((__rhs._M_refcount)); } 
# 1694
void reset() noexcept 
# 1695
{ __weak_ptr().swap(*this); } 
# 1698
void swap(__weak_ptr &__s) noexcept 
# 1699
{ 
# 1700
std::swap(_M_ptr, __s._M_ptr); 
# 1701
(_M_refcount)._M_swap(__s._M_refcount); 
# 1702
} 
# 1707
private: void _M_assign(_Tp *__ptr, const __shared_count< _Lp>  &__refcount) noexcept 
# 1708
{ 
# 1709
if (use_count() == 0) 
# 1710
{ 
# 1711
(_M_ptr) = __ptr; 
# 1712
(_M_refcount) = __refcount; 
# 1713
}  
# 1714
} 
# 1716
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend class __shared_ptr; 
# 1717
template< class _Tp1, __gnu_cxx::_Lock_policy _Lp1> friend class __weak_ptr; 
# 1718
friend class __enable_shared_from_this< _Tp, _Lp> ; 
# 1719
friend class enable_shared_from_this< _Tp> ; 
# 1721
element_type *_M_ptr; 
# 1722
__weak_count< _Lp>  _M_refcount; 
# 1723
}; 
# 1726
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline void 
# 1728
swap(__weak_ptr< _Tp, _Lp>  &__a, __weak_ptr< _Tp, _Lp>  &__b) noexcept 
# 1729
{ __a.swap(__b); } 
# 1731
template< class _Tp, class _Tp1> 
# 1732
struct _Sp_owner_less : public binary_function< _Tp, _Tp, bool>  { 
# 1735
bool operator()(const _Tp &__lhs, const _Tp &__rhs) const noexcept 
# 1736
{ return __lhs.owner_before(__rhs); } 
# 1739
bool operator()(const _Tp &__lhs, const _Tp1 &__rhs) const noexcept 
# 1740
{ return __lhs.owner_before(__rhs); } 
# 1743
bool operator()(const _Tp1 &__lhs, const _Tp &__rhs) const noexcept 
# 1744
{ return __lhs.owner_before(__rhs); } 
# 1745
}; 
# 1748
template<> struct _Sp_owner_less< void, void>  { 
# 1750
template< class _Tp, class _Up> auto 
# 1752
operator()(const _Tp &__lhs, const _Up &__rhs) const noexcept->__decltype((__lhs.owner_before(__rhs))) 
# 1754
{ return __lhs.owner_before(__rhs); } 
# 1756
using is_transparent = void; 
# 1757
}; 
# 1759
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1760
struct owner_less< __shared_ptr< _Tp, _Lp> >  : public _Sp_owner_less< __shared_ptr< _Tp, _Lp> , __weak_ptr< _Tp, _Lp> >  { 
# 1762
}; 
# 1764
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1765
struct owner_less< __weak_ptr< _Tp, _Lp> >  : public _Sp_owner_less< __weak_ptr< _Tp, _Lp> , __shared_ptr< _Tp, _Lp> >  { 
# 1767
}; 
# 1770
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1771
class __enable_shared_from_this { 
# 1774
protected: constexpr __enable_shared_from_this() noexcept { } 
# 1776
__enable_shared_from_this(const __enable_shared_from_this &) noexcept { } 
# 1779
__enable_shared_from_this &operator=(const __enable_shared_from_this &) noexcept 
# 1780
{ return *this; } 
# 1782
~__enable_shared_from_this() { } 
# 1786
public: __shared_ptr< _Tp, _Lp>  shared_from_this() 
# 1787
{ return ((__shared_ptr< _Tp, _Lp> )(this->_M_weak_this)); } 
# 1790
__shared_ptr< const _Tp, _Lp>  shared_from_this() const 
# 1791
{ return ((__shared_ptr< const _Tp, _Lp> )(this->_M_weak_this)); } 
# 1795
__weak_ptr< _Tp, _Lp>  weak_from_this() noexcept 
# 1796
{ return this->_M_weak_this; } 
# 1799
__weak_ptr< const _Tp, _Lp>  weak_from_this() const noexcept 
# 1800
{ return this->_M_weak_this; } 
# 1806
private: 
# 1804
template< class _Tp1> void 
# 1806
_M_weak_assign(_Tp1 *__p, const __shared_count< _Lp>  &__n) const noexcept 
# 1807
{ (_M_weak_this)._M_assign(__p, __n); } 
# 1810
friend inline const __enable_shared_from_this *__enable_shared_from_this_base(const std::__shared_count< _Lp>  &, const __enable_shared_from_this< _Tp, _Lp>  *
# 1811
__p) 
# 1812
{ return __p; } 
# 1814
template< class , __gnu_cxx::_Lock_policy > friend class __shared_ptr; 
# 1817
mutable __weak_ptr< _Tp, _Lp>  _M_weak_this; 
# 1818
}; 
# 1820
template< class _Tp, __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic, class 
# 1821
_Alloc, class ..._Args> inline __shared_ptr< _Tp, _Lp>  
# 1823
__allocate_shared(const _Alloc &__a, _Args &&...__args) 
# 1824
{ 
# 1825
return __shared_ptr< _Tp, _Lp> (_Sp_alloc_shared_tag< _Alloc> {__a}, std::forward< _Args> (__args)...); 
# 1827
} 
# 1829
template< class _Tp, __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic, class ...
# 1830
_Args> inline __shared_ptr< _Tp, _Lp>  
# 1832
__make_shared(_Args &&...__args) 
# 1833
{ 
# 1834
typedef typename remove_const< _Tp> ::type _Tp_nc; 
# 1835
return std::__allocate_shared< _Tp, _Lp> (allocator< typename remove_const< _Tp> ::type> (), std::forward< _Args> (__args)...); 
# 1837
} 
# 1840
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 1841
struct hash< __shared_ptr< _Tp, _Lp> >  : public __hash_base< unsigned long, __shared_ptr< _Tp, _Lp> >  { 
# 1845
std::size_t operator()(const __shared_ptr< _Tp, _Lp>  &__s) const noexcept 
# 1846
{ 
# 1847
return std::hash< typename __shared_ptr< _Tp, _Lp> ::element_type *> ()(__s.get()); 
# 1849
} 
# 1850
}; 
# 1853
}
# 54 "/usr/include/c++/9/bits/shared_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 64
template< class _Ch, class _Tr, class _Tp, __gnu_cxx::_Lock_policy _Lp> inline basic_ostream< _Ch, _Tr>  &
# 66
operator<<(basic_ostream< _Ch, _Tr>  &__os, const __shared_ptr< _Tp, _Lp>  &
# 67
__p) 
# 68
{ 
# 69
__os << __p.get(); 
# 70
return __os; 
# 71
} 
# 73
template< class _Del, class _Tp, __gnu_cxx::_Lock_policy _Lp> inline _Del *
# 75
get_deleter(const __shared_ptr< _Tp, _Lp>  &__p) noexcept 
# 76
{ 
# 78
return static_cast< _Del *>(__p._M_get_deleter(typeid(_Del))); 
# 82
} 
# 85
template< class _Del, class _Tp> inline _Del *
# 87
get_deleter(const shared_ptr< _Tp>  &__p) noexcept 
# 88
{ 
# 90
return static_cast< _Del *>(__p._M_get_deleter(typeid(_Del))); 
# 94
} 
# 102
template< class _Tp> 
# 103
class shared_ptr : public __shared_ptr< _Tp>  { 
# 105
template< class ..._Args> using _Constructible = typename enable_if< is_constructible< __shared_ptr< _Tp> , _Args...> ::value> ::type; 
# 110
template< class _Arg> using _Assignable = typename enable_if< is_assignable< __shared_ptr< _Tp>  &, _Arg> ::value, shared_ptr &> ::type; 
# 117
public: using element_type = typename __shared_ptr< _Tp> ::element_type; 
# 127 "/usr/include/c++/9/bits/shared_ptr.h" 3
constexpr shared_ptr() noexcept : __shared_ptr< _Tp> () { } 
# 129
shared_ptr(const shared_ptr &) noexcept = default;
# 137
template< class _Yp, class  = _Constructible< _Yp *> > explicit 
# 139
shared_ptr(_Yp *__p) : __shared_ptr< _Tp> (__p) { } 
# 154 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Yp, class _Deleter, class 
# 155
 = _Constructible< _Yp *, _Deleter> > 
# 156
shared_ptr(_Yp *__p, _Deleter __d) : __shared_ptr< _Tp> (__p, std::move(__d)) 
# 157
{ } 
# 172 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Deleter> 
# 173
shared_ptr(std::nullptr_t __p, _Deleter __d) : __shared_ptr< _Tp> (__p, std::move(__d)) 
# 174
{ } 
# 191 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Yp, class _Deleter, class _Alloc, class 
# 192
 = _Constructible< _Yp *, _Deleter, _Alloc> > 
# 193
shared_ptr(_Yp *__p, _Deleter __d, _Alloc __a) : __shared_ptr< _Tp> (__p, std::move(__d), std::move(__a)) 
# 194
{ } 
# 211 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Deleter, class _Alloc> 
# 212
shared_ptr(std::nullptr_t __p, _Deleter __d, _Alloc __a) : __shared_ptr< _Tp> (__p, std::move(__d), std::move(__a)) 
# 213
{ } 
# 233 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Yp> 
# 234
shared_ptr(const shared_ptr< _Yp>  &__r, element_type *__p) noexcept : __shared_ptr< _Tp> (__r, __p) 
# 235
{ } 
# 244 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Yp, class 
# 245
 = _Constructible< const shared_ptr< _Yp>  &> > 
# 246
shared_ptr(const shared_ptr< _Yp>  &__r) noexcept : __shared_ptr< _Tp> (__r) 
# 247
{ } 
# 254
shared_ptr(shared_ptr &&__r) noexcept : __shared_ptr< _Tp> (std::move(__r)) 
# 255
{ } 
# 262
template< class _Yp, class  = _Constructible< shared_ptr< _Yp> > > 
# 263
shared_ptr(shared_ptr< _Yp>  &&__r) noexcept : __shared_ptr< _Tp> (std::move(__r)) 
# 264
{ } 
# 274 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Yp, class  = _Constructible< const weak_ptr< _Yp>  &> > explicit 
# 275
shared_ptr(const weak_ptr< _Yp>  &__r) : __shared_ptr< _Tp> (__r) 
# 276
{ } 
# 279
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template< class _Yp, class  = _Constructible< auto_ptr< _Yp> > > inline shared_ptr(auto_ptr< _Yp>  && __r); 
# 283
#pragma GCC diagnostic pop
# 288
template< class _Yp, class _Del, class 
# 289
 = _Constructible< unique_ptr< _Yp, _Del> > > 
# 290
shared_ptr(unique_ptr< _Yp, _Del>  &&__r) : __shared_ptr< _Tp> (std::move(__r)) 
# 291
{ } 
# 297
template< class _Yp, class _Del, _Constructible< unique_ptr< _Yp, _Del> , std::__sp_array_delete>  *
# 298
 = 0> 
# 299
shared_ptr(unique_ptr< _Yp, _Del>  &&__r) : __shared_ptr< _Tp> (std::move(__r), std::__sp_array_delete()) 
# 300
{ } 
# 307
constexpr shared_ptr(std::nullptr_t) noexcept : shared_ptr() { } 
# 309
shared_ptr &operator=(const shared_ptr &) noexcept = default;
# 311
template< class _Yp> _Assignable< const shared_ptr< _Yp>  &>  
# 313
operator=(const shared_ptr< _Yp>  &__r) noexcept 
# 314
{ 
# 315
this->__shared_ptr< _Tp> ::operator=(__r); 
# 316
return *this; 
# 317
} 
# 320
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template< class _Yp> _Assignable< auto_ptr< _Yp> >  
# 324
operator=(auto_ptr< _Yp>  &&__r) 
# 325
{ 
# 326
this->__shared_ptr< _Tp> ::operator=(std::move(__r)); 
# 327
return *this; 
# 328
} 
#pragma GCC diagnostic pop
# 333
shared_ptr &operator=(shared_ptr &&__r) noexcept 
# 334
{ 
# 335
this->__shared_ptr< _Tp> ::operator=(std::move(__r)); 
# 336
return *this; 
# 337
} 
# 339
template< class _Yp> _Assignable< shared_ptr< _Yp> >  
# 341
operator=(shared_ptr< _Yp>  &&__r) noexcept 
# 342
{ 
# 343
this->__shared_ptr< _Tp> ::operator=(std::move(__r)); 
# 344
return *this; 
# 345
} 
# 347
template< class _Yp, class _Del> _Assignable< unique_ptr< _Yp, _Del> >  
# 349
operator=(unique_ptr< _Yp, _Del>  &&__r) 
# 350
{ 
# 351
this->__shared_ptr< _Tp> ::operator=(std::move(__r)); 
# 352
return *this; 
# 353
} 
# 358
private: 
# 357
template< class _Alloc, class ..._Args> 
# 358
shared_ptr(_Sp_alloc_shared_tag< _Alloc>  __tag, _Args &&...__args) : __shared_ptr< _Tp> (__tag, std::forward< _Args> (__args)...) 
# 360
{ } 
# 362
template< class _Yp, class _Alloc, class ..._Args> friend shared_ptr< _Yp>  allocate_shared(const _Alloc & __a, _Args && ...__args); 
# 367
shared_ptr(const weak_ptr< _Tp>  &__r, std::nothrow_t) : __shared_ptr< _Tp> (__r, std::nothrow) 
# 368
{ } 
# 370
friend class weak_ptr< _Tp> ; 
# 371
}; 
# 381 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Tp, class _Up> inline bool 
# 383
operator==(const shared_ptr< _Tp>  &__a, const shared_ptr< _Up>  &__b) noexcept 
# 384
{ return __a.get() == __b.get(); } 
# 386
template< class _Tp> inline bool 
# 388
operator==(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 389
{ return !__a; } 
# 391
template< class _Tp> inline bool 
# 393
operator==(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 394
{ return !__a; } 
# 396
template< class _Tp, class _Up> inline bool 
# 398
operator!=(const shared_ptr< _Tp>  &__a, const shared_ptr< _Up>  &__b) noexcept 
# 399
{ return __a.get() != __b.get(); } 
# 401
template< class _Tp> inline bool 
# 403
operator!=(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 404
{ return (bool)__a; } 
# 406
template< class _Tp> inline bool 
# 408
operator!=(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 409
{ return (bool)__a; } 
# 411
template< class _Tp, class _Up> inline bool 
# 413
operator<(const shared_ptr< _Tp>  &__a, const shared_ptr< _Up>  &__b) noexcept 
# 414
{ 
# 415
using _Tp_elt = typename shared_ptr< _Tp> ::element_type; 
# 416
using _Up_elt = typename shared_ptr< _Up> ::element_type; 
# 417
using _Vp = typename common_type< typename shared_ptr< _Tp> ::element_type *, typename shared_ptr< _Up> ::element_type *> ::type; 
# 418
return less< typename common_type< typename shared_ptr< _Tp> ::element_type *, typename shared_ptr< _Up> ::element_type *> ::type> ()(__a.get(), __b.get()); 
# 419
} 
# 421
template< class _Tp> inline bool 
# 423
operator<(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 424
{ 
# 425
using _Tp_elt = typename shared_ptr< _Tp> ::element_type; 
# 426
return less< typename shared_ptr< _Tp> ::element_type *> ()(__a.get(), nullptr); 
# 427
} 
# 429
template< class _Tp> inline bool 
# 431
operator<(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 432
{ 
# 433
using _Tp_elt = typename shared_ptr< _Tp> ::element_type; 
# 434
return less< typename shared_ptr< _Tp> ::element_type *> ()(nullptr, __a.get()); 
# 435
} 
# 437
template< class _Tp, class _Up> inline bool 
# 439
operator<=(const shared_ptr< _Tp>  &__a, const shared_ptr< _Up>  &__b) noexcept 
# 440
{ return !(__b < __a); } 
# 442
template< class _Tp> inline bool 
# 444
operator<=(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 445
{ return !(nullptr < __a); } 
# 447
template< class _Tp> inline bool 
# 449
operator<=(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 450
{ return !(__a < nullptr); } 
# 452
template< class _Tp, class _Up> inline bool 
# 454
operator>(const shared_ptr< _Tp>  &__a, const shared_ptr< _Up>  &__b) noexcept 
# 455
{ return (__b < __a); } 
# 457
template< class _Tp> inline bool 
# 459
operator>(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 460
{ return nullptr < __a; } 
# 462
template< class _Tp> inline bool 
# 464
operator>(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 465
{ return __a < nullptr; } 
# 467
template< class _Tp, class _Up> inline bool 
# 469
operator>=(const shared_ptr< _Tp>  &__a, const shared_ptr< _Up>  &__b) noexcept 
# 470
{ return !(__a < __b); } 
# 472
template< class _Tp> inline bool 
# 474
operator>=(const shared_ptr< _Tp>  &__a, nullptr_t) noexcept 
# 475
{ return !(__a < nullptr); } 
# 477
template< class _Tp> inline bool 
# 479
operator>=(nullptr_t, const shared_ptr< _Tp>  &__a) noexcept 
# 480
{ return !(nullptr < __a); } 
# 483
template< class _Tp> inline void 
# 485
swap(shared_ptr< _Tp>  &__a, shared_ptr< _Tp>  &__b) noexcept 
# 486
{ __a.swap(__b); } 
# 489
template< class _Tp, class _Up> inline shared_ptr< _Tp>  
# 491
static_pointer_cast(const shared_ptr< _Up>  &__r) noexcept 
# 492
{ 
# 493
using _Sp = shared_ptr< _Tp> ; 
# 494
return _Sp(__r, static_cast< typename shared_ptr< _Tp> ::element_type *>(__r.get())); 
# 495
} 
# 497
template< class _Tp, class _Up> inline shared_ptr< _Tp>  
# 499
const_pointer_cast(const shared_ptr< _Up>  &__r) noexcept 
# 500
{ 
# 501
using _Sp = shared_ptr< _Tp> ; 
# 502
return _Sp(__r, const_cast< typename shared_ptr< _Tp> ::element_type *>(__r.get())); 
# 503
} 
# 505
template< class _Tp, class _Up> inline shared_ptr< _Tp>  
# 507
dynamic_pointer_cast(const shared_ptr< _Up>  &__r) noexcept 
# 508
{ 
# 509
using _Sp = shared_ptr< _Tp> ; 
# 510
if (auto *__p = dynamic_cast< typename shared_ptr< _Tp> ::element_type *>(__r.get())) { 
# 511
return _Sp(__r, __p); }  
# 512
return _Sp(); 
# 513
} 
# 530 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Tp> 
# 531
class weak_ptr : public __weak_ptr< _Tp>  { 
# 533
template< class _Arg> using _Constructible = typename enable_if< is_constructible< __weak_ptr< _Tp> , _Arg> ::value> ::type; 
# 538
template< class _Arg> using _Assignable = typename enable_if< is_assignable< __weak_ptr< _Tp>  &, _Arg> ::value, weak_ptr &> ::type; 
# 544
public: constexpr weak_ptr() noexcept = default;
# 546
template< class _Yp, class 
# 547
 = _Constructible< const shared_ptr< _Yp>  &> > 
# 548
weak_ptr(const shared_ptr< _Yp>  &__r) noexcept : __weak_ptr< _Tp> (__r) 
# 549
{ } 
# 551
weak_ptr(const weak_ptr &) noexcept = default;
# 553
template< class _Yp, class  = _Constructible< const weak_ptr< _Yp>  &> > 
# 554
weak_ptr(const weak_ptr< _Yp>  &__r) noexcept : __weak_ptr< _Tp> (__r) 
# 555
{ } 
# 557
weak_ptr(weak_ptr &&) noexcept = default;
# 559
template< class _Yp, class  = _Constructible< weak_ptr< _Yp> > > 
# 560
weak_ptr(weak_ptr< _Yp>  &&__r) noexcept : __weak_ptr< _Tp> (std::move(__r)) 
# 561
{ } 
# 564
weak_ptr &operator=(const weak_ptr & __r) noexcept = default;
# 566
template< class _Yp> _Assignable< const weak_ptr< _Yp>  &>  
# 568
operator=(const weak_ptr< _Yp>  &__r) noexcept 
# 569
{ 
# 570
this->__weak_ptr< _Tp> ::operator=(__r); 
# 571
return *this; 
# 572
} 
# 574
template< class _Yp> _Assignable< const shared_ptr< _Yp>  &>  
# 576
operator=(const shared_ptr< _Yp>  &__r) noexcept 
# 577
{ 
# 578
this->__weak_ptr< _Tp> ::operator=(__r); 
# 579
return *this; 
# 580
} 
# 583
weak_ptr &operator=(weak_ptr && __r) noexcept = default;
# 585
template< class _Yp> _Assignable< weak_ptr< _Yp> >  
# 587
operator=(weak_ptr< _Yp>  &&__r) noexcept 
# 588
{ 
# 589
this->__weak_ptr< _Tp> ::operator=(std::move(__r)); 
# 590
return *this; 
# 591
} 
# 594
shared_ptr< _Tp>  lock() const noexcept 
# 595
{ return shared_ptr< _Tp> (*this, std::nothrow); } 
# 596
}; 
# 604
template< class _Tp> inline void 
# 606
swap(weak_ptr< _Tp>  &__a, weak_ptr< _Tp>  &__b) noexcept 
# 607
{ __a.swap(__b); } 
# 611
template< class _Tp = void> struct owner_less; 
# 616
template<> struct owner_less< void>  : public _Sp_owner_less< void, void>  { 
# 617
}; 
# 620
template< class _Tp> 
# 621
struct owner_less< shared_ptr< _Tp> >  : public _Sp_owner_less< shared_ptr< _Tp> , weak_ptr< _Tp> >  { 
# 623
}; 
# 626
template< class _Tp> 
# 627
struct owner_less< weak_ptr< _Tp> >  : public _Sp_owner_less< weak_ptr< _Tp> , shared_ptr< _Tp> >  { 
# 629
}; 
# 634
template< class _Tp> 
# 635
class enable_shared_from_this { 
# 638
protected: constexpr enable_shared_from_this() noexcept { } 
# 640
enable_shared_from_this(const enable_shared_from_this &) noexcept { } 
# 643
enable_shared_from_this &operator=(const enable_shared_from_this &) noexcept 
# 644
{ return *this; } 
# 646
~enable_shared_from_this() { } 
# 650
public: shared_ptr< _Tp>  shared_from_this() 
# 651
{ return ((shared_ptr< _Tp> )(this->_M_weak_this)); } 
# 654
shared_ptr< const _Tp>  shared_from_this() const 
# 655
{ return ((shared_ptr< const _Tp> )(this->_M_weak_this)); } 
# 660
weak_ptr< _Tp>  weak_from_this() noexcept 
# 661
{ return this->_M_weak_this; } 
# 664
weak_ptr< const _Tp>  weak_from_this() const noexcept 
# 665
{ return this->_M_weak_this; } 
# 671
private: 
# 669
template< class _Tp1> void 
# 671
_M_weak_assign(_Tp1 *__p, const __shared_count<>  &__n) const noexcept 
# 672
{ (_M_weak_this)._M_assign(__p, __n); } 
# 676
friend inline const enable_shared_from_this *__enable_shared_from_this_base(const std::__shared_count<>  &, const enable_shared_from_this< _Tp>  *
# 677
__p) 
# 678
{ return __p; } 
# 680
template< class , __gnu_cxx::_Lock_policy > friend class __shared_ptr; 
# 683
mutable weak_ptr< _Tp>  _M_weak_this; 
# 684
}; 
# 697 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Tp, class _Alloc, class ..._Args> inline shared_ptr< _Tp>  
# 699
allocate_shared(const _Alloc &__a, _Args &&...__args) 
# 700
{ 
# 701
return shared_ptr< _Tp> (_Sp_alloc_shared_tag< _Alloc> {__a}, std::forward< _Args> (__args)...); 
# 703
} 
# 712 "/usr/include/c++/9/bits/shared_ptr.h" 3
template< class _Tp, class ..._Args> inline shared_ptr< _Tp>  
# 714
make_shared(_Args &&...__args) 
# 715
{ 
# 716
typedef typename remove_cv< _Tp> ::type _Tp_nc; 
# 717
return std::allocate_shared< _Tp> (allocator< typename remove_cv< _Tp> ::type> (), std::forward< _Args> (__args)...); 
# 719
} 
# 722
template< class _Tp> 
# 723
struct hash< shared_ptr< _Tp> >  : public __hash_base< unsigned long, shared_ptr< _Tp> >  { 
# 727
std::size_t operator()(const shared_ptr< _Tp>  &__s) const noexcept 
# 728
{ 
# 729
return std::hash< typename shared_ptr< _Tp> ::element_type *> ()(__s.get()); 
# 730
} 
# 731
}; 
# 757 "/usr/include/c++/9/bits/shared_ptr.h" 3
}
# 43 "/usr/include/c++/9/bits/atomic_base.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 81 "/usr/include/c++/9/bits/atomic_base.h" 3
typedef 
# 73
enum memory_order { 
# 75
memory_order_relaxed, 
# 76
memory_order_consume, 
# 77
memory_order_acquire, 
# 78
memory_order_release, 
# 79
memory_order_acq_rel, 
# 80
memory_order_seq_cst
# 81
} memory_order; 
# 84
enum __memory_order_modifier { 
# 86
__memory_order_mask = 65535U, 
# 87
__memory_order_modifier_mask = 4294901760U, 
# 88
__memory_order_hle_acquire = 65536U, 
# 89
__memory_order_hle_release = 131072U
# 90
}; 
# 93
constexpr memory_order operator|(memory_order __m, __memory_order_modifier __mod) 
# 94
{ 
# 95
return (memory_order)(((int)__m) | ((int)__mod)); 
# 96
} 
# 99
constexpr memory_order operator&(memory_order __m, __memory_order_modifier __mod) 
# 100
{ 
# 101
return (memory_order)(((int)__m) & ((int)__mod)); 
# 102
} 
# 106
constexpr memory_order __cmpexch_failure_order2(memory_order __m) noexcept 
# 107
{ 
# 108
return (__m == (memory_order_acq_rel)) ? memory_order_acquire : ((__m == (memory_order_release)) ? memory_order_relaxed : __m); 
# 110
} 
# 113
constexpr memory_order __cmpexch_failure_order(memory_order __m) noexcept 
# 114
{ 
# 115
return (memory_order)((__cmpexch_failure_order2((__m & (__memory_order_mask)))) | ((__memory_order_modifier)(__m & (__memory_order_modifier_mask)))); 
# 117
} 
# 119
__attribute((__always_inline__)) inline void 
# 120
atomic_thread_fence(memory_order __m) noexcept 
# 121
{ __atomic_thread_fence((int)__m); } 
# 123
__attribute((__always_inline__)) inline void 
# 124
atomic_signal_fence(memory_order __m) noexcept 
# 125
{ __atomic_signal_fence((int)__m); } 
# 128
template< class _Tp> inline _Tp 
# 130
kill_dependency(_Tp __y) noexcept 
# 131
{ 
# 132
_Tp __ret(__y); 
# 133
return __ret; 
# 134
} 
# 138
template< class _IntTp> struct __atomic_base; 
# 144
template< class _Tp> struct atomic; 
# 147
template< class _Tp> struct atomic< _Tp *> ; 
# 152
typedef bool __atomic_flag_data_type; 
# 167 "/usr/include/c++/9/bits/atomic_base.h" 3
extern "C" {
# 169
struct __atomic_flag_base { 
# 171
__atomic_flag_data_type _M_i; 
# 172
}; 
# 174
}
# 179
struct atomic_flag : public __atomic_flag_base { 
# 181
atomic_flag() noexcept = default;
# 182
~atomic_flag() noexcept = default;
# 183
atomic_flag(const atomic_flag &) = delete;
# 184
atomic_flag &operator=(const atomic_flag &) = delete;
# 185
atomic_flag &operator=(const atomic_flag &) volatile = delete;
# 188
constexpr atomic_flag(bool __i) noexcept : __atomic_flag_base{_S_init(__i)} 
# 190
{ } 
# 192
__attribute((__always_inline__)) bool 
# 193
test_and_set(memory_order __m = memory_order_seq_cst) noexcept 
# 194
{ 
# 195
return __atomic_test_and_set(&(_M_i), (int)__m); 
# 196
} 
# 198
__attribute((__always_inline__)) bool 
# 199
test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept 
# 200
{ 
# 201
return __atomic_test_and_set(&(_M_i), (int)__m); 
# 202
} 
# 204
__attribute((__always_inline__)) void 
# 205
clear(memory_order __m = memory_order_seq_cst) noexcept 
# 206
{ 
# 207
memory_order __b = (__m & (__memory_order_mask)); 
# 208
; 
# 209
; 
# 210
; 
# 212
__atomic_clear(&(_M_i), (int)__m); 
# 213
} 
# 215
__attribute((__always_inline__)) void 
# 216
clear(memory_order __m = memory_order_seq_cst) volatile noexcept 
# 217
{ 
# 218
memory_order __b = (__m & (__memory_order_mask)); 
# 219
; 
# 220
; 
# 221
; 
# 223
__atomic_clear(&(_M_i), (int)__m); 
# 224
} 
# 228
private: static constexpr __atomic_flag_data_type _S_init(bool __i) 
# 229
{ return __i ? 1 : 0; } 
# 230
}; 
# 257 "/usr/include/c++/9/bits/atomic_base.h" 3
template< class _ITp> 
# 258
struct __atomic_base { 
# 260
using value_type = _ITp; 
# 261
using difference_type = value_type; 
# 264
private: typedef _ITp __int_type; 
# 266
static constexpr int _S_alignment = ((sizeof(_ITp) > __alignof__(_ITp)) ? sizeof(_ITp) : __alignof__(_ITp)); 
# 269
alignas(_S_alignment) __int_type _M_i; 
# 272
public: __atomic_base() noexcept = default;
# 273
~__atomic_base() noexcept = default;
# 274
__atomic_base(const __atomic_base &) = delete;
# 275
__atomic_base &operator=(const __atomic_base &) = delete;
# 276
__atomic_base &operator=(const __atomic_base &) volatile = delete;
# 279
constexpr __atomic_base(__int_type __i) noexcept : _M_i(__i) { } 
# 281
operator __int_type() const noexcept 
# 282
{ return load(); } 
# 284
operator __int_type() const volatile noexcept 
# 285
{ return load(); } 
# 288
__int_type operator=(__int_type __i) noexcept 
# 289
{ 
# 290
store(__i); 
# 291
return __i; 
# 292
} 
# 295
__int_type operator=(__int_type __i) volatile noexcept 
# 296
{ 
# 297
store(__i); 
# 298
return __i; 
# 299
} 
# 302
__int_type operator++(int) noexcept 
# 303
{ return fetch_add(1); } 
# 306
__int_type operator++(int) volatile noexcept 
# 307
{ return fetch_add(1); } 
# 310
__int_type operator--(int) noexcept 
# 311
{ return fetch_sub(1); } 
# 314
__int_type operator--(int) volatile noexcept 
# 315
{ return fetch_sub(1); } 
# 318
__int_type operator++() noexcept 
# 319
{ return __atomic_add_fetch(&(_M_i), 1, (int)memory_order_seq_cst); } 
# 322
__int_type operator++() volatile noexcept 
# 323
{ return __atomic_add_fetch(&(_M_i), 1, (int)memory_order_seq_cst); } 
# 326
__int_type operator--() noexcept 
# 327
{ return __atomic_sub_fetch(&(_M_i), 1, (int)memory_order_seq_cst); } 
# 330
__int_type operator--() volatile noexcept 
# 331
{ return __atomic_sub_fetch(&(_M_i), 1, (int)memory_order_seq_cst); } 
# 334
__int_type operator+=(__int_type __i) noexcept 
# 335
{ return __atomic_add_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 338
__int_type operator+=(__int_type __i) volatile noexcept 
# 339
{ return __atomic_add_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 342
__int_type operator-=(__int_type __i) noexcept 
# 343
{ return __atomic_sub_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 346
__int_type operator-=(__int_type __i) volatile noexcept 
# 347
{ return __atomic_sub_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 350
__int_type operator&=(__int_type __i) noexcept 
# 351
{ return __atomic_and_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 354
__int_type operator&=(__int_type __i) volatile noexcept 
# 355
{ return __atomic_and_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 358
__int_type operator|=(__int_type __i) noexcept 
# 359
{ return __atomic_or_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 362
__int_type operator|=(__int_type __i) volatile noexcept 
# 363
{ return __atomic_or_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 366
__int_type operator^=(__int_type __i) noexcept 
# 367
{ return __atomic_xor_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 370
__int_type operator^=(__int_type __i) volatile noexcept 
# 371
{ return __atomic_xor_fetch(&(_M_i), __i, (int)memory_order_seq_cst); } 
# 374
bool is_lock_free() const noexcept 
# 375
{ 
# 377
return __atomic_is_lock_free(sizeof((_M_i)), reinterpret_cast< void *>(-_S_alignment)); 
# 379
} 
# 382
bool is_lock_free() const volatile noexcept 
# 383
{ 
# 385
return __atomic_is_lock_free(sizeof((_M_i)), reinterpret_cast< void *>(-_S_alignment)); 
# 387
} 
# 389
__attribute((__always_inline__)) void 
# 390
store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept 
# 391
{ 
# 392
memory_order __b = (__m & (__memory_order_mask)); 
# 393
; 
# 394
; 
# 395
; 
# 397
__atomic_store_n(&(_M_i), __i, (int)__m); 
# 398
} 
# 400
__attribute((__always_inline__)) void 
# 401
store(__int_type __i, memory_order 
# 402
__m = memory_order_seq_cst) volatile noexcept 
# 403
{ 
# 404
memory_order __b = (__m & (__memory_order_mask)); 
# 405
; 
# 406
; 
# 407
; 
# 409
__atomic_store_n(&(_M_i), __i, (int)__m); 
# 410
} 
# 412
__attribute((__always_inline__)) __int_type 
# 413
load(memory_order __m = memory_order_seq_cst) const noexcept 
# 414
{ 
# 415
memory_order __b = (__m & (__memory_order_mask)); 
# 416
; 
# 417
; 
# 419
return __atomic_load_n(&(_M_i), (int)__m); 
# 420
} 
# 422
__attribute((__always_inline__)) __int_type 
# 423
load(memory_order __m = memory_order_seq_cst) const volatile noexcept 
# 424
{ 
# 425
memory_order __b = (__m & (__memory_order_mask)); 
# 426
; 
# 427
; 
# 429
return __atomic_load_n(&(_M_i), (int)__m); 
# 430
} 
# 432
__attribute((__always_inline__)) __int_type 
# 433
exchange(__int_type __i, memory_order 
# 434
__m = memory_order_seq_cst) noexcept 
# 435
{ 
# 436
return __atomic_exchange_n(&(_M_i), __i, (int)__m); 
# 437
} 
# 440
__attribute((__always_inline__)) __int_type 
# 441
exchange(__int_type __i, memory_order 
# 442
__m = memory_order_seq_cst) volatile noexcept 
# 443
{ 
# 444
return __atomic_exchange_n(&(_M_i), __i, (int)__m); 
# 445
} 
# 447
__attribute((__always_inline__)) bool 
# 448
compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order 
# 449
__m1, memory_order __m2) noexcept 
# 450
{ 
# 451
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 452
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 453
; 
# 454
; 
# 455
; 
# 457
return __atomic_compare_exchange_n(&(_M_i), &__i1, __i2, 1, (int)__m1, (int)__m2); 
# 459
} 
# 461
__attribute((__always_inline__)) bool 
# 462
compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order 
# 463
__m1, memory_order 
# 464
__m2) volatile noexcept 
# 465
{ 
# 466
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 467
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 468
; 
# 469
; 
# 470
; 
# 472
return __atomic_compare_exchange_n(&(_M_i), &__i1, __i2, 1, (int)__m1, (int)__m2); 
# 474
} 
# 476
__attribute((__always_inline__)) bool 
# 477
compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order 
# 478
__m = memory_order_seq_cst) noexcept 
# 479
{ 
# 480
return compare_exchange_weak(__i1, __i2, __m, __cmpexch_failure_order(__m)); 
# 482
} 
# 484
__attribute((__always_inline__)) bool 
# 485
compare_exchange_weak(__int_type &__i1, __int_type __i2, memory_order 
# 486
__m = memory_order_seq_cst) volatile noexcept 
# 487
{ 
# 488
return compare_exchange_weak(__i1, __i2, __m, __cmpexch_failure_order(__m)); 
# 490
} 
# 492
__attribute((__always_inline__)) bool 
# 493
compare_exchange_strong(__int_type &__i1, __int_type __i2, memory_order 
# 494
__m1, memory_order __m2) noexcept 
# 495
{ 
# 496
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 497
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 498
; 
# 499
; 
# 500
; 
# 502
return __atomic_compare_exchange_n(&(_M_i), &__i1, __i2, 0, (int)__m1, (int)__m2); 
# 504
} 
# 506
__attribute((__always_inline__)) bool 
# 507
compare_exchange_strong(__int_type &__i1, __int_type __i2, memory_order 
# 508
__m1, memory_order 
# 509
__m2) volatile noexcept 
# 510
{ 
# 511
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 512
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 514
; 
# 515
; 
# 516
; 
# 518
return __atomic_compare_exchange_n(&(_M_i), &__i1, __i2, 0, (int)__m1, (int)__m2); 
# 520
} 
# 522
__attribute((__always_inline__)) bool 
# 523
compare_exchange_strong(__int_type &__i1, __int_type __i2, memory_order 
# 524
__m = memory_order_seq_cst) noexcept 
# 525
{ 
# 526
return compare_exchange_strong(__i1, __i2, __m, __cmpexch_failure_order(__m)); 
# 528
} 
# 530
__attribute((__always_inline__)) bool 
# 531
compare_exchange_strong(__int_type &__i1, __int_type __i2, memory_order 
# 532
__m = memory_order_seq_cst) volatile noexcept 
# 533
{ 
# 534
return compare_exchange_strong(__i1, __i2, __m, __cmpexch_failure_order(__m)); 
# 536
} 
# 538
__attribute((__always_inline__)) __int_type 
# 539
fetch_add(__int_type __i, memory_order 
# 540
__m = memory_order_seq_cst) noexcept 
# 541
{ return __atomic_fetch_add(&(_M_i), __i, (int)__m); } 
# 543
__attribute((__always_inline__)) __int_type 
# 544
fetch_add(__int_type __i, memory_order 
# 545
__m = memory_order_seq_cst) volatile noexcept 
# 546
{ return __atomic_fetch_add(&(_M_i), __i, (int)__m); } 
# 548
__attribute((__always_inline__)) __int_type 
# 549
fetch_sub(__int_type __i, memory_order 
# 550
__m = memory_order_seq_cst) noexcept 
# 551
{ return __atomic_fetch_sub(&(_M_i), __i, (int)__m); } 
# 553
__attribute((__always_inline__)) __int_type 
# 554
fetch_sub(__int_type __i, memory_order 
# 555
__m = memory_order_seq_cst) volatile noexcept 
# 556
{ return __atomic_fetch_sub(&(_M_i), __i, (int)__m); } 
# 558
__attribute((__always_inline__)) __int_type 
# 559
fetch_and(__int_type __i, memory_order 
# 560
__m = memory_order_seq_cst) noexcept 
# 561
{ return __atomic_fetch_and(&(_M_i), __i, (int)__m); } 
# 563
__attribute((__always_inline__)) __int_type 
# 564
fetch_and(__int_type __i, memory_order 
# 565
__m = memory_order_seq_cst) volatile noexcept 
# 566
{ return __atomic_fetch_and(&(_M_i), __i, (int)__m); } 
# 568
__attribute((__always_inline__)) __int_type 
# 569
fetch_or(__int_type __i, memory_order 
# 570
__m = memory_order_seq_cst) noexcept 
# 571
{ return __atomic_fetch_or(&(_M_i), __i, (int)__m); } 
# 573
__attribute((__always_inline__)) __int_type 
# 574
fetch_or(__int_type __i, memory_order 
# 575
__m = memory_order_seq_cst) volatile noexcept 
# 576
{ return __atomic_fetch_or(&(_M_i), __i, (int)__m); } 
# 578
__attribute((__always_inline__)) __int_type 
# 579
fetch_xor(__int_type __i, memory_order 
# 580
__m = memory_order_seq_cst) noexcept 
# 581
{ return __atomic_fetch_xor(&(_M_i), __i, (int)__m); } 
# 583
__attribute((__always_inline__)) __int_type 
# 584
fetch_xor(__int_type __i, memory_order 
# 585
__m = memory_order_seq_cst) volatile noexcept 
# 586
{ return __atomic_fetch_xor(&(_M_i), __i, (int)__m); } 
# 587
}; 
# 591
template< class _PTp> 
# 592
struct __atomic_base< _PTp *>  { 
# 595
private: typedef _PTp *__pointer_type; 
# 597
__pointer_type _M_p; 
# 601
constexpr ptrdiff_t _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); } 
# 604
constexpr ptrdiff_t _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); } 
# 607
public: __atomic_base() noexcept = default;
# 608
~__atomic_base() noexcept = default;
# 609
__atomic_base(const std::__atomic_base< _PTp *>  &) = delete;
# 610
std::__atomic_base< _PTp *>  &operator=(const std::__atomic_base< _PTp *>  &) = delete;
# 611
std::__atomic_base< _PTp *>  &operator=(const std::__atomic_base< _PTp *>  &) volatile = delete;
# 614
constexpr __atomic_base(__pointer_type __p) noexcept : _M_p(__p) { } 
# 616
operator __pointer_type() const noexcept 
# 617
{ return load(); } 
# 619
operator __pointer_type() const volatile noexcept 
# 620
{ return load(); } 
# 623
__pointer_type operator=(__pointer_type __p) noexcept 
# 624
{ 
# 625
store(__p); 
# 626
return __p; 
# 627
} 
# 630
__pointer_type operator=(__pointer_type __p) volatile noexcept 
# 631
{ 
# 632
store(__p); 
# 633
return __p; 
# 634
} 
# 637
__pointer_type operator++(int) noexcept 
# 638
{ return fetch_add(1); } 
# 641
__pointer_type operator++(int) volatile noexcept 
# 642
{ return fetch_add(1); } 
# 645
__pointer_type operator--(int) noexcept 
# 646
{ return fetch_sub(1); } 
# 649
__pointer_type operator--(int) volatile noexcept 
# 650
{ return fetch_sub(1); } 
# 653
__pointer_type operator++() noexcept 
# 654
{ return __atomic_add_fetch(&(_M_p), _M_type_size(1), (int)memory_order_seq_cst); 
# 655
} 
# 658
__pointer_type operator++() volatile noexcept 
# 659
{ return __atomic_add_fetch(&(_M_p), _M_type_size(1), (int)memory_order_seq_cst); 
# 660
} 
# 663
__pointer_type operator--() noexcept 
# 664
{ return __atomic_sub_fetch(&(_M_p), _M_type_size(1), (int)memory_order_seq_cst); 
# 665
} 
# 668
__pointer_type operator--() volatile noexcept 
# 669
{ return __atomic_sub_fetch(&(_M_p), _M_type_size(1), (int)memory_order_seq_cst); 
# 670
} 
# 673
__pointer_type operator+=(ptrdiff_t __d) noexcept 
# 674
{ return __atomic_add_fetch(&(_M_p), _M_type_size(__d), (int)memory_order_seq_cst); 
# 675
} 
# 678
__pointer_type operator+=(ptrdiff_t __d) volatile noexcept 
# 679
{ return __atomic_add_fetch(&(_M_p), _M_type_size(__d), (int)memory_order_seq_cst); 
# 680
} 
# 683
__pointer_type operator-=(ptrdiff_t __d) noexcept 
# 684
{ return __atomic_sub_fetch(&(_M_p), _M_type_size(__d), (int)memory_order_seq_cst); 
# 685
} 
# 688
__pointer_type operator-=(ptrdiff_t __d) volatile noexcept 
# 689
{ return __atomic_sub_fetch(&(_M_p), _M_type_size(__d), (int)memory_order_seq_cst); 
# 690
} 
# 693
bool is_lock_free() const noexcept 
# 694
{ 
# 696
return __atomic_is_lock_free(sizeof((_M_p)), reinterpret_cast< void *>(-__alignof__((_M_p)))); 
# 698
} 
# 701
bool is_lock_free() const volatile noexcept 
# 702
{ 
# 704
return __atomic_is_lock_free(sizeof((_M_p)), reinterpret_cast< void *>(-__alignof__((_M_p)))); 
# 706
} 
# 708
__attribute((__always_inline__)) void 
# 709
store(__pointer_type __p, memory_order 
# 710
__m = memory_order_seq_cst) noexcept 
# 711
{ 
# 712
memory_order __b = (__m & (__memory_order_mask)); 
# 714
; 
# 715
; 
# 716
; 
# 718
__atomic_store_n(&(_M_p), __p, (int)__m); 
# 719
} 
# 721
__attribute((__always_inline__)) void 
# 722
store(__pointer_type __p, memory_order 
# 723
__m = memory_order_seq_cst) volatile noexcept 
# 724
{ 
# 725
memory_order __b = (__m & (__memory_order_mask)); 
# 726
; 
# 727
; 
# 728
; 
# 730
__atomic_store_n(&(_M_p), __p, (int)__m); 
# 731
} 
# 733
__attribute((__always_inline__)) __pointer_type 
# 734
load(memory_order __m = memory_order_seq_cst) const noexcept 
# 735
{ 
# 736
memory_order __b = (__m & (__memory_order_mask)); 
# 737
; 
# 738
; 
# 740
return __atomic_load_n(&(_M_p), (int)__m); 
# 741
} 
# 743
__attribute((__always_inline__)) __pointer_type 
# 744
load(memory_order __m = memory_order_seq_cst) const volatile noexcept 
# 745
{ 
# 746
memory_order __b = (__m & (__memory_order_mask)); 
# 747
; 
# 748
; 
# 750
return __atomic_load_n(&(_M_p), (int)__m); 
# 751
} 
# 753
__attribute((__always_inline__)) __pointer_type 
# 754
exchange(__pointer_type __p, memory_order 
# 755
__m = memory_order_seq_cst) noexcept 
# 756
{ 
# 757
return __atomic_exchange_n(&(_M_p), __p, (int)__m); 
# 758
} 
# 761
__attribute((__always_inline__)) __pointer_type 
# 762
exchange(__pointer_type __p, memory_order 
# 763
__m = memory_order_seq_cst) volatile noexcept 
# 764
{ 
# 765
return __atomic_exchange_n(&(_M_p), __p, (int)__m); 
# 766
} 
# 768
__attribute((__always_inline__)) bool 
# 769
compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2, memory_order 
# 770
__m1, memory_order 
# 771
__m2) noexcept 
# 772
{ 
# 773
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 774
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 775
; 
# 776
; 
# 777
; 
# 779
return __atomic_compare_exchange_n(&(_M_p), &__p1, __p2, 0, (int)__m1, (int)__m2); 
# 781
} 
# 783
__attribute((__always_inline__)) bool 
# 784
compare_exchange_strong(__pointer_type &__p1, __pointer_type __p2, memory_order 
# 785
__m1, memory_order 
# 786
__m2) volatile noexcept 
# 787
{ 
# 788
memory_order __b2 = (__m2 & (__memory_order_mask)); 
# 789
memory_order __b1 = (__m1 & (__memory_order_mask)); 
# 791
; 
# 792
; 
# 793
; 
# 795
return __atomic_compare_exchange_n(&(_M_p), &__p1, __p2, 0, (int)__m1, (int)__m2); 
# 797
} 
# 799
__attribute((__always_inline__)) __pointer_type 
# 800
fetch_add(ptrdiff_t __d, memory_order 
# 801
__m = memory_order_seq_cst) noexcept 
# 802
{ return __atomic_fetch_add(&(_M_p), _M_type_size(__d), (int)__m); } 
# 804
__attribute((__always_inline__)) __pointer_type 
# 805
fetch_add(ptrdiff_t __d, memory_order 
# 806
__m = memory_order_seq_cst) volatile noexcept 
# 807
{ return __atomic_fetch_add(&(_M_p), _M_type_size(__d), (int)__m); } 
# 809
__attribute((__always_inline__)) __pointer_type 
# 810
fetch_sub(ptrdiff_t __d, memory_order 
# 811
__m = memory_order_seq_cst) noexcept 
# 812
{ return __atomic_fetch_sub(&(_M_p), _M_type_size(__d), (int)__m); } 
# 814
__attribute((__always_inline__)) __pointer_type 
# 815
fetch_sub(ptrdiff_t __d, memory_order 
# 816
__m = memory_order_seq_cst) volatile noexcept 
# 817
{ return __atomic_fetch_sub(&(_M_p), _M_type_size(__d), (int)__m); } 
# 818
}; 
# 823
}
# 35 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 44
struct _Sp_locker { 
# 46
_Sp_locker(const _Sp_locker &) = delete;
# 47
_Sp_locker &operator=(const _Sp_locker &) = delete;
# 51
explicit _Sp_locker(const void *) noexcept; 
# 52
_Sp_locker(const void *, const void *) noexcept; 
# 53
~_Sp_locker(); 
# 56
private: unsigned char _M_key1; 
# 57
unsigned char _M_key2; 
# 61
}; 
# 69
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 71
atomic_is_lock_free(const __shared_ptr< _Tp, _Lp>  *__p) 
# 72
{ 
# 74
return __gthread_active_p() == 0; 
# 78
} 
# 80
template< class _Tp> inline bool 
# 82
atomic_is_lock_free(const shared_ptr< _Tp>  *__p) 
# 83
{ return std::atomic_is_lock_free< _Tp, __gnu_cxx::__default_lock_policy> (__p); } 
# 96 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
template< class _Tp> inline shared_ptr< _Tp>  
# 98
atomic_load_explicit(const shared_ptr< _Tp>  *__p, memory_order) 
# 99
{ 
# 100
_Sp_locker __lock{__p}; 
# 101
return *__p; 
# 102
} 
# 104
template< class _Tp> inline shared_ptr< _Tp>  
# 106
atomic_load(const shared_ptr< _Tp>  *__p) 
# 107
{ return std::atomic_load_explicit(__p, memory_order_seq_cst); } 
# 109
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 111
atomic_load_explicit(const __shared_ptr< _Tp, _Lp>  *__p, memory_order) 
# 112
{ 
# 113
_Sp_locker __lock{__p}; 
# 114
return *__p; 
# 115
} 
# 117
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 119
atomic_load(const __shared_ptr< _Tp, _Lp>  *__p) 
# 120
{ return std::atomic_load_explicit(__p, memory_order_seq_cst); } 
# 132 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
template< class _Tp> inline void 
# 134
atomic_store_explicit(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  __r, memory_order) 
# 136
{ 
# 137
_Sp_locker __lock{__p}; 
# 138
__p->swap(__r); 
# 139
} 
# 141
template< class _Tp> inline void 
# 143
atomic_store(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  __r) 
# 144
{ std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); } 
# 146
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline void 
# 148
atomic_store_explicit(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  
# 149
__r, memory_order) 
# 151
{ 
# 152
_Sp_locker __lock{__p}; 
# 153
__p->swap(__r); 
# 154
} 
# 156
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline void 
# 158
atomic_store(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  __r) 
# 159
{ std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); } 
# 169 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
template< class _Tp> inline shared_ptr< _Tp>  
# 171
atomic_exchange_explicit(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  __r, memory_order) 
# 173
{ 
# 174
_Sp_locker __lock{__p}; 
# 175
__p->swap(__r); 
# 176
return __r; 
# 177
} 
# 179
template< class _Tp> inline shared_ptr< _Tp>  
# 181
atomic_exchange(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  __r) 
# 182
{ 
# 183
return std::atomic_exchange_explicit(__p, std::move(__r), memory_order_seq_cst); 
# 185
} 
# 187
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 189
atomic_exchange_explicit(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  
# 190
__r, memory_order) 
# 192
{ 
# 193
_Sp_locker __lock{__p}; 
# 194
__p->swap(__r); 
# 195
return __r; 
# 196
} 
# 198
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline __shared_ptr< _Tp, _Lp>  
# 200
atomic_exchange(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  __r) 
# 201
{ 
# 202
return std::atomic_exchange_explicit(__p, std::move(__r), memory_order_seq_cst); 
# 204
} 
# 218 "/usr/include/c++/9/bits/shared_ptr_atomic.h" 3
template< class _Tp> bool 
# 220
atomic_compare_exchange_strong_explicit(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  *
# 221
__v, shared_ptr< _Tp>  
# 222
__w, memory_order, memory_order) 
# 225
{ 
# 226
shared_ptr< _Tp>  __x; 
# 227
_Sp_locker __lock{__p, __v}; 
# 228
owner_less< shared_ptr< _Tp> >  __less; 
# 229
if (((*__p) == (*__v)) && (!__less(*__p, *__v)) && (!__less(*__v, *__p))) 
# 230
{ 
# 231
__x = std::move(*__p); 
# 232
(*__p) = std::move(__w); 
# 233
return true; 
# 234
}  
# 235
__x = std::move(*__v); 
# 236
(*__v) = (*__p); 
# 237
return false; 
# 238
} 
# 240
template< class _Tp> inline bool 
# 242
atomic_compare_exchange_strong(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  *__v, shared_ptr< _Tp>  
# 243
__w) 
# 244
{ 
# 245
return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst); 
# 247
} 
# 249
template< class _Tp> inline bool 
# 251
atomic_compare_exchange_weak_explicit(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  *
# 252
__v, shared_ptr< _Tp>  
# 253
__w, memory_order 
# 254
__success, memory_order 
# 255
__failure) 
# 256
{ 
# 257
return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), __success, __failure); 
# 259
} 
# 261
template< class _Tp> inline bool 
# 263
atomic_compare_exchange_weak(shared_ptr< _Tp>  *__p, shared_ptr< _Tp>  *__v, shared_ptr< _Tp>  
# 264
__w) 
# 265
{ 
# 266
return std::atomic_compare_exchange_weak_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst); 
# 268
} 
# 270
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> bool 
# 272
atomic_compare_exchange_strong_explicit(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  *
# 273
__v, __shared_ptr< _Tp, _Lp>  
# 274
__w, memory_order, memory_order) 
# 277
{ 
# 278
__shared_ptr< _Tp, _Lp>  __x; 
# 279
_Sp_locker __lock{__p, __v}; 
# 280
owner_less< __shared_ptr< _Tp, _Lp> >  __less; 
# 281
if (((*__p) == (*__v)) && (!__less(*__p, *__v)) && (!__less(*__v, *__p))) 
# 282
{ 
# 283
__x = std::move(*__p); 
# 284
(*__p) = std::move(__w); 
# 285
return true; 
# 286
}  
# 287
__x = std::move(*__v); 
# 288
(*__v) = (*__p); 
# 289
return false; 
# 290
} 
# 292
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 294
atomic_compare_exchange_strong(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  *
# 295
__v, __shared_ptr< _Tp, _Lp>  
# 296
__w) 
# 297
{ 
# 298
return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst); 
# 300
} 
# 302
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 304
atomic_compare_exchange_weak_explicit(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  *
# 305
__v, __shared_ptr< _Tp, _Lp>  
# 306
__w, memory_order 
# 307
__success, memory_order 
# 308
__failure) 
# 309
{ 
# 310
return std::atomic_compare_exchange_strong_explicit(__p, __v, std::move(__w), __success, __failure); 
# 312
} 
# 314
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> inline bool 
# 316
atomic_compare_exchange_weak(__shared_ptr< _Tp, _Lp>  *__p, __shared_ptr< _Tp, _Lp>  *
# 317
__v, __shared_ptr< _Tp, _Lp>  
# 318
__w) 
# 319
{ 
# 320
return std::atomic_compare_exchange_weak_explicit(__p, __v, std::move(__w), memory_order_seq_cst, memory_order_seq_cst); 
# 322
} 
# 328
}
# 36 "/usr/include/c++/9/backward/auto_ptr.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 47 "/usr/include/c++/9/backward/auto_ptr.h" 3
template< class _Tp1> 
# 48
struct auto_ptr_ref { 
# 50
_Tp1 *_M_ptr; 
# 53
explicit auto_ptr_ref(_Tp1 *__p) : _M_ptr(__p) { } 
# 54
} __attribute((__deprecated__)); 
# 56
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 88 "/usr/include/c++/9/backward/auto_ptr.h" 3
template< class _Tp> 
# 89
class auto_ptr { 
# 92
_Tp *_M_ptr; 
# 96
public: typedef _Tp element_type; 
# 105
explicit auto_ptr(element_type *__p = 0) throw() : _M_ptr(__p) { } 
# 114 "/usr/include/c++/9/backward/auto_ptr.h" 3
auto_ptr(auto_ptr &__a) throw() : _M_ptr(__a.release()) { } 
# 126 "/usr/include/c++/9/backward/auto_ptr.h" 3
template< class _Tp1> 
# 127
auto_ptr(auto_ptr< _Tp1>  &__a) throw() : _M_ptr(__a.release()) { } 
# 138 "/usr/include/c++/9/backward/auto_ptr.h" 3
auto_ptr &operator=(auto_ptr &__a) throw() 
# 139
{ 
# 140
reset(__a.release()); 
# 141
return *this; 
# 142
} 
# 154 "/usr/include/c++/9/backward/auto_ptr.h" 3
template< class _Tp1> auto_ptr &
# 156
operator=(auto_ptr< _Tp1>  &__a) throw() 
# 157
{ 
# 158
reset(__a.release()); 
# 159
return *this; 
# 160
} 
# 172 "/usr/include/c++/9/backward/auto_ptr.h" 3
~auto_ptr() { delete (_M_ptr); } 
# 183 "/usr/include/c++/9/backward/auto_ptr.h" 3
element_type &operator*() const throw() 
# 184
{ 
# 185
; 
# 186
return *(_M_ptr); 
# 187
} 
# 196
element_type *operator->() const throw() 
# 197
{ 
# 198
; 
# 199
return _M_ptr; 
# 200
} 
# 213 "/usr/include/c++/9/backward/auto_ptr.h" 3
element_type *get() const throw() { return _M_ptr; } 
# 227 "/usr/include/c++/9/backward/auto_ptr.h" 3
element_type *release() throw() 
# 228
{ 
# 229
element_type *__tmp = _M_ptr; 
# 230
(_M_ptr) = 0; 
# 231
return __tmp; 
# 232
} 
# 242 "/usr/include/c++/9/backward/auto_ptr.h" 3
void reset(element_type *__p = 0) throw() 
# 243
{ 
# 244
if (__p != (_M_ptr)) 
# 245
{ 
# 246
delete (_M_ptr); 
# 247
(_M_ptr) = __p; 
# 248
}  
# 249
} 
# 266 "/usr/include/c++/9/backward/auto_ptr.h" 3
auto_ptr(auto_ptr_ref< element_type>  __ref) throw() : _M_ptr(((__ref._M_ptr))) 
# 267
{ } 
# 270
auto_ptr &operator=(auto_ptr_ref< element_type>  __ref) throw() 
# 271
{ 
# 272
if ((__ref._M_ptr) != get()) 
# 273
{ 
# 274
delete (_M_ptr); 
# 275
(_M_ptr) = (__ref._M_ptr); 
# 276
}  
# 277
return *this; 
# 278
} 
# 280
template< class _Tp1> 
# 281
operator auto_ptr_ref< _Tp1> () throw() 
# 282
{ return ((auto_ptr_ref< _Tp1> )(release())); } 
# 284
template< class _Tp1> 
# 285
operator auto_ptr< _Tp1> () throw() 
# 286
{ return ((auto_ptr< _Tp1> )(release())); } 
# 287
} __attribute((__deprecated__)); 
# 292
template<> class auto_ptr< void>  { 
# 295
public: typedef void element_type; 
# 296
} __attribute((__deprecated__)); 
# 299
template< __gnu_cxx::_Lock_policy _Lp> 
# 300
template< class _Tp> inline 
# 302
__shared_count< _Lp> ::__shared_count(auto_ptr< _Tp>  &&__r) : _M_pi(new _Sp_counted_ptr< _Tp *, _Lp> (__r.get())) 
# 304
{ __r.release(); } 
# 306
template< class _Tp, __gnu_cxx::_Lock_policy _Lp> 
# 307
template< class _Tp1, class > inline 
# 309
__shared_ptr< _Tp, _Lp> ::__shared_ptr(auto_ptr< _Tp1>  &&__r) : _M_ptr(__r.get()), _M_refcount() 
# 311
{ 
# 313
static_assert((sizeof(_Tp1) > (0)), "incomplete type");
# 314
_Tp1 *__tmp = __r.get(); 
# 315
(_M_refcount) = ((__shared_count< _Lp> )(std::move(__r))); 
# 316
_M_enable_shared_from_this_with(__tmp); 
# 317
} 
# 319
template< class _Tp> 
# 320
template< class _Tp1, class > inline 
# 322
shared_ptr< _Tp> ::shared_ptr(auto_ptr< _Tp1>  &&__r) : __shared_ptr< _Tp> (std::move(__r)) 
# 323
{ } 
# 325
template< class _Tp, class _Dp> 
# 326
template< class _Up, class > inline 
# 328
unique_ptr< _Tp, _Dp> ::unique_ptr(auto_ptr< _Up>  &&__u) noexcept : _M_t(__u.release(), deleter_type()) 
# 329
{ } 
# 335
}
# 97 "/usr/include/c++/9/memory" 3
namespace std __attribute((__visibility__("default"))) { 
# 118 "/usr/include/c++/9/memory" 3
inline void *align(size_t __align, size_t __size, void *&__ptr, size_t &__space) noexcept 
# 119
{ 
# 121
const auto __intptr = reinterpret_cast< uintptr_t>(__ptr); 
# 128
const auto __aligned = ((__intptr - (1U)) + __align) & (-__align); 
# 129
const auto __diff = __aligned - __intptr; 
# 130
if ((__size + __diff) > __space) { 
# 131
return nullptr; } else 
# 133
{ 
# 134
__space -= __diff; 
# 135
return __ptr = (reinterpret_cast< void *>(__aligned)); 
# 136
}  
# 137
} 
# 141
enum class pointer_safety { relaxed, preferred, strict}; 
# 144
inline void declare_reachable(void *) { } 
# 146
template< class _Tp> inline _Tp *
# 148
undeclare_reachable(_Tp *__p) { return __p; } 
# 151
inline void declare_no_pointers(char *, size_t) { } 
# 154
inline void undeclare_no_pointers(char *, size_t) { } 
# 157
inline pointer_safety get_pointer_safety() noexcept { return pointer_safety::relaxed; } 
# 384 "/usr/include/c++/9/memory" 3
}
# 14 "/usr/include/opencv4/opencv2/core/cvstd_wrapper.hpp" 3
namespace cv { 
# 16
using std::nullptr_t;
# 32 "/usr/include/opencv4/opencv2/core/cvstd_wrapper.hpp" 3
template< class Y> struct DefaultDeleter; 
# 39
namespace sfinae { 
# 40
template< class C, class Ret, class ...Args> 
# 41
struct has_parenthesis_operator { 
# 44
private: template< class T> static constexpr std::true_type check(typename std::is_same< typename std::decay< __decltype((std::declval< T> ().operator()(std::declval< Args> ()...)))> ::type, Ret> ::type *); 
# 47
template< class > static constexpr std::false_type check(...); 
# 49
typedef __decltype((check< C> (0))) type; 
# 53
public: static constexpr bool value = (type::value); 
# 58
}; 
# 59
}
# 61
template< class T, class  = void> 
# 62
struct has_custom_delete : public std::false_type { 
# 63
}; 
# 72 "/usr/include/opencv4/opencv2/core/cvstd_wrapper.hpp" 3
template< class T> 
# 73
struct Ptr : public std::shared_ptr< T>  { 
# 78
Ptr() noexcept : std::shared_ptr< T> () { } 
# 79
Ptr(std::nullptr_t) noexcept : std::shared_ptr< T> (nullptr) { } 
# 80
template< class Y, class D> Ptr(Y *p, D d) : std::shared_ptr< T> (p, d) { } 
# 81
template< class D> Ptr(std::nullptr_t, D d) : std::shared_ptr< T> (nullptr, d) { } 
# 83
template< class Y> Ptr(const Ptr< Y>  &r, T *ptr) noexcept : std::shared_ptr< T> (r, ptr) { } 
# 85
Ptr(const Ptr &o) noexcept : std::shared_ptr< T> (o) { } 
# 86
Ptr(Ptr &&o) noexcept : std::shared_ptr< T> (std::move(o)) { } 
# 88
template< class Y> Ptr(const Ptr< Y>  &o) noexcept : std::shared_ptr< T> (o) { } 
# 89
template< class Y> Ptr(Ptr< Y>  &&o) noexcept : std::shared_ptr< T> (std::move(o)) { } 
# 91
Ptr(const std::shared_ptr< T>  &o) noexcept : std::shared_ptr< T> (o) { } 
# 92
Ptr(std::shared_ptr< T>  &&o) noexcept : std::shared_ptr< T> (std::move(o)) { } 
# 95
template< class Y> 
# 96
Ptr(const std::true_type &, Y *ptr) : std::shared_ptr< T> (ptr, DefaultDeleter< Y> ()) { } 
# 99
template< class Y> 
# 100
Ptr(const std::false_type &, Y *ptr) : std::shared_ptr< T> (ptr) { } 
# 102
template< class Y = T> 
# 103
Ptr(Y *ptr) : Ptr(has_custom_delete< Y> (), ptr) { } 
# 106
template< class Y> void 
# 107
reset(const std::true_type &, Y *ptr) { std::template shared_ptr< T> ::reset(ptr, DefaultDeleter< Y> ()); } 
# 110
template< class Y> void 
# 111
reset(const std::false_type &, Y *ptr) { std::template shared_ptr< T> ::reset(ptr); } 
# 113
template< class Y> void 
# 114
reset(Y *ptr) { Ptr< T> ::reset(has_custom_delete< Y> (), ptr); } 
# 116
template< class Y, class Deleter> void 
# 117
reset(Y *ptr, Deleter d) { std::template shared_ptr< T> ::reset(ptr, d); } 
# 119
void reset() noexcept { std::template shared_ptr< T> ::reset(); } 
# 121
Ptr &operator=(const Ptr &o) { std::shared_ptr< T> ::operator=(o); return *this; } 
# 122
template< class Y> Ptr &operator=(const Ptr< Y>  &o) { std::shared_ptr< T> ::operator=(o); return *this; } 
# 124
T *operator->() const noexcept { return std::template shared_ptr< T> ::get(); } 
# 125
typename std::add_lvalue_reference< T> ::type operator*() const noexcept { return *std::template shared_ptr< T> ::get(); } 
# 128
void release() { std::template shared_ptr< T> ::reset(); } 
# 129
operator T *() const { return std::template shared_ptr< T> ::get(); } 
# 130
bool empty() const { return std::template shared_ptr< T> ::get() == nullptr; } 
# 132
template< class Y> Ptr< Y>  
# 133
staticCast() const noexcept { return std::static_pointer_cast< Y> (*this); } 
# 135
template< class Y> Ptr< Y>  
# 136
constCast() const noexcept { return std::const_pointer_cast< Y> (*this); } 
# 138
template< class Y> Ptr< Y>  
# 139
dynamicCast() const noexcept { return std::dynamic_pointer_cast< Y> (*this); } 
# 140
}; 
# 142
template< class _Tp, class ...A1> static inline Ptr< _Tp>  
# 143
makePtr(const A1 &...a1) 
# 144
{ 
# 145
static_assert((!has_custom_delete< _Tp> ::value), "Can\'t use this makePtr with custom DefaultDeleter");
# 146
return ((Ptr< _Tp> )(std::make_shared< _Tp> (a1...))); 
# 147
} 
# 152
}
# 83 "/usr/include/opencv4/opencv2/core/cvstd.hpp" 3
namespace cv { 
# 96 "/usr/include/opencv4/opencv2/core/cvstd.hpp" 3
void *fastMalloc(size_t bufSize); 
# 105 "/usr/include/opencv4/opencv2/core/cvstd.hpp" 3
void fastFree(void * ptr); 
# 110
template< class _Tp> class Allocator { 
# 113
public: typedef _Tp value_type; 
# 114
typedef value_type *pointer; 
# 115
typedef const value_type *const_pointer; 
# 116
typedef value_type &reference; 
# 117
typedef const value_type &const_reference; 
# 118
typedef size_t size_type; 
# 119
typedef ptrdiff_t difference_type; 
# 120
template< class U> class rebind { typedef Allocator< U>  other; }; 
# 122
explicit Allocator() { } 
# 123
~Allocator() { } 
# 124
explicit Allocator(const Allocator &) { } 
# 125
template< class U> explicit 
# 126
Allocator(const Allocator< U>  &) { } 
# 129
pointer address(reference r) { return &r; } 
# 130
const_pointer address(const_reference r) { return &r; } 
# 132
pointer allocate(size_type count, const void * = 0) { return reinterpret_cast< pointer>(fastMalloc(count * sizeof(_Tp))); } 
# 133
void deallocate(pointer p, size_type) { fastFree(p); } 
# 135
void construct(pointer p, const _Tp &v) { new (static_cast< void *>(p)) _Tp(v); } 
# 136
void destroy(pointer p) { p->~_Tp(); } 
# 138
size_type max_size() const { return cv::max((static_cast< _Tp>(-1)) / sizeof(_Tp), 1); } 
# 139
}; 
# 150 "/usr/include/opencv4/opencv2/core/cvstd.hpp" 3
class FileNode; 
# 152
typedef std::string String; 
# 157
namespace details { 
# 159
static inline char char_tolower(char ch) 
# 160
{ 
# 161
return (char)std::tolower((int)ch); 
# 162
} 
# 164
static inline char char_toupper(char ch) 
# 165
{ 
# 166
return (char)std::toupper((int)ch); 
# 167
} 
# 168
}
# 171
static inline std::string toLowerCase(const std::string &str) 
# 172
{ 
# 173
std::string result(str); 
# 174
std::transform(result.begin(), result.end(), result.begin(), details::char_tolower); 
# 175
return result; 
# 176
} 
# 178
static inline std::string toUpperCase(const std::string &str) 
# 179
{ 
# 180
std::string result(str); 
# 181
std::transform(result.begin(), result.end(), result.begin(), details::char_toupper); 
# 182
return result; 
# 183
} 
# 188
}
# 60 "/usr/include/opencv4/opencv2/core/base.hpp" 3
namespace cv { 
# 66
namespace Error { 
# 68
enum Code { 
# 69
StsOk, 
# 70
StsBackTrace = (-1), 
# 71
StsError = (-2), 
# 72
StsInternal = (-3), 
# 73
StsNoMem = (-4), 
# 74
StsBadArg = (-5), 
# 75
StsBadFunc = (-6), 
# 76
StsNoConv = (-7), 
# 77
StsAutoTrace = (-8), 
# 78
HeaderIsNull = (-9), 
# 79
BadImageSize = (-10), 
# 80
BadOffset = (-11), 
# 81
BadDataPtr = (-12), 
# 82
BadStep = (-13), 
# 83
BadModelOrChSeq = (-14), 
# 84
BadNumChannels = (-15), 
# 85
BadNumChannel1U = (-16), 
# 86
BadDepth = (-17), 
# 87
BadAlphaChannel = (-18), 
# 88
BadOrder = (-19), 
# 89
BadOrigin = (-20), 
# 90
BadAlign = (-21), 
# 91
BadCallBack = (-22), 
# 92
BadTileSize = (-23), 
# 93
BadCOI = (-24), 
# 94
BadROISize = (-25), 
# 95
MaskIsTiled = (-26), 
# 96
StsNullPtr = (-27), 
# 97
StsVecLengthErr = (-28), 
# 98
StsFilterStructContentErr = (-29), 
# 99
StsKernelStructContentErr = (-30), 
# 100
StsFilterOffsetErr = (-31), 
# 101
StsBadSize = (-201), 
# 102
StsDivByZero = (-202), 
# 103
StsInplaceNotSupported = (-203), 
# 104
StsObjectNotFound = (-204), 
# 105
StsUnmatchedFormats = (-205), 
# 106
StsBadFlag = (-206), 
# 107
StsBadPoint = (-207), 
# 108
StsBadMask = (-208), 
# 109
StsUnmatchedSizes = (-209), 
# 110
StsUnsupportedFormat = (-210), 
# 111
StsOutOfRange = (-211), 
# 112
StsParseError = (-212), 
# 113
StsNotImplemented = (-213), 
# 114
StsBadMemBlock = (-214), 
# 115
StsAssert = (-215), 
# 116
GpuNotSupported = (-216), 
# 117
GpuApiCallError = (-217), 
# 118
OpenGlNotSupported = (-218), 
# 119
OpenGlApiCallError = (-219), 
# 120
OpenCLApiCallError = (-220), 
# 121
OpenCLDoubleNotSupported = (-221), 
# 122
OpenCLInitError = (-222), 
# 123
OpenCLNoAMDBlasFft = (-223)
# 124
}; 
# 125
}
# 133
enum DecompTypes { 
# 135
DECOMP_LU, 
# 138
DECOMP_SVD, 
# 140
DECOMP_EIG, 
# 143
DECOMP_CHOLESKY, 
# 145
DECOMP_QR, 
# 151
DECOMP_NORMAL = 16
# 152
}; 
# 159
enum NormTypes { 
# 168 "/usr/include/opencv4/opencv2/core/base.hpp" 3
NORM_INF = 1, 
# 176
NORM_L1, 
# 185 "/usr/include/opencv4/opencv2/core/base.hpp" 3
NORM_L2 = 4, 
# 194 "/usr/include/opencv4/opencv2/core/base.hpp" 3
NORM_L2SQR, 
# 199
NORM_HAMMING, 
# 204
NORM_HAMMING2, 
# 205
NORM_TYPE_MASK = 7, 
# 206
NORM_RELATIVE, 
# 207
NORM_MINMAX = 32
# 208
}; 
# 211
enum CmpTypes { CMP_EQ, 
# 212
CMP_GT, 
# 213
CMP_GE, 
# 214
CMP_LT, 
# 215
CMP_LE, 
# 216
CMP_NE
# 217
}; 
# 220
enum GemmFlags { GEMM_1_T = 1, 
# 221
GEMM_2_T, 
# 222
GEMM_3_T = 4
# 223
}; 
# 225
enum DftFlags { 
# 228
DFT_INVERSE = 1, 
# 231
DFT_SCALE, 
# 236
DFT_ROWS = 4, 
# 243
DFT_COMPLEX_OUTPUT = 16, 
# 252 "/usr/include/opencv4/opencv2/core/base.hpp" 3
DFT_REAL_OUTPUT = 32, 
# 256
DFT_COMPLEX_INPUT = 64, 
# 258
DCT_INVERSE = DFT_INVERSE, 
# 263
DCT_ROWS = DFT_ROWS
# 264
}; 
# 268
enum BorderTypes { 
# 269
BORDER_CONSTANT, 
# 270
BORDER_REPLICATE, 
# 271
BORDER_REFLECT, 
# 272
BORDER_WRAP, 
# 273
BORDER_REFLECT_101, 
# 274
BORDER_TRANSPARENT, 
# 276
BORDER_REFLECT101 = BORDER_REFLECT_101, 
# 277
BORDER_DEFAULT = BORDER_REFLECT_101, 
# 278
BORDER_ISOLATED = 16
# 279
}; 
# 298 "/usr/include/opencv4/opencv2/core/base.hpp" 3
__attribute((__noreturn__)) void error(int _code, const String & _err, const char * _func, const char * _file, int _line); 
# 382 "/usr/include/opencv4/opencv2/core/base.hpp" 3
struct Hamming { 
# 384
static const NormTypes normType = NORM_HAMMING; 
# 385
typedef unsigned char ValueType; 
# 386
typedef int ResultType; 
# 390
ResultType operator()(const unsigned char * a, const unsigned char * b, int size) const; 
# 391
}; 
# 393
typedef Hamming HammingLUT; 
# 397
template< class _Tp> inline _Tp cv_abs(_Tp x) { return std::abs(x); } 
# 398
inline int cv_abs(uchar x) { return x; } 
# 399
inline int cv_abs(schar x) { return std::abs(x); } 
# 400
inline int cv_abs(ushort x) { return x; } 
# 401
inline int cv_abs(short x) { return std::abs(x); } 
# 403
template< class _Tp, class _AccTp> static inline _AccTp 
# 404
normL2Sqr(const _Tp *a, int n) 
# 405
{ 
# 406
_AccTp s = (0); 
# 407
int i = 0; 
# 409
for (; i <= (n - 4); i += 4) 
# 410
{ 
# 411
_AccTp v0 = a[i], v1 = a[i + 1], v2 = a[i + 2], v3 = a[i + 3]; 
# 412
s += ((((v0 * v0) + (v1 * v1)) + (v2 * v2)) + (v3 * v3)); 
# 413
}  
# 415
for (; i < n; i++) 
# 416
{ 
# 417
_AccTp v = a[i]; 
# 418
s += (v * v); 
# 419
}  
# 420
return s; 
# 421
} 
# 423
template< class _Tp, class _AccTp> static inline _AccTp 
# 424
normL1(const _Tp *a, int n) 
# 425
{ 
# 426
_AccTp s = (0); 
# 427
int i = 0; 
# 429
for (; i <= (n - 4); i += 4) 
# 430
{ 
# 431
s += (((((_AccTp)cv_abs(a[i])) + ((_AccTp)cv_abs(a[i + 1]))) + ((_AccTp)cv_abs(a[i + 2]))) + ((_AccTp)cv_abs(a[i + 3]))); 
# 433
}  
# 435
for (; i < n; i++) { 
# 436
s += cv_abs(a[i]); }  
# 437
return s; 
# 438
} 
# 440
template< class _Tp, class _AccTp> static inline _AccTp 
# 441
normInf(const _Tp *a, int n) 
# 442
{ 
# 443
_AccTp s = (0); 
# 444
for (int i = 0; i < n; i++) { 
# 445
s = std::max(s, (_AccTp)cv_abs(a[i])); }  
# 446
return s; 
# 447
} 
# 449
template< class _Tp, class _AccTp> static inline _AccTp 
# 450
normL2Sqr(const _Tp *a, const _Tp *b, int n) 
# 451
{ 
# 452
_AccTp s = (0); 
# 453
int i = 0; 
# 455
for (; i <= (n - 4); i += 4) 
# 456
{ 
# 457
_AccTp v0 = (_AccTp)((a[i]) - (b[i])), v1 = (_AccTp)((a[i + 1]) - (b[i + 1])), v2 = (_AccTp)((a[i + 2]) - (b[i + 2])), v3 = (_AccTp)((a[i + 3]) - (b[i + 3])); 
# 458
s += ((((v0 * v0) + (v1 * v1)) + (v2 * v2)) + (v3 * v3)); 
# 459
}  
# 461
for (; i < n; i++) 
# 462
{ 
# 463
_AccTp v = (_AccTp)((a[i]) - (b[i])); 
# 464
s += (v * v); 
# 465
}  
# 466
return s; 
# 467
} 
# 469
static inline float normL2Sqr(const float *a, const float *b, int n) 
# 470
{ 
# 471
float s = (0.0F); 
# 472
for (int i = 0; i < n; i++) 
# 473
{ 
# 474
float v = (a[i]) - (b[i]); 
# 475
s += (v * v); 
# 476
}  
# 477
return s; 
# 478
} 
# 480
template< class _Tp, class _AccTp> static inline _AccTp 
# 481
normL1(const _Tp *a, const _Tp *b, int n) 
# 482
{ 
# 483
_AccTp s = (0); 
# 484
int i = 0; 
# 486
for (; i <= (n - 4); i += 4) 
# 487
{ 
# 488
_AccTp v0 = (_AccTp)((a[i]) - (b[i])), v1 = (_AccTp)((a[i + 1]) - (b[i + 1])), v2 = (_AccTp)((a[i + 2]) - (b[i + 2])), v3 = (_AccTp)((a[i + 3]) - (b[i + 3])); 
# 489
s += (((std::abs(v0) + std::abs(v1)) + std::abs(v2)) + std::abs(v3)); 
# 490
}  
# 492
for (; i < n; i++) 
# 493
{ 
# 494
_AccTp v = (_AccTp)((a[i]) - (b[i])); 
# 495
s += std::abs(v); 
# 496
}  
# 497
return s; 
# 498
} 
# 500
inline float normL1(const float *a, const float *b, int n) 
# 501
{ 
# 502
float s = (0.0F); 
# 503
for (int i = 0; i < n; i++) 
# 504
{ 
# 505
s += std::abs((a[i]) - (b[i])); 
# 506
}  
# 507
return s; 
# 508
} 
# 510
inline int normL1(const uchar *a, const uchar *b, int n) 
# 511
{ 
# 512
int s = 0; 
# 513
for (int i = 0; i < n; i++) 
# 514
{ 
# 515
s += std::abs((a[i]) - (b[i])); 
# 516
}  
# 517
return s; 
# 518
} 
# 520
template< class _Tp, class _AccTp> static inline _AccTp 
# 521
normInf(const _Tp *a, const _Tp *b, int n) 
# 522
{ 
# 523
_AccTp s = (0); 
# 524
for (int i = 0; i < n; i++) 
# 525
{ 
# 526
_AccTp v0 = (a[i]) - (b[i]); 
# 527
s = std::max(s, std::abs(v0)); 
# 528
}  
# 529
return s; 
# 530
} 
# 539 "/usr/include/opencv4/opencv2/core/base.hpp" 3
float cubeRoot(float val); 
# 548 "/usr/include/opencv4/opencv2/core/base.hpp" 3
float fastAtan2(float y, float x); 
# 551
int LU(float * A, size_t astep, int m, float * b, size_t bstep, int n); 
# 553
int LU(double * A, size_t astep, int m, double * b, size_t bstep, int n); 
# 555
bool Cholesky(float * A, size_t astep, int m, float * b, size_t bstep, int n); 
# 557
bool Cholesky(double * A, size_t astep, int m, double * b, size_t bstep, int n); 
# 563
template< class _Tp, int cn> class Vec; 
# 564
template< class _Tp, int m, int n> class Matx; 
# 566
template< class _Tp> class Complex; 
# 567
template< class _Tp> class Point_; 
# 568
template< class _Tp> class Point3_; 
# 569
template< class _Tp> class Size_; 
# 570
template< class _Tp> class Rect_; 
# 571
template< class _Tp> class Scalar_; 
# 573
class RotatedRect; 
# 574
class Range; 
# 575
class TermCriteria; 
# 576
class KeyPoint; 
# 577
class DMatch; 
# 578
class RNG; 
# 580
class Mat; 
# 581
class MatExpr; 
# 583
class UMat; 
# 585
class SparseMat; 
# 586
typedef Mat MatND; 
# 588
template< class _Tp> class Mat_; 
# 589
template< class _Tp> class SparseMat_; 
# 591
class MatConstIterator; 
# 592
class SparseMatIterator; 
# 593
class SparseMatConstIterator; 
# 594
template< class _Tp> class MatIterator_; 
# 595
template< class _Tp> class MatConstIterator_; 
# 596
template< class _Tp> class SparseMatIterator_; 
# 597
template< class _Tp> class SparseMatConstIterator_; 
# 599
namespace ogl { 
# 601
class Buffer; 
# 602
class Texture2D; 
# 603
class Arrays; 
# 604
}
# 606
namespace cuda { 
# 608
class GpuMat; 
# 609
class HostMem; 
# 610
class Stream; 
# 611
class Event; 
# 612
}
# 614
namespace cudev { 
# 616
template< class _Tp> class GpuMat_; 
# 617
}
# 619
namespace ipp { 
# 621
unsigned long long getIppFeatures(); 
# 622
void setIppStatus(int status, const char *const funcname = 0, const char *const filename = 0, int line = 0); 
# 624
int getIppStatus(); 
# 625
String getIppErrorLocation(); 
# 626
bool useIPP(); 
# 627
void setUseIPP(bool flag); 
# 628
String getIppVersion(); 
# 632
bool useIPP_NotExact(); 
# 633
void setUseIPP_NotExact(bool flag); 
# 635
static inline bool useIPP_NE() { return useIPP_NotExact(); } 
# 636
static inline void setUseIPP_NE(bool flag) { setUseIPP_NotExact(flag); } 
# 639
}
# 648 "/usr/include/opencv4/opencv2/core/base.hpp" 3
}
# 66 "/usr/include/assert.h" 3
extern "C" {
# 69
extern void __assert_fail(const char * __assertion, const char * __file, unsigned __line, const char * __function) throw()
# 71
 __attribute((__noreturn__)); 
# 74
extern void __assert_perror_fail(int __errnum, const char * __file, unsigned __line, const char * __function) throw()
# 76
 __attribute((__noreturn__)); 
# 81
extern void __assert(const char * __assertion, const char * __file, int __line) throw()
# 82
 __attribute((__noreturn__)); 
# 85
}
# 10 "/usr/include/opencv4/opencv2/core/check.hpp" 3
namespace cv { 
# 13
const char *depthToString(int depth); 
# 16
const String typeToString(int type); 
# 20
namespace detail { 
# 23
const char *depthToString_(int depth); 
# 26
const String typeToString_(int type); 
# 28
enum TestOp { 
# 29
TEST_CUSTOM, 
# 30
TEST_EQ, 
# 31
TEST_NE, 
# 32
TEST_LE, 
# 33
TEST_LT, 
# 34
TEST_GE, 
# 35
TEST_GT, 
# 36
CV__LAST_TEST_OP
# 37
}; 
# 39
struct CheckContext { 
# 40
const char *func; 
# 41
const char *file; 
# 42
int line; 
# 43
TestOp testOp; 
# 44
const char *message; 
# 45
const char *p1_str; 
# 46
const char *p2_str; 
# 47
}; 
# 68 "/usr/include/opencv4/opencv2/core/check.hpp" 3
__attribute((__noreturn__)) void check_failed_auto(const int v1, const int v2, const CheckContext & ctx); 
# 69
__attribute((__noreturn__)) void check_failed_auto(const size_t v1, const size_t v2, const CheckContext & ctx); 
# 70
__attribute((__noreturn__)) void check_failed_auto(const float v1, const float v2, const CheckContext & ctx); 
# 71
__attribute((__noreturn__)) void check_failed_auto(const double v1, const double v2, const CheckContext & ctx); 
# 72
__attribute((__noreturn__)) void check_failed_auto(const Size_< int>  v1, const Size_< int>  v2, const CheckContext & ctx); 
# 73
__attribute((__noreturn__)) void check_failed_MatDepth(const int v1, const int v2, const CheckContext & ctx); 
# 74
__attribute((__noreturn__)) void check_failed_MatType(const int v1, const int v2, const CheckContext & ctx); 
# 75
__attribute((__noreturn__)) void check_failed_MatChannels(const int v1, const int v2, const CheckContext & ctx); 
# 77
__attribute((__noreturn__)) void check_failed_auto(const int v, const CheckContext & ctx); 
# 78
__attribute((__noreturn__)) void check_failed_auto(const size_t v, const CheckContext & ctx); 
# 79
__attribute((__noreturn__)) void check_failed_auto(const float v, const CheckContext & ctx); 
# 80
__attribute((__noreturn__)) void check_failed_auto(const double v, const CheckContext & ctx); 
# 81
__attribute((__noreturn__)) void check_failed_auto(const Size_< int>  v, const CheckContext & ctx); 
# 82
__attribute((__noreturn__)) void check_failed_MatDepth(const int v, const CheckContext & ctx); 
# 83
__attribute((__noreturn__)) void check_failed_MatType(const int v, const CheckContext & ctx); 
# 84
__attribute((__noreturn__)) void check_failed_MatChannels(const int v, const CheckContext & ctx); 
# 108 "/usr/include/opencv4/opencv2/core/check.hpp" 3
}
# 157 "/usr/include/opencv4/opencv2/core/check.hpp" 3
}
# 49 "/usr/include/opencv4/opencv2/core/traits.hpp" 3
namespace cv { 
# 112 "/usr/include/opencv4/opencv2/core/traits.hpp" 3
template< class _Tp> class DataType { 
# 127 "/usr/include/opencv4/opencv2/core/traits.hpp" 3
}; 
# 129
template<> class DataType< bool>  { 
# 132
public: typedef bool value_type; 
# 133
typedef int work_type; 
# 134
typedef value_type channel_type; 
# 135
typedef value_type vec_type; 
# 136
enum { generic_type, 
# 137
depth = 0, 
# 138
channels, 
# 139
fmt = ((int)'u'), 
# 140
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 141
}; 
# 142
}; 
# 144
template<> class DataType< unsigned char>  { 
# 147
public: typedef uchar value_type; 
# 148
typedef int work_type; 
# 149
typedef value_type channel_type; 
# 150
typedef value_type vec_type; 
# 151
enum { generic_type, 
# 152
depth = 0, 
# 153
channels, 
# 154
fmt = ((int)'u'), 
# 155
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 156
}; 
# 157
}; 
# 159
template<> class DataType< signed char>  { 
# 162
public: typedef schar value_type; 
# 163
typedef int work_type; 
# 164
typedef value_type channel_type; 
# 165
typedef value_type vec_type; 
# 166
enum { generic_type, 
# 167
depth, 
# 168
channels = 1, 
# 169
fmt = ((int)'c'), 
# 170
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 171
}; 
# 172
}; 
# 174
template<> class DataType< char>  { 
# 177
public: typedef schar value_type; 
# 178
typedef int work_type; 
# 179
typedef value_type channel_type; 
# 180
typedef value_type vec_type; 
# 181
enum { generic_type, 
# 182
depth, 
# 183
channels = 1, 
# 184
fmt = ((int)'c'), 
# 185
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 186
}; 
# 187
}; 
# 189
template<> class DataType< unsigned short>  { 
# 192
public: typedef ushort value_type; 
# 193
typedef int work_type; 
# 194
typedef value_type channel_type; 
# 195
typedef value_type vec_type; 
# 196
enum { generic_type, 
# 197
depth = 2, 
# 198
channels = 1, 
# 199
fmt = ((int)'w'), 
# 200
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 201
}; 
# 202
}; 
# 204
template<> class DataType< short>  { 
# 207
public: typedef short value_type; 
# 208
typedef int work_type; 
# 209
typedef value_type channel_type; 
# 210
typedef value_type vec_type; 
# 211
enum { generic_type, 
# 212
depth = 3, 
# 213
channels = 1, 
# 214
fmt = ((int)'s'), 
# 215
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 216
}; 
# 217
}; 
# 219
template<> class DataType< int>  { 
# 222
public: typedef int value_type; 
# 223
typedef value_type work_type; 
# 224
typedef value_type channel_type; 
# 225
typedef value_type vec_type; 
# 226
enum { generic_type, 
# 227
depth = 4, 
# 228
channels = 1, 
# 229
fmt = ((int)'i'), 
# 230
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 231
}; 
# 232
}; 
# 234
template<> class DataType< float>  { 
# 237
public: typedef float value_type; 
# 238
typedef value_type work_type; 
# 239
typedef value_type channel_type; 
# 240
typedef value_type vec_type; 
# 241
enum { generic_type, 
# 242
depth = 5, 
# 243
channels = 1, 
# 244
fmt = ((int)'f'), 
# 245
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 246
}; 
# 247
}; 
# 249
template<> class DataType< double>  { 
# 252
public: typedef double value_type; 
# 253
typedef value_type work_type; 
# 254
typedef value_type channel_type; 
# 255
typedef value_type vec_type; 
# 256
enum { generic_type, 
# 257
depth = 6, 
# 258
channels = 1, 
# 259
fmt = ((int)'d'), 
# 260
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 261
}; 
# 262
}; 
# 264
template<> class DataType< float16_t>  { 
# 267
public: typedef float16_t value_type; 
# 268
typedef float work_type; 
# 269
typedef value_type channel_type; 
# 270
typedef value_type vec_type; 
# 271
enum { generic_type, 
# 272
depth = 7, 
# 273
channels = 1, 
# 274
fmt = ((int)'h'), 
# 275
type = ((depth & ((1 << 3) - 1)) + ((channels - 1) << 3))
# 276
}; 
# 277
}; 
# 284
template< class _Tp> class DataDepth { 
# 288
public: enum { 
# 289
value = DataType< _Tp> ::depth, 
# 290
fmt = DataType< _Tp> ::fmt
# 291
}; 
# 292
}; 
# 357 "/usr/include/opencv4/opencv2/core/traits.hpp" 3
namespace traits { 
# 359
namespace internal { 
# 374 "/usr/include/opencv4/opencv2/core/traits.hpp" 3
template< class T> class CheckMember_fmt { struct Fallback { int fmt; }; struct Derived : public T, public Fallback { }; template< class U, U > struct Check; typedef char CV_NO[1]; typedef char CV_YES[2]; template< class U> static CV_NO &func(Check< int (Fallback::*), &U::fmt>  *); template< class U> static CV_YES &func(...); public: typedef CheckMember_fmt type; enum { value = sizeof(func< Derived> (0)) == sizeof(CV_YES)}; }; 
# 375
template< class T> class CheckMember_type { struct Fallback { int type; }; struct Derived : public T, public Fallback { }; template< class U, U > struct Check; typedef char CV_NO[1]; typedef char CV_YES[2]; template< class U> static CV_NO &func(Check< int (Fallback::*), &U::type>  *); template< class U> static CV_YES &func(...); public: typedef CheckMember_type type; enum { value = sizeof(func< Derived> (0)) == sizeof(CV_YES)}; }; 
# 377
}
# 380
template< class T> 
# 381
struct Depth { 
# 382
enum { value = DataType< T> ::depth}; }; 
# 384
template< class T> 
# 385
struct Type { 
# 386
enum { value = DataType< T> ::type}; }; 
# 389
template< class T, bool available = internal::template CheckMember_type< DataType< T> > ::value> 
# 390
struct SafeType { }; 
# 392
template< class T> 
# 393
struct SafeType< T, false>  { 
# 394
enum { value = -1}; }; 
# 396
template< class T> 
# 397
struct SafeType< T, true>  { 
# 398
enum { value = Type< T> ::value}; }; 
# 401
template< class T, bool available = internal::template CheckMember_fmt< DataType< T> > ::value> 
# 402
struct SafeFmt { }; 
# 404
template< class T> 
# 405
struct SafeFmt< T, false>  { 
# 406
enum { fmt}; }; 
# 408
template< class T> 
# 409
struct SafeFmt< T, true>  { 
# 410
enum { fmt = DataType< T> ::fmt}; }; 
# 413
}
# 415
}
# 197 "/usr/include/opencv4/opencv2/core/fast_math.hpp" 3
static inline int cvRound(double value) 
# 198
{ 
# 215 "/usr/include/opencv4/opencv2/core/fast_math.hpp" 3
return (int)lrint(value); 
# 221
} 
# 231 "/usr/include/opencv4/opencv2/core/fast_math.hpp" 3
static inline int cvFloor(double value) 
# 232
{ 
# 239
int i = (int)value; 
# 240
return i - (i > value); 
# 242
} 
# 251 "/usr/include/opencv4/opencv2/core/fast_math.hpp" 3
static inline int cvCeil(double value) 
# 252
{ 
# 259
int i = (int)value; 
# 260
return i + (i < value); 
# 262
} 
# 270
static inline int cvIsNaN(double value) 
# 271
{ 
# 275
Cv64suf ieee754; 
# 276
(ieee754.f) = value; 
# 277
return ((((unsigned)((ieee754.u) >> 32)) & (2147483647)) + (((unsigned)(ieee754.u)) != (0))) > (2146435072); 
# 280
} 
# 288
static inline int cvIsInf(double value) 
# 289
{ 
# 293
Cv64suf ieee754; 
# 294
(ieee754.f) = value; 
# 295
return ((ieee754.u) & (9223372032559808512L)) == (9218868437227405312L); 
# 303
} 
# 308
static inline int cvRound(float value) 
# 309
{ 
# 326 "/usr/include/opencv4/opencv2/core/fast_math.hpp" 3
return (int)lrintf(value); 
# 332
} 
# 335
static inline int cvRound(int value) 
# 336
{ 
# 337
return value; 
# 338
} 
# 341
static inline int cvFloor(float value) 
# 342
{ 
# 349
int i = (int)value; 
# 350
return i - (i > value); 
# 352
} 
# 355
static inline int cvFloor(int value) 
# 356
{ 
# 357
return value; 
# 358
} 
# 361
static inline int cvCeil(float value) 
# 362
{ 
# 369
int i = (int)value; 
# 370
return i + (i < value); 
# 372
} 
# 375
static inline int cvCeil(int value) 
# 376
{ 
# 377
return value; 
# 378
} 
# 381
static inline int cvIsNaN(float value) 
# 382
{ 
# 386
Cv32suf ieee754; 
# 387
(ieee754.f) = value; 
# 388
return ((ieee754.u) & (2147483647)) > (2139095040); 
# 390
} 
# 393
static inline int cvIsInf(float value) 
# 394
{ 
# 398
Cv32suf ieee754; 
# 399
(ieee754.f) = value; 
# 400
return ((ieee754.u) & (2147483647)) == (2139095040); 
# 402
} 
# 51 "/usr/include/opencv4/opencv2/core/saturate.hpp" 3
namespace cv { 
# 80 "/usr/include/opencv4/opencv2/core/saturate.hpp" 3
template< class _Tp> static inline _Tp saturate_cast(uchar v) { return (_Tp)v; } 
# 82
template< class _Tp> static inline _Tp saturate_cast(schar v) { return (_Tp)v; } 
# 84
template< class _Tp> static inline _Tp saturate_cast(ushort v) { return (_Tp)v; } 
# 86
template< class _Tp> static inline _Tp saturate_cast(short v) { return (_Tp)v; } 
# 88
template< class _Tp> static inline _Tp saturate_cast(unsigned v) { return (_Tp)v; } 
# 90
template< class _Tp> static inline _Tp saturate_cast(int v) { return (_Tp)v; } 
# 92
template< class _Tp> static inline _Tp saturate_cast(float v) { return (_Tp)v; } 
# 94
template< class _Tp> static inline _Tp saturate_cast(double v) { return (_Tp)v; } 
# 96
template< class _Tp> static inline _Tp saturate_cast(int64 v) { return (_Tp)v; } 
# 98
template< class _Tp> static inline _Tp saturate_cast(uint64 v) { return (_Tp)v; } 
# 100
template<> inline uchar saturate_cast< unsigned char> (schar v) { return (uchar)std::max((int)v, 0); } 
# 101
template<> inline uchar saturate_cast< unsigned char> (ushort v) { return (uchar)std::min((unsigned)v, (unsigned)((127 * 2) + 1)); } 
# 102
template<> inline uchar saturate_cast< unsigned char> (int v) { return (uchar)((((unsigned)v) <= ((127 * 2) + 1)) ? v : ((v > 0) ? (127 * 2) + 1 : 0)); } 
# 103
template<> inline uchar saturate_cast< unsigned char> (short v) { return saturate_cast< unsigned char> ((int)v); } 
# 104
template<> inline uchar saturate_cast< unsigned char> (unsigned v) { return (uchar)std::min(v, (unsigned)((127 * 2) + 1)); } 
# 105
template<> inline uchar saturate_cast< unsigned char> (float v) { int iv = cvRound(v); return saturate_cast< unsigned char> (iv); } 
# 106
template<> inline uchar saturate_cast< unsigned char> (double v) { int iv = cvRound(v); return saturate_cast< unsigned char> (iv); } 
# 107
template<> inline uchar saturate_cast< unsigned char> (int64 v) { return (uchar)((((uint64)v) <= ((uint64)((127 * 2) + 1))) ? v : ((v > (0)) ? (127 * 2) + 1 : 0)); } 
# 108
template<> inline uchar saturate_cast< unsigned char> (uint64 v) { return (uchar)std::min(v, (uint64)((127 * 2) + 1)); } 
# 110
template<> inline schar saturate_cast< signed char> (uchar v) { return (schar)std::min((int)v, 127); } 
# 111
template<> inline schar saturate_cast< signed char> (ushort v) { return (schar)std::min((unsigned)v, (unsigned)127); } 
# 112
template<> inline schar saturate_cast< signed char> (int v) { return (schar)((((unsigned)(v - ((-127) - 1))) <= ((unsigned)((127 * 2) + 1))) ? v : ((v > 0) ? 127 : ((-127) - 1))); } 
# 113
template<> inline schar saturate_cast< signed char> (short v) { return saturate_cast< signed char> ((int)v); } 
# 114
template<> inline schar saturate_cast< signed char> (unsigned v) { return (schar)std::min(v, (unsigned)127); } 
# 115
template<> inline schar saturate_cast< signed char> (float v) { int iv = cvRound(v); return saturate_cast< signed char> (iv); } 
# 116
template<> inline schar saturate_cast< signed char> (double v) { int iv = cvRound(v); return saturate_cast< signed char> (iv); } 
# 117
template<> inline schar saturate_cast< signed char> (int64 v) { return (schar)((((uint64)(((int64)v) - ((-127) - 1))) <= ((uint64)((127 * 2) + 1))) ? v : ((v > (0)) ? 127 : ((-127) - 1))); } 
# 118
template<> inline schar saturate_cast< signed char> (uint64 v) { return (schar)std::min(v, (uint64)127); } 
# 120
template<> inline ushort saturate_cast< unsigned short> (schar v) { return (ushort)std::max((int)v, 0); } 
# 121
template<> inline ushort saturate_cast< unsigned short> (short v) { return (ushort)std::max((int)v, 0); } 
# 122
template<> inline ushort saturate_cast< unsigned short> (int v) { return (ushort)((((unsigned)v) <= ((unsigned)((32767 * 2) + 1))) ? v : ((v > 0) ? (32767 * 2) + 1 : 0)); } 
# 123
template<> inline ushort saturate_cast< unsigned short> (unsigned v) { return (ushort)std::min(v, (unsigned)((32767 * 2) + 1)); } 
# 124
template<> inline ushort saturate_cast< unsigned short> (float v) { int iv = cvRound(v); return saturate_cast< unsigned short> (iv); } 
# 125
template<> inline ushort saturate_cast< unsigned short> (double v) { int iv = cvRound(v); return saturate_cast< unsigned short> (iv); } 
# 126
template<> inline ushort saturate_cast< unsigned short> (int64 v) { return (ushort)((((uint64)v) <= ((uint64)((32767 * 2) + 1))) ? v : ((v > (0)) ? (32767 * 2) + 1 : 0)); } 
# 127
template<> inline ushort saturate_cast< unsigned short> (uint64 v) { return (ushort)std::min(v, (uint64)((32767 * 2) + 1)); } 
# 129
template<> inline short saturate_cast< short> (ushort v) { return (short)std::min((int)v, 32767); } 
# 130
template<> inline short saturate_cast< short> (int v) { return (short)((((unsigned)(v - ((-32767) - 1))) <= ((unsigned)((32767 * 2) + 1))) ? v : ((v > 0) ? 32767 : ((-32767) - 1))); } 
# 131
template<> inline short saturate_cast< short> (unsigned v) { return (short)std::min(v, (unsigned)32767); } 
# 132
template<> inline short saturate_cast< short> (float v) { int iv = cvRound(v); return saturate_cast< short> (iv); } 
# 133
template<> inline short saturate_cast< short> (double v) { int iv = cvRound(v); return saturate_cast< short> (iv); } 
# 134
template<> inline short saturate_cast< short> (int64 v) { return (short)((((uint64)(((int64)v) - ((-32767) - 1))) <= ((uint64)((32767 * 2) + 1))) ? v : ((v > (0)) ? 32767 : ((-32767) - 1))); } 
# 135
template<> inline short saturate_cast< short> (uint64 v) { return (short)std::min(v, (uint64)32767); } 
# 137
template<> inline int saturate_cast< int> (unsigned v) { return (int)std::min(v, (unsigned)2147483647); } 
# 138
template<> inline int saturate_cast< int> (int64 v) { return (int)((((uint64)(v - ((-2147483647) - 1))) <= ((uint64)(((2147483647) * 2U) + 1U))) ? v : ((v > (0)) ? 2147483647 : ((-2147483647) - 1))); } 
# 139
template<> inline int saturate_cast< int> (uint64 v) { return (int)std::min(v, (uint64)2147483647); } 
# 140
template<> inline int saturate_cast< int> (float v) { return cvRound(v); } 
# 141
template<> inline int saturate_cast< int> (double v) { return cvRound(v); } 
# 143
template<> inline unsigned saturate_cast< unsigned> (schar v) { return (unsigned)std::max(v, (schar)0); } 
# 144
template<> inline unsigned saturate_cast< unsigned> (short v) { return (unsigned)std::max(v, (short)0); } 
# 145
template<> inline unsigned saturate_cast< unsigned> (int v) { return (unsigned)std::max(v, (int)0); } 
# 146
template<> inline unsigned saturate_cast< unsigned> (int64 v) { return (unsigned)((((uint64)v) <= ((uint64)(((2147483647) * 2U) + 1U))) ? v : ((v > (0)) ? ((2147483647) * 2U) + 1U : (0))); } 
# 147
template<> inline unsigned saturate_cast< unsigned> (uint64 v) { return (unsigned)std::min(v, (uint64)(((2147483647) * 2U) + 1U)); } 
# 149
template<> inline unsigned saturate_cast< unsigned> (float v) { return static_cast< unsigned>(cvRound(v)); } 
# 150
template<> inline unsigned saturate_cast< unsigned> (double v) { return static_cast< unsigned>(cvRound(v)); } 
# 152
template<> inline uint64 saturate_cast< unsigned long> (schar v) { return (uint64)std::max(v, (schar)0); } 
# 153
template<> inline uint64 saturate_cast< unsigned long> (short v) { return (uint64)std::max(v, (short)0); } 
# 154
template<> inline uint64 saturate_cast< unsigned long> (int v) { return (uint64)std::max(v, (int)0); } 
# 155
template<> inline uint64 saturate_cast< unsigned long> (int64 v) { return (uint64)std::max(v, (int64)0); } 
# 157
template<> inline int64 saturate_cast< signed long> (uint64 v) { return (int64)std::min(v, (uint64)9223372036854775807LL); } 
# 160
template< class _Tp> static inline _Tp saturate_cast(float16_t v) { return saturate_cast< _Tp> ((float)v); } 
# 164
template<> inline float16_t saturate_cast< float16_t> (uchar v) { return ((float16_t)((float)v)); } 
# 165
template<> inline float16_t saturate_cast< float16_t> (schar v) { return ((float16_t)((float)v)); } 
# 166
template<> inline float16_t saturate_cast< float16_t> (ushort v) { return ((float16_t)((float)v)); } 
# 167
template<> inline float16_t saturate_cast< float16_t> (short v) { return ((float16_t)((float)v)); } 
# 168
template<> inline float16_t saturate_cast< float16_t> (unsigned v) { return ((float16_t)((float)v)); } 
# 169
template<> inline float16_t saturate_cast< float16_t> (int v) { return ((float16_t)((float)v)); } 
# 170
template<> inline float16_t saturate_cast< float16_t> (uint64 v) { return ((float16_t)((float)v)); } 
# 171
template<> inline float16_t saturate_cast< float16_t> (int64 v) { return ((float16_t)((float)v)); } 
# 172
template<> inline float16_t saturate_cast< float16_t> (float v) { return ((float16_t)(v)); } 
# 173
template<> inline float16_t saturate_cast< float16_t> (double v) { return ((float16_t)((float)v)); } 
# 177
}
# 58 "/usr/include/opencv4/opencv2/core/matx.hpp" 3
namespace cv { 
# 68 "/usr/include/opencv4/opencv2/core/matx.hpp" 3
struct Matx_AddOp { Matx_AddOp() { } Matx_AddOp(const Matx_AddOp &) { } }; 
# 69
struct Matx_SubOp { Matx_SubOp() { } Matx_SubOp(const Matx_SubOp &) { } }; 
# 70
struct Matx_ScaleOp { Matx_ScaleOp() { } Matx_ScaleOp(const Matx_ScaleOp &) { } }; 
# 71
struct Matx_MulOp { Matx_MulOp() { } Matx_MulOp(const Matx_MulOp &) { } }; 
# 72
struct Matx_DivOp { Matx_DivOp() { } Matx_DivOp(const Matx_DivOp &) { } }; 
# 73
struct Matx_MatMulOp { Matx_MatMulOp() { } Matx_MatMulOp(const Matx_MatMulOp &) { } }; 
# 74
struct Matx_TOp { Matx_TOp() { } Matx_TOp(const Matx_TOp &) { } }; 
# 99 "/usr/include/opencv4/opencv2/core/matx.hpp" 3
template< class _Tp, int m, int n> class Matx { 
# 102
public: enum { 
# 103
rows = m, 
# 104
cols = n, 
# 105
channels = (m) * (n), 
# 110
shortdim = (m < n) ? m : n
# 111
}; 
# 113
typedef _Tp value_type; 
# 114
typedef Matx mat_type; 
# 115
typedef Matx< _Tp, shortdim, 1>  diag_type; 
# 118
inline Matx(); 
# 120
inline explicit Matx(_Tp v0); 
# 121
inline Matx(_Tp v0, _Tp v1); 
# 122
inline Matx(_Tp v0, _Tp v1, _Tp v2); 
# 123
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3); 
# 124
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); 
# 125
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); 
# 126
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); 
# 127
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); 
# 128
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); 
# 129
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); 
# 130
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11); 
# 133
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13); 
# 137
inline Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15); 
# 141
inline explicit Matx(const _Tp * vals); 
# 143
inline Matx(std::initializer_list< _Tp> ); 
# 145
static inline Matx all(_Tp alpha); 
# 146
static inline Matx zeros(); 
# 147
static inline Matx ones(); 
# 148
static inline Matx eye(); 
# 149
static inline Matx diag(const diag_type & d); 
# 150
static inline Matx randu(_Tp a, _Tp b); 
# 151
static inline Matx randn(_Tp a, _Tp b); 
# 154
inline _Tp dot(const Matx & v) const; 
# 157
inline double ddot(const Matx & v) const; 
# 160
template< class T2> inline operator Matx< T2, m, n> () const; 
# 163
template< int m1, int n1> inline Matx< _Tp, m1, n1>  reshape() const; 
# 166
template< int m1, int n1> inline Matx< _Tp, m1, n1>  get_minor(int base_row, int base_col) const; 
# 169
inline Matx< _Tp, 1, n>  row(int i) const; 
# 172
inline Matx< _Tp, m, 1>  col(int i) const; 
# 175
inline diag_type diag() const; 
# 178
inline Matx< _Tp, n, m>  t() const; 
# 181
inline Matx< _Tp, n, m>  inv(int method = DECOMP_LU, bool * p_is_ok = 0) const; 
# 184
template< int l> inline Matx< _Tp, n, l>  solve(const Matx< _Tp, m, l>  & rhs, int flags = DECOMP_LU) const; 
# 185
inline Vec< _Tp, n>  solve(const Vec< _Tp, m>  & rhs, int method) const; 
# 188
inline Matx mul(const Matx & a) const; 
# 191
inline Matx div(const Matx & a) const; 
# 194
inline const _Tp &operator()(int row, int col) const; 
# 195
inline _Tp &operator()(int row, int col); 
# 198
inline const _Tp &operator()(int i) const; 
# 199
inline _Tp &operator()(int i); 
# 201
inline Matx(const Matx & a, const Matx & b, Matx_AddOp); 
# 202
inline Matx(const Matx & a, const Matx & b, Matx_SubOp); 
# 203
template< class _T2> inline Matx(const Matx & a, _T2 alpha, Matx_ScaleOp); 
# 204
inline Matx(const Matx & a, const Matx & b, Matx_MulOp); 
# 205
inline Matx(const Matx & a, const Matx & b, Matx_DivOp); 
# 206
template< int l> inline Matx(const Matx< _Tp, m, l>  & a, const Matx< _Tp, l, n>  & b, Matx_MatMulOp); 
# 207
inline Matx(const Matx< _Tp, n, m>  & a, Matx_TOp); 
# 209
_Tp val[m * n]; 
# 210
}; 
# 212
typedef Matx< float, 1, 2>  Matx12f; 
# 213
typedef Matx< double, 1, 2>  Matx12d; 
# 214
typedef Matx< float, 1, 3>  Matx13f; 
# 215
typedef Matx< double, 1, 3>  Matx13d; 
# 216
typedef Matx< float, 1, 4>  Matx14f; 
# 217
typedef Matx< double, 1, 4>  Matx14d; 
# 218
typedef Matx< float, 1, 6>  Matx16f; 
# 219
typedef Matx< double, 1, 6>  Matx16d; 
# 221
typedef Matx< float, 2, 1>  Matx21f; 
# 222
typedef Matx< double, 2, 1>  Matx21d; 
# 223
typedef Matx< float, 3, 1>  Matx31f; 
# 224
typedef Matx< double, 3, 1>  Matx31d; 
# 225
typedef Matx< float, 4, 1>  Matx41f; 
# 226
typedef Matx< double, 4, 1>  Matx41d; 
# 227
typedef Matx< float, 6, 1>  Matx61f; 
# 228
typedef Matx< double, 6, 1>  Matx61d; 
# 230
typedef Matx< float, 2, 2>  Matx22f; 
# 231
typedef Matx< double, 2, 2>  Matx22d; 
# 232
typedef Matx< float, 2, 3>  Matx23f; 
# 233
typedef Matx< double, 2, 3>  Matx23d; 
# 234
typedef Matx< float, 3, 2>  Matx32f; 
# 235
typedef Matx< double, 3, 2>  Matx32d; 
# 237
typedef Matx< float, 3, 3>  Matx33f; 
# 238
typedef Matx< double, 3, 3>  Matx33d; 
# 240
typedef Matx< float, 3, 4>  Matx34f; 
# 241
typedef Matx< double, 3, 4>  Matx34d; 
# 242
typedef Matx< float, 4, 3>  Matx43f; 
# 243
typedef Matx< double, 4, 3>  Matx43d; 
# 245
typedef Matx< float, 4, 4>  Matx44f; 
# 246
typedef Matx< double, 4, 4>  Matx44d; 
# 247
typedef Matx< float, 6, 6>  Matx66f; 
# 248
typedef Matx< double, 6, 6>  Matx66d; 
# 253
template< class _Tp, int m, int n> class DataType< Matx< _Tp, m, n> >  { 
# 256
public: typedef Matx< _Tp, m, n>  value_type; 
# 257
typedef Matx< typename cv::DataType< _Tp> ::work_type, m, n>  work_type; 
# 258
typedef _Tp channel_type; 
# 259
typedef value_type vec_type; 
# 261
enum { generic_type, 
# 262
channels = m * n, 
# 263
fmt = traits::template SafeFmt< channel_type> ::fmt + (((m * n) - 1) << 8)
# 268
}; 
# 269
}; 
# 271
namespace traits { 
# 272
template< class _Tp, int m, int n> 
# 273
struct Depth< Matx< _Tp, m, n> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 274
template< class _Tp, int m, int n> 
# 275
struct Type< Matx< _Tp, m, n> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + (((n * m) - 1) << 3)}; }; 
# 276
}
# 281
template< class _Tp, int m, int n> class MatxCommaInitializer { 
# 284
public: inline MatxCommaInitializer(Matx< _Tp, m, n>  * _mtx); 
# 285
template< class T2> inline MatxCommaInitializer &operator,(T2 val); 
# 286
inline Matx< _Tp, m, n>  operator*() const; 
# 288
Matx< _Tp, m, n>  *dst; 
# 289
int idx; 
# 290
}; 
# 295
template< class _Tp, int m> static inline double determinant(const Matx< _Tp, m, m>  & a); 
# 296
template< class _Tp, int m, int n> static inline double trace(const Matx< _Tp, m, n>  & a); 
# 297
template< class _Tp, int m, int n> static inline double norm(const Matx< _Tp, m, n>  & M); 
# 298
template< class _Tp, int m, int n> static inline double norm(const Matx< _Tp, m, n>  & M, int normType); 
# 332 "/usr/include/opencv4/opencv2/core/matx.hpp" 3
template< class _Tp, int cn> class Vec : public Matx< _Tp, cn, 1>  { 
# 335
public: typedef _Tp value_type; 
# 336
enum { 
# 337
channels = cn, 
# 342
_dummy_enum_finalizer = 0
# 343
}; 
# 346
inline Vec(); 
# 348
inline Vec(_Tp v0); 
# 349
inline Vec(_Tp v0, _Tp v1); 
# 350
inline Vec(_Tp v0, _Tp v1, _Tp v2); 
# 351
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3); 
# 352
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4); 
# 353
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5); 
# 354
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6); 
# 355
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7); 
# 356
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8); 
# 357
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9); 
# 358
inline Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13); 
# 359
inline explicit Vec(const _Tp * values); 
# 361
inline Vec(std::initializer_list< _Tp> ); 
# 363
inline Vec(const Vec & v); 
# 365
static inline Vec all(_Tp alpha); 
# 368
inline Vec mul(const Vec & v) const; 
# 371
Vec conj() const; 
# 378
inline Vec cross(const Vec & v) const; 
# 380
template< class T2> inline operator Vec< T2, cn> () const; 
# 383
inline const _Tp &operator[](int i) const; 
# 384
inline _Tp &operator[](int i); 
# 385
inline const _Tp &operator()(int i) const; 
# 386
inline _Tp &operator()(int i); 
# 389
Vec &operator=(const Vec & rhs) = default;
# 392
inline Vec(const Matx< _Tp, cn, 1>  & a, const Matx< _Tp, cn, 1>  & b, cv::Matx_AddOp); 
# 393
inline Vec(const Matx< _Tp, cn, 1>  & a, const Matx< _Tp, cn, 1>  & b, cv::Matx_SubOp); 
# 394
template< class _T2> inline Vec(const Matx< _Tp, cn, 1>  & a, _T2 alpha, cv::Matx_ScaleOp); 
# 395
}; 
# 400
typedef Vec< unsigned char, 2>  Vec2b; 
# 401
typedef Vec< unsigned char, 3>  Vec3b; 
# 402
typedef Vec< unsigned char, 4>  Vec4b; 
# 404
typedef Vec< short, 2>  Vec2s; 
# 405
typedef Vec< short, 3>  Vec3s; 
# 406
typedef Vec< short, 4>  Vec4s; 
# 408
typedef Vec< unsigned short, 2>  Vec2w; 
# 409
typedef Vec< unsigned short, 3>  Vec3w; 
# 410
typedef Vec< unsigned short, 4>  Vec4w; 
# 412
typedef Vec< int, 2>  Vec2i; 
# 413
typedef Vec< int, 3>  Vec3i; 
# 414
typedef Vec< int, 4>  Vec4i; 
# 415
typedef Vec< int, 6>  Vec6i; 
# 416
typedef Vec< int, 8>  Vec8i; 
# 418
typedef Vec< float, 2>  Vec2f; 
# 419
typedef Vec< float, 3>  Vec3f; 
# 420
typedef Vec< float, 4>  Vec4f; 
# 421
typedef Vec< float, 6>  Vec6f; 
# 423
typedef Vec< double, 2>  Vec2d; 
# 424
typedef Vec< double, 3>  Vec3d; 
# 425
typedef Vec< double, 4>  Vec4d; 
# 426
typedef Vec< double, 6>  Vec6d; 
# 432
template< class _Tp, int cn> class DataType< Vec< _Tp, cn> >  { 
# 435
public: typedef Vec< _Tp, cn>  value_type; 
# 436
typedef Vec< typename cv::DataType< _Tp> ::work_type, cn>  work_type; 
# 437
typedef _Tp channel_type; 
# 438
typedef value_type vec_type; 
# 440
enum { generic_type, 
# 441
channels = cn, 
# 442
fmt = DataType< _Tp> ::fmt + (((cn) - 1) << 8), 
# 447
_dummy_enum_finalizer = 0
# 448
}; 
# 449
}; 
# 451
namespace traits { 
# 452
template< class _Tp, int cn> 
# 453
struct Depth< Vec< _Tp, cn> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 454
template< class _Tp, int cn> 
# 455
struct Type< Vec< _Tp, cn> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((cn - 1) << 3)}; }; 
# 456
}
# 461
template< class _Tp, int m> class VecCommaInitializer : public MatxCommaInitializer< _Tp, m, 1>  { 
# 464
public: inline VecCommaInitializer(Vec< _Tp, m>  * _vec); 
# 465
template< class T2> inline VecCommaInitializer &operator,(T2 val); 
# 466
inline Vec< _Tp, m>  operator*() const; 
# 467
}; 
# 469
template< class _Tp, int cn> static inline Vec< _Tp, cn>  normalize(const Vec< _Tp, cn>  & v); 
# 476
namespace internal { 
# 479
template< class _Tp, int m> struct Matx_DetOp { 
# 481
double operator()(const Matx< _Tp, m, m>  &a) const 
# 482
{ 
# 483
Matx< _Tp, m, m>  temp = a; 
# 484
double p = LU((temp.val), (m) * sizeof(_Tp), m, 0, 0, 0); 
# 485
if (p == (0)) { 
# 486
return p; }  
# 487
for (int i = 0; i < m; i++) { 
# 488
p *= temp(i, i); }  
# 489
return p; 
# 490
} 
# 491
}; 
# 493
template< class _Tp> struct Matx_DetOp< _Tp, 1>  { 
# 495
double operator()(const Matx< _Tp, 1, 1>  &a) const 
# 496
{ 
# 497
return a(0, 0); 
# 498
} 
# 499
}; 
# 501
template< class _Tp> struct Matx_DetOp< _Tp, 2>  { 
# 503
double operator()(const Matx< _Tp, 2, 2>  &a) const 
# 504
{ 
# 505
return (a(0, 0) * a(1, 1)) - (a(0, 1) * a(1, 0)); 
# 506
} 
# 507
}; 
# 509
template< class _Tp> struct Matx_DetOp< _Tp, 3>  { 
# 511
double operator()(const Matx< _Tp, 3, 3>  &a) const 
# 512
{ 
# 513
return ((a(0, 0) * ((a(1, 1) * a(2, 2)) - (a(2, 1) * a(1, 2)))) - (a(0, 1) * ((a(1, 0) * a(2, 2)) - (a(2, 0) * a(1, 2))))) + (a(0, 2) * ((a(1, 0) * a(2, 1)) - (a(2, 0) * a(1, 1)))); 
# 516
} 
# 517
}; 
# 519
template< class _Tp> inline Vec< _Tp, 2>  conjugate(const Vec< _Tp, 2>  &v) 
# 520
{ 
# 521
return Vec< _Tp, 2> (v[0], -(v[1])); 
# 522
} 
# 524
template< class _Tp> inline Vec< _Tp, 4>  conjugate(const Vec< _Tp, 4>  &v) 
# 525
{ 
# 526
return Vec< _Tp, 4> (v[0], -(v[1]), -(v[2]), -(v[3])); 
# 527
} 
# 529
}
# 535
template< class _Tp, int m, int n> inline 
# 536
Matx< _Tp, m, n> ::Matx() 
# 537
{ 
# 538
for (int i = 0; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 539
} 
# 541
template< class _Tp, int m, int n> inline 
# 542
Matx< _Tp, m, n> ::Matx(_Tp v0) 
# 543
{ 
# 544
((val)[0]) = v0; 
# 545
for (int i = 1; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 546
} 
# 548
template< class _Tp, int m, int n> inline 
# 549
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1) 
# 550
{ 
# 551
static_assert((channels >= 2), "Matx should have at least 2 elements. channels >= 2");
# 552
((val)[0]) = v0; ((val)[1]) = v1; 
# 553
for (int i = 2; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 554
} 
# 556
template< class _Tp, int m, int n> inline 
# 557
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2) 
# 558
{ 
# 559
static_assert((channels >= 3), "Matx should have at least 3 elements. channels >= 3");
# 560
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; 
# 561
for (int i = 3; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 562
} 
# 564
template< class _Tp, int m, int n> inline 
# 565
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3) 
# 566
{ 
# 567
static_assert((channels >= 4), "Matx should have at least 4 elements. channels >= 4");
# 568
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 569
for (int i = 4; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 570
} 
# 572
template< class _Tp, int m, int n> inline 
# 573
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4) 
# 574
{ 
# 575
static_assert((channels >= 5), "Matx should have at least 5 elements. channels >= 5");
# 576
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; ((val)[4]) = v4; 
# 577
for (int i = 5; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 578
} 
# 580
template< class _Tp, int m, int n> inline 
# 581
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5) 
# 582
{ 
# 583
static_assert((channels >= 6), "Matx should have at least 6 elements. channels >= 6");
# 584
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 585
((val)[4]) = v4; ((val)[5]) = v5; 
# 586
for (int i = 6; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 587
} 
# 589
template< class _Tp, int m, int n> inline 
# 590
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6) 
# 591
{ 
# 592
static_assert((channels >= 7), "Matx should have at least 7 elements. channels >= 7");
# 593
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 594
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; 
# 595
for (int i = 7; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 596
} 
# 598
template< class _Tp, int m, int n> inline 
# 599
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7) 
# 600
{ 
# 601
static_assert((channels >= 8), "Matx should have at least 8 elements. channels >= 8");
# 602
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 603
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 604
for (int i = 8; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 605
} 
# 607
template< class _Tp, int m, int n> inline 
# 608
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8) 
# 609
{ 
# 610
static_assert((channels >= 9), "Matx should have at least 9 elements. channels >= 9");
# 611
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 612
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 613
((val)[8]) = v8; 
# 614
for (int i = 9; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 615
} 
# 617
template< class _Tp, int m, int n> inline 
# 618
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9) 
# 619
{ 
# 620
static_assert((channels >= 10), "Matx should have at least 10 elements. channels >= 10");
# 621
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 622
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 623
((val)[8]) = v8; ((val)[9]) = v9; 
# 624
for (int i = 10; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 625
} 
# 628
template< class _Tp, int m, int n> inline 
# 629
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11) 
# 630
{ 
# 631
static_assert((channels >= 12), "Matx should have at least 12 elements. channels >= 12");
# 632
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 633
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 634
((val)[8]) = v8; ((val)[9]) = v9; ((val)[10]) = v10; ((val)[11]) = v11; 
# 635
for (int i = 12; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 636
} 
# 638
template< class _Tp, int m, int n> inline 
# 639
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13) 
# 640
{ 
# 641
static_assert((channels >= 14), "Matx should have at least 14 elements. channels >= 14");
# 642
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 643
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 644
((val)[8]) = v8; ((val)[9]) = v9; ((val)[10]) = v10; ((val)[11]) = v11; 
# 645
((val)[12]) = v12; ((val)[13]) = v13; 
# 646
for (int i = 14; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 647
} 
# 650
template< class _Tp, int m, int n> inline 
# 651
Matx< _Tp, m, n> ::Matx(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13, _Tp v14, _Tp v15) 
# 652
{ 
# 653
static_assert((channels >= 16), "Matx should have at least 16 elements. channels >= 16");
# 654
((val)[0]) = v0; ((val)[1]) = v1; ((val)[2]) = v2; ((val)[3]) = v3; 
# 655
((val)[4]) = v4; ((val)[5]) = v5; ((val)[6]) = v6; ((val)[7]) = v7; 
# 656
((val)[8]) = v8; ((val)[9]) = v9; ((val)[10]) = v10; ((val)[11]) = v11; 
# 657
((val)[12]) = v12; ((val)[13]) = v13; ((val)[14]) = v14; ((val)[15]) = v15; 
# 658
for (int i = 16; i < channels; i++) { ((val)[i]) = ((_Tp)0); }  
# 659
} 
# 661
template< class _Tp, int m, int n> inline 
# 662
Matx< _Tp, m, n> ::Matx(const _Tp *values) 
# 663
{ 
# 664
for (int i = 0; i < channels; i++) { ((val)[i]) = (values[i]); }  
# 665
} 
# 667
template< class _Tp, int m, int n> inline 
# 668
Matx< _Tp, m, n> ::Matx(std::initializer_list< _Tp>  list) 
# 669
{ 
# 670
; 
# 671
int i = 0; 
# 672
for (const auto &elem : list) 
# 673
{ 
# 674
((val)[i++]) = elem; 
# 675
}  
# 676
} 
# 678
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 679
Matx< _Tp, m, n> ::all(_Tp alpha) 
# 680
{ 
# 681
Matx M; 
# 682
for (int i = 0; i < (m * n); i++) { ((M.val)[i]) = alpha; }  
# 683
return M; 
# 684
} 
# 686
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 687
Matx< _Tp, m, n> ::zeros() 
# 688
{ 
# 689
return (all)(0); 
# 690
} 
# 692
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 693
Matx< _Tp, m, n> ::ones() 
# 694
{ 
# 695
return (all)(1); 
# 696
} 
# 698
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 699
Matx< _Tp, m, n> ::eye() 
# 700
{ 
# 701
Matx M; 
# 702
for (int i = 0; i < shortdim; i++) { 
# 703
M(i, i) = 1; }  
# 704
return M; 
# 705
} 
# 707
template< class _Tp, int m, int n> inline _Tp 
# 708
Matx< _Tp, m, n> ::dot(const Matx &M) const 
# 709
{ 
# 710
_Tp s = (0); 
# 711
for (int i = 0; i < channels; i++) { s += (((val)[i]) * ((M.val)[i])); }  
# 712
return s; 
# 713
} 
# 715
template< class _Tp, int m, int n> inline double 
# 716
Matx< _Tp, m, n> ::ddot(const Matx &M) const 
# 717
{ 
# 718
double s = (0); 
# 719
for (int i = 0; i < channels; i++) { s += (((double)((val)[i])) * ((M.val)[i])); }  
# 720
return s; 
# 721
} 
# 723
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 724
Matx< _Tp, m, n> ::diag(const diag_type &d) 
# 725
{ 
# 726
Matx M; 
# 727
for (int i = 0; i < shortdim; i++) { 
# 728
M(i, i) = d(i, 0); }  
# 729
return M; 
# 730
} 
# 732
template< class _Tp, int m, int n> template< class T2> inline 
# 733
Matx< _Tp, m, n> ::operator Matx< T2, m, n> () const 
# 734
{ 
# 735
Matx< T2, m, n>  M; 
# 736
for (int i = 0; i < (m * n); i++) { ((M.val)[i]) = saturate_cast< T2> ((val)[i]); }  
# 737
return M; 
# 738
} 
# 740
template< class _Tp, int m, int n> template< int m1, int n1> inline Matx< _Tp, m1, n1>  
# 741
Matx< _Tp, m, n> ::reshape() const 
# 742
{ 
# 743
static_assert(((m1 * n1) == (m * n)), "Input and destnarion matrices must have the same number of elements m1*n1 == m*n");
# 744
return (const Matx< _Tp, m1, n1>  &)(*this); 
# 745
} 
# 747
template< class _Tp, int m, int n> 
# 748
template< int m1, int n1> inline Matx< _Tp, m1, n1>  
# 749
Matx< _Tp, m, n> ::get_minor(int base_row, int base_col) const 
# 750
{ 
# 751
; 
# 752
Matx< _Tp, m1, n1>  s; 
# 753
for (int di = 0; di < m1; di++) { 
# 754
for (int dj = 0; dj < n1; dj++) { 
# 755
s(di, dj) = (*this)(base_row + di, base_col + dj); }  }  
# 756
return s; 
# 757
} 
# 759
template< class _Tp, int m, int n> inline Matx< _Tp, 1, n>  
# 760
Matx< _Tp, m, n> ::row(int i) const 
# 761
{ 
# 762
; 
# 763
return ((Matx< _Tp, 1, n> )(&((val)[i * n]))); 
# 764
} 
# 766
template< class _Tp, int m, int n> inline Matx< _Tp, m, 1>  
# 767
Matx< _Tp, m, n> ::col(int j) const 
# 768
{ 
# 769
; 
# 770
Matx< _Tp, m, 1>  v; 
# 771
for (int i = 0; i < m; i++) { 
# 772
((v.val)[i]) = ((val)[(i * n) + j]); }  
# 773
return v; 
# 774
} 
# 776
template< class _Tp, int m, int n> inline typename Matx< _Tp, m, n> ::diag_type 
# 777
Matx< _Tp, m, n> ::diag() const 
# 778
{ 
# 779
diag_type d; 
# 780
for (int i = 0; i < shortdim; i++) { 
# 781
((d.val)[i]) = ((val)[(i * n) + i]); }  
# 782
return d; 
# 783
} 
# 785
template< class _Tp, int m, int n> inline const _Tp &
# 786
Matx< _Tp, m, n> ::operator()(int row_idx, int col_idx) const 
# 787
{ 
# 788
; 
# 789
return (this->val)[(row_idx * n) + col_idx]; 
# 790
} 
# 792
template< class _Tp, int m, int n> inline _Tp &
# 793
Matx< _Tp, m, n> ::operator()(int row_idx, int col_idx) 
# 794
{ 
# 795
; 
# 796
return (val)[(row_idx * n) + col_idx]; 
# 797
} 
# 799
template< class _Tp, int m, int n> inline const _Tp &
# 800
Matx< _Tp, m, n> ::operator()(int i) const 
# 801
{ 
# 802
static_assert(((m == 1) || (n == 1)), "Single index indexation requires matrix to be a column or a row m == 1 || n == 1");
# 803
; 
# 804
return (val)[i]; 
# 805
} 
# 807
template< class _Tp, int m, int n> inline _Tp &
# 808
Matx< _Tp, m, n> ::operator()(int i) 
# 809
{ 
# 810
static_assert(((m == 1) || (n == 1)), "Single index indexation requires matrix to be a column or a row m == 1 || n == 1");
# 811
; 
# 812
return (val)[i]; 
# 813
} 
# 815
template< class _Tp, int m, int n> inline 
# 816
Matx< _Tp, m, n> ::Matx(const Matx &a, const Matx &b, Matx_AddOp) 
# 817
{ 
# 818
for (int i = 0; i < channels; i++) { 
# 819
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) + ((b.val)[i])); }  
# 820
} 
# 822
template< class _Tp, int m, int n> inline 
# 823
Matx< _Tp, m, n> ::Matx(const Matx &a, const Matx &b, Matx_SubOp) 
# 824
{ 
# 825
for (int i = 0; i < channels; i++) { 
# 826
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) - ((b.val)[i])); }  
# 827
} 
# 829
template< class _Tp, int m, int n> template< class _T2> inline 
# 830
Matx< _Tp, m, n> ::Matx(const Matx &a, _T2 alpha, Matx_ScaleOp) 
# 831
{ 
# 832
for (int i = 0; i < channels; i++) { 
# 833
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * alpha); }  
# 834
} 
# 836
template< class _Tp, int m, int n> inline 
# 837
Matx< _Tp, m, n> ::Matx(const Matx &a, const Matx &b, Matx_MulOp) 
# 838
{ 
# 839
for (int i = 0; i < channels; i++) { 
# 840
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * ((b.val)[i])); }  
# 841
} 
# 843
template< class _Tp, int m, int n> inline 
# 844
Matx< _Tp, m, n> ::Matx(const Matx &a, const Matx &b, Matx_DivOp) 
# 845
{ 
# 846
for (int i = 0; i < channels; i++) { 
# 847
((val)[i]) = saturate_cast< _Tp> (((a.val)[i]) / ((b.val)[i])); }  
# 848
} 
# 850
template< class _Tp, int m, int n> template< int l> inline 
# 851
Matx< _Tp, m, n> ::Matx(const Matx< _Tp, m, l>  &a, const Matx< _Tp, l, n>  &b, Matx_MatMulOp) 
# 852
{ 
# 853
for (int i = 0; i < m; i++) { 
# 854
for (int j = 0; j < n; j++) 
# 855
{ 
# 856
_Tp s = (0); 
# 857
for (int k = 0; k < l; k++) { 
# 858
s += (a(i, k) * b(k, j)); }  
# 859
((val)[(i * n) + j]) = s; 
# 860
}  }  
# 861
} 
# 863
template< class _Tp, int m, int n> inline 
# 864
Matx< _Tp, m, n> ::Matx(const Matx< _Tp, n, m>  &a, Matx_TOp) 
# 865
{ 
# 866
for (int i = 0; i < m; i++) { 
# 867
for (int j = 0; j < n; j++) { 
# 868
((val)[(i * n) + j]) = a(j, i); }  }  
# 869
} 
# 871
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 872
Matx< _Tp, m, n> ::mul(const Matx &a) const 
# 873
{ 
# 874
return Matx(*this, a, Matx_MulOp()); 
# 875
} 
# 877
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 878
Matx< _Tp, m, n> ::div(const Matx &a) const 
# 879
{ 
# 880
return Matx(*this, a, Matx_DivOp()); 
# 881
} 
# 883
template< class _Tp, int m, int n> inline Matx< _Tp, n, m>  
# 884
Matx< _Tp, m, n> ::t() const 
# 885
{ 
# 886
return Matx< _Tp, n, m> (*this, Matx_TOp()); 
# 887
} 
# 889
template< class _Tp, int m, int n> inline Vec< _Tp, n>  
# 890
Matx< _Tp, m, n> ::solve(const Vec< _Tp, m>  &rhs, int method) const 
# 891
{ 
# 892
Matx< _Tp, n, 1>  x = solve((const Matx< _Tp, m, 1>  &)rhs, method); 
# 893
return (Vec< _Tp, n>  &)x; 
# 894
} 
# 896
template< class _Tp, int m> inline double 
# 897
determinant(const Matx< _Tp, m, m>  &a) 
# 898
{ 
# 899
return internal::Matx_DetOp< _Tp, m> ()(a); 
# 900
} 
# 902
template< class _Tp, int m, int n> inline double 
# 903
trace(const Matx< _Tp, m, n>  &a) 
# 904
{ 
# 905
_Tp s = (0); 
# 906
for (int i = 0; i < std::min(m, n); i++) { 
# 907
s += a(i, i); }  
# 908
return s; 
# 909
} 
# 911
template< class _Tp, int m, int n> inline double 
# 912
norm(const Matx< _Tp, m, n>  &M) 
# 913
{ 
# 914
return std::sqrt(normL2Sqr< _Tp, double> ((M.val), m * n)); 
# 915
} 
# 917
template< class _Tp, int m, int n> inline double 
# 918
norm(const Matx< _Tp, m, n>  &M, int normType) 
# 919
{ 
# 920
switch (normType) { 
# 921
case NORM_INF:  
# 922
return (double)normInf< _Tp, typename DataType< _Tp> ::work_type> ((M.val), m * n); 
# 923
case NORM_L1:  
# 924
return (double)normL1< _Tp, typename DataType< _Tp> ::work_type> ((M.val), m * n); 
# 925
case NORM_L2SQR:  
# 926
return (double)normL2Sqr< _Tp, typename DataType< _Tp> ::work_type> ((M.val), m * n); 
# 927
default:  
# 928
case NORM_L2:  
# 929
return std::sqrt((double)normL2Sqr< _Tp, typename DataType< _Tp> ::work_type> ((M.val), m * n)); 
# 930
}  
# 931
} 
# 937
template< class _Tp, class _T2, int m, int n> static inline MatxCommaInitializer< _Tp, m, n>  
# 938
operator<<(const Matx< _Tp, m, n>  &mtx, _T2 val) 
# 939
{ 
# 940
MatxCommaInitializer< _Tp, m, n>  commaInitializer((Matx< _Tp, m, n>  *)(&mtx)); 
# 941
return (commaInitializer, val); 
# 942
} 
# 944
template< class _Tp, int m, int n> inline 
# 945
MatxCommaInitializer< _Tp, m, n> ::MatxCommaInitializer(Matx< _Tp, m, n>  *_mtx) : dst(_mtx), idx(0) 
# 947
{ } 
# 949
template< class _Tp, int m, int n> template< class _T2> inline MatxCommaInitializer< _Tp, m, n>  &
# 950
MatxCommaInitializer< _Tp, m, n> ::operator,(_T2 value) 
# 951
{ 
# 952
; 
# 953
(((dst)->val)[(idx)++]) = saturate_cast< _Tp> (value); 
# 954
return *this; 
# 955
} 
# 957
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 958
MatxCommaInitializer< _Tp, m, n> ::operator*() const 
# 959
{ 
# 960
; 
# 961
return *(dst); 
# 962
} 
# 968
template< class _Tp, int cn> inline 
# 969
Vec< _Tp, cn> ::Vec() { } 
# 971
template< class _Tp, int cn> inline 
# 972
Vec< _Tp, cn> ::Vec(_Tp v0) : Matx< _Tp, cn, 1> (v0) 
# 973
{ } 
# 975
template< class _Tp, int cn> inline 
# 976
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1) : Matx< _Tp, cn, 1> (v0, v1) 
# 977
{ } 
# 979
template< class _Tp, int cn> inline 
# 980
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2) : Matx< _Tp, cn, 1> (v0, v1, v2) 
# 981
{ } 
# 983
template< class _Tp, int cn> inline 
# 984
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3) : Matx< _Tp, cn, 1> (v0, v1, v2, v3) 
# 985
{ } 
# 987
template< class _Tp, int cn> inline 
# 988
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4) : Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4) 
# 989
{ } 
# 991
template< class _Tp, int cn> inline 
# 992
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5) : Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5) 
# 993
{ } 
# 995
template< class _Tp, int cn> inline 
# 996
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6) : Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6) 
# 997
{ } 
# 999
template< class _Tp, int cn> inline 
# 1000
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7) : Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6, v7) 
# 1001
{ } 
# 1003
template< class _Tp, int cn> inline 
# 1004
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8) : Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6, v7, v8) 
# 1005
{ } 
# 1007
template< class _Tp, int cn> inline 
# 1008
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9) : Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) 
# 1009
{ } 
# 1011
template< class _Tp, int cn> inline 
# 1012
Vec< _Tp, cn> ::Vec(_Tp v0, _Tp v1, _Tp v2, _Tp v3, _Tp v4, _Tp v5, _Tp v6, _Tp v7, _Tp v8, _Tp v9, _Tp v10, _Tp v11, _Tp v12, _Tp v13) : Matx< _Tp, cn, 1> (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) 
# 1013
{ } 
# 1015
template< class _Tp, int cn> inline 
# 1016
Vec< _Tp, cn> ::Vec(const _Tp *values) : Matx< _Tp, cn, 1> (values) 
# 1017
{ } 
# 1019
template< class _Tp, int cn> inline 
# 1020
Vec< _Tp, cn> ::Vec(std::initializer_list< _Tp>  list) : Matx< _Tp, cn, 1> (list) 
# 1021
{ } 
# 1023
template< class _Tp, int cn> inline 
# 1024
Vec< _Tp, cn> ::Vec(const Vec &m) : Matx< _Tp, cn, 1> ((m.val)) 
# 1025
{ } 
# 1027
template< class _Tp, int cn> inline 
# 1028
Vec< _Tp, cn> ::Vec(const Matx< _Tp, cn, 1>  &a, const Matx< _Tp, cn, 1>  &b, cv::Matx_AddOp op) : Matx< _Tp, cn, 1> (a, b, op) 
# 1029
{ } 
# 1031
template< class _Tp, int cn> inline 
# 1032
Vec< _Tp, cn> ::Vec(const Matx< _Tp, cn, 1>  &a, const Matx< _Tp, cn, 1>  &b, cv::Matx_SubOp op) : Matx< _Tp, cn, 1> (a, b, op) 
# 1033
{ } 
# 1035
template< class _Tp, int cn> template< class _T2> inline 
# 1036
Vec< _Tp, cn> ::Vec(const Matx< _Tp, cn, 1>  &a, _T2 alpha, cv::Matx_ScaleOp op) : Matx< _Tp, cn, 1> (a, alpha, op) 
# 1037
{ } 
# 1039
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1040
Vec< _Tp, cn> ::all(_Tp alpha) 
# 1041
{ 
# 1042
Vec v; 
# 1043
for (int i = 0; i < cn; i++) { ((v.val)[i]) = alpha; }  
# 1044
return v; 
# 1045
} 
# 1047
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1048
Vec< _Tp, cn> ::mul(const Vec &v) const 
# 1049
{ 
# 1050
Vec w; 
# 1051
for (int i = 0; i < cn; i++) { ((w.val)[i]) = saturate_cast< _Tp> (((this->val)[i]) * ((v.val)[i])); }  
# 1052
return w; 
# 1053
} 
# 1056
template<> inline Vec< float, 2>  Vec< float, 2> ::conj() const 
# 1057
{ 
# 1058
return cv::internal::conjugate(*this); 
# 1059
} 
# 1062
template<> inline Vec< double, 2>  Vec< double, 2> ::conj() const 
# 1063
{ 
# 1064
return cv::internal::conjugate(*this); 
# 1065
} 
# 1068
template<> inline Vec< float, 4>  Vec< float, 4> ::conj() const 
# 1069
{ 
# 1070
return cv::internal::conjugate(*this); 
# 1071
} 
# 1074
template<> inline Vec< double, 4>  Vec< double, 4> ::conj() const 
# 1075
{ 
# 1076
return cv::internal::conjugate(*this); 
# 1077
} 
# 1079
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1080
Vec< _Tp, cn> ::cross(const Vec &) const 
# 1081
{ 
# 1082
static_assert((cn == 3), "for arbitrary-size vector there is no cross-product defined cn == 3");
# 1083
return Vec(); 
# 1084
} 
# 1087
template<> inline Vec< float, 3>  Vec< float, 3> ::cross(const cv::Vec< float, 3>  &v) const 
# 1088
{ 
# 1089
return cv::Vec< float, 3> ((((this->val)[1]) * ((v.val)[2])) - (((this->val)[2]) * ((v.val)[1])), (((this->val)[2]) * ((v.val)[0])) - (((this->val)[0]) * ((v.val)[2])), (((this->val)[0]) * ((v.val)[1])) - (((this->val)[1]) * ((v.val)[0]))); 
# 1092
} 
# 1095
template<> inline Vec< double, 3>  Vec< double, 3> ::cross(const cv::Vec< double, 3>  &v) const 
# 1096
{ 
# 1097
return cv::Vec< double, 3> ((((this->val)[1]) * ((v.val)[2])) - (((this->val)[2]) * ((v.val)[1])), (((this->val)[2]) * ((v.val)[0])) - (((this->val)[0]) * ((v.val)[2])), (((this->val)[0]) * ((v.val)[1])) - (((this->val)[1]) * ((v.val)[0]))); 
# 1100
} 
# 1102
template< class _Tp, int cn> template< class T2> inline 
# 1103
Vec< _Tp, cn> ::operator Vec< T2, cn> () const 
# 1104
{ 
# 1105
Vec< T2, cn>  v; 
# 1106
for (int i = 0; i < cn; i++) { ((v.val)[i]) = saturate_cast< T2> ((this->val)[i]); }  
# 1107
return v; 
# 1108
} 
# 1110
template< class _Tp, int cn> inline const _Tp &
# 1111
Vec< _Tp, cn> ::operator[](int i) const 
# 1112
{ 
# 1113
; 
# 1114
return (this->val)[i]; 
# 1115
} 
# 1117
template< class _Tp, int cn> inline _Tp &
# 1118
Vec< _Tp, cn> ::operator[](int i) 
# 1119
{ 
# 1120
; 
# 1121
return (this->val)[i]; 
# 1122
} 
# 1124
template< class _Tp, int cn> inline const _Tp &
# 1125
Vec< _Tp, cn> ::operator()(int i) const 
# 1126
{ 
# 1127
; 
# 1128
return (this->val)[i]; 
# 1129
} 
# 1131
template< class _Tp, int cn> inline _Tp &
# 1132
Vec< _Tp, cn> ::operator()(int i) 
# 1133
{ 
# 1134
; 
# 1135
return (this->val)[i]; 
# 1136
} 
# 1138
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1139
normalize(const Vec< _Tp, cn>  &v) 
# 1140
{ 
# 1141
double nv = norm(v); 
# 1142
return v * ((nv) ? (1.0) / nv : (0.0)); 
# 1143
} 
# 1150
template< class _Tp, class _T2, int cn> static inline VecCommaInitializer< _Tp, cn>  
# 1151
operator<<(const Vec< _Tp, cn>  &vec, _T2 val) 
# 1152
{ 
# 1153
VecCommaInitializer< _Tp, cn>  commaInitializer((Vec< _Tp, cn>  *)(&vec)); 
# 1154
return (commaInitializer, val); 
# 1155
} 
# 1157
template< class _Tp, int cn> inline 
# 1158
VecCommaInitializer< _Tp, cn> ::VecCommaInitializer(Vec< _Tp, cn>  *_vec) : MatxCommaInitializer< _Tp, cn, 1> (_vec) 
# 1160
{ } 
# 1162
template< class _Tp, int cn> template< class _T2> inline VecCommaInitializer< _Tp, cn>  &
# 1163
VecCommaInitializer< _Tp, cn> ::operator,(_T2 value) 
# 1164
{ 
# 1165
; 
# 1166
(((this->dst)->val)[(this->idx)++]) = saturate_cast< _Tp> (value); 
# 1167
return *this; 
# 1168
} 
# 1170
template< class _Tp, int cn> inline Vec< _Tp, cn>  
# 1171
VecCommaInitializer< _Tp, cn> ::operator*() const 
# 1172
{ 
# 1173
; 
# 1174
return *(this->dst); 
# 1175
} 
# 1184 "/usr/include/opencv4/opencv2/core/matx.hpp" 3
template< class _Tp1, class _Tp2, int m, int n> static inline Matx< _Tp1, m, n>  &
# 1185
operator+=(Matx< _Tp1, m, n>  &a, const Matx< _Tp2, m, n>  &b) 
# 1186
{ 
# 1187
for (int i = 0; i < (m * n); i++) { 
# 1188
((a.val)[i]) = saturate_cast< _Tp1> (((a.val)[i]) + ((b.val)[i])); }  
# 1189
return a; 
# 1190
} 
# 1192
template< class _Tp1, class _Tp2, int m, int n> static inline Matx< _Tp1, m, n>  &
# 1193
operator-=(Matx< _Tp1, m, n>  &a, const Matx< _Tp2, m, n>  &b) 
# 1194
{ 
# 1195
for (int i = 0; i < (m * n); i++) { 
# 1196
((a.val)[i]) = saturate_cast< _Tp1> (((a.val)[i]) - ((b.val)[i])); }  
# 1197
return a; 
# 1198
} 
# 1200
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1201
operator+(const Matx< _Tp, m, n>  &a, const Matx< _Tp, m, n>  &b) 
# 1202
{ 
# 1203
return Matx< _Tp, m, n> (a, b, Matx_AddOp()); 
# 1204
} 
# 1206
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1207
operator-(const Matx< _Tp, m, n>  &a, const Matx< _Tp, m, n>  &b) 
# 1208
{ 
# 1209
return Matx< _Tp, m, n> (a, b, Matx_SubOp()); 
# 1210
} 
# 1212
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  &
# 1213
operator*=(Matx< _Tp, m, n>  &a, int alpha) 
# 1214
{ 
# 1215
for (int i = 0; i < (m * n); i++) { 
# 1216
((a.val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * alpha); }  
# 1217
return a; 
# 1218
} 
# 1220
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  &
# 1221
operator*=(Matx< _Tp, m, n>  &a, float alpha) 
# 1222
{ 
# 1223
for (int i = 0; i < (m * n); i++) { 
# 1224
((a.val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * alpha); }  
# 1225
return a; 
# 1226
} 
# 1228
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  &
# 1229
operator*=(Matx< _Tp, m, n>  &a, double alpha) 
# 1230
{ 
# 1231
for (int i = 0; i < (m * n); i++) { 
# 1232
((a.val)[i]) = saturate_cast< _Tp> (((a.val)[i]) * alpha); }  
# 1233
return a; 
# 1234
} 
# 1236
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1237
operator*(const Matx< _Tp, m, n>  &a, int alpha) 
# 1238
{ 
# 1239
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1240
} 
# 1242
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1243
operator*(const Matx< _Tp, m, n>  &a, float alpha) 
# 1244
{ 
# 1245
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1246
} 
# 1248
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1249
operator*(const Matx< _Tp, m, n>  &a, double alpha) 
# 1250
{ 
# 1251
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1252
} 
# 1254
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1255
operator*(int alpha, const Matx< _Tp, m, n>  &a) 
# 1256
{ 
# 1257
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1258
} 
# 1260
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1261
operator*(float alpha, const Matx< _Tp, m, n>  &a) 
# 1262
{ 
# 1263
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1264
} 
# 1266
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1267
operator*(double alpha, const Matx< _Tp, m, n>  &a) 
# 1268
{ 
# 1269
return Matx< _Tp, m, n> (a, alpha, Matx_ScaleOp()); 
# 1270
} 
# 1272
template< class _Tp, int m, int n> static inline Matx< _Tp, m, n>  
# 1273
operator-(const Matx< _Tp, m, n>  &a) 
# 1274
{ 
# 1275
return Matx< _Tp, m, n> (a, -1, Matx_ScaleOp()); 
# 1276
} 
# 1278
template< class _Tp, int m, int n, int l> static inline Matx< _Tp, m, n>  
# 1279
operator*(const Matx< _Tp, m, l>  &a, const Matx< _Tp, l, n>  &b) 
# 1280
{ 
# 1281
return Matx< _Tp, m, n> (a, b, Matx_MatMulOp()); 
# 1282
} 
# 1284
template< class _Tp, int m, int n> static inline Vec< _Tp, m>  
# 1285
operator*(const Matx< _Tp, m, n>  &a, const Vec< _Tp, n>  &b) 
# 1286
{ 
# 1287
Matx< _Tp, m, 1>  c(a, b, Matx_MatMulOp()); 
# 1288
return (const Vec< _Tp, m>  &)c; 
# 1289
} 
# 1291
template< class _Tp, int m, int n> static inline bool 
# 1292
operator==(const Matx< _Tp, m, n>  &a, const Matx< _Tp, m, n>  &b) 
# 1293
{ 
# 1294
for (int i = 0; i < (m * n); i++) { 
# 1295
if (((a.val)[i]) != ((b.val)[i])) { return false; }  }  
# 1296
return true; 
# 1297
} 
# 1299
template< class _Tp, int m, int n> static inline bool 
# 1300
operator!=(const Matx< _Tp, m, n>  &a, const Matx< _Tp, m, n>  &b) 
# 1301
{ 
# 1302
return !(a == b); 
# 1303
} 
# 1312 "/usr/include/opencv4/opencv2/core/matx.hpp" 3
template< class _Tp1, class _Tp2, int cn> static inline Vec< _Tp1, cn>  &
# 1313
operator+=(Vec< _Tp1, cn>  &a, const Vec< _Tp2, cn>  &b) 
# 1314
{ 
# 1315
for (int i = 0; i < cn; i++) { 
# 1316
((a.val)[i]) = saturate_cast< _Tp1> (((a.val)[i]) + ((b.val)[i])); }  
# 1317
return a; 
# 1318
} 
# 1320
template< class _Tp1, class _Tp2, int cn> static inline Vec< _Tp1, cn>  &
# 1321
operator-=(Vec< _Tp1, cn>  &a, const Vec< _Tp2, cn>  &b) 
# 1322
{ 
# 1323
for (int i = 0; i < cn; i++) { 
# 1324
((a.val)[i]) = saturate_cast< _Tp1> (((a.val)[i]) - ((b.val)[i])); }  
# 1325
return a; 
# 1326
} 
# 1328
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1329
operator+(const Vec< _Tp, cn>  &a, const Vec< _Tp, cn>  &b) 
# 1330
{ 
# 1331
return Vec< _Tp, cn> (a, b, Matx_AddOp()); 
# 1332
} 
# 1334
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1335
operator-(const Vec< _Tp, cn>  &a, const Vec< _Tp, cn>  &b) 
# 1336
{ 
# 1337
return Vec< _Tp, cn> (a, b, Matx_SubOp()); 
# 1338
} 
# 1340
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1341
operator*=(Vec< _Tp, cn>  &a, int alpha) 
# 1342
{ 
# 1343
for (int i = 0; i < cn; i++) { 
# 1344
(a[i]) = saturate_cast< _Tp> ((a[i]) * alpha); }  
# 1345
return a; 
# 1346
} 
# 1348
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1349
operator*=(Vec< _Tp, cn>  &a, float alpha) 
# 1350
{ 
# 1351
for (int i = 0; i < cn; i++) { 
# 1352
(a[i]) = saturate_cast< _Tp> ((a[i]) * alpha); }  
# 1353
return a; 
# 1354
} 
# 1356
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1357
operator*=(Vec< _Tp, cn>  &a, double alpha) 
# 1358
{ 
# 1359
for (int i = 0; i < cn; i++) { 
# 1360
(a[i]) = saturate_cast< _Tp> ((a[i]) * alpha); }  
# 1361
return a; 
# 1362
} 
# 1364
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1365
operator/=(Vec< _Tp, cn>  &a, int alpha) 
# 1366
{ 
# 1367
double ialpha = (1.0) / alpha; 
# 1368
for (int i = 0; i < cn; i++) { 
# 1369
(a[i]) = saturate_cast< _Tp> ((a[i]) * ialpha); }  
# 1370
return a; 
# 1371
} 
# 1373
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1374
operator/=(Vec< _Tp, cn>  &a, float alpha) 
# 1375
{ 
# 1376
float ialpha = (1.0F) / alpha; 
# 1377
for (int i = 0; i < cn; i++) { 
# 1378
(a[i]) = saturate_cast< _Tp> ((a[i]) * ialpha); }  
# 1379
return a; 
# 1380
} 
# 1382
template< class _Tp, int cn> static inline Vec< _Tp, cn>  &
# 1383
operator/=(Vec< _Tp, cn>  &a, double alpha) 
# 1384
{ 
# 1385
double ialpha = (1.0) / alpha; 
# 1386
for (int i = 0; i < cn; i++) { 
# 1387
(a[i]) = saturate_cast< _Tp> ((a[i]) * ialpha); }  
# 1388
return a; 
# 1389
} 
# 1391
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1392
operator*(const Vec< _Tp, cn>  &a, int alpha) 
# 1393
{ 
# 1394
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1395
} 
# 1397
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1398
operator*(int alpha, const Vec< _Tp, cn>  &a) 
# 1399
{ 
# 1400
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1401
} 
# 1403
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1404
operator*(const Vec< _Tp, cn>  &a, float alpha) 
# 1405
{ 
# 1406
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1407
} 
# 1409
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1410
operator*(float alpha, const Vec< _Tp, cn>  &a) 
# 1411
{ 
# 1412
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1413
} 
# 1415
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1416
operator*(const Vec< _Tp, cn>  &a, double alpha) 
# 1417
{ 
# 1418
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1419
} 
# 1421
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1422
operator*(double alpha, const Vec< _Tp, cn>  &a) 
# 1423
{ 
# 1424
return Vec< _Tp, cn> (a, alpha, Matx_ScaleOp()); 
# 1425
} 
# 1427
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1428
operator/(const Vec< _Tp, cn>  &a, int alpha) 
# 1429
{ 
# 1430
return Vec< _Tp, cn> (a, (1.0) / alpha, Matx_ScaleOp()); 
# 1431
} 
# 1433
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1434
operator/(const Vec< _Tp, cn>  &a, float alpha) 
# 1435
{ 
# 1436
return Vec< _Tp, cn> (a, (1.0F) / alpha, Matx_ScaleOp()); 
# 1437
} 
# 1439
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1440
operator/(const Vec< _Tp, cn>  &a, double alpha) 
# 1441
{ 
# 1442
return Vec< _Tp, cn> (a, (1.0) / alpha, Matx_ScaleOp()); 
# 1443
} 
# 1445
template< class _Tp, int cn> static inline Vec< _Tp, cn>  
# 1446
operator-(const Vec< _Tp, cn>  &a) 
# 1447
{ 
# 1448
Vec< _Tp, cn>  t; 
# 1449
for (int i = 0; i < cn; i++) { ((t.val)[i]) = saturate_cast< _Tp> (-((a.val)[i])); }  
# 1450
return t; 
# 1451
} 
# 1453
template< class _Tp> inline Vec< _Tp, 4>  operator*(const Vec< _Tp, 4>  &v1, const Vec< _Tp, 4>  &v2) 
# 1454
{ 
# 1455
return Vec< _Tp, 4> (saturate_cast< _Tp> (((((v1[0]) * (v2[0])) - ((v1[1]) * (v2[1]))) - ((v1[2]) * (v2[2]))) - ((v1[3]) * (v2[3]))), saturate_cast< _Tp> (((((v1[0]) * (v2[1])) + ((v1[1]) * (v2[0]))) + ((v1[2]) * (v2[3]))) - ((v1[3]) * (v2[2]))), saturate_cast< _Tp> (((((v1[0]) * (v2[2])) - ((v1[1]) * (v2[3]))) + ((v1[2]) * (v2[0]))) + ((v1[3]) * (v2[1]))), saturate_cast< _Tp> (((((v1[0]) * (v2[3])) + ((v1[1]) * (v2[2]))) - ((v1[2]) * (v2[1]))) + ((v1[3]) * (v2[0])))); 
# 1459
} 
# 1461
template< class _Tp> inline Vec< _Tp, 4>  &operator*=(Vec< _Tp, 4>  &v1, const Vec< _Tp, 4>  &v2) 
# 1462
{ 
# 1463
v1 = (v1 * v2); 
# 1464
return v1; 
# 1465
} 
# 1469
}
# 74 "/usr/include/c++/9/bits/stl_vector.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 80
template< class _Tp, class _Alloc> 
# 81
struct _Vector_base { 
# 84
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other _Tp_alloc_type; 
# 86
typedef typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::pointer pointer; 
# 88
struct _Vector_impl_data { 
# 90
pointer _M_start; 
# 91
pointer _M_finish; 
# 92
pointer _M_end_of_storage; 
# 94
_Vector_impl_data() noexcept : _M_start(), _M_finish(), _M_end_of_storage() 
# 96
{ } 
# 99
_Vector_impl_data(_Vector_impl_data &&__x) noexcept : _M_start(__x._M_start), _M_finish(__x._M_finish), _M_end_of_storage(__x._M_end_of_storage) 
# 102
{ (__x._M_start) = ((__x._M_finish) = ((__x._M_end_of_storage) = pointer())); } 
# 106
void _M_copy_data(const _Vector_impl_data &__x) noexcept 
# 107
{ 
# 108
(_M_start) = (__x._M_start); 
# 109
(_M_finish) = (__x._M_finish); 
# 110
(_M_end_of_storage) = (__x._M_end_of_storage); 
# 111
} 
# 114
void _M_swap_data(_Vector_impl_data &__x) noexcept 
# 115
{ 
# 118
_Vector_impl_data __tmp; 
# 119
__tmp._M_copy_data(*this); 
# 120
_M_copy_data(__x); 
# 121
__x._M_copy_data(__tmp); 
# 122
} 
# 123
}; 
# 125
struct _Vector_impl : public _Tp_alloc_type, public _Vector_impl_data { 
# 128
_Vector_impl() noexcept(is_nothrow_default_constructible< typename _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type> ::value) : _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type() 
# 131
{ } 
# 133
_Vector_impl(const typename _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type &__a) noexcept : _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(__a) 
# 135
{ } 
# 140
_Vector_impl(_Vector_impl &&__x) noexcept : _Vector_base< _Tp, _Alloc> ::_Vector_impl_data(std::move(__x)), _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(std::move(__x)) 
# 142
{ } 
# 144
_Vector_impl(typename _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type &&__a) noexcept : _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(std::move(__a)) 
# 146
{ } 
# 148
_Vector_impl(typename _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type &&__a, _Vector_impl &&__rv) noexcept : _Vector_base< _Tp, _Alloc> ::_Vector_impl_data(std::move(__rv)), _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type(std::move(__a)) 
# 150
{ } 
# 267 "/usr/include/c++/9/bits/stl_vector.h" 3
}; 
# 270
typedef _Alloc allocator_type; 
# 273
_Tp_alloc_type &_M_get_Tp_allocator() noexcept 
# 274
{ return this->_M_impl; } 
# 277
const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept 
# 278
{ return this->_M_impl; } 
# 281
allocator_type get_allocator() const noexcept 
# 282
{ return (allocator_type)_M_get_Tp_allocator(); } 
# 285
_Vector_base() = default;
# 290
_Vector_base(const allocator_type &__a) noexcept : _M_impl(__a) 
# 291
{ } 
# 295
_Vector_base(size_t __n) : _M_impl() 
# 297
{ _M_create_storage(__n); } 
# 300
_Vector_base(size_t __n, const allocator_type &__a) : _M_impl(__a) 
# 302
{ _M_create_storage(__n); } 
# 305
_Vector_base(_Vector_base &&) = default;
# 309
_Vector_base(_Tp_alloc_type &&__a) noexcept : _M_impl(std::move(__a)) 
# 310
{ } 
# 312
_Vector_base(_Vector_base &&__x, const allocator_type &__a) : _M_impl(__a) 
# 314
{ 
# 315
if (__x.get_allocator() == __a) { 
# 316
(this->_M_impl)._M_swap_data(__x._M_impl); } else 
# 318
{ 
# 319
size_t __n = ((__x._M_impl)._M_finish) - ((__x._M_impl)._M_start); 
# 320
_M_create_storage(__n); 
# 321
}  
# 322
} 
# 325
_Vector_base(const allocator_type &__a, _Vector_base &&__x) : _M_impl((_Tp_alloc_type)__a, std::move(__x._M_impl)) 
# 327
{ } 
# 330
~_Vector_base() noexcept 
# 331
{ 
# 332
_M_deallocate(((_M_impl)._M_start), ((_M_impl)._M_end_of_storage) - ((_M_impl)._M_start)); 
# 334
} 
# 337
_Vector_impl _M_impl; 
# 340
pointer _M_allocate(size_t __n) 
# 341
{ 
# 342
typedef __gnu_cxx::__alloc_traits< _Tp_alloc_type>  _Tr; 
# 343
return (__n != (0)) ? _Tr::allocate(_M_impl, __n) : pointer(); 
# 344
} 
# 347
void _M_deallocate(pointer __p, size_t __n) 
# 348
{ 
# 349
typedef __gnu_cxx::__alloc_traits< _Tp_alloc_type>  _Tr; 
# 350
if (__p) { 
# 351
_Tr::deallocate(_M_impl, __p, __n); }  
# 352
} 
# 356
protected: void _M_create_storage(size_t __n) 
# 357
{ 
# 358
((this->_M_impl)._M_start) = _M_allocate(__n); 
# 359
((this->_M_impl)._M_finish) = ((this->_M_impl)._M_start); 
# 360
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 361
} 
# 362
}; 
# 385 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class _Tp, class _Alloc = allocator< _Tp> > 
# 386
class vector : protected _Vector_base< _Tp, _Alloc>  { 
# 398 "/usr/include/c++/9/bits/stl_vector.h" 3
static_assert((is_same< typename remove_cv< _Tp> ::type, _Tp> ::value), "std::vector must have a non-const, non-volatile value_type");
# 406
typedef _Vector_base< _Tp, _Alloc>  _Base; 
# 407
typedef typename _Vector_base< _Tp, _Alloc> ::_Tp_alloc_type _Tp_alloc_type; 
# 408
typedef __gnu_cxx::__alloc_traits< _Tp_alloc_type>  _Alloc_traits; 
# 411
public: typedef _Tp value_type; 
# 412
typedef typename _Vector_base< _Tp, _Alloc> ::pointer pointer; 
# 413
typedef typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::const_pointer const_pointer; 
# 414
typedef typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::reference reference; 
# 415
typedef typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::const_reference const_reference; 
# 416
typedef __gnu_cxx::__normal_iterator< pointer, vector>  iterator; 
# 418
typedef __gnu_cxx::__normal_iterator< const_pointer, vector>  const_iterator; 
# 419
typedef std::reverse_iterator< const_iterator>  const_reverse_iterator; 
# 420
typedef std::reverse_iterator< iterator>  reverse_iterator; 
# 421
typedef std::size_t size_type; 
# 422
typedef std::ptrdiff_t difference_type; 
# 423
typedef _Alloc allocator_type; 
# 428
private: static constexpr bool _S_nothrow_relocate(std::true_type) 
# 429
{ 
# 430
return noexcept(std::__relocate_a(std::declval< pointer> (), std::declval< pointer> (), std::declval< pointer> (), std::declval< _Tp_alloc_type &> ())); 
# 434
} 
# 437
static constexpr bool _S_nothrow_relocate(std::false_type) 
# 438
{ return false; } 
# 441
static constexpr bool _S_use_relocate() 
# 442
{ 
# 446
return _S_nothrow_relocate(__is_move_insertable< _Tp_alloc_type> {}); 
# 447
} 
# 450
static pointer _S_do_relocate(pointer __first, pointer __last, pointer __result, _Tp_alloc_type &
# 451
__alloc, std::true_type) noexcept 
# 452
{ 
# 453
return std::__relocate_a(__first, __last, __result, __alloc); 
# 454
} 
# 457
static pointer _S_do_relocate(pointer, pointer, pointer __result, _Tp_alloc_type &, std::false_type) noexcept 
# 459
{ return __result; } 
# 462
static pointer _S_relocate(pointer __first, pointer __last, pointer __result, _Tp_alloc_type &
# 463
__alloc) noexcept 
# 464
{ 
# 465
using __do_it = std::__bool_constant< (&vector< _Tp, _Alloc> ::_S_use_relocate)()> ; 
# 466
return _S_do_relocate(__first, __last, __result, __alloc, __do_it{}); 
# 467
} 
# 471
protected: using _Vector_base< _Tp, _Alloc> ::_M_allocate;
# 472
using _Vector_base< _Tp, _Alloc> ::_M_deallocate;
# 473
using _Vector_base< _Tp, _Alloc> ::_M_impl;
# 474
using _Vector_base< _Tp, _Alloc> ::_M_get_Tp_allocator;
# 484
public: vector() = default;
# 494 "/usr/include/c++/9/bits/stl_vector.h" 3
explicit vector(const allocator_type &__a) noexcept : _Base(__a) 
# 495
{ } 
# 507 "/usr/include/c++/9/bits/stl_vector.h" 3
explicit vector(size_type __n, const allocator_type &__a = allocator_type()) : _Base((_S_check_init_len)(__n, __a), __a) 
# 509
{ _M_default_initialize(__n); } 
# 519 "/usr/include/c++/9/bits/stl_vector.h" 3
vector(size_type __n, const value_type &__value, const allocator_type &
# 520
__a = allocator_type()) : _Base((_S_check_init_len)(__n, __a), __a) 
# 522
{ _M_fill_initialize(__n, __value); } 
# 550 "/usr/include/c++/9/bits/stl_vector.h" 3
vector(const vector &__x) : _Base(__x.size(), _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator())) 
# 553
{ 
# 554
((this->_M_impl)._M_finish) = std::__uninitialized_copy_a(__x.begin(), __x.end(), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 558
} 
# 569 "/usr/include/c++/9/bits/stl_vector.h" 3
vector(vector &&) noexcept = default;
# 572
vector(const vector &__x, const allocator_type &__a) : _Base(__x.size(), __a) 
# 574
{ 
# 575
((this->_M_impl)._M_finish) = std::__uninitialized_copy_a(__x.begin(), __x.end(), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 579
} 
# 582
private: vector(vector &&__rv, const allocator_type &__m, std::true_type) noexcept : _Base(__m, std::move(__rv)) 
# 584
{ } 
# 586
vector(vector &&__rv, const allocator_type &__m, std::false_type) : _Base(__m) 
# 588
{ 
# 589
if (__rv.get_allocator() == __m) { 
# 590
(this->_M_impl)._M_swap_data((__rv._M_impl)); } else { 
# 591
if (!__rv.empty()) 
# 592
{ 
# 593
this->_M_create_storage(__rv.size()); 
# 594
((this->_M_impl)._M_finish) = std::__uninitialized_move_a(__rv.begin(), __rv.end(), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 598
__rv.clear(); 
# 599
}  }  
# 600
} 
# 604
public: vector(vector &&__rv, const allocator_type &__m) noexcept(noexcept((vector(std::declval< vector &&> (), std::declval< const allocator_type &> (), std::declval< typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::is_always_equal> ())))) : vector(std::move(__rv), __m, typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::is_always_equal{}) 
# 609
{ } 
# 622 "/usr/include/c++/9/bits/stl_vector.h" 3
vector(initializer_list< value_type>  __l, const allocator_type &
# 623
__a = allocator_type()) : _Base(__a) 
# 625
{ 
# 626
_M_range_initialize(__l.begin(), __l.end(), std::random_access_iterator_tag()); 
# 628
} 
# 648 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class _InputIterator, class 
# 649
 = std::_RequireInputIter< _InputIterator> > 
# 650
vector(_InputIterator __first, _InputIterator __last, const allocator_type &
# 651
__a = allocator_type()) : _Base(__a) 
# 653
{ 
# 654
_M_range_initialize(__first, __last, std::__iterator_category(__first)); 
# 656
} 
# 675 "/usr/include/c++/9/bits/stl_vector.h" 3
~vector() noexcept 
# 676
{ 
# 677
std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 679
; 
# 680
} 
# 692 "/usr/include/c++/9/bits/stl_vector.h" 3
vector &operator=(const vector & __x); 
# 706 "/usr/include/c++/9/bits/stl_vector.h" 3
vector &operator=(vector &&__x) noexcept(_Alloc_traits::_S_nothrow_move()) 
# 707
{ 
# 708
constexpr bool __move_storage = (_Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal()); 
# 711
_M_move_assign(std::move(__x), std::__bool_constant< __move_storage> ()); 
# 712
return *this; 
# 713
} 
# 727 "/usr/include/c++/9/bits/stl_vector.h" 3
vector &operator=(initializer_list< value_type>  __l) 
# 728
{ 
# 729
this->_M_assign_aux(__l.begin(), __l.end(), std::random_access_iterator_tag()); 
# 731
return *this; 
# 732
} 
# 746 "/usr/include/c++/9/bits/stl_vector.h" 3
void assign(size_type __n, const value_type &__val) 
# 747
{ _M_fill_assign(__n, __val); } 
# 762 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class _InputIterator, class 
# 763
 = std::_RequireInputIter< _InputIterator> > void 
# 765
assign(_InputIterator __first, _InputIterator __last) 
# 766
{ _M_assign_dispatch(__first, __last, std::__false_type()); } 
# 791 "/usr/include/c++/9/bits/stl_vector.h" 3
void assign(initializer_list< value_type>  __l) 
# 792
{ 
# 793
this->_M_assign_aux(__l.begin(), __l.end(), std::random_access_iterator_tag()); 
# 795
} 
# 799
using _Vector_base< _Tp, _Alloc> ::get_allocator;
# 808
iterator begin() noexcept 
# 809
{ return ((__gnu_cxx::__normal_iterator< pointer, vector> )(((this->_M_impl)._M_start))); } 
# 817
const_iterator begin() const noexcept 
# 818
{ return ((__gnu_cxx::__normal_iterator< const_pointer, vector> )(((this->_M_impl)._M_start))); } 
# 826
iterator end() noexcept 
# 827
{ return ((__gnu_cxx::__normal_iterator< pointer, vector> )(((this->_M_impl)._M_finish))); } 
# 835
const_iterator end() const noexcept 
# 836
{ return ((__gnu_cxx::__normal_iterator< const_pointer, vector> )(((this->_M_impl)._M_finish))); } 
# 844
reverse_iterator rbegin() noexcept 
# 845
{ return ((std::reverse_iterator< iterator> )(end())); } 
# 853
const_reverse_iterator rbegin() const noexcept 
# 854
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 862
reverse_iterator rend() noexcept 
# 863
{ return ((std::reverse_iterator< iterator> )(begin())); } 
# 871
const_reverse_iterator rend() const noexcept 
# 872
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 881
const_iterator cbegin() const noexcept 
# 882
{ return ((__gnu_cxx::__normal_iterator< const_pointer, vector> )(((this->_M_impl)._M_start))); } 
# 890
const_iterator cend() const noexcept 
# 891
{ return ((__gnu_cxx::__normal_iterator< const_pointer, vector> )(((this->_M_impl)._M_finish))); } 
# 899
const_reverse_iterator crbegin() const noexcept 
# 900
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 908
const_reverse_iterator crend() const noexcept 
# 909
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 915
size_type size() const noexcept 
# 916
{ return (size_type)(((this->_M_impl)._M_finish) - ((this->_M_impl)._M_start)); } 
# 920
size_type max_size() const noexcept 
# 921
{ return (_S_max_size)(_M_get_Tp_allocator()); } 
# 934 "/usr/include/c++/9/bits/stl_vector.h" 3
void resize(size_type __new_size) 
# 935
{ 
# 936
if (__new_size > size()) { 
# 937
_M_default_append(__new_size - size()); } else { 
# 938
if (__new_size < size()) { 
# 939
_M_erase_at_end(((this->_M_impl)._M_start) + __new_size); }  }  
# 940
} 
# 954 "/usr/include/c++/9/bits/stl_vector.h" 3
void resize(size_type __new_size, const value_type &__x) 
# 955
{ 
# 956
if (__new_size > size()) { 
# 957
_M_fill_insert(end(), __new_size - size(), __x); } else { 
# 958
if (__new_size < size()) { 
# 959
_M_erase_at_end(((this->_M_impl)._M_start) + __new_size); }  }  
# 960
} 
# 986 "/usr/include/c++/9/bits/stl_vector.h" 3
void shrink_to_fit() 
# 987
{ _M_shrink_to_fit(); } 
# 995
size_type capacity() const noexcept 
# 996
{ return (size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 997
} 
# 1004
bool empty() const noexcept 
# 1005
{ return begin() == end(); } 
# 1025 "/usr/include/c++/9/bits/stl_vector.h" 3
void reserve(size_type __n); 
# 1040 "/usr/include/c++/9/bits/stl_vector.h" 3
reference operator[](size_type __n) noexcept 
# 1041
{ 
# 1042
; 
# 1043
return *(((this->_M_impl)._M_start) + __n); 
# 1044
} 
# 1058 "/usr/include/c++/9/bits/stl_vector.h" 3
const_reference operator[](size_type __n) const noexcept 
# 1059
{ 
# 1060
; 
# 1061
return *(((this->_M_impl)._M_start) + __n); 
# 1062
} 
# 1067
protected: void _M_range_check(size_type __n) const 
# 1068
{ 
# 1069
if (__n >= size()) { 
# 1070
__throw_out_of_range_fmt("vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", __n, size()); }  
# 1074
} 
# 1089 "/usr/include/c++/9/bits/stl_vector.h" 3
public: reference at(size_type __n) 
# 1090
{ 
# 1091
_M_range_check(__n); 
# 1092
return (*this)[__n]; 
# 1093
} 
# 1107 "/usr/include/c++/9/bits/stl_vector.h" 3
const_reference at(size_type __n) const 
# 1108
{ 
# 1109
_M_range_check(__n); 
# 1110
return (*this)[__n]; 
# 1111
} 
# 1118
reference front() noexcept 
# 1119
{ 
# 1120
; 
# 1121
return *begin(); 
# 1122
} 
# 1129
const_reference front() const noexcept 
# 1130
{ 
# 1131
; 
# 1132
return *begin(); 
# 1133
} 
# 1140
reference back() noexcept 
# 1141
{ 
# 1142
; 
# 1143
return *(end() - 1); 
# 1144
} 
# 1151
const_reference back() const noexcept 
# 1152
{ 
# 1153
; 
# 1154
return *(end() - 1); 
# 1155
} 
# 1165 "/usr/include/c++/9/bits/stl_vector.h" 3
_Tp *data() noexcept 
# 1166
{ return _M_data_ptr(((this->_M_impl)._M_start)); } 
# 1169
const _Tp *data() const noexcept 
# 1170
{ return _M_data_ptr(((this->_M_impl)._M_start)); } 
# 1184 "/usr/include/c++/9/bits/stl_vector.h" 3
void push_back(const value_type &__x) 
# 1185
{ 
# 1186
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) 
# 1187
{ 
# 1188
; 
# 1189
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), __x); 
# 1191
++((this->_M_impl)._M_finish); 
# 1192
; 
# 1193
} else { 
# 1195
_M_realloc_insert(end(), __x); }  
# 1196
} 
# 1200
void push_back(value_type &&__x) 
# 1201
{ emplace_back(std::move(__x)); } 
# 1203
template< class ..._Args> void emplace_back(_Args && ...__args); 
# 1222 "/usr/include/c++/9/bits/stl_vector.h" 3
void pop_back() noexcept 
# 1223
{ 
# 1224
; 
# 1225
--((this->_M_impl)._M_finish); 
# 1226
_Alloc_traits::destroy((this->_M_impl), ((this->_M_impl)._M_finish)); 
# 1227
; 
# 1228
} 
# 1243 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class ..._Args> iterator 
# 1245
emplace(const_iterator __position, _Args &&...__args) 
# 1246
{ return _M_emplace_aux(__position, std::forward< _Args> (__args)...); } 
# 1260 "/usr/include/c++/9/bits/stl_vector.h" 3
iterator insert(const_iterator __position, const value_type & __x); 
# 1290 "/usr/include/c++/9/bits/stl_vector.h" 3
iterator insert(const_iterator __position, value_type &&__x) 
# 1291
{ return _M_insert_rval(__position, std::move(__x)); } 
# 1307 "/usr/include/c++/9/bits/stl_vector.h" 3
iterator insert(const_iterator __position, initializer_list< value_type>  __l) 
# 1308
{ 
# 1309
auto __offset = __position - cbegin(); 
# 1310
_M_range_insert(begin() + __offset, __l.begin(), __l.end(), std::random_access_iterator_tag()); 
# 1312
return begin() + __offset; 
# 1313
} 
# 1332 "/usr/include/c++/9/bits/stl_vector.h" 3
iterator insert(const_iterator __position, size_type __n, const value_type &__x) 
# 1333
{ 
# 1334
difference_type __offset = __position - cbegin(); 
# 1335
_M_fill_insert(begin() + __offset, __n, __x); 
# 1336
return begin() + __offset; 
# 1337
} 
# 1373 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class _InputIterator, class 
# 1374
 = std::_RequireInputIter< _InputIterator> > iterator 
# 1376
insert(const_iterator __position, _InputIterator __first, _InputIterator 
# 1377
__last) 
# 1378
{ 
# 1379
difference_type __offset = __position - cbegin(); 
# 1380
_M_insert_dispatch(begin() + __offset, __first, __last, std::__false_type()); 
# 1382
return begin() + __offset; 
# 1383
} 
# 1427 "/usr/include/c++/9/bits/stl_vector.h" 3
iterator erase(const_iterator __position) 
# 1428
{ return _M_erase(begin() + (__position - cbegin())); } 
# 1454 "/usr/include/c++/9/bits/stl_vector.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 1455
{ 
# 1456
const auto __beg = begin(); 
# 1457
const auto __cbeg = cbegin(); 
# 1458
return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg)); 
# 1459
} 
# 1477 "/usr/include/c++/9/bits/stl_vector.h" 3
void swap(vector &__x) noexcept 
# 1478
{ 
# 1481
; 
# 1483
(this->_M_impl)._M_swap_data((__x._M_impl)); 
# 1484
_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()); 
# 1486
} 
# 1495
void clear() noexcept 
# 1496
{ _M_erase_at_end(((this->_M_impl)._M_start)); } 
# 1505
protected: 
# 1503
template< class _ForwardIterator> pointer 
# 1505
_M_allocate_and_copy(size_type __n, _ForwardIterator 
# 1506
__first, _ForwardIterator __last) 
# 1507
{ 
# 1508
pointer __result = this->_M_allocate(__n); 
# 1509
try 
# 1510
{ 
# 1511
std::__uninitialized_copy_a(__first, __last, __result, _M_get_Tp_allocator()); 
# 1513
return __result; 
# 1514
} 
# 1515
catch (...) 
# 1516
{ 
# 1517
_M_deallocate(__result, __n); 
# 1518
throw; 
# 1519
}  
# 1520
} 
# 1553 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class _InputIterator> void 
# 1555
_M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) 
# 1557
{ 
# 1558
try { 
# 1559
for (; __first != __last; ++__first) { 
# 1561
emplace_back(*__first); }  
# 1565
} catch (...) { 
# 1566
clear(); 
# 1567
throw; 
# 1568
}  
# 1569
} 
# 1572
template< class _ForwardIterator> void 
# 1574
_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) 
# 1576
{ 
# 1577
const size_type __n = std::distance(__first, __last); 
# 1578
((this->_M_impl)._M_start) = this->_M_allocate((_S_check_init_len)(__n, _M_get_Tp_allocator())); 
# 1580
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 1581
((this->_M_impl)._M_finish) = std::__uninitialized_copy_a(__first, __last, ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 1585
} 
# 1590
void _M_fill_initialize(size_type __n, const value_type &__value) 
# 1591
{ 
# 1592
((this->_M_impl)._M_finish) = std::__uninitialized_fill_n_a(((this->_M_impl)._M_start), __n, __value, _M_get_Tp_allocator()); 
# 1595
} 
# 1600
void _M_default_initialize(size_type __n) 
# 1601
{ 
# 1602
((this->_M_impl)._M_finish) = std::__uninitialized_default_n_a(((this->_M_impl)._M_start), __n, _M_get_Tp_allocator()); 
# 1605
} 
# 1615 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class _Integer> void 
# 1617
_M_assign_dispatch(_Integer __n, _Integer __val, std::__true_type) 
# 1618
{ _M_fill_assign(__n, __val); } 
# 1621
template< class _InputIterator> void 
# 1623
_M_assign_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type) 
# 1625
{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); } 
# 1628
template< class _InputIterator> void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag); 
# 1634
template< class _ForwardIterator> void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag); 
# 1642
void _M_fill_assign(size_type __n, const value_type & __val); 
# 1650
template< class _Integer> void 
# 1652
_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, std::__true_type) 
# 1654
{ _M_fill_insert(__pos, __n, __val); } 
# 1657
template< class _InputIterator> void 
# 1659
_M_insert_dispatch(iterator __pos, _InputIterator __first, _InputIterator 
# 1660
__last, std::__false_type) 
# 1661
{ 
# 1662
_M_range_insert(__pos, __first, __last, std::__iterator_category(__first)); 
# 1664
} 
# 1667
template< class _InputIterator> void _M_range_insert(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag); 
# 1673
template< class _ForwardIterator> void _M_range_insert(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag); 
# 1681
void _M_fill_insert(iterator __pos, size_type __n, const value_type & __x); 
# 1686
void _M_default_append(size_type __n); 
# 1689
bool _M_shrink_to_fit(); 
# 1702 "/usr/include/c++/9/bits/stl_vector.h" 3
struct _Temporary_value { 
# 1704
template< class ..._Args> explicit 
# 1706
_Temporary_value(vector *__vec, _Args &&...__args) : _M_this(__vec) 
# 1707
{ 
# 1708
_Alloc_traits::construct(((_M_this)->_M_impl), _M_ptr(), std::forward< _Args> (__args)...); 
# 1710
} 
# 1712
~_Temporary_value() 
# 1713
{ _Alloc_traits::destroy(((_M_this)->_M_impl), _M_ptr()); } 
# 1716
value_type &_M_val() { return *_M_ptr(); } 
# 1720
private: _Tp *_M_ptr() { return reinterpret_cast< _Tp *>(&(__buf)); } 
# 1722
vector *_M_this; 
# 1723
typename aligned_storage< sizeof(_Tp), __alignof__(_Tp)> ::type __buf; 
# 1724
}; 
# 1728
template< class _Arg> void _M_insert_aux(iterator __position, _Arg && __arg); 
# 1732
template< class ..._Args> void _M_realloc_insert(iterator __position, _Args && ...__args); 
# 1738
iterator _M_insert_rval(const_iterator __position, value_type && __v); 
# 1741
template< class ..._Args> iterator _M_emplace_aux(const_iterator __position, _Args && ...__args); 
# 1747
iterator _M_emplace_aux(const_iterator __position, value_type &&__v) 
# 1748
{ return _M_insert_rval(__position, std::move(__v)); } 
# 1753
size_type _M_check_len(size_type __n, const char *__s) const 
# 1754
{ 
# 1755
if ((max_size() - size()) < __n) { 
# 1756
__throw_length_error(__s); }  
# 1758
const size_type __len = size() + (std::max)(size(), __n); 
# 1759
return ((__len < size()) || (__len > max_size())) ? max_size() : __len; 
# 1760
} 
# 1764
static size_type _S_check_init_len(size_type __n, const allocator_type &__a) 
# 1765
{ 
# 1766
if (__n > (_S_max_size)((_Tp_alloc_type)__a)) { 
# 1767
__throw_length_error("cannot create std::vector larger than max_size()"); }  
# 1769
return __n; 
# 1770
} 
# 1773
static size_type _S_max_size(const _Tp_alloc_type &__a) noexcept 
# 1774
{ 
# 1778
const std::size_t __diffmax = (__gnu_cxx::__numeric_traits_integer< std::streamsize> ::__max / sizeof(_Tp)); 
# 1780
const std::size_t __allocmax = _Alloc_traits::max_size(__a); 
# 1781
return (std::min)(__diffmax, __allocmax); 
# 1782
} 
# 1789
void _M_erase_at_end(pointer __pos) noexcept 
# 1790
{ 
# 1791
if (size_type __n = ((this->_M_impl)._M_finish) - __pos) 
# 1792
{ 
# 1793
std::_Destroy(__pos, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 1795
((this->_M_impl)._M_finish) = __pos; 
# 1796
; 
# 1797
}  
# 1798
} 
# 1801
iterator _M_erase(iterator __position); 
# 1804
iterator _M_erase(iterator __first, iterator __last); 
# 1812
private: void _M_move_assign(vector &&__x, std::true_type) noexcept 
# 1813
{ 
# 1814
vector __tmp(get_allocator()); 
# 1815
(this->_M_impl)._M_swap_data((__x._M_impl)); 
# 1816
(__tmp._M_impl)._M_swap_data((__x._M_impl)); 
# 1817
std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()); 
# 1818
} 
# 1823
void _M_move_assign(vector &&__x, std::false_type) 
# 1824
{ 
# 1825
if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator()) { 
# 1826
_M_move_assign(std::move(__x), std::true_type()); } else 
# 1828
{ 
# 1831
this->assign(std::__make_move_if_noexcept_iterator(__x.begin()), std::__make_move_if_noexcept_iterator(__x.end())); 
# 1833
__x.clear(); 
# 1834
}  
# 1835
} 
# 1838
template< class _Up> _Up *
# 1840
_M_data_ptr(_Up *__ptr) const noexcept 
# 1841
{ return __ptr; } 
# 1844
template< class _Ptr> typename pointer_traits< _Ptr> ::element_type *
# 1846
_M_data_ptr(_Ptr __ptr) const 
# 1847
{ return (empty()) ? nullptr : std::__to_address(__ptr); } 
# 1864 "/usr/include/c++/9/bits/stl_vector.h" 3
}; 
# 1886 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class _Tp, class _Alloc> inline bool 
# 1888
operator==(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1889
{ return ((__x.size() == __y.size()) && std::equal(__x.begin(), __x.end(), __y.begin())); 
# 1890
} 
# 1903 "/usr/include/c++/9/bits/stl_vector.h" 3
template< class _Tp, class _Alloc> inline bool 
# 1905
operator<(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1906
{ return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end()); 
# 1907
} 
# 1910
template< class _Tp, class _Alloc> inline bool 
# 1912
operator!=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1913
{ return !(__x == __y); } 
# 1916
template< class _Tp, class _Alloc> inline bool 
# 1918
operator>(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1919
{ return __y < __x; } 
# 1922
template< class _Tp, class _Alloc> inline bool 
# 1924
operator<=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1925
{ return !(__y < __x); } 
# 1928
template< class _Tp, class _Alloc> inline bool 
# 1930
operator>=(const vector< _Tp, _Alloc>  &__x, const vector< _Tp, _Alloc>  &__y) 
# 1931
{ return !(__x < __y); } 
# 1934
template< class _Tp, class _Alloc> inline void 
# 1936
swap(vector< _Tp, _Alloc>  &__x, vector< _Tp, _Alloc>  &__y) noexcept(noexcept(__x.swap(__y))) 
# 1938
{ __x.swap(__y); } 
# 1957 "/usr/include/c++/9/bits/stl_vector.h" 3
}
# 64 "/usr/include/c++/9/bits/stl_bvector.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 69
typedef unsigned long _Bit_type; 
# 70
enum { _S_word_bit = ((int)((8) * sizeof(_Bit_type)))}; 
# 72
struct _Bit_reference { 
# 74
_Bit_type *_M_p; 
# 75
_Bit_type _M_mask; 
# 77
_Bit_reference(_Bit_type *__x, _Bit_type __y) : _M_p(__x), _M_mask(__y) 
# 78
{ } 
# 80
_Bit_reference() noexcept : _M_p((0)), _M_mask((0)) { } 
# 83
_Bit_reference(const _Bit_reference &) = default;
# 86
operator bool() const noexcept 
# 87
{ return !(!((*(_M_p)) & (_M_mask))); } 
# 90
_Bit_reference &operator=(bool __x) noexcept 
# 91
{ 
# 92
if (__x) { 
# 93
(*(_M_p)) |= (_M_mask); } else { 
# 95
(*(_M_p)) &= (~(_M_mask)); }  
# 96
return *this; 
# 97
} 
# 100
_Bit_reference &operator=(const _Bit_reference &__x) noexcept 
# 101
{ return ((*this) = ((bool)__x)); } 
# 104
bool operator==(const _Bit_reference &__x) const 
# 105
{ return ((bool)(*this)) == ((bool)__x); } 
# 108
bool operator<(const _Bit_reference &__x) const 
# 109
{ return (!((bool)(*this))) && ((bool)__x); } 
# 112
void flip() noexcept 
# 113
{ (*(_M_p)) ^= (_M_mask); } 
# 114
}; 
# 118
inline void swap(_Bit_reference __x, _Bit_reference __y) noexcept 
# 119
{ 
# 120
bool __tmp = __x; 
# 121
(__x = __y); 
# 122
(__y = __tmp); 
# 123
} 
# 126
inline void swap(_Bit_reference __x, bool &__y) noexcept 
# 127
{ 
# 128
bool __tmp = __x; 
# 129
(__x = __y); 
# 130
__y = __tmp; 
# 131
} 
# 134
inline void swap(bool &__x, _Bit_reference __y) noexcept 
# 135
{ 
# 136
bool __tmp = __x; 
# 137
__x = __y; 
# 138
(__y = __tmp); 
# 139
} 
# 142
struct _Bit_iterator_base : public iterator< random_access_iterator_tag, bool>  { 
# 145
_Bit_type *_M_p; 
# 146
unsigned _M_offset; 
# 148
_Bit_iterator_base(_Bit_type *__x, unsigned __y) : _M_p(__x), _M_offset(__y) 
# 149
{ } 
# 152
void _M_bump_up() 
# 153
{ 
# 154
if (((_M_offset)++) == (((int)_S_word_bit) - 1)) 
# 155
{ 
# 156
(_M_offset) = (0); 
# 157
++(_M_p); 
# 158
}  
# 159
} 
# 162
void _M_bump_down() 
# 163
{ 
# 164
if (((_M_offset)--) == (0)) 
# 165
{ 
# 166
(_M_offset) = (((int)_S_word_bit) - 1); 
# 167
--(_M_p); 
# 168
}  
# 169
} 
# 172
void _M_incr(ptrdiff_t __i) 
# 173
{ 
# 174
difference_type __n = __i + (_M_offset); 
# 175
(_M_p) += (__n / ((int)_S_word_bit)); 
# 176
__n = (__n % ((int)_S_word_bit)); 
# 177
if (__n < (0)) 
# 178
{ 
# 179
__n += ((int)_S_word_bit); 
# 180
--(_M_p); 
# 181
}  
# 182
(_M_offset) = (static_cast< unsigned>(__n)); 
# 183
} 
# 186
bool operator==(const _Bit_iterator_base &__i) const 
# 187
{ return ((_M_p) == (__i._M_p)) && ((_M_offset) == (__i._M_offset)); } 
# 190
bool operator<(const _Bit_iterator_base &__i) const 
# 191
{ 
# 192
return ((_M_p) < (__i._M_p)) || (((_M_p) == (__i._M_p)) && ((_M_offset) < (__i._M_offset))); 
# 194
} 
# 197
bool operator!=(const _Bit_iterator_base &__i) const 
# 198
{ return !((*this) == __i); } 
# 201
bool operator>(const _Bit_iterator_base &__i) const 
# 202
{ return (__i < (*this)); } 
# 205
bool operator<=(const _Bit_iterator_base &__i) const 
# 206
{ return !(__i < (*this)); } 
# 209
bool operator>=(const _Bit_iterator_base &__i) const 
# 210
{ return !((*this) < __i); } 
# 211
}; 
# 214
inline ptrdiff_t operator-(const _Bit_iterator_base &__x, const _Bit_iterator_base &__y) 
# 215
{ 
# 216
return (((((int)_S_word_bit) * ((__x._M_p) - (__y._M_p))) + (__x._M_offset)) - (__y._M_offset)); 
# 218
} 
# 220
struct _Bit_iterator : public _Bit_iterator_base { 
# 222
typedef _Bit_reference reference; 
# 223
typedef _Bit_reference *pointer; 
# 224
typedef _Bit_iterator iterator; 
# 226
_Bit_iterator() : _Bit_iterator_base(0, 0) { } 
# 228
_Bit_iterator(_Bit_type *__x, unsigned __y) : _Bit_iterator_base(__x, __y) 
# 229
{ } 
# 232
iterator _M_const_cast() const 
# 233
{ return *this; } 
# 236
reference operator*() const 
# 237
{ return reference(_M_p, 1UL << (_M_offset)); } 
# 240
iterator &operator++() 
# 241
{ 
# 242
this->_M_bump_up(); 
# 243
return *this; 
# 244
} 
# 247
iterator operator++(int) 
# 248
{ 
# 249
iterator __tmp = *this; 
# 250
this->_M_bump_up(); 
# 251
return __tmp; 
# 252
} 
# 255
iterator &operator--() 
# 256
{ 
# 257
this->_M_bump_down(); 
# 258
return *this; 
# 259
} 
# 262
iterator operator--(int) 
# 263
{ 
# 264
iterator __tmp = *this; 
# 265
this->_M_bump_down(); 
# 266
return __tmp; 
# 267
} 
# 270
iterator &operator+=(difference_type __i) 
# 271
{ 
# 272
this->_M_incr(__i); 
# 273
return *this; 
# 274
} 
# 277
iterator &operator-=(difference_type __i) 
# 278
{ 
# 279
((*this) += (-__i)); 
# 280
return *this; 
# 281
} 
# 284
iterator operator+(difference_type __i) const 
# 285
{ 
# 286
iterator __tmp = *this; 
# 287
return (__tmp += __i); 
# 288
} 
# 291
iterator operator-(difference_type __i) const 
# 292
{ 
# 293
iterator __tmp = *this; 
# 294
return (__tmp -= __i); 
# 295
} 
# 298
reference operator[](difference_type __i) const 
# 299
{ return (*(((*this) + __i))); } 
# 300
}; 
# 303
inline _Bit_iterator operator+(ptrdiff_t __n, const _Bit_iterator &__x) 
# 304
{ return (__x + __n); } 
# 306
struct _Bit_const_iterator : public _Bit_iterator_base { 
# 308
typedef bool reference; 
# 309
typedef bool const_reference; 
# 310
typedef const bool *pointer; 
# 311
typedef _Bit_const_iterator const_iterator; 
# 313
_Bit_const_iterator() : _Bit_iterator_base(0, 0) { } 
# 315
_Bit_const_iterator(_Bit_type *__x, unsigned __y) : _Bit_iterator_base(__x, __y) 
# 316
{ } 
# 318
_Bit_const_iterator(const _Bit_iterator &__x) : _Bit_iterator_base(__x._M_p, __x._M_offset) 
# 319
{ } 
# 322
_Bit_iterator _M_const_cast() const 
# 323
{ return _Bit_iterator(_M_p, _M_offset); } 
# 326
const_reference operator*() const 
# 327
{ return _Bit_reference(_M_p, 1UL << (_M_offset)); } 
# 330
const_iterator &operator++() 
# 331
{ 
# 332
this->_M_bump_up(); 
# 333
return *this; 
# 334
} 
# 337
const_iterator operator++(int) 
# 338
{ 
# 339
const_iterator __tmp = *this; 
# 340
this->_M_bump_up(); 
# 341
return __tmp; 
# 342
} 
# 345
const_iterator &operator--() 
# 346
{ 
# 347
this->_M_bump_down(); 
# 348
return *this; 
# 349
} 
# 352
const_iterator operator--(int) 
# 353
{ 
# 354
const_iterator __tmp = *this; 
# 355
this->_M_bump_down(); 
# 356
return __tmp; 
# 357
} 
# 360
const_iterator &operator+=(difference_type __i) 
# 361
{ 
# 362
this->_M_incr(__i); 
# 363
return *this; 
# 364
} 
# 367
const_iterator &operator-=(difference_type __i) 
# 368
{ 
# 369
((*this) += (-__i)); 
# 370
return *this; 
# 371
} 
# 374
const_iterator operator+(difference_type __i) const 
# 375
{ 
# 376
const_iterator __tmp = *this; 
# 377
return (__tmp += __i); 
# 378
} 
# 381
const_iterator operator-(difference_type __i) const 
# 382
{ 
# 383
const_iterator __tmp = *this; 
# 384
return (__tmp -= __i); 
# 385
} 
# 388
const_reference operator[](difference_type __i) const 
# 389
{ return (*(((*this) + __i))); } 
# 390
}; 
# 393
inline _Bit_const_iterator operator+(ptrdiff_t __n, const _Bit_const_iterator &__x) 
# 394
{ return (__x + __n); } 
# 397
inline void __fill_bvector(_Bit_type *__v, unsigned 
# 398
__first, unsigned __last, bool __x) 
# 399
{ 
# 400
const _Bit_type __fmask = (~0UL) << __first; 
# 401
const _Bit_type __lmask = (~0UL) >> ((_S_word_bit) - __last); 
# 402
const _Bit_type __mask = __fmask & __lmask; 
# 404
if (__x) { 
# 405
(*__v) |= __mask; } else { 
# 407
(*__v) &= (~__mask); }  
# 408
} 
# 411
inline void fill(_Bit_iterator __first, _Bit_iterator __last, const bool &__x) 
# 412
{ 
# 413
if ((__first._M_p) != (__last._M_p)) 
# 414
{ 
# 415
_Bit_type *__first_p = __first._M_p; 
# 416
if ((__first._M_offset) != (0)) { 
# 417
__fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x); }  
# 419
__builtin_memset(__first_p, __x ? ~0 : 0, ((__last._M_p) - __first_p) * sizeof(_Bit_type)); 
# 422
if ((__last._M_offset) != (0)) { 
# 423
__fill_bvector(__last._M_p, 0, __last._M_offset, __x); }  
# 424
} else { 
# 425
if ((__first._M_offset) != (__last._M_offset)) { 
# 426
__fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x); }  }  
# 427
} 
# 429
template< class _Alloc> 
# 430
struct _Bvector_base { 
# 433
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Bit_type> ::other _Bit_alloc_type; 
# 435
typedef __gnu_cxx::__alloc_traits< _Bit_alloc_type>  _Bit_alloc_traits; 
# 436
typedef typename __gnu_cxx::__alloc_traits< _Bit_alloc_type> ::pointer _Bit_pointer; 
# 438
struct _Bvector_impl_data { 
# 440
_Bit_iterator _M_start; 
# 441
_Bit_iterator _M_finish; 
# 442
_Bit_pointer _M_end_of_storage; 
# 444
_Bvector_impl_data() noexcept : _M_start(), _M_finish(), _M_end_of_storage() 
# 446
{ } 
# 449
_Bvector_impl_data(_Bvector_impl_data &&__x) noexcept : _M_start(__x._M_start), _M_finish(__x._M_finish), _M_end_of_storage(__x._M_end_of_storage) 
# 452
{ __x._M_reset(); } 
# 455
void _M_move_data(_Bvector_impl_data &&__x) noexcept 
# 456
{ 
# 457
(this->_M_start) = (__x._M_start); 
# 458
(this->_M_finish) = (__x._M_finish); 
# 459
(this->_M_end_of_storage) = (__x._M_end_of_storage); 
# 460
__x._M_reset(); 
# 461
} 
# 465
void _M_reset() noexcept 
# 466
{ 
# 467
(_M_start) = ((_M_finish) = _Bit_iterator()); 
# 468
(_M_end_of_storage) = _Bit_pointer(); 
# 469
} 
# 470
}; 
# 472
struct _Bvector_impl : public _Bit_alloc_type, public _Bvector_impl_data { 
# 476
_Bvector_impl() noexcept(is_nothrow_default_constructible< typename _Bvector_base< _Alloc> ::_Bit_alloc_type> ::value) : _Bvector_base< _Alloc> ::_Bit_alloc_type() 
# 479
{ } 
# 481
_Bvector_impl(const typename _Bvector_base< _Alloc> ::_Bit_alloc_type &__a) noexcept : _Bvector_base< _Alloc> ::_Bit_alloc_type(__a) 
# 483
{ } 
# 486
_Bvector_impl(_Bvector_impl &&) = default;
# 490
std::_Bit_type *_M_end_addr() const noexcept 
# 491
{ 
# 492
if (this->_M_end_of_storage) { 
# 493
return std::__addressof((this->_M_end_of_storage)[-1]) + 1; }  
# 494
return 0; 
# 495
} 
# 496
}; 
# 499
typedef _Alloc allocator_type; 
# 502
_Bit_alloc_type &_M_get_Bit_allocator() noexcept 
# 503
{ return this->_M_impl; } 
# 506
const _Bit_alloc_type &_M_get_Bit_allocator() const noexcept 
# 507
{ return this->_M_impl; } 
# 510
allocator_type get_allocator() const noexcept 
# 511
{ return (allocator_type)_M_get_Bit_allocator(); } 
# 514
_Bvector_base() = default;
# 519
_Bvector_base(const allocator_type &__a) : _M_impl(__a) 
# 520
{ } 
# 523
_Bvector_base(_Bvector_base &&) = default;
# 526
~_Bvector_base() 
# 527
{ _M_deallocate(); } 
# 530
protected: _Bvector_impl _M_impl; 
# 533
_Bit_pointer _M_allocate(size_t __n) 
# 534
{ return _Bit_alloc_traits::allocate(_M_impl, (_S_nword)(__n)); } 
# 537
void _M_deallocate() 
# 538
{ 
# 539
if (((_M_impl)._M_start)._M_p) 
# 540
{ 
# 541
const size_t __n = (_M_impl)._M_end_addr() - (((_M_impl)._M_start)._M_p); 
# 542
_Bit_alloc_traits::deallocate(_M_impl, ((_M_impl)._M_end_of_storage) - __n, __n); 
# 545
(_M_impl)._M_reset(); 
# 546
}  
# 547
} 
# 551
void _M_move_data(_Bvector_base &&__x) noexcept 
# 552
{ (_M_impl)._M_move_data(std::move(__x._M_impl)); } 
# 556
static size_t _S_nword(size_t __n) 
# 557
{ return ((__n + ((int)_S_word_bit)) - (1)) / ((int)_S_word_bit); } 
# 558
}; 
# 562
}
# 567
namespace std __attribute((__visibility__("default"))) { 
# 591 "/usr/include/c++/9/bits/stl_bvector.h" 3
template< class _Alloc> 
# 592
class vector< bool, _Alloc>  : protected _Bvector_base< _Alloc>  { 
# 594
typedef _Bvector_base< _Alloc>  _Base; 
# 595
typedef typename _Bvector_base< _Alloc> ::_Bit_pointer _Bit_pointer; 
# 596
typedef typename _Bvector_base< _Alloc> ::_Bit_alloc_traits _Bit_alloc_traits; 
# 599
friend struct hash< std::vector< bool, _Alloc> > ; 
# 603
public: typedef bool value_type; 
# 604
typedef std::size_t size_type; 
# 605
typedef std::ptrdiff_t difference_type; 
# 606
typedef std::_Bit_reference reference; 
# 607
typedef bool const_reference; 
# 608
typedef std::_Bit_reference *pointer; 
# 609
typedef const bool *const_pointer; 
# 610
typedef std::_Bit_iterator iterator; 
# 611
typedef std::_Bit_const_iterator const_iterator; 
# 612
typedef std::reverse_iterator< std::_Bit_const_iterator>  const_reverse_iterator; 
# 613
typedef std::reverse_iterator< std::_Bit_iterator>  reverse_iterator; 
# 614
typedef _Alloc allocator_type; 
# 617
allocator_type get_allocator() const 
# 618
{ return _Base::get_allocator(); } 
# 621
protected: using _Bvector_base< _Alloc> ::_M_allocate;
# 622
using _Bvector_base< _Alloc> ::_M_deallocate;
# 623
using _Bvector_base< _Alloc> ::_S_nword;
# 624
using _Bvector_base< _Alloc> ::_M_get_Bit_allocator;
# 628
public: vector() = default;
# 634
explicit vector(const allocator_type &__a) : _Base(__a) 
# 635
{ } 
# 639
explicit vector(size_type __n, const allocator_type &__a = allocator_type()) : vector(__n, false, __a) 
# 641
{ } 
# 643
vector(size_type __n, const bool &__value, const allocator_type &
# 644
__a = allocator_type()) : _Base(__a) 
# 651
{ 
# 652
_M_initialize(__n); 
# 653
_M_initialize_value(__value); 
# 654
} 
# 656
vector(const std::vector< bool, _Alloc>  &__x) : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator())) 
# 658
{ 
# 659
_M_initialize(__x.size()); 
# 660
_M_copy_aligned(__x.begin(), __x.end(), ((this->_M_impl)._M_start)); 
# 661
} 
# 664
vector(std::vector< bool, _Alloc>  &&) = default;
# 666
vector(std::vector< bool, _Alloc>  &&__x, const allocator_type &__a) noexcept(_Bit_alloc_traits::_S_always_equal()) : _Base(__a) 
# 669
{ 
# 670
if (__x.get_allocator() == __a) { 
# 671
this->_M_move_data(std::move(__x)); } else 
# 673
{ 
# 674
_M_initialize(__x.size()); 
# 675
_M_copy_aligned(__x.begin(), __x.end(), begin()); 
# 676
__x.clear(); 
# 677
}  
# 678
} 
# 680
vector(const std::vector< bool, _Alloc>  &__x, const allocator_type &__a) : _Base(__a) 
# 682
{ 
# 683
_M_initialize(__x.size()); 
# 684
_M_copy_aligned(__x.begin(), __x.end(), ((this->_M_impl)._M_start)); 
# 685
} 
# 687
vector(std::initializer_list< bool>  __l, const allocator_type &
# 688
__a = allocator_type()) : _Base(__a) 
# 690
{ 
# 691
_M_initialize_range(__l.begin(), __l.end(), std::random_access_iterator_tag()); 
# 693
} 
# 697
template< class _InputIterator, class 
# 698
 = std::_RequireInputIter< _InputIterator> > 
# 699
vector(_InputIterator __first, _InputIterator __last, const allocator_type &
# 700
__a = allocator_type()) : _Base(__a) 
# 702
{ _M_initialize_dispatch(__first, __last, std::__false_type()); } 
# 714 "/usr/include/c++/9/bits/stl_bvector.h" 3
~vector() noexcept { } 
# 717
std::vector< bool, _Alloc>  &operator=(const std::vector< bool, _Alloc>  &__x) 
# 718
{ 
# 719
if ((&__x) == this) { 
# 720
return *this; }  
# 722
if (_Bit_alloc_traits::_S_propagate_on_copy_assign()) 
# 723
{ 
# 724
if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator()) 
# 725
{ 
# 726
this->_M_deallocate(); 
# 727
std::__alloc_on_copy(_M_get_Bit_allocator(), __x._M_get_Bit_allocator()); 
# 729
_M_initialize(__x.size()); 
# 730
} else { 
# 732
std::__alloc_on_copy(_M_get_Bit_allocator(), __x._M_get_Bit_allocator()); }  
# 734
}  
# 736
if (__x.size() > capacity()) 
# 737
{ 
# 738
this->_M_deallocate(); 
# 739
_M_initialize(__x.size()); 
# 740
}  
# 741
((this->_M_impl)._M_finish) = _M_copy_aligned(__x.begin(), __x.end(), begin()); 
# 743
return *this; 
# 744
} 
# 748
std::vector< bool, _Alloc>  &operator=(std::vector< bool, _Alloc>  &&__x) noexcept(_Bit_alloc_traits::_S_nothrow_move()) 
# 749
{ 
# 750
if (_Bit_alloc_traits::_S_propagate_on_move_assign() || (this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())) 
# 752
{ 
# 753
this->_M_deallocate(); 
# 754
this->_M_move_data(std::move(__x)); 
# 755
std::__alloc_on_move(_M_get_Bit_allocator(), __x._M_get_Bit_allocator()); 
# 757
} else 
# 759
{ 
# 760
if (__x.size() > capacity()) 
# 761
{ 
# 762
this->_M_deallocate(); 
# 763
_M_initialize(__x.size()); 
# 764
}  
# 765
((this->_M_impl)._M_finish) = _M_copy_aligned(__x.begin(), __x.end(), begin()); 
# 767
__x.clear(); 
# 768
}  
# 769
return *this; 
# 770
} 
# 773
std::vector< bool, _Alloc>  &operator=(std::initializer_list< bool>  __l) 
# 774
{ 
# 775
this->assign(__l.begin(), __l.end()); 
# 776
return *this; 
# 777
} 
# 785
void assign(size_type __n, const bool &__x) 
# 786
{ _M_fill_assign(__n, __x); } 
# 789
template< class _InputIterator, class 
# 790
 = std::_RequireInputIter< _InputIterator> > void 
# 792
assign(_InputIterator __first, _InputIterator __last) 
# 793
{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); } 
# 806 "/usr/include/c++/9/bits/stl_bvector.h" 3
void assign(std::initializer_list< bool>  __l) 
# 807
{ _M_assign_aux(__l.begin(), __l.end(), std::random_access_iterator_tag()); } 
# 811
iterator begin() noexcept 
# 812
{ return iterator((((this->_M_impl)._M_start)._M_p), 0); } 
# 815
const_iterator begin() const noexcept 
# 816
{ return const_iterator((((this->_M_impl)._M_start)._M_p), 0); } 
# 819
iterator end() noexcept 
# 820
{ return (this->_M_impl)._M_finish; } 
# 823
const_iterator end() const noexcept 
# 824
{ return (this->_M_impl)._M_finish; } 
# 827
reverse_iterator rbegin() noexcept 
# 828
{ return ((std::reverse_iterator< std::_Bit_iterator> )(end())); } 
# 831
const_reverse_iterator rbegin() const noexcept 
# 832
{ return ((std::reverse_iterator< std::_Bit_const_iterator> )(end())); } 
# 835
reverse_iterator rend() noexcept 
# 836
{ return ((std::reverse_iterator< std::_Bit_iterator> )(begin())); } 
# 839
const_reverse_iterator rend() const noexcept 
# 840
{ return ((std::reverse_iterator< std::_Bit_const_iterator> )(begin())); } 
# 844
const_iterator cbegin() const noexcept 
# 845
{ return const_iterator((((this->_M_impl)._M_start)._M_p), 0); } 
# 848
const_iterator cend() const noexcept 
# 849
{ return (this->_M_impl)._M_finish; } 
# 852
const_reverse_iterator crbegin() const noexcept 
# 853
{ return ((std::reverse_iterator< std::_Bit_const_iterator> )(end())); } 
# 856
const_reverse_iterator crend() const noexcept 
# 857
{ return ((std::reverse_iterator< std::_Bit_const_iterator> )(begin())); } 
# 861
size_type size() const noexcept 
# 862
{ return (size_type)((end()) - (begin())); } 
# 865
size_type max_size() const noexcept 
# 866
{ 
# 867
const size_type __isize = ((__gnu_cxx::__numeric_traits_integer< std::streamsize> ::__max - ((int)_S_word_bit)) + (1)); 
# 870
const size_type __asize = _Bit_alloc_traits::max_size(_M_get_Bit_allocator()); 
# 872
return (__asize <= (__isize / ((int)_S_word_bit))) ? __asize * ((int)_S_word_bit) : __isize; 
# 874
} 
# 877
size_type capacity() const noexcept 
# 878
{ return (size_type)(const_iterator((this->_M_impl)._M_end_addr(), 0) - (begin())); 
# 879
} 
# 882
bool empty() const noexcept 
# 883
{ return ((begin()) == (end())); } 
# 886
reference operator[](size_type __n) 
# 887
{ 
# 888
return (*iterator((((this->_M_impl)._M_start)._M_p) + (__n / ((int)_S_word_bit)), __n % ((int)_S_word_bit))); 
# 890
} 
# 893
const_reference operator[](size_type __n) const 
# 894
{ 
# 895
return (*const_iterator((((this->_M_impl)._M_start)._M_p) + (__n / ((int)_S_word_bit)), __n % ((int)_S_word_bit))); 
# 897
} 
# 901
protected: void _M_range_check(size_type __n) const 
# 902
{ 
# 903
if (__n >= size()) { 
# 904
__throw_out_of_range_fmt("vector<bool>::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)", __n, size()); }  
# 908
} 
# 912
public: reference at(size_type __n) 
# 913
{ _M_range_check(__n); return (*this)[__n]; } 
# 916
const_reference at(size_type __n) const 
# 917
{ _M_range_check(__n); return (*this)[__n]; } 
# 920
void reserve(size_type __n) 
# 921
{ 
# 922
if (__n > max_size()) { 
# 923
__throw_length_error("vector::reserve"); }  
# 924
if (capacity() < __n) { 
# 925
_M_reallocate(__n); }  
# 926
} 
# 929
reference front() 
# 930
{ return (*(begin())); } 
# 933
const_reference front() const 
# 934
{ return (*(begin())); } 
# 937
reference back() 
# 938
{ return (*(((end()) - (1)))); } 
# 941
const_reference back() const 
# 942
{ return (*(((end()) - (1)))); } 
# 950
void data() noexcept { } 
# 953
void push_back(bool __x) 
# 954
{ 
# 955
if ((((this->_M_impl)._M_finish)._M_p) != (this->_M_impl)._M_end_addr()) { 
# 956
(*(((this->_M_impl)._M_finish)++)) = __x; } else { 
# 958
_M_insert_aux(end(), __x); }  
# 959
} 
# 962
void swap(std::vector< bool, _Alloc>  &__x) noexcept 
# 963
{ 
# 964
std::swap(((this->_M_impl)._M_start), ((__x._M_impl)._M_start)); 
# 965
std::swap(((this->_M_impl)._M_finish), ((__x._M_impl)._M_finish)); 
# 966
std::swap(((this->_M_impl)._M_end_of_storage), ((__x._M_impl)._M_end_of_storage)); 
# 968
_Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(), __x._M_get_Bit_allocator()); 
# 970
} 
# 974
static void swap(reference __x, reference __y) noexcept 
# 975
{ 
# 976
bool __tmp = __x; 
# 977
(__x = __y); 
# 978
(__y = __tmp); 
# 979
} 
# 983
iterator insert(const_iterator __position, const bool &__x = ((bool)0)) 
# 987
{ 
# 988
const difference_type __n = (__position - (begin())); 
# 989
if (((((this->_M_impl)._M_finish)._M_p) != (this->_M_impl)._M_end_addr()) && (__position == (end()))) { 
# 991
(*(((this->_M_impl)._M_finish)++)) = __x; } else { 
# 993
_M_insert_aux(__position._M_const_cast(), __x); }  
# 994
return ((begin()) + __n); 
# 995
} 
# 998
template< class _InputIterator, class 
# 999
 = std::_RequireInputIter< _InputIterator> > iterator 
# 1001
insert(const_iterator __position, _InputIterator 
# 1002
__first, _InputIterator __last) 
# 1003
{ 
# 1004
difference_type __offset = __position - cbegin(); 
# 1005
_M_insert_dispatch(__position._M_const_cast(), __first, __last, std::__false_type()); 
# 1007
return ((begin()) + __offset); 
# 1008
} 
# 1022 "/usr/include/c++/9/bits/stl_bvector.h" 3
iterator insert(const_iterator __position, size_type __n, const bool &__x) 
# 1023
{ 
# 1024
difference_type __offset = __position - cbegin(); 
# 1025
_M_fill_insert(__position._M_const_cast(), __n, __x); 
# 1026
return ((begin()) + __offset); 
# 1027
} 
# 1036
iterator insert(const_iterator __p, std::initializer_list< bool>  __l) 
# 1037
{ return this->insert(__p, __l.begin(), __l.end()); } 
# 1041
void pop_back() 
# 1042
{ --((this->_M_impl)._M_finish); } 
# 1046
iterator erase(const_iterator __position) 
# 1050
{ return _M_erase(__position._M_const_cast()); } 
# 1054
iterator erase(const_iterator __first, const_iterator __last) 
# 1058
{ return _M_erase(__first._M_const_cast(), __last._M_const_cast()); } 
# 1061
void resize(size_type __new_size, bool __x = ((bool)0)) 
# 1062
{ 
# 1063
if (__new_size < size()) { 
# 1064
_M_erase_at_end(((begin()) + ((difference_type)__new_size))); } else { 
# 1066
insert(end(), __new_size - size(), __x); }  
# 1067
} 
# 1071
void shrink_to_fit() 
# 1072
{ _M_shrink_to_fit(); } 
# 1076
void flip() noexcept 
# 1077
{ 
# 1078
std::_Bit_type *const __end = (this->_M_impl)._M_end_addr(); 
# 1079
for (std::_Bit_type *__p = ((((this->_M_impl)._M_start)._M_p)); __p != __end; ++__p) { 
# 1080
(*__p) = (~(*__p)); }  
# 1081
} 
# 1084
void clear() noexcept 
# 1085
{ _M_erase_at_end(begin()); } 
# 1088
template< class ..._Args> void 
# 1094
emplace_back(_Args &&...__args) 
# 1095
{ 
# 1096
push_back(bool(__args...)); 
# 1100
} 
# 1102
template< class ..._Args> iterator 
# 1104
emplace(const_iterator __pos, _Args &&...__args) 
# 1105
{ return insert(__pos, bool(__args...)); } 
# 1111
protected: iterator _M_copy_aligned(const_iterator __first, const_iterator __last, iterator 
# 1112
__result) 
# 1113
{ 
# 1114
std::_Bit_type *__q = std::copy(__first._M_p, __last._M_p, __result._M_p); 
# 1115
return std::copy(const_iterator(__last._M_p, 0), __last, iterator(__q, 0)); 
# 1117
} 
# 1120
void _M_initialize(size_type __n) 
# 1121
{ 
# 1122
if (__n) 
# 1123
{ 
# 1124
_Bit_pointer __q = this->_M_allocate(__n); 
# 1125
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__n)); 
# 1126
((this->_M_impl)._M_start) = iterator(std::__addressof(*__q), 0); 
# 1127
} else 
# 1129
{ 
# 1130
((this->_M_impl)._M_end_of_storage) = _Bit_pointer(); 
# 1131
((this->_M_impl)._M_start) = iterator(0, 0); 
# 1132
}  
# 1133
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + ((difference_type)__n)); 
# 1135
} 
# 1138
void _M_initialize_value(bool __x) 
# 1139
{ 
# 1140
if (std::_Bit_type *__p = ((((this->_M_impl)._M_start)._M_p))) { 
# 1141
__builtin_memset(__p, __x ? ~0 : 0, ((this->_M_impl)._M_end_addr() - __p) * sizeof(std::_Bit_type)); }  
# 1144
} 
# 1147
void _M_reallocate(size_type __n); 
# 1151
bool _M_shrink_to_fit(); 
# 1158
template< class _Integer> void 
# 1160
_M_initialize_dispatch(_Integer __n, _Integer __x, std::__true_type) 
# 1161
{ 
# 1162
_M_initialize(static_cast< size_type>(__n)); 
# 1163
_M_initialize_value(__x); 
# 1164
} 
# 1166
template< class _InputIterator> void 
# 1168
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type) 
# 1170
{ _M_initialize_range(__first, __last, std::__iterator_category(__first)); 
# 1171
} 
# 1173
template< class _InputIterator> void 
# 1175
_M_initialize_range(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) 
# 1177
{ 
# 1178
for (; __first != __last; ++__first) { 
# 1179
push_back(*__first); }  
# 1180
} 
# 1182
template< class _ForwardIterator> void 
# 1184
_M_initialize_range(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) 
# 1186
{ 
# 1187
const size_type __n = std::distance(__first, __last); 
# 1188
_M_initialize(__n); 
# 1189
std::copy(__first, __last, ((this->_M_impl)._M_start)); 
# 1190
} 
# 1208 "/usr/include/c++/9/bits/stl_bvector.h" 3
void _M_fill_assign(std::size_t __n, bool __x) 
# 1209
{ 
# 1210
if (__n > size()) 
# 1211
{ 
# 1212
_M_initialize_value(__x); 
# 1213
insert(end(), __n - size(), __x); 
# 1214
} else 
# 1216
{ 
# 1217
_M_erase_at_end(((begin()) + __n)); 
# 1218
_M_initialize_value(__x); 
# 1219
}  
# 1220
} 
# 1222
template< class _InputIterator> void 
# 1224
_M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) 
# 1226
{ 
# 1227
iterator __cur = begin(); 
# 1228
for (; (__first != __last) && (__cur != (end())); (++__cur), ((void)(++__first))) { 
# 1229
(*__cur) = (*__first); }  
# 1230
if (__first == __last) { 
# 1231
_M_erase_at_end(__cur); } else { 
# 1233
insert(end(), __first, __last); }  
# 1234
} 
# 1236
template< class _ForwardIterator> void 
# 1238
_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) 
# 1240
{ 
# 1241
const size_type __len = std::distance(__first, __last); 
# 1242
if (__len < size()) { 
# 1243
_M_erase_at_end(std::copy(__first, __last, begin())); } else 
# 1245
{ 
# 1246
_ForwardIterator __mid = __first; 
# 1247
std::advance(__mid, size()); 
# 1248
std::copy(__first, __mid, begin()); 
# 1249
insert(end(), __mid, __last); 
# 1250
}  
# 1251
} 
# 1257
template< class _Integer> void 
# 1259
_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, std::__true_type) 
# 1261
{ _M_fill_insert(__pos, __n, __x); } 
# 1263
template< class _InputIterator> void 
# 1265
_M_insert_dispatch(iterator __pos, _InputIterator 
# 1266
__first, _InputIterator __last, std::__false_type) 
# 1268
{ _M_insert_range(__pos, __first, __last, std::__iterator_category(__first)); 
# 1269
} 
# 1272
void _M_fill_insert(iterator __position, size_type __n, bool __x); 
# 1274
template< class _InputIterator> void 
# 1276
_M_insert_range(iterator __pos, _InputIterator __first, _InputIterator 
# 1277
__last, std::input_iterator_tag) 
# 1278
{ 
# 1279
for (; __first != __last; ++__first) 
# 1280
{ 
# 1281
__pos = insert(__pos, *__first); 
# 1282
(++__pos); 
# 1283
}  
# 1284
} 
# 1286
template< class _ForwardIterator> void _M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag); 
# 1292
void _M_insert_aux(iterator __position, bool __x); 
# 1295
size_type _M_check_len(size_type __n, const char *__s) const 
# 1296
{ 
# 1297
if ((max_size() - size()) < __n) { 
# 1298
__throw_length_error(__s); }  
# 1300
const size_type __len = size() + std::max(size(), __n); 
# 1301
return ((__len < size()) || (__len > max_size())) ? max_size() : __len; 
# 1302
} 
# 1305
void _M_erase_at_end(iterator __pos) 
# 1306
{ ((this->_M_impl)._M_finish) = __pos; } 
# 1309
iterator _M_erase(iterator __pos); 
# 1312
iterator _M_erase(iterator __first, iterator __last); 
# 1313
}; 
# 1317
}
# 1321
namespace std __attribute((__visibility__("default"))) { 
# 1327
template< class _Alloc> 
# 1328
struct hash< vector< bool, _Alloc> >  : public __hash_base< unsigned long, vector< bool, _Alloc> >  { 
# 1332
std::size_t operator()(const vector< bool, _Alloc>  &) const noexcept; 
# 1333
}; 
# 1336
}
# 59 "/usr/include/c++/9/bits/vector.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 64
template< class _Tp, class _Alloc> void 
# 67
vector< _Tp, _Alloc> ::reserve(size_type __n) 
# 68
{ 
# 69
if (__n > max_size()) { 
# 70
__throw_length_error("vector::reserve"); }  
# 71
if (capacity() < __n) 
# 72
{ 
# 73
const size_type __old_size = size(); 
# 74
pointer __tmp; 
# 76
if ((_S_use_relocate)()) 
# 77
{ 
# 78
__tmp = this->_M_allocate(__n); 
# 79
(_S_relocate)(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), __tmp, _M_get_Tp_allocator()); 
# 81
} else 
# 84
{ 
# 85
__tmp = _M_allocate_and_copy(__n, std::__make_move_if_noexcept_iterator(((this->_M_impl)._M_start)), std::__make_move_if_noexcept_iterator(((this->_M_impl)._M_finish))); 
# 88
std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 90
}  
# 91
; 
# 92
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 95
((this->_M_impl)._M_start) = __tmp; 
# 96
((this->_M_impl)._M_finish) = (__tmp + __old_size); 
# 97
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __n); 
# 98
}  
# 99
} 
# 102
template< class _Tp, class _Alloc> 
# 103
template< class ..._Args> void 
# 110
vector< _Tp, _Alloc> ::emplace_back(_Args &&...__args) 
# 111
{ 
# 112
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) 
# 113
{ 
# 114
; 
# 115
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), std::forward< _Args> (__args)...); 
# 117
++((this->_M_impl)._M_finish); 
# 118
; 
# 119
} else { 
# 121
_M_realloc_insert(end(), std::forward< _Args> (__args)...); }  
# 125
} 
# 128
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 132
vector< _Tp, _Alloc> ::insert(const_iterator __position, const value_type &__x) 
# 136
{ 
# 137
const size_type __n = __position - begin(); 
# 138
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) { 
# 139
if (__position == end()) 
# 140
{ 
# 141
; 
# 142
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), __x); 
# 144
++((this->_M_impl)._M_finish); 
# 145
; 
# 146
} else 
# 148
{ 
# 150
const auto __pos = begin() + (__position - cbegin()); 
# 153
_Temporary_value __x_copy(this, __x); 
# 154
_M_insert_aux(__pos, std::move(__x_copy._M_val())); 
# 158
}  } else { 
# 161
_M_realloc_insert(begin() + (__position - cbegin()), __x); }  
# 166
return ((__gnu_cxx::__normal_iterator< pointer, vector> )(((this->_M_impl)._M_start) + __n)); 
# 167
} 
# 169
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 172
vector< _Tp, _Alloc> ::_M_erase(iterator __position) 
# 173
{ 
# 174
if ((__position + 1) != end()) { 
# 175
std::move(__position + 1, end(), __position); }  
# 176
--((this->_M_impl)._M_finish); 
# 177
_Alloc_traits::destroy((this->_M_impl), ((this->_M_impl)._M_finish)); 
# 178
; 
# 179
return __position; 
# 180
} 
# 182
template< class _Tp, class _Alloc> typename vector< _Tp, _Alloc> ::iterator 
# 185
vector< _Tp, _Alloc> ::_M_erase(iterator __first, iterator __last) 
# 186
{ 
# 187
if (__first != __last) 
# 188
{ 
# 189
if (__last != end()) { 
# 190
std::move(__last, end(), __first); }  
# 191
_M_erase_at_end(__first.base() + (end() - __last)); 
# 192
}  
# 193
return __first; 
# 194
} 
# 196
template< class _Tp, class _Alloc> vector< _Tp, _Alloc>  &
# 199
vector< _Tp, _Alloc> ::operator=(const vector &__x) 
# 200
{ 
# 201
if ((&__x) != this) 
# 202
{ 
# 203
; 
# 205
if (_Alloc_traits::_S_propagate_on_copy_assign()) 
# 206
{ 
# 207
if ((!_Alloc_traits::_S_always_equal()) && (_M_get_Tp_allocator() != __x._M_get_Tp_allocator())) 
# 209
{ 
# 211
clear(); 
# 212
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 215
((this->_M_impl)._M_start) = nullptr; 
# 216
((this->_M_impl)._M_finish) = nullptr; 
# 217
((this->_M_impl)._M_end_of_storage) = nullptr; 
# 218
}  
# 219
std::__alloc_on_copy(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()); 
# 221
}  
# 223
const size_type __xlen = __x.size(); 
# 224
if (__xlen > capacity()) 
# 225
{ 
# 226
pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); 
# 228
std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 230
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 233
((this->_M_impl)._M_start) = __tmp; 
# 234
((this->_M_impl)._M_end_of_storage) = (((this->_M_impl)._M_start) + __xlen); 
# 235
} else { 
# 236
if (size() >= __xlen) 
# 237
{ 
# 238
std::_Destroy(std::copy(__x.begin(), __x.end(), begin()), end(), _M_get_Tp_allocator()); 
# 240
} else 
# 242
{ 
# 243
std::copy(((__x._M_impl)._M_start), ((__x._M_impl)._M_start) + size(), ((this->_M_impl)._M_start)); 
# 245
std::__uninitialized_copy_a(((__x._M_impl)._M_start) + size(), ((__x._M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 249
}  }  
# 250
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + __xlen); 
# 251
}  
# 252
return *this; 
# 253
} 
# 255
template< class _Tp, class _Alloc> void 
# 258
vector< _Tp, _Alloc> ::_M_fill_assign(std::size_t __n, const value_type &__val) 
# 259
{ 
# 260
if (__n > capacity()) 
# 261
{ 
# 262
vector __tmp(__n, __val, _M_get_Tp_allocator()); 
# 263
(__tmp._M_impl)._M_swap_data((this->_M_impl)); 
# 264
} else { 
# 265
if (__n > size()) 
# 266
{ 
# 267
std::fill(begin(), end(), __val); 
# 268
const size_type __add = __n - size(); 
# 269
; 
# 270
((this->_M_impl)._M_finish) = std::__uninitialized_fill_n_a(((this->_M_impl)._M_finish), __add, __val, _M_get_Tp_allocator()); 
# 273
; 
# 274
} else { 
# 276
_M_erase_at_end(std::fill_n(((this->_M_impl)._M_start), __n, __val)); }  }  
# 277
} 
# 279
template< class _Tp, class _Alloc> 
# 280
template< class _InputIterator> void 
# 283
vector< _Tp, _Alloc> ::_M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) 
# 285
{ 
# 286
pointer __cur(((this->_M_impl)._M_start)); 
# 287
for (; (__first != __last) && (__cur != ((this->_M_impl)._M_finish)); (++__cur), ((void)(++__first))) { 
# 289
(*__cur) = (*__first); }  
# 290
if (__first == __last) { 
# 291
_M_erase_at_end(__cur); } else { 
# 293
_M_range_insert(end(), __first, __last, std::__iterator_category(__first)); }  
# 295
} 
# 297
template< class _Tp, class _Alloc> 
# 298
template< class _ForwardIterator> void 
# 301
vector< _Tp, _Alloc> ::_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) 
# 303
{ 
# 304
const size_type __len = std::distance(__first, __last); 
# 306
if (__len > capacity()) 
# 307
{ 
# 308
(_S_check_init_len)(__len, _M_get_Tp_allocator()); 
# 309
pointer __tmp(_M_allocate_and_copy(__len, __first, __last)); 
# 310
std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 312
; 
# 313
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 316
((this->_M_impl)._M_start) = __tmp; 
# 317
((this->_M_impl)._M_finish) = (((this->_M_impl)._M_start) + __len); 
# 318
((this->_M_impl)._M_end_of_storage) = ((this->_M_impl)._M_finish); 
# 319
} else { 
# 320
if (size() >= __len) { 
# 321
_M_erase_at_end(std::copy(__first, __last, ((this->_M_impl)._M_start))); } else 
# 323
{ 
# 324
_ForwardIterator __mid = __first; 
# 325
std::advance(__mid, size()); 
# 326
std::copy(__first, __mid, ((this->_M_impl)._M_start)); 
# 327
__attribute((__unused__)) const size_type __n = __len - size(); 
# 328
; 
# 329
((this->_M_impl)._M_finish) = std::__uninitialized_copy_a(__mid, __last, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 333
; 
# 334
}  }  
# 335
} 
# 338
template< class _Tp, class _Alloc> auto 
# 341
vector< _Tp, _Alloc> ::_M_insert_rval(const_iterator __position, value_type &&__v)->iterator 
# 342
{ 
# 343
const auto __n = __position - cbegin(); 
# 344
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) { 
# 345
if (__position == cend()) 
# 346
{ 
# 347
; 
# 348
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), std::move(__v)); 
# 350
++((this->_M_impl)._M_finish); 
# 351
; 
# 352
} else { 
# 354
_M_insert_aux(begin() + __n, std::move(__v)); }  } else { 
# 356
_M_realloc_insert(begin() + __n, std::move(__v)); }  
# 358
return ((__gnu_cxx::__normal_iterator< pointer, vector> )(((this->_M_impl)._M_start) + __n)); 
# 359
} 
# 361
template< class _Tp, class _Alloc> 
# 362
template< class ..._Args> auto 
# 365
vector< _Tp, _Alloc> ::_M_emplace_aux(const_iterator __position, _Args &&...__args)->iterator 
# 367
{ 
# 368
const auto __n = __position - cbegin(); 
# 369
if (((this->_M_impl)._M_finish) != ((this->_M_impl)._M_end_of_storage)) { 
# 370
if (__position == cend()) 
# 371
{ 
# 372
; 
# 373
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), std::forward< _Args> (__args)...); 
# 375
++((this->_M_impl)._M_finish); 
# 376
; 
# 377
} else 
# 379
{ 
# 383
_Temporary_value __tmp(this, std::forward< _Args> (__args)...); 
# 384
_M_insert_aux(begin() + __n, std::move(__tmp._M_val())); 
# 385
}  } else { 
# 387
_M_realloc_insert(begin() + __n, std::forward< _Args> (__args)...); }  
# 389
return ((__gnu_cxx::__normal_iterator< pointer, vector> )(((this->_M_impl)._M_start) + __n)); 
# 390
} 
# 392
template< class _Tp, class _Alloc> 
# 393
template< class _Arg> void 
# 396
vector< _Tp, _Alloc> ::_M_insert_aux(iterator __position, _Arg &&__arg) 
# 403
{ 
# 404
; 
# 405
_Alloc_traits::construct((this->_M_impl), ((this->_M_impl)._M_finish), std::move(*(((this->_M_impl)._M_finish) - 1))); 
# 407
++((this->_M_impl)._M_finish); 
# 408
; 
# 412
std::move_backward(__position.base(), ((this->_M_impl)._M_finish) - 2, ((this->_M_impl)._M_finish) - 1); 
# 418
(*__position) = std::forward< _Arg> (__arg); 
# 420
} 
# 423
template< class _Tp, class _Alloc> 
# 424
template< class ..._Args> void 
# 427
vector< _Tp, _Alloc> ::_M_realloc_insert(iterator __position, _Args &&...__args) 
# 434
{ 
# 435
const size_type __len = _M_check_len((size_type)1, "vector::_M_realloc_insert"); 
# 437
pointer __old_start = (((this->_M_impl)._M_start)); 
# 438
pointer __old_finish = (((this->_M_impl)._M_finish)); 
# 439
const size_type __elems_before = __position - begin(); 
# 440
pointer __new_start(this->_M_allocate(__len)); 
# 441
pointer __new_finish(__new_start); 
# 442
try 
# 443
{ 
# 449
_Alloc_traits::construct((this->_M_impl), __new_start + __elems_before, std::forward< _Args> (__args)...); 
# 456
__new_finish = pointer(); 
# 459
if ((_S_use_relocate)()) 
# 460
{ 
# 461
__new_finish = (_S_relocate)(__old_start, __position.base(), __new_start, _M_get_Tp_allocator()); 
# 464
++__new_finish; 
# 466
__new_finish = (_S_relocate)(__position.base(), __old_finish, __new_finish, _M_get_Tp_allocator()); 
# 468
} else 
# 471
{ 
# 472
__new_finish = std::__uninitialized_move_if_noexcept_a(__old_start, __position.base(), __new_start, _M_get_Tp_allocator()); 
# 477
++__new_finish; 
# 479
__new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), __old_finish, __new_finish, _M_get_Tp_allocator()); 
# 483
}  
# 484
} 
# 485
catch (...) 
# 486
{ 
# 487
if (!__new_finish) { 
# 488
_Alloc_traits::destroy((this->_M_impl), __new_start + __elems_before); } else { 
# 491
std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); }  
# 492
_M_deallocate(__new_start, __len); 
# 493
throw; 
# 494
}  
# 496
if (!(_S_use_relocate)()) { 
# 498
std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator()); }  
# 499
; 
# 500
_M_deallocate(__old_start, ((this->_M_impl)._M_end_of_storage) - __old_start); 
# 502
((this->_M_impl)._M_start) = __new_start; 
# 503
((this->_M_impl)._M_finish) = __new_finish; 
# 504
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 505
} 
# 507
template< class _Tp, class _Alloc> void 
# 510
vector< _Tp, _Alloc> ::_M_fill_insert(iterator __position, size_type __n, const value_type &__x) 
# 511
{ 
# 512
if (__n != (0)) 
# 513
{ 
# 514
if (((size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_finish))) >= __n) 
# 516
{ 
# 520
_Temporary_value __tmp(this, __x); 
# 521
value_type &__x_copy = __tmp._M_val(); 
# 523
const size_type __elems_after = end() - __position; 
# 524
pointer __old_finish(((this->_M_impl)._M_finish)); 
# 525
if (__elems_after > __n) 
# 526
{ 
# 527
; 
# 528
std::__uninitialized_move_a(((this->_M_impl)._M_finish) - __n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 532
((this->_M_impl)._M_finish) += __n; 
# 533
; 
# 534
std::move_backward(__position.base(), __old_finish - __n, __old_finish); 
# 536
std::fill(__position.base(), __position.base() + __n, __x_copy); 
# 538
} else 
# 540
{ 
# 541
; 
# 542
((this->_M_impl)._M_finish) = std::__uninitialized_fill_n_a(((this->_M_impl)._M_finish), __n - __elems_after, __x_copy, _M_get_Tp_allocator()); 
# 547
; 
# 548
std::__uninitialized_move_a(__position.base(), __old_finish, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 551
((this->_M_impl)._M_finish) += __elems_after; 
# 552
; 
# 553
std::fill(__position.base(), __old_finish, __x_copy); 
# 554
}  
# 555
} else 
# 557
{ 
# 558
const size_type __len = _M_check_len(__n, "vector::_M_fill_insert"); 
# 560
const size_type __elems_before = __position - begin(); 
# 561
pointer __new_start(this->_M_allocate(__len)); 
# 562
pointer __new_finish(__new_start); 
# 563
try 
# 564
{ 
# 566
std::__uninitialized_fill_n_a(__new_start + __elems_before, __n, __x, _M_get_Tp_allocator()); 
# 569
__new_finish = pointer(); 
# 571
__new_finish = std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), __position.base(), __new_start, _M_get_Tp_allocator()); 
# 576
__new_finish += __n; 
# 578
__new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), ((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 582
} 
# 583
catch (...) 
# 584
{ 
# 585
if (!__new_finish) { 
# 586
std::_Destroy(__new_start + __elems_before, (__new_start + __elems_before) + __n, _M_get_Tp_allocator()); } else { 
# 590
std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); }  
# 592
_M_deallocate(__new_start, __len); 
# 593
throw; 
# 594
}  
# 595
std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 597
; 
# 598
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 601
((this->_M_impl)._M_start) = __new_start; 
# 602
((this->_M_impl)._M_finish) = __new_finish; 
# 603
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 604
}  
# 605
}  
# 606
} 
# 609
template< class _Tp, class _Alloc> void 
# 612
vector< _Tp, _Alloc> ::_M_default_append(size_type __n) 
# 613
{ 
# 614
if (__n != (0)) 
# 615
{ 
# 616
const size_type __size = size(); 
# 617
size_type __navail = (size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_finish)); 
# 620
if ((__size > max_size()) || (__navail > (max_size() - __size))) { 
# 621
__builtin_unreachable(); }  
# 623
if (__navail >= __n) 
# 624
{ 
# 625
; 
# 626
((this->_M_impl)._M_finish) = std::__uninitialized_default_n_a(((this->_M_impl)._M_finish), __n, _M_get_Tp_allocator()); 
# 629
; 
# 630
} else 
# 632
{ 
# 633
const size_type __len = _M_check_len(__n, "vector::_M_default_append"); 
# 635
pointer __new_start(this->_M_allocate(__len)); 
# 636
if ((_S_use_relocate)()) 
# 637
{ 
# 638
try 
# 639
{ 
# 640
std::__uninitialized_default_n_a(__new_start + __size, __n, _M_get_Tp_allocator()); 
# 642
} 
# 643
catch (...) 
# 644
{ 
# 645
_M_deallocate(__new_start, __len); 
# 646
throw; 
# 647
}  
# 648
(_S_relocate)(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), __new_start, _M_get_Tp_allocator()); 
# 650
} else 
# 652
{ 
# 653
pointer __destroy_from = pointer(); 
# 654
try 
# 655
{ 
# 656
std::__uninitialized_default_n_a(__new_start + __size, __n, _M_get_Tp_allocator()); 
# 658
__destroy_from = (__new_start + __size); 
# 659
std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), __new_start, _M_get_Tp_allocator()); 
# 662
} 
# 663
catch (...) 
# 664
{ 
# 665
if (__destroy_from) { 
# 666
std::_Destroy(__destroy_from, __destroy_from + __n, _M_get_Tp_allocator()); }  
# 668
_M_deallocate(__new_start, __len); 
# 669
throw; 
# 670
}  
# 671
std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 673
}  
# 674
; 
# 675
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 678
((this->_M_impl)._M_start) = __new_start; 
# 679
((this->_M_impl)._M_finish) = ((__new_start + __size) + __n); 
# 680
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 681
}  
# 682
}  
# 683
} 
# 685
template< class _Tp, class _Alloc> bool 
# 688
vector< _Tp, _Alloc> ::_M_shrink_to_fit() 
# 689
{ 
# 690
if (capacity() == size()) { 
# 691
return false; }  
# 692
; 
# 693
return std::template __shrink_to_fit_aux< vector> ::_S_do_it(*this); 
# 694
} 
# 697
template< class _Tp, class _Alloc> 
# 698
template< class _InputIterator> void 
# 701
vector< _Tp, _Alloc> ::_M_range_insert(iterator __pos, _InputIterator __first, _InputIterator 
# 702
__last, std::input_iterator_tag) 
# 703
{ 
# 704
if (__pos == end()) 
# 705
{ 
# 706
for (; __first != __last; ++__first) { 
# 707
insert(end(), *__first); }  
# 708
} else { 
# 709
if (__first != __last) 
# 710
{ 
# 711
vector __tmp(__first, __last, _M_get_Tp_allocator()); 
# 712
insert(__pos, std::make_move_iterator(__tmp.begin()), std::make_move_iterator(__tmp.end())); 
# 715
}  }  
# 716
} 
# 718
template< class _Tp, class _Alloc> 
# 719
template< class _ForwardIterator> void 
# 722
vector< _Tp, _Alloc> ::_M_range_insert(iterator __position, _ForwardIterator __first, _ForwardIterator 
# 723
__last, std::forward_iterator_tag) 
# 724
{ 
# 725
if (__first != __last) 
# 726
{ 
# 727
const size_type __n = std::distance(__first, __last); 
# 728
if (((size_type)(((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_finish))) >= __n) 
# 730
{ 
# 731
const size_type __elems_after = end() - __position; 
# 732
pointer __old_finish(((this->_M_impl)._M_finish)); 
# 733
if (__elems_after > __n) 
# 734
{ 
# 735
; 
# 736
std::__uninitialized_move_a(((this->_M_impl)._M_finish) - __n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 740
((this->_M_impl)._M_finish) += __n; 
# 741
; 
# 742
std::move_backward(__position.base(), __old_finish - __n, __old_finish); 
# 744
std::copy(__first, __last, __position); 
# 745
} else 
# 747
{ 
# 748
_ForwardIterator __mid = __first; 
# 749
std::advance(__mid, __elems_after); 
# 750
; 
# 751
std::__uninitialized_copy_a(__mid, __last, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 754
((this->_M_impl)._M_finish) += (__n - __elems_after); 
# 755
; 
# 756
std::__uninitialized_move_a(__position.base(), __old_finish, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 760
((this->_M_impl)._M_finish) += __elems_after; 
# 761
; 
# 762
std::copy(__first, __mid, __position); 
# 763
}  
# 764
} else 
# 766
{ 
# 767
const size_type __len = _M_check_len(__n, "vector::_M_range_insert"); 
# 769
pointer __new_start(this->_M_allocate(__len)); 
# 770
pointer __new_finish(__new_start); 
# 771
try 
# 772
{ 
# 773
__new_finish = std::__uninitialized_move_if_noexcept_a(((this->_M_impl)._M_start), __position.base(), __new_start, _M_get_Tp_allocator()); 
# 777
__new_finish = std::__uninitialized_copy_a(__first, __last, __new_finish, _M_get_Tp_allocator()); 
# 781
__new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), ((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 785
} 
# 786
catch (...) 
# 787
{ 
# 788
std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator()); 
# 790
_M_deallocate(__new_start, __len); 
# 791
throw; 
# 792
}  
# 793
std::_Destroy(((this->_M_impl)._M_start), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 795
; 
# 796
_M_deallocate(((this->_M_impl)._M_start), ((this->_M_impl)._M_end_of_storage) - ((this->_M_impl)._M_start)); 
# 799
((this->_M_impl)._M_start) = __new_start; 
# 800
((this->_M_impl)._M_finish) = __new_finish; 
# 801
((this->_M_impl)._M_end_of_storage) = (__new_start + __len); 
# 802
}  
# 803
}  
# 804
} 
# 808
template< class _Alloc> void 
# 811
vector< bool, _Alloc> ::_M_reallocate(size_type __n) 
# 812
{ 
# 813
_Bit_pointer __q = this->_M_allocate(__n); 
# 814
iterator __start(std::__addressof(*__q), 0); 
# 815
iterator __finish(_M_copy_aligned(begin(), end(), __start)); 
# 816
this->_M_deallocate(); 
# 817
((this->_M_impl)._M_start) = __start; 
# 818
((this->_M_impl)._M_finish) = __finish; 
# 819
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__n)); 
# 820
} 
# 822
template< class _Alloc> void 
# 825
vector< bool, _Alloc> ::_M_fill_insert(iterator __position, size_type __n, bool __x) 
# 826
{ 
# 827
if (__n == (0)) { 
# 828
return; }  
# 829
if ((capacity() - size()) >= __n) 
# 830
{ 
# 831
std::copy_backward(__position, end(), ((this->_M_impl)._M_finish) + ((difference_type)__n)); 
# 833
std::fill(__position, (__position + ((difference_type)__n)), __x); 
# 834
((this->_M_impl)._M_finish) += ((difference_type)__n); 
# 835
} else 
# 837
{ 
# 838
const size_type __len = _M_check_len(__n, "vector<bool>::_M_fill_insert"); 
# 840
_Bit_pointer __q = this->_M_allocate(__len); 
# 841
iterator __start(std::__addressof(*__q), 0); 
# 842
iterator __i = _M_copy_aligned(begin(), __position, __start); 
# 843
std::fill(__i, (__i + ((difference_type)__n)), __x); 
# 844
iterator __finish = std::copy(__position, end(), (__i + ((difference_type)__n))); 
# 846
this->_M_deallocate(); 
# 847
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 848
((this->_M_impl)._M_start) = __start; 
# 849
((this->_M_impl)._M_finish) = __finish; 
# 850
}  
# 851
} 
# 853
template< class _Alloc> 
# 854
template< class _ForwardIterator> void 
# 857
vector< bool, _Alloc> ::_M_insert_range(iterator __position, _ForwardIterator __first, _ForwardIterator 
# 858
__last, std::forward_iterator_tag) 
# 859
{ 
# 860
if (__first != __last) 
# 861
{ 
# 862
size_type __n = std::distance(__first, __last); 
# 863
if ((capacity() - size()) >= __n) 
# 864
{ 
# 865
std::copy_backward(__position, end(), ((this->_M_impl)._M_finish) + ((difference_type)__n)); 
# 868
std::copy(__first, __last, __position); 
# 869
((this->_M_impl)._M_finish) += ((difference_type)__n); 
# 870
} else 
# 872
{ 
# 873
const size_type __len = _M_check_len(__n, "vector<bool>::_M_insert_range"); 
# 875
_Bit_pointer __q = this->_M_allocate(__len); 
# 876
iterator __start(std::__addressof(*__q), 0); 
# 877
iterator __i = _M_copy_aligned(begin(), __position, __start); 
# 878
__i = std::copy(__first, __last, __i); 
# 879
iterator __finish = std::copy(__position, end(), __i); 
# 880
this->_M_deallocate(); 
# 881
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 882
((this->_M_impl)._M_start) = __start; 
# 883
((this->_M_impl)._M_finish) = __finish; 
# 884
}  
# 885
}  
# 886
} 
# 888
template< class _Alloc> void 
# 891
vector< bool, _Alloc> ::_M_insert_aux(iterator __position, bool __x) 
# 892
{ 
# 893
if ((((this->_M_impl)._M_finish)._M_p) != (this->_M_impl)._M_end_addr()) 
# 894
{ 
# 895
std::copy_backward(__position, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish) + 1); 
# 897
(((*__position)) = __x); 
# 898
++((this->_M_impl)._M_finish); 
# 899
} else 
# 901
{ 
# 902
const size_type __len = _M_check_len((size_type)1, "vector<bool>::_M_insert_aux"); 
# 904
_Bit_pointer __q = this->_M_allocate(__len); 
# 905
iterator __start(std::__addressof(*__q), 0); 
# 906
iterator __i = _M_copy_aligned(begin(), __position, __start); 
# 907
(((*(__i++))) = __x); 
# 908
iterator __finish = std::copy(__position, end(), __i); 
# 909
this->_M_deallocate(); 
# 910
((this->_M_impl)._M_end_of_storage) = (__q + _S_nword(__len)); 
# 911
((this->_M_impl)._M_start) = __start; 
# 912
((this->_M_impl)._M_finish) = __finish; 
# 913
}  
# 914
} 
# 916
template< class _Alloc> typename vector< bool, _Alloc> ::iterator 
# 919
vector< bool, _Alloc> ::_M_erase(iterator __position) 
# 920
{ 
# 921
if ((((__position + (1))) != (end()))) { 
# 922
std::copy((__position + (1)), end(), __position); }  
# 923
--((this->_M_impl)._M_finish); 
# 924
return __position; 
# 925
} 
# 927
template< class _Alloc> typename vector< bool, _Alloc> ::iterator 
# 930
vector< bool, _Alloc> ::_M_erase(iterator __first, iterator __last) 
# 931
{ 
# 932
if ((__first != __last)) { 
# 933
_M_erase_at_end(std::copy(__last, end(), __first)); }  
# 934
return __first; 
# 935
} 
# 938
template< class _Alloc> bool 
# 941
vector< bool, _Alloc> ::_M_shrink_to_fit() 
# 942
{ 
# 943
if ((capacity() - size()) < ((int)_S_word_bit)) { 
# 944
return false; }  
# 945
try 
# 946
{ 
# 947
_M_reallocate(size()); 
# 948
return true; 
# 949
} 
# 950
catch (...) 
# 951
{ return false; }  
# 952
} 
# 957
}
# 961
namespace std __attribute((__visibility__("default"))) { 
# 965
template< class _Alloc> size_t 
# 968
hash< vector< bool, _Alloc> > ::operator()(const vector< bool, _Alloc>  &__b) const noexcept 
# 969
{ 
# 970
std::size_t __hash = (0); 
# 971
using std::_S_word_bit;
# 972
using std::_Bit_type;
# 974
const std::size_t __words = __b.size() / _S_word_bit; 
# 975
if (__words) 
# 976
{ 
# 977
const std::size_t __clength = (__words * sizeof(std::_Bit_type)); 
# 978
__hash = std::_Hash_impl::hash((((__b._M_impl)._M_start)._M_p), __clength); 
# 979
}  
# 981
const std::size_t __extrabits = __b.size() % _S_word_bit; 
# 982
if (__extrabits) 
# 983
{ 
# 984
std::_Bit_type __hiword = (*(((__b._M_impl)._M_finish)._M_p)); 
# 985
__hiword &= (~((~(static_cast< std::_Bit_type>(0))) << __extrabits)); 
# 987
const std::size_t __clength = (((__extrabits + (8)) - (1)) / (8)); 
# 989
if (__words) { 
# 990
__hash = std::_Hash_impl::hash(&__hiword, __clength, __hash); } else { 
# 992
__hash = std::_Hash_impl::hash(&__hiword, __clength); }  
# 993
}  
# 995
return __hash; 
# 996
} 
# 999
}
# 60 "/usr/include/opencv4/opencv2/core/types.hpp" 3
namespace cv { 
# 74 "/usr/include/opencv4/opencv2/core/types.hpp" 3
template< class _Tp> class Complex { 
# 79
public: inline Complex(); 
# 80
inline Complex(_Tp _re, _Tp _im = 0); 
# 83
template< class T2> inline operator Complex< T2> () const; 
# 85
inline Complex conj() const; 
# 87
_Tp re, im; 
# 88
}; 
# 90
typedef Complex< float>  Complexf; 
# 91
typedef Complex< double>  Complexd; 
# 93
template< class _Tp> class DataType< Complex< _Tp> >  { 
# 96
public: typedef Complex< _Tp>  value_type; 
# 97
typedef value_type work_type; 
# 98
typedef _Tp channel_type; 
# 100
enum { generic_type, 
# 101
channels = 2, 
# 102
fmt = DataType< channel_type> ::fmt + (((2) - 1) << 8)
# 107
}; 
# 109
typedef Vec< channel_type, channels>  vec_type; 
# 110
}; 
# 112
namespace traits { 
# 113
template< class _Tp> 
# 114
struct Depth< Complex< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 115
template< class _Tp> 
# 116
struct Type< Complex< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((2 - 1) << 3)}; }; 
# 117
}
# 157 "/usr/include/opencv4/opencv2/core/types.hpp" 3
template< class _Tp> class Point_ { 
# 160
public: typedef _Tp value_type; 
# 163
inline Point_(); 
# 164
inline Point_(_Tp _x, _Tp _y); 
# 165
inline Point_(const Point_ & pt); 
# 166
inline Point_(Point_ && pt) noexcept; 
# 167
inline Point_(const Size_< _Tp>  & sz); 
# 168
inline Point_(const Vec< _Tp, 2>  & v); 
# 170
inline Point_ &operator=(const Point_ & pt); 
# 171
inline Point_ &operator=(Point_ && pt) noexcept; 
# 173
template< class _Tp2> inline operator Point_< _Tp2> () const; 
# 176
inline operator Vec< _Tp, 2> () const; 
# 179
inline _Tp dot(const Point_ & pt) const; 
# 181
inline double ddot(const Point_ & pt) const; 
# 183
inline double cross(const Point_ & pt) const; 
# 185
inline bool inside(const Rect_< _Tp>  & r) const; 
# 186
_Tp x; 
# 187
_Tp y; 
# 188
}; 
# 190
typedef Point_< int>  Point2i; 
# 191
typedef Point_< signed long>  Point2l; 
# 192
typedef Point_< float>  Point2f; 
# 193
typedef Point_< double>  Point2d; 
# 194
typedef Point2i Point; 
# 196
template< class _Tp> class DataType< Point_< _Tp> >  { 
# 199
public: typedef Point_< _Tp>  value_type; 
# 200
typedef Point_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 201
typedef _Tp channel_type; 
# 203
enum { generic_type, 
# 204
channels = 2, 
# 205
fmt = traits::template SafeFmt< channel_type> ::fmt + (((2) - 1) << 8)
# 210
}; 
# 212
typedef Vec< channel_type, channels>  vec_type; 
# 213
}; 
# 215
namespace traits { 
# 216
template< class _Tp> 
# 217
struct Depth< Point_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 218
template< class _Tp> 
# 219
struct Type< Point_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((2 - 1) << 3)}; }; 
# 220
}
# 239 "/usr/include/opencv4/opencv2/core/types.hpp" 3
template< class _Tp> class Point3_ { 
# 242
public: typedef _Tp value_type; 
# 245
inline Point3_(); 
# 246
inline Point3_(_Tp _x, _Tp _y, _Tp _z); 
# 247
inline Point3_(const Point3_ & pt); 
# 248
inline Point3_(Point3_ && pt) noexcept; 
# 249
inline explicit Point3_(const Point_< _Tp>  & pt); 
# 250
inline Point3_(const Vec< _Tp, 3>  & v); 
# 252
inline Point3_ &operator=(const Point3_ & pt); 
# 253
inline Point3_ &operator=(Point3_ && pt) noexcept; 
# 255
template< class _Tp2> inline operator Point3_< _Tp2> () const; 
# 257
inline operator Vec< _Tp, 3> () const; 
# 260
inline _Tp dot(const Point3_ & pt) const; 
# 262
inline double ddot(const Point3_ & pt) const; 
# 264
inline Point3_ cross(const Point3_ & pt) const; 
# 265
_Tp x; 
# 266
_Tp y; 
# 267
_Tp z; 
# 268
}; 
# 270
typedef Point3_< int>  Point3i; 
# 271
typedef Point3_< float>  Point3f; 
# 272
typedef Point3_< double>  Point3d; 
# 274
template< class _Tp> class DataType< Point3_< _Tp> >  { 
# 277
public: typedef Point3_< _Tp>  value_type; 
# 278
typedef Point3_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 279
typedef _Tp channel_type; 
# 281
enum { generic_type, 
# 282
channels = 3, 
# 283
fmt = traits::template SafeFmt< channel_type> ::fmt + (((3) - 1) << 8)
# 288
}; 
# 290
typedef Vec< channel_type, channels>  vec_type; 
# 291
}; 
# 293
namespace traits { 
# 294
template< class _Tp> 
# 295
struct Depth< Point3_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 296
template< class _Tp> 
# 297
struct Type< Point3_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((3 - 1) << 3)}; }; 
# 298
}
# 315 "/usr/include/opencv4/opencv2/core/types.hpp" 3
template< class _Tp> class Size_ { 
# 318
public: typedef _Tp value_type; 
# 321
inline Size_(); 
# 322
inline Size_(_Tp _width, _Tp _height); 
# 323
inline Size_(const Size_ & sz); 
# 324
inline Size_(Size_ && sz) noexcept; 
# 325
inline Size_(const Point_< _Tp>  & pt); 
# 327
inline Size_ &operator=(const Size_ & sz); 
# 328
inline Size_ &operator=(Size_ && sz) noexcept; 
# 330
inline _Tp area() const; 
# 332
inline double aspectRatio() const; 
# 334
inline bool empty() const; 
# 337
template< class _Tp2> inline operator Size_< _Tp2> () const; 
# 339
_Tp width; 
# 340
_Tp height; 
# 341
}; 
# 343
typedef Size_< int>  Size2i; 
# 344
typedef Size_< signed long>  Size2l; 
# 345
typedef Size_< float>  Size2f; 
# 346
typedef Size_< double>  Size2d; 
# 347
typedef Size2i Size; 
# 349
template< class _Tp> class DataType< Size_< _Tp> >  { 
# 352
public: typedef Size_< _Tp>  value_type; 
# 353
typedef Size_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 354
typedef _Tp channel_type; 
# 356
enum { generic_type, 
# 357
channels = 2, 
# 358
fmt = DataType< _Tp> ::fmt + (((2) - 1) << 8)
# 363
}; 
# 365
typedef Vec< channel_type, channels>  vec_type; 
# 366
}; 
# 368
namespace traits { 
# 369
template< class _Tp> 
# 370
struct Depth< Size_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 371
template< class _Tp> 
# 372
struct Type< Size_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((2 - 1) << 3)}; }; 
# 373
}
# 420 "/usr/include/opencv4/opencv2/core/types.hpp" 3
template< class _Tp> class Rect_ { 
# 423
public: typedef _Tp value_type; 
# 426
inline Rect_(); 
# 427
inline Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height); 
# 428
inline Rect_(const Rect_ & r); 
# 429
inline Rect_(Rect_ && r) noexcept; 
# 430
inline Rect_(const Point_< _Tp>  & org, const Size_< _Tp>  & sz); 
# 431
inline Rect_(const Point_< _Tp>  & pt1, const Point_< _Tp>  & pt2); 
# 433
inline Rect_ &operator=(const Rect_ & r); 
# 434
inline Rect_ &operator=(Rect_ && r) noexcept; 
# 436
inline Point_< _Tp>  tl() const; 
# 438
inline Point_< _Tp>  br() const; 
# 441
inline Size_< _Tp>  size() const; 
# 443
inline _Tp area() const; 
# 445
inline bool empty() const; 
# 448
template< class _Tp2> inline operator Rect_< _Tp2> () const; 
# 451
inline bool contains(const Point_< _Tp>  & pt) const; 
# 453
_Tp x; 
# 454
_Tp y; 
# 455
_Tp width; 
# 456
_Tp height; 
# 457
}; 
# 459
typedef Rect_< int>  Rect2i; 
# 460
typedef Rect_< float>  Rect2f; 
# 461
typedef Rect_< double>  Rect2d; 
# 462
typedef Rect2i Rect; 
# 464
template< class _Tp> class DataType< Rect_< _Tp> >  { 
# 467
public: typedef Rect_< _Tp>  value_type; 
# 468
typedef Rect_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 469
typedef _Tp channel_type; 
# 471
enum { generic_type, 
# 472
channels = 4, 
# 473
fmt = traits::template SafeFmt< channel_type> ::fmt + (((4) - 1) << 8)
# 478
}; 
# 480
typedef Vec< channel_type, channels>  vec_type; 
# 481
}; 
# 483
namespace traits { 
# 484
template< class _Tp> 
# 485
struct Depth< Rect_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 486
template< class _Tp> 
# 487
struct Type< Rect_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((4 - 1) << 3)}; }; 
# 488
}
# 503 "/usr/include/opencv4/opencv2/core/types.hpp" 3
class RotatedRect { 
# 507
public: inline RotatedRect(); 
# 514
inline RotatedRect(const Point2f & center, const Size2f & size, float angle); 
# 519
RotatedRect(const Point2f & point1, const Point2f & point2, const Point2f & point3); 
# 524
void points(Point2f  pts[]) const; 
# 526
Rect boundingRect() const; 
# 528
Rect_< float>  boundingRect2f() const; 
# 530
Point2f center; 
# 532
Size2f size; 
# 534
float angle; 
# 535
}; 
# 537
template<> class DataType< RotatedRect>  { 
# 540
public: typedef RotatedRect value_type; 
# 541
typedef value_type work_type; 
# 542
typedef float channel_type; 
# 544
enum { generic_type, 
# 545
channels = (((int)sizeof(value_type)) / sizeof(channel_type)), 
# 546
fmt = 1126
# 551
}; 
# 553
typedef Vec< float, 5>  vec_type; 
# 554
}; 
# 556
namespace traits { 
# 558
template<> struct Depth< RotatedRect>  { enum { value = 5}; }; 
# 560
template<> struct Type< RotatedRect>  { enum { value = 37}; }; 
# 561
}
# 589 "/usr/include/opencv4/opencv2/core/types.hpp" 3
class Range { 
# 592
public: inline Range(); 
# 593
inline Range(int _start, int _end); 
# 594
inline int size() const; 
# 595
inline bool empty() const; 
# 596
static inline Range all(); 
# 598
int start, end; 
# 599
}; 
# 601
template<> class DataType< Range>  { 
# 604
public: typedef Range value_type; 
# 605
typedef value_type work_type; 
# 606
typedef int channel_type; 
# 608
enum { generic_type, 
# 609
channels = 2, 
# 610
fmt = 361
# 615
}; 
# 617
typedef Vec< int, 2>  vec_type; 
# 618
}; 
# 620
namespace traits { 
# 622
template<> struct Depth< Range>  { enum { value = 4}; }; 
# 624
template<> struct Type< Range>  { enum { value = 12}; }; 
# 625
}
# 636 "/usr/include/opencv4/opencv2/core/types.hpp" 3
template< class _Tp> class Scalar_ : public Vec< _Tp, 4>  { 
# 640
public: inline Scalar_(); 
# 641
inline Scalar_(_Tp v0, _Tp v1, _Tp v2 = 0, _Tp v3 = 0); 
# 642
inline Scalar_(_Tp v0); 
# 644
inline Scalar_(const Scalar_ & s); 
# 645
inline Scalar_(Scalar_ && s) noexcept; 
# 647
inline Scalar_ &operator=(const Scalar_ & s); 
# 648
inline Scalar_ &operator=(Scalar_ && s) noexcept; 
# 650
template< class _Tp2, int cn> inline Scalar_(const Vec< _Tp2, cn>  & v); 
# 654
static inline Scalar_ all(_Tp v0); 
# 657
template< class T2> inline operator Scalar_< T2> () const; 
# 660
inline Scalar_ mul(const Scalar_ & a, double scale = 1) const; 
# 663
inline Scalar_ conj() const; 
# 666
inline bool isReal() const; 
# 667
}; 
# 669
typedef Scalar_< double>  Scalar; 
# 671
template< class _Tp> class DataType< Scalar_< _Tp> >  { 
# 674
public: typedef Scalar_< _Tp>  value_type; 
# 675
typedef Scalar_< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 676
typedef _Tp channel_type; 
# 678
enum { generic_type, 
# 679
channels = 4, 
# 680
fmt = traits::template SafeFmt< channel_type> ::fmt + (((4) - 1) << 8)
# 685
}; 
# 687
typedef Vec< channel_type, channels>  vec_type; 
# 688
}; 
# 690
namespace traits { 
# 691
template< class _Tp> 
# 692
struct Depth< Scalar_< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 693
template< class _Tp> 
# 694
struct Type< Scalar_< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((4 - 1) << 3)}; }; 
# 695
}
# 711 "/usr/include/opencv4/opencv2/core/types.hpp" 3
class KeyPoint { 
# 715
public: inline KeyPoint(); 
# 724 "/usr/include/opencv4/opencv2/core/types.hpp" 3
inline KeyPoint(Point2f _pt, float _size, float _angle = -1, float _response = 0, int _octave = 0, int _class_id = -1); 
# 734 "/usr/include/opencv4/opencv2/core/types.hpp" 3
inline KeyPoint(float x, float y, float _size, float _angle = -1, float _response = 0, int _octave = 0, int _class_id = -1); 
# 736
size_t hash() const; 
# 747 "/usr/include/opencv4/opencv2/core/types.hpp" 3
static void convert(const std::vector< KeyPoint>  & keypoints, std::vector< Point_< float> >  & points2f, const std::vector< int>  & keypointIndexes = std::vector< int> ()); 
# 758 "/usr/include/opencv4/opencv2/core/types.hpp" 3
static void convert(const std::vector< Point_< float> >  & points2f, std::vector< KeyPoint>  & keypoints, float size = 1, float response = 1, int octave = 0, int class_id = -1); 
# 769 "/usr/include/opencv4/opencv2/core/types.hpp" 3
static float overlap(const KeyPoint & kp1, const KeyPoint & kp2); 
# 771
Point2f pt; 
# 772
float size; 
# 773
float angle; 
# 776
float response; 
# 777
int octave; 
# 778
int class_id; 
# 779
}; 
# 808 "/usr/include/opencv4/opencv2/core/types.hpp" 3
class DMatch { 
# 811
public: inline DMatch(); 
# 812
inline DMatch(int _queryIdx, int _trainIdx, float _distance); 
# 813
inline DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance); 
# 815
int queryIdx; 
# 816
int trainIdx; 
# 817
int imgIdx; 
# 819
float distance; 
# 822
inline bool operator<(const DMatch & m) const; 
# 823
}; 
# 852 "/usr/include/opencv4/opencv2/core/types.hpp" 3
class TermCriteria { 
# 858
public: enum Type { 
# 860
COUNT = 1, 
# 861
MAX_ITER = COUNT, 
# 862
EPS
# 863
}; 
# 866
inline TermCriteria(); 
# 872
inline TermCriteria(int type, int maxCount, double epsilon); 
# 874
bool isValid() const 
# 875
{ 
# 876
const bool isCount = ((type) & (COUNT)) && ((maxCount) > 0); 
# 877
const bool isEps = ((type) & (EPS)) && (!(cvIsNaN(epsilon))); 
# 878
return isCount || isEps; 
# 879
} 
# 881
int type; 
# 882
int maxCount; 
# 883
double epsilon; 
# 884
}; 
# 926 "/usr/include/opencv4/opencv2/core/types.hpp" 3
class Moments { 
# 930
public: Moments(); 
# 932
Moments(double m00, double m10, double m01, double m20, double m11, double m02, double m30, double m21, double m12, double m03); 
# 941
double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03; 
# 946
double mu20, mu11, mu02, mu30, mu21, mu12, mu03; 
# 951
double nu20, nu11, nu02, nu30, nu21, nu12, nu03; 
# 953
}; 
# 955
template<> class DataType< Moments>  { 
# 958
public: typedef Moments value_type; 
# 959
typedef double work_type; 
# 960
typedef double channel_type; 
# 962
enum { generic_type, 
# 963
channels = ((int)(sizeof(value_type) / sizeof(channel_type))), 
# 964
fmt = ((DataType< double> ::fmt) + ((channels - 1) << 8))
# 969
}; 
# 971
typedef Vec< double, 24>  vec_type; 
# 972
}; 
# 974
namespace traits { 
# 976
template<> struct Depth< Moments>  { enum { value = 6}; }; 
# 978
template<> struct Type< Moments>  { enum { value = 190}; }; 
# 979
}
# 991 "/usr/include/opencv4/opencv2/core/types.hpp" 3
template< class _Tp> inline 
# 992
Complex< _Tp> ::Complex() : re(0), im(0) 
# 993
{ } 
# 995
template< class _Tp> inline 
# 996
Complex< _Tp> ::Complex(_Tp _re, _Tp _im) : re(_re), im(_im) 
# 997
{ } 
# 999
template< class _Tp> template< class T2> inline 
# 1000
Complex< _Tp> ::operator Complex< T2> () const 
# 1001
{ 
# 1002
return Complex< T2> (saturate_cast< T2> (re), saturate_cast< T2> (im)); 
# 1003
} 
# 1005
template< class _Tp> inline Complex< _Tp>  
# 1006
Complex< _Tp> ::conj() const 
# 1007
{ 
# 1008
return Complex(re, -(im)); 
# 1009
} 
# 1012
template< class _Tp> static inline bool 
# 1013
operator==(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1014
{ 
# 1015
return ((a.re) == (b.re)) && ((a.im) == (b.im)); 
# 1016
} 
# 1018
template< class _Tp> static inline bool 
# 1019
operator!=(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1020
{ 
# 1021
return ((a.re) != (b.re)) || ((a.im) != (b.im)); 
# 1022
} 
# 1024
template< class _Tp> static inline Complex< _Tp>  
# 1025
operator+(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1026
{ 
# 1027
return Complex< _Tp> ((a.re) + (b.re), (a.im) + (b.im)); 
# 1028
} 
# 1030
template< class _Tp> static inline Complex< _Tp>  &
# 1031
operator+=(Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1032
{ 
# 1033
(a.re) += (b.re); (a.im) += (b.im); 
# 1034
return a; 
# 1035
} 
# 1037
template< class _Tp> static inline Complex< _Tp>  
# 1038
operator-(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1039
{ 
# 1040
return Complex< _Tp> ((a.re) - (b.re), (a.im) - (b.im)); 
# 1041
} 
# 1043
template< class _Tp> static inline Complex< _Tp>  &
# 1044
operator-=(Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1045
{ 
# 1046
(a.re) -= (b.re); (a.im) -= (b.im); 
# 1047
return a; 
# 1048
} 
# 1050
template< class _Tp> static inline Complex< _Tp>  
# 1051
operator-(const Complex< _Tp>  &a) 
# 1052
{ 
# 1053
return Complex< _Tp> (-(a.re), -(a.im)); 
# 1054
} 
# 1056
template< class _Tp> static inline Complex< _Tp>  
# 1057
operator*(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1058
{ 
# 1059
return Complex< _Tp> (((a.re) * (b.re)) - ((a.im) * (b.im)), ((a.re) * (b.im)) + ((a.im) * (b.re))); 
# 1060
} 
# 1062
template< class _Tp> static inline Complex< _Tp>  
# 1063
operator*(const Complex< _Tp>  &a, _Tp b) 
# 1064
{ 
# 1065
return Complex< _Tp> ((a.re) * b, (a.im) * b); 
# 1066
} 
# 1068
template< class _Tp> static inline Complex< _Tp>  
# 1069
operator*(_Tp b, const Complex< _Tp>  &a) 
# 1070
{ 
# 1071
return Complex< _Tp> ((a.re) * b, (a.im) * b); 
# 1072
} 
# 1074
template< class _Tp> static inline Complex< _Tp>  
# 1075
operator+(const Complex< _Tp>  &a, _Tp b) 
# 1076
{ 
# 1077
return Complex< _Tp> ((a.re) + b, (a.im)); 
# 1078
} 
# 1080
template< class _Tp> static inline Complex< _Tp>  
# 1081
operator-(const Complex< _Tp>  &a, _Tp b) 
# 1082
{ return Complex< _Tp> ((a.re) - b, (a.im)); } 
# 1084
template< class _Tp> static inline Complex< _Tp>  
# 1085
operator+(_Tp b, const Complex< _Tp>  &a) 
# 1086
{ 
# 1087
return Complex< _Tp> ((a.re) + b, (a.im)); 
# 1088
} 
# 1090
template< class _Tp> static inline Complex< _Tp>  
# 1091
operator-(_Tp b, const Complex< _Tp>  &a) 
# 1092
{ 
# 1093
return Complex< _Tp> (b - (a.re), -(a.im)); 
# 1094
} 
# 1096
template< class _Tp> static inline Complex< _Tp>  &
# 1097
operator+=(Complex< _Tp>  &a, _Tp b) 
# 1098
{ 
# 1099
(a.re) += b; return a; 
# 1100
} 
# 1102
template< class _Tp> static inline Complex< _Tp>  &
# 1103
operator-=(Complex< _Tp>  &a, _Tp b) 
# 1104
{ 
# 1105
(a.re) -= b; return a; 
# 1106
} 
# 1108
template< class _Tp> static inline Complex< _Tp>  &
# 1109
operator*=(Complex< _Tp>  &a, _Tp b) 
# 1110
{ 
# 1111
(a.re) *= b; (a.im) *= b; return a; 
# 1112
} 
# 1114
template< class _Tp> static inline double 
# 1115
abs(const Complex< _Tp>  &a) 
# 1116
{ 
# 1117
return std::sqrt((((double)(a.re)) * (a.re)) + (((double)(a.im)) * (a.im))); 
# 1118
} 
# 1120
template< class _Tp> static inline Complex< _Tp>  
# 1121
operator/(const Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1122
{ 
# 1123
double t = (1.0) / ((((double)(b.re)) * (b.re)) + (((double)(b.im)) * (b.im))); 
# 1124
return Complex< _Tp> ((_Tp)((((a.re) * (b.re)) + ((a.im) * (b.im))) * t), (_Tp)((((-(a.re)) * (b.im)) + ((a.im) * (b.re))) * t)); 
# 1126
} 
# 1128
template< class _Tp> static inline Complex< _Tp>  &
# 1129
operator/=(Complex< _Tp>  &a, const Complex< _Tp>  &b) 
# 1130
{ 
# 1131
a = (a / b); 
# 1132
return a; 
# 1133
} 
# 1135
template< class _Tp> static inline Complex< _Tp>  
# 1136
operator/(const Complex< _Tp>  &a, _Tp b) 
# 1137
{ 
# 1138
_Tp t = ((_Tp)1) / b; 
# 1139
return Complex< _Tp> ((a.re) * t, (a.im) * t); 
# 1140
} 
# 1142
template< class _Tp> static inline Complex< _Tp>  
# 1143
operator/(_Tp b, const Complex< _Tp>  &a) 
# 1144
{ 
# 1145
return ((Complex< _Tp> )(b)) / a; 
# 1146
} 
# 1148
template< class _Tp> static inline Complex< _Tp>  
# 1149
operator/=(const Complex< _Tp>  &a, _Tp b) 
# 1150
{ 
# 1151
_Tp t = ((_Tp)1) / b; 
# 1152
(a.re) *= t; (a.im) *= t; return a; 
# 1153
} 
# 1159
template< class _Tp> inline 
# 1160
Point_< _Tp> ::Point_() : x(0), y(0) 
# 1161
{ } 
# 1163
template< class _Tp> inline 
# 1164
Point_< _Tp> ::Point_(_Tp _x, _Tp _y) : x(_x), y(_y) 
# 1165
{ } 
# 1167
template< class _Tp> inline 
# 1168
Point_< _Tp> ::Point_(const Point_ &pt) : x(pt.x), y(pt.y) 
# 1169
{ } 
# 1171
template< class _Tp> inline 
# 1172
Point_< _Tp> ::Point_(Point_ &&pt) noexcept : x(std::move(pt.x)), y(std::move(pt.y)) 
# 1173
{ } 
# 1175
template< class _Tp> inline 
# 1176
Point_< _Tp> ::Point_(const Size_< _Tp>  &sz) : x((sz.width)), y((sz.height)) 
# 1177
{ } 
# 1179
template< class _Tp> inline 
# 1180
Point_< _Tp> ::Point_(const Vec< _Tp, 2>  &v) : x(v[0]), y(v[1]) 
# 1181
{ } 
# 1183
template< class _Tp> inline Point_< _Tp>  &
# 1184
Point_< _Tp> ::operator=(const Point_ &pt) 
# 1185
{ 
# 1186
(x) = (pt.x); (y) = (pt.y); 
# 1187
return *this; 
# 1188
} 
# 1190
template< class _Tp> inline Point_< _Tp>  &
# 1191
Point_< _Tp> ::operator=(Point_ &&pt) noexcept 
# 1192
{ 
# 1193
(x) = std::move(pt.x); (y) = std::move(pt.y); 
# 1194
return *this; 
# 1195
} 
# 1197
template< class _Tp> template< class _Tp2> inline 
# 1198
Point_< _Tp> ::operator Point_< _Tp2> () const 
# 1199
{ 
# 1200
return Point_< _Tp2> (saturate_cast< _Tp2> (x), saturate_cast< _Tp2> (y)); 
# 1201
} 
# 1203
template< class _Tp> inline 
# 1204
Point_< _Tp> ::operator Vec< _Tp, 2> () const 
# 1205
{ 
# 1206
return Vec< _Tp, 2> (x, y); 
# 1207
} 
# 1209
template< class _Tp> inline _Tp 
# 1210
Point_< _Tp> ::dot(const Point_ &pt) const 
# 1211
{ 
# 1212
return saturate_cast< _Tp> (((x) * (pt.x)) + ((y) * (pt.y))); 
# 1213
} 
# 1215
template< class _Tp> inline double 
# 1216
Point_< _Tp> ::ddot(const Point_ &pt) const 
# 1217
{ 
# 1218
return (((double)(x)) * (pt.x)) + (((double)(y)) * (pt.y)); 
# 1219
} 
# 1221
template< class _Tp> inline double 
# 1222
Point_< _Tp> ::cross(const Point_ &pt) const 
# 1223
{ 
# 1224
return (((double)(x)) * (pt.y)) - (((double)(y)) * (pt.x)); 
# 1225
} 
# 1227
template< class _Tp> inline bool 
# 1228
Point_< _Tp> ::inside(const Rect_< _Tp>  &r) const 
# 1229
{ 
# 1230
return r.contains(*this); 
# 1231
} 
# 1234
template< class _Tp> static inline Point_< _Tp>  &
# 1235
operator+=(Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1236
{ 
# 1237
(a.x) += (b.x); 
# 1238
(a.y) += (b.y); 
# 1239
return a; 
# 1240
} 
# 1242
template< class _Tp> static inline Point_< _Tp>  &
# 1243
operator-=(Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1244
{ 
# 1245
(a.x) -= (b.x); 
# 1246
(a.y) -= (b.y); 
# 1247
return a; 
# 1248
} 
# 1250
template< class _Tp> static inline Point_< _Tp>  &
# 1251
operator*=(Point_< _Tp>  &a, int b) 
# 1252
{ 
# 1253
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1254
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1255
return a; 
# 1256
} 
# 1258
template< class _Tp> static inline Point_< _Tp>  &
# 1259
operator*=(Point_< _Tp>  &a, float b) 
# 1260
{ 
# 1261
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1262
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1263
return a; 
# 1264
} 
# 1266
template< class _Tp> static inline Point_< _Tp>  &
# 1267
operator*=(Point_< _Tp>  &a, double b) 
# 1268
{ 
# 1269
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1270
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1271
return a; 
# 1272
} 
# 1274
template< class _Tp> static inline Point_< _Tp>  &
# 1275
operator/=(Point_< _Tp>  &a, int b) 
# 1276
{ 
# 1277
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1278
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1279
return a; 
# 1280
} 
# 1282
template< class _Tp> static inline Point_< _Tp>  &
# 1283
operator/=(Point_< _Tp>  &a, float b) 
# 1284
{ 
# 1285
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1286
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1287
return a; 
# 1288
} 
# 1290
template< class _Tp> static inline Point_< _Tp>  &
# 1291
operator/=(Point_< _Tp>  &a, double b) 
# 1292
{ 
# 1293
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1294
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1295
return a; 
# 1296
} 
# 1298
template< class _Tp> static inline double 
# 1299
norm(const Point_< _Tp>  &pt) 
# 1300
{ 
# 1301
return std::sqrt((((double)(pt.x)) * (pt.x)) + (((double)(pt.y)) * (pt.y))); 
# 1302
} 
# 1304
template< class _Tp> static inline bool 
# 1305
operator==(const Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1306
{ 
# 1307
return ((a.x) == (b.x)) && ((a.y) == (b.y)); 
# 1308
} 
# 1310
template< class _Tp> static inline bool 
# 1311
operator!=(const Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1312
{ 
# 1313
return ((a.x) != (b.x)) || ((a.y) != (b.y)); 
# 1314
} 
# 1316
template< class _Tp> static inline Point_< _Tp>  
# 1317
operator+(const Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1318
{ 
# 1319
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) + (b.x)), saturate_cast< _Tp> ((a.y) + (b.y))); 
# 1320
} 
# 1322
template< class _Tp> static inline Point_< _Tp>  
# 1323
operator-(const Point_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1324
{ 
# 1325
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) - (b.x)), saturate_cast< _Tp> ((a.y) - (b.y))); 
# 1326
} 
# 1328
template< class _Tp> static inline Point_< _Tp>  
# 1329
operator-(const Point_< _Tp>  &a) 
# 1330
{ 
# 1331
return Point_< _Tp> (saturate_cast< _Tp> (-(a.x)), saturate_cast< _Tp> (-(a.y))); 
# 1332
} 
# 1334
template< class _Tp> static inline Point_< _Tp>  
# 1335
operator*(const Point_< _Tp>  &a, int b) 
# 1336
{ 
# 1337
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b)); 
# 1338
} 
# 1340
template< class _Tp> static inline Point_< _Tp>  
# 1341
operator*(int a, const Point_< _Tp>  &b) 
# 1342
{ 
# 1343
return Point_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a)); 
# 1344
} 
# 1346
template< class _Tp> static inline Point_< _Tp>  
# 1347
operator*(const Point_< _Tp>  &a, float b) 
# 1348
{ 
# 1349
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b)); 
# 1350
} 
# 1352
template< class _Tp> static inline Point_< _Tp>  
# 1353
operator*(float a, const Point_< _Tp>  &b) 
# 1354
{ 
# 1355
return Point_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a)); 
# 1356
} 
# 1358
template< class _Tp> static inline Point_< _Tp>  
# 1359
operator*(const Point_< _Tp>  &a, double b) 
# 1360
{ 
# 1361
return Point_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b)); 
# 1362
} 
# 1364
template< class _Tp> static inline Point_< _Tp>  
# 1365
operator*(double a, const Point_< _Tp>  &b) 
# 1366
{ 
# 1367
return Point_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a)); 
# 1368
} 
# 1370
template< class _Tp> static inline Point_< _Tp>  
# 1371
operator*(const Matx< _Tp, 2, 2>  &a, const Point_< _Tp>  &b) 
# 1372
{ 
# 1373
Matx< _Tp, 2, 1>  tmp = a * Vec< _Tp, 2> ((b.x), (b.y)); 
# 1374
return Point_< _Tp> ((tmp.val)[0], (tmp.val)[1]); 
# 1375
} 
# 1377
template< class _Tp> static inline Point3_< _Tp>  
# 1378
operator*(const Matx< _Tp, 3, 3>  &a, const Point_< _Tp>  &b) 
# 1379
{ 
# 1380
Matx< _Tp, 3, 1>  tmp = a * Vec< _Tp, 3> ((b.x), (b.y), 1); 
# 1381
return Point3_< _Tp> ((tmp.val)[0], (tmp.val)[1], (tmp.val)[2]); 
# 1382
} 
# 1384
template< class _Tp> static inline Point_< _Tp>  
# 1385
operator/(const Point_< _Tp>  &a, int b) 
# 1386
{ 
# 1387
Point_< _Tp>  tmp(a); 
# 1388
tmp /= b; 
# 1389
return tmp; 
# 1390
} 
# 1392
template< class _Tp> static inline Point_< _Tp>  
# 1393
operator/(const Point_< _Tp>  &a, float b) 
# 1394
{ 
# 1395
Point_< _Tp>  tmp(a); 
# 1396
tmp /= b; 
# 1397
return tmp; 
# 1398
} 
# 1400
template< class _Tp> static inline Point_< _Tp>  
# 1401
operator/(const Point_< _Tp>  &a, double b) 
# 1402
{ 
# 1403
Point_< _Tp>  tmp(a); 
# 1404
tmp /= b; 
# 1405
return tmp; 
# 1406
} 
# 1409
template< class _AccTp> static inline _AccTp normL2Sqr(const Point_< int>  & pt); 
# 1410
template< class _AccTp> static inline _AccTp normL2Sqr(const Point_< signed long>  & pt); 
# 1411
template< class _AccTp> static inline _AccTp normL2Sqr(const Point_< float>  & pt); 
# 1412
template< class _AccTp> static inline _AccTp normL2Sqr(const Point_< double>  & pt); 
# 1414
template<> inline int normL2Sqr< int> (const Point_< int>  &pt) { return pt.dot(pt); } 
# 1415
template<> inline int64 normL2Sqr< signed long> (const Point_< signed long>  &pt) { return pt.dot(pt); } 
# 1416
template<> inline float normL2Sqr< float> (const Point_< float>  &pt) { return pt.dot(pt); } 
# 1417
template<> inline double normL2Sqr< double> (const Point_< int>  &pt) { return pt.dot(pt); } 
# 1419
template<> inline double normL2Sqr< double> (const Point_< float>  &pt) { return pt.ddot(pt); } 
# 1420
template<> inline double normL2Sqr< double> (const Point_< double>  &pt) { return pt.ddot(pt); } 
# 1426
template< class _Tp> inline 
# 1427
Point3_< _Tp> ::Point3_() : x(0), y(0), z(0) 
# 1428
{ } 
# 1430
template< class _Tp> inline 
# 1431
Point3_< _Tp> ::Point3_(_Tp _x, _Tp _y, _Tp _z) : x(_x), y(_y), z(_z) 
# 1432
{ } 
# 1434
template< class _Tp> inline 
# 1435
Point3_< _Tp> ::Point3_(const Point3_ &pt) : x(pt.x), y(pt.y), z(pt.z) 
# 1436
{ } 
# 1438
template< class _Tp> inline 
# 1439
Point3_< _Tp> ::Point3_(Point3_ &&pt) noexcept : x(std::move(pt.x)), y(std::move(pt.y)), z(std::move(pt.z)) 
# 1440
{ } 
# 1442
template< class _Tp> inline 
# 1443
Point3_< _Tp> ::Point3_(const Point_< _Tp>  &pt) : x((pt.x)), y((pt.y)), z(_Tp()) 
# 1444
{ } 
# 1446
template< class _Tp> inline 
# 1447
Point3_< _Tp> ::Point3_(const Vec< _Tp, 3>  &v) : x(v[0]), y(v[1]), z(v[2]) 
# 1448
{ } 
# 1450
template< class _Tp> template< class _Tp2> inline 
# 1451
Point3_< _Tp> ::operator Point3_< _Tp2> () const 
# 1452
{ 
# 1453
return Point3_< _Tp2> (saturate_cast< _Tp2> (x), saturate_cast< _Tp2> (y), saturate_cast< _Tp2> (z)); 
# 1454
} 
# 1456
template< class _Tp> inline 
# 1457
Point3_< _Tp> ::operator Vec< _Tp, 3> () const 
# 1458
{ 
# 1459
return Vec< _Tp, 3> (x, y, z); 
# 1460
} 
# 1462
template< class _Tp> inline Point3_< _Tp>  &
# 1463
Point3_< _Tp> ::operator=(const Point3_ &pt) 
# 1464
{ 
# 1465
(x) = (pt.x); (y) = (pt.y); (z) = (pt.z); 
# 1466
return *this; 
# 1467
} 
# 1469
template< class _Tp> inline Point3_< _Tp>  &
# 1470
Point3_< _Tp> ::operator=(Point3_ &&pt) noexcept 
# 1471
{ 
# 1472
(x) = std::move(pt.x); (y) = std::move(pt.y); (z) = std::move(pt.z); 
# 1473
return *this; 
# 1474
} 
# 1476
template< class _Tp> inline _Tp 
# 1477
Point3_< _Tp> ::dot(const Point3_ &pt) const 
# 1478
{ 
# 1479
return saturate_cast< _Tp> ((((x) * (pt.x)) + ((y) * (pt.y))) + ((z) * (pt.z))); 
# 1480
} 
# 1482
template< class _Tp> inline double 
# 1483
Point3_< _Tp> ::ddot(const Point3_ &pt) const 
# 1484
{ 
# 1485
return ((((double)(x)) * (pt.x)) + (((double)(y)) * (pt.y))) + (((double)(z)) * (pt.z)); 
# 1486
} 
# 1488
template< class _Tp> inline Point3_< _Tp>  
# 1489
Point3_< _Tp> ::cross(const Point3_ &pt) const 
# 1490
{ 
# 1491
return Point3_(((y) * (pt.z)) - ((z) * (pt.y)), ((z) * (pt.x)) - ((x) * (pt.z)), ((x) * (pt.y)) - ((y) * (pt.x))); 
# 1492
} 
# 1495
template< class _Tp> static inline Point3_< _Tp>  &
# 1496
operator+=(Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1497
{ 
# 1498
(a.x) += (b.x); 
# 1499
(a.y) += (b.y); 
# 1500
(a.z) += (b.z); 
# 1501
return a; 
# 1502
} 
# 1504
template< class _Tp> static inline Point3_< _Tp>  &
# 1505
operator-=(Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1506
{ 
# 1507
(a.x) -= (b.x); 
# 1508
(a.y) -= (b.y); 
# 1509
(a.z) -= (b.z); 
# 1510
return a; 
# 1511
} 
# 1513
template< class _Tp> static inline Point3_< _Tp>  &
# 1514
operator*=(Point3_< _Tp>  &a, int b) 
# 1515
{ 
# 1516
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1517
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1518
(a.z) = saturate_cast< _Tp> ((a.z) * b); 
# 1519
return a; 
# 1520
} 
# 1522
template< class _Tp> static inline Point3_< _Tp>  &
# 1523
operator*=(Point3_< _Tp>  &a, float b) 
# 1524
{ 
# 1525
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1526
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1527
(a.z) = saturate_cast< _Tp> ((a.z) * b); 
# 1528
return a; 
# 1529
} 
# 1531
template< class _Tp> static inline Point3_< _Tp>  &
# 1532
operator*=(Point3_< _Tp>  &a, double b) 
# 1533
{ 
# 1534
(a.x) = saturate_cast< _Tp> ((a.x) * b); 
# 1535
(a.y) = saturate_cast< _Tp> ((a.y) * b); 
# 1536
(a.z) = saturate_cast< _Tp> ((a.z) * b); 
# 1537
return a; 
# 1538
} 
# 1540
template< class _Tp> static inline Point3_< _Tp>  &
# 1541
operator/=(Point3_< _Tp>  &a, int b) 
# 1542
{ 
# 1543
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1544
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1545
(a.z) = saturate_cast< _Tp> ((a.z) / b); 
# 1546
return a; 
# 1547
} 
# 1549
template< class _Tp> static inline Point3_< _Tp>  &
# 1550
operator/=(Point3_< _Tp>  &a, float b) 
# 1551
{ 
# 1552
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1553
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1554
(a.z) = saturate_cast< _Tp> ((a.z) / b); 
# 1555
return a; 
# 1556
} 
# 1558
template< class _Tp> static inline Point3_< _Tp>  &
# 1559
operator/=(Point3_< _Tp>  &a, double b) 
# 1560
{ 
# 1561
(a.x) = saturate_cast< _Tp> ((a.x) / b); 
# 1562
(a.y) = saturate_cast< _Tp> ((a.y) / b); 
# 1563
(a.z) = saturate_cast< _Tp> ((a.z) / b); 
# 1564
return a; 
# 1565
} 
# 1567
template< class _Tp> static inline double 
# 1568
norm(const Point3_< _Tp>  &pt) 
# 1569
{ 
# 1570
return std::sqrt(((((double)(pt.x)) * (pt.x)) + (((double)(pt.y)) * (pt.y))) + (((double)(pt.z)) * (pt.z))); 
# 1571
} 
# 1573
template< class _Tp> static inline bool 
# 1574
operator==(const Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1575
{ 
# 1576
return ((a.x) == (b.x)) && ((a.y) == (b.y)) && ((a.z) == (b.z)); 
# 1577
} 
# 1579
template< class _Tp> static inline bool 
# 1580
operator!=(const Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1581
{ 
# 1582
return (((a.x) != (b.x)) || ((a.y) != (b.y))) || ((a.z) != (b.z)); 
# 1583
} 
# 1585
template< class _Tp> static inline Point3_< _Tp>  
# 1586
operator+(const Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1587
{ 
# 1588
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) + (b.x)), saturate_cast< _Tp> ((a.y) + (b.y)), saturate_cast< _Tp> ((a.z) + (b.z))); 
# 1589
} 
# 1591
template< class _Tp> static inline Point3_< _Tp>  
# 1592
operator-(const Point3_< _Tp>  &a, const Point3_< _Tp>  &b) 
# 1593
{ 
# 1594
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) - (b.x)), saturate_cast< _Tp> ((a.y) - (b.y)), saturate_cast< _Tp> ((a.z) - (b.z))); 
# 1595
} 
# 1597
template< class _Tp> static inline Point3_< _Tp>  
# 1598
operator-(const Point3_< _Tp>  &a) 
# 1599
{ 
# 1600
return Point3_< _Tp> (saturate_cast< _Tp> (-(a.x)), saturate_cast< _Tp> (-(a.y)), saturate_cast< _Tp> (-(a.z))); 
# 1601
} 
# 1603
template< class _Tp> static inline Point3_< _Tp>  
# 1604
operator*(const Point3_< _Tp>  &a, int b) 
# 1605
{ 
# 1606
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b), saturate_cast< _Tp> ((a.z) * b)); 
# 1607
} 
# 1609
template< class _Tp> static inline Point3_< _Tp>  
# 1610
operator*(int a, const Point3_< _Tp>  &b) 
# 1611
{ 
# 1612
return Point3_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a), saturate_cast< _Tp> ((b.z) * a)); 
# 1613
} 
# 1615
template< class _Tp> static inline Point3_< _Tp>  
# 1616
operator*(const Point3_< _Tp>  &a, float b) 
# 1617
{ 
# 1618
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b), saturate_cast< _Tp> ((a.z) * b)); 
# 1619
} 
# 1621
template< class _Tp> static inline Point3_< _Tp>  
# 1622
operator*(float a, const Point3_< _Tp>  &b) 
# 1623
{ 
# 1624
return Point3_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a), saturate_cast< _Tp> ((b.z) * a)); 
# 1625
} 
# 1627
template< class _Tp> static inline Point3_< _Tp>  
# 1628
operator*(const Point3_< _Tp>  &a, double b) 
# 1629
{ 
# 1630
return Point3_< _Tp> (saturate_cast< _Tp> ((a.x) * b), saturate_cast< _Tp> ((a.y) * b), saturate_cast< _Tp> ((a.z) * b)); 
# 1631
} 
# 1633
template< class _Tp> static inline Point3_< _Tp>  
# 1634
operator*(double a, const Point3_< _Tp>  &b) 
# 1635
{ 
# 1636
return Point3_< _Tp> (saturate_cast< _Tp> ((b.x) * a), saturate_cast< _Tp> ((b.y) * a), saturate_cast< _Tp> ((b.z) * a)); 
# 1637
} 
# 1639
template< class _Tp> static inline Point3_< _Tp>  
# 1640
operator*(const Matx< _Tp, 3, 3>  &a, const Point3_< _Tp>  &b) 
# 1641
{ 
# 1642
Matx< _Tp, 3, 1>  tmp = a * Vec< _Tp, 3> ((b.x), (b.y), (b.z)); 
# 1643
return Point3_< _Tp> ((tmp.val)[0], (tmp.val)[1], (tmp.val)[2]); 
# 1644
} 
# 1646
template< class _Tp> static inline Matx< _Tp, 4, 1>  
# 1647
operator*(const Matx< _Tp, 4, 4>  &a, const Point3_< _Tp>  &b) 
# 1648
{ 
# 1649
return a * Matx< _Tp, 4, 1> ((b.x), (b.y), (b.z), 1); 
# 1650
} 
# 1652
template< class _Tp> static inline Point3_< _Tp>  
# 1653
operator/(const Point3_< _Tp>  &a, int b) 
# 1654
{ 
# 1655
Point3_< _Tp>  tmp(a); 
# 1656
tmp /= b; 
# 1657
return tmp; 
# 1658
} 
# 1660
template< class _Tp> static inline Point3_< _Tp>  
# 1661
operator/(const Point3_< _Tp>  &a, float b) 
# 1662
{ 
# 1663
Point3_< _Tp>  tmp(a); 
# 1664
tmp /= b; 
# 1665
return tmp; 
# 1666
} 
# 1668
template< class _Tp> static inline Point3_< _Tp>  
# 1669
operator/(const Point3_< _Tp>  &a, double b) 
# 1670
{ 
# 1671
Point3_< _Tp>  tmp(a); 
# 1672
tmp /= b; 
# 1673
return tmp; 
# 1674
} 
# 1680
template< class _Tp> inline 
# 1681
Size_< _Tp> ::Size_() : width(0), height(0) 
# 1682
{ } 
# 1684
template< class _Tp> inline 
# 1685
Size_< _Tp> ::Size_(_Tp _width, _Tp _height) : width(_width), height(_height) 
# 1686
{ } 
# 1688
template< class _Tp> inline 
# 1689
Size_< _Tp> ::Size_(const Size_ &sz) : width(sz.width), height(sz.height) 
# 1690
{ } 
# 1692
template< class _Tp> inline 
# 1693
Size_< _Tp> ::Size_(Size_ &&sz) noexcept : width(std::move(sz.width)), height(std::move(sz.height)) 
# 1694
{ } 
# 1696
template< class _Tp> inline 
# 1697
Size_< _Tp> ::Size_(const Point_< _Tp>  &pt) : width((pt.x)), height((pt.y)) 
# 1698
{ } 
# 1700
template< class _Tp> template< class _Tp2> inline 
# 1701
Size_< _Tp> ::operator Size_< _Tp2> () const 
# 1702
{ 
# 1703
return Size_< _Tp2> (saturate_cast< _Tp2> (width), saturate_cast< _Tp2> (height)); 
# 1704
} 
# 1706
template< class _Tp> inline Size_< _Tp>  &
# 1707
Size_< _Tp> ::operator=(const Size_ &sz) 
# 1708
{ 
# 1709
(width) = (sz.width); (height) = (sz.height); 
# 1710
return *this; 
# 1711
} 
# 1713
template< class _Tp> inline Size_< _Tp>  &
# 1714
Size_< _Tp> ::operator=(Size_ &&sz) noexcept 
# 1715
{ 
# 1716
(width) = std::move(sz.width); (height) = std::move(sz.height); 
# 1717
return *this; 
# 1718
} 
# 1720
template< class _Tp> inline _Tp 
# 1721
Size_< _Tp> ::area() const 
# 1722
{ 
# 1723
const _Tp result = (width) * (height); 
# 1725
; 
# 1726
return result; 
# 1727
} 
# 1729
template< class _Tp> inline double 
# 1730
Size_< _Tp> ::aspectRatio() const 
# 1731
{ 
# 1732
return (width) / (static_cast< double>(height)); 
# 1733
} 
# 1735
template< class _Tp> inline bool 
# 1736
Size_< _Tp> ::empty() const 
# 1737
{ 
# 1738
return ((width) <= 0) || ((height) <= 0); 
# 1739
} 
# 1742
template< class _Tp> static inline Size_< _Tp>  &
# 1743
operator*=(Size_< _Tp>  &a, _Tp b) 
# 1744
{ 
# 1745
(a.width) *= b; 
# 1746
(a.height) *= b; 
# 1747
return a; 
# 1748
} 
# 1750
template< class _Tp> static inline Size_< _Tp>  
# 1751
operator*(const Size_< _Tp>  &a, _Tp b) 
# 1752
{ 
# 1753
Size_< _Tp>  tmp(a); 
# 1754
tmp *= b; 
# 1755
return tmp; 
# 1756
} 
# 1758
template< class _Tp> static inline Size_< _Tp>  &
# 1759
operator/=(Size_< _Tp>  &a, _Tp b) 
# 1760
{ 
# 1761
(a.width) /= b; 
# 1762
(a.height) /= b; 
# 1763
return a; 
# 1764
} 
# 1766
template< class _Tp> static inline Size_< _Tp>  
# 1767
operator/(const Size_< _Tp>  &a, _Tp b) 
# 1768
{ 
# 1769
Size_< _Tp>  tmp(a); 
# 1770
tmp /= b; 
# 1771
return tmp; 
# 1772
} 
# 1774
template< class _Tp> static inline Size_< _Tp>  &
# 1775
operator+=(Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1776
{ 
# 1777
(a.width) += (b.width); 
# 1778
(a.height) += (b.height); 
# 1779
return a; 
# 1780
} 
# 1782
template< class _Tp> static inline Size_< _Tp>  
# 1783
operator+(const Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1784
{ 
# 1785
Size_< _Tp>  tmp(a); 
# 1786
tmp += b; 
# 1787
return tmp; 
# 1788
} 
# 1790
template< class _Tp> static inline Size_< _Tp>  &
# 1791
operator-=(Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1792
{ 
# 1793
(a.width) -= (b.width); 
# 1794
(a.height) -= (b.height); 
# 1795
return a; 
# 1796
} 
# 1798
template< class _Tp> static inline Size_< _Tp>  
# 1799
operator-(const Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1800
{ 
# 1801
Size_< _Tp>  tmp(a); 
# 1802
tmp -= b; 
# 1803
return tmp; 
# 1804
} 
# 1806
template< class _Tp> static inline bool 
# 1807
operator==(const Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1808
{ 
# 1809
return ((a.width) == (b.width)) && ((a.height) == (b.height)); 
# 1810
} 
# 1812
template< class _Tp> static inline bool 
# 1813
operator!=(const Size_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1814
{ 
# 1815
return !(a == b); 
# 1816
} 
# 1822
template< class _Tp> inline 
# 1823
Rect_< _Tp> ::Rect_() : x(0), y(0), width(0), height(0) 
# 1824
{ } 
# 1826
template< class _Tp> inline 
# 1827
Rect_< _Tp> ::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height) : x(_x), y(_y), width(_width), height(_height) 
# 1828
{ } 
# 1830
template< class _Tp> inline 
# 1831
Rect_< _Tp> ::Rect_(const Rect_ &r) : x(r.x), y(r.y), width(r.width), height(r.height) 
# 1832
{ } 
# 1834
template< class _Tp> inline 
# 1835
Rect_< _Tp> ::Rect_(Rect_ &&r) noexcept : x(std::move(r.x)), y(std::move(r.y)), width(std::move(r.width)), height(std::move(r.height)) 
# 1836
{ } 
# 1838
template< class _Tp> inline 
# 1839
Rect_< _Tp> ::Rect_(const Point_< _Tp>  &org, const Size_< _Tp>  &sz) : x((org.x)), y((org.y)), width((sz.width)), height((sz.height)) 
# 1840
{ } 
# 1842
template< class _Tp> inline 
# 1843
Rect_< _Tp> ::Rect_(const Point_< _Tp>  &pt1, const Point_< _Tp>  &pt2) 
# 1844
{ 
# 1845
(x) = std::min((pt1.x), (pt2.x)); 
# 1846
(y) = std::min((pt1.y), (pt2.y)); 
# 1847
(width) = (std::max((pt1.x), (pt2.x)) - (x)); 
# 1848
(height) = (std::max((pt1.y), (pt2.y)) - (y)); 
# 1849
} 
# 1851
template< class _Tp> inline Rect_< _Tp>  &
# 1852
Rect_< _Tp> ::operator=(const Rect_ &r) 
# 1853
{ 
# 1854
(x) = (r.x); 
# 1855
(y) = (r.y); 
# 1856
(width) = (r.width); 
# 1857
(height) = (r.height); 
# 1858
return *this; 
# 1859
} 
# 1861
template< class _Tp> inline Rect_< _Tp>  &
# 1862
Rect_< _Tp> ::operator=(Rect_ &&r) noexcept 
# 1863
{ 
# 1864
(x) = std::move(r.x); 
# 1865
(y) = std::move(r.y); 
# 1866
(width) = std::move(r.width); 
# 1867
(height) = std::move(r.height); 
# 1868
return *this; 
# 1869
} 
# 1871
template< class _Tp> inline Point_< _Tp>  
# 1872
Rect_< _Tp> ::tl() const 
# 1873
{ 
# 1874
return Point_< _Tp> (x, y); 
# 1875
} 
# 1877
template< class _Tp> inline Point_< _Tp>  
# 1878
Rect_< _Tp> ::br() const 
# 1879
{ 
# 1880
return Point_< _Tp> ((x) + (width), (y) + (height)); 
# 1881
} 
# 1883
template< class _Tp> inline Size_< _Tp>  
# 1884
Rect_< _Tp> ::size() const 
# 1885
{ 
# 1886
return Size_< _Tp> (width, height); 
# 1887
} 
# 1889
template< class _Tp> inline _Tp 
# 1890
Rect_< _Tp> ::area() const 
# 1891
{ 
# 1892
const _Tp result = (width) * (height); 
# 1894
; 
# 1895
return result; 
# 1896
} 
# 1898
template< class _Tp> inline bool 
# 1899
Rect_< _Tp> ::empty() const 
# 1900
{ 
# 1901
return ((width) <= 0) || ((height) <= 0); 
# 1902
} 
# 1904
template< class _Tp> template< class _Tp2> inline 
# 1905
Rect_< _Tp> ::operator Rect_< _Tp2> () const 
# 1906
{ 
# 1907
return Rect_< _Tp2> (saturate_cast< _Tp2> (x), saturate_cast< _Tp2> (y), saturate_cast< _Tp2> (width), saturate_cast< _Tp2> (height)); 
# 1908
} 
# 1910
template< class _Tp> inline bool 
# 1911
Rect_< _Tp> ::contains(const Point_< _Tp>  &pt) const 
# 1912
{ 
# 1913
return ((x) <= (pt.x)) && ((pt.x) < ((x) + (width))) && ((y) <= (pt.y)) && ((pt.y) < ((y) + (height))); 
# 1914
} 
# 1917
template< class _Tp> static inline Rect_< _Tp>  &
# 1918
operator+=(Rect_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1919
{ 
# 1920
(a.x) += (b.x); 
# 1921
(a.y) += (b.y); 
# 1922
return a; 
# 1923
} 
# 1925
template< class _Tp> static inline Rect_< _Tp>  &
# 1926
operator-=(Rect_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1927
{ 
# 1928
(a.x) -= (b.x); 
# 1929
(a.y) -= (b.y); 
# 1930
return a; 
# 1931
} 
# 1933
template< class _Tp> static inline Rect_< _Tp>  &
# 1934
operator+=(Rect_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1935
{ 
# 1936
(a.width) += (b.width); 
# 1937
(a.height) += (b.height); 
# 1938
return a; 
# 1939
} 
# 1941
template< class _Tp> static inline Rect_< _Tp>  &
# 1942
operator-=(Rect_< _Tp>  &a, const Size_< _Tp>  &b) 
# 1943
{ 
# 1944
const _Tp width = (a.width) - (b.width); 
# 1945
const _Tp height = (a.height) - (b.height); 
# 1946
; 
# 1947
(a.width) = width; 
# 1948
(a.height) = height; 
# 1949
return a; 
# 1950
} 
# 1952
template< class _Tp> static inline Rect_< _Tp>  &
# 1953
operator&=(Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1954
{ 
# 1955
_Tp x1 = std::max((a.x), (b.x)); 
# 1956
_Tp y1 = std::max((a.y), (b.y)); 
# 1957
(a.width) = (std::min((a.x) + (a.width), (b.x) + (b.width)) - x1); 
# 1958
(a.height) = (std::min((a.y) + (a.height), (b.y) + (b.height)) - y1); 
# 1959
(a.x) = x1; 
# 1960
(a.y) = y1; 
# 1961
if (((a.width) <= 0) || ((a.height) <= 0)) { 
# 1962
a = Rect(); }  
# 1963
return a; 
# 1964
} 
# 1966
template< class _Tp> static inline Rect_< _Tp>  &
# 1967
operator|=(Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1968
{ 
# 1969
if (a.empty()) { 
# 1970
a = b; 
# 1971
} else { 
# 1972
if (!b.empty()) { 
# 1973
_Tp x1 = std::min((a.x), (b.x)); 
# 1974
_Tp y1 = std::min((a.y), (b.y)); 
# 1975
(a.width) = (std::max((a.x) + (a.width), (b.x) + (b.width)) - x1); 
# 1976
(a.height) = (std::max((a.y) + (a.height), (b.y) + (b.height)) - y1); 
# 1977
(a.x) = x1; 
# 1978
(a.y) = y1; 
# 1979
}  }  
# 1980
return a; 
# 1981
} 
# 1983
template< class _Tp> static inline bool 
# 1984
operator==(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1985
{ 
# 1986
return ((a.x) == (b.x)) && ((a.y) == (b.y)) && ((a.width) == (b.width)) && ((a.height) == (b.height)); 
# 1987
} 
# 1989
template< class _Tp> static inline bool 
# 1990
operator!=(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 1991
{ 
# 1992
return ((((a.x) != (b.x)) || ((a.y) != (b.y))) || ((a.width) != (b.width))) || ((a.height) != (b.height)); 
# 1993
} 
# 1995
template< class _Tp> static inline Rect_< _Tp>  
# 1996
operator+(const Rect_< _Tp>  &a, const Point_< _Tp>  &b) 
# 1997
{ 
# 1998
return Rect_< _Tp> ((a.x) + (b.x), (a.y) + (b.y), (a.width), (a.height)); 
# 1999
} 
# 2001
template< class _Tp> static inline Rect_< _Tp>  
# 2002
operator-(const Rect_< _Tp>  &a, const Point_< _Tp>  &b) 
# 2003
{ 
# 2004
return Rect_< _Tp> ((a.x) - (b.x), (a.y) - (b.y), (a.width), (a.height)); 
# 2005
} 
# 2007
template< class _Tp> static inline Rect_< _Tp>  
# 2008
operator+(const Rect_< _Tp>  &a, const Size_< _Tp>  &b) 
# 2009
{ 
# 2010
return Rect_< _Tp> ((a.x), (a.y), (a.width) + (b.width), (a.height) + (b.height)); 
# 2011
} 
# 2013
template< class _Tp> static inline Rect_< _Tp>  
# 2014
operator-(const Rect_< _Tp>  &a, const Size_< _Tp>  &b) 
# 2015
{ 
# 2016
const _Tp width = (a.width) - (b.width); 
# 2017
const _Tp height = (a.height) - (b.height); 
# 2018
; 
# 2019
return Rect_< _Tp> ((a.x), (a.y), width, height); 
# 2020
} 
# 2022
template< class _Tp> static inline Rect_< _Tp>  
# 2023
operator&(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 2024
{ 
# 2025
Rect_< _Tp>  c = a; 
# 2026
return c &= b; 
# 2027
} 
# 2029
template< class _Tp> static inline Rect_< _Tp>  
# 2030
operator|(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) 
# 2031
{ 
# 2032
Rect_< _Tp>  c = a; 
# 2033
return c |= b; 
# 2034
} 
# 2042
template< class _Tp> static inline double 
# 2043
jaccardDistance(const Rect_< _Tp>  &a, const Rect_< _Tp>  &b) { 
# 2044
_Tp Aa = a.area(); 
# 2045
_Tp Ab = b.area(); 
# 2047
if ((Aa + Ab) <= std::template numeric_limits< _Tp> ::epsilon()) { 
# 2049
return (0.0); 
# 2050
}  
# 2052
double Aab = (a & b).area(); 
# 2054
return (1.0) - (Aab / ((Aa + Ab) - Aab)); 
# 2055
} 
# 2060
inline RotatedRect::RotatedRect() : center(), size(), angle((0)) 
# 2061
{ } 
# 2064
inline RotatedRect::RotatedRect(const Point2f &_center, const Size2f &_size, float _angle) : center(_center), size(_size), angle(_angle) 
# 2065
{ } 
# 2070
inline Range::Range() : start(0), end(0) 
# 2071
{ } 
# 2074
inline Range::Range(int _start, int _end) : start(_start), end(_end) 
# 2075
{ } 
# 2078
inline int Range::size() const 
# 2079
{ 
# 2080
return (end) - (start); 
# 2081
} 
# 2084
inline bool Range::empty() const 
# 2085
{ 
# 2086
return (start) == (end); 
# 2087
} 
# 2090
inline Range Range::all() 
# 2091
{ 
# 2092
return Range((-2147483647) - 1, 2147483647); 
# 2093
} 
# 2097
static inline bool operator==(const Range &r1, const Range &r2) 
# 2098
{ 
# 2099
return ((r1.start) == (r2.start)) && ((r1.end) == (r2.end)); 
# 2100
} 
# 2103
static inline bool operator!=(const Range &r1, const Range &r2) 
# 2104
{ 
# 2105
return !(r1 == r2); 
# 2106
} 
# 2109
static inline bool operator!(const Range &r) 
# 2110
{ 
# 2111
return (r.start) == (r.end); 
# 2112
} 
# 2115
static inline Range operator&(const Range &r1, const Range &r2) 
# 2116
{ 
# 2117
Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end)); 
# 2118
(r.end) = std::max(r.end, r.start); 
# 2119
return r; 
# 2120
} 
# 2123
static inline Range &operator&=(Range &r1, const Range &r2) 
# 2124
{ 
# 2125
r1 = (r1 & r2); 
# 2126
return r1; 
# 2127
} 
# 2130
static inline Range operator+(const Range &r1, int delta) 
# 2131
{ 
# 2132
return Range((r1.start) + delta, (r1.end) + delta); 
# 2133
} 
# 2136
static inline Range operator+(int delta, const Range &r1) 
# 2137
{ 
# 2138
return Range((r1.start) + delta, (r1.end) + delta); 
# 2139
} 
# 2142
static inline Range operator-(const Range &r1, int delta) 
# 2143
{ 
# 2144
return (r1 + (-delta)); 
# 2145
} 
# 2151
template< class _Tp> inline 
# 2152
Scalar_< _Tp> ::Scalar_() 
# 2153
{ 
# 2154
((this->val)[0]) = (((this->val)[1]) = (((this->val)[2]) = (((this->val)[3]) = 0))); 
# 2155
} 
# 2157
template< class _Tp> inline 
# 2158
Scalar_< _Tp> ::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3) 
# 2159
{ 
# 2160
((this->val)[0]) = v0; 
# 2161
((this->val)[1]) = v1; 
# 2162
((this->val)[2]) = v2; 
# 2163
((this->val)[3]) = v3; 
# 2164
} 
# 2166
template< class _Tp> inline 
# 2167
Scalar_< _Tp> ::Scalar_(const Scalar_ &s) : Vec< _Tp, 4> (s) { 
# 2168
} 
# 2170
template< class _Tp> inline 
# 2171
Scalar_< _Tp> ::Scalar_(Scalar_ &&s) noexcept { 
# 2172
((this->val)[0]) = std::move((s.val)[0]); 
# 2173
((this->val)[1]) = std::move((s.val)[1]); 
# 2174
((this->val)[2]) = std::move((s.val)[2]); 
# 2175
((this->val)[3]) = std::move((s.val)[3]); 
# 2176
} 
# 2178
template< class _Tp> inline Scalar_< _Tp>  &
# 2179
Scalar_< _Tp> ::operator=(const Scalar_ &s) { 
# 2180
((this->val)[0]) = ((s.val)[0]); 
# 2181
((this->val)[1]) = ((s.val)[1]); 
# 2182
((this->val)[2]) = ((s.val)[2]); 
# 2183
((this->val)[3]) = ((s.val)[3]); 
# 2184
return *this; 
# 2185
} 
# 2187
template< class _Tp> inline Scalar_< _Tp>  &
# 2188
Scalar_< _Tp> ::operator=(Scalar_ &&s) noexcept { 
# 2189
((this->val)[0]) = std::move((s.val)[0]); 
# 2190
((this->val)[1]) = std::move((s.val)[1]); 
# 2191
((this->val)[2]) = std::move((s.val)[2]); 
# 2192
((this->val)[3]) = std::move((s.val)[3]); 
# 2193
return *this; 
# 2194
} 
# 2196
template< class _Tp> template< class _Tp2, int cn> inline 
# 2197
Scalar_< _Tp> ::Scalar_(const Vec< _Tp2, cn>  &v) 
# 2198
{ 
# 2199
int i; 
# 2200
for (i = 0; i < ((cn < 4) ? cn : 4); i++) { 
# 2201
((this->val)[i]) = cv::saturate_cast< _Tp> ((v.val)[i]); }  
# 2202
for (; i < 4; i++) { 
# 2203
((this->val)[i]) = 0; }  
# 2204
} 
# 2206
template< class _Tp> inline 
# 2207
Scalar_< _Tp> ::Scalar_(_Tp v0) 
# 2208
{ 
# 2209
((this->val)[0]) = v0; 
# 2210
((this->val)[1]) = (((this->val)[2]) = (((this->val)[3]) = 0)); 
# 2211
} 
# 2213
template< class _Tp> inline Scalar_< _Tp>  
# 2214
Scalar_< _Tp> ::all(_Tp v0) 
# 2215
{ 
# 2216
return Scalar_(v0, v0, v0, v0); 
# 2217
} 
# 2220
template< class _Tp> inline Scalar_< _Tp>  
# 2221
Scalar_< _Tp> ::mul(const Scalar_ &a, double scale) const 
# 2222
{ 
# 2223
return Scalar_(saturate_cast< _Tp> ((((this->val)[0]) * ((a.val)[0])) * scale), saturate_cast< _Tp> ((((this->val)[1]) * ((a.val)[1])) * scale), saturate_cast< _Tp> ((((this->val)[2]) * ((a.val)[2])) * scale), saturate_cast< _Tp> ((((this->val)[3]) * ((a.val)[3])) * scale)); 
# 2227
} 
# 2229
template< class _Tp> inline Scalar_< _Tp>  
# 2230
Scalar_< _Tp> ::conj() const 
# 2231
{ 
# 2232
return Scalar_(saturate_cast< _Tp> ((this->val)[0]), saturate_cast< _Tp> (-((this->val)[1])), saturate_cast< _Tp> (-((this->val)[2])), saturate_cast< _Tp> (-((this->val)[3]))); 
# 2236
} 
# 2238
template< class _Tp> inline bool 
# 2239
Scalar_< _Tp> ::isReal() const 
# 2240
{ 
# 2241
return (((this->val)[1]) == 0) && (((this->val)[2]) == 0) && (((this->val)[3]) == 0); 
# 2242
} 
# 2245
template< class _Tp> template< class T2> inline 
# 2246
Scalar_< _Tp> ::operator Scalar_< T2> () const 
# 2247
{ 
# 2248
return Scalar_< T2> (saturate_cast< T2> ((this->val)[0]), saturate_cast< T2> ((this->val)[1]), saturate_cast< T2> ((this->val)[2]), saturate_cast< T2> ((this->val)[3])); 
# 2252
} 
# 2255
template< class _Tp> static inline Scalar_< _Tp>  &
# 2256
operator+=(Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2257
{ 
# 2258
((a.val)[0]) += ((b.val)[0]); 
# 2259
((a.val)[1]) += ((b.val)[1]); 
# 2260
((a.val)[2]) += ((b.val)[2]); 
# 2261
((a.val)[3]) += ((b.val)[3]); 
# 2262
return a; 
# 2263
} 
# 2265
template< class _Tp> static inline Scalar_< _Tp>  &
# 2266
operator-=(Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2267
{ 
# 2268
((a.val)[0]) -= ((b.val)[0]); 
# 2269
((a.val)[1]) -= ((b.val)[1]); 
# 2270
((a.val)[2]) -= ((b.val)[2]); 
# 2271
((a.val)[3]) -= ((b.val)[3]); 
# 2272
return a; 
# 2273
} 
# 2275
template< class _Tp> static inline Scalar_< _Tp>  &
# 2276
operator*=(Scalar_< _Tp>  &a, _Tp v) 
# 2277
{ 
# 2278
((a.val)[0]) *= v; 
# 2279
((a.val)[1]) *= v; 
# 2280
((a.val)[2]) *= v; 
# 2281
((a.val)[3]) *= v; 
# 2282
return a; 
# 2283
} 
# 2285
template< class _Tp> static inline bool 
# 2286
operator==(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2287
{ 
# 2288
return (((a.val)[0]) == ((b.val)[0])) && (((a.val)[1]) == ((b.val)[1])) && (((a.val)[2]) == ((b.val)[2])) && (((a.val)[3]) == ((b.val)[3])); 
# 2290
} 
# 2292
template< class _Tp> static inline bool 
# 2293
operator!=(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2294
{ 
# 2295
return (((((a.val)[0]) != ((b.val)[0])) || (((a.val)[1]) != ((b.val)[1]))) || (((a.val)[2]) != ((b.val)[2]))) || (((a.val)[3]) != ((b.val)[3])); 
# 2297
} 
# 2299
template< class _Tp> static inline Scalar_< _Tp>  
# 2300
operator+(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2301
{ 
# 2302
return Scalar_< _Tp> (((a.val)[0]) + ((b.val)[0]), ((a.val)[1]) + ((b.val)[1]), ((a.val)[2]) + ((b.val)[2]), ((a.val)[3]) + ((b.val)[3])); 
# 2306
} 
# 2308
template< class _Tp> static inline Scalar_< _Tp>  
# 2309
operator-(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2310
{ 
# 2311
return Scalar_< _Tp> (saturate_cast< _Tp> (((a.val)[0]) - ((b.val)[0])), saturate_cast< _Tp> (((a.val)[1]) - ((b.val)[1])), saturate_cast< _Tp> (((a.val)[2]) - ((b.val)[2])), saturate_cast< _Tp> (((a.val)[3]) - ((b.val)[3]))); 
# 2315
} 
# 2317
template< class _Tp> static inline Scalar_< _Tp>  
# 2318
operator*(const Scalar_< _Tp>  &a, _Tp alpha) 
# 2319
{ 
# 2320
return Scalar_< _Tp> (((a.val)[0]) * alpha, ((a.val)[1]) * alpha, ((a.val)[2]) * alpha, ((a.val)[3]) * alpha); 
# 2324
} 
# 2326
template< class _Tp> static inline Scalar_< _Tp>  
# 2327
operator*(_Tp alpha, const Scalar_< _Tp>  &a) 
# 2328
{ 
# 2329
return a * alpha; 
# 2330
} 
# 2332
template< class _Tp> static inline Scalar_< _Tp>  
# 2333
operator-(const Scalar_< _Tp>  &a) 
# 2334
{ 
# 2335
return Scalar_< _Tp> (saturate_cast< _Tp> (-((a.val)[0])), saturate_cast< _Tp> (-((a.val)[1])), saturate_cast< _Tp> (-((a.val)[2])), saturate_cast< _Tp> (-((a.val)[3]))); 
# 2339
} 
# 2342
template< class _Tp> static inline Scalar_< _Tp>  
# 2343
operator*(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2344
{ 
# 2345
return Scalar_< _Tp> (saturate_cast< _Tp> (((((a[0]) * (b[0])) - ((a[1]) * (b[1]))) - ((a[2]) * (b[2]))) - ((a[3]) * (b[3]))), saturate_cast< _Tp> (((((a[0]) * (b[1])) + ((a[1]) * (b[0]))) + ((a[2]) * (b[3]))) - ((a[3]) * (b[2]))), saturate_cast< _Tp> (((((a[0]) * (b[2])) - ((a[1]) * (b[3]))) + ((a[2]) * (b[0]))) + ((a[3]) * (b[1]))), saturate_cast< _Tp> (((((a[0]) * (b[3])) + ((a[1]) * (b[2]))) - ((a[2]) * (b[1]))) + ((a[3]) * (b[0])))); 
# 2349
} 
# 2351
template< class _Tp> static inline Scalar_< _Tp>  &
# 2352
operator*=(Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2353
{ 
# 2354
a = (a * b); 
# 2355
return a; 
# 2356
} 
# 2358
template< class _Tp> static inline Scalar_< _Tp>  
# 2359
operator/(const Scalar_< _Tp>  &a, _Tp alpha) 
# 2360
{ 
# 2361
return Scalar_< _Tp> (((a.val)[0]) / alpha, ((a.val)[1]) / alpha, ((a.val)[2]) / alpha, ((a.val)[3]) / alpha); 
# 2365
} 
# 2367
template< class _Tp> static inline Scalar_< float>  
# 2368
operator/(const Scalar_< float>  &a, float alpha) 
# 2369
{ 
# 2370
float s = (1) / alpha; 
# 2371
return Scalar_< float> (((a.val)[0]) * s, ((a.val)[1]) * s, ((a.val)[2]) * s, ((a.val)[3]) * s); 
# 2372
} 
# 2374
template< class _Tp> static inline Scalar_< double>  
# 2375
operator/(const Scalar_< double>  &a, double alpha) 
# 2376
{ 
# 2377
double s = (1) / alpha; 
# 2378
return Scalar_< double> (((a.val)[0]) * s, ((a.val)[1]) * s, ((a.val)[2]) * s, ((a.val)[3]) * s); 
# 2379
} 
# 2381
template< class _Tp> static inline Scalar_< _Tp>  &
# 2382
operator/=(Scalar_< _Tp>  &a, _Tp alpha) 
# 2383
{ 
# 2384
a = (a / alpha); 
# 2385
return a; 
# 2386
} 
# 2388
template< class _Tp> static inline Scalar_< _Tp>  
# 2389
operator/(_Tp a, const Scalar_< _Tp>  &b) 
# 2390
{ 
# 2391
_Tp s = a / (((((b[0]) * (b[0])) + ((b[1]) * (b[1]))) + ((b[2]) * (b[2]))) + ((b[3]) * (b[3]))); 
# 2392
return b.conj() * s; 
# 2393
} 
# 2395
template< class _Tp> static inline Scalar_< _Tp>  
# 2396
operator/(const Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2397
{ 
# 2398
return a * (((_Tp)1) / b); 
# 2399
} 
# 2401
template< class _Tp> static inline Scalar_< _Tp>  &
# 2402
operator/=(Scalar_< _Tp>  &a, const Scalar_< _Tp>  &b) 
# 2403
{ 
# 2404
a = (a / b); 
# 2405
return a; 
# 2406
} 
# 2408
template< class _Tp> static inline Scalar 
# 2409
operator*(const Matx< _Tp, 4, 4>  &a, const Scalar &b) 
# 2410
{ 
# 2411
Matx< double, 4, 1>  c(((Matx< double, 4, 4> )(a)), b, Matx_MatMulOp()); 
# 2412
return reinterpret_cast< const Scalar &>(c); 
# 2413
} 
# 2416
template<> inline Scalar operator*(const Matx< double, 4, 4>  &a, const Scalar &b) 
# 2417
{ 
# 2418
Matx< double, 4, 1>  c(a, b, Matx_MatMulOp()); 
# 2419
return reinterpret_cast< const Scalar &>(c); 
# 2420
} 
# 2427
inline KeyPoint::KeyPoint() : pt(0, 0), size((0)), angle((-1)), response((0)), octave(0), class_id((-1)) 
# 2428
{ } 
# 2431
inline KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id) : pt(_pt), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) 
# 2432
{ } 
# 2435
inline KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id) : pt(x, y), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) 
# 2436
{ } 
# 2443
inline DMatch::DMatch() : queryIdx((-1)), trainIdx((-1)), imgIdx((-1)), distance((3.4028235E38F)) 
# 2444
{ } 
# 2447
inline DMatch::DMatch(int _queryIdx, int _trainIdx, float _distance) : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx((-1)), distance(_distance) 
# 2448
{ } 
# 2451
inline DMatch::DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance) : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx), distance(_distance) 
# 2452
{ } 
# 2455
inline bool DMatch::operator<(const DMatch &m) const 
# 2456
{ 
# 2457
return (distance) < (m.distance); 
# 2458
} 
# 2465
inline TermCriteria::TermCriteria() : type(0), maxCount(0), epsilon((0)) 
# 2466
{ } 
# 2469
inline TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon) : type(_type), maxCount(_maxCount), epsilon(_epsilon) 
# 2470
{ } 
# 2474
}
# 15 "/usr/include/opencv4/opencv2/core/bufferpool.hpp" 3
namespace cv { 
# 21
class BufferPoolController { 
# 24
protected: ~BufferPoolController() { } 
# 26
public: virtual size_t getReservedSize() const = 0; 
# 27
virtual size_t getMaxReservedSize() const = 0; 
# 28
virtual void setMaxReservedSize(size_t size) = 0; 
# 29
virtual void freeAllReservedBuffers() = 0; 
# 30
}; 
# 34
}
# 58 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
namespace cv { 
# 64
enum AccessFlag { ACCESS_READ = (1 << 24), ACCESS_WRITE = (1 << 25), 
# 65
ACCESS_RW = (3 << 24), ACCESS_MASK = ACCESS_RW, ACCESS_FAST = (1 << 26)}; 
# 66
static inline bool operator!(const AccessFlag &val) { typedef std::underlying_type< AccessFlag> ::type UnderlyingType; return !(static_cast< UnderlyingType>(val)); } static inline bool operator==(const AccessFlag &a, const int &b) { return (static_cast< int>(a)) == (static_cast< int>(b)); } static inline bool operator!=(const AccessFlag &a, const int &b) { return (static_cast< int>(a)) != (static_cast< int>(b)); } static inline AccessFlag operator~(const AccessFlag &val) { typedef std::underlying_type< AccessFlag> ::type UnderlyingType; return static_cast< AccessFlag>(~(static_cast< UnderlyingType>(val))); } static inline AccessFlag operator|(const AccessFlag &a, const AccessFlag &b) { typedef std::underlying_type< AccessFlag> ::type UnderlyingType; return static_cast< AccessFlag>((static_cast< UnderlyingType>(a)) | (static_cast< UnderlyingType>(b))); } static inline AccessFlag operator&(const AccessFlag &a, const AccessFlag &b) { typedef std::underlying_type< AccessFlag> ::type UnderlyingType; return static_cast< AccessFlag>((static_cast< UnderlyingType>(a)) & (static_cast< UnderlyingType>(b))); } static inline AccessFlag operator^(const AccessFlag &a, const AccessFlag &b) { typedef std::underlying_type< AccessFlag> ::type UnderlyingType; return static_cast< AccessFlag>((static_cast< UnderlyingType>(a)) ^ (static_cast< UnderlyingType>(b))); } static inline AccessFlag &operator|=(AccessFlag &_this, const AccessFlag &val) { _this = (static_cast< AccessFlag>((static_cast< int>(_this)) | (static_cast< int>(val)))); return _this; } static inline AccessFlag &operator&=(AccessFlag &_this, const AccessFlag &val) { _this = (static_cast< AccessFlag>((static_cast< int>(_this)) & (static_cast< int>(val)))); return _this; } static inline AccessFlag &operator^=(AccessFlag &_this, const AccessFlag &val) { _this = (static_cast< AccessFlag>((static_cast< int>(_this)) ^ (static_cast< int>(val)))); return _this; } 
# 67
static inline AccessFlag operator&(const int &a, const AccessFlag &b) { typedef std::underlying_type< AccessFlag> ::type UnderlyingType; return static_cast< AccessFlag>((static_cast< UnderlyingType>(a)) & (static_cast< UnderlyingType>(b))); } 
# 71
class _OutputArray; 
# 158 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
class _InputArray { 
# 161
public: enum KindFlag { 
# 162
KIND_SHIFT = 16, 
# 163
FIXED_TYPE = (32768 << KIND_SHIFT), 
# 164
FIXED_SIZE = (16384 << KIND_SHIFT), 
# 165
KIND_MASK = (31 << KIND_SHIFT), 
# 167
NONE = (0 << KIND_SHIFT), 
# 168
MAT = (1 << KIND_SHIFT), 
# 169
MATX = (2 << KIND_SHIFT), 
# 170
STD_VECTOR = (3 << KIND_SHIFT), 
# 171
STD_VECTOR_VECTOR = (4 << KIND_SHIFT), 
# 172
STD_VECTOR_MAT = (5 << KIND_SHIFT), 
# 173
EXPR = (6 << KIND_SHIFT), 
# 174
OPENGL_BUFFER = (7 << KIND_SHIFT), 
# 175
CUDA_HOST_MEM = (8 << KIND_SHIFT), 
# 176
CUDA_GPU_MAT = (9 << KIND_SHIFT), 
# 177
UMAT = (10 << KIND_SHIFT), 
# 178
STD_VECTOR_UMAT = (11 << KIND_SHIFT), 
# 179
STD_BOOL_VECTOR = (12 << KIND_SHIFT), 
# 180
STD_VECTOR_CUDA_GPU_MAT = (13 << KIND_SHIFT), 
# 181
STD_ARRAY = (14 << KIND_SHIFT), 
# 182
STD_ARRAY_MAT = (15 << KIND_SHIFT)
# 183
}; 
# 185
inline _InputArray(); 
# 186
inline _InputArray(int _flags, void * _obj); 
# 187
inline _InputArray(const Mat & m); 
# 188
inline _InputArray(const MatExpr & expr); 
# 189
inline _InputArray(const std::vector< Mat>  & vec); 
# 190
template< class _Tp> inline _InputArray(const Mat_< _Tp>  & m); 
# 191
template< class _Tp> inline _InputArray(const std::vector< _Tp>  & vec); 
# 192
inline _InputArray(const std::vector< bool>  & vec); 
# 193
template< class _Tp> inline _InputArray(const std::vector< std::vector< _Tp> >  & vec); 
# 194
_InputArray(const std::vector< std::vector< bool> >  &) = delete;
# 195
template< class _Tp> inline _InputArray(const std::vector< Mat_< _Tp> >  & vec); 
# 196
template< class _Tp> inline _InputArray(const _Tp * vec, int n); 
# 197
template< class _Tp, int m, int n> inline _InputArray(const Matx< _Tp, m, n>  & matx); 
# 198
inline _InputArray(const double & val); 
# 199
inline _InputArray(const cuda::GpuMat & d_mat); 
# 200
inline _InputArray(const std::vector< cuda::GpuMat>  & d_mat_array); 
# 201
inline _InputArray(const ogl::Buffer & buf); 
# 202
inline _InputArray(const cuda::HostMem & cuda_mem); 
# 203
template< class _Tp> _InputArray(const cudev::GpuMat_< _Tp>  & m); 
# 204
inline _InputArray(const UMat & um); 
# 205
inline _InputArray(const std::vector< UMat>  & umv); 
# 207
template< class _Tp, std::size_t _Nm> inline _InputArray(const std::array< _Tp, _Nm>  & arr); 
# 208
template< std::size_t _Nm> inline _InputArray(const std::array< Mat, _Nm>  & arr); 
# 210
template< class _Tp> static inline _InputArray rawIn(const std::vector< _Tp>  & vec); 
# 211
template< class _Tp, std::size_t _Nm> static inline _InputArray rawIn(const std::array< _Tp, _Nm>  & arr); 
# 213
inline Mat getMat(int idx = -1) const; 
# 214
Mat getMat_(int idx = -1) const; 
# 215
UMat getUMat(int idx = -1) const; 
# 216
void getMatVector(std::vector< Mat>  & mv) const; 
# 217
void getUMatVector(std::vector< UMat>  & umv) const; 
# 218
void getGpuMatVector(std::vector< cuda::GpuMat>  & gpumv) const; 
# 219
cuda::GpuMat getGpuMat() const; 
# 220
ogl::Buffer getOGlBuffer() const; 
# 222
inline int getFlags() const; 
# 223
inline void *getObj() const; 
# 224
inline Size getSz() const; 
# 226
KindFlag kind() const; 
# 227
int dims(int i = -1) const; 
# 228
int cols(int i = -1) const; 
# 229
int rows(int i = -1) const; 
# 230
Size size(int i = -1) const; 
# 231
int sizend(int * sz, int i = -1) const; 
# 232
bool sameSize(const _InputArray & arr) const; 
# 233
size_t total(int i = -1) const; 
# 234
int type(int i = -1) const; 
# 235
int depth(int i = -1) const; 
# 236
int channels(int i = -1) const; 
# 237
bool isContinuous(int i = -1) const; 
# 238
bool isSubmatrix(int i = -1) const; 
# 239
bool empty() const; 
# 240
void copyTo(const _OutputArray & arr) const; 
# 241
void copyTo(const _OutputArray & arr, const _InputArray & mask) const; 
# 242
size_t offset(int i = -1) const; 
# 243
size_t step(int i = -1) const; 
# 244
inline bool isMat() const; 
# 245
inline bool isUMat() const; 
# 246
inline bool isMatVector() const; 
# 247
inline bool isUMatVector() const; 
# 248
inline bool isMatx() const; 
# 249
inline bool isVector() const; 
# 250
inline bool isGpuMat() const; 
# 251
inline bool isGpuMatVector() const; 
# 252
inline ~_InputArray(); 
# 255
protected: int flags; 
# 256
void *obj; 
# 257
Size sz; 
# 259
inline void init(int _flags, const void * _obj); 
# 260
inline void init(int _flags, const void * _obj, Size _sz); 
# 261
}; 
# 262
static inline bool operator!(const _InputArray::KindFlag &val) { typedef std::underlying_type< _InputArray::KindFlag> ::type UnderlyingType; return !(static_cast< UnderlyingType>(val)); } static inline bool operator==(const _InputArray::KindFlag &a, const int &b) { return (static_cast< int>(a)) == (static_cast< int>(b)); } static inline bool operator!=(const _InputArray::KindFlag &a, const int &b) { return (static_cast< int>(a)) != (static_cast< int>(b)); } static inline _InputArray::KindFlag operator~(const _InputArray::KindFlag &val) { typedef std::underlying_type< _InputArray::KindFlag> ::type UnderlyingType; return static_cast< _InputArray::KindFlag>(~(static_cast< UnderlyingType>(val))); } static inline _InputArray::KindFlag operator|(const _InputArray::KindFlag &a, const _InputArray::KindFlag &b) { typedef std::underlying_type< _InputArray::KindFlag> ::type UnderlyingType; return static_cast< _InputArray::KindFlag>((static_cast< UnderlyingType>(a)) | (static_cast< UnderlyingType>(b))); } static inline _InputArray::KindFlag operator&(const _InputArray::KindFlag &a, const _InputArray::KindFlag &b) { typedef std::underlying_type< _InputArray::KindFlag> ::type UnderlyingType; return static_cast< _InputArray::KindFlag>((static_cast< UnderlyingType>(a)) & (static_cast< UnderlyingType>(b))); } static inline _InputArray::KindFlag operator^(const _InputArray::KindFlag &a, const _InputArray::KindFlag &b) { typedef std::underlying_type< _InputArray::KindFlag> ::type UnderlyingType; return static_cast< _InputArray::KindFlag>((static_cast< UnderlyingType>(a)) ^ (static_cast< UnderlyingType>(b))); } static inline _InputArray::KindFlag &operator|=(_InputArray::KindFlag &_this, const _InputArray::KindFlag &val) { _this = (static_cast< _InputArray::KindFlag>((static_cast< int>(_this)) | (static_cast< int>(val)))); return _this; } static inline _InputArray::KindFlag &operator&=(_InputArray::KindFlag &_this, const _InputArray::KindFlag &val) { _this = (static_cast< _InputArray::KindFlag>((static_cast< int>(_this)) & (static_cast< int>(val)))); return _this; } static inline _InputArray::KindFlag &operator^=(_InputArray::KindFlag &_this, const _InputArray::KindFlag &val) { _this = (static_cast< _InputArray::KindFlag>((static_cast< int>(_this)) ^ (static_cast< int>(val)))); return _this; } 
# 263
static inline _InputArray::KindFlag operator&(const int &a, const _InputArray::KindFlag &b) { typedef std::underlying_type< _InputArray::KindFlag> ::type UnderlyingType; return static_cast< _InputArray::KindFlag>((static_cast< UnderlyingType>(a)) & (static_cast< UnderlyingType>(b))); } 
# 290 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
class _OutputArray : public _InputArray { 
# 293
public: enum DepthMask { 
# 295
DEPTH_MASK_8U = (1 << 0), 
# 296
DEPTH_MASK_8S, 
# 297
DEPTH_MASK_16U = (1 << 2), 
# 298
DEPTH_MASK_16S = (1 << 3), 
# 299
DEPTH_MASK_32S = (1 << 4), 
# 300
DEPTH_MASK_32F = (1 << 5), 
# 301
DEPTH_MASK_64F = (1 << 6), 
# 302
DEPTH_MASK_16F = (1 << 7), 
# 303
DEPTH_MASK_ALL = ((DEPTH_MASK_64F << 1) - 1), 
# 304
DEPTH_MASK_ALL_BUT_8S = (DEPTH_MASK_ALL & (~DEPTH_MASK_8S)), 
# 305
DEPTH_MASK_ALL_16F = ((DEPTH_MASK_16F << 1) - 1), 
# 306
DEPTH_MASK_FLT = (DEPTH_MASK_32F + DEPTH_MASK_64F)
# 307
}; 
# 309
inline _OutputArray(); 
# 310
inline _OutputArray(int _flags, void * _obj); 
# 311
inline _OutputArray(Mat & m); 
# 312
inline _OutputArray(std::vector< Mat>  & vec); 
# 313
inline _OutputArray(cuda::GpuMat & d_mat); 
# 314
inline _OutputArray(std::vector< cuda::GpuMat>  & d_mat); 
# 315
inline _OutputArray(ogl::Buffer & buf); 
# 316
inline _OutputArray(cuda::HostMem & cuda_mem); 
# 317
template< class _Tp> _OutputArray(cudev::GpuMat_< _Tp>  & m); 
# 318
template< class _Tp> inline _OutputArray(std::vector< _Tp>  & vec); 
# 319
_OutputArray(std::vector< bool>  & vec) = delete;
# 320
template< class _Tp> inline _OutputArray(std::vector< std::vector< _Tp> >  & vec); 
# 321
_OutputArray(std::vector< std::vector< bool> >  &) = delete;
# 322
template< class _Tp> inline _OutputArray(std::vector< Mat_< _Tp> >  & vec); 
# 323
template< class _Tp> inline _OutputArray(Mat_< _Tp>  & m); 
# 324
template< class _Tp> inline _OutputArray(_Tp * vec, int n); 
# 325
template< class _Tp, int m, int n> inline _OutputArray(Matx< _Tp, m, n>  & matx); 
# 326
inline _OutputArray(UMat & m); 
# 327
inline _OutputArray(std::vector< UMat>  & vec); 
# 329
inline _OutputArray(const Mat & m); 
# 330
inline _OutputArray(const std::vector< Mat>  & vec); 
# 331
inline _OutputArray(const cuda::GpuMat & d_mat); 
# 332
_OutputArray(const std::vector< cuda::GpuMat>  & d_mat); 
# 333
inline _OutputArray(const ogl::Buffer & buf); 
# 334
inline _OutputArray(const cuda::HostMem & cuda_mem); 
# 335
template< class _Tp> _OutputArray(const cudev::GpuMat_< _Tp>  & m); 
# 336
template< class _Tp> inline _OutputArray(const std::vector< _Tp>  & vec); 
# 337
template< class _Tp> inline _OutputArray(const std::vector< std::vector< _Tp> >  & vec); 
# 338
template< class _Tp> inline _OutputArray(const std::vector< Mat_< _Tp> >  & vec); 
# 339
template< class _Tp> inline _OutputArray(const Mat_< _Tp>  & m); 
# 340
template< class _Tp> inline _OutputArray(const _Tp * vec, int n); 
# 341
template< class _Tp, int m, int n> inline _OutputArray(const Matx< _Tp, m, n>  & matx); 
# 342
inline _OutputArray(const UMat & m); 
# 343
inline _OutputArray(const std::vector< UMat>  & vec); 
# 345
template< class _Tp, std::size_t _Nm> inline _OutputArray(std::array< _Tp, _Nm>  & arr); 
# 346
template< class _Tp, std::size_t _Nm> inline _OutputArray(const std::array< _Tp, _Nm>  & arr); 
# 347
template< std::size_t _Nm> inline _OutputArray(std::array< Mat, _Nm>  & arr); 
# 348
template< std::size_t _Nm> inline _OutputArray(const std::array< Mat, _Nm>  & arr); 
# 350
template< class _Tp> static inline _OutputArray rawOut(std::vector< _Tp>  & vec); 
# 351
template< class _Tp, std::size_t _Nm> static inline _OutputArray rawOut(std::array< _Tp, _Nm>  & arr); 
# 353
bool fixedSize() const; 
# 354
bool fixedType() const; 
# 355
bool needed() const; 
# 356
Mat &getMatRef(int i = -1) const; 
# 357
UMat &getUMatRef(int i = -1) const; 
# 358
cuda::GpuMat &getGpuMatRef() const; 
# 359
std::vector< cuda::GpuMat>  &getGpuMatVecRef() const; 
# 360
ogl::Buffer &getOGlBufferRef() const; 
# 361
cuda::HostMem &getHostMemRef() const; 
# 362
void create(Size sz, int type, int i = -1, bool allowTransposed = false, DepthMask fixedDepthMask = static_cast< DepthMask>(0)) const; 
# 363
void create(int rows, int cols, int type, int i = -1, bool allowTransposed = false, DepthMask fixedDepthMask = static_cast< DepthMask>(0)) const; 
# 364
void create(int dims, const int * size, int type, int i = -1, bool allowTransposed = false, DepthMask fixedDepthMask = static_cast< DepthMask>(0)) const; 
# 365
void createSameSize(const _InputArray & arr, int mtype) const; 
# 366
void release() const; 
# 367
void clear() const; 
# 368
void setTo(const _InputArray & value, const _InputArray & mask = _InputArray()) const; 
# 370
void assign(const UMat & u) const; 
# 371
void assign(const Mat & m) const; 
# 373
void assign(const std::vector< UMat>  & v) const; 
# 374
void assign(const std::vector< Mat>  & v) const; 
# 376
void move(UMat & u) const; 
# 377
void move(Mat & m) const; 
# 378
}; 
# 381
class _InputOutputArray : public _OutputArray { 
# 384
public: inline _InputOutputArray(); 
# 385
inline _InputOutputArray(int _flags, void * _obj); 
# 386
inline _InputOutputArray(Mat & m); 
# 387
inline _InputOutputArray(std::vector< Mat>  & vec); 
# 388
inline _InputOutputArray(cuda::GpuMat & d_mat); 
# 389
inline _InputOutputArray(ogl::Buffer & buf); 
# 390
inline _InputOutputArray(cuda::HostMem & cuda_mem); 
# 391
template< class _Tp> _InputOutputArray(cudev::GpuMat_< _Tp>  & m); 
# 392
template< class _Tp> inline _InputOutputArray(std::vector< _Tp>  & vec); 
# 393
_InputOutputArray(std::vector< bool>  & vec) = delete;
# 394
template< class _Tp> inline _InputOutputArray(std::vector< std::vector< _Tp> >  & vec); 
# 395
template< class _Tp> inline _InputOutputArray(std::vector< Mat_< _Tp> >  & vec); 
# 396
template< class _Tp> inline _InputOutputArray(Mat_< _Tp>  & m); 
# 397
template< class _Tp> inline _InputOutputArray(_Tp * vec, int n); 
# 398
template< class _Tp, int m, int n> inline _InputOutputArray(Matx< _Tp, m, n>  & matx); 
# 399
inline _InputOutputArray(UMat & m); 
# 400
inline _InputOutputArray(std::vector< UMat>  & vec); 
# 402
inline _InputOutputArray(const Mat & m); 
# 403
inline _InputOutputArray(const std::vector< Mat>  & vec); 
# 404
inline _InputOutputArray(const cuda::GpuMat & d_mat); 
# 405
inline _InputOutputArray(const std::vector< cuda::GpuMat>  & d_mat); 
# 406
inline _InputOutputArray(const ogl::Buffer & buf); 
# 407
inline _InputOutputArray(const cuda::HostMem & cuda_mem); 
# 408
template< class _Tp> _InputOutputArray(const cudev::GpuMat_< _Tp>  & m); 
# 409
template< class _Tp> inline _InputOutputArray(const std::vector< _Tp>  & vec); 
# 410
template< class _Tp> inline _InputOutputArray(const std::vector< std::vector< _Tp> >  & vec); 
# 411
template< class _Tp> inline _InputOutputArray(const std::vector< Mat_< _Tp> >  & vec); 
# 412
template< class _Tp> inline _InputOutputArray(const Mat_< _Tp>  & m); 
# 413
template< class _Tp> inline _InputOutputArray(const _Tp * vec, int n); 
# 414
template< class _Tp, int m, int n> inline _InputOutputArray(const Matx< _Tp, m, n>  & matx); 
# 415
inline _InputOutputArray(const UMat & m); 
# 416
inline _InputOutputArray(const std::vector< UMat>  & vec); 
# 418
template< class _Tp, std::size_t _Nm> inline _InputOutputArray(std::array< _Tp, _Nm>  & arr); 
# 419
template< class _Tp, std::size_t _Nm> inline _InputOutputArray(const std::array< _Tp, _Nm>  & arr); 
# 420
template< std::size_t _Nm> inline _InputOutputArray(std::array< Mat, _Nm>  & arr); 
# 421
template< std::size_t _Nm> inline _InputOutputArray(const std::array< Mat, _Nm>  & arr); 
# 423
template< class _Tp> static inline _InputOutputArray rawInOut(std::vector< _Tp>  & vec); 
# 424
template< class _Tp, std::size_t _Nm> inline _InputOutputArray rawInOut(std::array< _Tp, _Nm>  & arr); 
# 426
}; 
# 429
template< class _Tp> static inline _InputArray rawIn(_Tp & v); 
# 431
template< class _Tp> static inline _OutputArray rawOut(_Tp & v); 
# 433
template< class _Tp> static inline _InputOutputArray rawInOut(_Tp & v); 
# 437
typedef const _InputArray &InputArray; 
# 438
typedef InputArray InputArrayOfArrays; 
# 439
typedef const _OutputArray &OutputArray; 
# 440
typedef OutputArray OutputArrayOfArrays; 
# 441
typedef const _InputOutputArray &InputOutputArray; 
# 442
typedef InputOutputArray InputOutputArrayOfArrays; 
# 444
InputOutputArray noArray(); 
# 449
enum UMatUsageFlags { 
# 451
USAGE_DEFAULT, 
# 454
USAGE_ALLOCATE_HOST_MEMORY, 
# 455
USAGE_ALLOCATE_DEVICE_MEMORY, 
# 456
USAGE_ALLOCATE_SHARED_MEMORY = (1 << 2), 
# 458
__UMAT_USAGE_FLAGS_32BIT = 2147483647
# 459
}; 
# 461
struct UMatData; 
# 465
class MatAllocator { 
# 468
public: MatAllocator() { } 
# 469
virtual ~MatAllocator() { } 
# 475
virtual UMatData *allocate(int dims, const int * sizes, int type, void * data, size_t * step, AccessFlag flags, UMatUsageFlags usageFlags) const = 0; 
# 477
virtual bool allocate(UMatData * data, AccessFlag accessflags, UMatUsageFlags usageFlags) const = 0; 
# 478
virtual void deallocate(UMatData * data) const = 0; 
# 479
virtual void map(UMatData * data, AccessFlag accessflags) const; 
# 480
virtual void unmap(UMatData * data) const; 
# 481
virtual void download(UMatData * data, void * dst, int dims, const size_t  sz[], const size_t  srcofs[], const size_t  srcstep[], const size_t  dststep[]) const; 
# 484
virtual void upload(UMatData * data, const void * src, int dims, const size_t  sz[], const size_t  dstofs[], const size_t  dststep[], const size_t  srcstep[]) const; 
# 487
virtual void copy(UMatData * srcdata, UMatData * dstdata, int dims, const size_t  sz[], const size_t  srcofs[], const size_t  srcstep[], const size_t  dstofs[], const size_t  dststep[], bool sync) const; 
# 492
virtual BufferPoolController *getBufferPoolController(const char * id = 0) const; 
# 493
}; 
# 510 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> class MatCommaInitializer_ { 
# 514
public: inline MatCommaInitializer_(Mat_< _Tp>  * _m); 
# 516
template< class T2> inline MatCommaInitializer_ &operator,(T2 v); 
# 518
inline operator Mat_< _Tp> () const; 
# 520
protected: MatIterator_< _Tp>  it; 
# 521
}; 
# 530 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
struct UMatData { 
# 532
enum MemoryFlag { COPY_ON_MAP = 1, HOST_COPY_OBSOLETE, 
# 533
DEVICE_COPY_OBSOLETE = 4, TEMP_UMAT = 8, TEMP_COPIED_UMAT = 24, 
# 534
USER_ALLOCATED = 32, DEVICE_MEM_MAPPED = 64, 
# 535
ASYNC_CLEANUP = 128
# 536
}; 
# 537
UMatData(const MatAllocator * allocator); 
# 538
~UMatData(); 
# 541
void lock(); 
# 542
void unlock(); 
# 544
inline bool hostCopyObsolete() const; 
# 545
inline bool deviceCopyObsolete() const; 
# 546
inline bool deviceMemMapped() const; 
# 547
inline bool copyOnMap() const; 
# 548
inline bool tempUMat() const; 
# 549
inline bool tempCopiedUMat() const; 
# 550
inline void markHostCopyObsolete(bool flag); 
# 551
inline void markDeviceCopyObsolete(bool flag); 
# 552
inline void markDeviceMemMapped(bool flag); 
# 554
const MatAllocator *prevAllocator; 
# 555
const MatAllocator *currAllocator; 
# 556
int urefcount; 
# 557
int refcount; 
# 558
uchar *data; 
# 559
uchar *origdata; 
# 560
size_t size; 
# 562
MemoryFlag flags; 
# 563
void *handle; 
# 564
void *userdata; 
# 565
int allocatorFlags_; 
# 566
int mapcount; 
# 567
UMatData *originalUMatData; 
# 568
}; 
# 569
static inline bool operator!(const UMatData::MemoryFlag &val) { typedef std::underlying_type< UMatData::MemoryFlag> ::type UnderlyingType; return !(static_cast< UnderlyingType>(val)); } static inline bool operator==(const UMatData::MemoryFlag &a, const int &b) { return (static_cast< int>(a)) == (static_cast< int>(b)); } static inline bool operator!=(const UMatData::MemoryFlag &a, const int &b) { return (static_cast< int>(a)) != (static_cast< int>(b)); } static inline UMatData::MemoryFlag operator~(const UMatData::MemoryFlag &val) { typedef std::underlying_type< UMatData::MemoryFlag> ::type UnderlyingType; return static_cast< UMatData::MemoryFlag>(~(static_cast< UnderlyingType>(val))); } static inline UMatData::MemoryFlag operator|(const UMatData::MemoryFlag &a, const UMatData::MemoryFlag &b) { typedef std::underlying_type< UMatData::MemoryFlag> ::type UnderlyingType; return static_cast< UMatData::MemoryFlag>((static_cast< UnderlyingType>(a)) | (static_cast< UnderlyingType>(b))); } static inline UMatData::MemoryFlag operator&(const UMatData::MemoryFlag &a, const UMatData::MemoryFlag &b) { typedef std::underlying_type< UMatData::MemoryFlag> ::type UnderlyingType; return static_cast< UMatData::MemoryFlag>((static_cast< UnderlyingType>(a)) & (static_cast< UnderlyingType>(b))); } static inline UMatData::MemoryFlag operator^(const UMatData::MemoryFlag &a, const UMatData::MemoryFlag &b) { typedef std::underlying_type< UMatData::MemoryFlag> ::type UnderlyingType; return static_cast< UMatData::MemoryFlag>((static_cast< UnderlyingType>(a)) ^ (static_cast< UnderlyingType>(b))); } static inline UMatData::MemoryFlag &operator|=(UMatData::MemoryFlag &_this, const UMatData::MemoryFlag &val) { _this = (static_cast< UMatData::MemoryFlag>((static_cast< int>(_this)) | (static_cast< int>(val)))); return _this; } static inline UMatData::MemoryFlag &operator&=(UMatData::MemoryFlag &_this, const UMatData::MemoryFlag &val) { _this = (static_cast< UMatData::MemoryFlag>((static_cast< int>(_this)) & (static_cast< int>(val)))); return _this; } static inline UMatData::MemoryFlag &operator^=(UMatData::MemoryFlag &_this, const UMatData::MemoryFlag &val) { _this = (static_cast< UMatData::MemoryFlag>((static_cast< int>(_this)) ^ (static_cast< int>(val)))); return _this; } 
# 572
struct MatSize { 
# 574
inline explicit MatSize(int * _p); 
# 575
inline int dims() const; 
# 576
inline Size operator()() const; 
# 577
inline const int &operator[](int i) const; 
# 578
inline int &operator[](int i); 
# 579
inline operator const int *() const; 
# 580
inline bool operator==(const MatSize & sz) const; 
# 581
inline bool operator!=(const MatSize & sz) const; 
# 583
int *p; 
# 584
}; 
# 586
struct MatStep { 
# 588
inline MatStep(); 
# 589
inline explicit MatStep(size_t s); 
# 590
inline const size_t &operator[](int i) const; 
# 591
inline size_t &operator[](int i); 
# 592
inline operator size_t() const; 
# 593
inline MatStep &operator=(size_t s); 
# 595
size_t *p; 
# 596
size_t buf[2]; 
# 598
protected: MatStep &operator=(const MatStep &); 
# 599
}; 
# 791 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
class Mat { 
# 800
public: inline Mat(); 
# 808
inline Mat(int rows, int cols, int type); 
# 816
inline Mat(Size size, int type); 
# 827 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat(int rows, int cols, int type, const Scalar & s); 
# 838 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat(Size size, int type, const Scalar & s); 
# 846
inline Mat(int ndims, const int * sizes, int type); 
# 853
inline Mat(const std::vector< int>  & sizes, int type); 
# 864 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat(int ndims, const int * sizes, int type, const Scalar & s); 
# 874 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat(const std::vector< int>  & sizes, int type, const Scalar & s); 
# 884 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat(const Mat & m); 
# 900 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat(int rows, int cols, int type, void * data, size_t step = AUTO_STEP); 
# 916 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat(Size size, int type, void * data, size_t step = AUTO_STEP); 
# 931 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat(int ndims, const int * sizes, int type, void * data, const size_t * steps = 0); 
# 945 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat(const std::vector< int>  & sizes, int type, void * data, const size_t * steps = 0); 
# 957 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat(const Mat & m, const Range & rowRange, const Range & colRange = Range::all()); 
# 967 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat(const Mat & m, const Rect & roi); 
# 977 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat(const Mat & m, const Range * ranges); 
# 987 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat(const Mat & m, const std::vector< Range>  & ranges); 
# 1005 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> inline explicit Mat(const std::vector< _Tp>  & vec, bool copyData = false); 
# 1009
template< class _Tp, class  = typename std::enable_if< std::is_arithmetic< _Tp> ::value> ::type> inline explicit Mat(const std::initializer_list< _Tp>  list); 
# 1014
template< class _Tp> inline explicit Mat(const std::initializer_list< int>  sizes, const std::initializer_list< _Tp>  list); 
# 1018
template< class _Tp, size_t _Nm> inline explicit Mat(const std::array< _Tp, _Nm>  & arr, bool copyData = false); 
# 1022
template< class _Tp, int n> inline explicit Mat(const Vec< _Tp, n>  & vec, bool copyData = true); 
# 1026
template< class _Tp, int m, int n> inline explicit Mat(const Matx< _Tp, m, n>  & mtx, bool copyData = true); 
# 1030
template< class _Tp> inline explicit Mat(const Point_< _Tp>  & pt, bool copyData = true); 
# 1034
template< class _Tp> inline explicit Mat(const Point3_< _Tp>  & pt, bool copyData = true); 
# 1038
template< class _Tp> inline explicit Mat(const MatCommaInitializer_< _Tp>  & commaInitializer); 
# 1041
inline explicit Mat(const cuda::GpuMat & m); 
# 1044
inline ~Mat(); 
# 1054 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat &operator=(const Mat & m); 
# 1063 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat &operator=(const MatExpr & expr); 
# 1066
UMat getUMat(AccessFlag accessFlags, UMatUsageFlags usageFlags = USAGE_DEFAULT) const; 
# 1101 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat row(int y) const; 
# 1110 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat col(int x) const; 
# 1119 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat rowRange(int startrow, int endrow) const; 
# 1124
inline Mat rowRange(const Range & r) const; 
# 1133 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat colRange(int startcol, int endcol) const; 
# 1138
inline Mat colRange(const Range & r) const; 
# 1174 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat diag(int d = 0) const; 
# 1181
static Mat diag(const Mat & d); 
# 1188
inline Mat clone() const __attribute((__warn_unused_result__)); 
# 1205 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
void copyTo(OutputArray m) const; 
# 1213
void copyTo(OutputArray m, InputArray mask) const; 
# 1228 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
void convertTo(OutputArray m, int rtype, double alpha = 1, double beta = 0) const; 
# 1236
inline void assignTo(Mat & m, int type = -1) const; 
# 1241
Mat &operator=(const Scalar & s); 
# 1250 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat &setTo(InputArray value, InputArray mask = noArray()); 
# 1276 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat reshape(int cn, int rows = 0) const; 
# 1279
Mat reshape(int cn, int newndims, const int * newsz) const; 
# 1282
Mat reshape(int cn, const std::vector< int>  & newshape) const; 
# 1294 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
MatExpr t() const; 
# 1303 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
MatExpr inv(int method = DECOMP_LU) const; 
# 1317 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
MatExpr mul(InputArray m, double scale = 1) const; 
# 1326 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat cross(InputArray m) const; 
# 1336 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
double dot(InputArray m) const; 
# 1352 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
static MatExpr zeros(int rows, int cols, int type); 
# 1358
static MatExpr zeros(Size size, int type); 
# 1365
static MatExpr zeros(int ndims, const int * sz, int type); 
# 1383 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
static MatExpr ones(int rows, int cols, int type); 
# 1389
static MatExpr ones(Size size, int type); 
# 1396
static MatExpr ones(int ndims, const int * sz, int type); 
# 1412 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
static MatExpr eye(int rows, int cols, int type); 
# 1418
static MatExpr eye(Size size, int type); 
# 1453 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline void create(int rows, int cols, int type); 
# 1459
inline void create(Size size, int type); 
# 1466
void create(int ndims, const int * sizes, int type); 
# 1472
void create(const std::vector< int>  & sizes, int type); 
# 1483 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline void addref(); 
# 1498 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline void release(); 
# 1501
void deallocate(); 
# 1503
void copySize(const Mat & m); 
# 1512 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
void reserve(size_t sz); 
# 1520
void reserveBuffer(size_t sz); 
# 1529 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
void resize(size_t sz); 
# 1535
void resize(size_t sz, const Scalar & s); 
# 1538
void push_back_(const void * elem); 
# 1547 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> inline void push_back(const _Tp & elem); 
# 1552
template< class _Tp> inline void push_back(const Mat_< _Tp>  & elem); 
# 1557
template< class _Tp> inline void push_back(const std::vector< _Tp>  & elem); 
# 1562
void push_back(const Mat & m); 
# 1570
void pop_back(size_t nelems = 1); 
# 1583 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
void locateROI(Size & wholeSize, Point & ofs) const; 
# 1612 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
Mat &adjustROI(int dtop, int dbottom, int dleft, int dright); 
# 1625 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline Mat operator()(Range rowRange, Range colRange) const; 
# 1630
inline Mat operator()(const Rect & roi) const; 
# 1635
inline Mat operator()(const Range * ranges) const; 
# 1640
inline Mat operator()(const std::vector< Range>  & ranges) const; 
# 1642
template< class _Tp> inline operator std::vector< _Tp> () const; 
# 1643
template< class _Tp, int n> inline operator Vec< _Tp, n> () const; 
# 1644
template< class _Tp, int m, int n> inline operator Matx< _Tp, m, n> () const; 
# 1646
template< class _Tp, std::size_t _Nm> inline operator std::array< _Tp, _Nm> () const; 
# 1722 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline bool isContinuous() const; 
# 1725
inline bool isSubmatrix() const; 
# 1732
inline size_t elemSize() const; 
# 1739
inline size_t elemSize1() const; 
# 1746
inline int type() const; 
# 1761 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
inline int depth() const; 
# 1767
inline int channels() const; 
# 1774
inline size_t step1(int i = 0) const; 
# 1781
inline bool empty() const; 
# 1788
inline size_t total() const; 
# 1794
inline size_t total(int startDim, int endDim = 2147483647) const; 
# 1817 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
int checkVector(int elemChannels, int depth = -1, bool requireContinuous = true) const; 
# 1825
inline uchar *ptr(int i0 = 0); 
# 1827
inline const uchar *ptr(int i0 = 0) const; 
# 1833
inline uchar *ptr(int row, int col); 
# 1838
inline const uchar *ptr(int row, int col) const; 
# 1841
inline uchar *ptr(int i0, int i1, int i2); 
# 1843
inline const uchar *ptr(int i0, int i1, int i2) const; 
# 1846
inline uchar *ptr(const int * idx); 
# 1848
inline const uchar *ptr(const int * idx) const; 
# 1850
template< int n> uchar *ptr(const Vec< int, n>  & idx); 
# 1852
template< int n> const uchar *ptr(const Vec< int, n>  & idx) const; 
# 1855
template< class _Tp> inline _Tp *ptr(int i0 = 0); 
# 1857
template< class _Tp> inline const _Tp *ptr(int i0 = 0) const; 
# 1862
template< class _Tp> inline _Tp *ptr(int row, int col); 
# 1867
template< class _Tp> inline const _Tp *ptr(int row, int col) const; 
# 1869
template< class _Tp> inline _Tp *ptr(int i0, int i1, int i2); 
# 1871
template< class _Tp> inline const _Tp *ptr(int i0, int i1, int i2) const; 
# 1873
template< class _Tp> inline _Tp *ptr(const int * idx); 
# 1875
template< class _Tp> inline const _Tp *ptr(const int * idx) const; 
# 1877
template< class _Tp, int n> _Tp *ptr(const Vec< int, n>  & idx); 
# 1879
template< class _Tp, int n> const _Tp *ptr(const Vec< int, n>  & idx) const; 
# 1911 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> inline _Tp &at(int i0 = 0); 
# 1915
template< class _Tp> inline const _Tp &at(int i0 = 0) const; 
# 1920
template< class _Tp> inline _Tp &at(int row, int col); 
# 1925
template< class _Tp> inline const _Tp &at(int row, int col) const; 
# 1932
template< class _Tp> inline _Tp &at(int i0, int i1, int i2); 
# 1938
template< class _Tp> inline const _Tp &at(int i0, int i1, int i2) const; 
# 1943
template< class _Tp> inline _Tp &at(const int * idx); 
# 1947
template< class _Tp> inline const _Tp &at(const int * idx) const; 
# 1950
template< class _Tp, int n> inline _Tp &at(const Vec< int, n>  & idx); 
# 1952
template< class _Tp, int n> inline const _Tp &at(const Vec< int, n>  & idx) const; 
# 1958
template< class _Tp> inline _Tp &at(Point pt); 
# 1963
template< class _Tp> inline const _Tp &at(Point pt) const; 
# 2001 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> inline MatIterator_< _Tp>  begin(); 
# 2002
template< class _Tp> inline MatConstIterator_< _Tp>  begin() const; 
# 2009
template< class _Tp> inline MatIterator_< _Tp>  end(); 
# 2010
template< class _Tp> inline MatConstIterator_< _Tp>  end() const; 
# 2066 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp, class Functor> inline void forEach(const Functor & operation); 
# 2068
template< class _Tp, class Functor> inline void forEach(const Functor & operation) const; 
# 2070
inline Mat(Mat && m); 
# 2071
inline Mat &operator=(Mat && m); 
# 2073
enum { MAGIC_VAL = 1124007936, AUTO_STEP = 0, CONTINUOUS_FLAG = (1 << 14), SUBMATRIX_FLAG = (1 << 15)}; 
# 2074
enum { MAGIC_MASK = 4294901760U, TYPE_MASK = 4095U, DEPTH_MASK = 7U}; 
# 2082
int flags; 
# 2084
int dims; 
# 2086
int rows, cols; 
# 2088
uchar *data; 
# 2091
const uchar *datastart; 
# 2092
const uchar *dataend; 
# 2093
const uchar *datalimit; 
# 2096
MatAllocator *allocator; 
# 2098
static MatAllocator *getStdAllocator(); 
# 2099
static MatAllocator *getDefaultAllocator(); 
# 2100
static void setDefaultAllocator(MatAllocator * allocator); 
# 2103
void updateContinuityFlag(); 
# 2106
UMatData *u; 
# 2108
MatSize size; 
# 2109
MatStep step; 
# 2112
protected: template< class _Tp, class Functor> inline void forEach_impl(const Functor & operation); 
# 2113
}; 
# 2177 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> class Mat_ : public Mat { 
# 2180
public: typedef _Tp value_type; 
# 2181
typedef typename DataType< _Tp> ::channel_type channel_type; 
# 2182
typedef MatIterator_< _Tp>  iterator; 
# 2183
typedef MatConstIterator_< _Tp>  const_iterator; 
# 2186
inline Mat_(); 
# 2188
inline Mat_(int _rows, int _cols); 
# 2190
inline Mat_(int _rows, int _cols, const _Tp & value); 
# 2192
inline explicit Mat_(Size _size); 
# 2194
inline Mat_(Size _size, const _Tp & value); 
# 2196
inline Mat_(int _ndims, const int * _sizes); 
# 2198
inline Mat_(int _ndims, const int * _sizes, const _Tp & value); 
# 2200
inline Mat_(const Mat & m); 
# 2202
inline Mat_(const Mat_ & m); 
# 2204
inline Mat_(int _rows, int _cols, _Tp * _data, size_t _step = AUTO_STEP); 
# 2206
inline Mat_(int _ndims, const int * _sizes, _Tp * _data, const size_t * _steps = 0); 
# 2208
inline Mat_(const Mat_ & m, const Range & rowRange, const Range & colRange = Range::all()); 
# 2210
inline Mat_(const Mat_ & m, const Rect & roi); 
# 2212
inline Mat_(const Mat_ & m, const Range * ranges); 
# 2214
inline Mat_(const Mat_ & m, const std::vector< Range>  & ranges); 
# 2216
inline explicit Mat_(const MatExpr & e); 
# 2218
inline explicit Mat_(const std::vector< _Tp>  & vec, bool copyData = false); 
# 2219
template< int n> inline explicit Mat_(const Vec< typename DataType< _Tp> ::channel_type, n>  & vec, bool copyData = true); 
# 2220
template< int m, int n> inline explicit Mat_(const Matx< typename DataType< _Tp> ::channel_type, m, n>  & mtx, bool copyData = true); 
# 2221
inline explicit Mat_(const Point_< typename DataType< _Tp> ::channel_type>  & pt, bool copyData = true); 
# 2222
inline explicit Mat_(const Point3_< typename DataType< _Tp> ::channel_type>  & pt, bool copyData = true); 
# 2223
inline explicit Mat_(const MatCommaInitializer_< _Tp>  & commaInitializer); 
# 2225
inline Mat_(std::initializer_list< _Tp>  values); 
# 2226
inline explicit Mat_(const std::initializer_list< std::vector< int> ::value_type>  sizes, const std::initializer_list< _Tp>  values); 
# 2228
template< std::size_t _Nm> inline explicit Mat_(const std::array< _Tp, _Nm>  & arr, bool copyData = false); 
# 2230
inline Mat_ &operator=(const Mat & m); 
# 2231
inline Mat_ &operator=(const Mat_ & m); 
# 2233
inline Mat_ &operator=(const _Tp & s); 
# 2235
inline Mat_ &operator=(const MatExpr & e); 
# 2238
inline iterator begin(); 
# 2239
inline iterator end(); 
# 2240
inline const_iterator begin() const; 
# 2241
inline const_iterator end() const; 
# 2245
template< class Functor> inline void forEach(const Functor & operation); 
# 2246
template< class Functor> inline void forEach(const Functor & operation) const; 
# 2249
inline void create(int _rows, int _cols); 
# 2251
inline void create(Size _size); 
# 2253
inline void create(int _ndims, const int * _sizes); 
# 2255
inline void release(); 
# 2257
inline Mat_ cross(const Mat_ & m) const; 
# 2259
template< class T2> inline operator Mat_< T2> () const; 
# 2261
inline Mat_ row(int y) const; 
# 2262
inline Mat_ col(int x) const; 
# 2263
inline Mat_ diag(int d = 0) const; 
# 2264
inline Mat_ clone() const __attribute((__warn_unused_result__)); 
# 2267
inline size_t elemSize() const; 
# 2268
inline size_t elemSize1() const; 
# 2269
inline int type() const; 
# 2270
inline int depth() const; 
# 2271
inline int channels() const; 
# 2272
inline size_t step1(int i = 0) const; 
# 2274
inline size_t stepT(int i = 0) const; 
# 2277
static inline MatExpr zeros(int rows, int cols); 
# 2278
static inline MatExpr zeros(Size size); 
# 2279
static MatExpr zeros(int _ndims, const int * _sizes); 
# 2280
static inline MatExpr ones(int rows, int cols); 
# 2281
static inline MatExpr ones(Size size); 
# 2282
static MatExpr ones(int _ndims, const int * _sizes); 
# 2283
static inline MatExpr eye(int rows, int cols); 
# 2284
static inline MatExpr eye(Size size); 
# 2287
inline Mat_ &adjustROI(int dtop, int dbottom, int dleft, int dright); 
# 2288
inline Mat_ operator()(const Range & rowRange, const Range & colRange) const; 
# 2289
inline Mat_ operator()(const Rect & roi) const; 
# 2290
inline Mat_ operator()(const Range * ranges) const; 
# 2291
inline Mat_ operator()(const std::vector< Range>  & ranges) const; 
# 2294
inline _Tp *operator[](int y); 
# 2295
inline const _Tp *operator[](int y) const; 
# 2298
inline _Tp &operator()(const int * idx); 
# 2300
inline const _Tp &operator()(const int * idx) const; 
# 2303
template< int n> inline _Tp &operator()(const Vec< int, n>  & idx); 
# 2305
template< int n> inline const _Tp &operator()(const Vec< int, n>  & idx) const; 
# 2308
inline _Tp &operator()(int idx0); 
# 2310
inline const _Tp &operator()(int idx0) const; 
# 2312
inline _Tp &operator()(int row, int col); 
# 2314
inline const _Tp &operator()(int row, int col) const; 
# 2316
inline _Tp &operator()(int idx0, int idx1, int idx2); 
# 2318
inline const _Tp &operator()(int idx0, int idx1, int idx2) const; 
# 2320
inline _Tp &operator()(Point pt); 
# 2321
inline const _Tp &operator()(Point pt) const; 
# 2324
inline operator std::vector< _Tp> () const; 
# 2327
template< std::size_t _Nm> inline operator std::array< _Tp, _Nm> () const; 
# 2330
template< int n> inline operator Vec< typename DataType< _Tp> ::channel_type, n> () const; 
# 2332
template< int m, int n> inline operator Matx< typename DataType< _Tp> ::channel_type, m, n> () const; 
# 2334
inline Mat_(Mat_ && m); 
# 2335
inline Mat_ &operator=(Mat_ && m); 
# 2337
inline Mat_(Mat && m); 
# 2338
inline Mat_ &operator=(Mat && m); 
# 2340
inline Mat_(MatExpr && e); 
# 2341
}; 
# 2343
typedef Mat_< unsigned char>  Mat1b; 
# 2344
typedef Mat_< Vec< unsigned char, 2> >  Mat2b; 
# 2345
typedef Mat_< Vec< unsigned char, 3> >  Mat3b; 
# 2346
typedef Mat_< Vec< unsigned char, 4> >  Mat4b; 
# 2348
typedef Mat_< short>  Mat1s; 
# 2349
typedef Mat_< Vec< short, 2> >  Mat2s; 
# 2350
typedef Mat_< Vec< short, 3> >  Mat3s; 
# 2351
typedef Mat_< Vec< short, 4> >  Mat4s; 
# 2353
typedef Mat_< unsigned short>  Mat1w; 
# 2354
typedef Mat_< Vec< unsigned short, 2> >  Mat2w; 
# 2355
typedef Mat_< Vec< unsigned short, 3> >  Mat3w; 
# 2356
typedef Mat_< Vec< unsigned short, 4> >  Mat4w; 
# 2358
typedef Mat_< int>  Mat1i; 
# 2359
typedef Mat_< Vec< int, 2> >  Mat2i; 
# 2360
typedef Mat_< Vec< int, 3> >  Mat3i; 
# 2361
typedef Mat_< Vec< int, 4> >  Mat4i; 
# 2363
typedef Mat_< float>  Mat1f; 
# 2364
typedef Mat_< Vec< float, 2> >  Mat2f; 
# 2365
typedef Mat_< Vec< float, 3> >  Mat3f; 
# 2366
typedef Mat_< Vec< float, 4> >  Mat4f; 
# 2368
typedef Mat_< double>  Mat1d; 
# 2369
typedef Mat_< Vec< double, 2> >  Mat2d; 
# 2370
typedef Mat_< Vec< double, 3> >  Mat3d; 
# 2371
typedef Mat_< Vec< double, 4> >  Mat4d; 
# 2374
class UMat { 
# 2378
public: inline UMat(UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2381
inline UMat(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2382
inline UMat(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2384
inline UMat(int rows, int cols, int type, const Scalar & s, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2385
inline UMat(Size size, int type, const Scalar & s, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2388
inline UMat(int ndims, const int * sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2389
inline UMat(int ndims, const int * sizes, int type, const Scalar & s, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2392
inline UMat(const UMat & m); 
# 2395
UMat(const UMat & m, const Range & rowRange, const Range & colRange = Range::all()); 
# 2396
UMat(const UMat & m, const Rect & roi); 
# 2397
UMat(const UMat & m, const Range * ranges); 
# 2398
UMat(const UMat & m, const std::vector< Range>  & ranges); 
# 2400
template< class _Tp> inline explicit UMat(const std::vector< _Tp>  & vec, bool copyData = false); 
# 2403
template< class _Tp, int n> explicit UMat(const Vec< _Tp, n>  & vec, bool copyData = true); 
# 2405
template< class _Tp, int m, int n> explicit UMat(const Matx< _Tp, m, n>  & mtx, bool copyData = true); 
# 2407
template< class _Tp> explicit UMat(const Point_< _Tp>  & pt, bool copyData = true); 
# 2409
template< class _Tp> explicit UMat(const Point3_< _Tp>  & pt, bool copyData = true); 
# 2411
template< class _Tp> explicit UMat(const MatCommaInitializer_< _Tp>  & commaInitializer); 
# 2414
~UMat(); 
# 2416
inline UMat &operator=(const UMat & m); 
# 2418
Mat getMat(AccessFlag flags) const; 
# 2421
inline UMat row(int y) const; 
# 2423
inline UMat col(int x) const; 
# 2425
inline UMat rowRange(int startrow, int endrow) const; 
# 2426
inline UMat rowRange(const Range & r) const; 
# 2428
inline UMat colRange(int startcol, int endcol) const; 
# 2429
inline UMat colRange(const Range & r) const; 
# 2434
UMat diag(int d = 0) const; 
# 2436
static UMat diag(const UMat & d); 
# 2439
inline UMat clone() const __attribute((__warn_unused_result__)); 
# 2442
void copyTo(OutputArray m) const; 
# 2444
void copyTo(OutputArray m, InputArray mask) const; 
# 2446
void convertTo(OutputArray m, int rtype, double alpha = 1, double beta = 0) const; 
# 2448
inline void assignTo(UMat & m, int type = -1) const; 
# 2451
UMat &operator=(const Scalar & s); 
# 2453
UMat &setTo(InputArray value, InputArray mask = noArray()); 
# 2456
UMat reshape(int cn, int rows = 0) const; 
# 2457
UMat reshape(int cn, int newndims, const int * newsz) const; 
# 2460
UMat t() const; 
# 2462
UMat inv(int method = DECOMP_LU) const; 
# 2464
UMat mul(InputArray m, double scale = 1) const; 
# 2467
double dot(InputArray m) const; 
# 2470
static UMat zeros(int rows, int cols, int type); 
# 2471
static UMat zeros(Size size, int type); 
# 2472
static UMat zeros(int ndims, const int * sz, int type); 
# 2473
static UMat ones(int rows, int cols, int type); 
# 2474
static UMat ones(Size size, int type); 
# 2475
static UMat ones(int ndims, const int * sz, int type); 
# 2476
static UMat eye(int rows, int cols, int type); 
# 2477
static UMat eye(Size size, int type); 
# 2481
inline void create(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2482
inline void create(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2483
void create(int ndims, const int * sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2484
void create(const std::vector< int>  & sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT); 
# 2487
inline void addref(); 
# 2490
inline void release(); 
# 2493
void deallocate(); 
# 2495
void copySize(const UMat & m); 
# 2498
void locateROI(Size & wholeSize, Point & ofs) const; 
# 2500
UMat &adjustROI(int dtop, int dbottom, int dleft, int dright); 
# 2503
inline UMat operator()(Range rowRange, Range colRange) const; 
# 2504
inline UMat operator()(const Rect & roi) const; 
# 2505
inline UMat operator()(const Range * ranges) const; 
# 2506
inline UMat operator()(const std::vector< Range>  & ranges) const; 
# 2511
inline bool isContinuous() const; 
# 2514
inline bool isSubmatrix() const; 
# 2518
inline size_t elemSize() const; 
# 2520
inline size_t elemSize1() const; 
# 2522
inline int type() const; 
# 2524
inline int depth() const; 
# 2526
inline int channels() const; 
# 2528
inline size_t step1(int i = 0) const; 
# 2530
inline bool empty() const; 
# 2532
inline size_t total() const; 
# 2535
int checkVector(int elemChannels, int depth = -1, bool requireContinuous = true) const; 
# 2537
inline UMat(UMat && m); 
# 2538
inline UMat &operator=(UMat && m); 
# 2544
void *handle(AccessFlag accessFlags) const; 
# 2545
void ndoffset(size_t * ofs) const; 
# 2547
enum { MAGIC_VAL = 1124007936, AUTO_STEP = 0, CONTINUOUS_FLAG = (1 << 14), SUBMATRIX_FLAG = (1 << 15)}; 
# 2548
enum { MAGIC_MASK = 4294901760U, TYPE_MASK = 4095U, DEPTH_MASK = 7U}; 
# 2556
int flags; 
# 2558
int dims; 
# 2560
int rows, cols; 
# 2563
MatAllocator *allocator; 
# 2564
UMatUsageFlags usageFlags; 
# 2566
static MatAllocator *getStdAllocator(); 
# 2569
void updateContinuityFlag(); 
# 2572
UMatData *u; 
# 2575
size_t offset; 
# 2577
MatSize size; 
# 2578
MatStep step; 
# 2581
}; 
# 2665 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
class SparseMat { 
# 2668
public: typedef SparseMatIterator iterator; 
# 2669
typedef SparseMatConstIterator const_iterator; 
# 2671
enum { MAGIC_VAL = 1123876864U, MAX_DIM = 32U, HASH_SCALE = 1540483477U, HASH_BIT = 2147483648U}; 
# 2674
struct Hdr { 
# 2676
Hdr(int _dims, const int * _sizes, int _type); 
# 2677
void clear(); 
# 2678
int refcount; 
# 2679
int dims; 
# 2680
int valueOffset; 
# 2681
size_t nodeSize; 
# 2682
size_t nodeCount; 
# 2683
size_t freeList; 
# 2684
std::vector< unsigned char>  pool; 
# 2685
std::vector< unsigned long>  hashtab; 
# 2686
int size[MAX_DIM]; 
# 2687
}; 
# 2690
struct Node { 
# 2693
size_t hashval; 
# 2695
size_t next; 
# 2697
int idx[MAX_DIM]; 
# 2698
}; 
# 2702
inline SparseMat(); 
# 2709
inline SparseMat(int dims, const int * _sizes, int _type); 
# 2715
inline SparseMat(const SparseMat & m); 
# 2721
explicit SparseMat(const Mat & m); 
# 2724
inline ~SparseMat(); 
# 2727
inline SparseMat &operator=(const SparseMat & m); 
# 2729
inline SparseMat &operator=(const Mat & m); 
# 2732
inline SparseMat clone() const __attribute((__warn_unused_result__)); 
# 2735
void copyTo(SparseMat & m) const; 
# 2737
void copyTo(Mat & m) const; 
# 2739
void convertTo(SparseMat & m, int rtype, double alpha = 1) const; 
# 2750 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
void convertTo(Mat & m, int rtype, double alpha = 1, double beta = 0) const; 
# 2753
inline void assignTo(SparseMat & m, int type = -1) const; 
# 2761
void create(int dims, const int * _sizes, int _type); 
# 2763
void clear(); 
# 2765
inline void addref(); 
# 2767
inline void release(); 
# 2772
inline size_t elemSize() const; 
# 2774
inline size_t elemSize1() const; 
# 2777
inline int type() const; 
# 2779
inline int depth() const; 
# 2781
inline int channels() const; 
# 2784
inline const int *size() const; 
# 2786
inline int size(int i) const; 
# 2788
inline int dims() const; 
# 2790
inline size_t nzcount() const; 
# 2793
inline size_t hash(int i0) const; 
# 2795
inline size_t hash(int i0, int i1) const; 
# 2797
inline size_t hash(int i0, int i1, int i2) const; 
# 2799
inline size_t hash(const int * idx) const; 
# 2813 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
uchar *ptr(int i0, bool createMissing, size_t * hashval = 0); 
# 2815
uchar *ptr(int i0, int i1, bool createMissing, size_t * hashval = 0); 
# 2817
uchar *ptr(int i0, int i1, int i2, bool createMissing, size_t * hashval = 0); 
# 2819
uchar *ptr(const int * idx, bool createMissing, size_t * hashval = 0); 
# 2831 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> inline _Tp &ref(int i0, size_t * hashval = 0); 
# 2833
template< class _Tp> inline _Tp &ref(int i0, int i1, size_t * hashval = 0); 
# 2835
template< class _Tp> inline _Tp &ref(int i0, int i1, int i2, size_t * hashval = 0); 
# 2837
template< class _Tp> inline _Tp &ref(const int * idx, size_t * hashval = 0); 
# 2852 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> inline _Tp value(int i0, size_t * hashval = 0) const; 
# 2854
template< class _Tp> inline _Tp value(int i0, int i1, size_t * hashval = 0) const; 
# 2856
template< class _Tp> inline _Tp value(int i0, int i1, int i2, size_t * hashval = 0) const; 
# 2858
template< class _Tp> inline _Tp value(const int * idx, size_t * hashval = 0) const; 
# 2870 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> inline const _Tp *find(int i0, size_t * hashval = 0) const; 
# 2872
template< class _Tp> inline const _Tp *find(int i0, int i1, size_t * hashval = 0) const; 
# 2874
template< class _Tp> inline const _Tp *find(int i0, int i1, int i2, size_t * hashval = 0) const; 
# 2876
template< class _Tp> inline const _Tp *find(const int * idx, size_t * hashval = 0) const; 
# 2880
void erase(int i0, int i1, size_t * hashval = 0); 
# 2882
void erase(int i0, int i1, int i2, size_t * hashval = 0); 
# 2884
void erase(const int * idx, size_t * hashval = 0); 
# 2891
inline SparseMatIterator begin(); 
# 2893
template< class _Tp> inline SparseMatIterator_< _Tp>  begin(); 
# 2895
inline SparseMatConstIterator begin() const; 
# 2897
template< class _Tp> inline SparseMatConstIterator_< _Tp>  begin() const; 
# 2903
inline SparseMatIterator end(); 
# 2905
inline SparseMatConstIterator end() const; 
# 2907
template< class _Tp> inline SparseMatIterator_< _Tp>  end(); 
# 2909
template< class _Tp> inline SparseMatConstIterator_< _Tp>  end() const; 
# 2912
template< class _Tp> inline _Tp &value(Node * n); 
# 2914
template< class _Tp> inline const _Tp &value(const Node * n) const; 
# 2917
inline Node *node(size_t nidx); 
# 2918
inline const Node *node(size_t nidx) const; 
# 2920
uchar *newNode(const int * idx, size_t hashval); 
# 2921
void removeNode(size_t hidx, size_t nidx, size_t previdx); 
# 2922
void resizeHashTab(size_t newsize); 
# 2924
int flags; 
# 2925
Hdr *hdr; 
# 2926
}; 
# 2943 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> class SparseMat_ : public SparseMat { 
# 2946
public: typedef SparseMatIterator_< _Tp>  iterator; 
# 2947
typedef SparseMatConstIterator_< _Tp>  const_iterator; 
# 2950
inline SparseMat_(); 
# 2952
inline SparseMat_(int dims, const int * _sizes); 
# 2954
inline SparseMat_(const SparseMat & m); 
# 2956
inline SparseMat_(const SparseMat_ & m); 
# 2958
inline SparseMat_(const Mat & m); 
# 2962
inline SparseMat_ &operator=(const SparseMat & m); 
# 2964
inline SparseMat_ &operator=(const SparseMat_ & m); 
# 2966
inline SparseMat_ &operator=(const Mat & m); 
# 2969
inline SparseMat_ clone() const __attribute((__warn_unused_result__)); 
# 2971
inline void create(int dims, const int * _sizes); 
# 2976
inline int type() const; 
# 2978
inline int depth() const; 
# 2980
inline int channels() const; 
# 2983
inline _Tp &ref(int i0, size_t * hashval = 0); 
# 2985
inline _Tp &ref(int i0, int i1, size_t * hashval = 0); 
# 2987
inline _Tp &ref(int i0, int i1, int i2, size_t * hashval = 0); 
# 2989
inline _Tp &ref(const int * idx, size_t * hashval = 0); 
# 2992
inline _Tp operator()(int i0, size_t * hashval = 0) const; 
# 2994
inline _Tp operator()(int i0, int i1, size_t * hashval = 0) const; 
# 2996
inline _Tp operator()(int i0, int i1, int i2, size_t * hashval = 0) const; 
# 2998
inline _Tp operator()(const int * idx, size_t * hashval = 0) const; 
# 3001
inline SparseMatIterator_< _Tp>  begin(); 
# 3003
inline SparseMatConstIterator_< _Tp>  begin() const; 
# 3005
inline SparseMatIterator_< _Tp>  end(); 
# 3007
inline SparseMatConstIterator_< _Tp>  end() const; 
# 3008
}; 
# 3014
class MatConstIterator { 
# 3017
public: typedef uchar *value_type; 
# 3018
typedef ptrdiff_t difference_type; 
# 3019
typedef const uchar **pointer; 
# 3020
typedef uchar *reference; 
# 3022
typedef std::random_access_iterator_tag iterator_category; 
# 3025
inline MatConstIterator(); 
# 3027
inline MatConstIterator(const Mat * _m); 
# 3029
inline MatConstIterator(const Mat * _m, int _row, int _col = 0); 
# 3031
inline MatConstIterator(const Mat * _m, Point _pt); 
# 3033
MatConstIterator(const Mat * _m, const int * _idx); 
# 3035
inline MatConstIterator(const MatConstIterator & it); 
# 3038
inline MatConstIterator &operator=(const MatConstIterator & it); 
# 3040
inline const uchar *operator*() const; 
# 3042
inline const uchar *operator[](ptrdiff_t i) const; 
# 3045
inline MatConstIterator &operator+=(ptrdiff_t ofs); 
# 3047
inline MatConstIterator &operator-=(ptrdiff_t ofs); 
# 3049
inline MatConstIterator &operator--(); 
# 3051
inline MatConstIterator operator--(int); 
# 3053
inline MatConstIterator &operator++(); 
# 3055
inline MatConstIterator operator++(int); 
# 3057
Point pos() const; 
# 3059
void pos(int * _idx) const; 
# 3061
ptrdiff_t lpos() const; 
# 3062
void seek(ptrdiff_t ofs, bool relative = false); 
# 3063
void seek(const int * _idx, bool relative = false); 
# 3065
const Mat *m; 
# 3066
size_t elemSize; 
# 3067
const uchar *ptr; 
# 3068
const uchar *sliceStart; 
# 3069
const uchar *sliceEnd; 
# 3070
}; 
# 3078
template< class _Tp> 
# 3079
class MatConstIterator_ : public MatConstIterator { 
# 3082
public: typedef _Tp value_type; 
# 3083
typedef ptrdiff_t difference_type; 
# 3084
typedef const _Tp *pointer; 
# 3085
typedef const _Tp &reference; 
# 3087
typedef std::random_access_iterator_tag iterator_category; 
# 3090
inline MatConstIterator_(); 
# 3092
inline MatConstIterator_(const Mat_< _Tp>  * _m); 
# 3094
inline MatConstIterator_(const Mat_< _Tp>  * _m, int _row, int _col = 0); 
# 3096
inline MatConstIterator_(const Mat_< _Tp>  * _m, Point _pt); 
# 3098
MatConstIterator_(const Mat_< _Tp>  * _m, const int * _idx); 
# 3100
inline MatConstIterator_(const MatConstIterator_ & it); 
# 3103
inline MatConstIterator_ &operator=(const MatConstIterator_ & it); 
# 3105
inline const _Tp &operator*() const; 
# 3107
inline const _Tp &operator[](ptrdiff_t i) const; 
# 3110
inline MatConstIterator_ &operator+=(ptrdiff_t ofs); 
# 3112
inline MatConstIterator_ &operator-=(ptrdiff_t ofs); 
# 3114
inline MatConstIterator_ &operator--(); 
# 3116
inline MatConstIterator_ operator--(int); 
# 3118
inline MatConstIterator_ &operator++(); 
# 3120
inline MatConstIterator_ operator++(int); 
# 3122
inline Point pos() const; 
# 3123
}; 
# 3131
template< class _Tp> 
# 3132
class MatIterator_ : public MatConstIterator_< _Tp>  { 
# 3135
public: typedef _Tp *pointer; 
# 3136
typedef _Tp &reference; 
# 3138
typedef std::random_access_iterator_tag iterator_category; 
# 3141
inline MatIterator_(); 
# 3143
inline MatIterator_(Mat_< _Tp>  * _m); 
# 3145
inline MatIterator_(Mat_< _Tp>  * _m, int _row, int _col = 0); 
# 3147
inline MatIterator_(Mat_< _Tp>  * _m, cv::Point _pt); 
# 3149
inline MatIterator_(Mat_< _Tp>  * _m, const int * _idx); 
# 3151
inline MatIterator_(const MatIterator_ & it); 
# 3153
inline MatIterator_ &operator=(const MatIterator_ & it); 
# 3156
inline _Tp &operator*() const; 
# 3158
inline _Tp &operator[](::ptrdiff_t i) const; 
# 3161
inline MatIterator_ &operator+=(::ptrdiff_t ofs); 
# 3163
inline MatIterator_ &operator-=(::ptrdiff_t ofs); 
# 3165
inline MatIterator_ &operator--(); 
# 3167
inline MatIterator_ operator--(int); 
# 3169
inline MatIterator_ &operator++(); 
# 3171
inline MatIterator_ operator++(int); 
# 3172
}; 
# 3190 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
class SparseMatConstIterator { 
# 3194
public: inline SparseMatConstIterator(); 
# 3196
SparseMatConstIterator(const SparseMat * _m); 
# 3198
inline SparseMatConstIterator(const SparseMatConstIterator & it); 
# 3201
inline SparseMatConstIterator &operator=(const SparseMatConstIterator & it); 
# 3204
template< class _Tp> inline const _Tp &value() const; 
# 3206
inline const SparseMat::Node *node() const; 
# 3209
SparseMatConstIterator &operator--(); 
# 3211
SparseMatConstIterator operator--(int); 
# 3213
SparseMatConstIterator &operator++(); 
# 3215
inline SparseMatConstIterator operator++(int); 
# 3218
inline void seekEnd(); 
# 3220
const SparseMat *m; 
# 3221
size_t hashidx; 
# 3222
uchar *ptr; 
# 3223
}; 
# 3234 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
class SparseMatIterator : public SparseMatConstIterator { 
# 3238
public: inline SparseMatIterator(); 
# 3240
inline SparseMatIterator(SparseMat * _m); 
# 3242
SparseMatIterator(SparseMat * _m, const int * idx); 
# 3244
inline SparseMatIterator(const SparseMatIterator & it); 
# 3247
inline SparseMatIterator &operator=(const SparseMatIterator & it); 
# 3249
template< class _Tp> inline _Tp &value() const; 
# 3251
inline SparseMat::Node *node() const; 
# 3254
inline SparseMatIterator &operator++(); 
# 3256
inline SparseMatIterator operator++(int); 
# 3257
}; 
# 3268 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> class SparseMatConstIterator_ : public SparseMatConstIterator { 
# 3272
public: typedef std::forward_iterator_tag iterator_category; 
# 3275
inline SparseMatConstIterator_(); 
# 3277
inline SparseMatConstIterator_(const SparseMat_< _Tp>  * _m); 
# 3278
inline SparseMatConstIterator_(const SparseMat * _m); 
# 3280
inline SparseMatConstIterator_(const SparseMatConstIterator_ & it); 
# 3283
inline SparseMatConstIterator_ &operator=(const SparseMatConstIterator_ & it); 
# 3285
inline const _Tp &operator*() const; 
# 3288
inline SparseMatConstIterator_ &operator++(); 
# 3290
inline SparseMatConstIterator_ operator++(int); 
# 3291
}; 
# 3302 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
template< class _Tp> class SparseMatIterator_ : public SparseMatConstIterator_< _Tp>  { 
# 3306
public: typedef std::forward_iterator_tag iterator_category; 
# 3309
inline SparseMatIterator_(); 
# 3311
inline SparseMatIterator_(SparseMat_< _Tp>  * _m); 
# 3312
inline SparseMatIterator_(cv::SparseMat * _m); 
# 3314
inline SparseMatIterator_(const SparseMatIterator_ & it); 
# 3317
inline SparseMatIterator_ &operator=(const SparseMatIterator_ & it); 
# 3319
inline _Tp &operator*() const; 
# 3322
inline SparseMatIterator_ &operator++(); 
# 3324
inline SparseMatIterator_ operator++(int); 
# 3325
}; 
# 3391 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
class NAryMatIterator { 
# 3395
public: NAryMatIterator(); 
# 3397
NAryMatIterator(const Mat ** arrays, uchar ** ptrs, int narrays = -1); 
# 3399
NAryMatIterator(const Mat ** arrays, Mat * planes, int narrays = -1); 
# 3401
void init(const Mat ** arrays, Mat * planes, uchar ** ptrs, int narrays = -1); 
# 3404
NAryMatIterator &operator++(); 
# 3406
NAryMatIterator operator++(int); 
# 3409
const Mat **arrays; 
# 3411
Mat *planes; 
# 3413
uchar **ptrs; 
# 3415
int narrays; 
# 3417
size_t nplanes; 
# 3419
size_t size; 
# 3421
protected: int iterdepth; 
# 3422
size_t idx; 
# 3423
}; 
# 3429
class MatOp { 
# 3432
public: MatOp(); 
# 3433
virtual ~MatOp(); 
# 3435
virtual bool elementWise(const MatExpr & expr) const; 
# 3436
virtual void assign(const MatExpr & expr, Mat & m, int type = -1) const = 0; 
# 3437
virtual void roi(const MatExpr & expr, const Range & rowRange, const Range & colRange, MatExpr & res) const; 
# 3439
virtual void diag(const MatExpr & expr, int d, MatExpr & res) const; 
# 3440
virtual void augAssignAdd(const MatExpr & expr, Mat & m) const; 
# 3441
virtual void augAssignSubtract(const MatExpr & expr, Mat & m) const; 
# 3442
virtual void augAssignMultiply(const MatExpr & expr, Mat & m) const; 
# 3443
virtual void augAssignDivide(const MatExpr & expr, Mat & m) const; 
# 3444
virtual void augAssignAnd(const MatExpr & expr, Mat & m) const; 
# 3445
virtual void augAssignOr(const MatExpr & expr, Mat & m) const; 
# 3446
virtual void augAssignXor(const MatExpr & expr, Mat & m) const; 
# 3448
virtual void add(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res) const; 
# 3449
virtual void add(const MatExpr & expr1, const Scalar & s, MatExpr & res) const; 
# 3451
virtual void subtract(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res) const; 
# 3452
virtual void subtract(const Scalar & s, const MatExpr & expr, MatExpr & res) const; 
# 3454
virtual void multiply(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res, double scale = 1) const; 
# 3455
virtual void multiply(const MatExpr & expr1, double s, MatExpr & res) const; 
# 3457
virtual void divide(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res, double scale = 1) const; 
# 3458
virtual void divide(double s, const MatExpr & expr, MatExpr & res) const; 
# 3460
virtual void abs(const MatExpr & expr, MatExpr & res) const; 
# 3462
virtual void transpose(const MatExpr & expr, MatExpr & res) const; 
# 3463
virtual void matmul(const MatExpr & expr1, const MatExpr & expr2, MatExpr & res) const; 
# 3464
virtual void invert(const MatExpr & expr, int method, MatExpr & res) const; 
# 3466
virtual Size size(const MatExpr & expr) const; 
# 3467
virtual int type(const MatExpr & expr) const; 
# 3468
}; 
# 3516 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
class MatExpr { 
# 3519
public: inline MatExpr(); 
# 3520
explicit MatExpr(const Mat & m); 
# 3522
inline MatExpr(const MatOp * _op, int _flags, const Mat & _a = Mat(), const Mat & _b = Mat(), const Mat & _c = Mat(), double _alpha = 1, double _beta = 1, const Scalar & _s = Scalar()); 
# 3525
inline operator Mat() const; 
# 3526
template< class _Tp> inline operator Mat_< _Tp> () const; 
# 3528
Size size() const; 
# 3529
int type() const; 
# 3531
MatExpr row(int y) const; 
# 3532
MatExpr col(int x) const; 
# 3533
MatExpr diag(int d = 0) const; 
# 3534
MatExpr operator()(const Range & rowRange, const Range & colRange) const; 
# 3535
MatExpr operator()(const Rect & roi) const; 
# 3537
MatExpr t() const; 
# 3538
MatExpr inv(int method = DECOMP_LU) const; 
# 3539
MatExpr mul(const MatExpr & e, double scale = 1) const; 
# 3540
MatExpr mul(const Mat & m, double scale = 1) const; 
# 3542
Mat cross(const Mat & m) const; 
# 3543
double dot(const Mat & m) const; 
# 3545
const MatOp *op; 
# 3546
int flags; 
# 3548
Mat a, b, c; 
# 3549
double alpha, beta; 
# 3550
Scalar s; 
# 3551
}; 
# 3557
MatExpr operator+(const Mat & a, const Mat & b); 
# 3558
MatExpr operator+(const Mat & a, const Scalar & s); 
# 3559
MatExpr operator+(const Scalar & s, const Mat & a); 
# 3560
MatExpr operator+(const MatExpr & e, const Mat & m); 
# 3561
MatExpr operator+(const Mat & m, const MatExpr & e); 
# 3562
MatExpr operator+(const MatExpr & e, const Scalar & s); 
# 3563
MatExpr operator+(const Scalar & s, const MatExpr & e); 
# 3564
MatExpr operator+(const MatExpr & e1, const MatExpr & e2); 
# 3565
template< class _Tp, int m, int n> static inline MatExpr 
# 3566
operator+(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a + ((Mat)(b))); } 
# 3567
template< class _Tp, int m, int n> static inline MatExpr 
# 3568
operator+(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) + b); } 
# 3570
MatExpr operator-(const Mat & a, const Mat & b); 
# 3571
MatExpr operator-(const Mat & a, const Scalar & s); 
# 3572
MatExpr operator-(const Scalar & s, const Mat & a); 
# 3573
MatExpr operator-(const MatExpr & e, const Mat & m); 
# 3574
MatExpr operator-(const Mat & m, const MatExpr & e); 
# 3575
MatExpr operator-(const MatExpr & e, const Scalar & s); 
# 3576
MatExpr operator-(const Scalar & s, const MatExpr & e); 
# 3577
MatExpr operator-(const MatExpr & e1, const MatExpr & e2); 
# 3578
template< class _Tp, int m, int n> static inline MatExpr 
# 3579
operator-(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a - ((Mat)(b))); } 
# 3580
template< class _Tp, int m, int n> static inline MatExpr 
# 3581
operator-(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) - b); } 
# 3583
MatExpr operator-(const Mat & m); 
# 3584
MatExpr operator-(const MatExpr & e); 
# 3586
MatExpr operator*(const Mat & a, const Mat & b); 
# 3587
MatExpr operator*(const Mat & a, double s); 
# 3588
MatExpr operator*(double s, const Mat & a); 
# 3589
MatExpr operator*(const MatExpr & e, const Mat & m); 
# 3590
MatExpr operator*(const Mat & m, const MatExpr & e); 
# 3591
MatExpr operator*(const MatExpr & e, double s); 
# 3592
MatExpr operator*(double s, const MatExpr & e); 
# 3593
MatExpr operator*(const MatExpr & e1, const MatExpr & e2); 
# 3594
template< class _Tp, int m, int n> static inline MatExpr 
# 3595
operator*(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a * ((Mat)(b))); } 
# 3596
template< class _Tp, int m, int n> static inline MatExpr 
# 3597
operator*(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) * b); } 
# 3599
MatExpr operator/(const Mat & a, const Mat & b); 
# 3600
MatExpr operator/(const Mat & a, double s); 
# 3601
MatExpr operator/(double s, const Mat & a); 
# 3602
MatExpr operator/(const MatExpr & e, const Mat & m); 
# 3603
MatExpr operator/(const Mat & m, const MatExpr & e); 
# 3604
MatExpr operator/(const MatExpr & e, double s); 
# 3605
MatExpr operator/(double s, const MatExpr & e); 
# 3606
MatExpr operator/(const MatExpr & e1, const MatExpr & e2); 
# 3607
template< class _Tp, int m, int n> static inline MatExpr 
# 3608
operator/(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a / ((Mat)(b))); } 
# 3609
template< class _Tp, int m, int n> static inline MatExpr 
# 3610
operator/(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) / b); } 
# 3612
MatExpr operator<(const Mat & a, const Mat & b); 
# 3613
MatExpr operator<(const Mat & a, double s); 
# 3614
MatExpr operator<(double s, const Mat & a); 
# 3615
template< class _Tp, int m, int n> static inline MatExpr 
# 3616
operator<(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a < ((Mat)(b))); } 
# 3617
template< class _Tp, int m, int n> static inline MatExpr 
# 3618
operator<(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) < b); } 
# 3620
MatExpr operator<=(const Mat & a, const Mat & b); 
# 3621
MatExpr operator<=(const Mat & a, double s); 
# 3622
MatExpr operator<=(double s, const Mat & a); 
# 3623
template< class _Tp, int m, int n> static inline MatExpr 
# 3624
operator<=(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a <= ((Mat)(b))); } 
# 3625
template< class _Tp, int m, int n> static inline MatExpr 
# 3626
operator<=(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) <= b); } 
# 3628
MatExpr operator==(const Mat & a, const Mat & b); 
# 3629
MatExpr operator==(const Mat & a, double s); 
# 3630
MatExpr operator==(double s, const Mat & a); 
# 3631
template< class _Tp, int m, int n> static inline MatExpr 
# 3632
operator==(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a == ((Mat)(b))); } 
# 3633
template< class _Tp, int m, int n> static inline MatExpr 
# 3634
operator==(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) == b); } 
# 3636
MatExpr operator!=(const Mat & a, const Mat & b); 
# 3637
MatExpr operator!=(const Mat & a, double s); 
# 3638
MatExpr operator!=(double s, const Mat & a); 
# 3639
template< class _Tp, int m, int n> static inline MatExpr 
# 3640
operator!=(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a != ((Mat)(b))); } 
# 3641
template< class _Tp, int m, int n> static inline MatExpr 
# 3642
operator!=(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) != b); } 
# 3644
MatExpr operator>=(const Mat & a, const Mat & b); 
# 3645
MatExpr operator>=(const Mat & a, double s); 
# 3646
MatExpr operator>=(double s, const Mat & a); 
# 3647
template< class _Tp, int m, int n> static inline MatExpr 
# 3648
operator>=(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a >= ((Mat)(b))); } 
# 3649
template< class _Tp, int m, int n> static inline MatExpr 
# 3650
operator>=(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) >= b); } 
# 3652
MatExpr operator>(const Mat & a, const Mat & b); 
# 3653
MatExpr operator>(const Mat & a, double s); 
# 3654
MatExpr operator>(double s, const Mat & a); 
# 3655
template< class _Tp, int m, int n> static inline MatExpr 
# 3656
operator>(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a > ((Mat)(b))); } 
# 3657
template< class _Tp, int m, int n> static inline MatExpr 
# 3658
operator>(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) > b); } 
# 3660
MatExpr operator&(const Mat & a, const Mat & b); 
# 3661
MatExpr operator&(const Mat & a, const Scalar & s); 
# 3662
MatExpr operator&(const Scalar & s, const Mat & a); 
# 3663
template< class _Tp, int m, int n> static inline MatExpr 
# 3664
operator&(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a & ((Mat)(b))); } 
# 3665
template< class _Tp, int m, int n> static inline MatExpr 
# 3666
operator&(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) & b); } 
# 3668
MatExpr operator|(const Mat & a, const Mat & b); 
# 3669
MatExpr operator|(const Mat & a, const Scalar & s); 
# 3670
MatExpr operator|(const Scalar & s, const Mat & a); 
# 3671
template< class _Tp, int m, int n> static inline MatExpr 
# 3672
operator|(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a | ((Mat)(b))); } 
# 3673
template< class _Tp, int m, int n> static inline MatExpr 
# 3674
operator|(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) | b); } 
# 3676
MatExpr operator^(const Mat & a, const Mat & b); 
# 3677
MatExpr operator^(const Mat & a, const Scalar & s); 
# 3678
MatExpr operator^(const Scalar & s, const Mat & a); 
# 3679
template< class _Tp, int m, int n> static inline MatExpr 
# 3680
operator^(const Mat &a, const Matx< _Tp, m, n>  &b) { return (a ^ ((Mat)(b))); } 
# 3681
template< class _Tp, int m, int n> static inline MatExpr 
# 3682
operator^(const Matx< _Tp, m, n>  &a, const Mat &b) { return (((Mat)(a)) ^ b); } 
# 3684
MatExpr operator~(const Mat & m); 
# 3686
MatExpr min(const Mat & a, const Mat & b); 
# 3687
MatExpr min(const Mat & a, double s); 
# 3688
MatExpr min(double s, const Mat & a); 
# 3689
template< class _Tp, int m, int n> static inline MatExpr 
# 3690
min(const Mat &a, const Matx< _Tp, m, n>  &b) { return min(a, ((Mat)(b))); } 
# 3691
template< class _Tp, int m, int n> static inline MatExpr 
# 3692
min(const Matx< _Tp, m, n>  &a, const Mat &b) { return min(((Mat)(a)), b); } 
# 3694
MatExpr max(const Mat & a, const Mat & b); 
# 3695
MatExpr max(const Mat & a, double s); 
# 3696
MatExpr max(double s, const Mat & a); 
# 3697
template< class _Tp, int m, int n> static inline MatExpr 
# 3698
max(const Mat &a, const Matx< _Tp, m, n>  &b) { return max(a, ((Mat)(b))); } 
# 3699
template< class _Tp, int m, int n> static inline MatExpr 
# 3700
max(const Matx< _Tp, m, n>  &a, const Mat &b) { return max(((Mat)(a)), b); } 
# 3715 "/usr/include/opencv4/opencv2/core/mat.hpp" 3
MatExpr abs(const Mat & m); 
# 3719
MatExpr abs(const MatExpr & e); 
# 3722
}
# 57 "/usr/include/opencv4/opencv2/core/mat.inl.hpp" 3
namespace cv { 
# 66
template< class _Tp> static inline int 
# 67
rawType() 
# 68
{ 
# 69
static_assert((sizeof(_Tp) <= (512)), "sizeof(_Tp) is too large sizeof(_Tp) <= CV_CN_MAX");
# 70
const int elemSize = (sizeof(_Tp)); 
# 71
return (int)((0 & ((1 << 3) - 1)) + ((elemSize - 1) << 3)); 
# 72
} 
# 76
inline void _InputArray::init(int _flags, const void *_obj) 
# 77
{ (flags) = _flags; (obj) = ((void *)_obj); } 
# 79
inline void _InputArray::init(int _flags, const void *_obj, Size _sz) 
# 80
{ (flags) = _flags; (obj) = ((void *)_obj); ((sz) = _sz); } 
# 82
inline void *_InputArray::getObj() const { return obj; } 
# 83
inline int _InputArray::getFlags() const { return flags; } 
# 84
inline Size _InputArray::getSz() const { return sz; } 
# 86
inline _InputArray::_InputArray() { this->init(0 + (NONE), 0); } 
# 87
inline _InputArray::_InputArray(int _flags, void *_obj) { this->init(_flags, _obj); } 
# 88
inline _InputArray::_InputArray(const Mat &m) { this->init((MAT) + (ACCESS_READ), &m); } 
# 89
inline _InputArray::_InputArray(const std::vector< Mat>  &vec) { this->init((STD_VECTOR_MAT) + (ACCESS_READ), &vec); } 
# 90
inline _InputArray::_InputArray(const UMat &m) { this->init((UMAT) + (ACCESS_READ), &m); } 
# 91
inline _InputArray::_InputArray(const std::vector< UMat>  &vec) { this->init((STD_VECTOR_UMAT) + (ACCESS_READ), &vec); } 
# 93
template< class _Tp> inline 
# 94
_InputArray::_InputArray(const std::vector< _Tp>  &vec) 
# 95
{ init((((FIXED_TYPE) + (STD_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_READ, &vec); } 
# 97
template< class _Tp, std::size_t _Nm> inline 
# 98
_InputArray::_InputArray(const std::array< _Tp, _Nm>  &arr) 
# 99
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::template Type< _Tp> ::value) + ACCESS_READ, arr.data(), Size(1, _Nm)); } 
# 101
template< std::size_t _Nm> inline 
# 102
_InputArray::_InputArray(const std::array< Mat, _Nm>  &arr) 
# 103
{ init((STD_ARRAY_MAT) + (ACCESS_READ), arr.data(), Size(1, _Nm)); } 
# 106
inline _InputArray::_InputArray(const std::vector< bool>  &vec) 
# 107
{ this->init((((FIXED_TYPE) + (STD_BOOL_VECTOR)) + (traits::Type< bool> ::value)) + (ACCESS_READ), &vec); } 
# 109
template< class _Tp> inline 
# 110
_InputArray::_InputArray(const std::vector< std::vector< _Tp> >  &vec) 
# 111
{ init((((FIXED_TYPE) + (STD_VECTOR_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_READ, &vec); } 
# 113
template< class _Tp> inline 
# 114
_InputArray::_InputArray(const std::vector< Mat_< _Tp> >  &vec) 
# 115
{ init((((FIXED_TYPE) + (STD_VECTOR_MAT)) + traits::template Type< _Tp> ::value) + ACCESS_READ, &vec); } 
# 117
template< class _Tp, int m, int n> inline 
# 118
_InputArray::_InputArray(const Matx< _Tp, m, n>  &mtx) 
# 119
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_READ, &mtx, Size(n, m)); } 
# 121
template< class _Tp> inline 
# 122
_InputArray::_InputArray(const _Tp *vec, int n) 
# 123
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_READ, vec, Size(n, 1)); } 
# 125
template< class _Tp> inline 
# 126
_InputArray::_InputArray(const Mat_< _Tp>  &m) 
# 127
{ init((((FIXED_TYPE) + (MAT)) + traits::template Type< _Tp> ::value) + ACCESS_READ, &m); } 
# 129
inline _InputArray::_InputArray(const double &val) 
# 130
{ this->init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + 6) + (ACCESS_READ), &val, Size(1, 1)); } 
# 132
inline _InputArray::_InputArray(const MatExpr &expr) 
# 133
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (EXPR)) + (ACCESS_READ), &expr); } 
# 135
inline _InputArray::_InputArray(const cuda::GpuMat &d_mat) 
# 136
{ this->init((CUDA_GPU_MAT) + (ACCESS_READ), &d_mat); } 
# 138
inline _InputArray::_InputArray(const std::vector< cuda::GpuMat>  &d_mat) 
# 139
{ this->init((STD_VECTOR_CUDA_GPU_MAT) + (ACCESS_READ), &d_mat); } 
# 141
inline _InputArray::_InputArray(const ogl::Buffer &buf) 
# 142
{ this->init((OPENGL_BUFFER) + (ACCESS_READ), &buf); } 
# 144
inline _InputArray::_InputArray(const cuda::HostMem &cuda_mem) 
# 145
{ this->init((CUDA_HOST_MEM) + (ACCESS_READ), &cuda_mem); } 
# 147
template< class _Tp> inline _InputArray 
# 148
_InputArray::rawIn(const std::vector< _Tp>  &vec) 
# 149
{ 
# 150
_InputArray v; 
# 151
(v.flags) = ((((_InputArray::FIXED_TYPE) + (_InputArray::STD_VECTOR)) + rawType< _Tp> ()) + ACCESS_READ); 
# 152
(v.obj) = ((void *)(&vec)); 
# 153
return v; 
# 154
} 
# 156
template< class _Tp, std::size_t _Nm> inline _InputArray 
# 157
_InputArray::rawIn(const std::array< _Tp, _Nm>  &arr) 
# 158
{ 
# 159
_InputArray v; 
# 160
(v.flags) = (((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::template Type< _Tp> ::value) + ACCESS_READ); 
# 161
(v.obj) = ((void *)arr.data()); 
# 162
((v.sz) = Size(1, _Nm)); 
# 163
return v; 
# 164
} 
# 166
inline _InputArray::~_InputArray() { } 
# 168
inline Mat _InputArray::getMat(int i) const 
# 169
{ 
# 170
if (((this->kind()) == (MAT)) && (i < 0)) { 
# 171
return *((const Mat *)(obj)); }  
# 172
return this->getMat_(i); 
# 173
} 
# 175
inline bool _InputArray::isMat() const { return (this->kind()) == (_InputArray::MAT); } 
# 176
inline bool _InputArray::isUMat() const { return (this->kind()) == (_InputArray::UMAT); } 
# 177
inline bool _InputArray::isMatVector() const { return (this->kind()) == (_InputArray::STD_VECTOR_MAT); } 
# 178
inline bool _InputArray::isUMatVector() const { return (this->kind()) == (_InputArray::STD_VECTOR_UMAT); } 
# 179
inline bool _InputArray::isMatx() const { return (this->kind()) == (_InputArray::MATX); } 
# 180
inline bool _InputArray::isVector() const { return (((this->kind()) == (_InputArray::STD_VECTOR)) || ((this->kind()) == (_InputArray::STD_BOOL_VECTOR))) || ((this->kind()) == (_InputArray::STD_ARRAY)); 
# 182
} 
# 183
inline bool _InputArray::isGpuMat() const { return (this->kind()) == (_InputArray::CUDA_GPU_MAT); } 
# 184
inline bool _InputArray::isGpuMatVector() const { return (this->kind()) == (_InputArray::STD_VECTOR_CUDA_GPU_MAT); } 
# 188
inline _OutputArray::_OutputArray() { this->init((NONE) + (ACCESS_WRITE), 0); } 
# 189
inline _OutputArray::_OutputArray(int _flags, void *_obj) { this->init(_flags + (ACCESS_WRITE), _obj); } 
# 190
inline _OutputArray::_OutputArray(Mat &m) { this->init((MAT) + (ACCESS_WRITE), &m); } 
# 191
inline _OutputArray::_OutputArray(std::vector< Mat>  &vec) { this->init((STD_VECTOR_MAT) + (ACCESS_WRITE), &vec); } 
# 192
inline _OutputArray::_OutputArray(UMat &m) { this->init((UMAT) + (ACCESS_WRITE), &m); } 
# 193
inline _OutputArray::_OutputArray(std::vector< UMat>  &vec) { this->init((STD_VECTOR_UMAT) + (ACCESS_WRITE), &vec); } 
# 195
template< class _Tp> inline 
# 196
_OutputArray::_OutputArray(std::vector< _Tp>  &vec) 
# 197
{ init((((FIXED_TYPE) + (STD_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 199
template< class _Tp, std::size_t _Nm> inline 
# 200
_OutputArray::_OutputArray(std::array< _Tp, _Nm>  &arr) 
# 201
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, arr.data(), Size(1, _Nm)); } 
# 203
template< std::size_t _Nm> inline 
# 204
_OutputArray::_OutputArray(std::array< Mat, _Nm>  &arr) 
# 205
{ init((STD_ARRAY_MAT) + (ACCESS_WRITE), arr.data(), Size(1, _Nm)); } 
# 207
template< class _Tp> inline 
# 208
_OutputArray::_OutputArray(std::vector< std::vector< _Tp> >  &vec) 
# 209
{ init((((FIXED_TYPE) + (STD_VECTOR_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 211
template< class _Tp> inline 
# 212
_OutputArray::_OutputArray(std::vector< Mat_< _Tp> >  &vec) 
# 213
{ init((((FIXED_TYPE) + (STD_VECTOR_MAT)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 215
template< class _Tp> inline 
# 216
_OutputArray::_OutputArray(Mat_< _Tp>  &m) 
# 217
{ init((((FIXED_TYPE) + (MAT)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &m); } 
# 219
template< class _Tp, int m, int n> inline 
# 220
_OutputArray::_OutputArray(Matx< _Tp, m, n>  &mtx) 
# 221
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &mtx, Size(n, m)); } 
# 223
template< class _Tp> inline 
# 224
_OutputArray::_OutputArray(_Tp *vec, int n) 
# 225
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, vec, Size(n, 1)); } 
# 227
template< class _Tp> inline 
# 228
_OutputArray::_OutputArray(const std::vector< _Tp>  &vec) 
# 229
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 231
template< class _Tp, std::size_t _Nm> inline 
# 232
_OutputArray::_OutputArray(const std::array< _Tp, _Nm>  &arr) 
# 233
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, arr.data(), Size(1, _Nm)); } 
# 235
template< std::size_t _Nm> inline 
# 236
_OutputArray::_OutputArray(const std::array< Mat, _Nm>  &arr) 
# 237
{ init(((FIXED_SIZE) + (STD_ARRAY_MAT)) + (ACCESS_WRITE), arr.data(), Size(1, _Nm)); } 
# 239
template< class _Tp> inline 
# 240
_OutputArray::_OutputArray(const std::vector< std::vector< _Tp> >  &vec) 
# 241
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 243
template< class _Tp> inline 
# 244
_OutputArray::_OutputArray(const std::vector< Mat_< _Tp> >  &vec) 
# 245
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_MAT)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &vec); } 
# 247
template< class _Tp> inline 
# 248
_OutputArray::_OutputArray(const Mat_< _Tp>  &m) 
# 249
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MAT)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &m); } 
# 251
template< class _Tp, int m, int n> inline 
# 252
_OutputArray::_OutputArray(const Matx< _Tp, m, n>  &mtx) 
# 253
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, &mtx, Size(n, m)); } 
# 255
template< class _Tp> inline 
# 256
_OutputArray::_OutputArray(const _Tp *vec, int n) 
# 257
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE, vec, Size(n, 1)); } 
# 259
inline _OutputArray::_OutputArray(cuda::GpuMat &d_mat) 
# 260
{ this->init((CUDA_GPU_MAT) + (ACCESS_WRITE), &d_mat); } 
# 262
inline _OutputArray::_OutputArray(std::vector< cuda::GpuMat>  &d_mat) 
# 263
{ this->init((STD_VECTOR_CUDA_GPU_MAT) + (ACCESS_WRITE), &d_mat); } 
# 265
inline _OutputArray::_OutputArray(ogl::Buffer &buf) 
# 266
{ this->init((OPENGL_BUFFER) + (ACCESS_WRITE), &buf); } 
# 268
inline _OutputArray::_OutputArray(cuda::HostMem &cuda_mem) 
# 269
{ this->init((CUDA_HOST_MEM) + (ACCESS_WRITE), &cuda_mem); } 
# 271
inline _OutputArray::_OutputArray(const Mat &m) 
# 272
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (MAT)) + (ACCESS_WRITE), &m); } 
# 274
inline _OutputArray::_OutputArray(const std::vector< Mat>  &vec) 
# 275
{ this->init(((FIXED_SIZE) + (STD_VECTOR_MAT)) + (ACCESS_WRITE), &vec); } 
# 277
inline _OutputArray::_OutputArray(const UMat &m) 
# 278
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (UMAT)) + (ACCESS_WRITE), &m); } 
# 280
inline _OutputArray::_OutputArray(const std::vector< UMat>  &vec) 
# 281
{ this->init(((FIXED_SIZE) + (STD_VECTOR_UMAT)) + (ACCESS_WRITE), &vec); } 
# 283
inline _OutputArray::_OutputArray(const cuda::GpuMat &d_mat) 
# 284
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (CUDA_GPU_MAT)) + (ACCESS_WRITE), &d_mat); } 
# 287
inline _OutputArray::_OutputArray(const ogl::Buffer &buf) 
# 288
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (OPENGL_BUFFER)) + (ACCESS_WRITE), &buf); } 
# 290
inline _OutputArray::_OutputArray(const cuda::HostMem &cuda_mem) 
# 291
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (CUDA_HOST_MEM)) + (ACCESS_WRITE), &cuda_mem); } 
# 293
template< class _Tp> inline _OutputArray 
# 294
_OutputArray::rawOut(std::vector< _Tp>  &vec) 
# 295
{ 
# 296
_OutputArray v; 
# 297
(v.flags) = ((((_InputArray::FIXED_TYPE) + (_InputArray::STD_VECTOR)) + rawType< _Tp> ()) + ACCESS_WRITE); 
# 298
(v.obj) = ((void *)(&vec)); 
# 299
return v; 
# 300
} 
# 302
template< class _Tp, std::size_t _Nm> inline _OutputArray 
# 303
_OutputArray::rawOut(std::array< _Tp, _Nm>  &arr) 
# 304
{ 
# 305
_OutputArray v; 
# 306
(v.flags) = (((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::template Type< _Tp> ::value) + ACCESS_WRITE); 
# 307
(v.obj) = ((void *)arr.data()); 
# 308
((v.sz) = Size(1, _Nm)); 
# 309
return v; 
# 310
} 
# 314
inline _InputOutputArray::_InputOutputArray() { this->init(0 + (ACCESS_RW), 0); } 
# 315
inline _InputOutputArray::_InputOutputArray(int _flags, void *_obj) { this->init(_flags + (ACCESS_RW), _obj); } 
# 316
inline _InputOutputArray::_InputOutputArray(Mat &m) { this->init((MAT) + (ACCESS_RW), &m); } 
# 317
inline _InputOutputArray::_InputOutputArray(std::vector< Mat>  &vec) { this->init((STD_VECTOR_MAT) + (ACCESS_RW), &vec); } 
# 318
inline _InputOutputArray::_InputOutputArray(UMat &m) { this->init((UMAT) + (ACCESS_RW), &m); } 
# 319
inline _InputOutputArray::_InputOutputArray(std::vector< UMat>  &vec) { this->init((STD_VECTOR_UMAT) + (ACCESS_RW), &vec); } 
# 321
template< class _Tp> inline 
# 322
_InputOutputArray::_InputOutputArray(std::vector< _Tp>  &vec) 
# 323
{ init((((FIXED_TYPE) + (STD_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 325
template< class _Tp, std::size_t _Nm> inline 
# 326
_InputOutputArray::_InputOutputArray(std::array< _Tp, _Nm>  &arr) 
# 327
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::template Type< _Tp> ::value) + ACCESS_RW, arr.data(), Size(1, _Nm)); } 
# 329
template< std::size_t _Nm> inline 
# 330
_InputOutputArray::_InputOutputArray(std::array< Mat, _Nm>  &arr) 
# 331
{ init((STD_ARRAY_MAT) + (ACCESS_RW), arr.data(), Size(1, _Nm)); } 
# 333
template< class _Tp> inline 
# 334
_InputOutputArray::_InputOutputArray(std::vector< std::vector< _Tp> >  &vec) 
# 335
{ init((((FIXED_TYPE) + (STD_VECTOR_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 337
template< class _Tp> inline 
# 338
_InputOutputArray::_InputOutputArray(std::vector< Mat_< _Tp> >  &vec) 
# 339
{ init((((FIXED_TYPE) + (STD_VECTOR_MAT)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 341
template< class _Tp> inline 
# 342
_InputOutputArray::_InputOutputArray(Mat_< _Tp>  &m) 
# 343
{ init((((FIXED_TYPE) + (MAT)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &m); } 
# 345
template< class _Tp, int m, int n> inline 
# 346
_InputOutputArray::_InputOutputArray(Matx< _Tp, m, n>  &mtx) 
# 347
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &mtx, Size(n, m)); } 
# 349
template< class _Tp> inline 
# 350
_InputOutputArray::_InputOutputArray(_Tp *vec, int n) 
# 351
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_RW, vec, Size(n, 1)); } 
# 353
template< class _Tp> inline 
# 354
_InputOutputArray::_InputOutputArray(const std::vector< _Tp>  &vec) 
# 355
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 357
template< class _Tp, std::size_t _Nm> inline 
# 358
_InputOutputArray::_InputOutputArray(const std::array< _Tp, _Nm>  &arr) 
# 359
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::template Type< _Tp> ::value) + ACCESS_RW, arr.data(), Size(1, _Nm)); } 
# 361
template< std::size_t _Nm> inline 
# 362
_InputOutputArray::_InputOutputArray(const std::array< Mat, _Nm>  &arr) 
# 363
{ init(((FIXED_SIZE) + (STD_ARRAY_MAT)) + (ACCESS_RW), arr.data(), Size(1, _Nm)); } 
# 365
template< class _Tp> inline 
# 366
_InputOutputArray::_InputOutputArray(const std::vector< std::vector< _Tp> >  &vec) 
# 367
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_VECTOR)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 369
template< class _Tp> inline 
# 370
_InputOutputArray::_InputOutputArray(const std::vector< Mat_< _Tp> >  &vec) 
# 371
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_MAT)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &vec); } 
# 373
template< class _Tp> inline 
# 374
_InputOutputArray::_InputOutputArray(const Mat_< _Tp>  &m) 
# 375
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MAT)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &m); } 
# 377
template< class _Tp, int m, int n> inline 
# 378
_InputOutputArray::_InputOutputArray(const Matx< _Tp, m, n>  &mtx) 
# 379
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_RW, &mtx, Size(n, m)); } 
# 381
template< class _Tp> inline 
# 382
_InputOutputArray::_InputOutputArray(const _Tp *vec, int n) 
# 383
{ init(((((FIXED_TYPE) + (FIXED_SIZE)) + (MATX)) + traits::template Type< _Tp> ::value) + ACCESS_RW, vec, Size(n, 1)); } 
# 385
inline _InputOutputArray::_InputOutputArray(cuda::GpuMat &d_mat) 
# 386
{ this->init((CUDA_GPU_MAT) + (ACCESS_RW), &d_mat); } 
# 388
inline _InputOutputArray::_InputOutputArray(ogl::Buffer &buf) 
# 389
{ this->init((OPENGL_BUFFER) + (ACCESS_RW), &buf); } 
# 391
inline _InputOutputArray::_InputOutputArray(cuda::HostMem &cuda_mem) 
# 392
{ this->init((CUDA_HOST_MEM) + (ACCESS_RW), &cuda_mem); } 
# 394
inline _InputOutputArray::_InputOutputArray(const Mat &m) 
# 395
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (MAT)) + (ACCESS_RW), &m); } 
# 397
inline _InputOutputArray::_InputOutputArray(const std::vector< Mat>  &vec) 
# 398
{ this->init(((FIXED_SIZE) + (STD_VECTOR_MAT)) + (ACCESS_RW), &vec); } 
# 400
inline _InputOutputArray::_InputOutputArray(const UMat &m) 
# 401
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (UMAT)) + (ACCESS_RW), &m); } 
# 403
inline _InputOutputArray::_InputOutputArray(const std::vector< UMat>  &vec) 
# 404
{ this->init(((FIXED_SIZE) + (STD_VECTOR_UMAT)) + (ACCESS_RW), &vec); } 
# 406
inline _InputOutputArray::_InputOutputArray(const cuda::GpuMat &d_mat) 
# 407
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (CUDA_GPU_MAT)) + (ACCESS_RW), &d_mat); } 
# 409
inline _InputOutputArray::_InputOutputArray(const std::vector< cuda::GpuMat>  &d_mat) 
# 410
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_CUDA_GPU_MAT)) + (ACCESS_RW), &d_mat); } 
# 412
template<> inline _InputOutputArray::_InputOutputArray(std::vector< cuda::GpuMat>  &d_mat) 
# 413
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_VECTOR_CUDA_GPU_MAT)) + (ACCESS_RW), &d_mat); } 
# 415
inline _InputOutputArray::_InputOutputArray(const ogl::Buffer &buf) 
# 416
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (OPENGL_BUFFER)) + (ACCESS_RW), &buf); } 
# 418
inline _InputOutputArray::_InputOutputArray(const cuda::HostMem &cuda_mem) 
# 419
{ this->init((((FIXED_TYPE) + (FIXED_SIZE)) + (CUDA_HOST_MEM)) + (ACCESS_RW), &cuda_mem); } 
# 421
template< class _Tp> inline _InputOutputArray 
# 422
_InputOutputArray::rawInOut(std::vector< _Tp>  &vec) 
# 423
{ 
# 424
_InputOutputArray v; 
# 425
(v.flags) = ((((_InputArray::FIXED_TYPE) + (_InputArray::STD_VECTOR)) + rawType< _Tp> ()) + ACCESS_RW); 
# 426
(v.obj) = ((void *)(&vec)); 
# 427
return v; 
# 428
} 
# 430
template< class _Tp, std::size_t _Nm> inline _InputOutputArray 
# 431
_InputOutputArray::rawInOut(std::array< _Tp, _Nm>  &arr) 
# 432
{ 
# 433
_InputOutputArray v; 
# 434
(v.flags) = (((((FIXED_TYPE) + (FIXED_SIZE)) + (STD_ARRAY)) + traits::template Type< _Tp> ::value) + ACCESS_RW); 
# 435
(v.obj) = ((void *)arr.data()); 
# 436
((v.sz) = Size(1, _Nm)); 
# 437
return v; 
# 438
} 
# 441
template< class _Tp> inline _InputArray rawIn(_Tp &v) { return _InputArray::rawIn(v); } 
# 442
template< class _Tp> inline _OutputArray rawOut(_Tp &v) { return _OutputArray::rawOut(v); } 
# 443
template< class _Tp> inline _InputOutputArray rawInOut(_Tp &v) { return _InputOutputArray::rawInOut(v); } 
# 450
inline Mat::Mat() : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 453
{ } 
# 456
inline Mat::Mat(int _rows, int _cols, int _type) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 459
{ 
# 460
this->create(_rows, _cols, _type); 
# 461
} 
# 464
inline Mat::Mat(int _rows, int _cols, int _type, const Scalar &_s) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 467
{ 
# 468
this->create(_rows, _cols, _type); 
# 469
((*this) = _s); 
# 470
} 
# 473
inline Mat::Mat(Size _sz, int _type) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 476
{ 
# 477
this->create(_sz.height, _sz.width, _type); 
# 478
} 
# 481
inline Mat::Mat(Size _sz, int _type, const Scalar &_s) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 484
{ 
# 485
this->create(_sz.height, _sz.width, _type); 
# 486
((*this) = _s); 
# 487
} 
# 490
inline Mat::Mat(int _dims, const int *_sz, int _type) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 493
{ 
# 494
this->create(_dims, _sz, _type); 
# 495
} 
# 498
inline Mat::Mat(int _dims, const int *_sz, int _type, const Scalar &_s) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 501
{ 
# 502
this->create(_dims, _sz, _type); 
# 503
((*this) = _s); 
# 504
} 
# 507
inline Mat::Mat(const std::vector< int>  &_sz, int _type) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 510
{ 
# 511
this->create(_sz, _type); 
# 512
} 
# 515
inline Mat::Mat(const std::vector< int>  &_sz, int _type, const Scalar &_s) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 518
{ 
# 519
this->create(_sz, _type); 
# 520
((*this) = _s); 
# 521
} 
# 524
inline Mat::Mat(const Mat &m) : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data), datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator), u(m.u), size(&(rows)), step(0) 
# 528
{ 
# 529
if (u) { 
# 530
(int)__atomic_fetch_add((unsigned *)(&((u)->refcount)), (unsigned)1, 4); }  
# 531
if ((m.dims) <= 2) 
# 532
{ 
# 533
(step)[0] = (m.step)[0]; (step)[1] = (m.step)[1]; 
# 534
} else 
# 536
{ 
# 537
(dims) = 0; 
# 538
this->copySize(m); 
# 539
}  
# 540
} 
# 543
inline Mat::Mat(int _rows, int _cols, int _type, void *_data, size_t _step) : flags((MAGIC_VAL) + (_type & (TYPE_MASK))), dims(2), rows(_rows), cols(_cols), data((uchar *)_data), datastart((uchar *)_data), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)) 
# 547
{ 
# 548
do { if (!(!((this->total() == (0)) || ((data) != (__null))))) { ; } else { cv::error(cv::Error::StsAssert, "total() == 0 || data != NULL", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 548); }  } while (0); 
# 550
size_t esz = (((_type & ((512 - 1) << 3)) >> 3) + 1) * ((675553809 >> ((_type & ((1 << 3) - 1)) * 4)) & 15), esz1 = (675553809 >> ((_type & ((1 << 3) - 1)) * 4)) & 15; 
# 551
size_t minstep = (cols) * esz; 
# 552
if (_step == (AUTO_STEP)) 
# 553
{ 
# 554
_step = minstep; 
# 555
} else 
# 557
{ 
# 558
; 
# 559
if ((_step % esz1) != (0)) 
# 560
{ 
# 561
cv::error(Error::BadStep, "Step must be a multiple of esz1", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 561); 
# 562
}  
# 563
}  
# 564
(step)[0] = _step; 
# 565
(step)[1] = esz; 
# 566
(datalimit) = ((datastart) + (_step * (rows))); 
# 567
(dataend) = (((datalimit) - _step) + minstep); 
# 568
this->updateContinuityFlag(); 
# 569
} 
# 572
inline Mat::Mat(Size _sz, int _type, void *_data, size_t _step) : flags((MAGIC_VAL) + (_type & (TYPE_MASK))), dims(2), rows(_sz.height), cols(_sz.width), data((uchar *)_data), datastart((uchar *)_data), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)) 
# 576
{ 
# 577
do { if (!(!((this->total() == (0)) || ((data) != (__null))))) { ; } else { cv::error(cv::Error::StsAssert, "total() == 0 || data != NULL", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 577); }  } while (0); 
# 579
size_t esz = (((_type & ((512 - 1) << 3)) >> 3) + 1) * ((675553809 >> ((_type & ((1 << 3) - 1)) * 4)) & 15), esz1 = (675553809 >> ((_type & ((1 << 3) - 1)) * 4)) & 15; 
# 580
size_t minstep = (cols) * esz; 
# 581
if (_step == (AUTO_STEP)) 
# 582
{ 
# 583
_step = minstep; 
# 584
} else 
# 586
{ 
# 587
; 
# 589
if ((_step % esz1) != (0)) 
# 590
{ 
# 591
cv::error(Error::BadStep, "Step must be a multiple of esz1", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 591); 
# 592
}  
# 593
}  
# 594
(step)[0] = _step; 
# 595
(step)[1] = esz; 
# 596
(datalimit) = ((datastart) + (_step * (rows))); 
# 597
(dataend) = (((datalimit) - _step) + minstep); 
# 598
this->updateContinuityFlag(); 
# 599
} 
# 601
template< class _Tp> inline 
# 602
Mat::Mat(const std::vector< _Tp>  &vec, bool copyData) : flags(((MAGIC_VAL + traits::template Type< _Tp> ::value) + (1 << 14))), dims(2), rows((int)vec.size()), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 605
{ 
# 606
if (vec.empty()) { 
# 607
return; }  
# 608
if (!copyData) 
# 609
{ 
# 610
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 611
(datastart) = ((data) = ((uchar *)(&(vec[0])))); 
# 612
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 613
} else { 
# 615
Mat((int)vec.size(), 1, traits::template Type< _Tp> ::value, (uchar *)(&(vec[0]))).copyTo(*this); }  
# 616
} 
# 618
template< class _Tp, class > inline 
# 619
Mat::Mat(const std::initializer_list< _Tp>  list) : Mat() 
# 621
{ 
# 622
do { if (!(!(list.size() != 0))) { ; } else { cv::error(cv::Error::StsAssert, "list.size() != 0", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 622); }  } while (0); 
# 623
Mat((int)list.size(), 1, traits::template Type< _Tp> ::value, (uchar *)list.begin()).copyTo(*this); 
# 624
} 
# 626
template< class _Tp> inline 
# 627
Mat::Mat(const std::initializer_list< int>  sizes, const std::initializer_list< _Tp>  list) : Mat() 
# 629
{ 
# 630
size_t size_total = (1); 
# 631
for (auto s : sizes) { 
# 632
size_total *= s; }  
# 633
do { if (!(!(list.size() != 0))) { ; } else { cv::error(cv::Error::StsAssert, "list.size() != 0", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 633); }  } while (0); 
# 634
do { if (!(!(size_total == list.size()))) { ; } else { cv::error(cv::Error::StsAssert, "size_total == list.size()", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 634); }  } while (0); 
# 635
Mat((int)sizes.size(), (int *)sizes.begin(), traits::template Type< _Tp> ::value, (uchar *)list.begin()).copyTo(*this); 
# 636
} 
# 638
template< class _Tp, std::size_t _Nm> inline 
# 639
Mat::Mat(const std::array< _Tp, _Nm>  &arr, bool copyData) : flags(((MAGIC_VAL + traits::template Type< _Tp> ::value) + (1 << 14))), dims(2), rows((int)arr.size()), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 642
{ 
# 643
if (arr.empty()) { 
# 644
return; }  
# 645
if (!copyData) 
# 646
{ 
# 647
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 648
(datastart) = ((data) = ((uchar *)arr.data())); 
# 649
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 650
} else { 
# 652
Mat((int)arr.size(), 1, traits::template Type< _Tp> ::value, (uchar *)arr.data()).copyTo(*this); }  
# 653
} 
# 655
template< class _Tp, int n> inline 
# 656
Mat::Mat(const Vec< _Tp, n>  &vec, bool copyData) : flags(((MAGIC_VAL + traits::template Type< _Tp> ::value) + (1 << 14))), dims(2), rows(n), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 659
{ 
# 660
if (!copyData) 
# 661
{ 
# 662
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 663
(datastart) = ((data) = ((uchar *)(vec.val))); 
# 664
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 665
} else { 
# 667
Mat(n, 1, traits::template Type< _Tp> ::value, (void *)(vec.val)).copyTo(*this); }  
# 668
} 
# 671
template< class _Tp, int m, int n> inline 
# 672
Mat::Mat(const Matx< _Tp, m, n>  &M, bool copyData) : flags(((MAGIC_VAL + traits::template Type< _Tp> ::value) + (1 << 14))), dims(2), rows(m), cols(n), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 675
{ 
# 676
if (!copyData) 
# 677
{ 
# 678
(step)[0] = ((cols) * sizeof(_Tp)); 
# 679
(step)[1] = sizeof(_Tp); 
# 680
(datastart) = ((data) = ((uchar *)(M.val))); 
# 681
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 682
} else { 
# 684
Mat(m, n, traits::template Type< _Tp> ::value, (uchar *)(M.val)).copyTo(*this); }  
# 685
} 
# 687
template< class _Tp> inline 
# 688
Mat::Mat(const Point_< _Tp>  &pt, bool copyData) : flags(((MAGIC_VAL + traits::template Type< _Tp> ::value) + (1 << 14))), dims(2), rows(2), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 691
{ 
# 692
if (!copyData) 
# 693
{ 
# 694
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 695
(datastart) = ((data) = ((uchar *)(&(pt.x)))); 
# 696
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 697
} else 
# 699
{ 
# 700
create(2, 1, traits::template Type< _Tp> ::value); 
# 701
(((_Tp *)(data))[0]) = (pt.x); 
# 702
(((_Tp *)(data))[1]) = (pt.y); 
# 703
}  
# 704
} 
# 706
template< class _Tp> inline 
# 707
Mat::Mat(const Point3_< _Tp>  &pt, bool copyData) : flags(((MAGIC_VAL + traits::template Type< _Tp> ::value) + (1 << 14))), dims(2), rows(3), cols(1), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)), step(0) 
# 710
{ 
# 711
if (!copyData) 
# 712
{ 
# 713
(step)[0] = ((step)[1] = sizeof(_Tp)); 
# 714
(datastart) = ((data) = ((uchar *)(&(pt.x)))); 
# 715
(datalimit) = ((dataend) = ((datastart) + ((rows) * (step)[0]))); 
# 716
} else 
# 718
{ 
# 719
create(3, 1, traits::template Type< _Tp> ::value); 
# 720
(((_Tp *)(data))[0]) = (pt.x); 
# 721
(((_Tp *)(data))[1]) = (pt.y); 
# 722
(((_Tp *)(data))[2]) = (pt.z); 
# 723
}  
# 724
} 
# 726
template< class _Tp> inline 
# 727
Mat::Mat(const MatCommaInitializer_< _Tp>  &commaInitializer) : flags(((MAGIC_VAL + traits::template Type< _Tp> ::value) + (1 << 14))), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), allocator((0)), u((0)), size(&(rows)) 
# 730
{ 
# 731
(*this) = commaInitializer.MatCommaInitializer_< _Tp> ::operator Mat_< _Tp> (); 
# 732
} 
# 735
inline Mat::~Mat() 
# 736
{ 
# 737
this->release(); 
# 738
if (((step).p) != ((step).buf)) { 
# 739
fastFree((step).p); }  
# 740
} 
# 743
inline Mat &Mat::operator=(const Mat &m) 
# 744
{ 
# 745
if (this != (&m)) 
# 746
{ 
# 747
if (m.u) { 
# 748
(int)__atomic_fetch_add((unsigned *)(&((m.u)->refcount)), (unsigned)1, 4); }  
# 749
this->release(); 
# 750
(flags) = (m.flags); 
# 751
if (((dims) <= 2) && ((m.dims) <= 2)) 
# 752
{ 
# 753
(dims) = (m.dims); 
# 754
(rows) = (m.rows); 
# 755
(cols) = (m.cols); 
# 756
(step)[0] = (m.step)[0]; 
# 757
(step)[1] = (m.step)[1]; 
# 758
} else { 
# 760
this->copySize(m); }  
# 761
(data) = (m.data); 
# 762
(datastart) = (m.datastart); 
# 763
(dataend) = (m.dataend); 
# 764
(datalimit) = (m.datalimit); 
# 765
(allocator) = (m.allocator); 
# 766
(u) = (m.u); 
# 767
}  
# 768
return *this; 
# 769
} 
# 772
inline Mat Mat::row(int y) const 
# 773
{ 
# 774
return Mat(*this, Range(y, y + 1), Range::all()); 
# 775
} 
# 778
inline Mat Mat::col(int x) const 
# 779
{ 
# 780
return Mat(*this, Range::all(), Range(x, x + 1)); 
# 781
} 
# 784
inline Mat Mat::rowRange(int startrow, int endrow) const 
# 785
{ 
# 786
return Mat(*this, Range(startrow, endrow), Range::all()); 
# 787
} 
# 790
inline Mat Mat::rowRange(const Range &r) const 
# 791
{ 
# 792
return Mat(*this, r, Range::all()); 
# 793
} 
# 796
inline Mat Mat::colRange(int startcol, int endcol) const 
# 797
{ 
# 798
return Mat(*this, Range::all(), Range(startcol, endcol)); 
# 799
} 
# 802
inline Mat Mat::colRange(const Range &r) const 
# 803
{ 
# 804
return Mat(*this, Range::all(), r); 
# 805
} 
# 808
inline Mat Mat::clone() const 
# 809
{ 
# 810
Mat m; 
# 811
this->copyTo(m); 
# 812
return m; 
# 813
} 
# 816
inline void Mat::assignTo(Mat &m, int _type) const 
# 817
{ 
# 818
if (_type < 0) { 
# 819
(m = (*this)); } else { 
# 821
this->convertTo(m, _type); }  
# 822
} 
# 825
inline void Mat::create(int _rows, int _cols, int _type) 
# 826
{ 
# 827
_type &= (TYPE_MASK); 
# 828
if (((dims) <= 2) && ((rows) == _rows) && ((cols) == _cols) && (this->type() == _type) && (data)) { 
# 829
return; }  
# 830
int sz[] = {_rows, _cols}; 
# 831
this->create(2, sz, _type); 
# 832
} 
# 835
inline void Mat::create(Size _sz, int _type) 
# 836
{ 
# 837
this->create(_sz.height, _sz.width, _type); 
# 838
} 
# 841
inline void Mat::addref() 
# 842
{ 
# 843
if (u) { 
# 844
(int)__atomic_fetch_add((unsigned *)(&((u)->refcount)), (unsigned)1, 4); }  
# 845
} 
# 848
inline void Mat::release() 
# 849
{ 
# 850
if ((u) && (((int)__atomic_fetch_add((unsigned *)(&((u)->refcount)), (unsigned)(-1), 4)) == 1)) { 
# 851
this->deallocate(); }  
# 852
(u) = (__null); 
# 853
(datastart) = ((dataend) = ((datalimit) = ((data) = (0)))); 
# 854
for (int i = 0; i < (dims); i++) { 
# 855
(((size).p)[i]) = 0; }  
# 866 "/usr/include/opencv4/opencv2/core/mat.inl.hpp" 3
} 
# 869
inline Mat Mat::operator()(Range _rowRange, Range _colRange) const 
# 870
{ 
# 871
return Mat(*this, _rowRange, _colRange); 
# 872
} 
# 875
inline Mat Mat::operator()(const Rect &roi) const 
# 876
{ 
# 877
return Mat(*this, roi); 
# 878
} 
# 881
inline Mat Mat::operator()(const Range *ranges) const 
# 882
{ 
# 883
return Mat(*this, ranges); 
# 884
} 
# 887
inline Mat Mat::operator()(const std::vector< Range>  &ranges) const 
# 888
{ 
# 889
return Mat(*this, ranges); 
# 890
} 
# 893
inline bool Mat::isContinuous() const 
# 894
{ 
# 895
return ((flags) & (CONTINUOUS_FLAG)) != 0; 
# 896
} 
# 899
inline bool Mat::isSubmatrix() const 
# 900
{ 
# 901
return ((flags) & (SUBMATRIX_FLAG)) != 0; 
# 902
} 
# 905
inline size_t Mat::elemSize() const 
# 906
{ 
# 907
size_t res = ((dims) > 0) ? ((step).p)[(dims) - 1] : (0); 
# 908
; 
# 909
return res; 
# 910
} 
# 913
inline size_t Mat::elemSize1() const 
# 914
{ 
# 915
return ((675553809 >> (((flags) & ((1 << 3) - 1)) * 4)) & 15); 
# 916
} 
# 919
inline int Mat::type() const 
# 920
{ 
# 921
return ((flags) & (((1 << 3) * 512) - 1)); 
# 922
} 
# 925
inline int Mat::depth() const 
# 926
{ 
# 927
return ((flags) & ((1 << 3) - 1)); 
# 928
} 
# 931
inline int Mat::channels() const 
# 932
{ 
# 933
return ((((flags) & ((512 - 1) << 3)) >> 3) + 1); 
# 934
} 
# 937
inline size_t Mat::step1(int i) const 
# 938
{ 
# 939
return (((step).p)[i]) / this->elemSize1(); 
# 940
} 
# 943
inline bool Mat::empty() const 
# 944
{ 
# 945
return (((data) == (0)) || (this->total() == (0))) || ((dims) == 0); 
# 946
} 
# 949
inline size_t Mat::total() const 
# 950
{ 
# 951
if ((dims) <= 2) { 
# 952
return ((size_t)(rows)) * (cols); }  
# 953
size_t p = (1); 
# 954
for (int i = 0; i < (dims); i++) { 
# 955
p *= ((size)[i]); }  
# 956
return p; 
# 957
} 
# 960
inline size_t Mat::total(int startDim, int endDim) const 
# 961
{ 
# 962
do { if (!(!((0 <= startDim) && (startDim <= endDim)))) { ; } else { cv::error(cv::Error::StsAssert, "0 <= startDim && startDim <= endDim", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 962); }  } while (0); 
# 963
size_t p = (1); 
# 964
int endDim_ = (endDim <= (dims)) ? endDim : (dims); 
# 965
for (int i = startDim; i < endDim_; i++) { 
# 966
p *= ((size)[i]); }  
# 967
return p; 
# 968
} 
# 971
inline uchar *Mat::ptr(int y) 
# 972
{ 
# 973
; 
# 974
return (data) + ((((step).p)[0]) * y); 
# 975
} 
# 978
inline const uchar *Mat::ptr(int y) const 
# 979
{ 
# 980
; 
# 981
return (data) + ((((step).p)[0]) * y); 
# 982
} 
# 984
template< class _Tp> inline _Tp *
# 985
Mat::ptr(int y) 
# 986
{ 
# 987
; 
# 988
return (_Tp *)((data) + ((((step).p)[0]) * y)); 
# 989
} 
# 991
template< class _Tp> inline const _Tp *
# 992
Mat::ptr(int y) const 
# 993
{ 
# 994
; 
# 995
return (const _Tp *)((data) + ((((step).p)[0]) * y)); 
# 996
} 
# 999
inline uchar *Mat::ptr(int i0, int i1) 
# 1000
{ 
# 1001
; 
# 1002
; 
# 1003
; 
# 1004
; 
# 1005
return ((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1])); 
# 1006
} 
# 1009
inline const uchar *Mat::ptr(int i0, int i1) const 
# 1010
{ 
# 1011
; 
# 1012
; 
# 1013
; 
# 1014
; 
# 1015
return ((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1])); 
# 1016
} 
# 1018
template< class _Tp> inline _Tp *
# 1019
Mat::ptr(int i0, int i1) 
# 1020
{ 
# 1021
; 
# 1022
; 
# 1023
; 
# 1024
; 
# 1025
return (_Tp *)(((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))); 
# 1026
} 
# 1028
template< class _Tp> inline const _Tp *
# 1029
Mat::ptr(int i0, int i1) const 
# 1030
{ 
# 1031
; 
# 1032
; 
# 1033
; 
# 1034
; 
# 1035
return (const _Tp *)(((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))); 
# 1036
} 
# 1039
inline uchar *Mat::ptr(int i0, int i1, int i2) 
# 1040
{ 
# 1041
; 
# 1042
; 
# 1043
; 
# 1044
; 
# 1045
; 
# 1046
return (((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))) + (i2 * (((step).p)[2])); 
# 1047
} 
# 1050
inline const uchar *Mat::ptr(int i0, int i1, int i2) const 
# 1051
{ 
# 1052
; 
# 1053
; 
# 1054
; 
# 1055
; 
# 1056
; 
# 1057
return (((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))) + (i2 * (((step).p)[2])); 
# 1058
} 
# 1060
template< class _Tp> inline _Tp *
# 1061
Mat::ptr(int i0, int i1, int i2) 
# 1062
{ 
# 1063
; 
# 1064
; 
# 1065
; 
# 1066
; 
# 1067
; 
# 1068
return (_Tp *)((((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))) + (i2 * (((step).p)[2]))); 
# 1069
} 
# 1071
template< class _Tp> inline const _Tp *
# 1072
Mat::ptr(int i0, int i1, int i2) const 
# 1073
{ 
# 1074
; 
# 1075
; 
# 1076
; 
# 1077
; 
# 1078
; 
# 1079
return (const _Tp *)((((data) + (i0 * (((step).p)[0]))) + (i1 * (((step).p)[1]))) + (i2 * (((step).p)[2]))); 
# 1080
} 
# 1083
inline uchar *Mat::ptr(const int *idx) 
# 1084
{ 
# 1085
int i, d = dims; 
# 1086
uchar *p = data; 
# 1087
; 
# 1088
for (i = 0; i < d; i++) 
# 1089
{ 
# 1090
; 
# 1091
p += ((idx[i]) * (((step).p)[i])); 
# 1092
}  
# 1093
return p; 
# 1094
} 
# 1097
inline const uchar *Mat::ptr(const int *idx) const 
# 1098
{ 
# 1099
int i, d = dims; 
# 1100
uchar *p = data; 
# 1101
; 
# 1102
for (i = 0; i < d; i++) 
# 1103
{ 
# 1104
; 
# 1105
p += ((idx[i]) * (((step).p)[i])); 
# 1106
}  
# 1107
return p; 
# 1108
} 
# 1110
template< class _Tp> inline _Tp *
# 1111
Mat::ptr(const int *idx) 
# 1112
{ 
# 1113
int i, d = dims; 
# 1114
uchar *p = data; 
# 1115
; 
# 1116
for (i = 0; i < d; i++) 
# 1117
{ 
# 1118
; 
# 1119
p += ((idx[i]) * (((step).p)[i])); 
# 1120
}  
# 1121
return (_Tp *)p; 
# 1122
} 
# 1124
template< class _Tp> inline const _Tp *
# 1125
Mat::ptr(const int *idx) const 
# 1126
{ 
# 1127
int i, d = dims; 
# 1128
uchar *p = data; 
# 1129
; 
# 1130
for (i = 0; i < d; i++) 
# 1131
{ 
# 1132
; 
# 1133
p += ((idx[i]) * (((step).p)[i])); 
# 1134
}  
# 1135
return (const _Tp *)p; 
# 1136
} 
# 1138
template< class _Tp> inline _Tp &
# 1139
Mat::at(int i0, int i1) 
# 1140
{ 
# 1141
; 
# 1142
; 
# 1143
; 
# 1144
; 
# 1145
; 
# 1146
return ((_Tp *)((data) + ((((step).p)[0]) * i0)))[i1]; 
# 1147
} 
# 1149
template< class _Tp> inline const _Tp &
# 1150
Mat::at(int i0, int i1) const 
# 1151
{ 
# 1152
; 
# 1153
; 
# 1154
; 
# 1155
; 
# 1156
; 
# 1157
return ((const _Tp *)((data) + ((((step).p)[0]) * i0)))[i1]; 
# 1158
} 
# 1160
template< class _Tp> inline _Tp &
# 1161
Mat::at(Point pt) 
# 1162
{ 
# 1163
; 
# 1164
; 
# 1165
; 
# 1166
; 
# 1167
; 
# 1168
return ((_Tp *)((data) + ((((step).p)[0]) * (pt.y))))[pt.x]; 
# 1169
} 
# 1171
template< class _Tp> inline const _Tp &
# 1172
Mat::at(Point pt) const 
# 1173
{ 
# 1174
; 
# 1175
; 
# 1176
; 
# 1177
; 
# 1178
; 
# 1179
return ((const _Tp *)((data) + ((((step).p)[0]) * (pt.y))))[pt.x]; 
# 1180
} 
# 1182
template< class _Tp> inline _Tp &
# 1183
Mat::at(int i0) 
# 1184
{ 
# 1185
; 
# 1186
; 
# 1187
; 
# 1188
; 
# 1189
if (this->isContinuous() || ((((size).p)[0]) == 1)) { 
# 1190
return ((_Tp *)(data))[i0]; }  
# 1191
if ((((size).p)[1]) == 1) { 
# 1192
return *((_Tp *)((data) + ((((step).p)[0]) * i0))); }  
# 1193
int i = i0 / (cols), j = i0 - (i * (cols)); 
# 1194
return ((_Tp *)((data) + ((((step).p)[0]) * i)))[j]; 
# 1195
} 
# 1197
template< class _Tp> inline const _Tp &
# 1198
Mat::at(int i0) const 
# 1199
{ 
# 1200
; 
# 1201
; 
# 1202
; 
# 1203
; 
# 1204
if (this->isContinuous() || ((((size).p)[0]) == 1)) { 
# 1205
return ((const _Tp *)(data))[i0]; }  
# 1206
if ((((size).p)[1]) == 1) { 
# 1207
return *((const _Tp *)((data) + ((((step).p)[0]) * i0))); }  
# 1208
int i = i0 / (cols), j = i0 - (i * (cols)); 
# 1209
return ((const _Tp *)((data) + ((((step).p)[0]) * i)))[j]; 
# 1210
} 
# 1212
template< class _Tp> inline _Tp &
# 1213
Mat::at(int i0, int i1, int i2) 
# 1214
{ 
# 1215
; 
# 1216
return *((_Tp *)this->ptr(i0, i1, i2)); 
# 1217
} 
# 1219
template< class _Tp> inline const _Tp &
# 1220
Mat::at(int i0, int i1, int i2) const 
# 1221
{ 
# 1222
; 
# 1223
return *((const _Tp *)this->ptr(i0, i1, i2)); 
# 1224
} 
# 1226
template< class _Tp> inline _Tp &
# 1227
Mat::at(const int *idx) 
# 1228
{ 
# 1229
; 
# 1230
return *((_Tp *)this->ptr(idx)); 
# 1231
} 
# 1233
template< class _Tp> inline const _Tp &
# 1234
Mat::at(const int *idx) const 
# 1235
{ 
# 1236
; 
# 1237
return *((const _Tp *)this->ptr(idx)); 
# 1238
} 
# 1240
template< class _Tp, int n> inline _Tp &
# 1241
Mat::at(const Vec< int, n>  &idx) 
# 1242
{ 
# 1243
; 
# 1244
return *((_Tp *)ptr((idx.val))); 
# 1245
} 
# 1247
template< class _Tp, int n> inline const _Tp &
# 1248
Mat::at(const Vec< int, n>  &idx) const 
# 1249
{ 
# 1250
; 
# 1251
return *((const _Tp *)ptr((idx.val))); 
# 1252
} 
# 1254
template< class _Tp> inline MatConstIterator_< _Tp>  
# 1255
Mat::begin() const 
# 1256
{ 
# 1257
; 
# 1258
return ((MatConstIterator_< _Tp> )((const Mat_< _Tp>  *)this)); 
# 1259
} 
# 1261
template< class _Tp> inline MatConstIterator_< _Tp>  
# 1262
Mat::end() const 
# 1263
{ 
# 1264
; 
# 1265
MatConstIterator_< _Tp>  it((const Mat_< _Tp>  *)this); 
# 1266
it += this->total(); 
# 1267
return it; 
# 1268
} 
# 1270
template< class _Tp> inline MatIterator_< _Tp>  
# 1271
Mat::begin() 
# 1272
{ 
# 1273
; 
# 1274
return ((MatIterator_< _Tp> )((Mat_< _Tp>  *)this)); 
# 1275
} 
# 1277
template< class _Tp> inline MatIterator_< _Tp>  
# 1278
Mat::end() 
# 1279
{ 
# 1280
; 
# 1281
MatIterator_< _Tp>  it((Mat_< _Tp>  *)this); 
# 1282
it += this->total(); 
# 1283
return it; 
# 1284
} 
# 1286
template< class _Tp, class Functor> inline void 
# 1287
Mat::forEach(const Functor &operation) { 
# 1288
this->template forEach_impl< _Tp> (operation); 
# 1289
} 
# 1291
template< class _Tp, class Functor> inline void 
# 1292
Mat::forEach(const Functor &operation) const { 
# 1294
(const_cast< Mat *>(this))->template forEach< _Tp> (operation); 
# 1295
} 
# 1297
template< class _Tp> inline 
# 1298
Mat::operator std::vector< _Tp> () const 
# 1299
{ 
# 1300
std::vector< _Tp>  v; 
# 1301
copyTo(v); 
# 1302
return v; 
# 1303
} 
# 1305
template< class _Tp, std::size_t _Nm> inline 
# 1306
Mat::operator std::array< _Tp, _Nm> () const 
# 1307
{ 
# 1308
std::array< _Tp, _Nm>  v; 
# 1309
copyTo(v); 
# 1310
return v; 
# 1311
} 
# 1313
template< class _Tp, int n> inline 
# 1314
Mat::operator Vec< _Tp, n> () const 
# 1315
{ 
# 1316
do { if (!(!((data) && ((dims) <= 2) && (((rows) == 1) || ((cols) == 1)) && ((((rows) + (cols)) - 1) == n) && (this->channels() == 1)))) { ; } else { cv::error(cv::Error::StsAssert, "data && dims <= 2 && (rows == 1 || cols == 1) && rows + cols - 1 == n && channels() == 1", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 1316); }  } while (0); 
# 1319
if (this->isContinuous() && (this->type() == traits::template Type< _Tp> ::value)) { 
# 1320
return ((Vec< _Tp, n> )((_Tp *)(data))); }  
# 1321
Vec< _Tp, n>  v; 
# 1322
Mat tmp(rows, cols, traits::template Type< _Tp> ::value, (v.val)); 
# 1323
this->convertTo(tmp, tmp.type()); 
# 1324
return v; 
# 1325
} 
# 1327
template< class _Tp, int m, int n> inline 
# 1328
Mat::operator Matx< _Tp, m, n> () const 
# 1329
{ 
# 1330
do { if (!(!((data) && ((dims) <= 2) && ((rows) == m) && ((cols) == n) && (this->channels() == 1)))) { ; } else { cv::error(cv::Error::StsAssert, "data && dims <= 2 && rows == m && cols == n && channels() == 1", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 1330); }  } while (0); 
# 1332
if (this->isContinuous() && (this->type() == traits::template Type< _Tp> ::value)) { 
# 1333
return ((Matx< _Tp, m, n> )((_Tp *)(data))); }  
# 1334
Matx< _Tp, m, n>  mtx; 
# 1335
Mat tmp(rows, cols, traits::template Type< _Tp> ::value, (mtx.val)); 
# 1336
this->convertTo(tmp, tmp.type()); 
# 1337
return mtx; 
# 1338
} 
# 1340
template< class _Tp> inline void 
# 1341
Mat::push_back(const _Tp &elem) 
# 1342
{ 
# 1343
if (!(data)) 
# 1344
{ 
# 1345
((*this) = (Mat(1, 1, traits::template Type< _Tp> ::value, (void *)(&elem)).clone())); 
# 1346
return; 
# 1347
}  
# 1348
do { if (!(!((traits::template Type< _Tp> ::value == this->type()) && ((cols) == 1)))) { ; } else { cv::error(cv::Error::StsAssert, "traits::Type<_Tp>::value == type() && cols == 1", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 1348); }  } while (0); 
# 1350
const uchar *tmp = (dataend) + (step)[0]; 
# 1351
if ((!this->isSubmatrix()) && this->isContinuous() && (tmp <= (datalimit))) 
# 1352
{ 
# 1353
(*((_Tp *)((data) + (((((size).p)[0])++) * (((step).p)[0]))))) = elem; 
# 1354
(dataend) = tmp; 
# 1355
} else { 
# 1357
this->push_back_(&elem); }  
# 1358
} 
# 1360
template< class _Tp> inline void 
# 1361
Mat::push_back(const Mat_< _Tp>  &m) 
# 1362
{ 
# 1363
this->push_back((const Mat &)m); 
# 1364
} 
# 1367
template<> inline void Mat::push_back(const MatExpr &expr) 
# 1368
{ 
# 1369
this->push_back(static_cast< Mat>(expr)); 
# 1370
} 
# 1373
template< class _Tp> inline void 
# 1374
Mat::push_back(const std::vector< _Tp>  &v) 
# 1375
{ 
# 1376
this->push_back(((Mat)(v))); 
# 1377
} 
# 1380
inline Mat::Mat(Mat &&m) : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data), datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator), u(m.u), size(&(rows)) 
# 1384
{ 
# 1385
if ((m.dims) <= 2) 
# 1386
{ 
# 1387
(step)[0] = (m.step)[0]; 
# 1388
(step)[1] = (m.step)[1]; 
# 1389
} else 
# 1391
{ 
# 1392
; 
# 1393
((step).p) = ((m.step).p); 
# 1394
((size).p) = ((m.size).p); 
# 1395
((m.step).p) = ((m.step).buf); 
# 1396
((m.size).p) = (&(m.rows)); 
# 1397
}  
# 1398
(m.flags) = (MAGIC_VAL); (m.dims) = ((m.rows) = ((m.cols) = 0)); 
# 1399
(m.data) = (__null); (m.datastart) = (__null); (m.dataend) = (__null); (m.datalimit) = (__null); 
# 1400
(m.allocator) = (__null); 
# 1401
(m.u) = (__null); 
# 1402
} 
# 1405
inline Mat &Mat::operator=(Mat &&m) 
# 1406
{ 
# 1407
if (this == (&m)) { 
# 1408
return *this; }  
# 1410
this->release(); 
# 1411
(flags) = (m.flags); (dims) = (m.dims); (rows) = (m.rows); (cols) = (m.cols); (data) = (m.data); 
# 1412
(datastart) = (m.datastart); (dataend) = (m.dataend); (datalimit) = (m.datalimit); (allocator) = (m.allocator); 
# 1413
(u) = (m.u); 
# 1414
if (((step).p) != ((step).buf)) 
# 1415
{ 
# 1416
fastFree((step).p); 
# 1417
((step).p) = ((step).buf); 
# 1418
((size).p) = (&(rows)); 
# 1419
}  
# 1420
if ((m.dims) <= 2) 
# 1421
{ 
# 1422
(step)[0] = (m.step)[0]; 
# 1423
(step)[1] = (m.step)[1]; 
# 1424
} else 
# 1426
{ 
# 1427
; 
# 1428
((step).p) = ((m.step).p); 
# 1429
((size).p) = ((m.size).p); 
# 1430
((m.step).p) = ((m.step).buf); 
# 1431
((m.size).p) = (&(m.rows)); 
# 1432
}  
# 1433
(m.flags) = (MAGIC_VAL); (m.dims) = ((m.rows) = ((m.cols) = 0)); 
# 1434
(m.data) = (__null); (m.datastart) = (__null); (m.dataend) = (__null); (m.datalimit) = (__null); 
# 1435
(m.allocator) = (__null); 
# 1436
(m.u) = (__null); 
# 1437
return *this; 
# 1438
} 
# 1444
inline MatSize::MatSize(int *_p) : p(_p) 
# 1445
{ } 
# 1448
inline int MatSize::dims() const 
# 1449
{ 
# 1450
return ((p) - 1)[0]; 
# 1451
} 
# 1454
inline Size MatSize::operator()() const 
# 1455
{ 
# 1456
; 
# 1457
return Size((p)[1], (p)[0]); 
# 1458
} 
# 1461
inline const int &MatSize::operator[](int i) const 
# 1462
{ 
# 1463
; 
# 1467
return (p)[i]; 
# 1468
} 
# 1471
inline int &MatSize::operator[](int i) 
# 1472
{ 
# 1473
; 
# 1477
return (p)[i]; 
# 1478
} 
# 1481
inline MatSize::operator const int *() const 
# 1482
{ 
# 1483
return p; 
# 1484
} 
# 1487
inline bool MatSize::operator==(const MatSize &sz) const 
# 1488
{ 
# 1489
int d = this->dims(); 
# 1490
int dsz = sz.dims(); 
# 1491
if (d != dsz) { 
# 1492
return false; }  
# 1493
if (d == 2) { 
# 1494
return (((p)[0]) == ((sz.p)[0])) && (((p)[1]) == ((sz.p)[1])); }  
# 1496
for (int i = 0; i < d; i++) { 
# 1497
if (((p)[i]) != ((sz.p)[i])) { 
# 1498
return false; }  }  
# 1499
return true; 
# 1500
} 
# 1503
inline bool MatSize::operator!=(const MatSize &sz) const 
# 1504
{ 
# 1505
return !((*this) == sz); 
# 1506
} 
# 1513
inline MatStep::MatStep() 
# 1514
{ 
# 1515
(p) = (buf); ((p)[0]) = (((p)[1]) = (0)); 
# 1516
} 
# 1519
inline MatStep::MatStep(size_t s) 
# 1520
{ 
# 1521
(p) = (buf); ((p)[0]) = s; ((p)[1]) = (0); 
# 1522
} 
# 1525
inline const size_t &MatStep::operator[](int i) const 
# 1526
{ 
# 1527
return (p)[i]; 
# 1528
} 
# 1531
inline size_t &MatStep::operator[](int i) 
# 1532
{ 
# 1533
return (p)[i]; 
# 1534
} 
# 1536
inline MatStep::operator size_t() const 
# 1537
{ 
# 1538
; 
# 1539
return (buf)[0]; 
# 1540
} 
# 1542
inline MatStep &MatStep::operator=(size_t s) 
# 1543
{ 
# 1544
; 
# 1545
((buf)[0]) = s; 
# 1546
return *this; 
# 1547
} 
# 1553
template< class _Tp> inline 
# 1554
Mat_< _Tp> ::Mat_() : Mat() 
# 1556
{ 
# 1557
(flags) = (((flags) & (~(((1 << 3) * 512) - 1))) + traits::template Type< _Tp> ::value); 
# 1558
} 
# 1560
template< class _Tp> inline 
# 1561
Mat_< _Tp> ::Mat_(int _rows, int _cols) : Mat(_rows, _cols, traits::template Type< _Tp> ::value) 
# 1563
{ 
# 1564
} 
# 1566
template< class _Tp> inline 
# 1567
Mat_< _Tp> ::Mat_(int _rows, int _cols, const _Tp &value) : Mat(_rows, _cols, traits::template Type< _Tp> ::value) 
# 1569
{ 
# 1570
(*this) = value; 
# 1571
} 
# 1573
template< class _Tp> inline 
# 1574
Mat_< _Tp> ::Mat_(Size _sz) : Mat(_sz.height, _sz.width, traits::template Type< _Tp> ::value) 
# 1576
{ } 
# 1578
template< class _Tp> inline 
# 1579
Mat_< _Tp> ::Mat_(Size _sz, const _Tp &value) : Mat(_sz.height, _sz.width, traits::template Type< _Tp> ::value) 
# 1581
{ 
# 1582
(*this) = value; 
# 1583
} 
# 1585
template< class _Tp> inline 
# 1586
Mat_< _Tp> ::Mat_(int _dims, const int *_sz) : Mat(_dims, _sz, traits::template Type< _Tp> ::value) 
# 1588
{ } 
# 1590
template< class _Tp> inline 
# 1591
Mat_< _Tp> ::Mat_(int _dims, const int *_sz, const _Tp &_s) : Mat(_dims, _sz, traits::template Type< _Tp> ::value, ((Scalar_< double> )(_s))) 
# 1593
{ } 
# 1595
template< class _Tp> inline 
# 1596
Mat_< _Tp> ::Mat_(int _dims, const int *_sz, _Tp *_data, const size_t *_steps) : Mat(_dims, _sz, traits::template Type< _Tp> ::value, _data, _steps) 
# 1598
{ } 
# 1600
template< class _Tp> inline 
# 1601
Mat_< _Tp> ::Mat_(const Mat_ &m, const Range *ranges) : Mat(m, ranges) 
# 1603
{ } 
# 1605
template< class _Tp> inline 
# 1606
Mat_< _Tp> ::Mat_(const Mat_ &m, const std::vector< Range>  &ranges) : Mat(m, ranges) 
# 1608
{ } 
# 1610
template< class _Tp> inline 
# 1611
Mat_< _Tp> ::Mat_(const Mat &m) : Mat() 
# 1613
{ 
# 1614
(flags) = (((flags) & (~(((1 << 3) * 512) - 1))) + traits::template Type< _Tp> ::value); 
# 1615
(*this) = m; 
# 1616
} 
# 1618
template< class _Tp> inline 
# 1619
Mat_< _Tp> ::Mat_(const Mat_ &m) : Mat(m) 
# 1621
{ } 
# 1623
template< class _Tp> inline 
# 1624
Mat_< _Tp> ::Mat_(int _rows, int _cols, _Tp *_data, size_t steps) : Mat(_rows, _cols, traits::template Type< _Tp> ::value, _data, steps) 
# 1626
{ } 
# 1628
template< class _Tp> inline 
# 1629
Mat_< _Tp> ::Mat_(const Mat_ &m, const Range &_rowRange, const Range &_colRange) : Mat(m, _rowRange, _colRange) 
# 1631
{ } 
# 1633
template< class _Tp> inline 
# 1634
Mat_< _Tp> ::Mat_(const Mat_ &m, const Rect &roi) : Mat(m, roi) 
# 1636
{ } 
# 1638
template< class _Tp> template< int n> inline 
# 1639
Mat_< _Tp> ::Mat_(const Vec< typename DataType< _Tp> ::channel_type, n>  &vec, bool copyData) : Mat(n / DataType< _Tp> ::channels, 1, traits::template Type< _Tp> ::value, (void *)(&vec)) 
# 1641
{ 
# 1642
do { if (!(!((n % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "n%DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 1642); }  } while (0); 
# 1643
if (copyData) { 
# 1644
(*this) = clone(); }  
# 1645
} 
# 1647
template< class _Tp> template< int m, int n> inline 
# 1648
Mat_< _Tp> ::Mat_(const Matx< typename DataType< _Tp> ::channel_type, m, n>  &M, bool copyData) : Mat(m, n / DataType< _Tp> ::channels, traits::template Type< _Tp> ::value, (void *)(&M)) 
# 1650
{ 
# 1651
do { if (!(!((n % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 1651); }  } while (0); 
# 1652
if (copyData) { 
# 1653
(*this) = clone(); }  
# 1654
} 
# 1656
template< class _Tp> inline 
# 1657
Mat_< _Tp> ::Mat_(const Point_< typename DataType< _Tp> ::channel_type>  &pt, bool copyData) : Mat(2 / DataType< _Tp> ::channels, 1, traits::template Type< _Tp> ::value, (void *)(&pt)) 
# 1659
{ 
# 1660
do { if (!(!((2 % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "2 % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 1660); }  } while (0); 
# 1661
if (copyData) { 
# 1662
(*this) = clone(); }  
# 1663
} 
# 1665
template< class _Tp> inline 
# 1666
Mat_< _Tp> ::Mat_(const Point3_< typename DataType< _Tp> ::channel_type>  &pt, bool copyData) : Mat(3 / DataType< _Tp> ::channels, 1, traits::template Type< _Tp> ::value, (void *)(&pt)) 
# 1668
{ 
# 1669
do { if (!(!((3 % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "3 % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 1669); }  } while (0); 
# 1670
if (copyData) { 
# 1671
(*this) = clone(); }  
# 1672
} 
# 1674
template< class _Tp> inline 
# 1675
Mat_< _Tp> ::Mat_(const MatCommaInitializer_< _Tp>  &commaInitializer) : Mat(commaInitializer) 
# 1677
{ } 
# 1679
template< class _Tp> inline 
# 1680
Mat_< _Tp> ::Mat_(const std::vector< _Tp>  &vec, bool copyData) : Mat(vec, copyData) 
# 1682
{ } 
# 1684
template< class _Tp> inline 
# 1685
Mat_< _Tp> ::Mat_(std::initializer_list< _Tp>  list) : Mat(list) 
# 1687
{ } 
# 1689
template< class _Tp> inline 
# 1690
Mat_< _Tp> ::Mat_(const std::initializer_list< std::vector< int> ::value_type>  sizes, std::initializer_list< _Tp>  list) : Mat(sizes, list) 
# 1692
{ } 
# 1694
template< class _Tp> template< std::size_t _Nm> inline 
# 1695
Mat_< _Tp> ::Mat_(const std::array< _Tp, _Nm>  &arr, bool copyData) : Mat(arr, copyData) 
# 1697
{ } 
# 1699
template< class _Tp> inline Mat_< _Tp>  &
# 1700
Mat_< _Tp> ::operator=(const Mat &m) 
# 1701
{ 
# 1702
if (m.empty()) 
# 1703
{ 
# 1704
release(); 
# 1705
return *this; 
# 1706
}  
# 1707
if (traits::template Type< _Tp> ::value == m.type()) 
# 1708
{ 
# 1709
this->Mat::operator=(m); 
# 1710
return *this; 
# 1711
}  
# 1712
if (traits::template Depth< _Tp> ::value == m.depth()) 
# 1713
{ 
# 1714
return ((*this) = m.reshape(DataType< _Tp> ::channels, m.dims, 0)); 
# 1715
}  
# 1716
do { if (!(!((DataType< _Tp> ::channels == m.channels()) || m.empty()))) { ; } else { cv::error(cv::Error::StsAssert, "DataType<_Tp>::channels == m.channels() || m.empty()", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 1716); }  } while (0); 
# 1717
m.convertTo(*this, type()); 
# 1718
return *this; 
# 1719
} 
# 1721
template< class _Tp> inline Mat_< _Tp>  &
# 1722
Mat_< _Tp> ::operator=(const Mat_ &m) 
# 1723
{ 
# 1724
Mat::operator=(m); 
# 1725
return *this; 
# 1726
} 
# 1728
template< class _Tp> inline Mat_< _Tp>  &
# 1729
Mat_< _Tp> ::operator=(const _Tp &s) 
# 1730
{ 
# 1731
typedef typename DataType< _Tp> ::vec_type VT; 
# 1732
this->Mat::operator=(((Scalar_< double> )((const VT &)s))); 
# 1733
return *this; 
# 1734
} 
# 1736
template< class _Tp> inline void 
# 1737
Mat_< _Tp> ::create(int _rows, int _cols) 
# 1738
{ 
# 1739
Mat::create(_rows, _cols, traits::template Type< _Tp> ::value); 
# 1740
} 
# 1742
template< class _Tp> inline void 
# 1743
Mat_< _Tp> ::create(Size _sz) 
# 1744
{ 
# 1745
Mat::create(_sz, traits::template Type< _Tp> ::value); 
# 1746
} 
# 1748
template< class _Tp> inline void 
# 1749
Mat_< _Tp> ::create(int _dims, const int *_sz) 
# 1750
{ 
# 1751
Mat::create(_dims, _sz, traits::template Type< _Tp> ::value); 
# 1752
} 
# 1754
template< class _Tp> inline void 
# 1755
Mat_< _Tp> ::release() 
# 1756
{ 
# 1757
this->Mat::release(); 
# 1761
} 
# 1763
template< class _Tp> inline Mat_< _Tp>  
# 1764
Mat_< _Tp> ::cross(const Mat_ &m) const 
# 1765
{ 
# 1766
return ((Mat_)(this->Mat::cross(m))); 
# 1767
} 
# 1769
template< class _Tp> template< class T2> inline 
# 1770
Mat_< _Tp> ::operator Mat_< T2> () const 
# 1771
{ 
# 1772
return ((Mat_< T2> )(static_cast< const Mat &>(*this))); 
# 1773
} 
# 1775
template< class _Tp> inline Mat_< _Tp>  
# 1776
Mat_< _Tp> ::row(int y) const 
# 1777
{ 
# 1778
return Mat_(*this, Range(y, y + 1), Range::all()); 
# 1779
} 
# 1781
template< class _Tp> inline Mat_< _Tp>  
# 1782
Mat_< _Tp> ::col(int x) const 
# 1783
{ 
# 1784
return Mat_(*this, Range::all(), Range(x, x + 1)); 
# 1785
} 
# 1787
template< class _Tp> inline Mat_< _Tp>  
# 1788
Mat_< _Tp> ::diag(int d) const 
# 1789
{ 
# 1790
return ((Mat_)(this->Mat::diag(d))); 
# 1791
} 
# 1793
template< class _Tp> inline Mat_< _Tp>  
# 1794
Mat_< _Tp> ::clone() const 
# 1795
{ 
# 1796
return ((Mat_)(this->Mat::clone())); 
# 1797
} 
# 1799
template< class _Tp> inline size_t 
# 1800
Mat_< _Tp> ::elemSize() const 
# 1801
{ 
# 1802
; 
# 1803
return sizeof(_Tp); 
# 1804
} 
# 1806
template< class _Tp> inline size_t 
# 1807
Mat_< _Tp> ::elemSize1() const 
# 1808
{ 
# 1809
; 
# 1810
return sizeof(_Tp) / DataType< _Tp> ::channels; 
# 1811
} 
# 1813
template< class _Tp> inline int 
# 1814
Mat_< _Tp> ::type() const 
# 1815
{ 
# 1816
; 
# 1817
return traits::template Type< _Tp> ::value; 
# 1818
} 
# 1820
template< class _Tp> inline int 
# 1821
Mat_< _Tp> ::depth() const 
# 1822
{ 
# 1823
; 
# 1824
return traits::template Depth< _Tp> ::value; 
# 1825
} 
# 1827
template< class _Tp> inline int 
# 1828
Mat_< _Tp> ::channels() const 
# 1829
{ 
# 1830
; 
# 1831
return DataType< _Tp> ::channels; 
# 1832
} 
# 1834
template< class _Tp> inline size_t 
# 1835
Mat_< _Tp> ::stepT(int i) const 
# 1836
{ 
# 1837
return (((step).p)[i]) / elemSize(); 
# 1838
} 
# 1840
template< class _Tp> inline size_t 
# 1841
Mat_< _Tp> ::step1(int i) const 
# 1842
{ 
# 1843
return (((step).p)[i]) / elemSize1(); 
# 1844
} 
# 1846
template< class _Tp> inline Mat_< _Tp>  &
# 1847
Mat_< _Tp> ::adjustROI(int dtop, int dbottom, int dleft, int dright) 
# 1848
{ 
# 1849
return (Mat_ &)this->Mat::adjustROI(dtop, dbottom, dleft, dright); 
# 1850
} 
# 1852
template< class _Tp> inline Mat_< _Tp>  
# 1853
Mat_< _Tp> ::operator()(const Range &_rowRange, const Range &_colRange) const 
# 1854
{ 
# 1855
return Mat_(*this, _rowRange, _colRange); 
# 1856
} 
# 1858
template< class _Tp> inline Mat_< _Tp>  
# 1859
Mat_< _Tp> ::operator()(const Rect &roi) const 
# 1860
{ 
# 1861
return Mat_(*this, roi); 
# 1862
} 
# 1864
template< class _Tp> inline Mat_< _Tp>  
# 1865
Mat_< _Tp> ::operator()(const Range *ranges) const 
# 1866
{ 
# 1867
return Mat_(*this, ranges); 
# 1868
} 
# 1870
template< class _Tp> inline Mat_< _Tp>  
# 1871
Mat_< _Tp> ::operator()(const std::vector< Range>  &ranges) const 
# 1872
{ 
# 1873
return Mat_(*this, ranges); 
# 1874
} 
# 1876
template< class _Tp> inline _Tp *
# 1877
Mat_< _Tp> ::operator[](int y) 
# 1878
{ 
# 1879
; 
# 1880
return (_Tp *)((data) + (y * (((step).p)[0]))); 
# 1881
} 
# 1883
template< class _Tp> inline const _Tp *
# 1884
Mat_< _Tp> ::operator[](int y) const 
# 1885
{ 
# 1886
; 
# 1887
return (const _Tp *)((data) + (y * (((step).p)[0]))); 
# 1888
} 
# 1890
template< class _Tp> inline _Tp &
# 1891
Mat_< _Tp> ::operator()(int i0, int i1) 
# 1892
{ 
# 1893
; 
# 1894
; 
# 1895
; 
# 1896
; 
# 1897
; 
# 1898
return ((_Tp *)((data) + ((((step).p)[0]) * i0)))[i1]; 
# 1899
} 
# 1901
template< class _Tp> inline const _Tp &
# 1902
Mat_< _Tp> ::operator()(int i0, int i1) const 
# 1903
{ 
# 1904
; 
# 1905
; 
# 1906
; 
# 1907
; 
# 1908
; 
# 1909
return ((const _Tp *)((data) + ((((step).p)[0]) * i0)))[i1]; 
# 1910
} 
# 1912
template< class _Tp> inline _Tp &
# 1913
Mat_< _Tp> ::operator()(Point pt) 
# 1914
{ 
# 1915
; 
# 1916
; 
# 1917
; 
# 1918
; 
# 1919
; 
# 1920
return ((_Tp *)((data) + ((((step).p)[0]) * (pt.y))))[pt.x]; 
# 1921
} 
# 1923
template< class _Tp> inline const _Tp &
# 1924
Mat_< _Tp> ::operator()(Point pt) const 
# 1925
{ 
# 1926
; 
# 1927
; 
# 1928
; 
# 1929
; 
# 1930
; 
# 1931
return ((const _Tp *)((data) + ((((step).p)[0]) * (pt.y))))[pt.x]; 
# 1932
} 
# 1934
template< class _Tp> inline _Tp &
# 1935
Mat_< _Tp> ::operator()(const int *idx) 
# 1936
{ 
# 1937
return Mat::template at< _Tp> (idx); 
# 1938
} 
# 1940
template< class _Tp> inline const _Tp &
# 1941
Mat_< _Tp> ::operator()(const int *idx) const 
# 1942
{ 
# 1943
return Mat::template at< _Tp> (idx); 
# 1944
} 
# 1946
template< class _Tp> template< int n> inline _Tp &
# 1947
Mat_< _Tp> ::operator()(const Vec< int, n>  &idx) 
# 1948
{ 
# 1949
return Mat::template at< _Tp> (idx); 
# 1950
} 
# 1952
template< class _Tp> template< int n> inline const _Tp &
# 1953
Mat_< _Tp> ::operator()(const Vec< int, n>  &idx) const 
# 1954
{ 
# 1955
return Mat::template at< _Tp> (idx); 
# 1956
} 
# 1958
template< class _Tp> inline _Tp &
# 1959
Mat_< _Tp> ::operator()(int i0) 
# 1960
{ 
# 1961
return this->template at< _Tp> (i0); 
# 1962
} 
# 1964
template< class _Tp> inline const _Tp &
# 1965
Mat_< _Tp> ::operator()(int i0) const 
# 1966
{ 
# 1967
return this->template at< _Tp> (i0); 
# 1968
} 
# 1970
template< class _Tp> inline _Tp &
# 1971
Mat_< _Tp> ::operator()(int i0, int i1, int i2) 
# 1972
{ 
# 1973
return this->template at< _Tp> (i0, i1, i2); 
# 1974
} 
# 1976
template< class _Tp> inline const _Tp &
# 1977
Mat_< _Tp> ::operator()(int i0, int i1, int i2) const 
# 1978
{ 
# 1979
return this->template at< _Tp> (i0, i1, i2); 
# 1980
} 
# 1982
template< class _Tp> inline 
# 1983
Mat_< _Tp> ::operator std::vector< _Tp> () const 
# 1984
{ 
# 1985
std::vector< _Tp>  v; 
# 1986
copyTo(v); 
# 1987
return v; 
# 1988
} 
# 1990
template< class _Tp> template< std::size_t _Nm> inline 
# 1991
Mat_< _Tp> ::operator std::array< _Tp, _Nm> () const 
# 1992
{ 
# 1993
std::array< _Tp, _Nm>  a; 
# 1994
copyTo(a); 
# 1995
return a; 
# 1996
} 
# 1998
template< class _Tp> template< int n> inline 
# 1999
Mat_< _Tp> ::operator Vec< typename DataType< _Tp> ::channel_type, n> () const 
# 2000
{ 
# 2001
do { if (!(!((n % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 2001); }  } while (0); 
# 2007
return this->Mat::operator Vec< typename DataType< _Tp> ::channel_type, n> (); 
# 2009
} 
# 2011
template< class _Tp> template< int m, int n> inline 
# 2012
Mat_< _Tp> ::operator Matx< typename DataType< _Tp> ::channel_type, m, n> () const 
# 2013
{ 
# 2014
do { if (!(!((n % DataType< _Tp> ::channels) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "n % DataType<_Tp>::channels == 0", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 2014); }  } while (0); 
# 2021
Matx< typename DataType< _Tp> ::channel_type, m, n>  res = this->Mat::operator Matx< typename DataType< _Tp> ::channel_type, m, n> (); 
# 2022
return res; 
# 2024
} 
# 2026
template< class _Tp> inline typename Mat_< _Tp> ::const_iterator 
# 2027
Mat_< _Tp> ::begin() const 
# 2028
{ 
# 2029
return Mat::template begin< _Tp> (); 
# 2030
} 
# 2032
template< class _Tp> inline typename Mat_< _Tp> ::const_iterator 
# 2033
Mat_< _Tp> ::end() const 
# 2034
{ 
# 2035
return Mat::template end< _Tp> (); 
# 2036
} 
# 2038
template< class _Tp> inline typename Mat_< _Tp> ::iterator 
# 2039
Mat_< _Tp> ::begin() 
# 2040
{ 
# 2041
return Mat::template begin< _Tp> (); 
# 2042
} 
# 2044
template< class _Tp> inline typename Mat_< _Tp> ::iterator 
# 2045
Mat_< _Tp> ::end() 
# 2046
{ 
# 2047
return Mat::template end< _Tp> (); 
# 2048
} 
# 2050
template< class _Tp> template< class Functor> inline void 
# 2051
Mat_< _Tp> ::forEach(const Functor &operation) { 
# 2052
Mat::template forEach< _Tp, Functor> (operation); 
# 2053
} 
# 2055
template< class _Tp> template< class Functor> inline void 
# 2056
Mat_< _Tp> ::forEach(const Functor &operation) const { 
# 2057
Mat::template forEach< _Tp, Functor> (operation); 
# 2058
} 
# 2060
template< class _Tp> inline 
# 2061
Mat_< _Tp> ::Mat_(Mat_ &&m) : Mat(std::move(m)) 
# 2063
{ 
# 2064
} 
# 2066
template< class _Tp> inline Mat_< _Tp>  &
# 2067
Mat_< _Tp> ::operator=(Mat_ &&m) 
# 2068
{ 
# 2069
Mat::operator=(std::move(m)); 
# 2070
return *this; 
# 2071
} 
# 2073
template< class _Tp> inline 
# 2074
Mat_< _Tp> ::Mat_(Mat &&m) : Mat() 
# 2076
{ 
# 2077
(flags) = (((flags) & (~(((1 << 3) * 512) - 1))) + traits::template Type< _Tp> ::value); 
# 2078
(*this) = std::move(m); 
# 2079
} 
# 2081
template< class _Tp> inline Mat_< _Tp>  &
# 2082
Mat_< _Tp> ::operator=(Mat &&m) 
# 2083
{ 
# 2084
if (m.empty()) 
# 2085
{ 
# 2086
release(); 
# 2087
return *this; 
# 2088
}  
# 2089
if (traits::template Type< _Tp> ::value == m.type()) 
# 2090
{ 
# 2091
this->Mat::operator=((Mat &&)m); 
# 2092
return *this; 
# 2093
}  
# 2094
if (traits::template Depth< _Tp> ::value == m.depth()) 
# 2095
{ 
# 2096
this->Mat::operator=((Mat &&)m.reshape(DataType< _Tp> ::channels, m.dims, 0)); 
# 2097
return *this; 
# 2098
}  
# 2099
; 
# 2100
m.convertTo(*this, type()); 
# 2101
return *this; 
# 2102
} 
# 2104
template< class _Tp> inline 
# 2105
Mat_< _Tp> ::Mat_(MatExpr &&e) : Mat() 
# 2107
{ 
# 2108
(flags) = (((flags) & (~(((1 << 3) * 512) - 1))) + traits::template Type< _Tp> ::value); 
# 2109
(*this) = ((Mat)(e)); 
# 2110
} 
# 2116
inline SparseMat::SparseMat() : flags((MAGIC_VAL)), hdr((0)) 
# 2118
{ } 
# 2121
inline SparseMat::SparseMat(int _dims, const int *_sizes, int _type) : flags((MAGIC_VAL)), hdr((0)) 
# 2123
{ 
# 2124
this->create(_dims, _sizes, _type); 
# 2125
} 
# 2128
inline SparseMat::SparseMat(const SparseMat &m) : flags(m.flags), hdr(m.hdr) 
# 2130
{ 
# 2131
this->addref(); 
# 2132
} 
# 2135
inline SparseMat::~SparseMat() 
# 2136
{ 
# 2137
this->release(); 
# 2138
} 
# 2141
inline SparseMat &SparseMat::operator=(const SparseMat &m) 
# 2142
{ 
# 2143
if (this != (&m)) 
# 2144
{ 
# 2145
if (m.hdr) { 
# 2146
(int)__atomic_fetch_add((unsigned *)(&((m.hdr)->refcount)), (unsigned)1, 4); }  
# 2147
this->release(); 
# 2148
(flags) = (m.flags); 
# 2149
(hdr) = (m.hdr); 
# 2150
}  
# 2151
return *this; 
# 2152
} 
# 2155
inline SparseMat &SparseMat::operator=(const Mat &m) 
# 2156
{ 
# 2157
return ((*this) = ((SparseMat)(m))); 
# 2158
} 
# 2161
inline SparseMat SparseMat::clone() const 
# 2162
{ 
# 2163
SparseMat temp; 
# 2164
this->copyTo(temp); 
# 2165
return temp; 
# 2166
} 
# 2169
inline void SparseMat::assignTo(SparseMat &m, int _type) const 
# 2170
{ 
# 2171
if (_type < 0) { 
# 2172
(m = (*this)); } else { 
# 2174
this->convertTo(m, _type); }  
# 2175
} 
# 2178
inline void SparseMat::addref() 
# 2179
{ 
# 2180
if (hdr) { 
# 2181
(int)__atomic_fetch_add((unsigned *)(&((hdr)->refcount)), (unsigned)1, 4); }  
# 2182
} 
# 2185
inline void SparseMat::release() 
# 2186
{ 
# 2187
if ((hdr) && (((int)__atomic_fetch_add((unsigned *)(&((hdr)->refcount)), (unsigned)(-1), 4)) == 1)) { 
# 2188
delete (hdr); }  
# 2189
(hdr) = (0); 
# 2190
} 
# 2193
inline size_t SparseMat::elemSize() const 
# 2194
{ 
# 2195
return (((((flags) & ((512 - 1) << 3)) >> 3) + 1) * ((675553809 >> (((flags) & ((1 << 3) - 1)) * 4)) & 15)); 
# 2196
} 
# 2199
inline size_t SparseMat::elemSize1() const 
# 2200
{ 
# 2201
return ((675553809 >> (((flags) & ((1 << 3) - 1)) * 4)) & 15); 
# 2202
} 
# 2205
inline int SparseMat::type() const 
# 2206
{ 
# 2207
return ((flags) & (((1 << 3) * 512) - 1)); 
# 2208
} 
# 2211
inline int SparseMat::depth() const 
# 2212
{ 
# 2213
return ((flags) & ((1 << 3) - 1)); 
# 2214
} 
# 2217
inline int SparseMat::channels() const 
# 2218
{ 
# 2219
return ((((flags) & ((512 - 1) << 3)) >> 3) + 1); 
# 2220
} 
# 2223
inline const int *SparseMat::size() const 
# 2224
{ 
# 2225
return (hdr) ? (hdr)->size : (0); 
# 2226
} 
# 2229
inline int SparseMat::size(int i) const 
# 2230
{ 
# 2231
if (hdr) 
# 2232
{ 
# 2233
; 
# 2234
return ((hdr)->size)[i]; 
# 2235
}  
# 2236
return 0; 
# 2237
} 
# 2240
inline int SparseMat::dims() const 
# 2241
{ 
# 2242
return (hdr) ? (hdr)->dims : 0; 
# 2243
} 
# 2246
inline size_t SparseMat::nzcount() const 
# 2247
{ 
# 2248
return (hdr) ? (hdr)->nodeCount : (0); 
# 2249
} 
# 2252
inline size_t SparseMat::hash(int i0) const 
# 2253
{ 
# 2254
return (size_t)i0; 
# 2255
} 
# 2258
inline size_t SparseMat::hash(int i0, int i1) const 
# 2259
{ 
# 2260
return (((size_t)((unsigned)i0)) * (HASH_SCALE)) + ((unsigned)i1); 
# 2261
} 
# 2264
inline size_t SparseMat::hash(int i0, int i1, int i2) const 
# 2265
{ 
# 2266
return (((((size_t)((unsigned)i0)) * (HASH_SCALE)) + ((unsigned)i1)) * (HASH_SCALE)) + ((unsigned)i2); 
# 2267
} 
# 2270
inline size_t SparseMat::hash(const int *idx) const 
# 2271
{ 
# 2272
size_t h = (unsigned)(idx[0]); 
# 2273
if (!(hdr)) { 
# 2274
return 0; }  
# 2275
int d = (hdr)->dims; 
# 2276
for (int i = 1; i < d; i++) { 
# 2277
h = ((h * (HASH_SCALE)) + ((unsigned)(idx[i]))); }  
# 2278
return h; 
# 2279
} 
# 2281
template< class _Tp> inline _Tp &
# 2282
SparseMat::ref(int i0, size_t *hashval) 
# 2283
{ 
# 2284
return *((_Tp *)((SparseMat *)this)->ptr(i0, true, hashval)); 
# 2285
} 
# 2287
template< class _Tp> inline _Tp &
# 2288
SparseMat::ref(int i0, int i1, size_t *hashval) 
# 2289
{ 
# 2290
return *((_Tp *)((SparseMat *)this)->ptr(i0, i1, true, hashval)); 
# 2291
} 
# 2293
template< class _Tp> inline _Tp &
# 2294
SparseMat::ref(int i0, int i1, int i2, size_t *hashval) 
# 2295
{ 
# 2296
return *((_Tp *)((SparseMat *)this)->ptr(i0, i1, i2, true, hashval)); 
# 2297
} 
# 2299
template< class _Tp> inline _Tp &
# 2300
SparseMat::ref(const int *idx, size_t *hashval) 
# 2301
{ 
# 2302
return *((_Tp *)((SparseMat *)this)->ptr(idx, true, hashval)); 
# 2303
} 
# 2305
template< class _Tp> inline _Tp 
# 2306
SparseMat::value(int i0, size_t *hashval) const 
# 2307
{ 
# 2308
const _Tp *p = (const _Tp *)((SparseMat *)this)->ptr(i0, false, hashval); 
# 2309
return (p) ? *p : _Tp(); 
# 2310
} 
# 2312
template< class _Tp> inline _Tp 
# 2313
SparseMat::value(int i0, int i1, size_t *hashval) const 
# 2314
{ 
# 2315
const _Tp *p = (const _Tp *)((SparseMat *)this)->ptr(i0, i1, false, hashval); 
# 2316
return (p) ? *p : _Tp(); 
# 2317
} 
# 2319
template< class _Tp> inline _Tp 
# 2320
SparseMat::value(int i0, int i1, int i2, size_t *hashval) const 
# 2321
{ 
# 2322
const _Tp *p = (const _Tp *)((SparseMat *)this)->ptr(i0, i1, i2, false, hashval); 
# 2323
return (p) ? *p : _Tp(); 
# 2324
} 
# 2326
template< class _Tp> inline _Tp 
# 2327
SparseMat::value(const int *idx, size_t *hashval) const 
# 2328
{ 
# 2329
const _Tp *p = (const _Tp *)((SparseMat *)this)->ptr(idx, false, hashval); 
# 2330
return (p) ? *p : _Tp(); 
# 2331
} 
# 2333
template< class _Tp> inline const _Tp *
# 2334
SparseMat::find(int i0, size_t *hashval) const 
# 2335
{ 
# 2336
return (const _Tp *)((SparseMat *)this)->ptr(i0, false, hashval); 
# 2337
} 
# 2339
template< class _Tp> inline const _Tp *
# 2340
SparseMat::find(int i0, int i1, size_t *hashval) const 
# 2341
{ 
# 2342
return (const _Tp *)((SparseMat *)this)->ptr(i0, i1, false, hashval); 
# 2343
} 
# 2345
template< class _Tp> inline const _Tp *
# 2346
SparseMat::find(int i0, int i1, int i2, size_t *hashval) const 
# 2347
{ 
# 2348
return (const _Tp *)((SparseMat *)this)->ptr(i0, i1, i2, false, hashval); 
# 2349
} 
# 2351
template< class _Tp> inline const _Tp *
# 2352
SparseMat::find(const int *idx, size_t *hashval) const 
# 2353
{ 
# 2354
return (const _Tp *)((SparseMat *)this)->ptr(idx, false, hashval); 
# 2355
} 
# 2357
template< class _Tp> inline _Tp &
# 2358
SparseMat::value(Node *n) 
# 2359
{ 
# 2360
return *((_Tp *)(((uchar *)n) + ((hdr)->valueOffset))); 
# 2361
} 
# 2363
template< class _Tp> inline const _Tp &
# 2364
SparseMat::value(const Node *n) const 
# 2365
{ 
# 2366
return *((const _Tp *)(((const uchar *)n) + ((hdr)->valueOffset))); 
# 2367
} 
# 2370
inline SparseMat::Node *SparseMat::node(size_t nidx) 
# 2371
{ 
# 2372
return (Node *)((void *)(&((hdr)->pool)[nidx])); 
# 2373
} 
# 2376
inline const SparseMat::Node *SparseMat::node(size_t nidx) const 
# 2377
{ 
# 2378
return (const Node *)((const void *)(&((hdr)->pool)[nidx])); 
# 2379
} 
# 2382
inline SparseMatIterator SparseMat::begin() 
# 2383
{ 
# 2384
return ((SparseMatIterator)(this)); 
# 2385
} 
# 2388
inline SparseMatConstIterator SparseMat::begin() const 
# 2389
{ 
# 2390
return ((SparseMatConstIterator)(this)); 
# 2391
} 
# 2394
inline SparseMatIterator SparseMat::end() 
# 2395
{ 
# 2396
SparseMatIterator it(this); 
# 2397
it.seekEnd(); 
# 2398
return it; 
# 2399
} 
# 2402
inline SparseMatConstIterator SparseMat::end() const 
# 2403
{ 
# 2404
SparseMatConstIterator it(this); 
# 2405
it.seekEnd(); 
# 2406
return it; 
# 2407
} 
# 2409
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 2410
SparseMat::begin() 
# 2411
{ 
# 2412
return ((SparseMatIterator_< _Tp> )(this)); 
# 2413
} 
# 2415
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 2416
SparseMat::begin() const 
# 2417
{ 
# 2418
return ((SparseMatConstIterator_< _Tp> )(this)); 
# 2419
} 
# 2421
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 2422
SparseMat::end() 
# 2423
{ 
# 2424
SparseMatIterator_< _Tp>  it(this); 
# 2425
it.seekEnd(); 
# 2426
return it; 
# 2427
} 
# 2429
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 2430
SparseMat::end() const 
# 2431
{ 
# 2432
SparseMatConstIterator_< _Tp>  it(this); 
# 2433
it.seekEnd(); 
# 2434
return it; 
# 2435
} 
# 2441
template< class _Tp> inline 
# 2442
SparseMat_< _Tp> ::SparseMat_() 
# 2443
{ 
# 2444
(flags) = (MAGIC_VAL + traits::template Type< _Tp> ::value); 
# 2445
} 
# 2447
template< class _Tp> inline 
# 2448
SparseMat_< _Tp> ::SparseMat_(int _dims, const int *_sizes) : SparseMat(_dims, _sizes, traits::template Type< _Tp> ::value) 
# 2450
{ } 
# 2452
template< class _Tp> inline 
# 2453
SparseMat_< _Tp> ::SparseMat_(const SparseMat &m) 
# 2454
{ 
# 2455
if (m.type() == traits::template Type< _Tp> ::value) { 
# 2456
(*this) = ((const SparseMat_ &)m); } else { 
# 2458
m.convertTo(*this, traits::template Type< _Tp> ::value); }  
# 2459
} 
# 2461
template< class _Tp> inline 
# 2462
SparseMat_< _Tp> ::SparseMat_(const SparseMat_ &m) 
# 2463
{ 
# 2464
(this->flags) = (m.flags); 
# 2465
(this->hdr) = (m.hdr); 
# 2466
if (this->hdr) { 
# 2467
(int)__atomic_fetch_add((unsigned *)(&((this->hdr)->refcount)), (unsigned)1, 4); }  
# 2468
} 
# 2470
template< class _Tp> inline 
# 2471
SparseMat_< _Tp> ::SparseMat_(const Mat &m) 
# 2472
{ 
# 2473
SparseMat sm(m); 
# 2474
(*this) = sm; 
# 2475
} 
# 2477
template< class _Tp> inline SparseMat_< _Tp>  &
# 2478
SparseMat_< _Tp> ::operator=(const SparseMat_ &m) 
# 2479
{ 
# 2480
if (this != (&m)) 
# 2481
{ 
# 2482
if (m.hdr) { (int)__atomic_fetch_add((unsigned *)(&((m.hdr)->refcount)), (unsigned)1, 4); }  
# 2483
this->SparseMat::release(); 
# 2484
(flags) = (m.flags); 
# 2485
(hdr) = (m.hdr); 
# 2486
}  
# 2487
return *this; 
# 2488
} 
# 2490
template< class _Tp> inline SparseMat_< _Tp>  &
# 2491
SparseMat_< _Tp> ::operator=(const SparseMat &m) 
# 2492
{ 
# 2493
if (m.type() == traits::template Type< _Tp> ::value) { 
# 2494
return ((*this) = ((const SparseMat_ &)m)); }  
# 2495
m.convertTo(*this, traits::template Type< _Tp> ::value); 
# 2496
return *this; 
# 2497
} 
# 2499
template< class _Tp> inline SparseMat_< _Tp>  &
# 2500
SparseMat_< _Tp> ::operator=(const Mat &m) 
# 2501
{ 
# 2502
return ((*this) = ((SparseMat)(m))); 
# 2503
} 
# 2505
template< class _Tp> inline SparseMat_< _Tp>  
# 2506
SparseMat_< _Tp> ::clone() const 
# 2507
{ 
# 2508
SparseMat_ m; 
# 2509
this->copyTo(m); 
# 2510
return m; 
# 2511
} 
# 2513
template< class _Tp> inline void 
# 2514
SparseMat_< _Tp> ::create(int _dims, const int *_sizes) 
# 2515
{ 
# 2516
this->SparseMat::create(_dims, _sizes, traits::template Type< _Tp> ::value); 
# 2517
} 
# 2519
template< class _Tp> inline int 
# 2520
SparseMat_< _Tp> ::type() const 
# 2521
{ 
# 2522
return traits::template Type< _Tp> ::value; 
# 2523
} 
# 2525
template< class _Tp> inline int 
# 2526
SparseMat_< _Tp> ::depth() const 
# 2527
{ 
# 2528
return traits::template Depth< _Tp> ::value; 
# 2529
} 
# 2531
template< class _Tp> inline int 
# 2532
SparseMat_< _Tp> ::channels() const 
# 2533
{ 
# 2534
return DataType< _Tp> ::channels; 
# 2535
} 
# 2537
template< class _Tp> inline _Tp &
# 2538
SparseMat_< _Tp> ::ref(int i0, size_t *hashval) 
# 2539
{ 
# 2540
return SparseMat::template ref< _Tp> (i0, hashval); 
# 2541
} 
# 2543
template< class _Tp> inline _Tp 
# 2544
SparseMat_< _Tp> ::operator()(int i0, size_t *hashval) const 
# 2545
{ 
# 2546
return SparseMat::template value< _Tp> (i0, hashval); 
# 2547
} 
# 2549
template< class _Tp> inline _Tp &
# 2550
SparseMat_< _Tp> ::ref(int i0, int i1, size_t *hashval) 
# 2551
{ 
# 2552
return SparseMat::template ref< _Tp> (i0, i1, hashval); 
# 2553
} 
# 2555
template< class _Tp> inline _Tp 
# 2556
SparseMat_< _Tp> ::operator()(int i0, int i1, size_t *hashval) const 
# 2557
{ 
# 2558
return SparseMat::template value< _Tp> (i0, i1, hashval); 
# 2559
} 
# 2561
template< class _Tp> inline _Tp &
# 2562
SparseMat_< _Tp> ::ref(int i0, int i1, int i2, size_t *hashval) 
# 2563
{ 
# 2564
return SparseMat::template ref< _Tp> (i0, i1, i2, hashval); 
# 2565
} 
# 2567
template< class _Tp> inline _Tp 
# 2568
SparseMat_< _Tp> ::operator()(int i0, int i1, int i2, size_t *hashval) const 
# 2569
{ 
# 2570
return SparseMat::template value< _Tp> (i0, i1, i2, hashval); 
# 2571
} 
# 2573
template< class _Tp> inline _Tp &
# 2574
SparseMat_< _Tp> ::ref(const int *idx, size_t *hashval) 
# 2575
{ 
# 2576
return SparseMat::template ref< _Tp> (idx, hashval); 
# 2577
} 
# 2579
template< class _Tp> inline _Tp 
# 2580
SparseMat_< _Tp> ::operator()(const int *idx, size_t *hashval) const 
# 2581
{ 
# 2582
return SparseMat::template value< _Tp> (idx, hashval); 
# 2583
} 
# 2585
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 2586
SparseMat_< _Tp> ::begin() 
# 2587
{ 
# 2588
return ((SparseMatIterator_< _Tp> )(this)); 
# 2589
} 
# 2591
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 2592
SparseMat_< _Tp> ::begin() const 
# 2593
{ 
# 2594
return ((SparseMatConstIterator_< _Tp> )(this)); 
# 2595
} 
# 2597
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 2598
SparseMat_< _Tp> ::end() 
# 2599
{ 
# 2600
SparseMatIterator_< _Tp>  it(this); 
# 2601
it.seekEnd(); 
# 2602
return it; 
# 2603
} 
# 2605
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 2606
SparseMat_< _Tp> ::end() const 
# 2607
{ 
# 2608
SparseMatConstIterator_< _Tp>  it(this); 
# 2609
it.seekEnd(); 
# 2610
return it; 
# 2611
} 
# 2618
inline MatConstIterator::MatConstIterator() : m((0)), elemSize((0)), ptr((0)), sliceStart((0)), sliceEnd((0)) 
# 2620
{ } 
# 2623
inline MatConstIterator::MatConstIterator(const Mat *_m) : m(_m), elemSize(_m->elemSize()), ptr((0)), sliceStart((0)), sliceEnd((0)) 
# 2625
{ 
# 2626
if ((m) && (m)->isContinuous()) 
# 2627
{ 
# 2628
(sliceStart) = (m)->ptr(); 
# 2629
(sliceEnd) = ((sliceStart) + ((m)->total() * (elemSize))); 
# 2630
}  
# 2631
this->seek((const int *)0); 
# 2632
} 
# 2635
inline MatConstIterator::MatConstIterator(const Mat *_m, int _row, int _col) : m(_m), elemSize(_m->elemSize()), ptr((0)), sliceStart((0)), sliceEnd((0)) 
# 2637
{ 
# 2638
do { if (!(!((m) && (((m)->dims) <= 2)))) { ; } else { cv::error(cv::Error::StsAssert, "m && m->dims <= 2", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 2638); }  } while (0); 
# 2639
if ((m)->isContinuous()) 
# 2640
{ 
# 2641
(sliceStart) = (m)->ptr(); 
# 2642
(sliceEnd) = ((sliceStart) + ((m)->total() * (elemSize))); 
# 2643
}  
# 2644
int idx[] = {_row, _col}; 
# 2645
this->seek(idx); 
# 2646
} 
# 2649
inline MatConstIterator::MatConstIterator(const Mat *_m, Point _pt) : m(_m), elemSize(_m->elemSize()), ptr((0)), sliceStart((0)), sliceEnd((0)) 
# 2651
{ 
# 2652
do { if (!(!((m) && (((m)->dims) <= 2)))) { ; } else { cv::error(cv::Error::StsAssert, "m && m->dims <= 2", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 2652); }  } while (0); 
# 2653
if ((m)->isContinuous()) 
# 2654
{ 
# 2655
(sliceStart) = (m)->ptr(); 
# 2656
(sliceEnd) = ((sliceStart) + ((m)->total() * (elemSize))); 
# 2657
}  
# 2658
int idx[] = {_pt.y, _pt.x}; 
# 2659
this->seek(idx); 
# 2660
} 
# 2663
inline MatConstIterator::MatConstIterator(const MatConstIterator &it) : m(it.m), elemSize(it.elemSize), ptr(it.ptr), sliceStart(it.sliceStart), sliceEnd(it.sliceEnd) 
# 2665
{ } 
# 2668
inline MatConstIterator &MatConstIterator::operator=(const MatConstIterator &it) 
# 2669
{ 
# 2670
(m) = (it.m); (elemSize) = (it.elemSize); (ptr) = (it.ptr); 
# 2671
(sliceStart) = (it.sliceStart); (sliceEnd) = (it.sliceEnd); 
# 2672
return *this; 
# 2673
} 
# 2676
inline const uchar *MatConstIterator::operator*() const 
# 2677
{ 
# 2678
return ptr; 
# 2679
} 
# 2681
inline MatConstIterator &MatConstIterator::operator+=(ptrdiff_t ofs) 
# 2682
{ 
# 2683
if ((!(m)) || (ofs == (0))) { 
# 2684
return *this; }  
# 2685
ptrdiff_t ofsb = ofs * (elemSize); 
# 2686
(ptr) += ofsb; 
# 2687
if (((ptr) < (sliceStart)) || ((sliceEnd) <= (ptr))) 
# 2688
{ 
# 2689
(ptr) -= ofsb; 
# 2690
this->seek(ofs, true); 
# 2691
}  
# 2692
return *this; 
# 2693
} 
# 2696
inline MatConstIterator &MatConstIterator::operator-=(ptrdiff_t ofs) 
# 2697
{ 
# 2698
return ((*this) += (-ofs)); 
# 2699
} 
# 2702
inline MatConstIterator &MatConstIterator::operator--() 
# 2703
{ 
# 2704
if ((m) && (((ptr) -= (elemSize)) < (sliceStart))) 
# 2705
{ 
# 2706
(ptr) += (elemSize); 
# 2707
this->seek(-1, true); 
# 2708
}  
# 2709
return *this; 
# 2710
} 
# 2713
inline MatConstIterator MatConstIterator::operator--(int) 
# 2714
{ 
# 2715
MatConstIterator b = *this; 
# 2716
((*this) += (-1)); 
# 2717
return b; 
# 2718
} 
# 2721
inline MatConstIterator &MatConstIterator::operator++() 
# 2722
{ 
# 2723
if ((m) && (((ptr) += (elemSize)) >= (sliceEnd))) 
# 2724
{ 
# 2725
(ptr) -= (elemSize); 
# 2726
this->seek(1, true); 
# 2727
}  
# 2728
return *this; 
# 2729
} 
# 2731
inline MatConstIterator MatConstIterator::operator++(int) 
# 2732
{ 
# 2733
MatConstIterator b = *this; 
# 2734
((*this) += (1)); 
# 2735
return b; 
# 2736
} 
# 2740
static inline bool operator==(const MatConstIterator &a, const MatConstIterator &b) 
# 2741
{ 
# 2742
return ((a.m) == (b.m)) && ((a.ptr) == (b.ptr)); 
# 2743
} 
# 2746
static inline bool operator!=(const MatConstIterator &a, const MatConstIterator &b) 
# 2747
{ 
# 2748
return !(a == b); 
# 2749
} 
# 2752
static inline bool operator<(const MatConstIterator &a, const MatConstIterator &b) 
# 2753
{ 
# 2754
return (a.ptr) < (b.ptr); 
# 2755
} 
# 2758
static inline bool operator>(const MatConstIterator &a, const MatConstIterator &b) 
# 2759
{ 
# 2760
return (a.ptr) > (b.ptr); 
# 2761
} 
# 2764
static inline bool operator<=(const MatConstIterator &a, const MatConstIterator &b) 
# 2765
{ 
# 2766
return (a.ptr) <= (b.ptr); 
# 2767
} 
# 2770
static inline bool operator>=(const MatConstIterator &a, const MatConstIterator &b) 
# 2771
{ 
# 2772
return (a.ptr) >= (b.ptr); 
# 2773
} 
# 2776
static inline ptrdiff_t operator-(const MatConstIterator &b, const MatConstIterator &a) 
# 2777
{ 
# 2778
if ((a.m) != (b.m)) { 
# 2779
return (((size_t)(-1)) >> 1); }  
# 2780
if ((a.sliceEnd) == (b.sliceEnd)) { 
# 2781
return ((b.ptr) - (a.ptr)) / (static_cast< ptrdiff_t>(b.elemSize)); }  
# 2783
return b.lpos() - a.lpos(); 
# 2784
} 
# 2787
static inline MatConstIterator operator+(const MatConstIterator &a, ptrdiff_t ofs) 
# 2788
{ 
# 2789
MatConstIterator b = a; 
# 2790
return (b += ofs); 
# 2791
} 
# 2794
static inline MatConstIterator operator+(ptrdiff_t ofs, const MatConstIterator &a) 
# 2795
{ 
# 2796
MatConstIterator b = a; 
# 2797
return (b += ofs); 
# 2798
} 
# 2801
static inline MatConstIterator operator-(const MatConstIterator &a, ptrdiff_t ofs) 
# 2802
{ 
# 2803
MatConstIterator b = a; 
# 2804
return (b += (-ofs)); 
# 2805
} 
# 2809
inline const uchar *MatConstIterator::operator[](ptrdiff_t i) const 
# 2810
{ 
# 2811
return (*(((*this) + i))); 
# 2812
} 
# 2818
template< class _Tp> inline 
# 2819
MatConstIterator_< _Tp> ::MatConstIterator_() 
# 2820
{ } 
# 2822
template< class _Tp> inline 
# 2823
MatConstIterator_< _Tp> ::MatConstIterator_(const Mat_< _Tp>  *_m) : MatConstIterator(_m) 
# 2825
{ } 
# 2827
template< class _Tp> inline 
# 2828
MatConstIterator_< _Tp> ::MatConstIterator_(const Mat_< _Tp>  *_m, int _row, int _col) : MatConstIterator(_m, _row, _col) 
# 2830
{ } 
# 2832
template< class _Tp> inline 
# 2833
MatConstIterator_< _Tp> ::MatConstIterator_(const Mat_< _Tp>  *_m, Point _pt) : MatConstIterator(_m, _pt) 
# 2835
{ } 
# 2837
template< class _Tp> inline 
# 2838
MatConstIterator_< _Tp> ::MatConstIterator_(const MatConstIterator_ &it) : MatConstIterator(it) 
# 2840
{ } 
# 2842
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2843
MatConstIterator_< _Tp> ::operator=(const MatConstIterator_ &it) 
# 2844
{ 
# 2845
this->MatConstIterator::operator=(it); 
# 2846
return *this; 
# 2847
} 
# 2849
template< class _Tp> inline const _Tp &
# 2850
MatConstIterator_< _Tp> ::operator*() const 
# 2851
{ 
# 2852
return *((_Tp *)(this->ptr)); 
# 2853
} 
# 2855
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2856
MatConstIterator_< _Tp> ::operator+=(ptrdiff_t ofs) 
# 2857
{ 
# 2858
this->MatConstIterator::operator+=(ofs); 
# 2859
return *this; 
# 2860
} 
# 2862
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2863
MatConstIterator_< _Tp> ::operator-=(ptrdiff_t ofs) 
# 2864
{ 
# 2865
return ((*this) += (-ofs)); 
# 2866
} 
# 2868
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2869
MatConstIterator_< _Tp> ::operator--() 
# 2870
{ 
# 2871
this->MatConstIterator::operator--(); 
# 2872
return *this; 
# 2873
} 
# 2875
template< class _Tp> inline MatConstIterator_< _Tp>  
# 2876
MatConstIterator_< _Tp> ::operator--(int) 
# 2877
{ 
# 2878
MatConstIterator_ b = *this; 
# 2879
this->MatConstIterator::operator--(); 
# 2880
return b; 
# 2881
} 
# 2883
template< class _Tp> inline MatConstIterator_< _Tp>  &
# 2884
MatConstIterator_< _Tp> ::operator++() 
# 2885
{ 
# 2886
this->MatConstIterator::operator++(); 
# 2887
return *this; 
# 2888
} 
# 2890
template< class _Tp> inline MatConstIterator_< _Tp>  
# 2891
MatConstIterator_< _Tp> ::operator++(int) 
# 2892
{ 
# 2893
MatConstIterator_ b = *this; 
# 2894
this->MatConstIterator::operator++(); 
# 2895
return b; 
# 2896
} 
# 2899
template< class _Tp> inline Point 
# 2900
MatConstIterator_< _Tp> ::pos() const 
# 2901
{ 
# 2902
if (!(m)) { 
# 2903
return Point(); }  
# 2904
; 
# 2905
if ((m)->isContinuous()) 
# 2906
{ 
# 2907
ptrdiff_t ofs = ((const _Tp *)(ptr)) - ((const _Tp *)((m)->data)); 
# 2908
int y = (int)(ofs / ((m)->cols)); 
# 2909
int x = (int)(ofs - (((ptrdiff_t)y) * ((m)->cols))); 
# 2910
return Point(x, y); 
# 2911
} else 
# 2913
{ 
# 2914
ptrdiff_t ofs = ((uchar *)(ptr)) - ((m)->data); 
# 2915
int y = (int)(ofs / ((m)->step)); 
# 2916
int x = (int)((ofs - (y * ((m)->step))) / sizeof(_Tp)); 
# 2917
return Point(x, y); 
# 2918
}  
# 2919
} 
# 2922
template< class _Tp> static inline bool 
# 2923
operator==(const MatConstIterator_< _Tp>  &a, const MatConstIterator_< _Tp>  &b) 
# 2924
{ 
# 2925
return ((a.m) == (b.m)) && ((a.ptr) == (b.ptr)); 
# 2926
} 
# 2928
template< class _Tp> static inline bool 
# 2929
operator!=(const MatConstIterator_< _Tp>  &a, const MatConstIterator_< _Tp>  &b) 
# 2930
{ 
# 2931
return ((a.m) != (b.m)) || ((a.ptr) != (b.ptr)); 
# 2932
} 
# 2934
template< class _Tp> static inline MatConstIterator_< _Tp>  
# 2935
operator+(const MatConstIterator_< _Tp>  &a, ptrdiff_t ofs) 
# 2936
{ 
# 2937
MatConstIterator t = (((const MatConstIterator &)a) + ofs); 
# 2938
return (MatConstIterator_< _Tp>  &)t; 
# 2939
} 
# 2941
template< class _Tp> static inline MatConstIterator_< _Tp>  
# 2942
operator+(ptrdiff_t ofs, const MatConstIterator_< _Tp>  &a) 
# 2943
{ 
# 2944
MatConstIterator t = (((const MatConstIterator &)a) + ofs); 
# 2945
return (MatConstIterator_< _Tp>  &)t; 
# 2946
} 
# 2948
template< class _Tp> static inline MatConstIterator_< _Tp>  
# 2949
operator-(const MatConstIterator_< _Tp>  &a, ptrdiff_t ofs) 
# 2950
{ 
# 2951
MatConstIterator t = (((const MatConstIterator &)a) - ofs); 
# 2952
return (MatConstIterator_< _Tp>  &)t; 
# 2953
} 
# 2955
template< class _Tp> inline const _Tp &
# 2956
MatConstIterator_< _Tp> ::operator[](ptrdiff_t i) const 
# 2957
{ 
# 2958
return *((_Tp *)this->MatConstIterator::operator[](i)); 
# 2959
} 
# 2965
template< class _Tp> inline 
# 2966
MatIterator_< _Tp> ::MatIterator_() : MatConstIterator_< _Tp> () 
# 2968
{ } 
# 2970
template< class _Tp> inline 
# 2971
MatIterator_< _Tp> ::MatIterator_(Mat_< _Tp>  *_m) : MatConstIterator_< _Tp> (_m) 
# 2973
{ } 
# 2975
template< class _Tp> inline 
# 2976
MatIterator_< _Tp> ::MatIterator_(Mat_< _Tp>  *_m, int _row, int _col) : MatConstIterator_< _Tp> (_m, _row, _col) 
# 2978
{ } 
# 2980
template< class _Tp> inline 
# 2981
MatIterator_< _Tp> ::MatIterator_(Mat_< _Tp>  *_m, cv::Point _pt) : MatConstIterator_< _Tp> (_m, _pt) 
# 2983
{ } 
# 2985
template< class _Tp> inline 
# 2986
MatIterator_< _Tp> ::MatIterator_(Mat_< _Tp>  *_m, const int *_idx) : MatConstIterator_< _Tp> (_m, _idx) 
# 2988
{ } 
# 2990
template< class _Tp> inline 
# 2991
MatIterator_< _Tp> ::MatIterator_(const MatIterator_ &it) : MatConstIterator_< _Tp> (it) 
# 2993
{ } 
# 2995
template< class _Tp> inline MatIterator_< _Tp>  &
# 2996
MatIterator_< _Tp> ::operator=(const MatIterator_ &it) 
# 2997
{ 
# 2998
cv::MatConstIterator::operator=(it); 
# 2999
return *this; 
# 3000
} 
# 3002
template< class _Tp> inline _Tp &
# 3003
MatIterator_< _Tp> ::operator*() const 
# 3004
{ 
# 3005
return *((_Tp *)(this->ptr)); 
# 3006
} 
# 3008
template< class _Tp> inline MatIterator_< _Tp>  &
# 3009
MatIterator_< _Tp> ::operator+=(::ptrdiff_t ofs) 
# 3010
{ 
# 3011
cv::MatConstIterator::operator+=(ofs); 
# 3012
return *this; 
# 3013
} 
# 3015
template< class _Tp> inline MatIterator_< _Tp>  &
# 3016
MatIterator_< _Tp> ::operator-=(::ptrdiff_t ofs) 
# 3017
{ 
# 3018
cv::MatConstIterator::operator+=(-ofs); 
# 3019
return *this; 
# 3020
} 
# 3022
template< class _Tp> inline MatIterator_< _Tp>  &
# 3023
MatIterator_< _Tp> ::operator--() 
# 3024
{ 
# 3025
cv::MatConstIterator::operator--(); 
# 3026
return *this; 
# 3027
} 
# 3029
template< class _Tp> inline MatIterator_< _Tp>  
# 3030
MatIterator_< _Tp> ::operator--(int) 
# 3031
{ 
# 3032
MatIterator_ b = *this; 
# 3033
cv::MatConstIterator::operator--(); 
# 3034
return b; 
# 3035
} 
# 3037
template< class _Tp> inline MatIterator_< _Tp>  &
# 3038
MatIterator_< _Tp> ::operator++() 
# 3039
{ 
# 3040
cv::MatConstIterator::operator++(); 
# 3041
return *this; 
# 3042
} 
# 3044
template< class _Tp> inline MatIterator_< _Tp>  
# 3045
MatIterator_< _Tp> ::operator++(int) 
# 3046
{ 
# 3047
MatIterator_ b = *this; 
# 3048
cv::MatConstIterator::operator++(); 
# 3049
return b; 
# 3050
} 
# 3052
template< class _Tp> inline _Tp &
# 3053
MatIterator_< _Tp> ::operator[](::ptrdiff_t i) const 
# 3054
{ 
# 3055
return *((*this) + i); 
# 3056
} 
# 3059
template< class _Tp> static inline bool 
# 3060
operator==(const MatIterator_< _Tp>  &a, const MatIterator_< _Tp>  &b) 
# 3061
{ 
# 3062
return ((a.m) == (b.m)) && ((a.ptr) == (b.ptr)); 
# 3063
} 
# 3065
template< class _Tp> static inline bool 
# 3066
operator!=(const MatIterator_< _Tp>  &a, const MatIterator_< _Tp>  &b) 
# 3067
{ 
# 3068
return ((a.m) != (b.m)) || ((a.ptr) != (b.ptr)); 
# 3069
} 
# 3071
template< class _Tp> static inline MatIterator_< _Tp>  
# 3072
operator+(const MatIterator_< _Tp>  &a, ptrdiff_t ofs) 
# 3073
{ 
# 3074
MatConstIterator t = (((const MatConstIterator &)a) + ofs); 
# 3075
return (MatIterator_< _Tp>  &)t; 
# 3076
} 
# 3078
template< class _Tp> static inline MatIterator_< _Tp>  
# 3079
operator+(ptrdiff_t ofs, const MatIterator_< _Tp>  &a) 
# 3080
{ 
# 3081
MatConstIterator t = (((const MatConstIterator &)a) + ofs); 
# 3082
return (MatIterator_< _Tp>  &)t; 
# 3083
} 
# 3085
template< class _Tp> static inline MatIterator_< _Tp>  
# 3086
operator-(const MatIterator_< _Tp>  &a, ptrdiff_t ofs) 
# 3087
{ 
# 3088
MatConstIterator t = (((const MatConstIterator &)a) - ofs); 
# 3089
return (MatIterator_< _Tp>  &)t; 
# 3090
} 
# 3097
inline SparseMatConstIterator::SparseMatConstIterator() : m((0)), hashidx((0)), ptr((0)) 
# 3099
{ } 
# 3102
inline SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator &it) : m(it.m), hashidx(it.hashidx), ptr(it.ptr) 
# 3104
{ } 
# 3106
inline SparseMatConstIterator &SparseMatConstIterator::operator=(const SparseMatConstIterator &it) 
# 3107
{ 
# 3108
if (this != (&it)) 
# 3109
{ 
# 3110
(m) = (it.m); 
# 3111
(hashidx) = (it.hashidx); 
# 3112
(ptr) = (it.ptr); 
# 3113
}  
# 3114
return *this; 
# 3115
} 
# 3117
template< class _Tp> inline const _Tp &
# 3118
SparseMatConstIterator::value() const 
# 3119
{ 
# 3120
return *((const _Tp *)(ptr)); 
# 3121
} 
# 3124
inline const SparseMat::Node *SparseMatConstIterator::node() const 
# 3125
{ 
# 3126
return ((ptr) && (m) && ((m)->hdr)) ? (const SparseMat::Node *)((const void *)((ptr) - (((m)->hdr)->valueOffset))) : (0); 
# 3127
} 
# 3130
inline SparseMatConstIterator SparseMatConstIterator::operator++(int) 
# 3131
{ 
# 3132
SparseMatConstIterator it = *this; 
# 3133
(++(*this)); 
# 3134
return it; 
# 3135
} 
# 3138
inline void SparseMatConstIterator::seekEnd() 
# 3139
{ 
# 3140
if ((m) && ((m)->hdr)) 
# 3141
{ 
# 3142
(hashidx) = (((m)->hdr)->hashtab).size(); 
# 3143
(ptr) = (0); 
# 3144
}  
# 3145
} 
# 3149
static inline bool operator==(const SparseMatConstIterator &it1, const SparseMatConstIterator &it2) 
# 3150
{ 
# 3151
return ((it1.m) == (it2.m)) && ((it1.ptr) == (it2.ptr)); 
# 3152
} 
# 3155
static inline bool operator!=(const SparseMatConstIterator &it1, const SparseMatConstIterator &it2) 
# 3156
{ 
# 3157
return !(it1 == it2); 
# 3158
} 
# 3165
inline SparseMatIterator::SparseMatIterator() 
# 3166
{ } 
# 3169
inline SparseMatIterator::SparseMatIterator(SparseMat *_m) : SparseMatConstIterator(_m) 
# 3171
{ } 
# 3174
inline SparseMatIterator::SparseMatIterator(const SparseMatIterator &it) : SparseMatConstIterator(it) 
# 3176
{ } 
# 3179
inline SparseMatIterator &SparseMatIterator::operator=(const SparseMatIterator &it) 
# 3180
{ 
# 3181
(((SparseMatConstIterator &)(*this)) = it); 
# 3182
return *this; 
# 3183
} 
# 3185
template< class _Tp> inline _Tp &
# 3186
SparseMatIterator::value() const 
# 3187
{ 
# 3188
return *((_Tp *)(ptr)); 
# 3189
} 
# 3192
inline SparseMat::Node *SparseMatIterator::node() const 
# 3193
{ 
# 3194
return (SparseMat::Node *)this->SparseMatConstIterator::node(); 
# 3195
} 
# 3198
inline SparseMatIterator &SparseMatIterator::operator++() 
# 3199
{ 
# 3200
this->SparseMatConstIterator::operator++(); 
# 3201
return *this; 
# 3202
} 
# 3205
inline SparseMatIterator SparseMatIterator::operator++(int) 
# 3206
{ 
# 3207
SparseMatIterator it = *this; 
# 3208
(++(*this)); 
# 3209
return it; 
# 3210
} 
# 3216
template< class _Tp> inline 
# 3217
SparseMatConstIterator_< _Tp> ::SparseMatConstIterator_() 
# 3218
{ } 
# 3220
template< class _Tp> inline 
# 3221
SparseMatConstIterator_< _Tp> ::SparseMatConstIterator_(const SparseMat_< _Tp>  *_m) : SparseMatConstIterator(_m) 
# 3223
{ } 
# 3225
template< class _Tp> inline 
# 3226
SparseMatConstIterator_< _Tp> ::SparseMatConstIterator_(const SparseMat *_m) : SparseMatConstIterator(_m) 
# 3228
{ 
# 3229
do { if (!(!(_m->type() == traits::template Type< _Tp> ::value))) { ; } else { cv::error(cv::Error::StsAssert, "_m->type() == traits::Type<_Tp>::value", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 3229); }  } while (0); 
# 3230
} 
# 3232
template< class _Tp> inline 
# 3233
SparseMatConstIterator_< _Tp> ::SparseMatConstIterator_(const SparseMatConstIterator_ &it) : SparseMatConstIterator(it) 
# 3235
{ } 
# 3237
template< class _Tp> inline SparseMatConstIterator_< _Tp>  &
# 3238
SparseMatConstIterator_< _Tp> ::operator=(const SparseMatConstIterator_ &it) 
# 3239
{ 
# 3240
return reinterpret_cast< SparseMatConstIterator_ &>(((*(reinterpret_cast< SparseMatConstIterator *>(this))) = (reinterpret_cast< const SparseMatConstIterator &>(it)))); 
# 3243
} 
# 3245
template< class _Tp> inline const _Tp &
# 3246
SparseMatConstIterator_< _Tp> ::operator*() const 
# 3247
{ 
# 3248
return *((const _Tp *)(this->ptr)); 
# 3249
} 
# 3251
template< class _Tp> inline SparseMatConstIterator_< _Tp>  &
# 3252
SparseMatConstIterator_< _Tp> ::operator++() 
# 3253
{ 
# 3254
this->SparseMatConstIterator::operator++(); 
# 3255
return *this; 
# 3256
} 
# 3258
template< class _Tp> inline SparseMatConstIterator_< _Tp>  
# 3259
SparseMatConstIterator_< _Tp> ::operator++(int) 
# 3260
{ 
# 3261
SparseMatConstIterator_ it = *this; 
# 3262
this->SparseMatConstIterator::operator++(); 
# 3263
return it; 
# 3264
} 
# 3270
template< class _Tp> inline 
# 3271
SparseMatIterator_< _Tp> ::SparseMatIterator_() 
# 3272
{ } 
# 3274
template< class _Tp> inline 
# 3275
SparseMatIterator_< _Tp> ::SparseMatIterator_(SparseMat_< _Tp>  *_m) : SparseMatConstIterator_< _Tp> (_m) 
# 3277
{ } 
# 3279
template< class _Tp> inline 
# 3280
SparseMatIterator_< _Tp> ::SparseMatIterator_(cv::SparseMat *_m) : SparseMatConstIterator_< _Tp> (_m) 
# 3282
{ } 
# 3284
template< class _Tp> inline 
# 3285
SparseMatIterator_< _Tp> ::SparseMatIterator_(const SparseMatIterator_ &it) : SparseMatConstIterator_< _Tp> (it) 
# 3287
{ } 
# 3289
template< class _Tp> inline SparseMatIterator_< _Tp>  &
# 3290
SparseMatIterator_< _Tp> ::operator=(const SparseMatIterator_ &it) 
# 3291
{ 
# 3292
return reinterpret_cast< SparseMatIterator_ &>(((*(reinterpret_cast< cv::SparseMatConstIterator *>(this))) = (reinterpret_cast< const cv::SparseMatConstIterator &>(it)))); 
# 3295
} 
# 3297
template< class _Tp> inline _Tp &
# 3298
SparseMatIterator_< _Tp> ::operator*() const 
# 3299
{ 
# 3300
return *((_Tp *)(this->ptr)); 
# 3301
} 
# 3303
template< class _Tp> inline SparseMatIterator_< _Tp>  &
# 3304
SparseMatIterator_< _Tp> ::operator++() 
# 3305
{ 
# 3306
cv::SparseMatConstIterator::operator++(); 
# 3307
return *this; 
# 3308
} 
# 3310
template< class _Tp> inline SparseMatIterator_< _Tp>  
# 3311
SparseMatIterator_< _Tp> ::operator++(int) 
# 3312
{ 
# 3313
SparseMatIterator_ it = *this; 
# 3314
cv::SparseMatConstIterator::operator++(); 
# 3315
return it; 
# 3316
} 
# 3322
template< class _Tp> inline 
# 3323
MatCommaInitializer_< _Tp> ::MatCommaInitializer_(Mat_< _Tp>  *_m) : it(_m) 
# 3325
{ } 
# 3327
template< class _Tp> template< class T2> inline MatCommaInitializer_< _Tp>  &
# 3328
MatCommaInitializer_< _Tp> ::operator,(T2 v) 
# 3329
{ 
# 3330
; 
# 3331
(*(this->it)) = ((_Tp)v); 
# 3332
++(this->it); 
# 3333
return *this; 
# 3334
} 
# 3336
template< class _Tp> inline 
# 3337
MatCommaInitializer_< _Tp> ::operator Mat_< _Tp> () const 
# 3338
{ 
# 3339
; 
# 3340
return ((Mat_< _Tp> )(*((this->it).m))); 
# 3341
} 
# 3344
template< class _Tp, class T2> static inline MatCommaInitializer_< _Tp>  
# 3345
operator<<(const Mat_< _Tp>  &m, T2 val) 
# 3346
{ 
# 3347
MatCommaInitializer_< _Tp>  commaInitializer((Mat_< _Tp>  *)(&m)); 
# 3348
return (commaInitializer, val); 
# 3349
} 
# 3356
inline Mat &Mat::operator=(const MatExpr &e) 
# 3357
{ 
# 3358
(e.op)->assign(e, *this); 
# 3359
return *this; 
# 3360
} 
# 3362
template< class _Tp> inline 
# 3363
Mat_< _Tp> ::Mat_(const MatExpr &e) 
# 3364
{ 
# 3365
(e.op)->assign(e, *this, traits::template Type< _Tp> ::value); 
# 3366
} 
# 3368
template< class _Tp> inline Mat_< _Tp>  &
# 3369
Mat_< _Tp> ::operator=(const MatExpr &e) 
# 3370
{ 
# 3371
(e.op)->assign(e, *this, traits::template Type< _Tp> ::value); 
# 3372
return *this; 
# 3373
} 
# 3375
template< class _Tp> inline MatExpr 
# 3376
Mat_< _Tp> ::zeros(int rows, int cols) 
# 3377
{ 
# 3378
return Mat::zeros(rows, cols, traits::template Type< _Tp> ::value); 
# 3379
} 
# 3381
template< class _Tp> inline MatExpr 
# 3382
Mat_< _Tp> ::zeros(Size sz) 
# 3383
{ 
# 3384
return Mat::zeros(sz, traits::template Type< _Tp> ::value); 
# 3385
} 
# 3387
template< class _Tp> inline MatExpr 
# 3388
Mat_< _Tp> ::ones(int rows, int cols) 
# 3389
{ 
# 3390
return Mat::ones(rows, cols, traits::template Type< _Tp> ::value); 
# 3391
} 
# 3393
template< class _Tp> inline MatExpr 
# 3394
Mat_< _Tp> ::ones(Size sz) 
# 3395
{ 
# 3396
return Mat::ones(sz, traits::template Type< _Tp> ::value); 
# 3397
} 
# 3399
template< class _Tp> inline MatExpr 
# 3400
Mat_< _Tp> ::eye(int rows, int cols) 
# 3401
{ 
# 3402
return Mat::eye(rows, cols, traits::template Type< _Tp> ::value); 
# 3403
} 
# 3405
template< class _Tp> inline MatExpr 
# 3406
Mat_< _Tp> ::eye(Size sz) 
# 3407
{ 
# 3408
return Mat::eye(sz, traits::template Type< _Tp> ::value); 
# 3409
} 
# 3412
inline MatExpr::MatExpr() : op((0)), flags(0), a(), b(), c(), alpha((0)), beta((0)), s() 
# 3414
{ } 
# 3417
inline MatExpr::MatExpr(const MatOp *_op, int _flags, const Mat &_a, const Mat &_b, const Mat &
# 3418
_c, double _alpha, double _beta, const Scalar &_s) : op(_op), flags(_flags), a(_a), b(_b), c(_c), alpha(_alpha), beta(_beta), s(_s) 
# 3420
{ } 
# 3423
inline MatExpr::operator Mat() const 
# 3424
{ 
# 3425
Mat m; 
# 3426
(op)->assign(*this, m); 
# 3427
return m; 
# 3428
} 
# 3430
template< class _Tp> inline 
# 3431
MatExpr::operator Mat_< _Tp> () const 
# 3432
{ 
# 3433
Mat_< _Tp>  m; 
# 3434
(op)->assign(*this, m, traits::template Type< _Tp> ::value); 
# 3435
return m; 
# 3436
} 
# 3439
template< class _Tp> static inline MatExpr 
# 3440
min(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) 
# 3441
{ 
# 3442
return cv::min((const Mat &)a, (const Mat &)b); 
# 3443
} 
# 3445
template< class _Tp> static inline MatExpr 
# 3446
min(const Mat_< _Tp>  &a, double s) 
# 3447
{ 
# 3448
return cv::min((const Mat &)a, s); 
# 3449
} 
# 3451
template< class _Tp> static inline MatExpr 
# 3452
min(double s, const Mat_< _Tp>  &a) 
# 3453
{ 
# 3454
return cv::min((const Mat &)a, s); 
# 3455
} 
# 3457
template< class _Tp> static inline MatExpr 
# 3458
max(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) 
# 3459
{ 
# 3460
return cv::max((const Mat &)a, (const Mat &)b); 
# 3461
} 
# 3463
template< class _Tp> static inline MatExpr 
# 3464
max(const Mat_< _Tp>  &a, double s) 
# 3465
{ 
# 3466
return cv::max((const Mat &)a, s); 
# 3467
} 
# 3469
template< class _Tp> static inline MatExpr 
# 3470
max(double s, const Mat_< _Tp>  &a) 
# 3471
{ 
# 3472
return cv::max((const Mat &)a, s); 
# 3473
} 
# 3475
template< class _Tp> static inline MatExpr 
# 3476
abs(const Mat_< _Tp>  &m) 
# 3477
{ 
# 3478
return cv::abs((const Mat &)m); 
# 3479
} 
# 3483
static inline Mat &operator+=(Mat &a, const MatExpr &b) 
# 3484
{ 
# 3485
(b.op)->augAssignAdd(b, a); 
# 3486
return a; 
# 3487
} 
# 3490
static inline const Mat &operator+=(const Mat &a, const MatExpr &b) 
# 3491
{ 
# 3492
(b.op)->augAssignAdd(b, (Mat &)a); 
# 3493
return a; 
# 3494
} 
# 3496
template< class _Tp> static inline Mat_< _Tp>  &
# 3497
operator+=(Mat_< _Tp>  &a, const MatExpr &b) 
# 3498
{ 
# 3499
(b.op)->augAssignAdd(b, a); 
# 3500
return a; 
# 3501
} 
# 3503
template< class _Tp> static inline const Mat_< _Tp>  &
# 3504
operator+=(const Mat_< _Tp>  &a, const MatExpr &b) 
# 3505
{ 
# 3506
(b.op)->augAssignAdd(b, (Mat &)a); 
# 3507
return a; 
# 3508
} 
# 3511
static inline Mat &operator-=(Mat &a, const MatExpr &b) 
# 3512
{ 
# 3513
(b.op)->augAssignSubtract(b, a); 
# 3514
return a; 
# 3515
} 
# 3518
static inline const Mat &operator-=(const Mat &a, const MatExpr &b) 
# 3519
{ 
# 3520
(b.op)->augAssignSubtract(b, (Mat &)a); 
# 3521
return a; 
# 3522
} 
# 3524
template< class _Tp> static inline Mat_< _Tp>  &
# 3525
operator-=(Mat_< _Tp>  &a, const MatExpr &b) 
# 3526
{ 
# 3527
(b.op)->augAssignSubtract(b, a); 
# 3528
return a; 
# 3529
} 
# 3531
template< class _Tp> static inline const Mat_< _Tp>  &
# 3532
operator-=(const Mat_< _Tp>  &a, const MatExpr &b) 
# 3533
{ 
# 3534
(b.op)->augAssignSubtract(b, (Mat &)a); 
# 3535
return a; 
# 3536
} 
# 3539
static inline Mat &operator*=(Mat &a, const MatExpr &b) 
# 3540
{ 
# 3541
(b.op)->augAssignMultiply(b, a); 
# 3542
return a; 
# 3543
} 
# 3546
static inline const Mat &operator*=(const Mat &a, const MatExpr &b) 
# 3547
{ 
# 3548
(b.op)->augAssignMultiply(b, (Mat &)a); 
# 3549
return a; 
# 3550
} 
# 3552
template< class _Tp> static inline Mat_< _Tp>  &
# 3553
operator*=(Mat_< _Tp>  &a, const MatExpr &b) 
# 3554
{ 
# 3555
(b.op)->augAssignMultiply(b, a); 
# 3556
return a; 
# 3557
} 
# 3559
template< class _Tp> static inline const Mat_< _Tp>  &
# 3560
operator*=(const Mat_< _Tp>  &a, const MatExpr &b) 
# 3561
{ 
# 3562
(b.op)->augAssignMultiply(b, (Mat &)a); 
# 3563
return a; 
# 3564
} 
# 3567
static inline Mat &operator/=(Mat &a, const MatExpr &b) 
# 3568
{ 
# 3569
(b.op)->augAssignDivide(b, a); 
# 3570
return a; 
# 3571
} 
# 3574
static inline const Mat &operator/=(const Mat &a, const MatExpr &b) 
# 3575
{ 
# 3576
(b.op)->augAssignDivide(b, (Mat &)a); 
# 3577
return a; 
# 3578
} 
# 3580
template< class _Tp> static inline Mat_< _Tp>  &
# 3581
operator/=(Mat_< _Tp>  &a, const MatExpr &b) 
# 3582
{ 
# 3583
(b.op)->augAssignDivide(b, a); 
# 3584
return a; 
# 3585
} 
# 3587
template< class _Tp> static inline const Mat_< _Tp>  &
# 3588
operator/=(const Mat_< _Tp>  &a, const MatExpr &b) 
# 3589
{ 
# 3590
(b.op)->augAssignDivide(b, (Mat &)a); 
# 3591
return a; 
# 3592
} 
# 3598
inline UMat::UMat(UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3600
{ } 
# 3603
inline UMat::UMat(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3605
{ 
# 3606
this->create(_rows, _cols, _type); 
# 3607
} 
# 3610
inline UMat::UMat(int _rows, int _cols, int _type, const Scalar &_s, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3612
{ 
# 3613
this->create(_rows, _cols, _type); 
# 3614
((*this) = _s); 
# 3615
} 
# 3618
inline UMat::UMat(Size _sz, int _type, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3620
{ 
# 3621
this->create(_sz.height, _sz.width, _type); 
# 3622
} 
# 3625
inline UMat::UMat(Size _sz, int _type, const Scalar &_s, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3627
{ 
# 3628
this->create(_sz.height, _sz.width, _type); 
# 3629
((*this) = _s); 
# 3630
} 
# 3633
inline UMat::UMat(int _dims, const int *_sz, int _type, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3635
{ 
# 3636
this->create(_dims, _sz, _type); 
# 3637
} 
# 3640
inline UMat::UMat(int _dims, const int *_sz, int _type, const Scalar &_s, UMatUsageFlags _usageFlags) : flags((MAGIC_VAL)), dims(0), rows(0), cols(0), allocator((0)), usageFlags(_usageFlags), u((0)), offset((0)), size(&(rows)) 
# 3642
{ 
# 3643
this->create(_dims, _sz, _type); 
# 3644
((*this) = _s); 
# 3645
} 
# 3648
inline UMat::UMat(const UMat &m) : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator), usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&(rows)) 
# 3651
{ 
# 3652
this->addref(); 
# 3653
if ((m.dims) <= 2) 
# 3654
{ 
# 3655
(step)[0] = (m.step)[0]; (step)[1] = (m.step)[1]; 
# 3656
} else 
# 3658
{ 
# 3659
(dims) = 0; 
# 3660
this->copySize(m); 
# 3661
}  
# 3662
} 
# 3665
template< class _Tp> inline 
# 3666
UMat::UMat(const std::vector< _Tp>  &vec, bool copyData) : flags(((MAGIC_VAL + traits::template Type< _Tp> ::value) + (1 << 14))), dims(2), rows((int)vec.size()), cols(1), allocator((0)), usageFlags(USAGE_DEFAULT), u((0)), offset((0)), size(&(rows)) 
# 3669
{ 
# 3670
if (vec.empty()) { 
# 3671
return; }  
# 3672
if (!copyData) 
# 3673
{ 
# 3675
cv::error(Error::StsNotImplemented, "", __func__, "/usr/include/opencv4/opencv2/core/mat.inl.hpp", 3675); 
# 3676
} else { 
# 3678
Mat((int)vec.size(), 1, traits::template Type< _Tp> ::value, (uchar *)(&(vec[0]))).copyTo(*this); }  
# 3679
} 
# 3682
inline UMat &UMat::operator=(const UMat &m) 
# 3683
{ 
# 3684
if (this != (&m)) 
# 3685
{ 
# 3686
(const_cast< UMat &>(m)).addref(); 
# 3687
this->release(); 
# 3688
(flags) = (m.flags); 
# 3689
if (((dims) <= 2) && ((m.dims) <= 2)) 
# 3690
{ 
# 3691
(dims) = (m.dims); 
# 3692
(rows) = (m.rows); 
# 3693
(cols) = (m.cols); 
# 3694
(step)[0] = (m.step)[0]; 
# 3695
(step)[1] = (m.step)[1]; 
# 3696
} else { 
# 3698
this->copySize(m); }  
# 3699
(allocator) = (m.allocator); 
# 3700
if ((usageFlags) == (USAGE_DEFAULT)) { 
# 3701
(usageFlags) = (m.usageFlags); }  
# 3702
(u) = (m.u); 
# 3703
(offset) = (m.offset); 
# 3704
}  
# 3705
return *this; 
# 3706
} 
# 3709
inline UMat UMat::row(int y) const 
# 3710
{ 
# 3711
return UMat(*this, Range(y, y + 1), Range::all()); 
# 3712
} 
# 3715
inline UMat UMat::col(int x) const 
# 3716
{ 
# 3717
return UMat(*this, Range::all(), Range(x, x + 1)); 
# 3718
} 
# 3721
inline UMat UMat::rowRange(int startrow, int endrow) const 
# 3722
{ 
# 3723
return UMat(*this, Range(startrow, endrow), Range::all()); 
# 3724
} 
# 3727
inline UMat UMat::rowRange(const Range &r) const 
# 3728
{ 
# 3729
return UMat(*this, r, Range::all()); 
# 3730
} 
# 3733
inline UMat UMat::colRange(int startcol, int endcol) const 
# 3734
{ 
# 3735
return UMat(*this, Range::all(), Range(startcol, endcol)); 
# 3736
} 
# 3739
inline UMat UMat::colRange(const Range &r) const 
# 3740
{ 
# 3741
return UMat(*this, Range::all(), r); 
# 3742
} 
# 3745
inline UMat UMat::clone() const 
# 3746
{ 
# 3747
UMat m; 
# 3748
this->copyTo(m); 
# 3749
return m; 
# 3750
} 
# 3753
inline void UMat::assignTo(UMat &m, int _type) const 
# 3754
{ 
# 3755
if (_type < 0) { 
# 3756
(m = (*this)); } else { 
# 3758
this->convertTo(m, _type); }  
# 3759
} 
# 3762
inline void UMat::create(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags) 
# 3763
{ 
# 3764
_type &= (TYPE_MASK); 
# 3765
if (((dims) <= 2) && ((rows) == _rows) && ((cols) == _cols) && (this->type() == _type) && (u)) { 
# 3766
return; }  
# 3767
int sz[] = {_rows, _cols}; 
# 3768
this->create(2, sz, _type, _usageFlags); 
# 3769
} 
# 3772
inline void UMat::create(Size _sz, int _type, UMatUsageFlags _usageFlags) 
# 3773
{ 
# 3774
this->create(_sz.height, _sz.width, _type, _usageFlags); 
# 3775
} 
# 3778
inline void UMat::addref() 
# 3779
{ 
# 3780
if (u) { 
# 3781
(int)__atomic_fetch_add((unsigned *)(&((u)->urefcount)), (unsigned)1, 4); }  
# 3782
} 
# 3784
inline void UMat::release() 
# 3785
{ 
# 3786
if ((u) && (((int)__atomic_fetch_add((unsigned *)(&((u)->urefcount)), (unsigned)(-1), 4)) == 1)) { 
# 3787
this->deallocate(); }  
# 3788
for (int i = 0; i < (dims); i++) { 
# 3789
(((size).p)[i]) = 0; }  
# 3790
(u) = (0); 
# 3791
} 
# 3794
inline UMat UMat::operator()(Range _rowRange, Range _colRange) const 
# 3795
{ 
# 3796
return UMat(*this, _rowRange, _colRange); 
# 3797
} 
# 3800
inline UMat UMat::operator()(const Rect &roi) const 
# 3801
{ 
# 3802
return UMat(*this, roi); 
# 3803
} 
# 3806
inline UMat UMat::operator()(const Range *ranges) const 
# 3807
{ 
# 3808
return UMat(*this, ranges); 
# 3809
} 
# 3812
inline UMat UMat::operator()(const std::vector< Range>  &ranges) const 
# 3813
{ 
# 3814
return UMat(*this, ranges); 
# 3815
} 
# 3818
inline bool UMat::isContinuous() const 
# 3819
{ 
# 3820
return ((flags) & (CONTINUOUS_FLAG)) != 0; 
# 3821
} 
# 3824
inline bool UMat::isSubmatrix() const 
# 3825
{ 
# 3826
return ((flags) & (SUBMATRIX_FLAG)) != 0; 
# 3827
} 
# 3830
inline size_t UMat::elemSize() const 
# 3831
{ 
# 3832
size_t res = ((dims) > 0) ? ((step).p)[(dims) - 1] : (0); 
# 3833
; 
# 3834
return res; 
# 3835
} 
# 3838
inline size_t UMat::elemSize1() const 
# 3839
{ 
# 3840
return ((675553809 >> (((flags) & ((1 << 3) - 1)) * 4)) & 15); 
# 3841
} 
# 3844
inline int UMat::type() const 
# 3845
{ 
# 3846
return ((flags) & (((1 << 3) * 512) - 1)); 
# 3847
} 
# 3850
inline int UMat::depth() const 
# 3851
{ 
# 3852
return ((flags) & ((1 << 3) - 1)); 
# 3853
} 
# 3856
inline int UMat::channels() const 
# 3857
{ 
# 3858
return ((((flags) & ((512 - 1) << 3)) >> 3) + 1); 
# 3859
} 
# 3862
inline size_t UMat::step1(int i) const 
# 3863
{ 
# 3864
return (((step).p)[i]) / this->elemSize1(); 
# 3865
} 
# 3868
inline bool UMat::empty() const 
# 3869
{ 
# 3870
return (((u) == (0)) || (this->total() == (0))) || ((dims) == 0); 
# 3871
} 
# 3874
inline size_t UMat::total() const 
# 3875
{ 
# 3876
if ((dims) <= 2) { 
# 3877
return ((size_t)(rows)) * (cols); }  
# 3878
size_t p = (1); 
# 3879
for (int i = 0; i < (dims); i++) { 
# 3880
p *= ((size)[i]); }  
# 3881
return p; 
# 3882
} 
# 3885
inline UMat::UMat(UMat &&m) : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator), usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&(rows)) 
# 3888
{ 
# 3889
if ((m.dims) <= 2) 
# 3890
{ 
# 3891
(step)[0] = (m.step)[0]; 
# 3892
(step)[1] = (m.step)[1]; 
# 3893
} else 
# 3895
{ 
# 3896
; 
# 3897
((step).p) = ((m.step).p); 
# 3898
((size).p) = ((m.size).p); 
# 3899
((m.step).p) = ((m.step).buf); 
# 3900
((m.size).p) = (&(m.rows)); 
# 3901
}  
# 3902
(m.flags) = (MAGIC_VAL); (m.dims) = ((m.rows) = ((m.cols) = 0)); 
# 3903
(m.allocator) = (__null); 
# 3904
(m.u) = (__null); 
# 3905
(m.offset) = (0); 
# 3906
} 
# 3909
inline UMat &UMat::operator=(UMat &&m) 
# 3910
{ 
# 3911
if (this == (&m)) { 
# 3912
return *this; }  
# 3913
this->release(); 
# 3914
(flags) = (m.flags); (dims) = (m.dims); (rows) = (m.rows); (cols) = (m.cols); 
# 3915
(allocator) = (m.allocator); (usageFlags) = (m.usageFlags); 
# 3916
(u) = (m.u); 
# 3917
(offset) = (m.offset); 
# 3918
if (((step).p) != ((step).buf)) 
# 3919
{ 
# 3920
fastFree((step).p); 
# 3921
((step).p) = ((step).buf); 
# 3922
((size).p) = (&(rows)); 
# 3923
}  
# 3924
if ((m.dims) <= 2) 
# 3925
{ 
# 3926
(step)[0] = (m.step)[0]; 
# 3927
(step)[1] = (m.step)[1]; 
# 3928
} else 
# 3930
{ 
# 3931
; 
# 3932
((step).p) = ((m.step).p); 
# 3933
((size).p) = ((m.size).p); 
# 3934
((m.step).p) = ((m.step).buf); 
# 3935
((m.size).p) = (&(m.rows)); 
# 3936
}  
# 3937
(m.flags) = (MAGIC_VAL); (m.dims) = ((m.rows) = ((m.cols) = 0)); 
# 3938
(m.allocator) = (__null); 
# 3939
(m.u) = (__null); 
# 3940
(m.offset) = (0); 
# 3941
return *this; 
# 3942
} 
# 3945
inline bool UMatData::hostCopyObsolete() const { return ((((flags) & (HOST_COPY_OBSOLETE))) != (0)); } 
# 3946
inline bool UMatData::deviceCopyObsolete() const { return ((((flags) & (DEVICE_COPY_OBSOLETE))) != (0)); } 
# 3947
inline bool UMatData::deviceMemMapped() const { return ((((flags) & (DEVICE_MEM_MAPPED))) != (0)); } 
# 3948
inline bool UMatData::copyOnMap() const { return ((((flags) & (COPY_ON_MAP))) != (0)); } 
# 3949
inline bool UMatData::tempUMat() const { return ((((flags) & (TEMP_UMAT))) != (0)); } 
# 3950
inline bool UMatData::tempCopiedUMat() const { return (((flags) & (TEMP_COPIED_UMAT))) == (TEMP_COPIED_UMAT); } 
# 3952
inline void UMatData::markDeviceMemMapped(bool flag) 
# 3953
{ 
# 3954
if (flag) { 
# 3955
((flags) |= (DEVICE_MEM_MAPPED)); } else { 
# 3957
((flags) &= ((~(DEVICE_MEM_MAPPED)))); }  
# 3958
} 
# 3960
inline void UMatData::markHostCopyObsolete(bool flag) 
# 3961
{ 
# 3962
if (flag) { 
# 3963
((flags) |= (HOST_COPY_OBSOLETE)); } else { 
# 3965
((flags) &= ((~(HOST_COPY_OBSOLETE)))); }  
# 3966
} 
# 3967
inline void UMatData::markDeviceCopyObsolete(bool flag) 
# 3968
{ 
# 3969
if (flag) { 
# 3970
((flags) |= (DEVICE_COPY_OBSOLETE)); } else { 
# 3972
((flags) &= ((~(DEVICE_COPY_OBSOLETE)))); }  
# 3973
} 
# 3977
}
# 103 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
namespace cv { 
# 297 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
class FileNode; 
# 298
class FileNodeIterator; 
# 303
class FileStorage { 
# 307
public: enum Mode { 
# 309
READ, 
# 310
WRITE, 
# 311
APPEND, 
# 312
MEMORY = 4, 
# 314
FORMAT_MASK = (7 << 3), 
# 315
FORMAT_AUTO = 0, 
# 316
FORMAT_XML = (1 << 3), 
# 317
FORMAT_YAML = (2 << 3), 
# 318
FORMAT_JSON = (3 << 3), 
# 320
BASE64 = 64, 
# 321
WRITE_BASE64
# 322
}; 
# 323
enum State { 
# 325
UNDEFINED, 
# 326
VALUE_EXPECTED, 
# 327
NAME_EXPECTED, 
# 328
INSIDE_MAP = 4
# 329
}; 
# 336
FileStorage(); 
# 341
FileStorage(const String & filename, int flags, const String & encoding = String()); 
# 344
virtual ~FileStorage(); 
# 361 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
virtual bool open(const String & filename, int flags, const String & encoding = String()); 
# 368
virtual bool isOpened() const; 
# 374
virtual void release(); 
# 381
virtual String releaseAndGetString(); 
# 386
FileNode getFirstTopLevelNode() const; 
# 393
FileNode root(int streamidx = 0) const; 
# 399
FileNode operator[](const String & nodename) const; 
# 402
FileNode operator[](const char * nodename) const; 
# 409
void write(const String & name, int val); 
# 411
void write(const String & name, double val); 
# 413
void write(const String & name, const String & val); 
# 415
void write(const String & name, const Mat & val); 
# 417
void write(const String & name, const std::vector< std::__cxx11::basic_string< char> >  & val); 
# 427 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
void writeRaw(const String & fmt, const void * vec, size_t len); 
# 437 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
void writeComment(const String & comment, bool append = false); 
# 439
void startWriteStruct(const String & name, int flags, const String & typeName); 
# 440
void endWriteStruct(); 
# 446
static String getDefaultObjectName(const String & filename); 
# 451
int getFormat() const; 
# 453
int state; 
# 454
std::string elname; 
# 456
class Impl; 
# 457
Ptr< Impl>  p; 
# 458
}; 
# 472 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
class FileNode { 
# 477
public: enum { 
# 478
NONE, 
# 479
INT, 
# 480
REAL, 
# 481
FLOAT = REAL, 
# 482
STR, 
# 483
STRING = STR, 
# 484
SEQ, 
# 485
MAP, 
# 486
TYPE_MASK = 7, 
# 488
FLOW, 
# 489
UNIFORM = 8, 
# 491
EMPTY = 16, 
# 492
NAMED = 32
# 493
}; 
# 499
FileNode(); 
# 506
FileNode(const FileStorage * fs, size_t blockIdx, size_t ofs); 
# 511
FileNode(const FileNode & node); 
# 513
FileNode &operator=(const FileNode & node); 
# 519
FileNode operator[](const String & nodename) const; 
# 524
FileNode operator[](const char * nodename) const; 
# 529
FileNode operator[](int i) const; 
# 534
std::vector< std::__cxx11::basic_string< char> >  keys() const; 
# 539
int type() const; 
# 542
bool empty() const; 
# 544
bool isNone() const; 
# 546
bool isSeq() const; 
# 548
bool isMap() const; 
# 550
bool isInt() const; 
# 552
bool isReal() const; 
# 554
bool isString() const; 
# 556
bool isNamed() const; 
# 558
std::string name() const; 
# 560
size_t size() const; 
# 562
size_t rawSize() const; 
# 564
operator int() const; 
# 566
operator float() const; 
# 568
operator double() const; 
# 570
operator std::string() const { return this->string(); } 
# 572
static bool isMap(int flags); 
# 573
static bool isSeq(int flags); 
# 574
static bool isCollection(int flags); 
# 575
static bool isEmptyCollection(int flags); 
# 576
static bool isFlow(int flags); 
# 578
uchar *ptr(); 
# 579
const uchar *ptr() const; 
# 582
FileNodeIterator begin() const; 
# 584
FileNodeIterator end() const; 
# 594 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
void readRaw(const String & fmt, void * vec, size_t len) const; 
# 599
void setValue(int type, const void * value, int len = -1); 
# 602
double real() const; 
# 604
std::string string() const; 
# 606
Mat mat() const; 
# 609
const FileStorage *fs; 
# 610
size_t blockIdx; 
# 611
size_t ofs; 
# 612
}; 
# 620
class FileNodeIterator { 
# 628
public: FileNodeIterator(); 
# 638 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
FileNodeIterator(const FileNode & node, bool seekEnd); 
# 643
FileNodeIterator(const FileNodeIterator & it); 
# 645
FileNodeIterator &operator=(const FileNodeIterator & it); 
# 648
FileNode operator*() const; 
# 651
FileNodeIterator &operator++(); 
# 653
FileNodeIterator operator++(int); 
# 655
FileNodeIterator &operator+=(int ofs); 
# 665 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
FileNodeIterator &readRaw(const String & fmt, void * vec, size_t len = (size_t)2147483647); 
# 669
size_t remaining() const; 
# 671
bool equalTo(const FileNodeIterator & it) const; 
# 674
protected: const FileStorage *fs; 
# 675
size_t blockIdx; 
# 676
size_t ofs; 
# 677
size_t blockSize; 
# 678
size_t nodeNElems; 
# 679
size_t idx; 
# 680
}; 
# 689 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
void write(FileStorage & fs, const String & name, int value); 
# 690
void write(FileStorage & fs, const String & name, float value); 
# 691
void write(FileStorage & fs, const String & name, double value); 
# 692
void write(FileStorage & fs, const String & name, const String & value); 
# 693
void write(FileStorage & fs, const String & name, const Mat & value); 
# 694
void write(FileStorage & fs, const String & name, const SparseMat & value); 
# 696
void write(FileStorage & fs, const String & name, const std::vector< KeyPoint>  & value); 
# 697
void write(FileStorage & fs, const String & name, const std::vector< DMatch>  & value); 
# 700
void writeScalar(FileStorage & fs, int value); 
# 701
void writeScalar(FileStorage & fs, float value); 
# 702
void writeScalar(FileStorage & fs, double value); 
# 703
void writeScalar(FileStorage & fs, const String & value); 
# 710
void read(const FileNode & node, int & value, int default_value); 
# 711
void read(const FileNode & node, float & value, float default_value); 
# 712
void read(const FileNode & node, double & value, double default_value); 
# 713
void read(const FileNode & node, std::string & value, const std::string & default_value); 
# 714
void read(const FileNode & node, Mat & mat, const Mat & default_mat = Mat()); 
# 715
void read(const FileNode & node, SparseMat & mat, const SparseMat & default_mat = SparseMat()); 
# 717
void read(const FileNode & node, std::vector< KeyPoint>  & keypoints); 
# 718
void read(const FileNode & node, std::vector< DMatch>  & matches); 
# 720
void read(const FileNode & node, KeyPoint & value, const KeyPoint & default_value); 
# 721
void read(const FileNode & node, DMatch & value, const DMatch & default_value); 
# 723
template< class _Tp> static inline void read(const FileNode &node, Point_< _Tp>  &value, const Point_< _Tp>  &default_value) 
# 724
{ 
# 725
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 726
value = ((temp.size() != 2) ? default_value : Point_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]))); 
# 727
} 
# 729
template< class _Tp> static inline void read(const FileNode &node, Point3_< _Tp>  &value, const Point3_< _Tp>  &default_value) 
# 730
{ 
# 731
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 732
value = ((temp.size() != 3) ? default_value : Point3_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]), saturate_cast< _Tp> (temp[2]))); 
# 734
} 
# 736
template< class _Tp> static inline void read(const FileNode &node, Size_< _Tp>  &value, const Size_< _Tp>  &default_value) 
# 737
{ 
# 738
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 739
value = ((temp.size() != 2) ? default_value : Size_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]))); 
# 740
} 
# 742
template< class _Tp> static inline void read(const FileNode &node, Complex< _Tp>  &value, const Complex< _Tp>  &default_value) 
# 743
{ 
# 744
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 745
value = ((temp.size() != 2) ? default_value : Complex< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]))); 
# 746
} 
# 748
template< class _Tp> static inline void read(const FileNode &node, Rect_< _Tp>  &value, const Rect_< _Tp>  &default_value) 
# 749
{ 
# 750
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 751
value = ((temp.size() != 4) ? default_value : Rect_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]), saturate_cast< _Tp> (temp[2]), saturate_cast< _Tp> (temp[3]))); 
# 753
} 
# 755
template< class _Tp, int cn> static inline void read(const FileNode &node, Vec< _Tp, cn>  &value, const Vec< _Tp, cn>  &default_value) 
# 756
{ 
# 757
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 758
value = ((temp.size() != cn) ? default_value : ((Vec< _Tp, cn> )(&(temp[0])))); 
# 759
} 
# 761
template< class _Tp, int m, int n> static inline void read(const FileNode &node, Matx< _Tp, m, n>  &value, const Matx< _Tp, m, n>  &default_matx = Matx< _Tp, m, n> ()) 
# 762
{ 
# 763
Mat temp; 
# 764
read(node, temp); 
# 766
if (temp.empty()) { 
# 767
value = default_matx; } else { 
# 769
value = ((Matx< _Tp, m, n> )(temp)); }  
# 770
} 
# 772
template< class _Tp> static inline void read(const FileNode &node, Scalar_< _Tp>  &value, const Scalar_< _Tp>  &default_value) 
# 773
{ 
# 774
std::vector< _Tp>  temp; FileNodeIterator it = node.begin(); it >> temp; 
# 775
value = ((temp.size() != 4) ? default_value : Scalar_< _Tp> (saturate_cast< _Tp> (temp[0]), saturate_cast< _Tp> (temp[1]), saturate_cast< _Tp> (temp[2]), saturate_cast< _Tp> (temp[3]))); 
# 777
} 
# 779
static inline void read(const FileNode &node, Range &value, const Range &default_value) 
# 780
{ 
# 781
Point2i temp(value.start, value.end); const Point2i default_temp = Point2i(default_value.start, default_value.end); 
# 782
read(node, temp, default_temp); 
# 783
(value.start) = (temp.x); (value.end) = (temp.y); 
# 784
} 
# 791
FileStorage &operator<<(FileStorage & fs, const String & str); 
# 795
namespace internal { 
# 797
class WriteStructContext { 
# 800
public: WriteStructContext(FileStorage & _fs, const String & name, int flags, const String & typeName = String()); 
# 801
~WriteStructContext(); 
# 803
private: FileStorage *fs; 
# 804
}; 
# 806
template< class _Tp, int numflag> class VecWriterProxy { 
# 809
public: VecWriterProxy(FileStorage *_fs) : fs(_fs) { } 
# 810
void operator()(const std::vector< _Tp>  &vec) const 
# 811
{ 
# 812
size_t count = vec.size(); 
# 813
for (size_t i = (0); i < count; i++) { 
# 814
write(*(fs), vec[i]); }  
# 815
} 
# 817
private: FileStorage *fs; 
# 818
}; 
# 820
template< class _Tp> class VecWriterProxy< _Tp, 1>  { 
# 823
public: VecWriterProxy(FileStorage *_fs) : fs(_fs) { } 
# 824
void operator()(const std::vector< _Tp>  &vec) const 
# 825
{ 
# 826
int _fmt = (traits::template SafeFmt< _Tp> ::fmt); 
# 827
char fmt[] = {(char)((_fmt >> 8) + ('1')), (char)_fmt, '\000'}; 
# 828
(fs)->writeRaw(fmt, (!vec.empty()) ? (uchar *)(&(vec[0])) : (0), vec.size() * sizeof(_Tp)); 
# 829
} 
# 831
private: FileStorage *fs; 
# 832
}; 
# 834
template< class _Tp, int numflag> class VecReaderProxy { 
# 837
public: VecReaderProxy(FileNodeIterator *_it) : it(_it) { } 
# 838
void operator()(std::vector< _Tp>  &vec, size_t count) const 
# 839
{ 
# 840
count = std::min(count, (it)->remaining()); 
# 841
vec.resize(count); 
# 842
for (size_t i = (0); i < count; (i++), (++(*(it)))) { 
# 843
read((*(*(it))), vec[i], _Tp()); }  
# 844
} 
# 846
private: FileNodeIterator *it; 
# 847
}; 
# 849
template< class _Tp> class VecReaderProxy< _Tp, 1>  { 
# 852
public: VecReaderProxy(FileNodeIterator *_it) : it(_it) { } 
# 853
void operator()(std::vector< _Tp>  &vec, size_t count) const 
# 854
{ 
# 855
size_t remaining = (it)->remaining(); 
# 856
size_t cn = (DataType< _Tp> ::channels); 
# 857
int _fmt = (traits::template SafeFmt< _Tp> ::fmt); 
# 858
do { if (!(!((_fmt >> 8) < 9))) { ; } else { cv::error(cv::Error::StsAssert, "(_fmt >> 8) < 9", __func__, "/usr/include/opencv4/opencv2/core/persistence.hpp", 858); }  } while (0); 
# 859
char fmt[] = {(char)((_fmt >> 8) + ('1')), (char)_fmt, '\000'}; 
# 860
do { if (!(!((remaining % cn) == (0)))) { ; } else { cv::error(cv::Error::StsAssert, "(remaining % cn) == 0", __func__, "/usr/include/opencv4/opencv2/core/persistence.hpp", 860); }  } while (0); 
# 861
size_t remaining1 = remaining / cn; 
# 862
count = ((count > remaining1) ? remaining1 : count); 
# 863
vec.resize(count); 
# 864
(it)->readRaw(fmt, (!vec.empty()) ? (uchar *)(&(vec[0])) : (0), count * sizeof(_Tp)); 
# 865
} 
# 867
private: FileNodeIterator *it; 
# 868
}; 
# 870
}
# 877
template< class _Tp> static inline void 
# 878
write(FileStorage &fs, const _Tp &value) 
# 879
{ 
# 880
write(fs, String(), value); 
# 881
} 
# 884
template<> inline void write(FileStorage &fs, const int &value) 
# 885
{ 
# 886
writeScalar(fs, value); 
# 887
} 
# 890
template<> inline void write(FileStorage &fs, const float &value) 
# 891
{ 
# 892
writeScalar(fs, value); 
# 893
} 
# 896
template<> inline void write(FileStorage &fs, const double &value) 
# 897
{ 
# 898
writeScalar(fs, value); 
# 899
} 
# 902
template<> inline void write(FileStorage &fs, const String &value) 
# 903
{ 
# 904
writeScalar(fs, value); 
# 905
} 
# 907
template< class _Tp> static inline void 
# 908
write(FileStorage &fs, const Point_< _Tp>  &pt) 
# 909
{ 
# 910
write(fs, (pt.x)); 
# 911
write(fs, (pt.y)); 
# 912
} 
# 914
template< class _Tp> static inline void 
# 915
write(FileStorage &fs, const Point3_< _Tp>  &pt) 
# 916
{ 
# 917
write(fs, (pt.x)); 
# 918
write(fs, (pt.y)); 
# 919
write(fs, (pt.z)); 
# 920
} 
# 922
template< class _Tp> static inline void 
# 923
write(FileStorage &fs, const Size_< _Tp>  &sz) 
# 924
{ 
# 925
write(fs, (sz.width)); 
# 926
write(fs, (sz.height)); 
# 927
} 
# 929
template< class _Tp> static inline void 
# 930
write(FileStorage &fs, const Complex< _Tp>  &c) 
# 931
{ 
# 932
write(fs, (c.re)); 
# 933
write(fs, (c.im)); 
# 934
} 
# 936
template< class _Tp> static inline void 
# 937
write(FileStorage &fs, const Rect_< _Tp>  &r) 
# 938
{ 
# 939
write(fs, (r.x)); 
# 940
write(fs, (r.y)); 
# 941
write(fs, (r.width)); 
# 942
write(fs, (r.height)); 
# 943
} 
# 945
template< class _Tp, int cn> static inline void 
# 946
write(FileStorage &fs, const Vec< _Tp, cn>  &v) 
# 947
{ 
# 948
for (int i = 0; i < cn; i++) { 
# 949
write(fs, (v.val)[i]); }  
# 950
} 
# 952
template< class _Tp, int m, int n> static inline void 
# 953
write(FileStorage &fs, const Matx< _Tp, m, n>  &x) 
# 954
{ 
# 955
write(fs, ((Mat)(x))); 
# 956
} 
# 958
template< class _Tp> static inline void 
# 959
write(FileStorage &fs, const Scalar_< _Tp>  &s) 
# 960
{ 
# 961
write(fs, (s.val)[0]); 
# 962
write(fs, (s.val)[1]); 
# 963
write(fs, (s.val)[2]); 
# 964
write(fs, (s.val)[3]); 
# 965
} 
# 968
static inline void write(FileStorage &fs, const Range &r) 
# 969
{ 
# 970
write(fs, r.start); 
# 971
write(fs, r.end); 
# 972
} 
# 974
template< class _Tp> static inline void 
# 975
write(FileStorage &fs, const std::vector< _Tp>  &vec) 
# 976
{ 
# 977
internal::VecWriterProxy< _Tp, traits::SafeFmt< _Tp> ::fmt != 0>  w(&fs); 
# 978
w(vec); 
# 979
} 
# 981
template< class _Tp> static inline void 
# 982
write(FileStorage &fs, const String &name, const Point_< _Tp>  &pt) 
# 983
{ 
# 984
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 985
write(fs, pt); 
# 986
} 
# 988
template< class _Tp> static inline void 
# 989
write(FileStorage &fs, const String &name, const Point3_< _Tp>  &pt) 
# 990
{ 
# 991
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 992
write(fs, pt); 
# 993
} 
# 995
template< class _Tp> static inline void 
# 996
write(FileStorage &fs, const String &name, const Size_< _Tp>  &sz) 
# 997
{ 
# 998
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 999
write(fs, sz); 
# 1000
} 
# 1002
template< class _Tp> static inline void 
# 1003
write(FileStorage &fs, const String &name, const Complex< _Tp>  &c) 
# 1004
{ 
# 1005
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1006
write(fs, c); 
# 1007
} 
# 1009
template< class _Tp> static inline void 
# 1010
write(FileStorage &fs, const String &name, const Rect_< _Tp>  &r) 
# 1011
{ 
# 1012
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1013
write(fs, r); 
# 1014
} 
# 1016
template< class _Tp, int cn> static inline void 
# 1017
write(FileStorage &fs, const String &name, const Vec< _Tp, cn>  &v) 
# 1018
{ 
# 1019
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1020
write(fs, v); 
# 1021
} 
# 1023
template< class _Tp, int m, int n> static inline void 
# 1024
write(FileStorage &fs, const String &name, const Matx< _Tp, m, n>  &x) 
# 1025
{ 
# 1026
write(fs, name, ((Mat)(x))); 
# 1027
} 
# 1029
template< class _Tp> static inline void 
# 1030
write(FileStorage &fs, const String &name, const Scalar_< _Tp>  &s) 
# 1031
{ 
# 1032
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1033
write(fs, s); 
# 1034
} 
# 1037
static inline void write(FileStorage &fs, const String &name, const Range &r) 
# 1038
{ 
# 1039
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1040
write(fs, r); 
# 1041
} 
# 1044
static inline void write(FileStorage &fs, const String &name, const KeyPoint &kpt) 
# 1045
{ 
# 1046
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1047
write(fs, (kpt.pt).x); 
# 1048
write(fs, (kpt.pt).y); 
# 1049
write(fs, kpt.size); 
# 1050
write(fs, kpt.angle); 
# 1051
write(fs, kpt.response); 
# 1052
write(fs, kpt.octave); 
# 1053
write(fs, kpt.class_id); 
# 1054
} 
# 1057
static inline void write(FileStorage &fs, const String &name, const DMatch &m) 
# 1058
{ 
# 1059
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + (FileNode::FLOW)); 
# 1060
write(fs, m.queryIdx); 
# 1061
write(fs, m.trainIdx); 
# 1062
write(fs, m.imgIdx); 
# 1063
write(fs, m.distance); 
# 1064
} 
# 1066
template< class _Tp, typename std::enable_if< std::is_enum< _Tp> ::value> ::type * = nullptr> static inline void 
# 1067
write(FileStorage &fs, const String &name, const _Tp &val) 
# 1068
{ 
# 1069
write(fs, name, static_cast< int>(val)); 
# 1070
} 
# 1072
template< class _Tp> static inline void 
# 1073
write(FileStorage &fs, const String &name, const std::vector< _Tp>  &vec) 
# 1074
{ 
# 1075
internal::WriteStructContext ws(fs, name, (FileNode::SEQ) + ((traits::template SafeFmt< _Tp> ::fmt != 0) ? FileNode::FLOW : 0)); 
# 1076
write(fs, vec); 
# 1077
} 
# 1079
template< class _Tp> static inline void 
# 1080
write(FileStorage &fs, const String &name, const std::vector< std::vector< _Tp> >  &vec) 
# 1081
{ 
# 1082
internal::WriteStructContext ws(fs, name, FileNode::SEQ); 
# 1083
for (size_t i = (0); i < vec.size(); i++) 
# 1084
{ 
# 1085
internal::WriteStructContext ws_(fs, name, (FileNode::SEQ) + ((traits::template SafeFmt< _Tp> ::fmt != 0) ? FileNode::FLOW : 0)); 
# 1086
write(fs, vec[i]); 
# 1087
}  
# 1088
} 
# 1093
static inline void write(FileStorage &fs, const KeyPoint &kpt) { write(fs, String(), kpt); } 
# 1094
static inline void write(FileStorage &fs, const DMatch &m) { write(fs, String(), m); } 
# 1095
static inline void write(FileStorage &fs, const std::vector< KeyPoint>  &vec) 
# 1096
{ 
# 1097
internal::VecWriterProxy< KeyPoint, 0>  w(&fs); 
# 1098
w(vec); 
# 1099
} 
# 1100
static inline void write(FileStorage &fs, const std::vector< DMatch>  &vec) 
# 1101
{ 
# 1102
internal::VecWriterProxy< DMatch, 0>  w(&fs); 
# 1103
w(vec); 
# 1105
} 
# 1114
static inline void read(const FileNode &node, bool &value, bool default_value) 
# 1115
{ 
# 1116
int temp; 
# 1117
read(node, temp, (int)default_value); 
# 1118
value = (temp != 0); 
# 1119
} 
# 1122
static inline void read(const FileNode &node, uchar &value, uchar default_value) 
# 1123
{ 
# 1124
int temp; 
# 1125
read(node, temp, (int)default_value); 
# 1126
value = saturate_cast< unsigned char> (temp); 
# 1127
} 
# 1130
static inline void read(const FileNode &node, schar &value, schar default_value) 
# 1131
{ 
# 1132
int temp; 
# 1133
read(node, temp, (int)default_value); 
# 1134
value = saturate_cast< signed char> (temp); 
# 1135
} 
# 1138
static inline void read(const FileNode &node, ushort &value, ushort default_value) 
# 1139
{ 
# 1140
int temp; 
# 1141
read(node, temp, (int)default_value); 
# 1142
value = saturate_cast< unsigned short> (temp); 
# 1143
} 
# 1146
static inline void read(const FileNode &node, short &value, short default_value) 
# 1147
{ 
# 1148
int temp; 
# 1149
read(node, temp, (int)default_value); 
# 1150
value = saturate_cast< short> (temp); 
# 1151
} 
# 1153
template< class _Tp> static inline void 
# 1154
read(FileNodeIterator &it, std::vector< _Tp>  &vec, size_t maxCount = (size_t)2147483647) 
# 1155
{ 
# 1156
internal::VecReaderProxy< _Tp, traits::SafeFmt< _Tp> ::fmt != 0>  r(&it); 
# 1157
r(vec, maxCount); 
# 1158
} 
# 1160
template< class _Tp, typename std::enable_if< std::is_enum< _Tp> ::value> ::type * = nullptr> static inline void 
# 1161
read(const FileNode &node, _Tp &value, const _Tp &default_value = static_cast< _Tp>(0)) 
# 1162
{ 
# 1163
int temp; 
# 1164
read(node, temp, static_cast< int>(default_value)); 
# 1165
value = (static_cast< _Tp>(temp)); 
# 1166
} 
# 1168
template< class _Tp> static inline void 
# 1169
read(const FileNode &node, std::vector< _Tp>  &vec, const std::vector< _Tp>  &default_value = std::vector< _Tp> ()) 
# 1170
{ 
# 1171
if (node.empty()) { 
# 1172
vec = default_value; } else 
# 1174
{ 
# 1175
FileNodeIterator it = node.begin(); 
# 1176
read(it, vec); 
# 1177
}  
# 1178
} 
# 1181
static inline void read(const FileNode &node, std::vector< KeyPoint>  &vec, const std::vector< KeyPoint>  &default_value) 
# 1182
{ 
# 1183
if (node.empty()) { 
# 1184
(vec = default_value); } else { 
# 1186
read(node, vec); }  
# 1187
} 
# 1190
static inline void read(const FileNode &node, std::vector< DMatch>  &vec, const std::vector< DMatch>  &default_value) 
# 1191
{ 
# 1192
if (node.empty()) { 
# 1193
(vec = default_value); } else { 
# 1195
read(node, vec); }  
# 1196
} 
# 1205 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
template< class _Tp> static inline FileStorage &
# 1206
operator<<(FileStorage &fs, const _Tp &value) 
# 1207
{ 
# 1208
if (!fs.isOpened()) { 
# 1209
return fs; }  
# 1210
if ((fs.state) == ((FileStorage::NAME_EXPECTED) + (FileStorage::INSIDE_MAP))) { 
# 1211
cv::error(Error::StsError, "No element name has been given", __func__, "/usr/include/opencv4/opencv2/core/persistence.hpp", 1211); }  
# 1212
write(fs, fs.elname, value); 
# 1213
if ((fs.state) & (FileStorage::INSIDE_MAP)) { 
# 1214
(fs.state) = ((FileStorage::NAME_EXPECTED) + (FileStorage::INSIDE_MAP)); }  
# 1215
return fs; 
# 1216
} 
# 1221
static inline FileStorage &operator<<(FileStorage &fs, const char *str) 
# 1222
{ 
# 1223
return (fs << ((std::__cxx11::basic_string< char> )(str))); 
# 1224
} 
# 1229
static inline FileStorage &operator<<(FileStorage &fs, char *value) 
# 1230
{ 
# 1231
return (fs << ((std::__cxx11::basic_string< char> )(value))); 
# 1232
} 
# 1241 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
template< class _Tp> static inline FileNodeIterator &
# 1242
operator>>(FileNodeIterator &it, _Tp &value) 
# 1243
{ 
# 1244
read((*it), value, _Tp()); 
# 1245
return (++it); 
# 1246
} 
# 1250
template< class _Tp> static inline FileNodeIterator &
# 1251
operator>>(FileNodeIterator &it, std::vector< _Tp>  &vec) 
# 1252
{ 
# 1253
internal::VecReaderProxy< _Tp, traits::SafeFmt< _Tp> ::fmt != 0>  r(&it); 
# 1254
r(vec, (size_t)2147483647); 
# 1255
return it; 
# 1256
} 
# 1265 "/usr/include/opencv4/opencv2/core/persistence.hpp" 3
template< class _Tp> static inline void 
# 1266
operator>>(const FileNode &n, _Tp &value) 
# 1267
{ 
# 1268
read(n, value, _Tp()); 
# 1269
} 
# 1273
template< class _Tp> static inline void 
# 1274
operator>>(const FileNode &n, std::vector< _Tp>  &vec) 
# 1275
{ 
# 1276
FileNodeIterator it = n.begin(); 
# 1277
it >> vec; 
# 1278
} 
# 1284
static inline void operator>>(const FileNode &n, KeyPoint &kpt) 
# 1285
{ 
# 1286
FileNodeIterator it = n.begin(); 
# 1287
(((((((((((((it >> ((kpt.pt).x))) >> ((kpt.pt).y))) >> (kpt.size))) >> (kpt.angle))) >> (kpt.response))) >> (kpt.octave))) >> (kpt.class_id)); 
# 1288
} 
# 1292
static inline void operator>>(const FileNode &n, std::vector< KeyPoint>  &vec) 
# 1293
{ 
# 1294
read(n, vec); 
# 1295
} 
# 1297
static inline void operator>>(const FileNode &n, std::vector< DMatch>  &vec) 
# 1298
{ 
# 1299
read(n, vec); 
# 1300
} 
# 1307
static inline void operator>>(const FileNode &n, DMatch &m) 
# 1308
{ 
# 1309
FileNodeIterator it = n.begin(); 
# 1310
(((((((it >> (m.queryIdx))) >> (m.trainIdx))) >> (m.imgIdx))) >> (m.distance)); 
# 1311
} 
# 1318
bool operator==(const FileNodeIterator & it1, const FileNodeIterator & it2); 
# 1319
bool operator!=(const FileNodeIterator & it1, const FileNodeIterator & it2); 
# 1322
static inline ptrdiff_t operator-(const FileNodeIterator &it1, const FileNodeIterator &it2) 
# 1323
{ 
# 1324
return it2.remaining() - it1.remaining(); 
# 1325
} 
# 1328
static inline bool operator<(const FileNodeIterator &it1, const FileNodeIterator &it2) 
# 1329
{ 
# 1330
return it1.remaining() > it2.remaining(); 
# 1331
} 
# 1335
}
# 103 "/usr/include/opencv4/opencv2/core.hpp" 3
namespace cv { 
# 115 "/usr/include/opencv4/opencv2/core.hpp" 3
class Exception : public std::exception { 
# 121
public: Exception(); 
# 126
Exception(int _code, const String & _err, const String & _func, const String & _file, int _line); 
# 127
virtual ~Exception() throw(); 
# 132
virtual const char *what() const throw() override; 
# 133
void formatMessage(); 
# 135
String msg; 
# 137
int code; 
# 138
String err; 
# 139
String func; 
# 140
String file; 
# 141
int line; 
# 142
}; 
# 152 "/usr/include/opencv4/opencv2/core.hpp" 3
__attribute((__noreturn__)) void error(const Exception & exc); 
# 154
enum SortFlags { SORT_EVERY_ROW, 
# 155
SORT_EVERY_COLUMN, 
# 158
SORT_ASCENDING = 0, 
# 160
SORT_DESCENDING = 16
# 163
}; 
# 171
enum CovarFlags { 
# 179
COVAR_SCRAMBLED, 
# 184
COVAR_NORMAL, 
# 190
COVAR_USE_AVG, 
# 195
COVAR_SCALE = 4, 
# 199
COVAR_ROWS = 8, 
# 203
COVAR_COLS = 16
# 204
}; 
# 207
enum KmeansFlags { 
# 209
KMEANS_RANDOM_CENTERS, 
# 211
KMEANS_PP_CENTERS = 2, 
# 216
KMEANS_USE_INITIAL_LABELS = 1
# 217
}; 
# 219
enum ReduceTypes { REDUCE_SUM, 
# 220
REDUCE_AVG, 
# 221
REDUCE_MAX, 
# 222
REDUCE_MIN
# 223
}; 
# 228
void swap(Mat & a, Mat & b); 
# 230
void swap(UMat & a, UMat & b); 
# 258 "/usr/include/opencv4/opencv2/core.hpp" 3
int borderInterpolate(int p, int len, int borderType); 
# 308 "/usr/include/opencv4/opencv2/core.hpp" 3
void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar & value = Scalar()); 
# 348 "/usr/include/opencv4/opencv2/core.hpp" 3
void add(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray(), int dtype = -1); 
# 388 "/usr/include/opencv4/opencv2/core.hpp" 3
void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray(), int dtype = -1); 
# 413 "/usr/include/opencv4/opencv2/core.hpp" 3
void multiply(InputArray src1, InputArray src2, OutputArray dst, double scale = 1, int dtype = -1); 
# 441 "/usr/include/opencv4/opencv2/core.hpp" 3
void divide(InputArray src1, InputArray src2, OutputArray dst, double scale = 1, int dtype = -1); 
# 445
void divide(double scale, InputArray src2, OutputArray dst, int dtype = -1); 
# 466 "/usr/include/opencv4/opencv2/core.hpp" 3
void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst); 
# 494 "/usr/include/opencv4/opencv2/core.hpp" 3
void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype = -1); 
# 522 "/usr/include/opencv4/opencv2/core.hpp" 3
void convertScaleAbs(InputArray src, OutputArray dst, double alpha = 1, double beta = 0); 
# 535 "/usr/include/opencv4/opencv2/core.hpp" 3
void convertFp16(InputArray src, OutputArray dst); 
# 551 "/usr/include/opencv4/opencv2/core.hpp" 3
void LUT(InputArray src, InputArray lut, OutputArray dst); 
# 560 "/usr/include/opencv4/opencv2/core.hpp" 3
Scalar sum(InputArray src); 
# 569 "/usr/include/opencv4/opencv2/core.hpp" 3
int countNonZero(InputArray src); 
# 597 "/usr/include/opencv4/opencv2/core.hpp" 3
void findNonZero(InputArray src, OutputArray idx); 
# 610 "/usr/include/opencv4/opencv2/core.hpp" 3
Scalar mean(InputArray src, InputArray mask = noArray()); 
# 632 "/usr/include/opencv4/opencv2/core.hpp" 3
void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask = noArray()); 
# 671 "/usr/include/opencv4/opencv2/core.hpp" 3
double norm(InputArray src1, int normType = NORM_L2, InputArray mask = noArray()); 
# 684 "/usr/include/opencv4/opencv2/core.hpp" 3
double norm(InputArray src1, InputArray src2, int normType = NORM_L2, InputArray mask = noArray()); 
# 690
double norm(const SparseMat & src, int normType); 
# 711 "/usr/include/opencv4/opencv2/core.hpp" 3
double PSNR(InputArray src1, InputArray src2, double R = (255.0)); 
# 718
void batchDistance(InputArray src1, InputArray src2, OutputArray dist, int dtype, OutputArray nidx, int normType = NORM_L2, int K = 0, InputArray mask = noArray(), int update = 0, bool crosscheck = false); 
# 782 "/usr/include/opencv4/opencv2/core.hpp" 3
void normalize(InputArray src, InputOutputArray dst, double alpha = 1, double beta = 0, int norm_type = NORM_L2, int dtype = -1, InputArray mask = noArray()); 
# 792 "/usr/include/opencv4/opencv2/core.hpp" 3
void normalize(const SparseMat & src, SparseMat & dst, double alpha, int normType); 
# 812 "/usr/include/opencv4/opencv2/core.hpp" 3
void minMaxLoc(InputArray src, double * minVal, double * maxVal = 0, Point * minLoc = 0, Point * maxLoc = 0, InputArray mask = noArray()); 
# 840 "/usr/include/opencv4/opencv2/core.hpp" 3
void minMaxIdx(InputArray src, double * minVal, double * maxVal = 0, int * minIdx = 0, int * maxIdx = 0, InputArray mask = noArray()); 
# 852 "/usr/include/opencv4/opencv2/core.hpp" 3
void minMaxLoc(const SparseMat & a, double * minVal, double * maxVal, int * minIdx = 0, int * maxIdx = 0); 
# 879 "/usr/include/opencv4/opencv2/core.hpp" 3
void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype = -1); 
# 900 "/usr/include/opencv4/opencv2/core.hpp" 3
void merge(const Mat * mv, size_t count, OutputArray dst); 
# 908
void merge(InputArrayOfArrays mv, OutputArray dst); 
# 925 "/usr/include/opencv4/opencv2/core.hpp" 3
void split(const Mat & src, Mat * mvbegin); 
# 931
void split(InputArray m, OutputArrayOfArrays mv); 
# 974 "/usr/include/opencv4/opencv2/core.hpp" 3
void mixChannels(const Mat * src, size_t nsrcs, Mat * dst, size_t ndsts, const int * fromTo, size_t npairs); 
# 991 "/usr/include/opencv4/opencv2/core.hpp" 3
void mixChannels(InputArrayOfArrays src, InputOutputArrayOfArrays dst, const int * fromTo, size_t npairs); 
# 1007 "/usr/include/opencv4/opencv2/core.hpp" 3
void mixChannels(InputArrayOfArrays src, InputOutputArrayOfArrays dst, const std::vector< int>  & fromTo); 
# 1016
void extractChannel(InputArray src, OutputArray dst, int coi); 
# 1024
void insertChannel(InputArray src, InputOutputArray dst, int coi); 
# 1058 "/usr/include/opencv4/opencv2/core.hpp" 3
void flip(InputArray src, OutputArray dst, int flipCode); 
# 1060
enum RotateFlags { 
# 1061
ROTATE_90_CLOCKWISE, 
# 1062
ROTATE_180, 
# 1063
ROTATE_90_COUNTERCLOCKWISE
# 1064
}; 
# 1076 "/usr/include/opencv4/opencv2/core.hpp" 3
void rotate(InputArray src, OutputArray dst, int rotateCode); 
# 1091 "/usr/include/opencv4/opencv2/core.hpp" 3
void repeat(InputArray src, int ny, int nx, OutputArray dst); 
# 1100 "/usr/include/opencv4/opencv2/core.hpp" 3
Mat repeat(const Mat & src, int ny, int nx); 
# 1123 "/usr/include/opencv4/opencv2/core.hpp" 3
void hconcat(const Mat * src, size_t nsrc, OutputArray dst); 
# 1144 "/usr/include/opencv4/opencv2/core.hpp" 3
void hconcat(InputArray src1, InputArray src2, OutputArray dst); 
# 1163 "/usr/include/opencv4/opencv2/core.hpp" 3
void hconcat(InputArrayOfArrays src, OutputArray dst); 
# 1185 "/usr/include/opencv4/opencv2/core.hpp" 3
void vconcat(const Mat * src, size_t nsrc, OutputArray dst); 
# 1209 "/usr/include/opencv4/opencv2/core.hpp" 3
void vconcat(InputArray src1, InputArray src2, OutputArray dst); 
# 1227 "/usr/include/opencv4/opencv2/core.hpp" 3
void vconcat(InputArrayOfArrays src, OutputArray dst); 
# 1254 "/usr/include/opencv4/opencv2/core.hpp" 3
void bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray()); 
# 1281 "/usr/include/opencv4/opencv2/core.hpp" 3
void bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray()); 
# 1309 "/usr/include/opencv4/opencv2/core.hpp" 3
void bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask = noArray()); 
# 1326 "/usr/include/opencv4/opencv2/core.hpp" 3
void bitwise_not(InputArray src, OutputArray dst, InputArray mask = noArray()); 
# 1352 "/usr/include/opencv4/opencv2/core.hpp" 3
void absdiff(InputArray src1, InputArray src2, OutputArray dst); 
# 1364 "/usr/include/opencv4/opencv2/core.hpp" 3
void copyTo(InputArray src, OutputArray dst, InputArray mask); 
# 1384 "/usr/include/opencv4/opencv2/core.hpp" 3
void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst); 
# 1413 "/usr/include/opencv4/opencv2/core.hpp" 3
void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop); 
# 1426 "/usr/include/opencv4/opencv2/core.hpp" 3
void min(InputArray src1, InputArray src2, OutputArray dst); 
# 1430
void min(const Mat & src1, const Mat & src2, Mat & dst); 
# 1434
void min(const UMat & src1, const UMat & src2, UMat & dst); 
# 1447 "/usr/include/opencv4/opencv2/core.hpp" 3
void max(InputArray src1, InputArray src2, OutputArray dst); 
# 1451
void max(const Mat & src1, const Mat & src2, Mat & dst); 
# 1455
void max(const UMat & src1, const UMat & src2, UMat & dst); 
# 1466 "/usr/include/opencv4/opencv2/core.hpp" 3
void sqrt(InputArray src, OutputArray dst); 
# 1491 "/usr/include/opencv4/opencv2/core.hpp" 3
void pow(InputArray src, double power, OutputArray dst); 
# 1507 "/usr/include/opencv4/opencv2/core.hpp" 3
void exp(InputArray src, OutputArray dst); 
# 1520 "/usr/include/opencv4/opencv2/core.hpp" 3
void log(InputArray src, OutputArray dst); 
# 1542 "/usr/include/opencv4/opencv2/core.hpp" 3
void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees = false); 
# 1563 "/usr/include/opencv4/opencv2/core.hpp" 3
void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees = false); 
# 1583 "/usr/include/opencv4/opencv2/core.hpp" 3
void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees = false); 
# 1597 "/usr/include/opencv4/opencv2/core.hpp" 3
void magnitude(InputArray x, InputArray y, OutputArray magnitude); 
# 1614 "/usr/include/opencv4/opencv2/core.hpp" 3
bool checkRange(InputArray a, bool quiet = true, Point * pos = 0, double minVal = -((double)(1.7976931348623157081E308L)), double maxVal = (double)(1.7976931348623157081E308L)); 
# 1619
void patchNaNs(InputOutputArray a, double val = 0); 
# 1649 "/usr/include/opencv4/opencv2/core.hpp" 3
void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double beta, OutputArray dst, int flags = 0); 
# 1680 "/usr/include/opencv4/opencv2/core.hpp" 3
void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta = noArray(), double scale = 1, int dtype = -1); 
# 1693 "/usr/include/opencv4/opencv2/core.hpp" 3
void transpose(InputArray src, OutputArray dst); 
# 1719 "/usr/include/opencv4/opencv2/core.hpp" 3
void transform(InputArray src, OutputArray dst, InputArray m); 
# 1746 "/usr/include/opencv4/opencv2/core.hpp" 3
void perspectiveTransform(InputArray src, OutputArray dst, InputArray m); 
# 1762 "/usr/include/opencv4/opencv2/core.hpp" 3
void completeSymm(InputOutputArray m, bool lowerToUpper = false); 
# 1779 "/usr/include/opencv4/opencv2/core.hpp" 3
void setIdentity(InputOutputArray mtx, const Scalar & s = ((Scalar_< double> )(1))); 
# 1794 "/usr/include/opencv4/opencv2/core.hpp" 3
double determinant(InputArray mtx); 
# 1803 "/usr/include/opencv4/opencv2/core.hpp" 3
Scalar trace(InputArray mtx); 
# 1830 "/usr/include/opencv4/opencv2/core.hpp" 3
double invert(InputArray src, OutputArray dst, int flags = DECOMP_LU); 
# 1854 "/usr/include/opencv4/opencv2/core.hpp" 3
bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags = DECOMP_LU); 
# 1870 "/usr/include/opencv4/opencv2/core.hpp" 3
void sort(InputArray src, OutputArray dst, int flags); 
# 1890 "/usr/include/opencv4/opencv2/core.hpp" 3
void sortIdx(InputArray src, OutputArray dst, int flags); 
# 1905 "/usr/include/opencv4/opencv2/core.hpp" 3
int solveCubic(InputArray coeffs, OutputArray roots); 
# 1915 "/usr/include/opencv4/opencv2/core.hpp" 3
double solvePoly(InputArray coeffs, OutputArray roots, int maxIters = 300); 
# 1936 "/usr/include/opencv4/opencv2/core.hpp" 3
bool eigen(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors = noArray()); 
# 1953 "/usr/include/opencv4/opencv2/core.hpp" 3
void eigenNonSymmetric(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors); 
# 1969 "/usr/include/opencv4/opencv2/core.hpp" 3
void calcCovarMatrix(const Mat * samples, int nsamples, Mat & covar, Mat & mean, int flags, int ctype = 6); 
# 1980 "/usr/include/opencv4/opencv2/core.hpp" 3
void calcCovarMatrix(InputArray samples, OutputArray covar, InputOutputArray mean, int flags, int ctype = 6); 
# 1984
void PCACompute(InputArray data, InputOutputArray mean, OutputArray eigenvectors, int maxComponents = 0); 
# 1988
void PCACompute(InputArray data, InputOutputArray mean, OutputArray eigenvectors, OutputArray eigenvalues, int maxComponents = 0); 
# 1993
void PCACompute(InputArray data, InputOutputArray mean, OutputArray eigenvectors, double retainedVariance); 
# 1997
void PCACompute(InputArray data, InputOutputArray mean, OutputArray eigenvectors, OutputArray eigenvalues, double retainedVariance); 
# 2002
void PCAProject(InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result); 
# 2006
void PCABackProject(InputArray data, InputArray mean, InputArray eigenvectors, OutputArray result); 
# 2010
void SVDecomp(InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags = 0); 
# 2013
void SVBackSubst(InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst); 
# 2026 "/usr/include/opencv4/opencv2/core.hpp" 3
double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar); 
# 2160 "/usr/include/opencv4/opencv2/core.hpp" 3
void dft(InputArray src, OutputArray dst, int flags = 0, int nonzeroRows = 0); 
# 2174 "/usr/include/opencv4/opencv2/core.hpp" 3
void idft(InputArray src, OutputArray dst, int flags = 0, int nonzeroRows = 0); 
# 2215 "/usr/include/opencv4/opencv2/core.hpp" 3
void dct(InputArray src, OutputArray dst, int flags = 0); 
# 2225 "/usr/include/opencv4/opencv2/core.hpp" 3
void idct(InputArray src, OutputArray dst, int flags = 0); 
# 2244 "/usr/include/opencv4/opencv2/core.hpp" 3
void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB = false); 
# 2268 "/usr/include/opencv4/opencv2/core.hpp" 3
int getOptimalDFTSize(int vecsize); 
# 2279 "/usr/include/opencv4/opencv2/core.hpp" 3
RNG &theRNG(); 
# 2287
void setRNGSeed(int seed); 
# 2299 "/usr/include/opencv4/opencv2/core.hpp" 3
void randu(InputOutputArray dst, InputArray low, InputArray high); 
# 2312 "/usr/include/opencv4/opencv2/core.hpp" 3
void randn(InputOutputArray dst, InputArray mean, InputArray stddev); 
# 2325 "/usr/include/opencv4/opencv2/core.hpp" 3
void randShuffle(InputOutputArray dst, double iterFactor = (1.0), RNG * rng = 0); 
# 2392 "/usr/include/opencv4/opencv2/core.hpp" 3
class PCA { 
# 2395
public: enum Flags { DATA_AS_ROW, 
# 2396
DATA_AS_COL, 
# 2397
USE_AVG
# 2398
}; 
# 2405
PCA(); 
# 2416 "/usr/include/opencv4/opencv2/core.hpp" 3
PCA(InputArray data, InputArray mean, int flags, int maxComponents = 0); 
# 2428 "/usr/include/opencv4/opencv2/core.hpp" 3
PCA(InputArray data, InputArray mean, int flags, double retainedVariance); 
# 2450 "/usr/include/opencv4/opencv2/core.hpp" 3
PCA &operator()(InputArray data, InputArray mean, int flags, int maxComponents = 0); 
# 2463 "/usr/include/opencv4/opencv2/core.hpp" 3
PCA &operator()(InputArray data, InputArray mean, int flags, double retainedVariance); 
# 2479 "/usr/include/opencv4/opencv2/core.hpp" 3
Mat project(InputArray vec) const; 
# 2493 "/usr/include/opencv4/opencv2/core.hpp" 3
void project(InputArray vec, OutputArray result) const; 
# 2508 "/usr/include/opencv4/opencv2/core.hpp" 3
Mat backProject(InputArray vec) const; 
# 2517 "/usr/include/opencv4/opencv2/core.hpp" 3
void backProject(InputArray vec, OutputArray result) const; 
# 2523
void write(FileStorage & fs) const; 
# 2529
void read(const FileNode & fn); 
# 2531
Mat eigenvectors; 
# 2532
Mat eigenvalues; 
# 2533
Mat mean; 
# 2534
}; 
# 2548 "/usr/include/opencv4/opencv2/core.hpp" 3
class LDA { 
# 2554
public: explicit LDA(int num_components = 0); 
# 2561
LDA(InputArrayOfArrays src, InputArray labels, int num_components = 0); 
# 2565
void save(const String & filename) const; 
# 2569
void load(const String & filename); 
# 2573
void save(FileStorage & fs) const; 
# 2577
void load(const FileStorage & node); 
# 2581
~LDA(); 
# 2585
void compute(InputArrayOfArrays src, InputArray labels); 
# 2590
Mat project(InputArray src); 
# 2595
Mat reconstruct(InputArray src); 
# 2599
Mat eigenvectors() const { return _eigenvectors; } 
# 2603
Mat eigenvalues() const { return _eigenvalues; } 
# 2605
static Mat subspaceProject(InputArray W, InputArray mean, InputArray src); 
# 2606
static Mat subspaceReconstruct(InputArray W, InputArray mean, InputArray src); 
# 2609
protected: int _num_components; 
# 2610
Mat _eigenvectors; 
# 2611
Mat _eigenvalues; 
# 2612
void lda(InputArrayOfArrays src, InputArray labels); 
# 2613
}; 
# 2629 "/usr/include/opencv4/opencv2/core.hpp" 3
class SVD { 
# 2632
public: enum Flags { 
# 2635
MODIFY_A = 1, 
# 2638
NO_UV, 
# 2642
FULL_UV = 4
# 2643
}; 
# 2649
inline SVD(); 
# 2656
inline SVD(InputArray src, int flags = 0); 
# 2669 "/usr/include/opencv4/opencv2/core.hpp" 3
SVD &operator()(InputArray src, int flags = 0); 
# 2688 "/usr/include/opencv4/opencv2/core.hpp" 3
static void compute(InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags = 0); 
# 2697
static void compute(InputArray src, OutputArray w, int flags = 0); 
# 2701
static void backSubst(InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst); 
# 2715 "/usr/include/opencv4/opencv2/core.hpp" 3
static inline void solveZ(InputArray src, OutputArray dst); 
# 2739 "/usr/include/opencv4/opencv2/core.hpp" 3
void backSubst(InputArray rhs, OutputArray dst) const; 
# 2742
template< class _Tp, int m, int n, int nm> static inline void compute(const Matx< _Tp, m, n>  & a, Matx< _Tp, nm, 1>  & w, Matx< _Tp, m, nm>  & u, Matx< _Tp, n, nm>  & vt); 
# 2746
template< class _Tp, int m, int n, int nm> static inline void compute(const Matx< _Tp, m, n>  & a, Matx< _Tp, nm, 1>  & w); 
# 2750
template< class _Tp, int m, int n, int nm, int nb> static inline void backSubst(const Matx< _Tp, nm, 1>  & w, const Matx< _Tp, m, nm>  & u, const Matx< _Tp, n, nm>  & vt, const Matx< _Tp, m, nb>  & rhs, Matx< _Tp, n, nb>  & dst); 
# 2753
Mat u, w, vt; 
# 2754
}; 
# 2768 "/usr/include/opencv4/opencv2/core.hpp" 3
class RNG { 
# 2771
public: enum { UNIFORM, 
# 2772
NORMAL
# 2773
}; 
# 2783 "/usr/include/opencv4/opencv2/core.hpp" 3
inline RNG(); 
# 2787
inline RNG(uint64 state); 
# 2790
inline unsigned next(); 
# 2798
inline operator uchar(); 
# 2800
inline operator schar(); 
# 2802
inline operator ushort(); 
# 2804
inline operator short(); 
# 2806
inline operator unsigned(); 
# 2808
inline operator int(); 
# 2810
inline operator float(); 
# 2812
inline operator double(); 
# 2821 "/usr/include/opencv4/opencv2/core.hpp" 3
inline unsigned operator()(); 
# 2825
inline unsigned operator()(unsigned N); 
# 2863 "/usr/include/opencv4/opencv2/core.hpp" 3
inline int uniform(int a, int b); 
# 2865
inline float uniform(float a, float b); 
# 2867
inline double uniform(double a, double b); 
# 2903 "/usr/include/opencv4/opencv2/core.hpp" 3
void fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange = false); 
# 2913 "/usr/include/opencv4/opencv2/core.hpp" 3
double gaussian(double sigma); 
# 2915
uint64 state; 
# 2917
inline bool operator==(const RNG & other) const; 
# 2918
}; 
# 2925
class RNG_MT19937 { 
# 2928
public: RNG_MT19937(); 
# 2929
RNG_MT19937(unsigned s); 
# 2930
void seed(unsigned s); 
# 2932
unsigned next(); 
# 2934
operator int(); 
# 2935
operator unsigned(); 
# 2936
operator float(); 
# 2937
operator double(); 
# 2939
unsigned operator()(unsigned N); 
# 2940
unsigned operator()(); 
# 2943
int uniform(int a, int b); 
# 2945
float uniform(float a, float b); 
# 2947
double uniform(double a, double b); 
# 2950
private: enum PeriodParameters { N = 624, M = 397}; 
# 2951
unsigned state[N]; 
# 2952
int mti; 
# 2953
}; 
# 2997 "/usr/include/opencv4/opencv2/core.hpp" 3
double kmeans(InputArray data, int K, InputOutputArray bestLabels, TermCriteria criteria, int attempts, int flags, OutputArray centers = noArray()); 
# 3009 "/usr/include/opencv4/opencv2/core.hpp" 3
class Formatted { 
# 3012
public: virtual const char *next() = 0; 
# 3013
virtual void reset() = 0; 
# 3014
virtual ~Formatted(); 
# 3015
}; 
# 3018
class Formatter { 
# 3021
public: enum FormatType { 
# 3022
FMT_DEFAULT, 
# 3023
FMT_MATLAB, 
# 3024
FMT_CSV, 
# 3025
FMT_PYTHON, 
# 3026
FMT_NUMPY, 
# 3027
FMT_C
# 3028
}; 
# 3030
virtual ~Formatter(); 
# 3032
virtual Ptr< Formatted>  format(const Mat & mtx) const = 0; 
# 3034
virtual void set16fPrecision(int p = 4) = 0; 
# 3035
virtual void set32fPrecision(int p = 8) = 0; 
# 3036
virtual void set64fPrecision(int p = 16) = 0; 
# 3037
virtual void setMultiline(bool ml = true) = 0; 
# 3039
static Ptr< Formatter>  get(FormatType fmt = FMT_DEFAULT); 
# 3041
}; 
# 3044
static inline String &operator<<(String &out, Ptr< Formatted>  fmtd) 
# 3045
{ 
# 3046
fmtd->reset(); 
# 3047
for (const char *str = fmtd->next(); str; str = fmtd->next()) { 
# 3048
(out += ((std::__cxx11::basic_string< char> )(str))); }  
# 3049
return out; 
# 3050
} 
# 3053
static inline String &operator<<(String &out, const Mat &mtx) 
# 3054
{ 
# 3055
return (out << ((Formatter::get())->format(mtx))); 
# 3056
} 
# 3060
class Algorithm; 
# 3062
template< class _Tp, class _EnumTp = void> struct ParamType { }; 
# 3076 "/usr/include/opencv4/opencv2/core.hpp" 3
class Algorithm { 
# 3079
public: Algorithm(); 
# 3080
virtual ~Algorithm(); 
# 3084
virtual void clear() { } 
# 3088
virtual void write(FileStorage &fs) const { (void)fs; } 
# 3093
void write(const Ptr< FileStorage>  & fs, const String & name = String()) const; 
# 3097
virtual void read(const FileNode &fn) { (void)fn; } 
# 3101
virtual bool empty() const { return false; } 
# 3114 "/usr/include/opencv4/opencv2/core.hpp" 3
template< class _Tp> static Ptr< _Tp>  read(const FileNode &fn) 
# 3115
{ 
# 3116
Ptr< _Tp>  obj = _Tp::create(); 
# 3117
obj->read(fn); 
# 3118
return (!obj->empty()) ? obj : Ptr< _Tp> (); 
# 3119
} 
# 3133 "/usr/include/opencv4/opencv2/core.hpp" 3
template< class _Tp> static Ptr< _Tp>  load(const String &filename, const String &objname = String()) 
# 3134
{ 
# 3135
FileStorage fs(filename, FileStorage::READ); 
# 3136
do { if (!(!fs.isOpened())) { ; } else { cv::error(cv::Error::StsAssert, "fs.isOpened()", __func__, "/usr/include/opencv4/opencv2/core.hpp", 3136); }  } while (0); 
# 3137
FileNode fn = (objname.empty() ? fs.getFirstTopLevelNode() : (fs[objname])); 
# 3138
if (fn.empty()) { return Ptr< _Tp> (); }  
# 3139
Ptr< _Tp>  obj = _Tp::create(); 
# 3140
obj->read(fn); 
# 3141
return (!obj->empty()) ? obj : Ptr< _Tp> (); 
# 3142
} 
# 3154 "/usr/include/opencv4/opencv2/core.hpp" 3
template< class _Tp> static Ptr< _Tp>  loadFromString(const String &strModel, const String &objname = String()) 
# 3155
{ 
# 3156
FileStorage fs(strModel, (FileStorage::READ) + (FileStorage::MEMORY)); 
# 3157
FileNode fn = (objname.empty() ? fs.getFirstTopLevelNode() : (fs[objname])); 
# 3158
Ptr< _Tp>  obj = _Tp::create(); 
# 3159
obj->read(fn); 
# 3160
return (!obj->empty()) ? obj : Ptr< _Tp> (); 
# 3161
} 
# 3165
virtual void save(const String & filename) const; 
# 3169
virtual String getDefaultName() const; 
# 3172
protected: void writeFormat(FileStorage & fs) const; 
# 3173
}; 
# 3175
enum class Param { 
# 3176
INT, BOOLEAN, REAL, STRING, MAT, MAT_VECTOR, ALGORITHM, FLOAT, 
# 3177
UNSIGNED_INT, UINT64, UCHAR = 11, SCALAR
# 3178
}; 
# 3182
template<> struct ParamType< bool>  { 
# 3184
typedef bool const_param_type; 
# 3185
typedef bool member_type; 
# 3187
static const Param type = Param::BOOLEAN; 
# 3188
}; 
# 3190
template<> struct ParamType< int>  { 
# 3192
typedef int const_param_type; 
# 3193
typedef int member_type; 
# 3195
static const Param type = Param::INT; 
# 3196
}; 
# 3198
template<> struct ParamType< double>  { 
# 3200
typedef double const_param_type; 
# 3201
typedef double member_type; 
# 3203
static const Param type = Param::REAL; 
# 3204
}; 
# 3206
template<> struct ParamType< std::__cxx11::basic_string< char> >  { 
# 3208
typedef const String &const_param_type; 
# 3209
typedef String member_type; 
# 3211
static const Param type = Param::STRING; 
# 3212
}; 
# 3214
template<> struct ParamType< Mat>  { 
# 3216
typedef const Mat &const_param_type; 
# 3217
typedef Mat member_type; 
# 3219
static const Param type = Param::MAT; 
# 3220
}; 
# 3222
template<> struct ParamType< std::vector< Mat> >  { 
# 3224
typedef const std::vector< Mat>  &const_param_type; 
# 3225
typedef std::vector< Mat>  member_type; 
# 3227
static const Param type = Param::MAT_VECTOR; 
# 3228
}; 
# 3230
template<> struct ParamType< Algorithm>  { 
# 3232
typedef const Ptr< Algorithm>  &const_param_type; 
# 3233
typedef Ptr< Algorithm>  member_type; 
# 3235
static const Param type = Param::ALGORITHM; 
# 3236
}; 
# 3238
template<> struct ParamType< float>  { 
# 3240
typedef float const_param_type; 
# 3241
typedef float member_type; 
# 3243
static const Param type = Param::FLOAT; 
# 3244
}; 
# 3246
template<> struct ParamType< unsigned>  { 
# 3248
typedef unsigned const_param_type; 
# 3249
typedef unsigned member_type; 
# 3251
static const Param type = Param::UNSIGNED_INT; 
# 3252
}; 
# 3254
template<> struct ParamType< unsigned long>  { 
# 3256
typedef uint64 const_param_type; 
# 3257
typedef uint64 member_type; 
# 3259
static const Param type = Param::UINT64; 
# 3260
}; 
# 3262
template<> struct ParamType< unsigned char>  { 
# 3264
typedef uchar const_param_type; 
# 3265
typedef uchar member_type; 
# 3267
static const Param type = Param::UCHAR; 
# 3268
}; 
# 3270
template<> struct ParamType< Scalar_< double> >  { 
# 3272
typedef const Scalar &const_param_type; 
# 3273
typedef Scalar member_type; 
# 3275
static const Param type = Param::SCALAR; 
# 3276
}; 
# 3278
template< class _Tp> 
# 3279
struct ParamType< _Tp, typename std::enable_if< std::is_enum< _Tp> ::value> ::type>  { 
# 3281
typedef typename std::underlying_type< _Tp> ::type const_param_type; 
# 3282
typedef typename std::underlying_type< _Tp> ::type member_type; 
# 3284
static const Param type = Param::INT; 
# 3285
}; 
# 3289
}
# 66 "/usr/include/opencv4/opencv2/core/operations.hpp" 3
namespace cv { 
# 71
namespace internal { 
# 74
template< class _Tp, int m, int n> struct Matx_FastInvOp { 
# 76
bool operator()(const Matx< _Tp, m, n>  &a, Matx< _Tp, n, m>  &b, int method) const 
# 77
{ 
# 78
return invert(a, b, method) != 0; 
# 79
} 
# 80
}; 
# 82
template< class _Tp, int m> struct Matx_FastInvOp< _Tp, m, m>  { 
# 84
bool operator()(const Matx< _Tp, m, m>  &a, Matx< _Tp, m, m>  &b, int method) const 
# 85
{ 
# 86
if ((method == (DECOMP_LU)) || (method == (DECOMP_CHOLESKY))) 
# 87
{ 
# 88
Matx< _Tp, m, m>  temp = a; 
# 91
for (int i = 0; i < m; i++) { 
# 92
b(i, i) = ((_Tp)1); }  
# 94
if (method == (DECOMP_CHOLESKY)) { 
# 95
return Cholesky((temp.val), (m) * sizeof(_Tp), m, (b.val), (m) * sizeof(_Tp), m); }  
# 97
return LU((temp.val), (m) * sizeof(_Tp), m, (b.val), (m) * sizeof(_Tp), m) != 0; 
# 98
} else 
# 100
{ 
# 101
return invert(a, b, method) != 0; 
# 102
}  
# 103
} 
# 104
}; 
# 106
template< class _Tp> struct Matx_FastInvOp< _Tp, 2, 2>  { 
# 108
bool operator()(const Matx< _Tp, 2, 2>  &a, Matx< _Tp, 2, 2>  &b, int) const 
# 109
{ 
# 110
_Tp d = (_Tp)determinant(a); 
# 111
if (d == 0) { 
# 112
return false; }  
# 113
d = (1 / d); 
# 114
b(1, 1) = (a(0, 0) * d); 
# 115
b(0, 0) = (a(1, 1) * d); 
# 116
b(0, 1) = ((-a(0, 1)) * d); 
# 117
b(1, 0) = ((-a(1, 0)) * d); 
# 118
return true; 
# 119
} 
# 120
}; 
# 122
template< class _Tp> struct Matx_FastInvOp< _Tp, 3, 3>  { 
# 124
bool operator()(const Matx< _Tp, 3, 3>  &a, Matx< _Tp, 3, 3>  &b, int) const 
# 125
{ 
# 126
_Tp d = (_Tp)determinant(a); 
# 127
if (d == 0) { 
# 128
return false; }  
# 129
d = (1 / d); 
# 130
b(0, 0) = (((a(1, 1) * a(2, 2)) - (a(1, 2) * a(2, 1))) * d); 
# 131
b(0, 1) = (((a(0, 2) * a(2, 1)) - (a(0, 1) * a(2, 2))) * d); 
# 132
b(0, 2) = (((a(0, 1) * a(1, 2)) - (a(0, 2) * a(1, 1))) * d); 
# 134
b(1, 0) = (((a(1, 2) * a(2, 0)) - (a(1, 0) * a(2, 2))) * d); 
# 135
b(1, 1) = (((a(0, 0) * a(2, 2)) - (a(0, 2) * a(2, 0))) * d); 
# 136
b(1, 2) = (((a(0, 2) * a(1, 0)) - (a(0, 0) * a(1, 2))) * d); 
# 138
b(2, 0) = (((a(1, 0) * a(2, 1)) - (a(1, 1) * a(2, 0))) * d); 
# 139
b(2, 1) = (((a(0, 1) * a(2, 0)) - (a(0, 0) * a(2, 1))) * d); 
# 140
b(2, 2) = (((a(0, 0) * a(1, 1)) - (a(0, 1) * a(1, 0))) * d); 
# 141
return true; 
# 142
} 
# 143
}; 
# 146
template< class _Tp, int m, int l, int n> struct Matx_FastSolveOp { 
# 148
bool operator()(const Matx< _Tp, m, l>  &a, const Matx< _Tp, m, n>  &b, Matx< _Tp, l, n>  &
# 149
x, int method) const 
# 150
{ 
# 151
return cv::solve(a, b, x, method); 
# 152
} 
# 153
}; 
# 155
template< class _Tp, int m, int n> struct Matx_FastSolveOp< _Tp, m, m, n>  { 
# 157
bool operator()(const Matx< _Tp, m, m>  &a, const Matx< _Tp, m, n>  &b, Matx< _Tp, m, n>  &
# 158
x, int method) const 
# 159
{ 
# 160
if ((method == (DECOMP_LU)) || (method == (DECOMP_CHOLESKY))) 
# 161
{ 
# 162
Matx< _Tp, m, m>  temp = a; 
# 163
x = b; 
# 164
if (method == (DECOMP_CHOLESKY)) { 
# 165
return Cholesky((temp.val), (m) * sizeof(_Tp), m, (x.val), (n) * sizeof(_Tp), n); }  
# 167
return LU((temp.val), (m) * sizeof(_Tp), m, (x.val), (n) * sizeof(_Tp), n) != 0; 
# 168
} else 
# 170
{ 
# 171
return cv::solve(a, b, x, method); 
# 172
}  
# 173
} 
# 174
}; 
# 176
template< class _Tp> struct Matx_FastSolveOp< _Tp, 2, 2, 1>  { 
# 178
bool operator()(const Matx< _Tp, 2, 2>  &a, const Matx< _Tp, 2, 1>  &b, Matx< _Tp, 2, 1>  &
# 179
x, int) const 
# 180
{ 
# 181
_Tp d = (_Tp)determinant(a); 
# 182
if (d == 0) { 
# 183
return false; }  
# 184
d = (1 / d); 
# 185
x(0) = (((b(0) * a(1, 1)) - (b(1) * a(0, 1))) * d); 
# 186
x(1) = (((b(1) * a(0, 0)) - (b(0) * a(1, 0))) * d); 
# 187
return true; 
# 188
} 
# 189
}; 
# 191
template< class _Tp> struct Matx_FastSolveOp< _Tp, 3, 3, 1>  { 
# 193
bool operator()(const Matx< _Tp, 3, 3>  &a, const Matx< _Tp, 3, 1>  &b, Matx< _Tp, 3, 1>  &
# 194
x, int) const 
# 195
{ 
# 196
_Tp d = (_Tp)determinant(a); 
# 197
if (d == 0) { 
# 198
return false; }  
# 199
d = (1 / d); 
# 200
x(0) = (d * (((b(0) * ((a(1, 1) * a(2, 2)) - (a(1, 2) * a(2, 1)))) - (a(0, 1) * ((b(1) * a(2, 2)) - (a(1, 2) * b(2))))) + (a(0, 2) * ((b(1) * a(2, 1)) - (a(1, 1) * b(2)))))); 
# 204
x(1) = (d * (((a(0, 0) * ((b(1) * a(2, 2)) - (a(1, 2) * b(2)))) - (b(0) * ((a(1, 0) * a(2, 2)) - (a(1, 2) * a(2, 0))))) + (a(0, 2) * ((a(1, 0) * b(2)) - (b(1) * a(2, 0)))))); 
# 208
x(2) = (d * (((a(0, 0) * ((a(1, 1) * b(2)) - (b(1) * a(2, 1)))) - (a(0, 1) * ((a(1, 0) * b(2)) - (b(1) * a(2, 0))))) + (b(0) * ((a(1, 0) * a(2, 1)) - (a(1, 1) * a(2, 0)))))); 
# 211
return true; 
# 212
} 
# 213
}; 
# 215
}
# 217
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 218
Matx< _Tp, m, n> ::randu(_Tp a, _Tp b) 
# 219
{ 
# 220
Matx M; 
# 221
cv::randu(M, ((Scalar_< double> )(a)), ((Scalar_< double> )(b))); 
# 222
return M; 
# 223
} 
# 225
template< class _Tp, int m, int n> inline Matx< _Tp, m, n>  
# 226
Matx< _Tp, m, n> ::randn(_Tp a, _Tp b) 
# 227
{ 
# 228
Matx M; 
# 229
cv::randn(M, ((Scalar_< double> )(a)), ((Scalar_< double> )(b))); 
# 230
return M; 
# 231
} 
# 233
template< class _Tp, int m, int n> inline Matx< _Tp, n, m>  
# 234
Matx< _Tp, m, n> ::inv(int method, bool *p_is_ok) const 
# 235
{ 
# 236
Matx< _Tp, n, m>  b; 
# 237
bool ok = internal::Matx_FastInvOp< _Tp, m, n> ()(*this, b, method); 
# 238
if (p_is_ok) { (*p_is_ok) = ok; }  
# 239
return ok ? b : Matx< _Tp, n, m> ::zeros(); 
# 240
} 
# 242
template< class _Tp, int m, int n> template< int l> inline Matx< _Tp, n, l>  
# 243
Matx< _Tp, m, n> ::solve(const Matx< _Tp, m, l>  &rhs, int method) const 
# 244
{ 
# 245
Matx< _Tp, n, l>  x; 
# 246
bool ok = internal::Matx_FastSolveOp< _Tp, m, n, l> ()(*this, rhs, x, method); 
# 247
return ok ? x : Matx< _Tp, n, l> ::zeros(); 
# 248
} 
# 269 "/usr/include/opencv4/opencv2/core/operations.hpp" 3
static inline Mat &operator+=(Mat &a, const Mat &b) { cv::add(a, b, a); return a; } static inline const Mat &operator+=(const Mat &a, const Mat &b) { cv::add(a, b, a); return a; } 
# 270
static inline Mat &operator+=(Mat &a, const Scalar &b) { cv::add(a, b, a); return a; } static inline const Mat &operator+=(const Mat &a, const Scalar &b) { cv::add(a, b, a); return a; } 
# 271
template< class _Tp> static inline Mat_< _Tp>  &operator+=(Mat_< _Tp>  &a, const Mat &b) { cv::add(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator+=(const Mat_< _Tp>  &a, const Mat &b) { cv::add(a, b, a); return a; } 
# 272
template< class _Tp> static inline Mat_< _Tp>  &operator+=(Mat_< _Tp>  &a, const Scalar &b) { cv::add(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator+=(const Mat_< _Tp>  &a, const Scalar &b) { cv::add(a, b, a); return a; } 
# 273
template< class _Tp> static inline Mat_< _Tp>  &operator+=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::add(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator+=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::add(a, b, a); return a; } 
# 274
template< class _Tp, int m, int n> static inline Mat &operator+=(Mat &a, const Matx< _Tp, m, n>  &b) { cv::add(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat &operator+=(const Mat &a, const Matx< _Tp, m, n>  &b) { cv::add(a, ((Mat)(b)), a); return a; } 
# 275
template< class _Tp, int m, int n> static inline Mat_< _Tp>  &operator+=(Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::add(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat_< _Tp>  &operator+=(const Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::add(a, ((Mat)(b)), a); return a; } 
# 277
static inline Mat &operator-=(Mat &a, const Mat &b) { cv::subtract(a, b, a); return a; } static inline const Mat &operator-=(const Mat &a, const Mat &b) { cv::subtract(a, b, a); return a; } 
# 278
static inline Mat &operator-=(Mat &a, const Scalar &b) { cv::subtract(a, b, a); return a; } static inline const Mat &operator-=(const Mat &a, const Scalar &b) { cv::subtract(a, b, a); return a; } 
# 279
template< class _Tp> static inline Mat_< _Tp>  &operator-=(Mat_< _Tp>  &a, const Mat &b) { cv::subtract(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator-=(const Mat_< _Tp>  &a, const Mat &b) { cv::subtract(a, b, a); return a; } 
# 280
template< class _Tp> static inline Mat_< _Tp>  &operator-=(Mat_< _Tp>  &a, const Scalar &b) { cv::subtract(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator-=(const Mat_< _Tp>  &a, const Scalar &b) { cv::subtract(a, b, a); return a; } 
# 281
template< class _Tp> static inline Mat_< _Tp>  &operator-=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::subtract(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator-=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::subtract(a, b, a); return a; } 
# 282
template< class _Tp, int m, int n> static inline Mat &operator-=(Mat &a, const Matx< _Tp, m, n>  &b) { cv::subtract(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat &operator-=(const Mat &a, const Matx< _Tp, m, n>  &b) { cv::subtract(a, ((Mat)(b)), a); return a; } 
# 283
template< class _Tp, int m, int n> static inline Mat_< _Tp>  &operator-=(Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::subtract(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat_< _Tp>  &operator-=(const Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::subtract(a, ((Mat)(b)), a); return a; } 
# 285
static inline Mat &operator*=(Mat &a, const Mat &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } static inline const Mat &operator*=(const Mat &a, const Mat &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } 
# 286
template< class _Tp> static inline Mat_< _Tp>  &operator*=(Mat_< _Tp>  &a, const Mat &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator*=(const Mat_< _Tp>  &a, const Mat &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } 
# 287
template< class _Tp> static inline Mat_< _Tp>  &operator*=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator*=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::gemm(a, b, 1, Mat(), 0, a, 0); return a; } 
# 288
static inline Mat &operator*=(Mat &a, const double &b) { a.convertTo(a, -1, b); return a; } static inline const Mat &operator*=(const Mat &a, const double &b) { a.convertTo(a, -1, b); return a; } 
# 289
template< class _Tp> static inline Mat_< _Tp>  &operator*=(Mat_< _Tp>  &a, const double &b) { a.convertTo(a, -1, b); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator*=(const Mat_< _Tp>  &a, const double &b) { a.convertTo(a, -1, b); return a; } 
# 290
template< class _Tp, int m, int n> static inline Mat &operator*=(Mat &a, const Matx< _Tp, m, n>  &b) { cv::gemm(a, ((Mat)(b)), 1, Mat(), 0, a, 0); return a; } template< class _Tp, int m, int n> static inline const Mat &operator*=(const Mat &a, const Matx< _Tp, m, n>  &b) { cv::gemm(a, ((Mat)(b)), 1, Mat(), 0, a, 0); return a; } 
# 291
template< class _Tp, int m, int n> static inline Mat_< _Tp>  &operator*=(Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::gemm(a, ((Mat)(b)), 1, Mat(), 0, a, 0); return a; } template< class _Tp, int m, int n> static inline const Mat_< _Tp>  &operator*=(const Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::gemm(a, ((Mat)(b)), 1, Mat(), 0, a, 0); return a; } 
# 293
static inline Mat &operator/=(Mat &a, const Mat &b) { cv::divide(a, b, a); return a; } static inline const Mat &operator/=(const Mat &a, const Mat &b) { cv::divide(a, b, a); return a; } 
# 294
template< class _Tp> static inline Mat_< _Tp>  &operator/=(Mat_< _Tp>  &a, const Mat &b) { cv::divide(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator/=(const Mat_< _Tp>  &a, const Mat &b) { cv::divide(a, b, a); return a; } 
# 295
template< class _Tp> static inline Mat_< _Tp>  &operator/=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::divide(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator/=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::divide(a, b, a); return a; } 
# 296
static inline Mat &operator/=(Mat &a, const double &b) { a.convertTo((Mat &)a, -1, (1.0) / b); return a; } static inline const Mat &operator/=(const Mat &a, const double &b) { a.convertTo((Mat &)a, -1, (1.0) / b); return a; } 
# 297
template< class _Tp> static inline Mat_< _Tp>  &operator/=(Mat_< _Tp>  &a, const double &b) { a.convertTo((Mat &)a, -1, (1.0) / b); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator/=(const Mat_< _Tp>  &a, const double &b) { a.convertTo((Mat &)a, -1, (1.0) / b); return a; } 
# 298
template< class _Tp, int m, int n> static inline Mat &operator/=(Mat &a, const Matx< _Tp, m, n>  &b) { cv::divide(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat &operator/=(const Mat &a, const Matx< _Tp, m, n>  &b) { cv::divide(a, ((Mat)(b)), a); return a; } 
# 299
template< class _Tp, int m, int n> static inline Mat_< _Tp>  &operator/=(Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::divide(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat_< _Tp>  &operator/=(const Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::divide(a, ((Mat)(b)), a); return a; } 
# 301
static inline Mat &operator&=(Mat &a, const Mat &b) { cv::bitwise_and(a, b, a); return a; } static inline const Mat &operator&=(const Mat &a, const Mat &b) { cv::bitwise_and(a, b, a); return a; } 
# 302
static inline Mat &operator&=(Mat &a, const Scalar &b) { cv::bitwise_and(a, b, a); return a; } static inline const Mat &operator&=(const Mat &a, const Scalar &b) { cv::bitwise_and(a, b, a); return a; } 
# 303
template< class _Tp> static inline Mat_< _Tp>  &operator&=(Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_and(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator&=(const Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_and(a, b, a); return a; } 
# 304
template< class _Tp> static inline Mat_< _Tp>  &operator&=(Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_and(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator&=(const Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_and(a, b, a); return a; } 
# 305
template< class _Tp> static inline Mat_< _Tp>  &operator&=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_and(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator&=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_and(a, b, a); return a; } 
# 306
template< class _Tp, int m, int n> static inline Mat &operator&=(Mat &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_and(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat &operator&=(const Mat &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_and(a, ((Mat)(b)), a); return a; } 
# 307
template< class _Tp, int m, int n> static inline Mat_< _Tp>  &operator&=(Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_and(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat_< _Tp>  &operator&=(const Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_and(a, ((Mat)(b)), a); return a; } 
# 309
static inline Mat &operator|=(Mat &a, const Mat &b) { cv::bitwise_or(a, b, a); return a; } static inline const Mat &operator|=(const Mat &a, const Mat &b) { cv::bitwise_or(a, b, a); return a; } 
# 310
static inline Mat &operator|=(Mat &a, const Scalar &b) { cv::bitwise_or(a, b, a); return a; } static inline const Mat &operator|=(const Mat &a, const Scalar &b) { cv::bitwise_or(a, b, a); return a; } 
# 311
template< class _Tp> static inline Mat_< _Tp>  &operator|=(Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_or(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator|=(const Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_or(a, b, a); return a; } 
# 312
template< class _Tp> static inline Mat_< _Tp>  &operator|=(Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_or(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator|=(const Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_or(a, b, a); return a; } 
# 313
template< class _Tp> static inline Mat_< _Tp>  &operator|=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_or(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator|=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_or(a, b, a); return a; } 
# 314
template< class _Tp, int m, int n> static inline Mat &operator|=(Mat &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_or(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat &operator|=(const Mat &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_or(a, ((Mat)(b)), a); return a; } 
# 315
template< class _Tp, int m, int n> static inline Mat_< _Tp>  &operator|=(Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_or(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat_< _Tp>  &operator|=(const Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_or(a, ((Mat)(b)), a); return a; } 
# 317
static inline Mat &operator^=(Mat &a, const Mat &b) { cv::bitwise_xor(a, b, a); return a; } static inline const Mat &operator^=(const Mat &a, const Mat &b) { cv::bitwise_xor(a, b, a); return a; } 
# 318
static inline Mat &operator^=(Mat &a, const Scalar &b) { cv::bitwise_xor(a, b, a); return a; } static inline const Mat &operator^=(const Mat &a, const Scalar &b) { cv::bitwise_xor(a, b, a); return a; } 
# 319
template< class _Tp> static inline Mat_< _Tp>  &operator^=(Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_xor(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator^=(const Mat_< _Tp>  &a, const Mat &b) { cv::bitwise_xor(a, b, a); return a; } 
# 320
template< class _Tp> static inline Mat_< _Tp>  &operator^=(Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_xor(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator^=(const Mat_< _Tp>  &a, const Scalar &b) { cv::bitwise_xor(a, b, a); return a; } 
# 321
template< class _Tp> static inline Mat_< _Tp>  &operator^=(Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_xor(a, b, a); return a; } template< class _Tp> static inline const Mat_< _Tp>  &operator^=(const Mat_< _Tp>  &a, const Mat_< _Tp>  &b) { cv::bitwise_xor(a, b, a); return a; } 
# 322
template< class _Tp, int m, int n> static inline Mat &operator^=(Mat &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_xor(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat &operator^=(const Mat &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_xor(a, ((Mat)(b)), a); return a; } 
# 323
template< class _Tp, int m, int n> static inline Mat_< _Tp>  &operator^=(Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_xor(a, ((Mat)(b)), a); return a; } template< class _Tp, int m, int n> static inline const Mat_< _Tp>  &operator^=(const Mat_< _Tp>  &a, const Matx< _Tp, m, n>  &b) { cv::bitwise_xor(a, ((Mat)(b)), a); return a; } 
# 334 "/usr/include/opencv4/opencv2/core/operations.hpp" 3
inline SVD::SVD() { } 
# 335
inline SVD::SVD(InputArray m, int flags) { this->operator()(m, flags); } 
# 336
inline void SVD::solveZ(InputArray m, OutputArray _dst) 
# 337
{ 
# 338
Mat mtx = m.getMat(); 
# 339
SVD svd(mtx, ((mtx.rows) >= (mtx.cols)) ? 0 : (SVD::FULL_UV)); 
# 340
_dst.create((svd.vt).cols, 1, (svd.vt).type()); 
# 341
Mat dst = _dst.getMat(); 
# 342
(((svd.vt).row(((svd.vt).rows) - 1)).reshape(1, (svd.vt).cols)).copyTo(dst); 
# 343
} 
# 345
template< class _Tp, int m, int n, int nm> inline void 
# 346
SVD::compute(const Matx< _Tp, m, n>  &a, Matx< _Tp, nm, 1>  &w, Matx< _Tp, m, nm>  &u, Matx< _Tp, n, nm>  &vt) 
# 347
{ 
# 348
static_assert((nm == ((m > n) ? n : m)), "Invalid size of output vector. nm == MIN(m, n)");
# 349
Mat _a(a, false), _u(u, false), _w(w, false), _vt(vt, false); 
# 350
SVD::compute(_a, _w, _u, _vt); 
# 351
do { if (!(!(((_w.data) == ((uchar *)(&((w.val)[0])))) && ((_u.data) == ((uchar *)(&((u.val)[0])))) && ((_vt.data) == ((uchar *)(&((vt.val)[0]))))))) { ; } else { cv::error(cv::Error::StsAssert, "_w.data == (uchar*)&w.val[0] && _u.data == (uchar*)&u.val[0] && _vt.data == (uchar*)&vt.val[0]", __func__, "/usr/include/opencv4/opencv2/core/operations.hpp", 351); }  } while (0); 
# 352
} 
# 354
template< class _Tp, int m, int n, int nm> inline void 
# 355
SVD::compute(const Matx< _Tp, m, n>  &a, Matx< _Tp, nm, 1>  &w) 
# 356
{ 
# 357
static_assert((nm == ((m > n) ? n : m)), "Invalid size of output vector. nm == MIN(m, n)");
# 358
Mat _a(a, false), _w(w, false); 
# 359
SVD::compute(_a, _w); 
# 360
do { if (!(!((_w.data) == ((uchar *)(&((w.val)[0])))))) { ; } else { cv::error(cv::Error::StsAssert, "_w.data == (uchar*)&w.val[0]", __func__, "/usr/include/opencv4/opencv2/core/operations.hpp", 360); }  } while (0); 
# 361
} 
# 363
template< class _Tp, int m, int n, int nm, int nb> inline void 
# 364
SVD::backSubst(const Matx< _Tp, nm, 1>  &w, const Matx< _Tp, m, nm>  &u, const Matx< _Tp, n, nm>  &
# 365
vt, const Matx< _Tp, m, nb>  &rhs, Matx< _Tp, n, nb>  &
# 366
dst) 
# 367
{ 
# 368
static_assert((nm == ((m > n) ? n : m)), "Invalid size of output vector. nm == MIN(m, n)");
# 369
Mat _u(u, false), _w(w, false), _vt(vt, false), _rhs(rhs, false), _dst(dst, false); 
# 370
SVD::backSubst(_w, _u, _vt, _rhs, _dst); 
# 371
do { if (!(!((_dst.data) == ((uchar *)(&((dst.val)[0])))))) { ; } else { cv::error(cv::Error::StsAssert, "_dst.data == (uchar*)&dst.val[0]", __func__, "/usr/include/opencv4/opencv2/core/operations.hpp", 371); }  } while (0); 
# 372
} 
# 378
inline RNG::RNG() { (state) = (4294967295U); } 
# 379
inline RNG::RNG(uint64 _state) { (state) = ((_state) ? _state : (4294967295U)); } 
# 381
inline RNG::operator uchar() { return (uchar)this->next(); } 
# 382
inline RNG::operator schar() { return (schar)this->next(); } 
# 383
inline RNG::operator ushort() { return (ushort)this->next(); } 
# 384
inline RNG::operator short() { return (short)this->next(); } 
# 385
inline RNG::operator int() { return (int)this->next(); } 
# 386
inline RNG::operator unsigned() { return this->next(); } 
# 387
inline RNG::operator float() { return (this->next()) * (2.3283064E-10F); } 
# 388
inline RNG::operator double() { unsigned t = this->next(); return ((((uint64)t) << 32) | (this->next())) * (5.421010862427522E-20); } 
# 390
inline unsigned RNG::operator()(unsigned N) { return (unsigned)this->uniform(0, N); } 
# 391
inline unsigned RNG::operator()() { return this->next(); } 
# 393
inline int RNG::uniform(int a, int b) { return (a == b) ? a : ((int)((this->next() % (b - a)) + a)); } 
# 394
inline float RNG::uniform(float a, float b) { return (((float)(*this)) * (b - a)) + a; } 
# 395
inline double RNG::uniform(double a, double b) { return (((double)(*this)) * (b - a)) + a; } 
# 397
inline bool RNG::operator==(const RNG &other) const { return (state) == (other.state); } 
# 399
inline unsigned RNG::next() 
# 400
{ 
# 401
(state) = ((((uint64)((unsigned)(state))) * (4164903690U)) + ((unsigned)((state) >> 32))); 
# 402
return (unsigned)(state); 
# 403
} 
# 406
template< class _Tp> static inline _Tp randu() 
# 407
{ 
# 408
return (_Tp)theRNG(); 
# 409
} 
# 430 "/usr/include/opencv4/opencv2/core/operations.hpp" 3
String format(const char * fmt, ...) __attribute((format(printf, 1, 2))); 
# 435
static inline Ptr< Formatted>  format(InputArray mtx, Formatter::FormatType fmt) 
# 436
{ 
# 437
return (Formatter::get(fmt))->format(mtx.getMat()); 
# 438
} 
# 441
static inline int print(Ptr< Formatted>  fmtd, FILE *stream = stdout) 
# 442
{ 
# 443
int written = 0; 
# 444
fmtd->reset(); 
# 445
for (const char *str = fmtd->next(); str; str = fmtd->next()) { 
# 446
written += fputs(str, stream); }  
# 448
return written; 
# 449
} 
# 452
static inline int print(const Mat &mtx, FILE *stream = stdout) 
# 453
{ 
# 454
return print((Formatter::get())->format(mtx), stream); 
# 455
} 
# 458
static inline int print(const UMat &mtx, FILE *stream = stdout) 
# 459
{ 
# 460
return print((Formatter::get())->format(mtx.getMat(ACCESS_READ)), stream); 
# 461
} 
# 463
template< class _Tp> static inline int 
# 464
print(const std::vector< Point_< _Tp> >  &vec, FILE *stream = stdout) 
# 465
{ 
# 466
return print((Formatter::get())->format(((Mat)(vec))), stream); 
# 467
} 
# 469
template< class _Tp> static inline int 
# 470
print(const std::vector< Point3_< _Tp> >  &vec, FILE *stream = stdout) 
# 471
{ 
# 472
return print((Formatter::get())->format(((Mat)(vec))), stream); 
# 473
} 
# 475
template< class _Tp, int m, int n> static inline int 
# 476
print(const Matx< _Tp, m, n>  &matx, FILE *stream = stdout) 
# 477
{ 
# 478
return print((Formatter::get())->format(((Mat)(matx))), stream); 
# 479
} 
# 502 "/usr/include/opencv4/opencv2/core/operations.hpp" 3
template< class _Tp, class _EqPredicate> int 
# 503
partition(const std::vector< _Tp>  &_vec, std::vector< int>  &labels, _EqPredicate 
# 504
predicate = _EqPredicate()) 
# 505
{ 
# 506
int i, j, N = (int)_vec.size(); 
# 507
const _Tp *vec = (&(_vec[0])); 
# 509
const int PARENT = 0; 
# 510
const int RANK = 1; 
# 512
std::vector< int>  _nodes(N * 2); 
# 513
int (*nodes)[2] = (int (*)[2])(&_nodes[0]); 
# 516
for (i = 0; i < N; i++) 
# 517
{ 
# 518
((nodes[i])[PARENT]) = (-1); 
# 519
((nodes[i])[RANK]) = 0; 
# 520
}  
# 523
for (i = 0; i < N; i++) 
# 524
{ 
# 525
int root = i; 
# 528
while (((nodes[root])[PARENT]) >= 0) { 
# 529
root = ((nodes[root])[PARENT]); }  
# 531
for (j = 0; j < N; j++) 
# 532
{ 
# 533
if ((i == j) || (!predicate(vec[i], vec[j]))) { 
# 534
continue; }  
# 535
int root2 = j; 
# 537
while (((nodes[root2])[PARENT]) >= 0) { 
# 538
root2 = ((nodes[root2])[PARENT]); }  
# 540
if (root2 != root) 
# 541
{ 
# 543
int rank = (nodes[root])[RANK], rank2 = (nodes[root2])[RANK]; 
# 544
if (rank > rank2) { 
# 545
((nodes[root2])[PARENT]) = root; } else 
# 547
{ 
# 548
((nodes[root])[PARENT]) = root2; 
# 549
((nodes[root2])[RANK]) += (rank == rank2); 
# 550
root = root2; 
# 551
}  
# 552
do { if (!(!(((nodes[root])[PARENT]) < 0))) { ; } else { cv::error(cv::Error::StsAssert, "nodes[root][PARENT] < 0", __func__, "/usr/include/opencv4/opencv2/core/operations.hpp", 552); }  } while (0); 
# 554
int k = j, parent; 
# 557
while ((parent = ((nodes[k])[PARENT])) >= 0) 
# 558
{ 
# 559
((nodes[k])[PARENT]) = root; 
# 560
k = parent; 
# 561
}  
# 564
k = i; 
# 565
while ((parent = ((nodes[k])[PARENT])) >= 0) 
# 566
{ 
# 567
((nodes[k])[PARENT]) = root; 
# 568
k = parent; 
# 569
}  
# 570
}  
# 571
}   
# 572
}  
# 575
labels.resize(N); 
# 576
int nclasses = 0; 
# 578
for (i = 0; i < N; i++) 
# 579
{ 
# 580
int root = i; 
# 581
while (((nodes[root])[PARENT]) >= 0) { 
# 582
root = ((nodes[root])[PARENT]); }  
# 584
if (((nodes[root])[RANK]) >= 0) { 
# 585
((nodes[root])[RANK]) = (~(nclasses++)); }  
# 586
labels[i] = (~((nodes[root])[RANK])); 
# 587
}  
# 589
return nclasses; 
# 590
} 
# 592
}
# 41 "/usr/include/c++/9/sstream" 3
namespace std __attribute((__visibility__("default"))) { 
# 44
inline namespace __cxx11 { 
# 64 "/usr/include/c++/9/sstream" 3
template< class _CharT, class _Traits, class _Alloc> 
# 65
class basic_stringbuf : public basic_streambuf< _CharT, _Traits>  { 
# 67
struct __xfer_bufptrs; 
# 70
public: typedef _CharT char_type; 
# 71
typedef _Traits traits_type; 
# 74
typedef _Alloc allocator_type; 
# 75
typedef typename _Traits::int_type int_type; 
# 76
typedef typename _Traits::pos_type pos_type; 
# 77
typedef typename _Traits::off_type off_type; 
# 79
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 80
typedef basic_string< char_type, _Traits, _Alloc>  __string_type; 
# 81
typedef typename basic_string< char_type, _Traits, _Alloc> ::size_type __size_type; 
# 85
protected: std::ios_base::openmode _M_mode; 
# 88
__string_type _M_string; 
# 99 "/usr/include/c++/9/sstream" 3
public: basic_stringbuf() : __streambuf_type(), _M_mode((std::ios_base::in | std::ios_base::out)), _M_string() 
# 101
{ } 
# 111 "/usr/include/c++/9/sstream" 3
explicit basic_stringbuf(std::ios_base::openmode __mode) : __streambuf_type(), _M_mode(__mode), _M_string() 
# 113
{ } 
# 124 "/usr/include/c++/9/sstream" 3
explicit basic_stringbuf(const __string_type &__str, std::ios_base::openmode 
# 125
__mode = (std::ios_base::in | std::ios_base::out)) : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size(), __str.get_allocator()) 
# 128
{ _M_stringbuf_init(__mode); } 
# 131
basic_stringbuf(const basic_stringbuf &) = delete;
# 133
basic_stringbuf(basic_stringbuf &&__rhs) : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this)) 
# 135
{ __rhs._M_sync(const_cast< char_type *>((__rhs._M_string).data()), 0, 0); } 
# 140
basic_stringbuf &operator=(const basic_stringbuf &) = delete;
# 143
basic_stringbuf &operator=(basic_stringbuf &&__rhs) 
# 144
{ 
# 145
__xfer_bufptrs __st{__rhs, this}; 
# 146
const __streambuf_type &__base = __rhs; 
# 147
basic_streambuf< _CharT, _Traits> ::operator=(__base); 
# 148
this->pubimbue(__rhs.getloc()); 
# 149
(_M_mode) = (__rhs._M_mode); 
# 150
(_M_string) = std::move(__rhs._M_string); 
# 151
__rhs._M_sync(const_cast< char_type *>((__rhs._M_string).data()), 0, 0); 
# 152
return *this; 
# 153
} 
# 156
void swap(basic_stringbuf &__rhs) 
# 157
{ 
# 158
__xfer_bufptrs __l_st{*this, std::__addressof(__rhs)}; 
# 159
__xfer_bufptrs __r_st{__rhs, this}; 
# 160
__streambuf_type &__base = __rhs; 
# 161
__streambuf_type::swap(__base); 
# 162
__rhs.pubimbue(this->pubimbue(__rhs.getloc())); 
# 163
std::swap(_M_mode, __rhs._M_mode); 
# 164
std::swap(_M_string, __rhs._M_string); 
# 165
} 
# 178 "/usr/include/c++/9/sstream" 3
__string_type str() const 
# 179
{ 
# 180
__string_type __ret((_M_string).get_allocator()); 
# 181
if (this->pptr()) 
# 182
{ 
# 184
if (this->pptr() > this->egptr()) { 
# 185
__ret.assign(this->pbase(), this->pptr()); } else { 
# 187
__ret.assign(this->pbase(), this->egptr()); }  
# 188
} else { 
# 190
__ret = (_M_string); }  
# 191
return __ret; 
# 192
} 
# 202 "/usr/include/c++/9/sstream" 3
void str(const __string_type &__s) 
# 203
{ 
# 206
(_M_string).assign(__s.data(), __s.size()); 
# 207
_M_stringbuf_init(_M_mode); 
# 208
} 
# 213
protected: void _M_stringbuf_init(std::ios_base::openmode __mode) 
# 214
{ 
# 215
(_M_mode) = __mode; 
# 216
__size_type __len = (0); 
# 217
if (((_M_mode) & ((std::ios_base::ate | std::ios_base::app)))) { 
# 218
__len = (_M_string).size(); }  
# 219
_M_sync(const_cast< char_type *>((_M_string).data()), 0, __len); 
# 220
} 
# 223
virtual std::streamsize showmanyc() 
# 224
{ 
# 225
std::streamsize __ret = (-1); 
# 226
if (((_M_mode) & std::ios_base::in)) 
# 227
{ 
# 228
_M_update_egptr(); 
# 229
__ret = (this->egptr() - this->gptr()); 
# 230
}  
# 231
return __ret; 
# 232
} 
# 235
virtual int_type underflow(); 
# 238
virtual int_type pbackfail(int_type __c = traits_type::eof()); 
# 241
virtual int_type overflow(int_type __c = traits_type::eof()); 
# 255 "/usr/include/c++/9/sstream" 3
virtual __streambuf_type *setbuf(char_type *__s, std::streamsize __n) 
# 256
{ 
# 257
if (__s && (__n >= (0))) 
# 258
{ 
# 265
(_M_string).clear(); 
# 268
_M_sync(__s, __n, 0); 
# 269
}  
# 270
return this; 
# 271
} 
# 274
virtual pos_type seekoff(off_type __off, std::ios_base::seekdir __way, std::ios_base::openmode __mode = (std::ios_base::in | std::ios_base::out)); 
# 278
virtual pos_type seekpos(pos_type __sp, std::ios_base::openmode __mode = (std::ios_base::in | std::ios_base::out)); 
# 285
void _M_sync(char_type * __base, __size_type __i, __size_type __o); 
# 290
void _M_update_egptr() 
# 291
{ 
# 292
const bool __testin = ((_M_mode) & std::ios_base::in); 
# 293
if (this->pptr() && (this->pptr() > this->egptr())) 
# 294
{ 
# 295
if (__testin) { 
# 296
this->setg(this->eback(), this->gptr(), this->pptr()); } else { 
# 298
this->setg(this->pptr(), this->pptr(), this->pptr()); }  
# 299
}  
# 300
} 
# 305
void _M_pbump(char_type * __pbeg, char_type * __pend, off_type __off); 
# 312
private: struct __xfer_bufptrs { 
# 314
__xfer_bufptrs(const basic_stringbuf &__from, basic_stringbuf *__to) : _M_to{__to}, _M_goff{(-1), (-1), (-1)}, _M_poff{(-1), (-1), (-1)} 
# 316
{ 
# 317
const _CharT *const __str = (__from._M_string).data(); 
# 318
const _CharT *__end = (nullptr); 
# 319
if (__from.eback()) 
# 320
{ 
# 321
((_M_goff)[0]) = (__from.eback() - __str); 
# 322
((_M_goff)[1]) = (__from.gptr() - __str); 
# 323
((_M_goff)[2]) = (__from.egptr() - __str); 
# 324
__end = __from.egptr(); 
# 325
}  
# 326
if (__from.pbase()) 
# 327
{ 
# 328
((_M_poff)[0]) = (__from.pbase() - __str); 
# 329
((_M_poff)[1]) = (__from.pptr() - __from.pbase()); 
# 330
((_M_poff)[2]) = (__from.epptr() - __str); 
# 331
if (__from.pptr() > __end) { 
# 332
__end = __from.pptr(); }  
# 333
}  
# 336
if (__end) 
# 337
{ 
# 340
auto &__mut_from = const_cast< basic_stringbuf &>(__from); 
# 341
(__mut_from._M_string)._M_length(__end - __str); 
# 342
}  
# 343
} 
# 345
~__xfer_bufptrs() 
# 346
{ 
# 347
char_type *__str = const_cast< char_type *>(((_M_to)->_M_string).data()); 
# 348
if (((_M_goff)[0]) != (-1)) { 
# 349
(_M_to)->setg(__str + ((_M_goff)[0]), __str + ((_M_goff)[1]), __str + ((_M_goff)[2])); }  
# 350
if (((_M_poff)[0]) != (-1)) { 
# 351
(_M_to)->_M_pbump(__str + ((_M_poff)[0]), __str + ((_M_poff)[2]), (_M_poff)[1]); }  
# 352
} 
# 354
basic_stringbuf *_M_to; 
# 355
off_type _M_goff[3]; 
# 356
off_type _M_poff[3]; 
# 357
}; 
# 368 "/usr/include/c++/9/sstream" 3
basic_stringbuf(basic_stringbuf &&__rhs, __xfer_bufptrs &&) : __streambuf_type(static_cast< const __streambuf_type &>(__rhs)), _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string)) 
# 371
{ } 
# 373
}; 
# 391 "/usr/include/c++/9/sstream" 3
template< class _CharT, class _Traits, class _Alloc> 
# 392
class basic_istringstream : public basic_istream< _CharT, _Traits>  { 
# 396
public: typedef _CharT char_type; 
# 397
typedef _Traits traits_type; 
# 400
typedef _Alloc allocator_type; 
# 401
typedef typename _Traits::int_type int_type; 
# 402
typedef typename _Traits::pos_type pos_type; 
# 403
typedef typename _Traits::off_type off_type; 
# 406
typedef basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 407
typedef basic_stringbuf< _CharT, _Traits, _Alloc>  __stringbuf_type; 
# 408
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 411
private: __stringbuf_type _M_stringbuf; 
# 425 "/usr/include/c++/9/sstream" 3
public: basic_istringstream() : __istream_type(), _M_stringbuf(ios_base::in) 
# 427
{ this->init(&(_M_stringbuf)); } 
# 442 "/usr/include/c++/9/sstream" 3
explicit basic_istringstream(std::ios_base::openmode __mode) : __istream_type(), _M_stringbuf((__mode | std::ios_base::in)) 
# 444
{ this->init(&(_M_stringbuf)); } 
# 460 "/usr/include/c++/9/sstream" 3
explicit basic_istringstream(const __string_type &__str, std::ios_base::openmode 
# 461
__mode = ios_base::in) : __istream_type(), _M_stringbuf(__str, (__mode | std::ios_base::in)) 
# 463
{ this->init(&(_M_stringbuf)); } 
# 471
~basic_istringstream() 
# 472
{ } 
# 475
basic_istringstream(const basic_istringstream &) = delete;
# 477
basic_istringstream(basic_istringstream &&__rhs) : __istream_type(std::move(__rhs)), _M_stringbuf(std::move(__rhs._M_stringbuf)) 
# 480
{ __istream_type::set_rdbuf(&(_M_stringbuf)); } 
# 485
basic_istringstream &operator=(const basic_istringstream &) = delete;
# 488
basic_istringstream &operator=(basic_istringstream &&__rhs) 
# 489
{ 
# 490
basic_istream< _CharT, _Traits> ::operator=(std::move(__rhs)); 
# 491
(_M_stringbuf) = std::move(__rhs._M_stringbuf); 
# 492
return *this; 
# 493
} 
# 496
void swap(basic_istringstream &__rhs) 
# 497
{ 
# 498
__istream_type::swap(__rhs); 
# 499
(_M_stringbuf).swap(__rhs._M_stringbuf); 
# 500
} 
# 511 "/usr/include/c++/9/sstream" 3
__stringbuf_type *rdbuf() const 
# 512
{ return const_cast< __stringbuf_type *>(&(_M_stringbuf)); } 
# 519
__string_type str() const 
# 520
{ return (_M_stringbuf).str(); } 
# 529
void str(const __string_type &__s) 
# 530
{ (_M_stringbuf).str(__s); } 
# 531
}; 
# 549 "/usr/include/c++/9/sstream" 3
template< class _CharT, class _Traits, class _Alloc> 
# 550
class basic_ostringstream : public basic_ostream< _CharT, _Traits>  { 
# 554
public: typedef _CharT char_type; 
# 555
typedef _Traits traits_type; 
# 558
typedef _Alloc allocator_type; 
# 559
typedef typename _Traits::int_type int_type; 
# 560
typedef typename _Traits::pos_type pos_type; 
# 561
typedef typename _Traits::off_type off_type; 
# 564
typedef basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 565
typedef basic_stringbuf< _CharT, _Traits, _Alloc>  __stringbuf_type; 
# 566
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 569
private: __stringbuf_type _M_stringbuf; 
# 583 "/usr/include/c++/9/sstream" 3
public: basic_ostringstream() : __ostream_type(), _M_stringbuf(ios_base::out) 
# 585
{ this->init(&(_M_stringbuf)); } 
# 600 "/usr/include/c++/9/sstream" 3
explicit basic_ostringstream(std::ios_base::openmode __mode) : __ostream_type(), _M_stringbuf((__mode | std::ios_base::out)) 
# 602
{ this->init(&(_M_stringbuf)); } 
# 618 "/usr/include/c++/9/sstream" 3
explicit basic_ostringstream(const __string_type &__str, std::ios_base::openmode 
# 619
__mode = ios_base::out) : __ostream_type(), _M_stringbuf(__str, (__mode | std::ios_base::out)) 
# 621
{ this->init(&(_M_stringbuf)); } 
# 629
~basic_ostringstream() 
# 630
{ } 
# 633
basic_ostringstream(const basic_ostringstream &) = delete;
# 635
basic_ostringstream(basic_ostringstream &&__rhs) : __ostream_type(std::move(__rhs)), _M_stringbuf(std::move(__rhs._M_stringbuf)) 
# 638
{ __ostream_type::set_rdbuf(&(_M_stringbuf)); } 
# 643
basic_ostringstream &operator=(const basic_ostringstream &) = delete;
# 646
basic_ostringstream &operator=(basic_ostringstream &&__rhs) 
# 647
{ 
# 648
basic_ostream< _CharT, _Traits> ::operator=(std::move(__rhs)); 
# 649
(_M_stringbuf) = std::move(__rhs._M_stringbuf); 
# 650
return *this; 
# 651
} 
# 654
void swap(basic_ostringstream &__rhs) 
# 655
{ 
# 656
__ostream_type::swap(__rhs); 
# 657
(_M_stringbuf).swap(__rhs._M_stringbuf); 
# 658
} 
# 669 "/usr/include/c++/9/sstream" 3
__stringbuf_type *rdbuf() const 
# 670
{ return const_cast< __stringbuf_type *>(&(_M_stringbuf)); } 
# 677
__string_type str() const 
# 678
{ return (_M_stringbuf).str(); } 
# 687
void str(const __string_type &__s) 
# 688
{ (_M_stringbuf).str(__s); } 
# 689
}; 
# 707 "/usr/include/c++/9/sstream" 3
template< class _CharT, class _Traits, class _Alloc> 
# 708
class basic_stringstream : public basic_iostream< _CharT, _Traits>  { 
# 712
public: typedef _CharT char_type; 
# 713
typedef _Traits traits_type; 
# 716
typedef _Alloc allocator_type; 
# 717
typedef typename _Traits::int_type int_type; 
# 718
typedef typename _Traits::pos_type pos_type; 
# 719
typedef typename _Traits::off_type off_type; 
# 722
typedef basic_string< _CharT, _Traits, _Alloc>  __string_type; 
# 723
typedef basic_stringbuf< _CharT, _Traits, _Alloc>  __stringbuf_type; 
# 724
typedef basic_iostream< _CharT, _Traits>  __iostream_type; 
# 727
private: __stringbuf_type _M_stringbuf; 
# 741 "/usr/include/c++/9/sstream" 3
public: basic_stringstream() : __iostream_type(), _M_stringbuf((std::ios_base::out | std::ios_base::in)) 
# 743
{ this->init(&(_M_stringbuf)); } 
# 756 "/usr/include/c++/9/sstream" 3
explicit basic_stringstream(std::ios_base::openmode __m) : __iostream_type(), _M_stringbuf(__m) 
# 758
{ this->init(&(_M_stringbuf)); } 
# 772 "/usr/include/c++/9/sstream" 3
explicit basic_stringstream(const __string_type &__str, std::ios_base::openmode 
# 773
__m = (std::ios_base::out | std::ios_base::in)) : __iostream_type(), _M_stringbuf(__str, __m) 
# 775
{ this->init(&(_M_stringbuf)); } 
# 783
~basic_stringstream() 
# 784
{ } 
# 787
basic_stringstream(const basic_stringstream &) = delete;
# 789
basic_stringstream(basic_stringstream &&__rhs) : __iostream_type(std::move(__rhs)), _M_stringbuf(std::move(__rhs._M_stringbuf)) 
# 792
{ __iostream_type::set_rdbuf(&(_M_stringbuf)); } 
# 797
basic_stringstream &operator=(const basic_stringstream &) = delete;
# 800
basic_stringstream &operator=(basic_stringstream &&__rhs) 
# 801
{ 
# 802
basic_iostream< _CharT, _Traits> ::operator=(std::move(__rhs)); 
# 803
(_M_stringbuf) = std::move(__rhs._M_stringbuf); 
# 804
return *this; 
# 805
} 
# 808
void swap(basic_stringstream &__rhs) 
# 809
{ 
# 810
__iostream_type::swap(__rhs); 
# 811
(_M_stringbuf).swap(__rhs._M_stringbuf); 
# 812
} 
# 823 "/usr/include/c++/9/sstream" 3
__stringbuf_type *rdbuf() const 
# 824
{ return const_cast< __stringbuf_type *>(&(_M_stringbuf)); } 
# 831
__string_type str() const 
# 832
{ return (_M_stringbuf).str(); } 
# 841
void str(const __string_type &__s) 
# 842
{ (_M_stringbuf).str(__s); } 
# 843
}; 
# 847
template< class _CharT, class _Traits, class _Allocator> inline void 
# 849
swap(basic_stringbuf< _CharT, _Traits, _Allocator>  &__x, basic_stringbuf< _CharT, _Traits, _Allocator>  &
# 850
__y) 
# 851
{ __x.swap(__y); } 
# 854
template< class _CharT, class _Traits, class _Allocator> inline void 
# 856
swap(basic_istringstream< _CharT, _Traits, _Allocator>  &__x, basic_istringstream< _CharT, _Traits, _Allocator>  &
# 857
__y) 
# 858
{ __x.swap(__y); } 
# 861
template< class _CharT, class _Traits, class _Allocator> inline void 
# 863
swap(basic_ostringstream< _CharT, _Traits, _Allocator>  &__x, basic_ostringstream< _CharT, _Traits, _Allocator>  &
# 864
__y) 
# 865
{ __x.swap(__y); } 
# 868
template< class _CharT, class _Traits, class _Allocator> inline void 
# 870
swap(basic_stringstream< _CharT, _Traits, _Allocator>  &__x, basic_stringstream< _CharT, _Traits, _Allocator>  &
# 871
__y) 
# 872
{ __x.swap(__y); } 
# 875
}
# 877
}
# 39 "/usr/include/c++/9/bits/sstream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::int_type 
# 46
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::pbackfail(int_type __c) 
# 47
{ 
# 48
int_type __ret = traits_type::eof(); 
# 49
if (this->eback() < this->gptr()) 
# 50
{ 
# 53
const bool __testeof = traits_type::eq_int_type(__c, __ret); 
# 54
if (!__testeof) 
# 55
{ 
# 56
const bool __testeq = traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]); 
# 59
const bool __testout = ((this->_M_mode) & std::ios_base::out); 
# 60
if (__testeq || __testout) 
# 61
{ 
# 62
this->gbump(-1); 
# 63
if (!__testeq) { 
# 64
(*this->gptr()) = traits_type::to_char_type(__c); }  
# 65
__ret = __c; 
# 66
}  
# 67
} else 
# 69
{ 
# 70
this->gbump(-1); 
# 71
__ret = traits_type::not_eof(__c); 
# 72
}  
# 73
}  
# 74
return __ret; 
# 75
} 
# 77
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::int_type 
# 80
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::overflow(int_type __c) 
# 81
{ 
# 82
const bool __testout = ((this->_M_mode) & std::ios_base::out); 
# 83
if (__builtin_expect(!__testout, false)) { 
# 84
return traits_type::eof(); }  
# 86
const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof()); 
# 87
if (__builtin_expect(__testeof, false)) { 
# 88
return traits_type::not_eof(__c); }  
# 90
const __size_type __capacity = (_M_string).capacity(); 
# 93
if ((this->epptr() - this->pbase()) < __capacity) 
# 94
{ 
# 96
char_type *__base = const_cast< char_type *>((_M_string).data()); 
# 97
_M_pbump(__base, __base + __capacity, this->pptr() - this->pbase()); 
# 98
if (((_M_mode) & std::ios_base::in)) 
# 99
{ 
# 100
const __size_type __nget = this->gptr() - this->eback(); 
# 101
const __size_type __eget = this->egptr() - this->eback(); 
# 102
this->setg(__base, __base + __nget, (__base + __eget) + 1); 
# 103
}  
# 104
(*this->pptr()) = traits_type::to_char_type(__c); 
# 105
this->pbump(1); 
# 106
return __c; 
# 107
}  
# 110
const __size_type __max_size = (_M_string).max_size(); 
# 111
const bool __testput = this->pptr() < this->epptr(); 
# 112
if (__builtin_expect((!__testput) && (__capacity == __max_size), false)) { 
# 113
return traits_type::eof(); }  
# 117
const char_type __conv = traits_type::to_char_type(__c); 
# 118
if (!__testput) 
# 119
{ 
# 129 "/usr/include/c++/9/bits/sstream.tcc" 3
const __size_type __opt_len = std::max((__size_type)(2 * __capacity), (__size_type)512); 
# 131
const __size_type __len = std::min(__opt_len, __max_size); 
# 132
__string_type __tmp((_M_string).get_allocator()); 
# 133
__tmp.reserve(__len); 
# 134
if (this->pbase()) { 
# 135
__tmp.assign(this->pbase(), this->epptr() - this->pbase()); }  
# 136
__tmp.push_back(__conv); 
# 137
(_M_string).swap(__tmp); 
# 138
_M_sync(const_cast< char_type *>((_M_string).data()), this->gptr() - this->eback(), this->pptr() - this->pbase()); 
# 140
} else { 
# 142
(*this->pptr()) = __conv; }  
# 143
this->pbump(1); 
# 144
return __c; 
# 145
} 
# 147
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::int_type 
# 150
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::underflow() 
# 151
{ 
# 152
int_type __ret = traits_type::eof(); 
# 153
const bool __testin = ((this->_M_mode) & std::ios_base::in); 
# 154
if (__testin) 
# 155
{ 
# 157
_M_update_egptr(); 
# 159
if (this->gptr() < this->egptr()) { 
# 160
__ret = traits_type::to_int_type(*this->gptr()); }  
# 161
}  
# 162
return __ret; 
# 163
} 
# 165
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::pos_type 
# 168
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::seekoff(off_type __off, std::ios_base::seekdir __way, std::ios_base::openmode __mode) 
# 169
{ 
# 170
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 171
bool __testin = ((((std::ios_base::in & (this->_M_mode))) & __mode)) != 0; 
# 172
bool __testout = ((((std::ios_base::out & (this->_M_mode))) & __mode)) != 0; 
# 173
const bool __testboth = __testin && __testout && (__way != std::ios_base::cur); 
# 174
__testin &= (!((__mode & std::ios_base::out))); 
# 175
__testout &= (!((__mode & std::ios_base::in))); 
# 179
const char_type *__beg = __testin ? this->eback() : this->pbase(); 
# 180
if ((__beg || (!__off)) && ((__testin || __testout) || __testboth)) 
# 181
{ 
# 182
_M_update_egptr(); 
# 184
off_type __newoffi = __off; 
# 185
off_type __newoffo = __newoffi; 
# 186
if (__way == std::ios_base::cur) 
# 187
{ 
# 188
__newoffi += (this->gptr() - __beg); 
# 189
__newoffo += (this->pptr() - __beg); 
# 190
} else { 
# 191
if (__way == std::ios_base::end) { 
# 192
__newoffo = (__newoffi += (this->egptr() - __beg)); }  }  
# 194
if ((__testin || __testboth) && (__newoffi >= 0) && ((this->egptr() - __beg) >= __newoffi)) 
# 197
{ 
# 198
this->setg(this->eback(), this->eback() + __newoffi, this->egptr()); 
# 200
__ret = ((pos_type)__newoffi); 
# 201
}  
# 202
if ((__testout || __testboth) && (__newoffo >= 0) && ((this->egptr() - __beg) >= __newoffo)) 
# 205
{ 
# 206
_M_pbump(this->pbase(), this->epptr(), __newoffo); 
# 207
__ret = ((pos_type)__newoffo); 
# 208
}  
# 209
}  
# 210
return __ret; 
# 211
} 
# 213
template< class _CharT, class _Traits, class _Alloc> typename __cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::pos_type 
# 216
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::seekpos(pos_type __sp, std::ios_base::openmode __mode) 
# 217
{ 
# 218
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 219
const bool __testin = ((((std::ios_base::in & (this->_M_mode))) & __mode)) != 0; 
# 220
const bool __testout = ((((std::ios_base::out & (this->_M_mode))) & __mode)) != 0; 
# 222
const char_type *__beg = __testin ? this->eback() : this->pbase(); 
# 223
if ((__beg || (!((off_type)__sp))) && (__testin || __testout)) 
# 224
{ 
# 225
_M_update_egptr(); 
# 227
const off_type __pos(__sp); 
# 228
const bool __testpos = (0 <= __pos) && (__pos <= (this->egptr() - __beg)); 
# 230
if (__testpos) 
# 231
{ 
# 232
if (__testin) { 
# 233
this->setg(this->eback(), this->eback() + __pos, this->egptr()); }  
# 235
if (__testout) { 
# 236
_M_pbump(this->pbase(), this->epptr(), __pos); }  
# 237
__ret = __sp; 
# 238
}  
# 239
}  
# 240
return __ret; 
# 241
} 
# 243
template< class _CharT, class _Traits, class _Alloc> void 
# 246
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::_M_sync(char_type *__base, __size_type __i, __size_type __o) 
# 247
{ 
# 248
const bool __testin = ((_M_mode) & std::ios_base::in); 
# 249
const bool __testout = ((_M_mode) & std::ios_base::out); 
# 250
char_type *__endg = __base + (_M_string).size(); 
# 251
char_type *__endp = __base + (_M_string).capacity(); 
# 253
if (__base != (_M_string).data()) 
# 254
{ 
# 256
__endg += __i; 
# 257
__i = 0; 
# 258
__endp = __endg; 
# 259
}  
# 261
if (__testin) { 
# 262
this->setg(__base, __base + __i, __endg); }  
# 263
if (__testout) 
# 264
{ 
# 265
_M_pbump(__base, __endp, __o); 
# 269
if (!__testin) { 
# 270
this->setg(__endg, __endg, __endg); }  
# 271
}  
# 272
} 
# 274
template< class _CharT, class _Traits, class _Alloc> void 
# 277
__cxx11::basic_stringbuf< _CharT, _Traits, _Alloc> ::_M_pbump(char_type *__pbeg, char_type *__pend, off_type __off) 
# 278
{ 
# 279
this->setp(__pbeg, __pend); 
# 280
while (__off > __gnu_cxx::__numeric_traits< int> ::__max) 
# 281
{ 
# 282
this->pbump(__gnu_cxx::__numeric_traits< int> ::__max); 
# 283
__off -= __gnu_cxx::__numeric_traits< int> ::__max; 
# 284
}  
# 285
this->pbump(__off); 
# 286
} 
# 291
extern template class __cxx11::basic_stringbuf< char> ;
# 292
extern template class __cxx11::basic_istringstream< char> ;
# 293
extern template class __cxx11::basic_ostringstream< char> ;
# 294
extern template class __cxx11::basic_stringstream< char> ;
# 297
extern template class __cxx11::basic_stringbuf< wchar_t> ;
# 298
extern template class __cxx11::basic_istringstream< wchar_t> ;
# 299
extern template class __cxx11::basic_ostringstream< wchar_t> ;
# 300
extern template class __cxx11::basic_stringstream< wchar_t> ;
# 305
}
# 54 "/usr/include/c++/9/complex" 3
namespace std __attribute((__visibility__("default"))) { 
# 67 "/usr/include/c++/9/complex" 3
template< class _Tp> struct complex; 
# 68
template<> struct complex< float> ; 
# 69
template<> struct complex< double> ; 
# 70
template<> struct complex< long double> ; 
# 73
template< class _Tp> inline _Tp abs(const complex< _Tp>  &); 
# 75
template< class _Tp> inline _Tp arg(const complex< _Tp>  &); 
# 77
template< class _Tp> inline _Tp norm(const complex< _Tp>  &); 
# 80
template< class _Tp> inline complex< _Tp>  conj(const complex< _Tp>  &); 
# 83
template< class _Tp> inline complex< _Tp>  polar(const _Tp &, const _Tp & = 0); 
# 87
template< class _Tp> inline complex< _Tp>  cos(const complex< _Tp>  &); 
# 89
template< class _Tp> inline complex< _Tp>  cosh(const complex< _Tp>  &); 
# 91
template< class _Tp> inline complex< _Tp>  exp(const complex< _Tp>  &); 
# 93
template< class _Tp> inline complex< _Tp>  log(const complex< _Tp>  &); 
# 95
template< class _Tp> inline complex< _Tp>  log10(const complex< _Tp>  &); 
# 97
template< class _Tp> inline complex< _Tp>  pow(const complex< _Tp>  &, int); 
# 99
template< class _Tp> complex< _Tp>  pow(const complex< _Tp>  &, const _Tp &); 
# 101
template< class _Tp> inline complex< _Tp>  pow(const complex< _Tp>  &, const complex< _Tp>  &); 
# 104
template< class _Tp> inline complex< _Tp>  pow(const _Tp &, const complex< _Tp>  &); 
# 106
template< class _Tp> inline complex< _Tp>  sin(const complex< _Tp>  &); 
# 108
template< class _Tp> inline complex< _Tp>  sinh(const complex< _Tp>  &); 
# 110
template< class _Tp> inline complex< _Tp>  sqrt(const complex< _Tp>  &); 
# 112
template< class _Tp> inline complex< _Tp>  tan(const complex< _Tp>  &); 
# 114
template< class _Tp> inline complex< _Tp>  tanh(const complex< _Tp>  &); 
# 126 "/usr/include/c++/9/complex" 3
template< class _Tp> 
# 127
struct complex { 
# 130
typedef _Tp value_type; 
# 134
constexpr complex(const _Tp &__r = _Tp(), const _Tp &__i = _Tp()) : _M_real(__r), _M_imag(__i) 
# 135
{ } 
# 139
constexpr complex(const complex &) = default;
# 143
template< class _Up> constexpr 
# 144
complex(const complex< _Up>  &__z) : _M_real(__z.real()), _M_imag(__z.imag()) 
# 145
{ } 
# 150
__attribute((__abi_tag__("cxx11"))) constexpr _Tp 
# 152
real() const { return _M_real; } 
# 154
__attribute((__abi_tag__("cxx11"))) constexpr _Tp 
# 156
imag() const { return _M_imag; } 
# 178 "/usr/include/c++/9/complex" 3
void real(_Tp __val) { (_M_real) = __val; } 
# 181
void imag(_Tp __val) { (_M_imag) = __val; } 
# 184
complex &operator=(const _Tp &); 
# 189
complex &operator+=(const _Tp &__t) 
# 190
{ 
# 191
(_M_real) += __t; 
# 192
return *this; 
# 193
} 
# 198
complex &operator-=(const _Tp &__t) 
# 199
{ 
# 200
(_M_real) -= __t; 
# 201
return *this; 
# 202
} 
# 205
complex &operator*=(const _Tp &); 
# 207
complex &operator/=(const _Tp &); 
# 211
complex &operator=(const complex &) = default;
# 215
template< class _Up> complex &operator=(const complex< _Up>  &); 
# 218
template< class _Up> complex &operator+=(const complex< _Up>  &); 
# 221
template< class _Up> complex &operator-=(const complex< _Up>  &); 
# 224
template< class _Up> complex &operator*=(const complex< _Up>  &); 
# 227
template< class _Up> complex &operator/=(const complex< _Up>  &); 
# 230
constexpr complex __rep() const 
# 231
{ return *this; } 
# 234
private: _Tp _M_real; 
# 235
_Tp _M_imag; 
# 236
}; 
# 238
template< class _Tp> complex< _Tp>  &
# 240
complex< _Tp> ::operator=(const _Tp &__t) 
# 241
{ 
# 242
(_M_real) = __t; 
# 243
(_M_imag) = _Tp(); 
# 244
return *this; 
# 245
} 
# 248
template< class _Tp> complex< _Tp>  &
# 250
complex< _Tp> ::operator*=(const _Tp &__t) 
# 251
{ 
# 252
(_M_real) *= __t; 
# 253
(_M_imag) *= __t; 
# 254
return *this; 
# 255
} 
# 258
template< class _Tp> complex< _Tp>  &
# 260
complex< _Tp> ::operator/=(const _Tp &__t) 
# 261
{ 
# 262
(_M_real) /= __t; 
# 263
(_M_imag) /= __t; 
# 264
return *this; 
# 265
} 
# 267
template< class _Tp> 
# 268
template< class _Up> complex< _Tp>  &
# 270
complex< _Tp> ::operator=(const complex< _Up>  &__z) 
# 271
{ 
# 272
(_M_real) = __z.real(); 
# 273
(_M_imag) = __z.imag(); 
# 274
return *this; 
# 275
} 
# 278
template< class _Tp> 
# 279
template< class _Up> complex< _Tp>  &
# 281
complex< _Tp> ::operator+=(const complex< _Up>  &__z) 
# 282
{ 
# 283
(_M_real) += __z.real(); 
# 284
(_M_imag) += __z.imag(); 
# 285
return *this; 
# 286
} 
# 289
template< class _Tp> 
# 290
template< class _Up> complex< _Tp>  &
# 292
complex< _Tp> ::operator-=(const complex< _Up>  &__z) 
# 293
{ 
# 294
(_M_real) -= __z.real(); 
# 295
(_M_imag) -= __z.imag(); 
# 296
return *this; 
# 297
} 
# 301
template< class _Tp> 
# 302
template< class _Up> complex< _Tp>  &
# 304
complex< _Tp> ::operator*=(const complex< _Up>  &__z) 
# 305
{ 
# 306
const _Tp __r = ((_M_real) * __z.real()) - ((_M_imag) * __z.imag()); 
# 307
(_M_imag) = (((_M_real) * __z.imag()) + ((_M_imag) * __z.real())); 
# 308
(_M_real) = __r; 
# 309
return *this; 
# 310
} 
# 314
template< class _Tp> 
# 315
template< class _Up> complex< _Tp>  &
# 317
complex< _Tp> ::operator/=(const complex< _Up>  &__z) 
# 318
{ 
# 319
const _Tp __r = ((_M_real) * __z.real()) + ((_M_imag) * __z.imag()); 
# 320
const _Tp __n = std::norm(__z); 
# 321
(_M_imag) = ((((_M_imag) * __z.real()) - ((_M_real) * __z.imag())) / __n); 
# 322
(_M_real) = (__r / __n); 
# 323
return *this; 
# 324
} 
# 329
template< class _Tp> inline complex< _Tp>  
# 331
operator+(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 332
{ 
# 333
complex< _Tp>  __r = __x; 
# 334
__r += __y; 
# 335
return __r; 
# 336
} 
# 338
template< class _Tp> inline complex< _Tp>  
# 340
operator+(const complex< _Tp>  &__x, const _Tp &__y) 
# 341
{ 
# 342
complex< _Tp>  __r = __x; 
# 343
__r += __y; 
# 344
return __r; 
# 345
} 
# 347
template< class _Tp> inline complex< _Tp>  
# 349
operator+(const _Tp &__x, const complex< _Tp>  &__y) 
# 350
{ 
# 351
complex< _Tp>  __r = __y; 
# 352
__r += __x; 
# 353
return __r; 
# 354
} 
# 359
template< class _Tp> inline complex< _Tp>  
# 361
operator-(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 362
{ 
# 363
complex< _Tp>  __r = __x; 
# 364
__r -= __y; 
# 365
return __r; 
# 366
} 
# 368
template< class _Tp> inline complex< _Tp>  
# 370
operator-(const complex< _Tp>  &__x, const _Tp &__y) 
# 371
{ 
# 372
complex< _Tp>  __r = __x; 
# 373
__r -= __y; 
# 374
return __r; 
# 375
} 
# 377
template< class _Tp> inline complex< _Tp>  
# 379
operator-(const _Tp &__x, const complex< _Tp>  &__y) 
# 380
{ 
# 381
complex< _Tp>  __r = -__y; 
# 382
__r += __x; 
# 383
return __r; 
# 384
} 
# 389
template< class _Tp> inline complex< _Tp>  
# 391
operator*(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 392
{ 
# 393
complex< _Tp>  __r = __x; 
# 394
__r *= __y; 
# 395
return __r; 
# 396
} 
# 398
template< class _Tp> inline complex< _Tp>  
# 400
operator*(const complex< _Tp>  &__x, const _Tp &__y) 
# 401
{ 
# 402
complex< _Tp>  __r = __x; 
# 403
__r *= __y; 
# 404
return __r; 
# 405
} 
# 407
template< class _Tp> inline complex< _Tp>  
# 409
operator*(const _Tp &__x, const complex< _Tp>  &__y) 
# 410
{ 
# 411
complex< _Tp>  __r = __y; 
# 412
__r *= __x; 
# 413
return __r; 
# 414
} 
# 419
template< class _Tp> inline complex< _Tp>  
# 421
operator/(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 422
{ 
# 423
complex< _Tp>  __r = __x; 
# 424
__r /= __y; 
# 425
return __r; 
# 426
} 
# 428
template< class _Tp> inline complex< _Tp>  
# 430
operator/(const complex< _Tp>  &__x, const _Tp &__y) 
# 431
{ 
# 432
complex< _Tp>  __r = __x; 
# 433
__r /= __y; 
# 434
return __r; 
# 435
} 
# 437
template< class _Tp> inline complex< _Tp>  
# 439
operator/(const _Tp &__x, const complex< _Tp>  &__y) 
# 440
{ 
# 441
complex< _Tp>  __r = __x; 
# 442
__r /= __y; 
# 443
return __r; 
# 444
} 
# 448
template< class _Tp> inline complex< _Tp>  
# 450
operator+(const complex< _Tp>  &__x) 
# 451
{ return __x; } 
# 454
template< class _Tp> inline complex< _Tp>  
# 456
operator-(const complex< _Tp>  &__x) 
# 457
{ return complex< _Tp> (-__x.real(), -__x.imag()); } 
# 461
template< class _Tp> constexpr bool 
# 463
operator==(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 464
{ return (__x.real() == __y.real()) && (__x.imag() == __y.imag()); } 
# 466
template< class _Tp> constexpr bool 
# 468
operator==(const complex< _Tp>  &__x, const _Tp &__y) 
# 469
{ return (__x.real() == __y) && (__x.imag() == _Tp()); } 
# 471
template< class _Tp> constexpr bool 
# 473
operator==(const _Tp &__x, const complex< _Tp>  &__y) 
# 474
{ return (__x == __y.real()) && (_Tp() == __y.imag()); } 
# 479
template< class _Tp> constexpr bool 
# 481
operator!=(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 482
{ return (__x.real() != __y.real()) || (__x.imag() != __y.imag()); } 
# 484
template< class _Tp> constexpr bool 
# 486
operator!=(const complex< _Tp>  &__x, const _Tp &__y) 
# 487
{ return (__x.real() != __y) || (__x.imag() != _Tp()); } 
# 489
template< class _Tp> constexpr bool 
# 491
operator!=(const _Tp &__x, const complex< _Tp>  &__y) 
# 492
{ return (__x != __y.real()) || (_Tp() != __y.imag()); } 
# 496
template< class _Tp, class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 498
operator>>(basic_istream< _CharT, _Traits>  &__is, complex< _Tp>  &__x) 
# 499
{ 
# 500
bool __fail = true; 
# 501
_CharT __ch; 
# 502
if (__is >> __ch) 
# 503
{ 
# 504
if (_Traits::eq(__ch, __is.widen('('))) 
# 505
{ 
# 506
_Tp __u; 
# 507
if ((__is >> __u) >> __ch) 
# 508
{ 
# 509
const _CharT __rparen = __is.widen(')'); 
# 510
if (_Traits::eq(__ch, __rparen)) 
# 511
{ 
# 512
__x = __u; 
# 513
__fail = false; 
# 514
} else { 
# 515
if (_Traits::eq(__ch, __is.widen(','))) 
# 516
{ 
# 517
_Tp __v; 
# 518
if ((__is >> __v) >> __ch) 
# 519
{ 
# 520
if (_Traits::eq(__ch, __rparen)) 
# 521
{ 
# 522
__x = complex< _Tp> (__u, __v); 
# 523
__fail = false; 
# 524
} else { 
# 526
__is.putback(__ch); }  
# 527
}  
# 528
} else { 
# 530
__is.putback(__ch); }  }  
# 531
}  
# 532
} else 
# 534
{ 
# 535
__is.putback(__ch); 
# 536
_Tp __u; 
# 537
if (__is >> __u) 
# 538
{ 
# 539
__x = __u; 
# 540
__fail = false; 
# 541
}  
# 542
}  
# 543
}  
# 544
if (__fail) { 
# 545
__is.setstate(ios_base::failbit); }  
# 546
return __is; 
# 547
} 
# 550
template< class _Tp, class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 552
operator<<(basic_ostream< _CharT, _Traits>  &__os, const complex< _Tp>  &__x) 
# 553
{ 
# 554
__cxx11::basic_ostringstream< _CharT, _Traits>  __s; 
# 555
__s.flags(__os.flags()); 
# 556
__s.imbue(__os.getloc()); 
# 557
__s.precision(__os.precision()); 
# 558
((((__s << '(') << __x.real()) << ',') << __x.imag()) << ')'; 
# 559
return __os << __s.str(); 
# 560
} 
# 564
template< class _Tp> constexpr _Tp 
# 566
real(const complex< _Tp>  &__z) 
# 567
{ return __z.real(); } 
# 569
template< class _Tp> constexpr _Tp 
# 571
imag(const complex< _Tp>  &__z) 
# 572
{ return __z.imag(); } 
# 596 "/usr/include/c++/9/complex" 3
template< class _Tp> inline _Tp 
# 598
__complex_abs(const complex< _Tp>  &__z) 
# 599
{ 
# 600
_Tp __x = __z.real(); 
# 601
_Tp __y = __z.imag(); 
# 602
const _Tp __s = std::max(abs(__x), abs(__y)); 
# 603
if (__s == _Tp()) { 
# 604
return __s; }  
# 605
__x /= __s; 
# 606
__y /= __s; 
# 607
return __s * sqrt((__x * __x) + (__y * __y)); 
# 608
} 
# 612
inline float __complex_abs(float __complex__ __z) { return __builtin_cabsf(__z); } 
# 615
inline double __complex_abs(double __complex__ __z) { return __builtin_cabs(__z); } 
# 618
inline long double __complex_abs(const long double __complex__ &__z) 
# 619
{ return __builtin_cabsl(__z); } 
# 621
template< class _Tp> inline _Tp 
# 623
abs(const complex< _Tp>  &__z) { return __complex_abs(__z.__rep()); } 
# 632 "/usr/include/c++/9/complex" 3
template< class _Tp> inline _Tp 
# 634
__complex_arg(const complex< _Tp>  &__z) 
# 635
{ return atan2(__z.imag(), __z.real()); } 
# 639
inline float __complex_arg(float __complex__ __z) { return __builtin_cargf(__z); } 
# 642
inline double __complex_arg(double __complex__ __z) { return __builtin_carg(__z); } 
# 645
inline long double __complex_arg(const long double __complex__ &__z) 
# 646
{ return __builtin_cargl(__z); } 
# 648
template< class _Tp> inline _Tp 
# 650
arg(const complex< _Tp>  &__z) { return __complex_arg(__z.__rep()); } 
# 662 "/usr/include/c++/9/complex" 3
template< bool > 
# 663
struct _Norm_helper { 
# 665
template< class _Tp> static _Tp 
# 666
_S_do_it(const complex< _Tp>  &__z) 
# 667
{ 
# 668
const _Tp __x = __z.real(); 
# 669
const _Tp __y = __z.imag(); 
# 670
return (__x * __x) + (__y * __y); 
# 671
} 
# 672
}; 
# 675
template<> struct _Norm_helper< true>  { 
# 677
template< class _Tp> static _Tp 
# 678
_S_do_it(const complex< _Tp>  &__z) 
# 679
{ 
# 682
const _Tp __x = __z.real(); 
# 683
const _Tp __y = __z.imag(); 
# 684
return (__x * __x) + (__y * __y); 
# 685
} 
# 686
}; 
# 688
template< class _Tp> inline _Tp 
# 690
norm(const complex< _Tp>  &__z) 
# 691
{ 
# 692
return _Norm_helper< __is_floating< _Tp> ::__value && (!(0))> ::_S_do_it(__z); 
# 694
} 
# 696
template< class _Tp> inline complex< _Tp>  
# 698
polar(const _Tp &__rho, const _Tp &__theta) 
# 699
{ 
# 700
; 
# 701
return complex< _Tp> (__rho * cos(__theta), __rho * sin(__theta)); 
# 702
} 
# 704
template< class _Tp> inline complex< _Tp>  
# 706
conj(const complex< _Tp>  &__z) 
# 707
{ return complex< _Tp> (__z.real(), -__z.imag()); } 
# 712
template< class _Tp> inline complex< _Tp>  
# 714
__complex_cos(const complex< _Tp>  &__z) 
# 715
{ 
# 716
const _Tp __x = __z.real(); 
# 717
const _Tp __y = __z.imag(); 
# 718
return complex< _Tp> (cos(__x) * cosh(__y), (-sin(__x)) * sinh(__y)); 
# 719
} 
# 723
inline float __complex__ __complex_cos(float __complex__ __z) { return __builtin_ccosf(__z); } 
# 726
inline double __complex__ __complex_cos(double __complex__ __z) { return __builtin_ccos(__z); } 
# 729
inline long double __complex__ __complex_cos(const long double __complex__ &__z) 
# 730
{ return __builtin_ccosl(__z); } 
# 732
template< class _Tp> inline complex< _Tp>  
# 734
cos(const complex< _Tp>  &__z) { return __complex_cos(__z.__rep()); } 
# 742
template< class _Tp> inline complex< _Tp>  
# 744
__complex_cosh(const complex< _Tp>  &__z) 
# 745
{ 
# 746
const _Tp __x = __z.real(); 
# 747
const _Tp __y = __z.imag(); 
# 748
return complex< _Tp> (cosh(__x) * cos(__y), sinh(__x) * sin(__y)); 
# 749
} 
# 753
inline float __complex__ __complex_cosh(float __complex__ __z) { return __builtin_ccoshf(__z); } 
# 756
inline double __complex__ __complex_cosh(double __complex__ __z) { return __builtin_ccosh(__z); } 
# 759
inline long double __complex__ __complex_cosh(const long double __complex__ &__z) 
# 760
{ return __builtin_ccoshl(__z); } 
# 762
template< class _Tp> inline complex< _Tp>  
# 764
cosh(const complex< _Tp>  &__z) { return __complex_cosh(__z.__rep()); } 
# 772
template< class _Tp> inline complex< _Tp>  
# 774
__complex_exp(const complex< _Tp>  &__z) 
# 775
{ return std::polar< _Tp> (exp(__z.real()), __z.imag()); } 
# 779
inline float __complex__ __complex_exp(float __complex__ __z) { return __builtin_cexpf(__z); } 
# 782
inline double __complex__ __complex_exp(double __complex__ __z) { return __builtin_cexp(__z); } 
# 785
inline long double __complex__ __complex_exp(const long double __complex__ &__z) 
# 786
{ return __builtin_cexpl(__z); } 
# 788
template< class _Tp> inline complex< _Tp>  
# 790
exp(const complex< _Tp>  &__z) { return __complex_exp(__z.__rep()); } 
# 799 "/usr/include/c++/9/complex" 3
template< class _Tp> inline complex< _Tp>  
# 801
__complex_log(const complex< _Tp>  &__z) 
# 802
{ return complex< _Tp> (log(std::abs(__z)), std::arg(__z)); } 
# 806
inline float __complex__ __complex_log(float __complex__ __z) { return __builtin_clogf(__z); } 
# 809
inline double __complex__ __complex_log(double __complex__ __z) { return __builtin_clog(__z); } 
# 812
inline long double __complex__ __complex_log(const long double __complex__ &__z) 
# 813
{ return __builtin_clogl(__z); } 
# 815
template< class _Tp> inline complex< _Tp>  
# 817
log(const complex< _Tp>  &__z) { return __complex_log(__z.__rep()); } 
# 824
template< class _Tp> inline complex< _Tp>  
# 826
log10(const complex< _Tp>  &__z) 
# 827
{ return std::log(__z) / log((_Tp)(10.0)); } 
# 830
template< class _Tp> inline complex< _Tp>  
# 832
__complex_sin(const complex< _Tp>  &__z) 
# 833
{ 
# 834
const _Tp __x = __z.real(); 
# 835
const _Tp __y = __z.imag(); 
# 836
return complex< _Tp> (sin(__x) * cosh(__y), cos(__x) * sinh(__y)); 
# 837
} 
# 841
inline float __complex__ __complex_sin(float __complex__ __z) { return __builtin_csinf(__z); } 
# 844
inline double __complex__ __complex_sin(double __complex__ __z) { return __builtin_csin(__z); } 
# 847
inline long double __complex__ __complex_sin(const long double __complex__ &__z) 
# 848
{ return __builtin_csinl(__z); } 
# 850
template< class _Tp> inline complex< _Tp>  
# 852
sin(const complex< _Tp>  &__z) { return __complex_sin(__z.__rep()); } 
# 860
template< class _Tp> inline complex< _Tp>  
# 862
__complex_sinh(const complex< _Tp>  &__z) 
# 863
{ 
# 864
const _Tp __x = __z.real(); 
# 865
const _Tp __y = __z.imag(); 
# 866
return complex< _Tp> (sinh(__x) * cos(__y), cosh(__x) * sin(__y)); 
# 867
} 
# 871
inline float __complex__ __complex_sinh(float __complex__ __z) { return __builtin_csinhf(__z); } 
# 874
inline double __complex__ __complex_sinh(double __complex__ __z) { return __builtin_csinh(__z); } 
# 877
inline long double __complex__ __complex_sinh(const long double __complex__ &__z) 
# 878
{ return __builtin_csinhl(__z); } 
# 880
template< class _Tp> inline complex< _Tp>  
# 882
sinh(const complex< _Tp>  &__z) { return __complex_sinh(__z.__rep()); } 
# 891 "/usr/include/c++/9/complex" 3
template< class _Tp> complex< _Tp>  
# 893
__complex_sqrt(const complex< _Tp>  &__z) 
# 894
{ 
# 895
_Tp __x = __z.real(); 
# 896
_Tp __y = __z.imag(); 
# 898
if (__x == _Tp()) 
# 899
{ 
# 900
_Tp __t = sqrt(abs(__y) / 2); 
# 901
return complex< _Tp> (__t, (__y < _Tp()) ? -__t : __t); 
# 902
} else 
# 904
{ 
# 905
_Tp __t = sqrt(2 * (std::abs(__z) + abs(__x))); 
# 906
_Tp __u = __t / 2; 
# 907
return (__x > _Tp()) ? complex< _Tp> (__u, __y / __t) : complex< _Tp> (abs(__y) / __t, (__y < _Tp()) ? -__u : __u); 
# 910
}  
# 911
} 
# 915
inline float __complex__ __complex_sqrt(float __complex__ __z) { return __builtin_csqrtf(__z); } 
# 918
inline double __complex__ __complex_sqrt(double __complex__ __z) { return __builtin_csqrt(__z); } 
# 921
inline long double __complex__ __complex_sqrt(const long double __complex__ &__z) 
# 922
{ return __builtin_csqrtl(__z); } 
# 924
template< class _Tp> inline complex< _Tp>  
# 926
sqrt(const complex< _Tp>  &__z) { return __complex_sqrt(__z.__rep()); } 
# 935 "/usr/include/c++/9/complex" 3
template< class _Tp> inline complex< _Tp>  
# 937
__complex_tan(const complex< _Tp>  &__z) 
# 938
{ return std::sin(__z) / std::cos(__z); } 
# 942
inline float __complex__ __complex_tan(float __complex__ __z) { return __builtin_ctanf(__z); } 
# 945
inline double __complex__ __complex_tan(double __complex__ __z) { return __builtin_ctan(__z); } 
# 948
inline long double __complex__ __complex_tan(const long double __complex__ &__z) 
# 949
{ return __builtin_ctanl(__z); } 
# 951
template< class _Tp> inline complex< _Tp>  
# 953
tan(const complex< _Tp>  &__z) { return __complex_tan(__z.__rep()); } 
# 963 "/usr/include/c++/9/complex" 3
template< class _Tp> inline complex< _Tp>  
# 965
__complex_tanh(const complex< _Tp>  &__z) 
# 966
{ return std::sinh(__z) / std::cosh(__z); } 
# 970
inline float __complex__ __complex_tanh(float __complex__ __z) { return __builtin_ctanhf(__z); } 
# 973
inline double __complex__ __complex_tanh(double __complex__ __z) { return __builtin_ctanh(__z); } 
# 976
inline long double __complex__ __complex_tanh(const long double __complex__ &__z) 
# 977
{ return __builtin_ctanhl(__z); } 
# 979
template< class _Tp> inline complex< _Tp>  
# 981
tanh(const complex< _Tp>  &__z) { return __complex_tanh(__z.__rep()); } 
# 992 "/usr/include/c++/9/complex" 3
template< class _Tp> complex< _Tp>  
# 994
__complex_pow_unsigned(complex< _Tp>  __x, unsigned __n) 
# 995
{ 
# 996
complex< _Tp>  __y = (__n % (2)) ? __x : ((complex< _Tp> )(1)); 
# 998
while (__n >>= 1) 
# 999
{ 
# 1000
__x *= __x; 
# 1001
if (__n % (2)) { 
# 1002
__y *= __x; }  
# 1003
}  
# 1005
return __y; 
# 1006
} 
# 1014
template< class _Tp> inline complex< _Tp>  
# 1016
pow(const complex< _Tp>  &__z, int __n) 
# 1017
{ 
# 1018
return (__n < 0) ? ((complex< _Tp> )(1)) / std::__complex_pow_unsigned(__z, -((unsigned)__n)) : std::__complex_pow_unsigned(__z, __n); 
# 1021
} 
# 1023
template< class _Tp> complex< _Tp>  
# 1025
pow(const complex< _Tp>  &__x, const _Tp &__y) 
# 1026
{ 
# 1031
if ((__x.imag() == _Tp()) && (__x.real() > _Tp())) { 
# 1032
return pow(__x.real(), __y); }  
# 1034
complex< _Tp>  __t = std::log(__x); 
# 1035
return std::polar< _Tp> (exp(__y * __t.real()), __y * __t.imag()); 
# 1036
} 
# 1038
template< class _Tp> inline complex< _Tp>  
# 1040
__complex_pow(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 1041
{ return (__x == _Tp()) ? _Tp() : std::exp(__y * std::log(__x)); } 
# 1045
inline float __complex__ __complex_pow(float __complex__ __x, float __complex__ __y) 
# 1046
{ return __builtin_cpowf(__x, __y); } 
# 1049
inline double __complex__ __complex_pow(double __complex__ __x, double __complex__ __y) 
# 1050
{ return __builtin_cpow(__x, __y); } 
# 1053
inline long double __complex__ __complex_pow(const long double __complex__ &__x, const long double __complex__ &
# 1054
__y) 
# 1055
{ return __builtin_cpowl(__x, __y); } 
# 1057
template< class _Tp> inline complex< _Tp>  
# 1059
pow(const complex< _Tp>  &__x, const complex< _Tp>  &__y) 
# 1060
{ return __complex_pow(__x.__rep(), __y.__rep()); } 
# 1068
template< class _Tp> inline complex< _Tp>  
# 1070
pow(const _Tp &__x, const complex< _Tp>  &__y) 
# 1071
{ 
# 1072
return (__x > _Tp()) ? std::polar< _Tp> (pow(__x, __y.real()), __y.imag() * log(__x)) : std::pow(((complex< _Tp> )(__x)), __y); 
# 1075
} 
# 1080
template<> struct complex< float>  { 
# 1082
typedef float value_type; 
# 1083
typedef float __complex__ _ComplexT; 
# 1085
constexpr complex(_ComplexT __z) : _M_value(__z) { } 
# 1087
constexpr complex(float __r = (0.0F), float __i = (0.0F)) : _M_value{__r, __i} 
# 1089
{ } 
# 1097
constexpr explicit complex(const std::complex< double>  &); 
# 1098
constexpr explicit complex(const std::complex< long double>  &); 
# 1103
__attribute((__abi_tag__("cxx11"))) constexpr float 
# 1105
real() const { return __real(_M_value); } 
# 1107
__attribute((__abi_tag__("cxx11"))) constexpr float 
# 1109
imag() const { return __imag(_M_value); } 
# 1127 "/usr/include/c++/9/complex" 3
void real(float __val) { (__real(_M_value)) = __val; } 
# 1130
void imag(float __val) { (__imag(_M_value)) = __val; } 
# 1133
std::complex< float>  &operator=(float __f) 
# 1134
{ 
# 1135
(_M_value) = __f; 
# 1136
return *this; 
# 1137
} 
# 1140
std::complex< float>  &operator+=(float __f) 
# 1141
{ 
# 1142
(_M_value) += __f; 
# 1143
return *this; 
# 1144
} 
# 1147
std::complex< float>  &operator-=(float __f) 
# 1148
{ 
# 1149
(_M_value) -= __f; 
# 1150
return *this; 
# 1151
} 
# 1154
std::complex< float>  &operator*=(float __f) 
# 1155
{ 
# 1156
(_M_value) *= __f; 
# 1157
return *this; 
# 1158
} 
# 1161
std::complex< float>  &operator/=(float __f) 
# 1162
{ 
# 1163
(_M_value) /= __f; 
# 1164
return *this; 
# 1165
} 
# 1170
constexpr std::complex< float>  &operator=(const std::complex< float>  &) = default;
# 1173
template< class _Tp> std::complex< float>  &
# 1175
operator=(const std::complex< _Tp>  &__z) 
# 1176
{ 
# 1177
(__real(_M_value)) = __z.real(); 
# 1178
(__imag(_M_value)) = __z.imag(); 
# 1179
return *this; 
# 1180
} 
# 1182
template< class _Tp> std::complex< float>  &
# 1184
operator+=(const std::complex< _Tp>  &__z) 
# 1185
{ 
# 1186
(_M_value) += __z.__rep(); 
# 1187
return *this; 
# 1188
} 
# 1190
template< class _Tp> std::complex< float>  &
# 1192
operator-=(const std::complex< _Tp>  &__z) 
# 1193
{ 
# 1194
(_M_value) -= __z.__rep(); 
# 1195
return *this; 
# 1196
} 
# 1198
template< class _Tp> std::complex< float>  &
# 1200
operator*=(const std::complex< _Tp>  &__z) 
# 1201
{ 
# 1202
const _ComplexT __t = __z.__rep(); 
# 1203
(_M_value) *= __t; 
# 1204
return *this; 
# 1205
} 
# 1207
template< class _Tp> std::complex< float>  &
# 1209
operator/=(const std::complex< _Tp>  &__z) 
# 1210
{ 
# 1211
const _ComplexT __t = __z.__rep(); 
# 1212
(_M_value) /= __t; 
# 1213
return *this; 
# 1214
} 
# 1216
constexpr _ComplexT __rep() const { return _M_value; } 
# 1219
private: _ComplexT _M_value; 
# 1220
}; 
# 1225
template<> struct complex< double>  { 
# 1227
typedef double value_type; 
# 1228
typedef double __complex__ _ComplexT; 
# 1230
constexpr complex(_ComplexT __z) : _M_value(__z) { } 
# 1232
constexpr complex(double __r = (0.0), double __i = (0.0)) : _M_value{__r, __i} 
# 1234
{ } 
# 1242
constexpr complex(const std::complex< float>  &__z) : _M_value(__z.__rep()) 
# 1243
{ } 
# 1245
constexpr explicit complex(const std::complex< long double>  &); 
# 1250
__attribute((__abi_tag__("cxx11"))) constexpr double 
# 1252
real() const { return __real(_M_value); } 
# 1254
__attribute((__abi_tag__("cxx11"))) constexpr double 
# 1256
imag() const { return __imag(_M_value); } 
# 1274 "/usr/include/c++/9/complex" 3
void real(double __val) { (__real(_M_value)) = __val; } 
# 1277
void imag(double __val) { (__imag(_M_value)) = __val; } 
# 1280
std::complex< double>  &operator=(double __d) 
# 1281
{ 
# 1282
(_M_value) = __d; 
# 1283
return *this; 
# 1284
} 
# 1287
std::complex< double>  &operator+=(double __d) 
# 1288
{ 
# 1289
(_M_value) += __d; 
# 1290
return *this; 
# 1291
} 
# 1294
std::complex< double>  &operator-=(double __d) 
# 1295
{ 
# 1296
(_M_value) -= __d; 
# 1297
return *this; 
# 1298
} 
# 1301
std::complex< double>  &operator*=(double __d) 
# 1302
{ 
# 1303
(_M_value) *= __d; 
# 1304
return *this; 
# 1305
} 
# 1308
std::complex< double>  &operator/=(double __d) 
# 1309
{ 
# 1310
(_M_value) /= __d; 
# 1311
return *this; 
# 1312
} 
# 1316
constexpr std::complex< double>  &operator=(const std::complex< double>  &) = default;
# 1319
template< class _Tp> std::complex< double>  &
# 1321
operator=(const std::complex< _Tp>  &__z) 
# 1322
{ 
# 1323
(_M_value) = __z.__rep(); 
# 1324
return *this; 
# 1325
} 
# 1327
template< class _Tp> std::complex< double>  &
# 1329
operator+=(const std::complex< _Tp>  &__z) 
# 1330
{ 
# 1331
(_M_value) += __z.__rep(); 
# 1332
return *this; 
# 1333
} 
# 1335
template< class _Tp> std::complex< double>  &
# 1337
operator-=(const std::complex< _Tp>  &__z) 
# 1338
{ 
# 1339
(_M_value) -= __z.__rep(); 
# 1340
return *this; 
# 1341
} 
# 1343
template< class _Tp> std::complex< double>  &
# 1345
operator*=(const std::complex< _Tp>  &__z) 
# 1346
{ 
# 1347
const _ComplexT __t = __z.__rep(); 
# 1348
(_M_value) *= __t; 
# 1349
return *this; 
# 1350
} 
# 1352
template< class _Tp> std::complex< double>  &
# 1354
operator/=(const std::complex< _Tp>  &__z) 
# 1355
{ 
# 1356
const _ComplexT __t = __z.__rep(); 
# 1357
(_M_value) /= __t; 
# 1358
return *this; 
# 1359
} 
# 1361
constexpr _ComplexT __rep() const { return _M_value; } 
# 1364
private: _ComplexT _M_value; 
# 1365
}; 
# 1370
template<> struct complex< long double>  { 
# 1372
typedef long double value_type; 
# 1373
typedef long double __complex__ _ComplexT; 
# 1375
constexpr complex(_ComplexT __z) : _M_value(__z) { } 
# 1377
constexpr complex(long double __r = (0.0L), long double 
# 1378
__i = (0.0L)) : _M_value{__r, __i} 
# 1380
{ } 
# 1388
constexpr complex(const std::complex< float>  &__z) : _M_value(__z.__rep()) 
# 1389
{ } 
# 1391
constexpr complex(const std::complex< double>  &__z) : _M_value(__z.__rep()) 
# 1392
{ } 
# 1397
__attribute((__abi_tag__("cxx11"))) constexpr long double 
# 1399
real() const { return __real(_M_value); } 
# 1401
__attribute((__abi_tag__("cxx11"))) constexpr long double 
# 1403
imag() const { return __imag(_M_value); } 
# 1421 "/usr/include/c++/9/complex" 3
void real(long double __val) { (__real(_M_value)) = __val; } 
# 1424
void imag(long double __val) { (__imag(_M_value)) = __val; } 
# 1427
std::complex< long double>  &operator=(long double __r) 
# 1428
{ 
# 1429
(_M_value) = __r; 
# 1430
return *this; 
# 1431
} 
# 1434
std::complex< long double>  &operator+=(long double __r) 
# 1435
{ 
# 1436
(_M_value) += __r; 
# 1437
return *this; 
# 1438
} 
# 1441
std::complex< long double>  &operator-=(long double __r) 
# 1442
{ 
# 1443
(_M_value) -= __r; 
# 1444
return *this; 
# 1445
} 
# 1448
std::complex< long double>  &operator*=(long double __r) 
# 1449
{ 
# 1450
(_M_value) *= __r; 
# 1451
return *this; 
# 1452
} 
# 1455
std::complex< long double>  &operator/=(long double __r) 
# 1456
{ 
# 1457
(_M_value) /= __r; 
# 1458
return *this; 
# 1459
} 
# 1463
constexpr std::complex< long double>  &operator=(const std::complex< long double>  &) = default;
# 1466
template< class _Tp> std::complex< long double>  &
# 1468
operator=(const std::complex< _Tp>  &__z) 
# 1469
{ 
# 1470
(_M_value) = __z.__rep(); 
# 1471
return *this; 
# 1472
} 
# 1474
template< class _Tp> std::complex< long double>  &
# 1476
operator+=(const std::complex< _Tp>  &__z) 
# 1477
{ 
# 1478
(_M_value) += __z.__rep(); 
# 1479
return *this; 
# 1480
} 
# 1482
template< class _Tp> std::complex< long double>  &
# 1484
operator-=(const std::complex< _Tp>  &__z) 
# 1485
{ 
# 1486
(_M_value) -= __z.__rep(); 
# 1487
return *this; 
# 1488
} 
# 1490
template< class _Tp> std::complex< long double>  &
# 1492
operator*=(const std::complex< _Tp>  &__z) 
# 1493
{ 
# 1494
const _ComplexT __t = __z.__rep(); 
# 1495
(_M_value) *= __t; 
# 1496
return *this; 
# 1497
} 
# 1499
template< class _Tp> std::complex< long double>  &
# 1501
operator/=(const std::complex< _Tp>  &__z) 
# 1502
{ 
# 1503
const _ComplexT __t = __z.__rep(); 
# 1504
(_M_value) /= __t; 
# 1505
return *this; 
# 1506
} 
# 1508
constexpr _ComplexT __rep() const { return _M_value; } 
# 1511
private: _ComplexT _M_value; 
# 1512
}; 
# 1517
constexpr complex< float> ::complex(const std::complex< double>  &__z) : _M_value(__z.__rep()) 
# 1518
{ } 
# 1521
constexpr complex< float> ::complex(const std::complex< long double>  &__z) : _M_value(__z.__rep()) 
# 1522
{ } 
# 1525
constexpr complex< double> ::complex(const std::complex< long double>  &__z) : _M_value(__z.__rep()) 
# 1526
{ } 
# 1532
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, complex< float>  & __x);
# 1533
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, const complex< float>  & __x);
# 1534
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, complex< double>  & __x);
# 1535
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, const complex< double>  & __x);
# 1536
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, complex< long double>  & __x);
# 1537
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, const complex< long double>  & __x);
# 1540
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, complex< float>  & __x);
# 1541
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, const complex< float>  & __x);
# 1542
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, complex< double>  & __x);
# 1543
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, const complex< double>  & __x);
# 1544
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, complex< long double>  & __x);
# 1545
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, const complex< long double>  & __x);
# 1552
}
# 1554
namespace __gnu_cxx __attribute((__visibility__("default"))) { 
# 1559
template< class _Tp, class _Up> 
# 1560
struct __promote_2< std::complex< _Tp> , _Up, typename __promote< std::complex< _Tp> > ::__type, typename __promote< _Up> ::__type>  { 
# 1563
typedef std::complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  __type; 
# 1564
}; 
# 1566
template< class _Tp, class _Up> 
# 1567
struct __promote_2< _Tp, std::complex< _Up> , typename __promote< _Tp> ::__type, typename __promote< std::complex< _Up> > ::__type>  { 
# 1570
typedef std::complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  __type; 
# 1571
}; 
# 1573
template< class _Tp, class _Up> 
# 1574
struct __promote_2< std::complex< _Tp> , std::complex< _Up> , typename __promote< std::complex< _Tp> > ::__type, typename __promote< std::complex< _Up> > ::__type>  { 
# 1577
typedef std::complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  __type; 
# 1578
}; 
# 1581
}
# 1585
namespace std __attribute((__visibility__("default"))) { 
# 1590
template< class _Tp> inline complex< _Tp>  acos(const complex< _Tp>  &); 
# 1591
template< class _Tp> inline complex< _Tp>  asin(const complex< _Tp>  &); 
# 1592
template< class _Tp> inline complex< _Tp>  atan(const complex< _Tp>  &); 
# 1594
template< class _Tp> inline complex< _Tp>  acosh(const complex< _Tp>  &); 
# 1595
template< class _Tp> inline complex< _Tp>  asinh(const complex< _Tp>  &); 
# 1596
template< class _Tp> inline complex< _Tp>  atanh(const complex< _Tp>  &); 
# 1598
template< class _Tp> inline _Tp fabs(const complex< _Tp>  &); 
# 1600
template< class _Tp> inline complex< _Tp>  
# 1602
__complex_acos(const complex< _Tp>  &__z) 
# 1603
{ 
# 1604
const complex< _Tp>  __t = std::asin(__z); 
# 1605
const _Tp __pi_2 = ((1.5707963267948966193L)); 
# 1606
return complex< _Tp> (__pi_2 - __t.real(), -__t.imag()); 
# 1607
} 
# 1611
inline float __complex__ __complex_acos(float __complex__ __z) 
# 1612
{ return __builtin_cacosf(__z); } 
# 1615
inline double __complex__ __complex_acos(double __complex__ __z) 
# 1616
{ return __builtin_cacos(__z); } 
# 1619
inline long double __complex__ __complex_acos(const long double __complex__ &__z) 
# 1620
{ return __builtin_cacosl(__z); } 
# 1622
template< class _Tp> inline complex< _Tp>  
# 1624
acos(const complex< _Tp>  &__z) 
# 1625
{ return __complex_acos(__z.__rep()); } 
# 1636 "/usr/include/c++/9/complex" 3
template< class _Tp> inline complex< _Tp>  
# 1638
__complex_asin(const complex< _Tp>  &__z) 
# 1639
{ 
# 1640
complex< _Tp>  __t(-__z.imag(), __z.real()); 
# 1641
__t = std::asinh(__t); 
# 1642
return complex< _Tp> (__t.imag(), -__t.real()); 
# 1643
} 
# 1647
inline float __complex__ __complex_asin(float __complex__ __z) 
# 1648
{ return __builtin_casinf(__z); } 
# 1651
inline double __complex__ __complex_asin(double __complex__ __z) 
# 1652
{ return __builtin_casin(__z); } 
# 1655
inline long double __complex__ __complex_asin(const long double __complex__ &__z) 
# 1656
{ return __builtin_casinl(__z); } 
# 1658
template< class _Tp> inline complex< _Tp>  
# 1660
asin(const complex< _Tp>  &__z) 
# 1661
{ return __complex_asin(__z.__rep()); } 
# 1672 "/usr/include/c++/9/complex" 3
template< class _Tp> complex< _Tp>  
# 1674
__complex_atan(const complex< _Tp>  &__z) 
# 1675
{ 
# 1676
const _Tp __r2 = __z.real() * __z.real(); 
# 1677
const _Tp __x = (((_Tp)(1.0)) - __r2) - (__z.imag() * __z.imag()); 
# 1679
_Tp __num = __z.imag() + ((_Tp)(1.0)); 
# 1680
_Tp __den = __z.imag() - ((_Tp)(1.0)); 
# 1682
__num = (__r2 + (__num * __num)); 
# 1683
__den = (__r2 + (__den * __den)); 
# 1685
return complex< _Tp> (((_Tp)(0.5)) * atan2(((_Tp)(2.0)) * __z.real(), __x), ((_Tp)(0.25)) * log(__num / __den)); 
# 1687
} 
# 1691
inline float __complex__ __complex_atan(float __complex__ __z) 
# 1692
{ return __builtin_catanf(__z); } 
# 1695
inline double __complex__ __complex_atan(double __complex__ __z) 
# 1696
{ return __builtin_catan(__z); } 
# 1699
inline long double __complex__ __complex_atan(const long double __complex__ &__z) 
# 1700
{ return __builtin_catanl(__z); } 
# 1702
template< class _Tp> inline complex< _Tp>  
# 1704
atan(const complex< _Tp>  &__z) 
# 1705
{ return __complex_atan(__z.__rep()); } 
# 1716 "/usr/include/c++/9/complex" 3
template< class _Tp> complex< _Tp>  
# 1718
__complex_acosh(const complex< _Tp>  &__z) 
# 1719
{ 
# 1721
return ((_Tp)(2.0)) * std::log(std::sqrt(((_Tp)(0.5)) * (__z + ((_Tp)(1.0)))) + std::sqrt(((_Tp)(0.5)) * (__z - ((_Tp)(1.0))))); 
# 1723
} 
# 1727
inline float __complex__ __complex_acosh(float __complex__ __z) 
# 1728
{ return __builtin_cacoshf(__z); } 
# 1731
inline double __complex__ __complex_acosh(double __complex__ __z) 
# 1732
{ return __builtin_cacosh(__z); } 
# 1735
inline long double __complex__ __complex_acosh(const long double __complex__ &__z) 
# 1736
{ return __builtin_cacoshl(__z); } 
# 1738
template< class _Tp> inline complex< _Tp>  
# 1740
acosh(const complex< _Tp>  &__z) 
# 1741
{ return __complex_acosh(__z.__rep()); } 
# 1752 "/usr/include/c++/9/complex" 3
template< class _Tp> complex< _Tp>  
# 1754
__complex_asinh(const complex< _Tp>  &__z) 
# 1755
{ 
# 1756
complex< _Tp>  __t(((__z.real() - __z.imag()) * (__z.real() + __z.imag())) + ((_Tp)(1.0)), (((_Tp)(2.0)) * __z.real()) * __z.imag()); 
# 1759
__t = std::sqrt(__t); 
# 1761
return std::log(__t + __z); 
# 1762
} 
# 1766
inline float __complex__ __complex_asinh(float __complex__ __z) 
# 1767
{ return __builtin_casinhf(__z); } 
# 1770
inline double __complex__ __complex_asinh(double __complex__ __z) 
# 1771
{ return __builtin_casinh(__z); } 
# 1774
inline long double __complex__ __complex_asinh(const long double __complex__ &__z) 
# 1775
{ return __builtin_casinhl(__z); } 
# 1777
template< class _Tp> inline complex< _Tp>  
# 1779
asinh(const complex< _Tp>  &__z) 
# 1780
{ return __complex_asinh(__z.__rep()); } 
# 1791 "/usr/include/c++/9/complex" 3
template< class _Tp> complex< _Tp>  
# 1793
__complex_atanh(const complex< _Tp>  &__z) 
# 1794
{ 
# 1795
const _Tp __i2 = __z.imag() * __z.imag(); 
# 1796
const _Tp __x = (((_Tp)(1.0)) - __i2) - (__z.real() * __z.real()); 
# 1798
_Tp __num = ((_Tp)(1.0)) + __z.real(); 
# 1799
_Tp __den = ((_Tp)(1.0)) - __z.real(); 
# 1801
__num = (__i2 + (__num * __num)); 
# 1802
__den = (__i2 + (__den * __den)); 
# 1804
return complex< _Tp> (((_Tp)(0.25)) * (log(__num) - log(__den)), ((_Tp)(0.5)) * atan2(((_Tp)(2.0)) * __z.imag(), __x)); 
# 1806
} 
# 1810
inline float __complex__ __complex_atanh(float __complex__ __z) 
# 1811
{ return __builtin_catanhf(__z); } 
# 1814
inline double __complex__ __complex_atanh(double __complex__ __z) 
# 1815
{ return __builtin_catanh(__z); } 
# 1818
inline long double __complex__ __complex_atanh(const long double __complex__ &__z) 
# 1819
{ return __builtin_catanhl(__z); } 
# 1821
template< class _Tp> inline complex< _Tp>  
# 1823
atanh(const complex< _Tp>  &__z) 
# 1824
{ return __complex_atanh(__z.__rep()); } 
# 1835 "/usr/include/c++/9/complex" 3
template< class _Tp> inline _Tp 
# 1840
fabs(const complex< _Tp>  &__z) 
# 1841
{ return std::abs(__z); } 
# 1844
template< class _Tp> inline typename __gnu_cxx::__promote< _Tp> ::__type 
# 1846
arg(_Tp __x) 
# 1847
{ 
# 1848
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 1850
return (std::signbit(__x)) ? (__type)(3.1415926535897932385L) : __type(); 
# 1855
} 
# 1857
template< class _Tp> constexpr typename __gnu_cxx::__promote< _Tp> ::__type 
# 1859
imag(_Tp) 
# 1860
{ return _Tp(); } 
# 1862
template< class _Tp> inline typename __gnu_cxx::__promote< _Tp> ::__type 
# 1864
norm(_Tp __x) 
# 1865
{ 
# 1866
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 1867
return ((__type)__x) * ((__type)__x); 
# 1868
} 
# 1870
template< class _Tp> constexpr typename __gnu_cxx::__promote< _Tp> ::__type 
# 1872
real(_Tp __x) 
# 1873
{ return __x; } 
# 1875
template< class _Tp, class _Up> inline complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  
# 1877
pow(const complex< _Tp>  &__x, const _Up &__y) 
# 1878
{ 
# 1879
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1880
return std::pow(((complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type> )(__x)), (__type)__y); 
# 1881
} 
# 1883
template< class _Tp, class _Up> inline complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  
# 1885
pow(const _Tp &__x, const complex< _Up>  &__y) 
# 1886
{ 
# 1887
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1888
return std::pow((__type)__x, ((complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type> )(__y))); 
# 1889
} 
# 1891
template< class _Tp, class _Up> inline complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type>  
# 1893
pow(const complex< _Tp>  &__x, const complex< _Up>  &__y) 
# 1894
{ 
# 1895
typedef typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type __type; 
# 1896
return std::pow(((complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type> )(__x)), ((complex< typename __gnu_cxx::__promote_2< _Tp, _Up> ::__type> )(__y))); 
# 1898
} 
# 1902
template< class _Tp> inline complex< _Tp>  proj(const complex< _Tp>  &); 
# 1906
template< class _Tp> inline complex< _Tp>  
# 1908
__complex_proj(const complex< _Tp>  &__z) 
# 1909
{ return __z; } 
# 1913
inline complex< float>  __complex_proj(const complex< float>  &__z) 
# 1914
{ return __builtin_cprojf(__z.__rep()); } 
# 1917
inline complex< double>  __complex_proj(const complex< double>  &__z) 
# 1918
{ return __builtin_cproj(__z.__rep()); } 
# 1921
inline complex< long double>  __complex_proj(const complex< long double>  &__z) 
# 1922
{ return __builtin_cprojl(__z.__rep()); } 
# 1952 "/usr/include/c++/9/complex" 3
template< class _Tp> inline complex< _Tp>  
# 1954
proj(const complex< _Tp>  &__z) 
# 1955
{ return __complex_proj(__z); } 
# 1958
template< class _Tp> inline complex< typename __gnu_cxx::__promote< _Tp> ::__type>  
# 1960
proj(_Tp __x) 
# 1961
{ 
# 1962
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 1963
return std::proj(((complex< typename __gnu_cxx::__promote< _Tp> ::__type> )(__x))); 
# 1964
} 
# 1966
template< class _Tp> inline complex< typename __gnu_cxx::__promote< _Tp> ::__type>  
# 1969
conj(_Tp __x) 
# 1970
{ 
# 1971
typedef typename __gnu_cxx::__promote< _Tp> ::__type __type; 
# 1972
return complex< typename __gnu_cxx::__promote< _Tp> ::__type> (__x, -__type()); 
# 1973
} 
# 1977
inline namespace literals { 
# 1978
inline namespace complex_literals { 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
# 1984
constexpr complex< float>  operator ""if(long double __num) 
# 1985
{ return complex< float> {(0.0F), static_cast< float>(__num)}; } 
# 1988
constexpr complex< float>  operator ""if(unsigned long long __num) 
# 1989
{ return complex< float> {(0.0F), static_cast< float>(__num)}; } 
# 1992
constexpr complex< double>  operator ""i(long double __num) 
# 1993
{ return complex< double> {(0.0), static_cast< double>(__num)}; } 
# 1996
constexpr complex< double>  operator ""i(unsigned long long __num) 
# 1997
{ return complex< double> {(0.0), static_cast< double>(__num)}; } 
# 2000
constexpr complex< long double>  operator ""il(long double __num) 
# 2001
{ return complex< long double> {(0.0L), __num}; } 
# 2004
constexpr complex< long double>  operator ""il(unsigned long long __num) 
# 2005
{ return complex< long double> {(0.0L), static_cast< long double>(__num)}; } 
# 2007
#pragma GCC diagnostic pop
}
# 2009
}
# 2014
}
# 57 "/usr/include/opencv4/opencv2/core/cvstd.inl.hpp" 3
namespace cv { 
# 60
template< class _Tp> class DataType< std::complex< _Tp> >  { 
# 63
public: typedef std::complex< _Tp>  value_type; 
# 64
typedef value_type work_type; 
# 65
typedef _Tp channel_type; 
# 67
enum { generic_type, 
# 68
depth = cv::DataType< channel_type> ::depth, 
# 69
channels = 2, 
# 70
fmt = DataType< channel_type> ::fmt + (((2) - 1) << 8), 
# 71
type = ((cv::DataType< channel_type> ::depth) & ((1 << 3) - 1)) + (((2) - 1) << 3)}; 
# 73
typedef Vec< channel_type, channels>  vec_type; 
# 74
}; 
# 77
static inline std::ostream &operator<<(std::ostream &out, Ptr< Formatted>  fmtd) 
# 78
{ 
# 79
fmtd->reset(); 
# 80
for (const char *str = fmtd->next(); str; str = fmtd->next()) { 
# 81
(out << str); }  
# 82
return out; 
# 83
} 
# 86
static inline std::ostream &operator<<(std::ostream &out, const Mat &mtx) 
# 87
{ 
# 88
return (out << ((Formatter::get())->format(mtx))); 
# 89
} 
# 92
static inline std::ostream &operator<<(std::ostream &out, const UMat &m) 
# 93
{ 
# 94
return (out << (m.getMat(ACCESS_READ))); 
# 95
} 
# 97
template< class _Tp> static inline std::ostream &
# 98
operator<<(std::ostream &out, const Complex< _Tp>  &c) 
# 99
{ 
# 100
return ((((out << ("(")) << (c.re)) << ",") << (c.im)) << ")"; 
# 101
} 
# 103
template< class _Tp> static inline std::ostream &
# 104
operator<<(std::ostream &out, const std::vector< Point_< _Tp> >  &vec) 
# 105
{ 
# 106
return (out << ((Formatter::get())->format(((Mat)(vec))))); 
# 107
} 
# 110
template< class _Tp> static inline std::ostream &
# 111
operator<<(std::ostream &out, const std::vector< Point3_< _Tp> >  &vec) 
# 112
{ 
# 113
return (out << ((Formatter::get())->format(((Mat)(vec))))); 
# 114
} 
# 117
template< class _Tp, int m, int n> static inline std::ostream &
# 118
operator<<(std::ostream &out, const Matx< _Tp, m, n>  &matx) 
# 119
{ 
# 120
return (out << ((Formatter::get())->format(((Mat)(matx))))); 
# 121
} 
# 123
template< class _Tp> static inline std::ostream &
# 124
operator<<(std::ostream &out, const Point_< _Tp>  &p) 
# 125
{ 
# 126
((((out << ("[")) << (p.x)) << ", ") << (p.y)) << "]"; 
# 127
return out; 
# 128
} 
# 130
template< class _Tp> static inline std::ostream &
# 131
operator<<(std::ostream &out, const Point3_< _Tp>  &p) 
# 132
{ 
# 133
((((((out << ("[")) << (p.x)) << ", ") << (p.y)) << ", ") << (p.z)) << "]"; 
# 134
return out; 
# 135
} 
# 137
template< class _Tp, int n> static inline std::ostream &
# 138
operator<<(std::ostream &out, const Vec< _Tp, n>  &vec) 
# 139
{ 
# 140
(out << ("[")); 
# 141
if (cv::traits::template Depth< _Tp> ::value <= 4) 
# 142
{ 
# 143
for (int i = 0; i < (n - 1); ++i) { 
# 144
(((out << ((int)(vec[i])))) << (", ")); 
# 145
}  
# 146
(((out << ((int)(vec[n - 1])))) << ("]")); 
# 147
} else 
# 149
{ 
# 150
for (int i = 0; i < (n - 1); ++i) { 
# 151
(out << (vec[i])) << ", "; 
# 152
}  
# 153
(out << (vec[n - 1])) << "]"; 
# 154
}  
# 156
return out; 
# 157
} 
# 159
template< class _Tp> static inline std::ostream &
# 160
operator<<(std::ostream &out, const Size_< _Tp>  &size) 
# 161
{ 
# 162
return ((((out << ("[")) << (size.width)) << " x ") << (size.height)) << "]"; 
# 163
} 
# 165
template< class _Tp> static inline std::ostream &
# 166
operator<<(std::ostream &out, const Rect_< _Tp>  &rect) 
# 167
{ 
# 168
return ((((((((out << ("[")) << (rect.width)) << " x ") << (rect.height)) << " from (") << (rect.x)) << ", ") << (rect.y)) << ")]"; 
# 169
} 
# 171
static inline std::ostream &operator<<(std::ostream &out, const MatSize &msize) 
# 172
{ 
# 173
int i, dims = msize.dims(); 
# 174
for (i = 0; i < dims; i++) 
# 175
{ 
# 176
(out << (msize[i])); 
# 177
if (i < (dims - 1)) { 
# 178
(out << (" x ")); }  
# 179
}  
# 180
return out; 
# 181
} 
# 183
static inline std::ostream &operator<<(std::ostream &s, Range &r) 
# 184
{ 
# 185
return (((((((((s << ("["))) << (r.start))) << (" : "))) << (r.end))) << (")")); 
# 186
} 
# 188
}
# 47 "/usr/include/c++/9/bits/std_function.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 56
class bad_function_call : public exception { 
# 59
public: virtual ~bad_function_call() noexcept; 
# 61
virtual const char *what() const noexcept; 
# 62
}; 
# 70
template< class _Tp> 
# 71
struct __is_location_invariant : public is_trivially_copyable< _Tp> ::type { 
# 73
}; 
# 75
class _Undefined_class; 
# 77
union _Nocopy_types { 
# 79
void *_M_object; 
# 80
const void *_M_const_object; 
# 81
void (*_M_function_pointer)(void); 
# 82
void (_Undefined_class::*_M_member_pointer)(void); 
# 83
}; 
# 85
union [[gnu::may_alias]] _Any_data { 
# 87
void *_M_access() { return &((_M_pod_data)[0]); } 
# 88
const void *_M_access() const { return &((_M_pod_data)[0]); } 
# 90
template< class _Tp> _Tp &
# 92
_M_access() 
# 93
{ return *(static_cast< _Tp *>(this->_M_access())); } 
# 95
template< class _Tp> const _Tp &
# 97
_M_access() const 
# 98
{ return *(static_cast< const _Tp *>(this->_M_access())); } 
# 100
_Nocopy_types _M_unused; 
# 101
char _M_pod_data[sizeof(_Nocopy_types)]; 
# 102
}; 
# 104
enum _Manager_operation { 
# 106
__get_type_info, 
# 107
__get_functor_ptr, 
# 108
__clone_functor, 
# 109
__destroy_functor
# 110
}; 
# 114
template< class _Tp> 
# 115
struct _Simple_type_wrapper { 
# 117
_Simple_type_wrapper(_Tp __value) : __value(__value) { } 
# 119
_Tp __value; 
# 120
}; 
# 122
template< class _Tp> 
# 123
struct __is_location_invariant< _Simple_type_wrapper< _Tp> >  : public std::__is_location_invariant< _Tp>  { 
# 125
}; 
# 127
template< class _Signature> class function; 
# 131
class _Function_base { 
# 134
public: static const size_t _M_max_size = sizeof(_Nocopy_types); 
# 135
static const size_t _M_max_align = __alignof__(_Nocopy_types); 
# 137
template< class _Functor> 
# 138
class _Base_manager { 
# 141
protected: static const bool __stored_locally = (__is_location_invariant< _Functor> ::value && (sizeof(_Functor) <= _M_max_size) && (__alignof__(_Functor) <= _M_max_align) && ((_M_max_align % __alignof__(_Functor)) == (0))); 
# 147
typedef integral_constant< bool, __stored_locally>  _Local_storage; 
# 151
static _Functor *_M_get_pointer(const _Any_data &__source) 
# 152
{ 
# 153
if (__stored_locally) 
# 154
{ 
# 155
const _Functor &__f = __source.template _M_access< _Functor> (); 
# 156
return const_cast< _Functor *>(std::__addressof(__f)); 
# 157
} else { 
# 159
return __source.template _M_access< _Functor *> (); }  
# 160
} 
# 165
static void _M_clone(_Any_data &__dest, const _Any_data &__source, true_type) 
# 166
{ 
# 167
::new (__dest._M_access()) _Functor(__source.template _M_access< _Functor> ()); 
# 168
} 
# 173
static void _M_clone(_Any_data &__dest, const _Any_data &__source, false_type) 
# 174
{ 
# 175
__dest.template _M_access< _Functor *> () = (new _Functor(*__source.template _M_access< const _Functor *> ())); 
# 177
} 
# 182
static void _M_destroy(_Any_data &__victim, true_type) 
# 183
{ 
# 184
__victim.template _M_access< _Functor> ().~_Functor(); 
# 185
} 
# 189
static void _M_destroy(_Any_data &__victim, false_type) 
# 190
{ 
# 191
delete __victim.template _M_access< _Functor *> (); 
# 192
} 
# 196
public: static bool _M_manager(_Any_data &__dest, const _Any_data &__source, _Manager_operation 
# 197
__op) 
# 198
{ 
# 199
switch (__op) 
# 200
{ 
# 202
case __get_type_info:  
# 203
__dest.template _M_access< const type_info *> () = (&typeid(_Functor)); 
# 204
break; 
# 206
case __get_functor_ptr:  
# 207
__dest.template _M_access< _Functor *> () = (_M_get_pointer)(__source); 
# 208
break; 
# 210
case __clone_functor:  
# 211
_M_clone(__dest, __source, _Local_storage()); 
# 212
break; 
# 214
case __destroy_functor:  
# 215
_M_destroy(__dest, _Local_storage()); 
# 216
break; 
# 217
}  
# 218
return false; 
# 219
} 
# 222
static void _M_init_functor(_Any_data &__functor, _Functor &&__f) 
# 223
{ _M_init_functor(__functor, std::move(__f), _Local_storage()); } 
# 225
template< class _Signature> static bool 
# 227
_M_not_empty_function(const function< _Signature>  &__f) 
# 228
{ return static_cast< bool>(__f); } 
# 230
template< class _Tp> static bool 
# 232
_M_not_empty_function(_Tp *__fp) 
# 233
{ return __fp != nullptr; } 
# 235
template< class _Class, class _Tp> static bool 
# 237
_M_not_empty_function(_Tp (_Class::*__mp)) 
# 238
{ return __mp != nullptr; } 
# 240
template< class _Tp> static bool 
# 242
_M_not_empty_function(const _Tp &) 
# 243
{ return true; } 
# 247
private: static void _M_init_functor(_Any_data &__functor, _Functor &&__f, true_type) 
# 248
{ ::new (__functor._M_access()) _Functor(std::move(__f)); } 
# 251
static void _M_init_functor(_Any_data &__functor, _Functor &&__f, false_type) 
# 252
{ __functor.template _M_access< _Functor *> () = (new _Functor(std::move(__f))); } 
# 253
}; 
# 255
_Function_base() : _M_manager((nullptr)) { } 
# 257
~_Function_base() 
# 258
{ 
# 259
if (_M_manager) { 
# 260
(_M_manager)(_M_functor, _M_functor, __destroy_functor); }  
# 261
} 
# 263
bool _M_empty() const { return !(_M_manager); } 
# 265
typedef bool (*_Manager_type)(_Any_data &, const _Any_data &, _Manager_operation); 
# 268
_Any_data _M_functor; 
# 269
_Manager_type _M_manager; 
# 270
}; 
# 272
template< class _Signature, class _Functor> class _Function_handler; 
# 275
template< class _Res, class _Functor, class ..._ArgTypes> 
# 276
class _Function_handler< _Res (_ArgTypes ...), _Functor>  : public _Function_base::_Base_manager< _Functor>  { 
# 279
typedef typename std::_Function_base::template _Base_manager< _Functor>  _Base; 
# 283
public: static _Res _M_invoke(const std::_Any_data &__functor, _ArgTypes &&...__args) 
# 284
{ 
# 285
return (*_Base::_M_get_pointer(__functor))(std::forward< _ArgTypes> (__args)...); 
# 287
} 
# 288
}; 
# 290
template< class _Functor, class ..._ArgTypes> 
# 291
class _Function_handler< void (_ArgTypes ...), _Functor>  : public _Function_base::_Base_manager< _Functor>  { 
# 294
typedef typename std::_Function_base::template _Base_manager< _Functor>  _Base; 
# 298
public: static void _M_invoke(const std::_Any_data &__functor, _ArgTypes &&...__args) 
# 299
{ 
# 300
(*_Base::_M_get_pointer(__functor))(std::forward< _ArgTypes> (__args)...); 
# 302
} 
# 303
}; 
# 305
template< class _Class, class _Member, class _Res, class ...
# 306
_ArgTypes> 
# 307
class _Function_handler< _Res (_ArgTypes ...), _Member (_Class::*)>  : public std::_Function_handler< void (_ArgTypes ...), _Member (_Class::*)>  { 
# 311
typedef std::_Function_handler< void (_ArgTypes ...), _Member (_Class::*)>  _Base; 
# 315
public: static _Res _M_invoke(const std::_Any_data &__functor, _ArgTypes &&...__args) 
# 316
{ 
# 317
return std::__invoke((_Base::_M_get_pointer(__functor)->__value), std::forward< _ArgTypes> (__args)...); 
# 319
} 
# 320
}; 
# 322
template< class _Class, class _Member, class ..._ArgTypes> 
# 323
class _Function_handler< void (_ArgTypes ...), _Member (_Class::*)>  : public _Function_base::_Base_manager< _Simple_type_wrapper< _Member (_Class::*)> >  { 
# 327
typedef _Member (_Class::*_Functor); 
# 328
typedef _Simple_type_wrapper< _Member (_Class::*)>  _Wrapper; 
# 329
typedef typename std::_Function_base::template _Base_manager< _Simple_type_wrapper< _Member (_Class::*)> >  _Base; 
# 333
public: static bool _M_manager(std::_Any_data &__dest, const std::_Any_data &__source, std::_Manager_operation 
# 334
__op) 
# 335
{ 
# 336
switch (__op) 
# 337
{ 
# 339
case __get_type_info:  
# 340
__dest.template _M_access< const std::type_info *> () = (&typeid(_Member (_Class::*))); 
# 341
break; 
# 343
case __get_functor_ptr:  
# 344
__dest.template _M_access< _Functor *> () = (&(_Base::_M_get_pointer(__source)->__value)); 
# 346
break; 
# 348
default:  
# 349
_Base::_M_manager(__dest, __source, __op); 
# 350
}  
# 351
return false; 
# 352
} 
# 355
static void _M_invoke(const std::_Any_data &__functor, _ArgTypes &&...__args) 
# 356
{ 
# 357
std::__invoke((_Base::_M_get_pointer(__functor)->__value), std::forward< _ArgTypes> (__args)...); 
# 359
} 
# 360
}; 
# 368
template< class _Res, class ..._ArgTypes> 
# 369
class function< _Res (_ArgTypes ...)>  : public _Maybe_unary_or_binary_function< _Res, _ArgTypes...> , private _Function_base { 
# 373
template< class _Func, class 
# 374
_Res2 = __invoke_result< _Func &, _ArgTypes...> > 
# 375
struct _Callable : public __is_invocable_impl< _Res2, _Res> ::type { 
# 377
}; 
# 381
template< class _Tp> 
# 382
struct _Callable< std::function< _Res (_ArgTypes ...)> , _Tp>  : public std::false_type { }; 
# 384
template< class _Cond, class _Tp> using _Requires = typename enable_if< _Cond::value, _Tp> ::type; 
# 388
public: typedef _Res result_type; 
# 396
function() noexcept : std::_Function_base() 
# 397
{ } 
# 403
function(std::nullptr_t) noexcept : std::_Function_base() 
# 404
{ } 
# 414 "/usr/include/c++/9/bits/std_function.h" 3
function(const std::function< _Res (_ArgTypes ...)>  & __x); 
# 423 "/usr/include/c++/9/bits/std_function.h" 3
function(std::function< _Res (_ArgTypes ...)>  &&__x) noexcept : std::_Function_base() 
# 424
{ 
# 425
__x.swap(*this); 
# 426
} 
# 444 "/usr/include/c++/9/bits/std_function.h" 3
template< class _Functor, class 
# 445
 = _Requires< __not_< is_same< _Functor, std::function< _Res (_ArgTypes ...)> > > , void> , class 
# 446
 = _Requires< _Callable< _Functor> , void> > 
# 444
function(_Functor); 
# 462 "/usr/include/c++/9/bits/std_function.h" 3
std::function< _Res (_ArgTypes ...)>  &operator=(const std::function< _Res (_ArgTypes ...)>  &__x) 
# 463
{ 
# 464
((std::function< _Res (_ArgTypes ...)> )(__x)).swap(*this); 
# 465
return *this; 
# 466
} 
# 480 "/usr/include/c++/9/bits/std_function.h" 3
std::function< _Res (_ArgTypes ...)>  &operator=(std::function< _Res (_ArgTypes ...)>  &&__x) noexcept 
# 481
{ 
# 482
((std::function< _Res (_ArgTypes ...)> )(std::move(__x))).swap(*this); 
# 483
return *this; 
# 484
} 
# 494 "/usr/include/c++/9/bits/std_function.h" 3
std::function< _Res (_ArgTypes ...)>  &operator=(std::nullptr_t) noexcept 
# 495
{ 
# 496
if (_M_manager) 
# 497
{ 
# 498
(_M_manager)(_M_functor, _M_functor, __destroy_functor); 
# 499
(_M_manager) = (nullptr); 
# 500
(_M_invoker) = nullptr; 
# 501
}  
# 502
return *this; 
# 503
} 
# 521 "/usr/include/c++/9/bits/std_function.h" 3
template< class _Functor> _Requires< _Callable< typename decay< _Functor> ::type> , std::function< _Res (_ArgTypes ...)>  &>  
# 523
operator=(_Functor &&__f) 
# 524
{ 
# 525
((std::function< _Res (_ArgTypes ...)> )(std::forward< _Functor> (__f))).swap(*this); 
# 526
return *this; 
# 527
} 
# 530
template< class _Functor> std::function< _Res (_ArgTypes ...)>  &
# 532
operator=(reference_wrapper< _Functor>  __f) noexcept 
# 533
{ 
# 534
((std::function< _Res (_ArgTypes ...)> )(__f)).swap(*this); 
# 535
return *this; 
# 536
} 
# 547 "/usr/include/c++/9/bits/std_function.h" 3
void swap(std::function< _Res (_ArgTypes ...)>  &__x) noexcept 
# 548
{ 
# 549
std::swap(_M_functor, __x._M_functor); 
# 550
std::swap(_M_manager, __x._M_manager); 
# 551
std::swap(_M_invoker, __x._M_invoker); 
# 552
} 
# 564 "/usr/include/c++/9/bits/std_function.h" 3
explicit operator bool() const noexcept 
# 565
{ return !this->std::_Function_base::_M_empty(); } 
# 577 "/usr/include/c++/9/bits/std_function.h" 3
_Res operator()(_ArgTypes ...__args) const; 
# 590 "/usr/include/c++/9/bits/std_function.h" 3
const std::type_info &target_type() const noexcept; 
# 603 "/usr/include/c++/9/bits/std_function.h" 3
template< class _Functor> _Functor *target() noexcept; 
# 605
template< class _Functor> const _Functor *target() const noexcept; 
# 610
private: using _Invoker_type = _Res (*)(const std::_Any_data &, _ArgTypes && ...); 
# 611
_Invoker_type _M_invoker; 
# 612
}; 
# 652 "/usr/include/c++/9/bits/std_function.h" 3
template< class _Res, class ..._ArgTypes> 
# 654
function< _Res (_ArgTypes ...)> ::function(const std::function< _Res (_ArgTypes ...)>  &__x) : std::_Function_base() 
# 656
{ 
# 657
if (static_cast< bool>(__x)) 
# 658
{ 
# 659
(__x._M_manager)(_M_functor, __x._M_functor, __clone_functor); 
# 660
(_M_invoker) = (__x._M_invoker); 
# 661
(_M_manager) = (__x._M_manager); 
# 662
}  
# 663
} 
# 665
template< class _Res, class ..._ArgTypes> 
# 666
template< class _Functor, class , class > 
# 668
function< _Res (_ArgTypes ...)> ::function(_Functor __f) : std::_Function_base() 
# 670
{ 
# 671
typedef _Function_handler< _Res (_ArgTypes ...), _Functor>  _My_handler; 
# 673
if (_My_handler::_M_not_empty_function(__f)) 
# 674
{ 
# 675
_My_handler::_M_init_functor(_M_functor, std::move(__f)); 
# 676
(_M_invoker) = (&_My_handler::_M_invoke); 
# 677
(_M_manager) = (&_My_handler::_M_manager); 
# 678
}  
# 679
} 
# 681
template< class _Res, class ..._ArgTypes> _Res 
# 684
function< _Res (_ArgTypes ...)> ::operator()(_ArgTypes ...__args) const 
# 685
{ 
# 686
if (this->std::_Function_base::_M_empty()) { 
# 687
__throw_bad_function_call(); }  
# 688
return (_M_invoker)(_M_functor, std::forward< _ArgTypes> (__args)...); 
# 689
} 
# 692
template< class _Res, class ..._ArgTypes> const type_info &
# 695
function< _Res (_ArgTypes ...)> ::target_type() const noexcept 
# 696
{ 
# 697
if (_M_manager) 
# 698
{ 
# 699
std::_Any_data __typeinfo_result; 
# 700
(_M_manager)(__typeinfo_result, _M_functor, __get_type_info); 
# 701
return *__typeinfo_result.template _M_access< const std::type_info *> (); 
# 702
} else { 
# 704
return typeid(void); }  
# 705
} 
# 707
template< class _Res, class ..._ArgTypes> 
# 708
template< class _Functor> _Functor *
# 711
function< _Res (_ArgTypes ...)> ::target() noexcept 
# 712
{ 
# 713
const std::function< _Res (_ArgTypes ...)>  *__const_this = this; 
# 714
const _Functor *__func = __const_this->template target< _Functor> (); 
# 715
return const_cast< _Functor *>(__func); 
# 716
} 
# 718
template< class _Res, class ..._ArgTypes> 
# 719
template< class _Functor> const _Functor *
# 722
function< _Res (_ArgTypes ...)> ::target() const noexcept 
# 723
{ 
# 724
if ((typeid(_Functor) == target_type()) && (_M_manager)) 
# 725
{ 
# 726
std::_Any_data __ptr; 
# 727
(_M_manager)(__ptr, _M_functor, __get_functor_ptr); 
# 728
return __ptr.template _M_access< const _Functor *> (); 
# 729
} else { 
# 731
return nullptr; }  
# 732
} 
# 744 "/usr/include/c++/9/bits/std_function.h" 3
template< class _Res, class ..._Args> inline bool 
# 746
operator==(const function< _Res (_Args ...)>  &__f, nullptr_t) noexcept 
# 747
{ return !(static_cast< bool>(__f)); } 
# 750
template< class _Res, class ..._Args> inline bool 
# 752
operator==(nullptr_t, const function< _Res (_Args ...)>  &__f) noexcept 
# 753
{ return !(static_cast< bool>(__f)); } 
# 762 "/usr/include/c++/9/bits/std_function.h" 3
template< class _Res, class ..._Args> inline bool 
# 764
operator!=(const function< _Res (_Args ...)>  &__f, nullptr_t) noexcept 
# 765
{ return static_cast< bool>(__f); } 
# 768
template< class _Res, class ..._Args> inline bool 
# 770
operator!=(nullptr_t, const function< _Res (_Args ...)>  &__f) noexcept 
# 771
{ return static_cast< bool>(__f); } 
# 783 "/usr/include/c++/9/bits/std_function.h" 3
template< class _Res, class ..._Args> inline void 
# 785
swap(function< _Res (_Args ...)>  &__x, function< _Res (_Args ...)>  &__y) noexcept 
# 786
{ __x.swap(__y); } 
# 803 "/usr/include/c++/9/bits/std_function.h" 3
}
# 68 "/usr/include/c++/9/functional" 3
namespace std __attribute((__visibility__("default"))) { 
# 86 "/usr/include/c++/9/functional" 3
template< class _MemFunPtr, bool 
# 87
__is_mem_fn = is_member_function_pointer< _MemFunPtr> ::value> 
# 88
class _Mem_fn_base : public _Mem_fn_traits< _MemFunPtr> ::__maybe_type { 
# 91
using _Traits = _Mem_fn_traits< _MemFunPtr> ; 
# 93
using _Arity = typename _Mem_fn_traits< _MemFunPtr> ::__arity; 
# 94
using _Varargs = typename _Mem_fn_traits< _MemFunPtr> ::__vararg; 
# 96
template< class _Func, class ..._BoundArgs> friend struct _Bind_check_arity; 
# 99
_MemFunPtr _M_pmf; 
# 103
public: using result_type = typename _Mem_fn_traits< _MemFunPtr> ::__result_type; 
# 106
constexpr explicit _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { } 
# 108
template< class ..._Args> auto 
# 110
operator()(_Args &&...__args) const noexcept(noexcept(std::__invoke(_M_pmf, std::forward< _Args> (__args)...)))->__decltype((std::__invoke(_M_pmf, std::forward< _Args> (__args)...))) 
# 114
{ return std::__invoke(_M_pmf, std::forward< _Args> (__args)...); } 
# 115
}; 
# 118
template< class _MemObjPtr> 
# 119
class _Mem_fn_base< _MemObjPtr, false>  { 
# 121
using _Arity = integral_constant< size_t, 0UL> ; 
# 122
using _Varargs = false_type; 
# 124
template< class _Func, class ..._BoundArgs> friend struct _Bind_check_arity; 
# 127
_MemObjPtr _M_pm; 
# 131
public: constexpr explicit _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { } 
# 133
template< class _Tp> auto 
# 135
operator()(_Tp &&__obj) const noexcept(noexcept(std::__invoke(_M_pm, std::forward< _Tp> (__obj))))->__decltype((std::__invoke(_M_pm, std::forward< _Tp> (__obj)))) 
# 138
{ return std::__invoke(_M_pm, std::forward< _Tp> (__obj)); } 
# 139
}; 
# 141
template< class _MemberPointer> struct _Mem_fn; 
# 144
template< class _Res, class _Class> 
# 145
struct _Mem_fn< _Res (_Class::*)>  : public _Mem_fn_base< _Res (_Class::*)>  { 
# 148
using _Mem_fn_base< _Res (_Class::*)> ::_Mem_fn_base;
# 149
}; 
# 158 "/usr/include/c++/9/functional" 3
template< class _Tp, class _Class> inline _Mem_fn< _Tp (_Class::*)>  
# 160
mem_fn(_Tp (_Class::*__pm)) noexcept 
# 161
{ 
# 162
return ((_Mem_fn< _Tp (_Class::*)> )(__pm)); 
# 163
} 
# 173 "/usr/include/c++/9/functional" 3
template< class _Tp> 
# 174
struct is_bind_expression : public false_type { 
# 175
}; 
# 184 "/usr/include/c++/9/functional" 3
template< class _Tp> 
# 185
struct is_placeholder : public integral_constant< int, 0>  { 
# 187
}; 
# 199 "/usr/include/c++/9/functional" 3
template< int _Num> struct _Placeholder { }; 
# 205
namespace placeholders { 
# 211
extern const _Placeholder< 1>  _1; 
# 212
extern const _Placeholder< 2>  _2; 
# 213
extern const _Placeholder< 3>  _3; 
# 214
extern const _Placeholder< 4>  _4; 
# 215
extern const _Placeholder< 5>  _5; 
# 216
extern const _Placeholder< 6>  _6; 
# 217
extern const _Placeholder< 7>  _7; 
# 218
extern const _Placeholder< 8>  _8; 
# 219
extern const _Placeholder< 9>  _9; 
# 220
extern const _Placeholder< 10>  _10; 
# 221
extern const _Placeholder< 11>  _11; 
# 222
extern const _Placeholder< 12>  _12; 
# 223
extern const _Placeholder< 13>  _13; 
# 224
extern const _Placeholder< 14>  _14; 
# 225
extern const _Placeholder< 15>  _15; 
# 226
extern const _Placeholder< 16>  _16; 
# 227
extern const _Placeholder< 17>  _17; 
# 228
extern const _Placeholder< 18>  _18; 
# 229
extern const _Placeholder< 19>  _19; 
# 230
extern const _Placeholder< 20>  _20; 
# 231
extern const _Placeholder< 21>  _21; 
# 232
extern const _Placeholder< 22>  _22; 
# 233
extern const _Placeholder< 23>  _23; 
# 234
extern const _Placeholder< 24>  _24; 
# 235
extern const _Placeholder< 25>  _25; 
# 236
extern const _Placeholder< 26>  _26; 
# 237
extern const _Placeholder< 27>  _27; 
# 238
extern const _Placeholder< 28>  _28; 
# 239
extern const _Placeholder< 29>  _29; 
# 240
}
# 247
template< int _Num> 
# 248
struct is_placeholder< _Placeholder< _Num> >  : public integral_constant< int, _Num>  { 
# 250
}; 
# 252
template< int _Num> 
# 253
struct is_placeholder< const _Placeholder< _Num> >  : public integral_constant< int, _Num>  { 
# 255
}; 
# 259
template< size_t __i, class _Tuple> using _Safe_tuple_element_t = typename enable_if< __i < tuple_size< _Tuple> ::value, tuple_element< __i, _Tuple> > ::type::type; 
# 275 "/usr/include/c++/9/functional" 3
template< class _Arg, bool 
# 276
_IsBindExp = is_bind_expression< _Arg> ::value, bool 
# 277
_IsPlaceholder = (is_placeholder< _Arg> ::value > 0)> class _Mu; 
# 285
template< class _Tp> 
# 286
class _Mu< reference_wrapper< _Tp> , false, false>  { 
# 295
public: 
# 293
template< class _CVRef, class _Tuple> _Tp &
# 295
operator()(_CVRef &__arg, _Tuple &) const volatile 
# 296
{ return __arg.get(); } 
# 297
}; 
# 305
template< class _Arg> 
# 306
class _Mu< _Arg, true, false>  { 
# 311
public: 
# 309
template< class _CVArg, class ..._Args> auto 
# 311
operator()(_CVArg &__arg, tuple< _Args...>  &
# 312
__tuple) const volatile->__decltype((__arg(declval< _Args> ()...))) 
# 314
{ 
# 317
typedef typename _Build_index_tuple< sizeof...(_Args)> ::__type _Indexes; 
# 318
return this->__call(__arg, __tuple, _Indexes()); 
# 319
} 
# 326
private: 
# 324
template< class _CVArg, class ..._Args, size_t ..._Indexes> auto 
# 326
__call(_CVArg &__arg, tuple< _Args...>  &__tuple, const _Index_tuple< _Indexes...>  &) const volatile->__decltype((__arg(declval< _Args> ()...))) 
# 329
{ 
# 330
return __arg(std::get< _Indexes> (std::move(__tuple))...); 
# 331
} 
# 332
}; 
# 339
template< class _Arg> 
# 340
class _Mu< _Arg, false, true>  { 
# 345
public: 
# 343
template< class _Tuple> _Safe_tuple_element_t< is_placeholder< _Arg> ::value - 1, _Tuple>  &&
# 345
operator()(const volatile _Arg &, _Tuple &__tuple) const volatile 
# 346
{ 
# 347
return std::get< is_placeholder< _Arg> ::value - 1> (std::move(__tuple)); 
# 349
} 
# 350
}; 
# 357
template< class _Arg> 
# 358
class _Mu< _Arg, false, false>  { 
# 363
public: 
# 361
template< class _CVArg, class _Tuple> _CVArg &&
# 363
operator()(_CVArg &&__arg, _Tuple &) const volatile 
# 364
{ return std::forward< _CVArg> (__arg); } 
# 365
}; 
# 368
template< size_t _Ind, class ..._Tp> inline auto 
# 370
__volget(volatile tuple< _Tp...>  &__tuple)->volatile __tuple_element_t< _Ind, tuple< _Tp...> >  & 
# 372
{ return std::get< _Ind> (const_cast< tuple< _Tp...>  &>(__tuple)); } 
# 375
template< size_t _Ind, class ..._Tp> inline auto 
# 377
__volget(const volatile tuple< _Tp...>  &__tuple)->const volatile __tuple_element_t< _Ind, tuple< _Tp...> >  & 
# 379
{ return std::get< _Ind> (const_cast< const tuple< _Tp...>  &>(__tuple)); } 
# 382
template< class _Signature> struct _Bind; 
# 385
template< class _Functor, class ..._Bound_args> 
# 386
class _Bind< _Functor (_Bound_args ...)>  : public _Weak_result_type< _Functor>  { 
# 390
typedef typename _Build_index_tuple< sizeof...(_Bound_args)> ::__type _Bound_indexes; 
# 392
_Functor _M_f; 
# 393
tuple< _Bound_args...>  _M_bound_args; 
# 396
template< class _Result, class ..._Args, std::size_t ..._Indexes> _Result 
# 398
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) 
# 399
{ 
# 400
return std::__invoke(_M_f, _Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 403
} 
# 406
template< class _Result, class ..._Args, std::size_t ..._Indexes> _Result 
# 408
__call_c(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) const 
# 409
{ 
# 410
return std::__invoke(_M_f, _Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 413
} 
# 416
template< class _Result, class ..._Args, std::size_t ..._Indexes> _Result 
# 418
__call_v(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) volatile 
# 420
{ 
# 421
return std::__invoke(_M_f, _Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 424
} 
# 427
template< class _Result, class ..._Args, std::size_t ..._Indexes> _Result 
# 429
__call_c_v(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) const volatile 
# 431
{ 
# 432
return std::__invoke(_M_f, _Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 435
} 
# 437
template< class _BoundArg, class _CallArgs> using _Mu_type = __decltype((_Mu< typename remove_cv< _BoundArg> ::type> ()(std::declval< _BoundArg &> (), std::declval< _CallArgs &> ()))); 
# 442
template< class _Fn, class _CallArgs, class ..._BArgs> using _Res_type_impl = typename result_of< _Fn &(_Mu_type< _BArgs, _CallArgs>  && ...)> ::type; 
# 446
template< class _CallArgs> using _Res_type = _Res_type_impl< _Functor, _CallArgs, _Bound_args...> ; 
# 449
template< class _CallArgs> using __dependent = typename enable_if< (bool)(tuple_size< _CallArgs> ::value + 1), _Functor> ::type; 
# 453
template< class _CallArgs, template< class >  class __cv_quals> using _Res_type_cv = _Res_type_impl< typename __cv_quals< __dependent< _CallArgs> > ::type, _CallArgs, typename __cv_quals< _Bound_args> ::type...> ; 
# 461
public: 
# 460
template< class ..._Args> explicit 
# 461
_Bind(const _Functor &__f, _Args &&...__args) : _M_f(__f), _M_bound_args(std::forward< _Args> (__args)...) 
# 463
{ } 
# 465
template< class ..._Args> explicit 
# 466
_Bind(_Functor &&__f, _Args &&...__args) : _M_f(std::move(__f)), _M_bound_args(std::forward< _Args> (__args)...) 
# 468
{ } 
# 470
_Bind(const std::_Bind< _Functor (_Bound_args ...)>  &) = default;
# 472
_Bind(std::_Bind< _Functor (_Bound_args ...)>  &&__b) : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args)) 
# 474
{ } 
# 477
template< class ..._Args, class 
# 478
_Result = _Res_type< tuple< _Args...> > > _Result 
# 480
operator()(_Args &&...__args) 
# 481
{ 
# 482
return this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes()); 
# 485
} 
# 488
template< class ..._Args, class 
# 489
_Result = _Res_type_cv< tuple< _Args...> , std::add_const> > _Result 
# 491
operator()(_Args &&...__args) const 
# 492
{ 
# 493
return this->template __call_c< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes()); 
# 496
} 
# 505 "/usr/include/c++/9/functional" 3
template< class ..._Args, class 
# 506
_Result = _Res_type_cv< tuple< _Args...> , std::add_volatile> > _Result 
# 509
operator()(_Args &&...__args) volatile 
# 510
{ 
# 511
return this->template __call_v< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes()); 
# 514
} 
# 517
template< class ..._Args, class 
# 518
_Result = _Res_type_cv< tuple< _Args...> , std::add_cv> > _Result 
# 521
operator()(_Args &&...__args) const volatile 
# 522
{ 
# 523
return this->template __call_c_v< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes()); 
# 526
} 
# 527
}; 
# 530
template< class _Result, class _Signature> struct _Bind_result; 
# 533
template< class _Result, class _Functor, class ..._Bound_args> 
# 534
class _Bind_result< _Result, _Functor (_Bound_args ...)>  { 
# 537
typedef typename _Build_index_tuple< sizeof...(_Bound_args)> ::__type _Bound_indexes; 
# 539
_Functor _M_f; 
# 540
tuple< _Bound_args...>  _M_bound_args; 
# 543
template< class _Res> using __enable_if_void = typename enable_if< is_void< _Res> {}> ::type; 
# 547
template< class _Res> using __disable_if_void = typename enable_if< !is_void< _Res> {}, _Result> ::type; 
# 552
template< class _Res, class ..._Args, size_t ..._Indexes> __disable_if_void< _Res>  
# 554
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) 
# 555
{ 
# 556
return std::__invoke(_M_f, _Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 558
} 
# 561
template< class _Res, class ..._Args, size_t ..._Indexes> __enable_if_void< _Res>  
# 563
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) 
# 564
{ 
# 565
std::__invoke(_M_f, _Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 567
} 
# 570
template< class _Res, class ..._Args, size_t ..._Indexes> __disable_if_void< _Res>  
# 572
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) const 
# 573
{ 
# 574
return std::__invoke(_M_f, _Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 576
} 
# 579
template< class _Res, class ..._Args, size_t ..._Indexes> __enable_if_void< _Res>  
# 581
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) const 
# 582
{ 
# 583
std::__invoke(_M_f, _Mu< _Bound_args> ()(std::get< _Indexes> (_M_bound_args), __args)...); 
# 585
} 
# 588
template< class _Res, class ..._Args, size_t ..._Indexes> __disable_if_void< _Res>  
# 590
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) volatile 
# 591
{ 
# 592
return std::__invoke(_M_f, _Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 594
} 
# 597
template< class _Res, class ..._Args, size_t ..._Indexes> __enable_if_void< _Res>  
# 599
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) volatile 
# 600
{ 
# 601
std::__invoke(_M_f, _Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 603
} 
# 606
template< class _Res, class ..._Args, size_t ..._Indexes> __disable_if_void< _Res>  
# 608
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) const volatile 
# 610
{ 
# 611
return std::__invoke(_M_f, _Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 613
} 
# 616
template< class _Res, class ..._Args, size_t ..._Indexes> __enable_if_void< _Res>  
# 618
__call(tuple< _Args...>  &&__args, _Index_tuple< _Indexes...> ) const volatile 
# 620
{ 
# 621
std::__invoke(_M_f, _Mu< _Bound_args> ()(__volget< _Indexes> (_M_bound_args), __args)...); 
# 623
} 
# 626
public: typedef _Result result_type; 
# 628
template< class ..._Args> explicit 
# 629
_Bind_result(const _Functor &__f, _Args &&...__args) : _M_f(__f), _M_bound_args(std::forward< _Args> (__args)...) 
# 631
{ } 
# 633
template< class ..._Args> explicit 
# 634
_Bind_result(_Functor &&__f, _Args &&...__args) : _M_f(std::move(__f)), _M_bound_args(std::forward< _Args> (__args)...) 
# 636
{ } 
# 638
_Bind_result(const std::_Bind_result< _Result, _Functor (_Bound_args ...)>  &) = default;
# 640
_Bind_result(std::_Bind_result< _Result, _Functor (_Bound_args ...)>  &&__b) : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args)) 
# 642
{ } 
# 645
template< class ..._Args> result_type 
# 647
operator()(_Args &&...__args) 
# 648
{ 
# 649
return this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes()); 
# 652
} 
# 655
template< class ..._Args> result_type 
# 657
operator()(_Args &&...__args) const 
# 658
{ 
# 659
return this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes()); 
# 662
} 
# 665
template< class ..._Args> result_type 
# 668
operator()(_Args &&...__args) volatile 
# 669
{ 
# 670
return this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes()); 
# 673
} 
# 676
template< class ..._Args> result_type 
# 679
operator()(_Args &&...__args) const volatile 
# 680
{ 
# 681
return this->template __call< _Result> (std::forward_as_tuple(std::forward< _Args> (__args)...), _Bound_indexes()); 
# 684
} 
# 685
}; 
# 692
template< class _Signature> 
# 693
struct is_bind_expression< _Bind< _Signature> >  : public true_type { 
# 694
}; 
# 700
template< class _Signature> 
# 701
struct is_bind_expression< const _Bind< _Signature> >  : public true_type { 
# 702
}; 
# 708
template< class _Signature> 
# 709
struct is_bind_expression< volatile _Bind< _Signature> >  : public true_type { 
# 710
}; 
# 716
template< class _Signature> 
# 717
struct is_bind_expression< const volatile _Bind< _Signature> >  : public true_type { 
# 718
}; 
# 724
template< class _Result, class _Signature> 
# 725
struct is_bind_expression< _Bind_result< _Result, _Signature> >  : public true_type { 
# 726
}; 
# 732
template< class _Result, class _Signature> 
# 733
struct is_bind_expression< const _Bind_result< _Result, _Signature> >  : public true_type { 
# 734
}; 
# 740
template< class _Result, class _Signature> 
# 741
struct is_bind_expression< volatile _Bind_result< _Result, _Signature> >  : public true_type { 
# 742
}; 
# 748
template< class _Result, class _Signature> 
# 749
struct is_bind_expression< const volatile _Bind_result< _Result, _Signature> >  : public true_type { 
# 750
}; 
# 752
template< class _Func, class ..._BoundArgs> 
# 753
struct _Bind_check_arity { }; 
# 755
template< class _Ret, class ..._Args, class ..._BoundArgs> 
# 756
struct _Bind_check_arity< _Ret (*)(_Args ...), _BoundArgs...>  { 
# 758
static_assert((sizeof...(_BoundArgs) == sizeof...(_Args)), "Wrong number of arguments for function");
# 760
}; 
# 762
template< class _Ret, class ..._Args, class ..._BoundArgs> 
# 763
struct _Bind_check_arity< _Ret (*)(_Args ..., ...), _BoundArgs...>  { 
# 765
static_assert((sizeof...(_BoundArgs) >= sizeof...(_Args)), "Wrong number of arguments for function");
# 767
}; 
# 769
template< class _Tp, class _Class, class ..._BoundArgs> 
# 770
struct _Bind_check_arity< _Tp (_Class::*), _BoundArgs...>  { 
# 772
using _Arity = typename _Mem_fn< _Tp (_Class::*)> ::_Arity; 
# 773
using _Varargs = typename _Mem_fn< _Tp (_Class::*)> ::_Varargs; 
# 774
static_assert(((_Varargs::value) ? sizeof...(_BoundArgs) >= (_Arity::value + 1) : (sizeof...(_BoundArgs) == (_Arity::value + 1))), "Wrong number of arguments for pointer-to-member");
# 778
}; 
# 783
template< class _Tp, class _Tp2 = typename decay< _Tp> ::type> using __is_socketlike = __or_< is_integral< _Tp2> , is_enum< _Tp2> > ; 
# 786
template< bool _SocketLike, class _Func, class ..._BoundArgs> 
# 787
struct _Bind_helper : public _Bind_check_arity< typename decay< _Func> ::type, _BoundArgs...>  { 
# 790
typedef typename decay< _Func> ::type __func_type; 
# 791
typedef _Bind< __func_type (typename decay< _BoundArgs> ::type ...)>  type; 
# 792
}; 
# 797
template< class _Func, class ..._BoundArgs> 
# 798
struct _Bind_helper< true, _Func, _BoundArgs...>  { 
# 799
}; 
# 805
template< class _Func, class ..._BoundArgs> inline typename _Bind_helper< __or_< is_integral< typename decay< _Func> ::type> , is_enum< typename decay< _Func> ::type> > ::value, _Func, _BoundArgs...> ::type 
# 808
bind(_Func &&__f, _BoundArgs &&...__args) 
# 809
{ 
# 810
typedef _Bind_helper< false, _Func, _BoundArgs...>  __helper_type; 
# 811
return typename _Bind_helper< false, _Func, _BoundArgs...> ::type(std::forward< _Func> (__f), std::forward< _BoundArgs> (__args)...); 
# 813
} 
# 815
template< class _Result, class _Func, class ..._BoundArgs> 
# 816
struct _Bindres_helper : public _Bind_check_arity< typename decay< _Func> ::type, _BoundArgs...>  { 
# 819
typedef typename decay< _Func> ::type __functor_type; 
# 822
typedef _Bind_result< _Result, __functor_type (typename decay< _BoundArgs> ::type ...)>  type; 
# 823
}; 
# 829
template< class _Result, class _Func, class ..._BoundArgs> inline typename _Bindres_helper< _Result, _Func, _BoundArgs...> ::type 
# 832
bind(_Func &&__f, _BoundArgs &&...__args) 
# 833
{ 
# 834
typedef _Bindres_helper< _Result, _Func, _BoundArgs...>  __helper_type; 
# 835
return typename _Bindres_helper< _Result, _Func, _BoundArgs...> ::type(std::forward< _Func> (__f), std::forward< _BoundArgs> (__args)...); 
# 837
} 
# 941 "/usr/include/c++/9/functional" 3
template< class _Fn> 
# 942
class _Not_fn { 
# 944
template< class _Fn2, class ..._Args> using __inv_res_t = typename __invoke_result< _Fn2, _Args...> ::type; 
# 947
template< class _Tp> static __decltype((!std::declval< _Tp> ())) _S_not() noexcept(noexcept((!std::declval< _Tp> ()))); 
# 953
public: 
# 952
template< class _Fn2> 
# 953
_Not_fn(_Fn2 &&__fn, int) : _M_fn(std::forward< _Fn2> (__fn)) 
# 954
{ } 
# 956
_Not_fn(const _Not_fn & __fn) = default;
# 957
_Not_fn(_Not_fn && __fn) = default;
# 958
~_Not_fn() = default;
# 973 "/usr/include/c++/9/functional" 3
template< class ..._Args> __decltype((_S_not< __inv_res_t< _Fn &, _Args...> > ())) operator()(_Args &&...__args) & noexcept(__is_nothrow_invocable< _Fn &, _Args...> ::value && noexcept(_S_not< __inv_res_t< _Fn &, _Args...> > ())) { return !std::__invoke(std::forward< _Fn &> (_M_fn), std::forward< _Args> (__args)...); } 
# 974
template< class ..._Args> __decltype((_S_not< __inv_res_t< const _Fn &, _Args...> > ())) operator()(_Args &&...__args) const & noexcept(__is_nothrow_invocable< const _Fn &, _Args...> ::value && noexcept(_S_not< __inv_res_t< const _Fn &, _Args...> > ())) { return !std::__invoke(std::forward< const _Fn &> (_M_fn), std::forward< _Args> (__args)...); } 
# 975
template< class ..._Args> __decltype((_S_not< __inv_res_t< _Fn &&, _Args...> > ())) operator()(_Args &&...__args) && noexcept(__is_nothrow_invocable< _Fn &&, _Args...> ::value && noexcept(_S_not< __inv_res_t< _Fn &&, _Args...> > ())) { return !std::__invoke(std::forward< _Fn &&> (_M_fn), std::forward< _Args> (__args)...); } 
# 976
template< class ..._Args> __decltype((_S_not< __inv_res_t< const _Fn &&, _Args...> > ())) operator()(_Args &&...__args) const && noexcept(__is_nothrow_invocable< const _Fn &&, _Args...> ::value && noexcept(_S_not< __inv_res_t< const _Fn &&, _Args...> > ())) { return !std::__invoke(std::forward< const _Fn &&> (_M_fn), std::forward< _Args> (__args)...); } 
# 980
private: _Fn _M_fn; 
# 981
}; 
# 983
template< class _Tp, class _Pred> 
# 984
struct __is_byte_like : public false_type { }; 
# 986
template< class _Tp> 
# 987
struct __is_byte_like< _Tp, equal_to< _Tp> >  : public __bool_constant< (sizeof(_Tp) == (1)) && is_integral< _Tp> ::value>  { 
# 988
}; 
# 990
template< class _Tp> 
# 991
struct __is_byte_like< _Tp, equal_to< void> >  : public __bool_constant< (sizeof(_Tp) == (1)) && is_integral< _Tp> ::value>  { 
# 992
}; 
# 1294 "/usr/include/c++/9/functional" 3
}
# 41 "/usr/include/c++/9/ratio" 3
namespace std __attribute((__visibility__("default"))) { 
# 53 "/usr/include/c++/9/ratio" 3
template< intmax_t _Pn> 
# 54
struct __static_sign : public integral_constant< long, (_Pn < (0)) ? -1 : 1>  { 
# 56
}; 
# 58
template< intmax_t _Pn> 
# 59
struct __static_abs : public integral_constant< long, _Pn * __static_sign< _Pn> ::value>  { 
# 61
}; 
# 63
template< intmax_t _Pn, intmax_t _Qn> 
# 64
struct __static_gcd : public __static_gcd< _Qn, _Pn % _Qn>  { 
# 66
}; 
# 68
template< intmax_t _Pn> 
# 69
struct __static_gcd< _Pn, 0>  : public integral_constant< long, __static_abs< _Pn> ::value>  { 
# 71
}; 
# 73
template< intmax_t _Qn> 
# 74
struct __static_gcd< 0, _Qn>  : public integral_constant< long, __static_abs< _Qn> ::value>  { 
# 76
}; 
# 84
template< intmax_t _Pn, intmax_t _Qn> 
# 85
struct __safe_multiply { 
# 88
private: static const uintmax_t __c = (((uintmax_t)1) << (sizeof(intmax_t) * (4))); 
# 90
static const uintmax_t __a0 = (__static_abs< _Pn> ::value % __c); 
# 91
static const uintmax_t __a1 = (__static_abs< _Pn> ::value / __c); 
# 92
static const uintmax_t __b0 = (__static_abs< _Qn> ::value % __c); 
# 93
static const uintmax_t __b1 = (__static_abs< _Qn> ::value / __c); 
# 95
static_assert(((__a1 == (0)) || (__b1 == (0))), "overflow in multiplication");
# 97
static_assert((((__a0 * __b1) + (__b0 * __a1)) < (__c >> 1)), "overflow in multiplication");
# 99
static_assert(((__b0 * __a0) <= (9223372036854775807L)), "overflow in multiplication");
# 101
static_assert(((((__a0 * __b1) + (__b0 * __a1)) * __c) <= ((9223372036854775807L) - (__b0 * __a0))), "overflow in multiplication");
# 106
public: static const intmax_t value = (_Pn * _Qn); 
# 107
}; 
# 111
template< uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2> 
# 112
struct __big_less : public integral_constant< bool, (__hi1 < __hi2) || ((__hi1 == __hi2) && (__lo1 < __lo2))>  { 
# 115
}; 
# 117
template< uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2> 
# 118
struct __big_add { 
# 120
static constexpr uintmax_t __lo = (__lo1 + __lo2); 
# 121
static constexpr uintmax_t __hi = ((__hi1 + __hi2) + ((__lo1 + __lo2) < __lo1)); 
# 123
}; 
# 126
template< uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2> 
# 127
struct __big_sub { 
# 129
static_assert((!__big_less< __hi1, __lo1, __hi2, __lo2> ::value), "Internal library error");
# 131
static constexpr uintmax_t __lo = (__lo1 - __lo2); 
# 132
static constexpr uintmax_t __hi = ((__hi1 - __hi2) - (__lo1 < __lo2)); 
# 134
}; 
# 137
template< uintmax_t __x, uintmax_t __y> 
# 138
struct __big_mul { 
# 141
private: static constexpr uintmax_t __c = (((uintmax_t)1) << (sizeof(intmax_t) * (4))); 
# 142
static constexpr uintmax_t __x0 = (__x % __c); 
# 143
static constexpr uintmax_t __x1 = (__x / __c); 
# 144
static constexpr uintmax_t __y0 = (__y % __c); 
# 145
static constexpr uintmax_t __y1 = (__y / __c); 
# 146
static constexpr uintmax_t __x0y0 = (__x0 * __y0); 
# 147
static constexpr uintmax_t __x0y1 = (__x0 * __y1); 
# 148
static constexpr uintmax_t __x1y0 = (__x1 * __y0); 
# 149
static constexpr uintmax_t __x1y1 = (__x1 * __y1); 
# 150
static constexpr uintmax_t __mix = (__x0y1 + __x1y0); 
# 151
static constexpr uintmax_t __mix_lo = (__mix * __c); 
# 152
static constexpr uintmax_t __mix_hi = ((__mix / __c) + ((__mix < __x0y1) ? __c : (0))); 
# 154
typedef __big_add< __mix_hi, __mix_lo, __x1y1, __x0y0>  _Res; 
# 156
public: static constexpr uintmax_t __hi = (_Res::__hi); 
# 157
static constexpr uintmax_t __lo = (_Res::__lo); 
# 158
}; 
# 162
template< uintmax_t __n1, uintmax_t __n0, uintmax_t __d> 
# 163
struct __big_div_impl { 
# 166
static_assert((__d >= (((uintmax_t)1) << ((sizeof(intmax_t) * (8)) - (1)))), "Internal library error");
# 168
static_assert((__n1 < __d), "Internal library error");
# 169
private: static constexpr uintmax_t __c = (((uintmax_t)1) << (sizeof(intmax_t) * (4))); 
# 170
static constexpr uintmax_t __d1 = (__d / __c); 
# 171
static constexpr uintmax_t __d0 = (__d % __c); 
# 173
static constexpr uintmax_t __q1x = (__n1 / __d1); 
# 174
static constexpr uintmax_t __r1x = (__n1 % __d1); 
# 175
static constexpr uintmax_t __m = (__q1x * __d0); 
# 176
static constexpr uintmax_t __r1y = ((__r1x * __c) + (__n0 / __c)); 
# 177
static constexpr uintmax_t __r1z = (__r1y + __d); 
# 178
static constexpr uintmax_t __r1 = (((__r1y < __m) ? ((__r1z >= __d) && (__r1z < __m)) ? __r1z + __d : __r1z : __r1y) - __m); 
# 181
static constexpr uintmax_t __q1 = (__q1x - ((__r1y < __m) ? ((__r1z >= __d) && (__r1z < __m)) ? 2 : 1 : 0)); 
# 184
static constexpr uintmax_t __q0x = (__r1 / __d1); 
# 185
static constexpr uintmax_t __r0x = (__r1 % __d1); 
# 186
static constexpr uintmax_t __n = (__q0x * __d0); 
# 187
static constexpr uintmax_t __r0y = ((__r0x * __c) + (__n0 % __c)); 
# 188
static constexpr uintmax_t __r0z = (__r0y + __d); 
# 189
static constexpr uintmax_t __r0 = (((__r0y < __n) ? ((__r0z >= __d) && (__r0z < __n)) ? __r0z + __d : __r0z : __r0y) - __n); 
# 192
static constexpr uintmax_t __q0 = (__q0x - ((__r0y < __n) ? ((__r0z >= __d) && (__r0z < __n)) ? 2 : 1 : 0)); 
# 197
public: static constexpr uintmax_t __quot = ((__q1 * __c) + __q0); 
# 198
static constexpr uintmax_t __rem = __r0; 
# 201
private: typedef __big_mul< __quot, __d>  _Prod; 
# 202
typedef __big_add< __big_mul< __quot, __d> ::__hi, __big_mul< __quot, __d> ::__lo, 0UL, __rem>  _Sum; 
# 203
static_assert(((_Sum::__hi == __n1) && (_Sum::__lo == __n0)), "Internal library error");
# 205
}; 
# 207
template< uintmax_t __n1, uintmax_t __n0, uintmax_t __d> 
# 208
struct __big_div { 
# 211
static_assert((__d != (0)), "Internal library error");
# 212
static_assert((sizeof(uintmax_t) == sizeof(unsigned long long)), "This library calls __builtin_clzll on uintmax_t, which is unsafe on your platform. Please complain to http://gcc.gnu.org/bugzill" "a/");
# 216
private: static constexpr int __shift = __builtin_clzll(__d); 
# 217
static constexpr int __coshift_ = ((sizeof(uintmax_t) * (8)) - __shift); 
# 218
static constexpr int __coshift = ((__shift != 0) ? __coshift_ : 0); 
# 219
static constexpr uintmax_t __c1 = (((uintmax_t)1) << __shift); 
# 220
static constexpr uintmax_t __c2 = (((uintmax_t)1) << __coshift); 
# 221
static constexpr uintmax_t __new_d = (__d * __c1); 
# 222
static constexpr uintmax_t __new_n0 = (__n0 * __c1); 
# 223
static constexpr uintmax_t __n1_shifted = ((__n1 % __d) * __c1); 
# 224
static constexpr uintmax_t __n0_top = ((__shift != 0) ? __n0 / __c2 : (0)); 
# 225
static constexpr uintmax_t __new_n1 = (__n1_shifted + __n0_top); 
# 226
typedef __big_div_impl< __new_n1, __new_n0, __new_d>  _Res; 
# 229
public: static constexpr uintmax_t __quot_hi = (__n1 / __d); 
# 230
static constexpr uintmax_t __quot_lo = (_Res::__quot); 
# 231
static constexpr uintmax_t __rem = (_Res::__rem / __c1); 
# 234
private: typedef __big_mul< __quot_lo, __d>  _P0; 
# 235
typedef __big_mul< __quot_hi, __d>  _P1; 
# 236
typedef __big_add< __big_mul< __quot_lo, __d> ::__hi, __big_mul< __quot_lo, __d> ::__lo, __big_mul< __quot_hi, __d> ::__lo, __rem>  _Sum; 
# 238
static_assert((_P1::__hi == 0), "Internal library error");
# 239
static_assert((_Sum::__hi >= _P0::__hi), "Internal library error");
# 241
static_assert(((_Sum::__hi == __n1) && (_Sum::__lo == __n0)), "Internal library error");
# 243
static_assert((__rem < __d), "Internal library error");
# 244
}; 
# 260 "/usr/include/c++/9/ratio" 3
template< intmax_t _Num, intmax_t _Den = 1L> 
# 261
struct ratio { 
# 263
static_assert((_Den != (0)), "denominator cannot be zero");
# 264
static_assert(((_Num >= (-9223372036854775807L)) && (_Den >= (-9223372036854775807L))), "out of range");
# 268
static constexpr intmax_t num = ((_Num * __static_sign< _Den> ::value) / __static_gcd< _Num, _Den> ::value); 
# 271
static constexpr intmax_t den = (__static_abs< _Den> ::value / __static_gcd< _Num, _Den> ::value); 
# 274
typedef ratio< num, den>  type; 
# 275
}; 
# 277
template< intmax_t _Num, intmax_t _Den> constexpr intmax_t ratio< _Num, _Den> ::num; 
# 280
template< intmax_t _Num, intmax_t _Den> constexpr intmax_t ratio< _Num, _Den> ::den; 
# 283
template< class _R1, class _R2> 
# 284
struct __ratio_multiply { 
# 287
private: static const intmax_t __gcd1 = (__static_gcd< _R1::num, _R2::den> ::value); 
# 289
static const intmax_t __gcd2 = (__static_gcd< _R2::num, _R1::den> ::value); 
# 297
public: typedef ratio< __safe_multiply< _R1::num / __gcd1, _R2::num / __gcd2> ::value, __safe_multiply< _R1::den / __gcd2, _R2::den / __gcd1> ::value>  type; 
# 299
static constexpr intmax_t num = (type::num); 
# 300
static constexpr intmax_t den = (type::den); 
# 301
}; 
# 303
template< class _R1, class _R2> constexpr intmax_t __ratio_multiply< _R1, _R2> ::num; 
# 306
template< class _R1, class _R2> constexpr intmax_t __ratio_multiply< _R1, _R2> ::den; 
# 310
template< class _R1, class _R2> using ratio_multiply = typename __ratio_multiply< _R1, _R2> ::type; 
# 313
template< class _R1, class _R2> 
# 314
struct __ratio_divide { 
# 316
static_assert((_R2::num != 0), "division by 0");
# 320
typedef typename __ratio_multiply< _R1, ratio< _R2::den, _R2::num> > ::type type; 
# 322
static constexpr intmax_t num = (type::num); 
# 323
static constexpr intmax_t den = (type::den); 
# 324
}; 
# 326
template< class _R1, class _R2> constexpr intmax_t __ratio_divide< _R1, _R2> ::num; 
# 329
template< class _R1, class _R2> constexpr intmax_t __ratio_divide< _R1, _R2> ::den; 
# 333
template< class _R1, class _R2> using ratio_divide = typename __ratio_divide< _R1, _R2> ::type; 
# 337
template< class _R1, class _R2> 
# 338
struct ratio_equal : public integral_constant< bool, (_R1::num == _R2::num) && (_R1::den == _R2::den)>  { 
# 340
}; 
# 343
template< class _R1, class _R2> 
# 344
struct ratio_not_equal : public integral_constant< bool, !ratio_equal< _R1, _R2> ::value>  { 
# 346
}; 
# 349
template< class _R1, class _R2, class 
# 350
_Left = __big_mul< _R1::num, _R2::den> , class 
# 351
_Right = __big_mul< _R2::num, _R1::den> > 
# 352
struct __ratio_less_impl_1 : public integral_constant< bool, __big_less< _Left::__hi, _Left::__lo, _Right::__hi, _Right::__lo> ::value>  { 
# 355
}; 
# 357
template< class _R1, class _R2, bool 
# 358
 = ((_R1::num == 0) || (_R2::num == 0)) || (__static_sign< _R1::num> ::value != __static_sign< _R2::num> ::value), bool 
# 361
 = (__static_sign< _R1::num> ::value == (-1)) && (__static_sign< _R2::num> ::value == (-1))> 
# 363
struct __ratio_less_impl : public __ratio_less_impl_1< _R1, _R2> ::type { 
# 365
}; 
# 367
template< class _R1, class _R2> 
# 368
struct __ratio_less_impl< _R1, _R2, true, false>  : public integral_constant< bool, _R1::num < _R2::num>  { 
# 370
}; 
# 372
template< class _R1, class _R2> 
# 373
struct __ratio_less_impl< _R1, _R2, false, true>  : public __ratio_less_impl_1< ratio< -_R2::num, _R2::den> , ratio< -_R1::num, _R1::den> > ::type { 
# 376
}; 
# 379
template< class _R1, class _R2> 
# 380
struct ratio_less : public __ratio_less_impl< _R1, _R2> ::type { 
# 382
}; 
# 385
template< class _R1, class _R2> 
# 386
struct ratio_less_equal : public integral_constant< bool, !ratio_less< _R2, _R1> ::value>  { 
# 388
}; 
# 391
template< class _R1, class _R2> 
# 392
struct ratio_greater : public integral_constant< bool, ratio_less< _R2, _R1> ::value>  { 
# 394
}; 
# 397
template< class _R1, class _R2> 
# 398
struct ratio_greater_equal : public integral_constant< bool, !ratio_less< _R1, _R2> ::value>  { 
# 400
}; 
# 419 "/usr/include/c++/9/ratio" 3
template< class _R1, class _R2, bool 
# 420
 = _R1::num >= 0, bool 
# 421
 = _R2::num >= 0, bool 
# 422
 = ratio_less< ratio< __static_abs< _R1::num> ::value, _R1::den> , ratio< __static_abs< _R2::num> ::value, _R2::den> > ::value> 
# 424
struct __ratio_add_impl { 
# 429
private: typedef typename __ratio_add_impl< ratio< -_R1::num, _R1::den> , ratio< -_R2::num, _R2::den> > ::type __t; 
# 431
public: typedef ratio< -__ratio_add_impl< ratio< -_R1::num, _R1::den> , ratio< -_R2::num, _R2::den> > ::type::num, __ratio_add_impl< ratio< -_R1::num, _R1::den> , ratio< -_R2::num, _R2::den> > ::type::den>  type; 
# 432
}; 
# 435
template< class _R1, class _R2, bool __b> 
# 436
struct __ratio_add_impl< _R1, _R2, true, true, __b>  { 
# 439
private: static constexpr uintmax_t __g = (__static_gcd< _R1::den, _R2::den> ::value); 
# 440
static constexpr uintmax_t __d2 = (_R2::den / __g); 
# 441
typedef __big_mul< _R1::den, __d2>  __d; 
# 442
typedef __big_mul< _R1::num, _R2::den / __g>  __x; 
# 443
typedef __big_mul< _R2::num, _R1::den / __g>  __y; 
# 444
typedef __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo>  __n; 
# 445
static_assert((__n::__hi >= __x::__hi), "Internal library error");
# 446
typedef __big_div< __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__hi, __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__lo, __g>  __ng; 
# 447
static constexpr uintmax_t __g2 = (__static_gcd< __big_div< __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__hi, __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__lo, __g> ::__rem, __g> ::value); 
# 448
typedef __big_div< __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__hi, __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__lo, __g2>  __n_final; 
# 449
static_assert((__n_final::__rem == 0), "Internal library error");
# 450
static_assert(((__n_final::__quot_hi == 0) && (__n_final::__quot_lo <= 9223372036854775807L)), "overflow in addition");
# 452
typedef __big_mul< _R1::den / __g2, __d2>  __d_final; 
# 453
static_assert(((__d_final::__hi == 0) && (__d_final::__lo <= 9223372036854775807L)), "overflow in addition");
# 456
public: typedef ratio< __big_div< __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__hi, __big_add< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< _R2::num, _R1::den / __g> ::__hi, __big_mul< _R2::num, _R1::den / __g> ::__lo> ::__lo, __g2> ::__quot_lo, __big_mul< _R1::den / __g2, __d2> ::__lo>  type; 
# 457
}; 
# 459
template< class _R1, class _R2> 
# 460
struct __ratio_add_impl< _R1, _R2, false, true, true>  : public std::__ratio_add_impl< _R2, _R1>  { 
# 462
}; 
# 465
template< class _R1, class _R2> 
# 466
struct __ratio_add_impl< _R1, _R2, true, false, false>  { 
# 469
private: static constexpr uintmax_t __g = (__static_gcd< _R1::den, _R2::den> ::value); 
# 470
static constexpr uintmax_t __d2 = (_R2::den / __g); 
# 471
typedef __big_mul< _R1::den, __d2>  __d; 
# 472
typedef __big_mul< _R1::num, _R2::den / __g>  __x; 
# 473
typedef __big_mul< -_R2::num, _R1::den / __g>  __y; 
# 474
typedef __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo>  __n; 
# 475
typedef __big_div< __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__hi, __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__lo, __g>  __ng; 
# 476
static constexpr uintmax_t __g2 = (__static_gcd< __big_div< __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__hi, __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__lo, __g> ::__rem, __g> ::value); 
# 477
typedef __big_div< __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__hi, __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__lo, __g2>  __n_final; 
# 478
static_assert((__n_final::__rem == 0), "Internal library error");
# 479
static_assert(((__n_final::__quot_hi == 0) && (__n_final::__quot_lo <= 9223372036854775807L)), "overflow in addition");
# 481
typedef __big_mul< _R1::den / __g2, __d2>  __d_final; 
# 482
static_assert(((__d_final::__hi == 0) && (__d_final::__lo <= 9223372036854775807L)), "overflow in addition");
# 485
public: typedef ratio< __big_div< __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__hi, __big_sub< __big_mul< _R1::num, _R2::den / __g> ::__hi, __big_mul< _R1::num, _R2::den / __g> ::__lo, __big_mul< -_R2::num, _R1::den / __g> ::__hi, __big_mul< -_R2::num, _R1::den / __g> ::__lo> ::__lo, __g2> ::__quot_lo, __big_mul< _R1::den / __g2, __d2> ::__lo>  type; 
# 486
}; 
# 488
template< class _R1, class _R2> 
# 489
struct __ratio_add { 
# 491
typedef typename __ratio_add_impl< _R1, _R2> ::type type; 
# 492
static constexpr intmax_t num = (type::num); 
# 493
static constexpr intmax_t den = (type::den); 
# 494
}; 
# 496
template< class _R1, class _R2> constexpr intmax_t __ratio_add< _R1, _R2> ::num; 
# 499
template< class _R1, class _R2> constexpr intmax_t __ratio_add< _R1, _R2> ::den; 
# 503
template< class _R1, class _R2> using ratio_add = typename __ratio_add< _R1, _R2> ::type; 
# 506
template< class _R1, class _R2> 
# 507
struct __ratio_subtract { 
# 511
typedef typename __ratio_add< _R1, ratio< -_R2::num, _R2::den> > ::type type; 
# 513
static constexpr intmax_t num = (type::num); 
# 514
static constexpr intmax_t den = (type::den); 
# 515
}; 
# 517
template< class _R1, class _R2> constexpr intmax_t __ratio_subtract< _R1, _R2> ::num; 
# 520
template< class _R1, class _R2> constexpr intmax_t __ratio_subtract< _R1, _R2> ::den; 
# 524
template< class _R1, class _R2> using ratio_subtract = typename __ratio_subtract< _R1, _R2> ::type; 
# 528
typedef ratio< 1L, 1000000000000000000L>  atto; 
# 529
typedef ratio< 1L, 1000000000000000L>  femto; 
# 530
typedef ratio< 1L, 1000000000000L>  pico; 
# 531
typedef ratio< 1L, 1000000000L>  nano; 
# 532
typedef ratio< 1L, 1000000L>  micro; 
# 533
typedef ratio< 1L, 1000L>  milli; 
# 534
typedef ratio< 1L, 100L>  centi; 
# 535
typedef ratio< 1L, 10L>  deci; 
# 536
typedef ratio< 10L, 1L>  deca; 
# 537
typedef ratio< 100L, 1L>  hecto; 
# 538
typedef ratio< 1000L, 1L>  kilo; 
# 539
typedef ratio< 1000000L, 1L>  mega; 
# 540
typedef ratio< 1000000000L, 1L>  giga; 
# 541
typedef ratio< 1000000000000L, 1L>  tera; 
# 542
typedef ratio< 1000000000000000L, 1L>  peta; 
# 543
typedef ratio< 1000000000000000000L, 1L>  exa; 
# 547
}
# 58 "/usr/include/c++/9/ctime" 3
namespace std { 
# 60
using ::clock_t;
# 61
using ::time_t;
# 62
using ::tm;
# 64
using ::clock;
# 65
using ::difftime;
# 66
using ::mktime;
# 67
using ::time;
# 68
using ::asctime;
# 69
using ::ctime;
# 70
using ::gmtime;
# 71
using ::localtime;
# 72
using ::strftime;
# 73
}
# 41 "/usr/include/c++/9/bits/parse_numbers.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 45
namespace __parse_int { 
# 47
template< unsigned _Base, char _Dig> struct _Digit; 
# 50
template< unsigned _Base> 
# 51
struct _Digit< _Base, '0'>  : public integral_constant< unsigned, 0U>  { 
# 53
using __valid = true_type; 
# 54
}; 
# 56
template< unsigned _Base> 
# 57
struct _Digit< _Base, '1'>  : public integral_constant< unsigned, 1U>  { 
# 59
using __valid = true_type; 
# 60
}; 
# 62
template< unsigned _Base, unsigned _Val> 
# 63
struct _Digit_impl : public integral_constant< unsigned, _Val>  { 
# 65
static_assert((_Base > _Val), "invalid digit");
# 66
using __valid = std::true_type; 
# 67
}; 
# 69
template< unsigned _Base> 
# 70
struct _Digit< _Base, '2'>  : public _Digit_impl< _Base, 2U>  { 
# 71
}; 
# 73
template< unsigned _Base> 
# 74
struct _Digit< _Base, '3'>  : public _Digit_impl< _Base, 3U>  { 
# 75
}; 
# 77
template< unsigned _Base> 
# 78
struct _Digit< _Base, '4'>  : public _Digit_impl< _Base, 4U>  { 
# 79
}; 
# 81
template< unsigned _Base> 
# 82
struct _Digit< _Base, '5'>  : public _Digit_impl< _Base, 5U>  { 
# 83
}; 
# 85
template< unsigned _Base> 
# 86
struct _Digit< _Base, '6'>  : public _Digit_impl< _Base, 6U>  { 
# 87
}; 
# 89
template< unsigned _Base> 
# 90
struct _Digit< _Base, '7'>  : public _Digit_impl< _Base, 7U>  { 
# 91
}; 
# 93
template< unsigned _Base> 
# 94
struct _Digit< _Base, '8'>  : public _Digit_impl< _Base, 8U>  { 
# 95
}; 
# 97
template< unsigned _Base> 
# 98
struct _Digit< _Base, '9'>  : public _Digit_impl< _Base, 9U>  { 
# 99
}; 
# 101
template< unsigned _Base> 
# 102
struct _Digit< _Base, 'a'>  : public _Digit_impl< _Base, 10U>  { 
# 103
}; 
# 105
template< unsigned _Base> 
# 106
struct _Digit< _Base, 'A'>  : public _Digit_impl< _Base, 10U>  { 
# 107
}; 
# 109
template< unsigned _Base> 
# 110
struct _Digit< _Base, 'b'>  : public _Digit_impl< _Base, 11U>  { 
# 111
}; 
# 113
template< unsigned _Base> 
# 114
struct _Digit< _Base, 'B'>  : public _Digit_impl< _Base, 11U>  { 
# 115
}; 
# 117
template< unsigned _Base> 
# 118
struct _Digit< _Base, 'c'>  : public _Digit_impl< _Base, 12U>  { 
# 119
}; 
# 121
template< unsigned _Base> 
# 122
struct _Digit< _Base, 'C'>  : public _Digit_impl< _Base, 12U>  { 
# 123
}; 
# 125
template< unsigned _Base> 
# 126
struct _Digit< _Base, 'd'>  : public _Digit_impl< _Base, 13U>  { 
# 127
}; 
# 129
template< unsigned _Base> 
# 130
struct _Digit< _Base, 'D'>  : public _Digit_impl< _Base, 13U>  { 
# 131
}; 
# 133
template< unsigned _Base> 
# 134
struct _Digit< _Base, 'e'>  : public _Digit_impl< _Base, 14U>  { 
# 135
}; 
# 137
template< unsigned _Base> 
# 138
struct _Digit< _Base, 'E'>  : public _Digit_impl< _Base, 14U>  { 
# 139
}; 
# 141
template< unsigned _Base> 
# 142
struct _Digit< _Base, 'f'>  : public _Digit_impl< _Base, 15U>  { 
# 143
}; 
# 145
template< unsigned _Base> 
# 146
struct _Digit< _Base, 'F'>  : public _Digit_impl< _Base, 15U>  { 
# 147
}; 
# 150
template< unsigned _Base> 
# 151
struct _Digit< _Base, '\''>  : public integral_constant< unsigned, 0U>  { 
# 153
using __valid = false_type; 
# 154
}; 
# 158
template< unsigned long long _Val> using __ull_constant = integral_constant< unsigned long long, _Val> ; 
# 161
template< unsigned _Base, char _Dig, char ..._Digs> 
# 162
struct _Power_help { 
# 164
using __next = typename _Power_help< _Base, _Digs...> ::type; 
# 165
using __valid_digit = typename _Digit< _Base, _Dig> ::__valid; 
# 166
using type = __ull_constant< _Power_help< _Base, _Digs...> ::type::value * ((__valid_digit{}) ? _Base : 1ULL)> ; 
# 168
}; 
# 170
template< unsigned _Base, char _Dig> 
# 171
struct _Power_help< _Base, _Dig>  { 
# 173
using __valid_digit = typename _Digit< _Base, _Dig> ::__valid; 
# 174
using type = __ull_constant< _Digit< _Base, _Dig> ::__valid::value> ; 
# 175
}; 
# 177
template< unsigned _Base, char ..._Digs> 
# 178
struct _Power : public _Power_help< _Base, _Digs...> ::type { 
# 179
}; 
# 181
template< unsigned _Base> 
# 182
struct _Power< _Base>  : public __ull_constant< 0ULL>  { 
# 183
}; 
# 187
template< unsigned _Base, unsigned long long _Pow, char _Dig, char ..._Digs> 
# 188
struct _Number_help { 
# 190
using __digit = _Digit< _Base, _Dig> ; 
# 191
using __valid_digit = typename _Digit< _Base, _Dig> ::__valid; 
# 192
using __next = _Number_help< _Base, (_Digit< _Base, _Dig> ::__valid::value) ? _Pow / (_Base) : _Pow, _Digs...> ; 
# 195
using type = __ull_constant< (_Pow * _Digit< _Base, _Dig> ::value) + _Number_help< _Base, (_Digit< _Base, _Dig> ::__valid::value) ? _Pow / (_Base) : _Pow, _Digs...> ::type::value> ; 
# 196
static_assert(((type::value / _Pow) == __digit::value), "integer literal does not fit in unsigned long long");
# 198
}; 
# 201
template< unsigned _Base, unsigned long long _Pow, char _Dig, char ..._Digs> 
# 202
struct _Number_help< _Base, _Pow, '\'', _Dig, _Digs...>  : public __parse_int::_Number_help< _Base, _Pow, _Dig, _Digs...>  { 
# 204
}; 
# 207
template< unsigned _Base, char _Dig> 
# 208
struct _Number_help< _Base, 1ULL, _Dig>  { 
# 210
using type = __ull_constant< _Digit< _Base, _Dig> ::value> ; 
# 211
}; 
# 213
template< unsigned _Base, char ..._Digs> 
# 214
struct _Number : public _Number_help< _Base, _Power< _Base, _Digs...> ::value, _Digs...> ::type { 
# 216
}; 
# 218
template< unsigned _Base> 
# 219
struct _Number< _Base>  : public __ull_constant< 0ULL>  { 
# 221
}; 
# 225
template< char ..._Digs> struct _Parse_int; 
# 228
template< char ..._Digs> 
# 229
struct _Parse_int< '0', 'b', _Digs...>  : public _Number< 2U, _Digs...> ::type { 
# 231
}; 
# 233
template< char ..._Digs> 
# 234
struct _Parse_int< '0', 'B', _Digs...>  : public _Number< 2U, _Digs...> ::type { 
# 236
}; 
# 238
template< char ..._Digs> 
# 239
struct _Parse_int< '0', 'x', _Digs...>  : public _Number< 16U, _Digs...> ::type { 
# 241
}; 
# 243
template< char ..._Digs> 
# 244
struct _Parse_int< '0', 'X', _Digs...>  : public _Number< 16U, _Digs...> ::type { 
# 246
}; 
# 248
template< char ..._Digs> 
# 249
struct _Parse_int< '0', _Digs...>  : public _Number< 8U, _Digs...> ::type { 
# 251
}; 
# 253
template< char ..._Digs> 
# 254
struct _Parse_int : public _Number< 10U, _Digs...> ::type { 
# 256
}; 
# 258
}
# 261
namespace __select_int { 
# 263
template< unsigned long long _Val, class ..._Ints> struct _Select_int_base; 
# 266
template< unsigned long long _Val, class _IntType, class ..._Ints> 
# 267
struct _Select_int_base< _Val, _IntType, _Ints...>  : public std::conditional_t< _Val <= numeric_limits< _IntType> ::max(), integral_constant< _IntType, _Val> , __select_int::_Select_int_base< _Val, _Ints...> >  { 
# 271
}; 
# 273
template< unsigned long long _Val> 
# 274
struct _Select_int_base< _Val>  { 
# 275
}; 
# 277
template< char ..._Digs> using _Select_int = typename _Select_int_base< __parse_int::_Parse_int< _Digs...> ::value, unsigned char, unsigned short, unsigned, unsigned long, unsigned long long> ::type; 
# 287
}
# 290
}
# 44 "/usr/include/c++/9/chrono" 3
namespace std __attribute((__visibility__("default"))) { 
# 59 "/usr/include/c++/9/chrono" 3
namespace chrono { 
# 61
template< class _Rep, class _Period = ratio< 1> > struct duration; 
# 64
template< class _Clock, class _Dur = typename _Clock::duration> struct time_point; 
# 66
}
# 70
template< class _CT, class _Period1, class _Period2> 
# 71
struct __duration_common_type_wrapper { 
# 74
private: typedef __static_gcd< _Period1::num, _Period2::num>  __gcd_num; 
# 75
typedef __static_gcd< _Period1::den, _Period2::den>  __gcd_den; 
# 76
typedef typename _CT::type __cr; 
# 78
typedef ratio< __static_gcd< _Period1::num, _Period2::num> ::value, (_Period1::den / __static_gcd< _Period1::den, _Period2::den> ::value) * _Period2::den>  __r; 
# 80
public: typedef __success_type< chrono::duration< __cr, __r> >  type; 
# 81
}; 
# 83
template< class _Period1, class _Period2> 
# 84
struct __duration_common_type_wrapper< __failure_type, _Period1, _Period2>  { 
# 85
typedef __failure_type type; }; 
# 87
template< class _Rep1, class _Period1, class _Rep2, class _Period2> 
# 88
struct common_type< chrono::duration< _Rep1, _Period1> , chrono::duration< _Rep2, _Period2> >  : public __duration_common_type_wrapper< typename __member_type_wrapper< std::common_type< _Rep1, _Rep2> > ::type, _Period1, _Period2> ::type { 
# 92
}; 
# 96
template< class _CT, class _Clock> 
# 97
struct __timepoint_common_type_wrapper { 
# 100
typedef __success_type< chrono::time_point< _Clock, typename _CT::type> >  type; 
# 101
}; 
# 103
template< class _Clock> 
# 104
struct __timepoint_common_type_wrapper< __failure_type, _Clock>  { 
# 105
typedef __failure_type type; }; 
# 107
template< class _Clock, class _Duration1, class _Duration2> 
# 108
struct common_type< chrono::time_point< _Clock, _Duration1> , chrono::time_point< _Clock, _Duration2> >  : public __timepoint_common_type_wrapper< typename __member_type_wrapper< std::common_type< _Duration1, _Duration2> > ::type, _Clock> ::type { 
# 112
}; 
# 114
namespace chrono { 
# 117
template< class _ToDur, class _CF, class _CR, bool 
# 118
_NumIsOne = false, bool _DenIsOne = false> 
# 119
struct __duration_cast_impl { 
# 121
template< class _Rep, class _Period> static constexpr _ToDur 
# 123
__cast(const duration< _Rep, _Period>  &__d) 
# 124
{ 
# 125
typedef typename _ToDur::rep __to_rep; 
# 126
return (_ToDur)(static_cast< __to_rep>(((static_cast< _CR>(__d.count())) * (static_cast< _CR>(_CF::num))) / (static_cast< _CR>(_CF::den)))); 
# 129
} 
# 130
}; 
# 132
template< class _ToDur, class _CF, class _CR> 
# 133
struct __duration_cast_impl< _ToDur, _CF, _CR, true, true>  { 
# 135
template< class _Rep, class _Period> static constexpr _ToDur 
# 137
__cast(const duration< _Rep, _Period>  &__d) 
# 138
{ 
# 139
typedef typename _ToDur::rep __to_rep; 
# 140
return (_ToDur)(static_cast< __to_rep>(__d.count())); 
# 141
} 
# 142
}; 
# 144
template< class _ToDur, class _CF, class _CR> 
# 145
struct __duration_cast_impl< _ToDur, _CF, _CR, true, false>  { 
# 147
template< class _Rep, class _Period> static constexpr _ToDur 
# 149
__cast(const duration< _Rep, _Period>  &__d) 
# 150
{ 
# 151
typedef typename _ToDur::rep __to_rep; 
# 152
return (_ToDur)(static_cast< __to_rep>((static_cast< _CR>(__d.count())) / (static_cast< _CR>(_CF::den)))); 
# 154
} 
# 155
}; 
# 157
template< class _ToDur, class _CF, class _CR> 
# 158
struct __duration_cast_impl< _ToDur, _CF, _CR, false, true>  { 
# 160
template< class _Rep, class _Period> static constexpr _ToDur 
# 162
__cast(const duration< _Rep, _Period>  &__d) 
# 163
{ 
# 164
typedef typename _ToDur::rep __to_rep; 
# 165
return (_ToDur)(static_cast< __to_rep>((static_cast< _CR>(__d.count())) * (static_cast< _CR>(_CF::num)))); 
# 167
} 
# 168
}; 
# 170
template< class _Tp> 
# 171
struct __is_duration : public false_type { 
# 173
}; 
# 175
template< class _Rep, class _Period> 
# 176
struct __is_duration< duration< _Rep, _Period> >  : public true_type { 
# 178
}; 
# 180
template< class _Tp> using __enable_if_is_duration = typename enable_if< __is_duration< _Tp> ::value, _Tp> ::type; 
# 184
template< class _Tp> using __disable_if_is_duration = typename enable_if< !__is_duration< _Tp> ::value, _Tp> ::type; 
# 189
template< class _ToDur, class _Rep, class _Period> constexpr __enable_if_is_duration< _ToDur>  
# 191
duration_cast(const duration< _Rep, _Period>  &__d) 
# 192
{ 
# 193
typedef typename _ToDur::period __to_period; 
# 194
typedef typename _ToDur::rep __to_rep; 
# 195
typedef ratio_divide< _Period, typename _ToDur::period>  __cf; 
# 197
typedef typename common_type< typename _ToDur::rep, _Rep, intmax_t> ::type __cr; 
# 199
typedef __duration_cast_impl< _ToDur, ratio_divide< _Period, typename _ToDur::period> , typename common_type< typename _ToDur::rep, _Rep, intmax_t> ::type, __ratio_divide< _Period, typename _ToDur::period> ::type::num == 1, __ratio_divide< _Period, typename _ToDur::period> ::type::den == 1>  __dc; 
# 200
return __dc::__cast(__d); 
# 201
} 
# 204
template< class _Rep> 
# 205
struct treat_as_floating_point : public is_floating_point< _Rep>  { 
# 207
}; 
# 272 "/usr/include/c++/9/chrono" 3
template< class _Rep> 
# 273
struct duration_values { 
# 276
static constexpr _Rep zero() noexcept 
# 277
{ return (_Rep)0; } 
# 280
static constexpr _Rep max() noexcept 
# 281
{ return numeric_limits< _Rep> ::max(); } 
# 284
static constexpr _Rep min() noexcept 
# 285
{ return numeric_limits< _Rep> ::lowest(); } 
# 286
}; 
# 288
template< class _Tp> 
# 289
struct __is_ratio : public false_type { 
# 291
}; 
# 293
template< intmax_t _Num, intmax_t _Den> 
# 294
struct __is_ratio< ratio< _Num, _Den> >  : public true_type { 
# 296
}; 
# 299
template< class _Rep, class _Period> 
# 300
struct duration { 
# 304
private: 
# 303
template< class _Rep2> using __is_float = treat_as_floating_point< _Rep2> ; 
# 307
template< class _Period2> using __is_harmonic = __bool_constant< __ratio_divide< _Period2, _Period> ::type::den == 1> ; 
# 313
public: typedef _Rep rep; 
# 314
typedef _Period period; 
# 316
static_assert((!__is_duration< _Rep> ::value), "rep cannot be a duration");
# 317
static_assert((__is_ratio< _Period> ::value), "period must be a specialization of ratio");
# 319
static_assert((_Period::num > 0), "period must be positive");
# 322
constexpr duration() = default;
# 324
duration(const duration &) = default;
# 328
template< class _Rep2, class  = _Require< is_convertible< const _Rep2 &, rep> , __or_< __is_float< rep> , __not_< __is_float< _Rep2> > > > > constexpr explicit 
# 331
duration(const _Rep2 &__rep) : __r(static_cast< rep>(__rep)) 
# 332
{ } 
# 334
template< class _Rep2, class _Period2, class  = _Require< __or_< __is_float< rep> , __and_< __is_harmonic< _Period2> , __not_< __is_float< _Rep2> > > > > > constexpr 
# 338
duration(const duration< _Rep2, _Period2>  &__d) : __r(duration_cast< duration> (__d).count()) 
# 339
{ } 
# 341
~duration() = default;
# 342
duration &operator=(const duration &) = default;
# 346
constexpr rep count() const 
# 347
{ return __r; } 
# 351
constexpr duration operator+() const 
# 352
{ return *this; } 
# 355
constexpr duration operator-() const 
# 356
{ return ((duration)(-(__r))); } 
# 359
duration &operator++() 
# 360
{ 
# 361
++(__r); 
# 362
return *this; 
# 363
} 
# 366
duration operator++(int) 
# 367
{ return ((duration)((__r)++)); } 
# 370
duration &operator--() 
# 371
{ 
# 372
--(__r); 
# 373
return *this; 
# 374
} 
# 377
duration operator--(int) 
# 378
{ return ((duration)((__r)--)); } 
# 381
duration &operator+=(const duration &__d) 
# 382
{ 
# 383
(__r) += __d.count(); 
# 384
return *this; 
# 385
} 
# 388
duration &operator-=(const duration &__d) 
# 389
{ 
# 390
(__r) -= __d.count(); 
# 391
return *this; 
# 392
} 
# 395
duration &operator*=(const rep &__rhs) 
# 396
{ 
# 397
(__r) *= __rhs; 
# 398
return *this; 
# 399
} 
# 402
duration &operator/=(const rep &__rhs) 
# 403
{ 
# 404
(__r) /= __rhs; 
# 405
return *this; 
# 406
} 
# 409
template< class _Rep2 = rep> typename enable_if< !treat_as_floating_point< _Rep2> ::value, duration &> ::type 
# 413
operator%=(const rep &__rhs) 
# 414
{ 
# 415
(__r) %= __rhs; 
# 416
return *this; 
# 417
} 
# 419
template< class _Rep2 = rep> typename enable_if< !treat_as_floating_point< _Rep2> ::value, duration &> ::type 
# 423
operator%=(const duration &__d) 
# 424
{ 
# 425
(__r) %= __d.count(); 
# 426
return *this; 
# 427
} 
# 431
static constexpr duration zero() noexcept 
# 432
{ return ((duration)(duration_values< rep> ::zero())); } 
# 435
static constexpr duration min() noexcept 
# 436
{ return ((duration)(duration_values< rep> ::min())); } 
# 439
static constexpr duration max() noexcept 
# 440
{ return ((duration)(duration_values< rep> ::max())); } 
# 443
private: rep __r; 
# 444
}; 
# 446
template< class _Rep1, class _Period1, class 
# 447
_Rep2, class _Period2> constexpr typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type 
# 450
operator+(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 451
__rhs) 
# 452
{ 
# 453
typedef duration< _Rep1, _Period1>  __dur1; 
# 454
typedef duration< _Rep2, _Period2>  __dur2; 
# 455
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __cd; 
# 456
return (__cd)(((__cd)__lhs).count() + ((__cd)__rhs).count()); 
# 457
} 
# 459
template< class _Rep1, class _Period1, class 
# 460
_Rep2, class _Period2> constexpr typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type 
# 463
operator-(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 464
__rhs) 
# 465
{ 
# 466
typedef duration< _Rep1, _Period1>  __dur1; 
# 467
typedef duration< _Rep2, _Period2>  __dur2; 
# 468
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __cd; 
# 469
return (__cd)(((__cd)__lhs).count() - ((__cd)__rhs).count()); 
# 470
} 
# 476
template< class _Rep1, class _Rep2, class 
# 477
_CRep = typename common_type< _Rep1, _Rep2> ::type> using __common_rep_t = typename enable_if< is_convertible< const _Rep2 &, _CRep> ::value, _CRep> ::type; 
# 481
template< class _Rep1, class _Period, class _Rep2> constexpr duration< __common_rep_t< _Rep1, _Rep2> , _Period>  
# 483
operator*(const duration< _Rep1, _Period>  &__d, const _Rep2 &__s) 
# 484
{ 
# 486
typedef duration< typename common_type< _Rep1, _Rep2> ::type, _Period>  __cd; 
# 487
return ((duration< typename common_type< _Rep1, _Rep2> ::type, _Period> )(((duration< typename common_type< _Rep1, _Rep2> ::type, _Period> )(__d)).count() * __s)); 
# 488
} 
# 490
template< class _Rep1, class _Rep2, class _Period> constexpr duration< __common_rep_t< _Rep2, _Rep1> , _Period>  
# 492
operator*(const _Rep1 &__s, const duration< _Rep2, _Period>  &__d) 
# 493
{ return __d * __s; } 
# 495
template< class _Rep1, class _Period, class _Rep2> constexpr duration< __common_rep_t< _Rep1, __disable_if_is_duration< _Rep2> > , _Period>  
# 498
operator/(const duration< _Rep1, _Period>  &__d, const _Rep2 &__s) 
# 499
{ 
# 501
typedef duration< typename common_type< _Rep1, _Rep2> ::type, _Period>  __cd; 
# 502
return ((duration< typename common_type< _Rep1, _Rep2> ::type, _Period> )(((duration< typename common_type< _Rep1, _Rep2> ::type, _Period> )(__d)).count() / __s)); 
# 503
} 
# 505
template< class _Rep1, class _Period1, class 
# 506
_Rep2, class _Period2> constexpr typename common_type< _Rep1, _Rep2> ::type 
# 508
operator/(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 509
__rhs) 
# 510
{ 
# 511
typedef duration< _Rep1, _Period1>  __dur1; 
# 512
typedef duration< _Rep2, _Period2>  __dur2; 
# 513
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __cd; 
# 514
return ((__cd)__lhs).count() / ((__cd)__rhs).count(); 
# 515
} 
# 518
template< class _Rep1, class _Period, class _Rep2> constexpr duration< __common_rep_t< _Rep1, __disable_if_is_duration< _Rep2> > , _Period>  
# 521
operator%(const duration< _Rep1, _Period>  &__d, const _Rep2 &__s) 
# 522
{ 
# 524
typedef duration< typename common_type< _Rep1, _Rep2> ::type, _Period>  __cd; 
# 525
return ((duration< typename common_type< _Rep1, _Rep2> ::type, _Period> )(((duration< typename common_type< _Rep1, _Rep2> ::type, _Period> )(__d)).count() % __s)); 
# 526
} 
# 528
template< class _Rep1, class _Period1, class 
# 529
_Rep2, class _Period2> constexpr typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type 
# 532
operator%(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 533
__rhs) 
# 534
{ 
# 535
typedef duration< _Rep1, _Period1>  __dur1; 
# 536
typedef duration< _Rep2, _Period2>  __dur2; 
# 537
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __cd; 
# 538
return (__cd)(((__cd)__lhs).count() % ((__cd)__rhs).count()); 
# 539
} 
# 542
template< class _Rep1, class _Period1, class 
# 543
_Rep2, class _Period2> constexpr bool 
# 545
operator==(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 546
__rhs) 
# 547
{ 
# 548
typedef duration< _Rep1, _Period1>  __dur1; 
# 549
typedef duration< _Rep2, _Period2>  __dur2; 
# 550
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __ct; 
# 551
return ((__ct)__lhs).count() == ((__ct)__rhs).count(); 
# 552
} 
# 554
template< class _Rep1, class _Period1, class 
# 555
_Rep2, class _Period2> constexpr bool 
# 557
operator<(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 558
__rhs) 
# 559
{ 
# 560
typedef duration< _Rep1, _Period1>  __dur1; 
# 561
typedef duration< _Rep2, _Period2>  __dur2; 
# 562
typedef typename common_type< duration< _Rep1, _Period1> , duration< _Rep2, _Period2> > ::type __ct; 
# 563
return ((__ct)__lhs).count() < ((__ct)__rhs).count(); 
# 564
} 
# 566
template< class _Rep1, class _Period1, class 
# 567
_Rep2, class _Period2> constexpr bool 
# 569
operator!=(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 570
__rhs) 
# 571
{ return !(__lhs == __rhs); } 
# 573
template< class _Rep1, class _Period1, class 
# 574
_Rep2, class _Period2> constexpr bool 
# 576
operator<=(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 577
__rhs) 
# 578
{ return !(__rhs < __lhs); } 
# 580
template< class _Rep1, class _Period1, class 
# 581
_Rep2, class _Period2> constexpr bool 
# 583
operator>(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 584
__rhs) 
# 585
{ return __rhs < __lhs; } 
# 587
template< class _Rep1, class _Period1, class 
# 588
_Rep2, class _Period2> constexpr bool 
# 590
operator>=(const duration< _Rep1, _Period1>  &__lhs, const duration< _Rep2, _Period2>  &
# 591
__rhs) 
# 592
{ return !(__lhs < __rhs); } 
# 605 "/usr/include/c++/9/chrono" 3
typedef duration< signed long, ratio< 1L, 1000000000L> >  nanoseconds; 
# 608
typedef duration< signed long, ratio< 1L, 1000000L> >  microseconds; 
# 611
typedef duration< signed long, ratio< 1L, 1000L> >  milliseconds; 
# 614
typedef duration< signed long>  seconds; 
# 617
typedef duration< signed long, ratio< 60L> >  minutes; 
# 620
typedef duration< signed long, ratio< 3600L> >  hours; 
# 625
template< class _Clock, class _Dur> 
# 626
struct time_point { 
# 628
typedef _Clock clock; 
# 629
typedef _Dur duration; 
# 630
typedef typename _Dur::rep rep; 
# 631
typedef typename _Dur::period period; 
# 633
constexpr time_point() : __d(duration::zero()) 
# 634
{ } 
# 636
constexpr explicit time_point(const duration &__dur) : __d(__dur) 
# 638
{ } 
# 641
template< class _Dur2, class 
# 642
 = _Require< is_convertible< _Dur2, _Dur> > > constexpr 
# 643
time_point(const time_point< clock, _Dur2>  &__t) : __d(__t.time_since_epoch()) 
# 645
{ } 
# 649
constexpr duration time_since_epoch() const 
# 650
{ return __d; } 
# 654
time_point &operator+=(const duration &__dur) 
# 655
{ 
# 656
(__d) += __dur; 
# 657
return *this; 
# 658
} 
# 661
time_point &operator-=(const duration &__dur) 
# 662
{ 
# 663
(__d) -= __dur; 
# 664
return *this; 
# 665
} 
# 669
static constexpr time_point min() noexcept 
# 670
{ return ((time_point)(duration::min())); } 
# 673
static constexpr time_point max() noexcept 
# 674
{ return ((time_point)(duration::max())); } 
# 677
private: duration __d; 
# 678
}; 
# 681
template< class _ToDur, class _Clock, class _Dur> constexpr typename enable_if< __is_duration< _ToDur> ::value, time_point< _Clock, _ToDur> > ::type 
# 684
time_point_cast(const time_point< _Clock, _Dur>  &__t) 
# 685
{ 
# 686
typedef time_point< _Clock, _ToDur>  __time_point; 
# 687
return ((time_point< _Clock, _ToDur> )(duration_cast< _ToDur> (__t.time_since_epoch()))); 
# 688
} 
# 721 "/usr/include/c++/9/chrono" 3
template< class _Clock, class _Dur1, class 
# 722
_Rep2, class _Period2> constexpr time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type>  
# 725
operator+(const time_point< _Clock, _Dur1>  &__lhs, const duration< _Rep2, _Period2>  &
# 726
__rhs) 
# 727
{ 
# 728
typedef duration< _Rep2, _Period2>  __dur2; 
# 729
typedef typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type __ct; 
# 730
typedef time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type>  __time_point; 
# 731
return ((time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type> )(__lhs.time_since_epoch() + __rhs)); 
# 732
} 
# 734
template< class _Rep1, class _Period1, class 
# 735
_Clock, class _Dur2> constexpr time_point< _Clock, typename common_type< duration< _Rep1, _Period1> , _Dur2> ::type>  
# 738
operator+(const duration< _Rep1, _Period1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 739
__rhs) 
# 740
{ 
# 741
typedef duration< _Rep1, _Period1>  __dur1; 
# 742
typedef typename common_type< duration< _Rep1, _Period1> , _Dur2> ::type __ct; 
# 743
typedef time_point< _Clock, typename common_type< duration< _Rep1, _Period1> , _Dur2> ::type>  __time_point; 
# 744
return ((time_point< _Clock, typename common_type< duration< _Rep1, _Period1> , _Dur2> ::type> )(__rhs.time_since_epoch() + __lhs)); 
# 745
} 
# 747
template< class _Clock, class _Dur1, class 
# 748
_Rep2, class _Period2> constexpr time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type>  
# 751
operator-(const time_point< _Clock, _Dur1>  &__lhs, const duration< _Rep2, _Period2>  &
# 752
__rhs) 
# 753
{ 
# 754
typedef duration< _Rep2, _Period2>  __dur2; 
# 755
typedef typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type __ct; 
# 756
typedef time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type>  __time_point; 
# 757
return ((time_point< _Clock, typename common_type< _Dur1, duration< _Rep2, _Period2> > ::type> )(__lhs.time_since_epoch() - __rhs)); 
# 758
} 
# 760
template< class _Clock, class _Dur1, class _Dur2> constexpr typename common_type< _Dur1, _Dur2> ::type 
# 762
operator-(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 763
__rhs) 
# 764
{ return __lhs.time_since_epoch() - __rhs.time_since_epoch(); } 
# 766
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 768
operator==(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 769
__rhs) 
# 770
{ return __lhs.time_since_epoch() == __rhs.time_since_epoch(); } 
# 772
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 774
operator!=(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 775
__rhs) 
# 776
{ return !(__lhs == __rhs); } 
# 778
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 780
operator<(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 781
__rhs) 
# 782
{ return __lhs.time_since_epoch() < __rhs.time_since_epoch(); } 
# 784
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 786
operator<=(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 787
__rhs) 
# 788
{ return !(__rhs < __lhs); } 
# 790
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 792
operator>(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 793
__rhs) 
# 794
{ return __rhs < __lhs; } 
# 796
template< class _Clock, class _Dur1, class _Dur2> constexpr bool 
# 798
operator>=(const time_point< _Clock, _Dur1>  &__lhs, const time_point< _Clock, _Dur2>  &
# 799
__rhs) 
# 800
{ return !(__lhs < __rhs); } 
# 821 "/usr/include/c++/9/chrono" 3
inline namespace _V2 { 
# 828
struct system_clock { 
# 830
typedef nanoseconds duration; 
# 831
typedef chrono::duration< signed long, ratio< 1L, 1000000000L> > ::rep rep; 
# 832
typedef chrono::duration< signed long, ratio< 1L, 1000000000L> > ::period period; 
# 833
typedef chrono::time_point< system_clock, chrono::duration< signed long, ratio< 1L, 1000000000L> > >  time_point; 
# 835
static_assert(((system_clock::duration::min()) < (system_clock::duration::zero())), "a clock\'s minimum duration cannot be less than its epoch");
# 839
static constexpr bool is_steady = false; 
# 842
static time_point now() noexcept; 
# 846
static time_t to_time_t(const time_point &__t) noexcept 
# 847
{ 
# 848
return (time_t)duration_cast< chrono::duration< signed long> > (__t.time_since_epoch()).count(); 
# 850
} 
# 853
static time_point from_time_t(time_t __t) noexcept 
# 854
{ 
# 855
typedef chrono::time_point< system_clock, chrono::duration< signed long> >  __from; 
# 856
return time_point_cast< chrono::duration< signed long, ratio< 1L, 1000000000L> > > (((chrono::time_point< system_clock, chrono::duration< signed long> > )(((chrono::duration< signed long> )(__t))))); 
# 858
} 
# 859
}; 
# 867
struct steady_clock { 
# 869
typedef nanoseconds duration; 
# 870
typedef chrono::duration< signed long, ratio< 1L, 1000000000L> > ::rep rep; 
# 871
typedef chrono::duration< signed long, ratio< 1L, 1000000000L> > ::period period; 
# 872
typedef chrono::time_point< steady_clock, chrono::duration< signed long, ratio< 1L, 1000000000L> > >  time_point; 
# 874
static constexpr bool is_steady = true; 
# 877
static time_point now() noexcept; 
# 878
}; 
# 888 "/usr/include/c++/9/chrono" 3
using high_resolution_clock = system_clock; 
# 890
}
# 891
}
# 897
inline namespace literals { 
# 899
inline namespace chrono_literals { 
# 901
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
template< class _Dur, char ..._Digits> constexpr _Dur 
# 904
__check_overflow() 
# 905
{ 
# 906
using _Val = __parse_int::_Parse_int< _Digits...> ; 
# 907
constexpr typename _Dur::rep __repval = (_Val::value); 
# 908
static_assert(((__repval >= 0) && (__repval == _Val::value)), "literal value cannot be represented by duration type");
# 910
return (_Dur)__repval; 
# 911
} 
# 914
constexpr chrono::duration< long double, ratio< 3600L> >  operator ""h(long double __hours) 
# 915
{ return chrono::duration< long double, ratio< 3600L> > {__hours}; } 
# 917
template< char ..._Digits> constexpr chrono::hours 
# 919
operator ""h() 
# 920
{ return __check_overflow< chrono::hours, _Digits...> (); } 
# 923
constexpr chrono::duration< long double, ratio< 60L> >  operator ""min(long double __mins) 
# 924
{ return chrono::duration< long double, ratio< 60L> > {__mins}; } 
# 926
template< char ..._Digits> constexpr chrono::minutes 
# 928
operator ""min() 
# 929
{ return __check_overflow< chrono::minutes, _Digits...> (); } 
# 932
constexpr chrono::duration< long double>  operator ""s(long double __secs) 
# 933
{ return chrono::duration< long double> {__secs}; } 
# 935
template< char ..._Digits> constexpr chrono::seconds 
# 937
operator ""s() 
# 938
{ return __check_overflow< chrono::seconds, _Digits...> (); } 
# 941
constexpr chrono::duration< long double, ratio< 1L, 1000L> >  operator ""ms(long double __msecs) 
# 942
{ return chrono::duration< long double, ratio< 1L, 1000L> > {__msecs}; } 
# 944
template< char ..._Digits> constexpr chrono::milliseconds 
# 946
operator ""ms() 
# 947
{ return __check_overflow< chrono::milliseconds, _Digits...> (); } 
# 950
constexpr chrono::duration< long double, ratio< 1L, 1000000L> >  operator ""us(long double __usecs) 
# 951
{ return chrono::duration< long double, ratio< 1L, 1000000L> > {__usecs}; } 
# 953
template< char ..._Digits> constexpr chrono::microseconds 
# 955
operator ""us() 
# 956
{ return __check_overflow< chrono::microseconds, _Digits...> (); } 
# 959
constexpr chrono::duration< long double, ratio< 1L, 1000000000L> >  operator ""ns(long double __nsecs) 
# 960
{ return chrono::duration< long double, ratio< 1L, 1000000000L> > {__nsecs}; } 
# 962
template< char ..._Digits> constexpr chrono::nanoseconds 
# 964
operator ""ns() 
# 965
{ return __check_overflow< chrono::nanoseconds, _Digits...> (); } 
# 967
#pragma GCC diagnostic pop
}
# 969
}
# 971
namespace chrono { 
# 973
using namespace literals::chrono_literals;
# 974
}
# 981
}
# 43 "/usr/include/c++/9/bits/std_mutex.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 57 "/usr/include/c++/9/bits/std_mutex.h" 3
class __mutex_base { 
# 60
protected: typedef __gthread_mutex_t __native_type; 
# 63
__native_type _M_mutex = {{0, (0), 0, (0), (PTHREAD_MUTEX_TIMED_NP), (0), (0), {(0), (0)}}}; 
# 65
constexpr __mutex_base() noexcept = default;
# 78 "/usr/include/c++/9/bits/std_mutex.h" 3
__mutex_base(const __mutex_base &) = delete;
# 79
__mutex_base &operator=(const __mutex_base &) = delete;
# 80
}; 
# 83
class mutex : private __mutex_base { 
# 86
public: typedef __gthread_mutex_t *native_handle_type; 
# 91
constexpr mutex() noexcept = default;
# 92
~mutex() = default;
# 94
mutex(const mutex &) = delete;
# 95
mutex &operator=(const mutex &) = delete;
# 98
void lock() 
# 99
{ 
# 100
int __e = __gthread_mutex_lock(&(_M_mutex)); 
# 103
if (__e) { 
# 104
__throw_system_error(__e); }  
# 105
} 
# 108
bool try_lock() noexcept 
# 109
{ 
# 111
return !(__gthread_mutex_trylock(&(_M_mutex))); 
# 112
} 
# 115
void unlock() 
# 116
{ 
# 118
__gthread_mutex_unlock(&(_M_mutex)); 
# 119
} 
# 122
native_handle_type native_handle() noexcept 
# 123
{ return &(_M_mutex); } 
# 124
}; 
# 129
struct defer_lock_t { explicit defer_lock_t() = default;}; 
# 132
struct try_to_lock_t { explicit try_to_lock_t() = default;}; 
# 136
struct adopt_lock_t { explicit adopt_lock_t() = default;}; 
# 139
constexpr defer_lock_t defer_lock{}; 
# 142
constexpr try_to_lock_t try_to_lock{}; 
# 145
constexpr adopt_lock_t adopt_lock{}; 
# 152
template< class _Mutex> 
# 153
class lock_guard { 
# 156
public: typedef _Mutex mutex_type; 
# 158
explicit lock_guard(mutex_type &__m) : _M_device(__m) 
# 159
{ (_M_device).lock(); } 
# 161
lock_guard(mutex_type &__m, adopt_lock_t) noexcept : _M_device(__m) 
# 162
{ } 
# 164
~lock_guard() 
# 165
{ (_M_device).unlock(); } 
# 167
lock_guard(const lock_guard &) = delete;
# 168
lock_guard &operator=(const lock_guard &) = delete;
# 171
private: mutex_type &_M_device; 
# 172
}; 
# 176
}
# 42 "/usr/include/c++/9/bits/unique_lock.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 58 "/usr/include/c++/9/bits/unique_lock.h" 3
template< class _Mutex> 
# 59
class unique_lock { 
# 62
public: typedef _Mutex mutex_type; 
# 64
unique_lock() noexcept : _M_device((0)), _M_owns(false) 
# 66
{ } 
# 68
explicit unique_lock(mutex_type &__m) : _M_device(std::__addressof(__m)), _M_owns(false) 
# 70
{ 
# 71
lock(); 
# 72
(_M_owns) = true; 
# 73
} 
# 75
unique_lock(mutex_type &__m, defer_lock_t) noexcept : _M_device(std::__addressof(__m)), _M_owns(false) 
# 77
{ } 
# 79
unique_lock(mutex_type &__m, try_to_lock_t) : _M_device(std::__addressof(__m)), _M_owns((_M_device)->try_lock()) 
# 81
{ } 
# 83
unique_lock(mutex_type &__m, adopt_lock_t) noexcept : _M_device(std::__addressof(__m)), _M_owns(true) 
# 85
{ 
# 87
} 
# 89
template< class _Clock, class _Duration> 
# 90
unique_lock(mutex_type &__m, const chrono::time_point< _Clock, _Duration>  &
# 91
__atime) : _M_device(std::__addressof(__m)), _M_owns((_M_device)->try_lock_until(__atime)) 
# 94
{ } 
# 96
template< class _Rep, class _Period> 
# 97
unique_lock(mutex_type &__m, const chrono::duration< _Rep, _Period>  &
# 98
__rtime) : _M_device(std::__addressof(__m)), _M_owns((_M_device)->try_lock_for(__rtime)) 
# 101
{ } 
# 103
~unique_lock() 
# 104
{ 
# 105
if (_M_owns) { 
# 106
unlock(); }  
# 107
} 
# 109
unique_lock(const unique_lock &) = delete;
# 110
unique_lock &operator=(const unique_lock &) = delete;
# 112
unique_lock(unique_lock &&__u) noexcept : _M_device(__u._M_device), _M_owns(__u._M_owns) 
# 114
{ 
# 115
(__u._M_device) = 0; 
# 116
(__u._M_owns) = false; 
# 117
} 
# 119
unique_lock &operator=(unique_lock &&__u) noexcept 
# 120
{ 
# 121
if (_M_owns) { 
# 122
unlock(); }  
# 124
((unique_lock)(std::move(__u))).swap(*this); 
# 126
(__u._M_device) = 0; 
# 127
(__u._M_owns) = false; 
# 129
return *this; 
# 130
} 
# 133
void lock() 
# 134
{ 
# 135
if (!(_M_device)) { 
# 136
__throw_system_error((int)errc::operation_not_permitted); } else { 
# 137
if (_M_owns) { 
# 138
__throw_system_error((int)errc::resource_deadlock_would_occur); } else 
# 140
{ 
# 141
(_M_device)->lock(); 
# 142
(_M_owns) = true; 
# 143
}  }  
# 144
} 
# 147
bool try_lock() 
# 148
{ 
# 149
if (!(_M_device)) { 
# 150
__throw_system_error((int)errc::operation_not_permitted); } else { 
# 151
if (_M_owns) { 
# 152
__throw_system_error((int)errc::resource_deadlock_would_occur); } else 
# 154
{ 
# 155
(_M_owns) = (_M_device)->try_lock(); 
# 156
return _M_owns; 
# 157
}  }  
# 158
} 
# 160
template< class _Clock, class _Duration> bool 
# 162
try_lock_until(const chrono::time_point< _Clock, _Duration>  &__atime) 
# 163
{ 
# 164
if (!(_M_device)) { 
# 165
__throw_system_error((int)errc::operation_not_permitted); } else { 
# 166
if (_M_owns) { 
# 167
__throw_system_error((int)errc::resource_deadlock_would_occur); } else 
# 169
{ 
# 170
(_M_owns) = (_M_device)->try_lock_until(__atime); 
# 171
return _M_owns; 
# 172
}  }  
# 173
} 
# 175
template< class _Rep, class _Period> bool 
# 177
try_lock_for(const chrono::duration< _Rep, _Period>  &__rtime) 
# 178
{ 
# 179
if (!(_M_device)) { 
# 180
__throw_system_error((int)errc::operation_not_permitted); } else { 
# 181
if (_M_owns) { 
# 182
__throw_system_error((int)errc::resource_deadlock_would_occur); } else 
# 184
{ 
# 185
(_M_owns) = (_M_device)->try_lock_for(__rtime); 
# 186
return _M_owns; 
# 187
}  }  
# 188
} 
# 191
void unlock() 
# 192
{ 
# 193
if (!(_M_owns)) { 
# 194
__throw_system_error((int)errc::operation_not_permitted); } else { 
# 195
if (_M_device) 
# 196
{ 
# 197
(_M_device)->unlock(); 
# 198
(_M_owns) = false; 
# 199
}  }  
# 200
} 
# 203
void swap(unique_lock &__u) noexcept 
# 204
{ 
# 205
std::swap(_M_device, __u._M_device); 
# 206
std::swap(_M_owns, __u._M_owns); 
# 207
} 
# 210
mutex_type *release() noexcept 
# 211
{ 
# 212
mutex_type *__ret = _M_device; 
# 213
(_M_device) = 0; 
# 214
(_M_owns) = false; 
# 215
return __ret; 
# 216
} 
# 219
bool owns_lock() const noexcept 
# 220
{ return _M_owns; } 
# 222
explicit operator bool() const noexcept 
# 223
{ return owns_lock(); } 
# 226
mutex_type *mutex() const noexcept 
# 227
{ return _M_device; } 
# 230
private: mutex_type *_M_device; 
# 231
bool _M_owns; 
# 232
}; 
# 235
template< class _Mutex> inline void 
# 237
swap(unique_lock< _Mutex>  &__x, unique_lock< _Mutex>  &__y) noexcept 
# 238
{ __x.swap(__y); } 
# 242
}
# 53 "/usr/include/c++/9/mutex" 3
namespace std __attribute((__visibility__("default"))) { 
# 65 "/usr/include/c++/9/mutex" 3
class __recursive_mutex_base { 
# 68
protected: typedef __gthread_recursive_mutex_t __native_type; 
# 70
__recursive_mutex_base(const __recursive_mutex_base &) = delete;
# 71
__recursive_mutex_base &operator=(const __recursive_mutex_base &) = delete;
# 74
__native_type _M_mutex = {{0, (0), 0, (0), (PTHREAD_MUTEX_RECURSIVE_NP), (0), (0), {(0), (0)}}}; 
# 76
__recursive_mutex_base() = default;
# 89 "/usr/include/c++/9/mutex" 3
}; 
# 92
class recursive_mutex : private __recursive_mutex_base { 
# 95
public: typedef __gthread_recursive_mutex_t *native_handle_type; 
# 97
recursive_mutex() = default;
# 98
~recursive_mutex() = default;
# 100
recursive_mutex(const recursive_mutex &) = delete;
# 101
recursive_mutex &operator=(const recursive_mutex &) = delete;
# 104
void lock() 
# 105
{ 
# 106
int __e = __gthread_recursive_mutex_lock(&(_M_mutex)); 
# 109
if (__e) { 
# 110
__throw_system_error(__e); }  
# 111
} 
# 114
bool try_lock() noexcept 
# 115
{ 
# 117
return !(__gthread_recursive_mutex_trylock(&(_M_mutex))); 
# 118
} 
# 121
void unlock() 
# 122
{ 
# 124
__gthread_recursive_mutex_unlock(&(_M_mutex)); 
# 125
} 
# 128
native_handle_type native_handle() noexcept 
# 129
{ return &(_M_mutex); } 
# 130
}; 
# 133
template< class _Derived> 
# 134
class __timed_mutex_impl { 
# 137
protected: typedef chrono::_V2::high_resolution_clock __clock_t; 
# 139
template< class _Rep, class _Period> bool 
# 141
_M_try_lock_for(const chrono::duration< _Rep, _Period>  &__rtime) 
# 142
{ 
# 143
using chrono::steady_clock;
# 144
auto __rt = chrono::duration_cast< chrono::_V2::steady_clock::duration> (__rtime); 
# 145
if (ratio_greater< chrono::_V2::steady_clock::period, _Period> ()) { 
# 146
++__rt; }  
# 147
return _M_try_lock_until(steady_clock::now() + __rt); 
# 148
} 
# 150
template< class _Duration> bool 
# 152
_M_try_lock_until(const chrono::time_point< __clock_t, _Duration>  &
# 153
__atime) 
# 154
{ 
# 155
auto __s = chrono::time_point_cast< chrono::seconds> (__atime); 
# 156
auto __ns = chrono::duration_cast< chrono::nanoseconds> (__atime - __s); 
# 158
__gthread_time_t __ts = {static_cast< time_t>(__s.time_since_epoch().count()), static_cast< long>(__ns.count())}; 
# 163
return (static_cast< _Derived *>(this))->_M_timedlock(__ts); 
# 164
} 
# 166
template< class _Clock, class _Duration> bool 
# 168
_M_try_lock_until(const chrono::time_point< _Clock, _Duration>  &__atime) 
# 169
{ 
# 170
auto __rtime = __atime - _Clock::now(); 
# 171
return _M_try_lock_until(__clock_t::now() + __rtime); 
# 172
} 
# 173
}; 
# 176
class timed_mutex : private __mutex_base, public __timed_mutex_impl< timed_mutex>  { 
# 180
public: typedef __gthread_mutex_t *native_handle_type; 
# 182
timed_mutex() = default;
# 183
~timed_mutex() = default;
# 185
timed_mutex(const timed_mutex &) = delete;
# 186
timed_mutex &operator=(const timed_mutex &) = delete;
# 189
void lock() 
# 190
{ 
# 191
int __e = __gthread_mutex_lock(&(_M_mutex)); 
# 194
if (__e) { 
# 195
__throw_system_error(__e); }  
# 196
} 
# 199
bool try_lock() noexcept 
# 200
{ 
# 202
return !(__gthread_mutex_trylock(&(_M_mutex))); 
# 203
} 
# 205
template< class _Rep, class _Period> bool 
# 207
try_lock_for(const chrono::duration< _Rep, _Period>  &__rtime) 
# 208
{ return _M_try_lock_for(__rtime); } 
# 210
template< class _Clock, class _Duration> bool 
# 212
try_lock_until(const chrono::time_point< _Clock, _Duration>  &__atime) 
# 213
{ return _M_try_lock_until(__atime); } 
# 216
void unlock() 
# 217
{ 
# 219
__gthread_mutex_unlock(&(_M_mutex)); 
# 220
} 
# 223
native_handle_type native_handle() noexcept 
# 224
{ return &(_M_mutex); } 
# 227
friend class std::__timed_mutex_impl< timed_mutex> ; 
# 230
private: bool _M_timedlock(const __gthread_time_t &__ts) 
# 231
{ return !(__gthread_mutex_timedlock(&(_M_mutex), &__ts)); } 
# 232
}; 
# 235
class recursive_timed_mutex : private __recursive_mutex_base, public __timed_mutex_impl< recursive_timed_mutex>  { 
# 240
public: typedef __gthread_recursive_mutex_t *native_handle_type; 
# 242
recursive_timed_mutex() = default;
# 243
~recursive_timed_mutex() = default;
# 245
recursive_timed_mutex(const recursive_timed_mutex &) = delete;
# 246
recursive_timed_mutex &operator=(const recursive_timed_mutex &) = delete;
# 249
void lock() 
# 250
{ 
# 251
int __e = __gthread_recursive_mutex_lock(&(_M_mutex)); 
# 254
if (__e) { 
# 255
__throw_system_error(__e); }  
# 256
} 
# 259
bool try_lock() noexcept 
# 260
{ 
# 262
return !(__gthread_recursive_mutex_trylock(&(_M_mutex))); 
# 263
} 
# 265
template< class _Rep, class _Period> bool 
# 267
try_lock_for(const chrono::duration< _Rep, _Period>  &__rtime) 
# 268
{ return _M_try_lock_for(__rtime); } 
# 270
template< class _Clock, class _Duration> bool 
# 272
try_lock_until(const chrono::time_point< _Clock, _Duration>  &__atime) 
# 273
{ return _M_try_lock_until(__atime); } 
# 276
void unlock() 
# 277
{ 
# 279
__gthread_recursive_mutex_unlock(&(_M_mutex)); 
# 280
} 
# 283
native_handle_type native_handle() noexcept 
# 284
{ return &(_M_mutex); } 
# 287
friend class std::__timed_mutex_impl< recursive_timed_mutex> ; 
# 290
private: bool _M_timedlock(const __gthread_time_t &__ts) 
# 291
{ return !(__gthread_recursive_mutex_timedlock(&(_M_mutex), &__ts)); } 
# 292
}; 
# 466 "/usr/include/c++/9/mutex" 3
template< class _Lock> inline unique_lock< _Lock>  
# 468
__try_to_lock(_Lock &__l) 
# 469
{ return unique_lock< _Lock> {__l, try_to_lock}; } 
# 471
template< int _Idx, bool _Continue = true> 
# 472
struct __try_lock_impl { 
# 474
template< class ..._Lock> static void 
# 476
__do_try_lock(tuple< _Lock &...>  &__locks, int &__idx) 
# 477
{ 
# 478
__idx = _Idx; 
# 479
auto __lock = std::__try_to_lock(std::get< _Idx> (__locks)); 
# 480
if (__lock.owns_lock()) 
# 481
{ 
# 482
constexpr bool __cont = ((_Idx + 2) < sizeof...(_Lock)); 
# 483
using __try_locker = __try_lock_impl< _Idx + 1, __cont> ; 
# 484
__try_locker::__do_try_lock(__locks, __idx); 
# 485
if (__idx == (-1)) { 
# 486
__lock.release(); }  
# 487
}  
# 488
} 
# 489
}; 
# 491
template< int _Idx> 
# 492
struct __try_lock_impl< _Idx, false>  { 
# 494
template< class ..._Lock> static void 
# 496
__do_try_lock(tuple< _Lock &...>  &__locks, int &__idx) 
# 497
{ 
# 498
__idx = _Idx; 
# 499
auto __lock = std::__try_to_lock(std::get< _Idx> (__locks)); 
# 500
if (__lock.owns_lock()) 
# 501
{ 
# 502
__idx = (-1); 
# 503
__lock.release(); 
# 504
}  
# 505
} 
# 506
}; 
# 518 "/usr/include/c++/9/mutex" 3
template< class _Lock1, class _Lock2, class ..._Lock3> int 
# 520
try_lock(_Lock1 &__l1, _Lock2 &__l2, _Lock3 &...__l3) 
# 521
{ 
# 522
int __idx; 
# 523
auto __locks = std::tie(__l1, __l2, __l3...); 
# 524
__try_lock_impl< 0> ::__do_try_lock(__locks, __idx); 
# 525
return __idx; 
# 526
} 
# 539 "/usr/include/c++/9/mutex" 3
template< class _L1, class _L2, class ..._L3> void 
# 541
lock(_L1 &__l1, _L2 &__l2, _L3 &...__l3) 
# 542
{ 
# 543
while (true) 
# 544
{ 
# 545
using __try_locker = __try_lock_impl< 0, sizeof...(_L3) != (0)> ; 
# 546
unique_lock< _L1>  __first(__l1); 
# 547
int __idx; 
# 548
auto __locks = std::tie(__l2, __l3...); 
# 549
__try_locker::__do_try_lock(__locks, __idx); 
# 550
if (__idx == (-1)) 
# 551
{ 
# 552
__first.release(); 
# 553
return; 
# 554
}  
# 555
}  
# 556
} 
# 628 "/usr/include/c++/9/mutex" 3
struct once_flag { 
# 631
private: typedef __gthread_once_t __native_type; 
# 632
__native_type _M_once = 0; 
# 636
public: constexpr once_flag() noexcept = default;
# 639
once_flag(const once_flag &) = delete;
# 641
once_flag &operator=(const once_flag &) = delete;
# 643
template< class _Callable, class ..._Args> friend void call_once(once_flag & __once, _Callable && __f, _Args && ...__args); 
# 646
}; 
# 649
extern __thread void *__once_callable; 
# 650
extern __thread void (*__once_call)(void); 
# 661 "/usr/include/c++/9/mutex" 3
extern "C" void __once_proxy(); 
# 664
template< class _Callable, class ..._Args> void 
# 666
call_once(once_flag &__once, _Callable &&__f, _Args &&...__args) 
# 667
{ 
# 670
auto __callable = [&]{ 
# 671
std::__invoke(std::forward< _Callable> (__f), std::forward< _Args> (__args)...); 
# 673
} ; 
# 675
__once_callable = std::__addressof(__callable); 
# 676
__once_call = []{ (*((__decltype(__callable) *)__once_callable))(); } ; 
# 683
int __e = __gthread_once(&(__once._M_once), &__once_proxy); 
# 690
if (__e) { 
# 691
__throw_system_error(__e); }  
# 692
} 
# 697
}
# 65 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
namespace cv { 
# 100 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
template< class _Tp, size_t fixed_size = ((1024) / sizeof(_Tp)) + (8)> class AutoBuffer { 
# 104
public: typedef _Tp value_type; 
# 107
inline AutoBuffer(); 
# 109
inline explicit AutoBuffer(size_t _size); 
# 112
inline AutoBuffer(const AutoBuffer & buf); 
# 114
inline AutoBuffer &operator=(const AutoBuffer & buf); 
# 117
inline ~AutoBuffer(); 
# 120
inline void allocate(size_t _size); 
# 122
inline void deallocate(); 
# 124
inline void resize(size_t _size); 
# 126
inline size_t size() const; 
# 128
_Tp *data() { return ptr; } 
# 130
const _Tp *data() const { return ptr; } 
# 134
operator _Tp *() { return ptr; } 
# 136
operator const _Tp *() const { return ptr; } 
# 146
protected: _Tp *ptr; 
# 148
size_t sz; 
# 150
_Tp buf[(fixed_size > (0)) ? fixed_size : (1)]; 
# 151
}; 
# 160 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
bool setBreakOnError(bool flag); 
# 162
extern "C" { typedef int (*ErrorCallback)(int status, const char * func_name, const char * err_msg, const char * file_name, int line, void * userdata); }
# 177 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
ErrorCallback redirectError(ErrorCallback errCallback, void * userdata = 0, void ** prevUserdata = 0); 
# 179
String tempfile(const char * suffix = 0); 
# 180
void glob(String pattern, std::vector< std::__cxx11::basic_string< char> >  & result, bool recursive = false); 
# 200 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
void setNumThreads(int nthreads); 
# 218 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
int getNumThreads(); 
# 234 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
int getThreadNum(); 
# 242
const String &getBuildInformation(); 
# 250
String getVersionString(); 
# 253
int getVersionMajor(); 
# 256
int getVersionMinor(); 
# 259
int getVersionRevision(); 
# 268 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
int64 getTickCount(); 
# 281 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
double getTickFrequency(); 
# 310 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
class TickMeter { 
# 314
public: TickMeter() 
# 315
{ 
# 316
this->reset(); 
# 317
} 
# 322
void start() 
# 323
{ 
# 324
(startTime) = cv::getTickCount(); 
# 325
} 
# 330
void stop() 
# 331
{ 
# 332
int64 time = cv::getTickCount(); 
# 333
if ((startTime) == (0)) { 
# 334
return; }  
# 335
++(counter); 
# 336
(sumTime) += (time - (startTime)); 
# 337
(startTime) = (0); 
# 338
} 
# 343
int64 getTimeTicks() const 
# 344
{ 
# 345
return sumTime; 
# 346
} 
# 351
double getTimeMicro() const 
# 352
{ 
# 353
return this->getTimeMilli() * (1000.0); 
# 354
} 
# 359
double getTimeMilli() const 
# 360
{ 
# 361
return this->getTimeSec() * (1000.0); 
# 362
} 
# 367
double getTimeSec() const 
# 368
{ 
# 369
return ((double)this->getTimeTicks()) / getTickFrequency(); 
# 370
} 
# 375
int64 getCounter() const 
# 376
{ 
# 377
return counter; 
# 378
} 
# 383
void reset() 
# 384
{ 
# 385
(startTime) = (0); 
# 386
(sumTime) = (0); 
# 387
(counter) = (0); 
# 388
} 
# 391
private: int64 counter; 
# 392
int64 sumTime; 
# 393
int64 startTime; 
# 394
}; 
# 407 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
static inline std::ostream &operator<<(std::ostream &out, const TickMeter &tm) 
# 408
{ 
# 409
return (((out << (tm.getTimeSec()))) << ("sec")); 
# 410
} 
# 424 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
int64 getCPUTickCount(); 
# 434 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
bool checkHardwareSupport(int feature); 
# 440
String getHardwareFeatureName(int feature); 
# 452 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
std::string getCPUFeaturesLine(); 
# 456
int getNumberOfCPUs(); 
# 466 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
template< class _Tp> static inline _Tp *alignPtr(_Tp *ptr, int n = (int)sizeof(_Tp)) 
# 467
{ 
# 468
; 
# 469
return (_Tp *)(((((size_t)ptr) + n) - (1)) & (-n)); 
# 470
} 
# 479 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
static inline size_t alignSize(size_t sz, int n) 
# 480
{ 
# 481
; 
# 482
return ((sz + n) - (1)) & (-n); 
# 483
} 
# 491
static inline int divUp(int a, unsigned b) 
# 492
{ 
# 493
; 
# 494
return ((a + b) - (1)) / b; 
# 495
} 
# 497
static inline size_t divUp(size_t a, unsigned b) 
# 498
{ 
# 499
return ((a + b) - (1)) / b; 
# 500
} 
# 508
static inline int roundUp(int a, unsigned b) 
# 509
{ 
# 510
; 
# 511
return ((a + b) - (1)) - (((a + b) - (1)) % b); 
# 512
} 
# 514
static inline size_t roundUp(size_t a, unsigned b) 
# 515
{ 
# 516
return ((a + b) - (1)) - (((a + b) - (1)) % b); 
# 517
} 
# 525
template< int N, class T> static inline bool 
# 526
isAligned(const T &data) 
# 527
{ 
# 528
static_assert(((N & (N - 1)) == 0), " (N & (N - 1)) == 0");
# 529
return (((size_t)data) & (N - 1)) == (0); 
# 530
} 
# 532
template< int N> static inline bool 
# 533
isAligned(const void *p1) 
# 534
{ 
# 535
return isAligned< N> ((size_t)p1); 
# 536
} 
# 538
template< int N> static inline bool 
# 539
isAligned(const void *p1, const void *p2) 
# 540
{ 
# 541
return isAligned< N> (((size_t)p1) | ((size_t)p2)); 
# 542
} 
# 544
template< int N> static inline bool 
# 545
isAligned(const void *p1, const void *p2, const void *p3) 
# 546
{ 
# 547
return isAligned< N> ((((size_t)p1) | ((size_t)p2)) | ((size_t)p3)); 
# 548
} 
# 550
template< int N> static inline bool 
# 551
isAligned(const void *p1, const void *p2, const void *p3, const void *p4) 
# 552
{ 
# 553
return isAligned< N> (((((size_t)p1) | ((size_t)p2)) | ((size_t)p3)) | ((size_t)p4)); 
# 554
} 
# 569 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
void setUseOptimized(bool onoff); 
# 575
bool useOptimized(); 
# 577
static inline size_t getElemSize(int type) { return (size_t)((((type & ((512 - 1) << 3)) >> 3) + 1) * ((675553809 >> ((type & ((1 << 3) - 1)) * 4)) & 15)); } 
# 583
class ParallelLoopBody { 
# 586
public: virtual ~ParallelLoopBody(); 
# 587
virtual void operator()(const Range & range) const = 0; 
# 588
}; 
# 592
void parallel_for_(const Range & range, const ParallelLoopBody & body, double nstripes = -(1.0)); 
# 594
class ParallelLoopBodyLambdaWrapper : public ParallelLoopBody { 
# 597
std::function< void (const Range &)>  m_functor; 
# 599
public: ParallelLoopBodyLambdaWrapper(std::function< void (const Range &)>  functor) : m_functor(functor) 
# 601
{ } 
# 603
virtual void operator()(const Range &range) const override 
# 604
{ 
# 605
(m_functor)(range); 
# 606
} 
# 607
}; 
# 609
inline void parallel_for_(const Range &range, std::function< void (const Range &)>  functor, double nstripes = -(1.0)) 
# 610
{ 
# 611
parallel_for_(range, ((ParallelLoopBodyLambdaWrapper)(functor)), nstripes); 
# 612
} 
# 615
template< class _Tp, class Functor> inline void 
# 616
Mat::forEach_impl(const Functor &operation) { 
# 617
if (false) { 
# 618
operation(*(reinterpret_cast< _Tp *>(0)), reinterpret_cast< int *>(0)); 
# 623
}  
# 625
do { if (!(!((this->total() / ((this->size)[(this->dims) - 1])) <= (2147483647)))) { ; } else { cv::error(cv::Error::StsAssert, "this->total() / this->size[this->dims - 1] <= INT_MAX", __func__, "/usr/include/opencv4/opencv2/core/utility.hpp", 625); }  } while (0); 
# 626
const int LINES = static_cast< int>(this->total() / ((this->size)[(this->dims) - 1])); 
# 628
class PixelOperationWrapper : public ParallelLoopBody { 
# 631
public: PixelOperationWrapper(Mat_< _Tp>  *const frame, const Functor &_operation) : mat(frame), op(_operation) 
# 632
{ } 
# 633
virtual ~PixelOperationWrapper() { } 
# 636
virtual void operator()(const Range &range) const override 
# 637
{ 
# 638
const int DIMS = (((mat)->dims)); 
# 639
const int COLS = (((mat)->size)[DIMS - 1]); 
# 640
if (DIMS <= 2) { 
# 641
for (int row = range.start; row < (range.end); ++row) { 
# 642
this->rowCall2(row, COLS); 
# 643
}  
# 644
} else { 
# 645
std::vector< int>  idx(DIMS); 
# 646
idx[DIMS - 2] = ((range.start) - 1); 
# 648
for (int line_num = range.start; line_num < (range.end); ++line_num) { 
# 649
idx[DIMS - 2]++; 
# 650
for (int i = (DIMS - 2); i >= 0; --i) { 
# 651
if (idx[i] >= (((mat)->size)[i])) { 
# 652
idx[i - 1] += (idx[i] / (((mat)->size)[i])); 
# 653
idx[i] %= (((mat)->size)[i]); 
# 654
continue; 
# 655
} else 
# 656
{ 
# 657
break; 
# 658
}  
# 659
}  
# 660
this->rowCall(&idx[0], COLS, DIMS); 
# 661
}  
# 662
}  
# 663
} 
# 665
private: Mat_< _Tp>  *const mat; 
# 666
const Functor op; 
# 668
void rowCall(int *const idx, const int COLS, const int DIMS) const { 
# 669
int &col = idx[DIMS - 1]; 
# 670
col = 0; 
# 671
_Tp *pixel = (&(mat)->template at< _Tp> (idx)); 
# 673
while (col < COLS) { 
# 674
(op)(*pixel, const_cast< const int *>(idx)); 
# 675
pixel++; col++; 
# 676
}  
# 677
col = 0; 
# 678
} 
# 680
void rowCall2(const int row, const int COLS) const { 
# 681
union Index { 
# 682
int body[2]; 
# 683
operator const int *() const { 
# 684
return reinterpret_cast< const int *>(this); 
# 685
} 
# 686
int &operator[](const int i) { 
# 687
return (body)[i]; 
# 688
} 
# 689
} idx = {{row, 0}}; 
# 694
_Tp *pixel = (&(mat)->template at< _Tp> (idx)); 
# 695
const _Tp *const pixel_end = pixel + COLS; 
# 696
while (pixel < pixel_end) { 
# 697
(op)(*(pixel++), static_cast< const int *>(idx)); 
# 698
(idx[1])++; 
# 699
}  
# 700
} 
# 701
PixelOperationWrapper &operator=(const PixelOperationWrapper &) { 
# 702
do { if (!(!false)) { ; } else { cv::error(cv::Error::StsAssert, "false", __func__, "/usr/include/opencv4/opencv2/core/utility.hpp", 702); }  } while (0); 
# 704
return *this; 
# 705
} 
# 706
}; 
# 708
parallel_for_(Range(0, LINES), PixelOperationWrapper(reinterpret_cast< Mat_< _Tp>  *>(this), operation)); 
# 709
} 
# 714
typedef std::recursive_mutex Mutex; 
# 715
typedef std::lock_guard< std::recursive_mutex>  AutoLock; 
# 796 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
class CommandLineParser { 
# 808 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
public: CommandLineParser(int argc, const char *const  argv[], const String & keys); 
# 811
CommandLineParser(const CommandLineParser & parser); 
# 814
CommandLineParser &operator=(const CommandLineParser & parser); 
# 817
~CommandLineParser(); 
# 829 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
String getPathToApplication() const; 
# 862 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
template< class T> T 
# 863
get(const String &name, bool space_delete = true) const 
# 864
{ 
# 865
T val = T(); 
# 866
this->getByName(name, space_delete, ParamType< T> ::type, (void *)(&val)); 
# 867
return val; 
# 868
} 
# 894 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
template< class T> T 
# 895
get(int index, bool space_delete = true) const 
# 896
{ 
# 897
T val = T(); 
# 898
this->getByIndex(index, space_delete, ParamType< T> ::type, (void *)(&val)); 
# 899
return val; 
# 900
} 
# 906
bool has(const String & name) const; 
# 913
bool check() const; 
# 919
void about(const String & message); 
# 927
void printMessage() const; 
# 933
void printErrors() const; 
# 936
protected: void getByName(const String & name, bool space_delete, Param type, void * dst) const; 
# 937
void getByIndex(int index, bool space_delete, Param type, void * dst) const; 
# 939
struct Impl; 
# 940
Impl *impl; 
# 941
}; 
# 949
template< class _Tp, size_t fixed_size> inline 
# 950
AutoBuffer< _Tp, fixed_size> ::AutoBuffer() 
# 951
{ 
# 952
(ptr) = (buf); 
# 953
(sz) = fixed_size; 
# 954
} 
# 956
template< class _Tp, size_t fixed_size> inline 
# 957
AutoBuffer< _Tp, fixed_size> ::AutoBuffer(size_t _size) 
# 958
{ 
# 959
(ptr) = (buf); 
# 960
(sz) = fixed_size; 
# 961
allocate(_size); 
# 962
} 
# 964
template< class _Tp, size_t fixed_size> inline 
# 965
AutoBuffer< _Tp, fixed_size> ::AutoBuffer(const AutoBuffer &abuf) 
# 966
{ 
# 967
(ptr) = (buf); 
# 968
(sz) = fixed_size; 
# 969
allocate(abuf.size()); 
# 970
for (size_t i = (0); i < (sz); i++) { 
# 971
((ptr)[i]) = ((abuf.ptr)[i]); }  
# 972
} 
# 974
template< class _Tp, size_t fixed_size> inline AutoBuffer< _Tp, fixed_size>  &
# 975
AutoBuffer< _Tp, fixed_size> ::operator=(const AutoBuffer &abuf) 
# 976
{ 
# 977
if (this != (&abuf)) 
# 978
{ 
# 979
deallocate(); 
# 980
allocate(abuf.size()); 
# 981
for (size_t i = (0); i < (sz); i++) { 
# 982
((ptr)[i]) = ((abuf.ptr)[i]); }  
# 983
}  
# 984
return *this; 
# 985
} 
# 987
template< class _Tp, size_t fixed_size> inline 
# 988
AutoBuffer< _Tp, fixed_size> ::~AutoBuffer() 
# 989
{ deallocate(); } 
# 991
template< class _Tp, size_t fixed_size> inline void 
# 992
AutoBuffer< _Tp, fixed_size> ::allocate(size_t _size) 
# 993
{ 
# 994
if (_size <= (sz)) 
# 995
{ 
# 996
(sz) = _size; 
# 997
return; 
# 998
}  
# 999
deallocate(); 
# 1000
(sz) = _size; 
# 1001
if (_size > fixed_size) 
# 1002
{ 
# 1003
(ptr) = (new _Tp [_size]); 
# 1004
}  
# 1005
} 
# 1007
template< class _Tp, size_t fixed_size> inline void 
# 1008
AutoBuffer< _Tp, fixed_size> ::deallocate() 
# 1009
{ 
# 1010
if ((ptr) != (buf)) 
# 1011
{ 
# 1012
delete [] (ptr); 
# 1013
(ptr) = (buf); 
# 1014
(sz) = fixed_size; 
# 1015
}  
# 1016
} 
# 1018
template< class _Tp, size_t fixed_size> inline void 
# 1019
AutoBuffer< _Tp, fixed_size> ::resize(size_t _size) 
# 1020
{ 
# 1021
if (_size <= (sz)) 
# 1022
{ 
# 1023
(sz) = _size; 
# 1024
return; 
# 1025
}  
# 1026
size_t i, prevsize = sz, minsize = (prevsize > _size) ? _size : prevsize; 
# 1027
_Tp *prevptr = ptr; 
# 1029
(ptr) = ((_size > fixed_size) ? new _Tp [_size] : (buf)); 
# 1030
(sz) = _size; 
# 1032
if ((ptr) != prevptr) { 
# 1033
for (i = (0); i < minsize; i++) { 
# 1034
((ptr)[i]) = (prevptr[i]); }  }  
# 1035
for (i = prevsize; i < _size; i++) { 
# 1036
((ptr)[i]) = _Tp(); }  
# 1038
if (prevptr != (buf)) { 
# 1039
delete [] prevptr; }  
# 1040
} 
# 1042
template< class _Tp, size_t fixed_size> inline size_t 
# 1043
AutoBuffer< _Tp, fixed_size> ::size() const 
# 1044
{ return sz; } 
# 1050
template< class OBJECT> 
# 1051
class Node { 
# 1054
public: Node() 
# 1055
{ 
# 1056
(m_pParent) = 0; 
# 1057
} 
# 1058
Node(OBJECT &payload) : m_payload(payload) 
# 1059
{ 
# 1060
(m_pParent) = 0; 
# 1061
} 
# 1062
~Node() 
# 1063
{ 
# 1064
removeChilds(); 
# 1065
if (m_pParent) 
# 1066
{ 
# 1067
int idx = (m_pParent)->findChild(this); 
# 1068
if (idx >= 0) { 
# 1069
((m_pParent)->m_childs).erase(((m_pParent)->m_childs).begin() + idx); }  
# 1070
}  
# 1071
} 
# 1073
Node *findChild(OBJECT &payload) const 
# 1074
{ 
# 1075
for (size_t i = (0); i < (this->m_childs).size(); i++) 
# 1076
{ 
# 1077
if ((((this->m_childs)[i])->m_payload) == payload) { 
# 1078
return (this->m_childs)[i]; }  
# 1079
}  
# 1080
return __null; 
# 1081
} 
# 1083
int findChild(Node *pNode) const 
# 1084
{ 
# 1085
for (size_t i = (0); i < (this->m_childs).size(); i++) 
# 1086
{ 
# 1087
if (((this->m_childs)[i]) == pNode) { 
# 1088
return (int)i; }  
# 1089
}  
# 1090
return -1; 
# 1091
} 
# 1093
void addChild(Node *pNode) 
# 1094
{ 
# 1095
if (!pNode) { 
# 1096
return; }  
# 1098
do { if (!(!((pNode->m_pParent) == 0))) { ; } else { cv::error(cv::Error::StsAssert, "pNode->m_pParent == 0", __func__, "/usr/include/opencv4/opencv2/core/utility.hpp", 1098); }  } while (0); 
# 1099
(pNode->m_pParent) = this; 
# 1100
(this->m_childs).push_back(pNode); 
# 1101
} 
# 1103
void removeChilds() 
# 1104
{ 
# 1105
for (size_t i = (0); i < (m_childs).size(); i++) 
# 1106
{ 
# 1107
(((m_childs)[i])->m_pParent) = 0; 
# 1108
delete ((m_childs)[i]); 
# 1109
}  
# 1110
(m_childs).clear(); 
# 1111
} 
# 1113
int getDepth() 
# 1114
{ 
# 1115
int count = 0; 
# 1116
Node *pParent = m_pParent; 
# 1117
while (pParent) { (count++), (pParent = (pParent->m_pParent)); }  
# 1118
return count; 
# 1119
} 
# 1122
OBJECT m_payload; 
# 1123
Node *m_pParent; 
# 1124
std::vector< Node *>  m_childs; 
# 1125
}; 
# 1128
namespace samples { 
# 1160 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
String findFile(const String & relative_path, bool required = true, bool silentMode = false); 
# 1162
inline String findFileOrKeep(const String & relative_path, bool silentMode = false); 
# 1164
inline String findFileOrKeep(const String &relative_path, bool silentMode) 
# 1165
{ 
# 1166
String res = findFile(relative_path, false, silentMode); 
# 1167
if (res.empty()) { 
# 1168
return relative_path; }  
# 1169
return res; 
# 1170
} 
# 1179 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
void addSamplesDataSearchPath(const String & path); 
# 1188 "/usr/include/opencv4/opencv2/core/utility.hpp" 3
void addSamplesDataSearchSubDirectory(const String & subdir); 
# 1191
}
# 1193
namespace utils { 
# 1195
int getThreadID(); 
# 1197
}
# 1199
}
# 47 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
namespace cv { 
# 58 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
class MinProblemSolver : public Algorithm { 
# 63
public: class Function { 
# 66
public: virtual ~Function() { } 
# 67
virtual int getDims() const = 0; 
# 68
virtual double getGradientEps() const; 
# 69
virtual double calc(const double * x) const = 0; 
# 70
virtual void getGradient(const double * x, double * grad); 
# 71
}; 
# 81 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
virtual Ptr< Function>  getFunction() const = 0; 
# 89
virtual void setFunction(const Ptr< Function>  & f) = 0; 
# 95
virtual TermCriteria getTermCriteria() const = 0; 
# 108 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
virtual void setTermCriteria(const TermCriteria & termcrit) = 0; 
# 122 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
virtual double minimize(InputOutputArray x) = 0; 
# 123
}; 
# 155 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
class DownhillSolver : public MinProblemSolver { 
# 164
public: virtual void getInitStep(OutputArray step) const = 0; 
# 180 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
virtual void setInitStep(InputArray step) = 0; 
# 198 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
static Ptr< DownhillSolver>  create(const Ptr< Function>  & f = Ptr< Function> (), InputArray initStep = Mat_< double> (1, 1, (0.0)), TermCriteria termcrit = TermCriteria((TermCriteria::MAX_ITER) + (TermCriteria::EPS), 5000, (1.0E-6))); 
# 201
}; 
# 236 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
class ConjGradSolver : public MinProblemSolver { 
# 252 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
public: static Ptr< ConjGradSolver>  create(const Ptr< Function>  & f = Ptr< Function> (), TermCriteria termcrit = TermCriteria((TermCriteria::MAX_ITER) + (TermCriteria::EPS), 5000, (1.0E-6))); 
# 254
}; 
# 257
enum SolveLPResult { 
# 259
SOLVELP_UNBOUNDED = (-2), 
# 260
SOLVELP_UNFEASIBLE, 
# 261
SOLVELP_SINGLE = 0, 
# 262
SOLVELP_MULTI
# 263
}; 
# 296 "/usr/include/opencv4/opencv2/core/optim.hpp" 3
int solveLP(InputArray Func, InputArray Constr, OutputArray z); 
# 300
}
# 16 "/usr/include/opencv4/opencv2/core/ovx.hpp" 3
namespace cv { 
# 19
bool haveOpenVX(); 
# 22
bool useOpenVX(); 
# 25
void setUseOpenVX(bool flag); 
# 26
}
# 67 "/usr/include/opencv4/opencv2/flann/defines.h" 3
namespace cvflann { 
# 70
enum flann_algorithm_t { 
# 72
FLANN_INDEX_LINEAR, 
# 73
FLANN_INDEX_KDTREE, 
# 74
FLANN_INDEX_KMEANS, 
# 75
FLANN_INDEX_COMPOSITE, 
# 76
FLANN_INDEX_KDTREE_SINGLE, 
# 77
FLANN_INDEX_HIERARCHICAL, 
# 78
FLANN_INDEX_LSH, 
# 79
FLANN_INDEX_SAVED = 254, 
# 80
FLANN_INDEX_AUTOTUNED, 
# 83
LINEAR = 0, 
# 84
KDTREE, 
# 85
KMEANS, 
# 86
COMPOSITE, 
# 87
KDTREE_SINGLE, 
# 88
SAVED = 254, 
# 89
AUTOTUNED
# 90
}; 
# 94
enum flann_centers_init_t { 
# 96
FLANN_CENTERS_RANDOM, 
# 97
FLANN_CENTERS_GONZALES, 
# 98
FLANN_CENTERS_KMEANSPP, 
# 99
FLANN_CENTERS_GROUPWISE, 
# 102
CENTERS_RANDOM = 0, 
# 103
CENTERS_GONZALES, 
# 104
CENTERS_KMEANSPP
# 105
}; 
# 107
enum flann_log_level_t { 
# 109
FLANN_LOG_NONE, 
# 110
FLANN_LOG_FATAL, 
# 111
FLANN_LOG_ERROR, 
# 112
FLANN_LOG_WARN, 
# 113
FLANN_LOG_INFO
# 114
}; 
# 116
enum flann_distance_t { 
# 118
FLANN_DIST_EUCLIDEAN = 1, 
# 119
FLANN_DIST_L2 = 1, 
# 120
FLANN_DIST_MANHATTAN, 
# 121
FLANN_DIST_L1 = 2, 
# 122
FLANN_DIST_MINKOWSKI, 
# 123
FLANN_DIST_MAX, 
# 124
FLANN_DIST_HIST_INTERSECT, 
# 125
FLANN_DIST_HELLINGER, 
# 126
FLANN_DIST_CHI_SQUARE, 
# 127
FLANN_DIST_CS = 7, 
# 128
FLANN_DIST_KULLBACK_LEIBLER, 
# 129
FLANN_DIST_KL = 8, 
# 130
FLANN_DIST_HAMMING, 
# 133
EUCLIDEAN = 1, 
# 134
MANHATTAN, 
# 135
MINKOWSKI, 
# 136
MAX_DIST, 
# 137
HIST_INTERSECT, 
# 138
HELLINGER, 
# 139
CS, 
# 140
KL, 
# 141
KULLBACK_LEIBLER = 8
# 142
}; 
# 144
enum flann_datatype_t { 
# 146
FLANN_INT8, 
# 147
FLANN_INT16, 
# 148
FLANN_INT32, 
# 149
FLANN_INT64, 
# 150
FLANN_UINT8, 
# 151
FLANN_UINT16, 
# 152
FLANN_UINT32, 
# 153
FLANN_UINT64, 
# 154
FLANN_FLOAT32, 
# 155
FLANN_FLOAT64
# 156
}; 
# 159
enum { 
# 160
FLANN_CHECKS_UNLIMITED = (-1), 
# 161
FLANN_CHECKS_AUTOTUNED = (-2)
# 162
}; 
# 164
}
# 51 "/usr/include/opencv4/opencv2/flann/miniflann.hpp" 3
namespace cv { 
# 54
namespace flann { 
# 57
enum FlannIndexType { 
# 58
FLANN_INDEX_TYPE_8U, 
# 59
FLANN_INDEX_TYPE_8S, 
# 60
FLANN_INDEX_TYPE_16U, 
# 61
FLANN_INDEX_TYPE_16S, 
# 62
FLANN_INDEX_TYPE_32S, 
# 63
FLANN_INDEX_TYPE_32F, 
# 64
FLANN_INDEX_TYPE_64F, 
# 65
FLANN_INDEX_TYPE_STRING, 
# 66
FLANN_INDEX_TYPE_BOOL, 
# 67
FLANN_INDEX_TYPE_ALGORITHM, 
# 68
LAST_VALUE_FLANN_INDEX_TYPE = FLANN_INDEX_TYPE_ALGORITHM
# 69
}; 
# 71
struct IndexParams { 
# 73
IndexParams(); 
# 74
~IndexParams(); 
# 76
String getString(const String & key, const String & defaultVal = String()) const; 
# 77
int getInt(const String & key, int defaultVal = -1) const; 
# 78
double getDouble(const String & key, double defaultVal = -1) const; 
# 80
void setString(const String & key, const String & value); 
# 81
void setInt(const String & key, int value); 
# 82
void setDouble(const String & key, double value); 
# 83
void setFloat(const String & key, float value); 
# 84
void setBool(const String & key, bool value); 
# 85
void setAlgorithm(int value); 
# 88
void getAll(std::vector< std::__cxx11::basic_string< char> >  & names, std::vector< FlannIndexType>  & types, std::vector< std::__cxx11::basic_string< char> >  & strValues, std::vector< double>  & numValues) const; 
# 93
void *params; 
# 96
private: IndexParams(const IndexParams &); 
# 97
IndexParams &operator=(const IndexParams &); 
# 98
}; 
# 100
struct KDTreeIndexParams : public IndexParams { 
# 102
KDTreeIndexParams(int trees = 4); 
# 103
}; 
# 105
struct LinearIndexParams : public IndexParams { 
# 107
LinearIndexParams(); 
# 108
}; 
# 110
struct CompositeIndexParams : public IndexParams { 
# 112
CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = (0.2F)); 
# 114
}; 
# 116
struct AutotunedIndexParams : public IndexParams { 
# 118
AutotunedIndexParams(float target_precision = (0.8F), float build_weight = (0.01F), float memory_weight = 0, float sample_fraction = (0.1F)); 
# 120
}; 
# 122
struct HierarchicalClusteringIndexParams : public IndexParams { 
# 124
HierarchicalClusteringIndexParams(int branching = 32, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, int trees = 4, int leaf_size = 100); 
# 126
}; 
# 128
struct KMeansIndexParams : public IndexParams { 
# 130
KMeansIndexParams(int branching = 32, int iterations = 11, cvflann::flann_centers_init_t centers_init = cvflann::FLANN_CENTERS_RANDOM, float cb_index = (0.2F)); 
# 132
}; 
# 134
struct LshIndexParams : public IndexParams { 
# 136
LshIndexParams(int table_number, int key_size, int multi_probe_level); 
# 137
}; 
# 139
struct SavedIndexParams : public IndexParams { 
# 141
SavedIndexParams(const String & filename); 
# 142
}; 
# 144
struct SearchParams : public IndexParams { 
# 146
SearchParams(int checks = 32, float eps = 0, bool sorted = true); 
# 147
}; 
# 149
class Index { 
# 152
public: Index(); 
# 153
Index(InputArray features, const IndexParams & params, cvflann::flann_distance_t distType = cvflann::FLANN_DIST_L2); 
# 154
virtual ~Index(); 
# 156
virtual void build(InputArray features, const IndexParams & params, cvflann::flann_distance_t distType = cvflann::FLANN_DIST_L2); 
# 157
virtual void knnSearch(InputArray query, OutputArray indices, OutputArray dists, int knn, const SearchParams & params = SearchParams()); 
# 160
virtual int radiusSearch(InputArray query, OutputArray indices, OutputArray dists, double radius, int maxResults, const SearchParams & params = SearchParams()); 
# 164
virtual void save(const String & filename) const; 
# 165
virtual bool load(InputArray features, const String & filename); 
# 166
virtual void release(); 
# 167
cvflann::flann_distance_t getDistance() const; 
# 168
cvflann::flann_algorithm_t getAlgorithm() const; 
# 171
protected: cvflann::flann_distance_t distType; 
# 172
cvflann::flann_algorithm_t algo; 
# 173
int featureType; 
# 174
void *index; 
# 175
}; 
# 177
}}
# 90 "/usr/include/opencv4/opencv2/features2d.hpp" 3
namespace cv { 
# 106 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class KeyPointsFilter { 
# 109
public: KeyPointsFilter() { } 
# 114
static void runByImageBorder(std::vector< KeyPoint>  & keypoints, Size imageSize, int borderSize); 
# 118
static void runByKeypointSize(std::vector< KeyPoint>  & keypoints, float minSize, float maxSize = (3.4028235E38F)); 
# 123
static void runByPixelsMask(std::vector< KeyPoint>  & keypoints, const Mat & mask); 
# 127
static void removeDuplicated(std::vector< KeyPoint>  & keypoints); 
# 131
static void removeDuplicatedSorted(std::vector< KeyPoint>  & keypoints); 
# 136
static void retainBest(std::vector< KeyPoint>  & keypoints, int npoints); 
# 137
}; 
# 147 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class Feature2D : virtual public Algorithm { 
# 151
public: virtual ~Feature2D(); 
# 161 "/usr/include/opencv4/opencv2/features2d.hpp" 3
virtual void detect(InputArray image, std::vector< KeyPoint>  & keypoints, InputArray mask = noArray()); 
# 172 "/usr/include/opencv4/opencv2/features2d.hpp" 3
virtual void detect(InputArrayOfArrays images, std::vector< std::vector< KeyPoint> >  & keypoints, InputArrayOfArrays masks = noArray()); 
# 187 "/usr/include/opencv4/opencv2/features2d.hpp" 3
virtual void compute(InputArray image, std::vector< KeyPoint>  & keypoints, OutputArray descriptors); 
# 201 "/usr/include/opencv4/opencv2/features2d.hpp" 3
virtual void compute(InputArrayOfArrays images, std::vector< std::vector< KeyPoint> >  & keypoints, OutputArrayOfArrays descriptors); 
# 206
virtual void detectAndCompute(InputArray image, InputArray mask, std::vector< KeyPoint>  & keypoints, OutputArray descriptors, bool useProvidedKeypoints = false); 
# 211
virtual int descriptorSize() const; 
# 212
virtual int descriptorType() const; 
# 213
virtual int defaultNorm() const; 
# 215
void write(const String & fileName) const; 
# 217
void read(const String & fileName); 
# 219
virtual void write(FileStorage &) const override; 
# 222
virtual void read(const FileNode &) override; 
# 225
virtual bool empty() const override; 
# 226
virtual String getDefaultName() const override; 
# 229
void write(const Ptr< FileStorage>  &fs, const String &name = String()) const { this->Algorithm::write(fs, name); } 
# 230
}; 
# 235
typedef Feature2D FeatureDetector; 
# 242
typedef Feature2D DescriptorExtractor; 
# 249
class BRISK : public Feature2D { 
# 259
public: static Ptr< BRISK>  create(int thresh = 30, int octaves = 3, float patternScale = (1.0F)); 
# 272 "/usr/include/opencv4/opencv2/features2d.hpp" 3
static Ptr< BRISK>  create(const std::vector< float>  & radiusList, const std::vector< int>  & numberList, float dMax = (5.85F), float dMin = (8.2F), const std::vector< int>  & indexChange = std::vector< int> ()); 
# 288 "/usr/include/opencv4/opencv2/features2d.hpp" 3
static Ptr< BRISK>  create(int thresh, int octaves, const std::vector< float>  & radiusList, const std::vector< int>  & numberList, float dMax = (5.85F), float dMin = (8.2F), const std::vector< int>  & indexChange = std::vector< int> ()); 
# 291
virtual String getDefaultName() const override; 
# 296
virtual void setThreshold(int threshold) { (void)threshold; } 
# 297
virtual int getThreshold() const { return -1; } 
# 302
virtual void setOctaves(int octaves) { (void)octaves; } 
# 303
virtual int getOctaves() const { return -1; } 
# 304
}; 
# 313 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class ORB : public Feature2D { 
# 316
public: enum ScoreType { HARRIS_SCORE, FAST_SCORE}; 
# 317
static const int kBytes = 32; 
# 350 "/usr/include/opencv4/opencv2/features2d.hpp" 3
static Ptr< ORB>  create(int nfeatures = 500, float scaleFactor = (1.2F), int nlevels = 8, int edgeThreshold = 31, int firstLevel = 0, int WTA_K = 2, ScoreType scoreType = ORB::HARRIS_SCORE, int patchSize = 31, int fastThreshold = 20); 
# 353
virtual void setMaxFeatures(int maxFeatures) = 0; 
# 354
virtual int getMaxFeatures() const = 0; 
# 356
virtual void setScaleFactor(double scaleFactor) = 0; 
# 357
virtual double getScaleFactor() const = 0; 
# 359
virtual void setNLevels(int nlevels) = 0; 
# 360
virtual int getNLevels() const = 0; 
# 362
virtual void setEdgeThreshold(int edgeThreshold) = 0; 
# 363
virtual int getEdgeThreshold() const = 0; 
# 365
virtual void setFirstLevel(int firstLevel) = 0; 
# 366
virtual int getFirstLevel() const = 0; 
# 368
virtual void setWTA_K(int wta_k) = 0; 
# 369
virtual int getWTA_K() const = 0; 
# 371
virtual void setScoreType(ScoreType scoreType) = 0; 
# 372
virtual ScoreType getScoreType() const = 0; 
# 374
virtual void setPatchSize(int patchSize) = 0; 
# 375
virtual int getPatchSize() const = 0; 
# 377
virtual void setFastThreshold(int fastThreshold) = 0; 
# 378
virtual int getFastThreshold() const = 0; 
# 379
virtual String getDefaultName() const override; 
# 380
}; 
# 398 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class MSER : public Feature2D { 
# 413 "/usr/include/opencv4/opencv2/features2d.hpp" 3
public: static Ptr< MSER>  create(int _delta = 5, int _min_area = 60, int _max_area = 14400, double _max_variation = (0.25), double _min_diversity = (0.2), int _max_evolution = 200, double _area_threshold = (1.01), double _min_margin = (0.003), int _edge_blur_size = 5); 
# 424
virtual void detectRegions(InputArray image, std::vector< std::vector< Point_< int> > >  & msers, std::vector< Rect_< int> >  & bboxes) = 0; 
# 428
virtual void setDelta(int delta) = 0; 
# 429
virtual int getDelta() const = 0; 
# 431
virtual void setMinArea(int minArea) = 0; 
# 432
virtual int getMinArea() const = 0; 
# 434
virtual void setMaxArea(int maxArea) = 0; 
# 435
virtual int getMaxArea() const = 0; 
# 437
virtual void setPass2Only(bool f) = 0; 
# 438
virtual bool getPass2Only() const = 0; 
# 439
virtual String getDefaultName() const override; 
# 440
}; 
# 449 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class FastFeatureDetector : public Feature2D { 
# 452
public: enum DetectorType { 
# 454
TYPE_5_8, TYPE_7_12, TYPE_9_16
# 455
}; 
# 457
enum { 
# 458
THRESHOLD = 10000, NONMAX_SUPPRESSION, FAST_N
# 459
}; 
# 462
static Ptr< FastFeatureDetector>  create(int threshold = 10, bool nonmaxSuppression = true, DetectorType type = FastFeatureDetector::TYPE_9_16); 
# 466
virtual void setThreshold(int threshold) = 0; 
# 467
virtual int getThreshold() const = 0; 
# 469
virtual void setNonmaxSuppression(bool f) = 0; 
# 470
virtual bool getNonmaxSuppression() const = 0; 
# 472
virtual void setType(DetectorType type) = 0; 
# 473
virtual DetectorType getType() const = 0; 
# 474
virtual String getDefaultName() const override; 
# 475
}; 
# 478
void FAST(InputArray image, std::vector< KeyPoint>  & keypoints, int threshold, bool nonmaxSuppression = true); 
# 499 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void FAST(InputArray image, std::vector< KeyPoint>  & keypoints, int threshold, bool nonmaxSuppression, FastFeatureDetector::DetectorType type); 
# 509 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class AgastFeatureDetector : public Feature2D { 
# 512
public: enum DetectorType { 
# 514
AGAST_5_8, AGAST_7_12d, AGAST_7_12s, OAST_9_16
# 515
}; 
# 518
enum { 
# 519
THRESHOLD = 10000, NONMAX_SUPPRESSION
# 520
}; 
# 522
static Ptr< AgastFeatureDetector>  create(int threshold = 10, bool nonmaxSuppression = true, DetectorType type = AgastFeatureDetector::OAST_9_16); 
# 526
virtual void setThreshold(int threshold) = 0; 
# 527
virtual int getThreshold() const = 0; 
# 529
virtual void setNonmaxSuppression(bool f) = 0; 
# 530
virtual bool getNonmaxSuppression() const = 0; 
# 532
virtual void setType(DetectorType type) = 0; 
# 533
virtual DetectorType getType() const = 0; 
# 534
virtual String getDefaultName() const override; 
# 535
}; 
# 538
void AGAST(InputArray image, std::vector< KeyPoint>  & keypoints, int threshold, bool nonmaxSuppression = true); 
# 559 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void AGAST(InputArray image, std::vector< KeyPoint>  & keypoints, int threshold, bool nonmaxSuppression, AgastFeatureDetector::DetectorType type); 
# 564
class GFTTDetector : public Feature2D { 
# 567
public: static Ptr< GFTTDetector>  create(int maxCorners = 1000, double qualityLevel = (0.01), double minDistance = 1, int blockSize = 3, bool useHarrisDetector = false, double k = (0.04)); 
# 569
static Ptr< GFTTDetector>  create(int maxCorners, double qualityLevel, double minDistance, int blockSize, int gradiantSize, bool useHarrisDetector = false, double k = (0.04)); 
# 571
virtual void setMaxFeatures(int maxFeatures) = 0; 
# 572
virtual int getMaxFeatures() const = 0; 
# 574
virtual void setQualityLevel(double qlevel) = 0; 
# 575
virtual double getQualityLevel() const = 0; 
# 577
virtual void setMinDistance(double minDistance) = 0; 
# 578
virtual double getMinDistance() const = 0; 
# 580
virtual void setBlockSize(int blockSize) = 0; 
# 581
virtual int getBlockSize() const = 0; 
# 583
virtual void setHarrisDetector(bool val) = 0; 
# 584
virtual bool getHarrisDetector() const = 0; 
# 586
virtual void setK(double k) = 0; 
# 587
virtual double getK() const = 0; 
# 588
virtual String getDefaultName() const override; 
# 589
}; 
# 622 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class SimpleBlobDetector : public Feature2D { 
# 625
public: struct Params { 
# 627
Params(); 
# 628
float thresholdStep; 
# 629
float minThreshold; 
# 630
float maxThreshold; 
# 631
size_t minRepeatability; 
# 632
float minDistBetweenBlobs; 
# 634
bool filterByColor; 
# 635
uchar blobColor; 
# 637
bool filterByArea; 
# 638
float minArea, maxArea; 
# 640
bool filterByCircularity; 
# 641
float minCircularity, maxCircularity; 
# 643
bool filterByInertia; 
# 644
float minInertiaRatio, maxInertiaRatio; 
# 646
bool filterByConvexity; 
# 647
float minConvexity, maxConvexity; 
# 649
void read(const FileNode & fn); 
# 650
void write(FileStorage & fs) const; 
# 651
}; 
# 654
static Ptr< SimpleBlobDetector>  create(const Params & parameters = Params()); 
# 655
virtual String getDefaultName() const override; 
# 656
}; 
# 669 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class KAZE : public Feature2D { 
# 672
public: enum DiffusivityType { 
# 674
DIFF_PM_G1, 
# 675
DIFF_PM_G2, 
# 676
DIFF_WEICKERT, 
# 677
DIFF_CHARBONNIER
# 678
}; 
# 690 "/usr/include/opencv4/opencv2/features2d.hpp" 3
static Ptr< KAZE>  create(bool extended = false, bool upright = false, float threshold = (0.001F), int nOctaves = 4, int nOctaveLayers = 4, DiffusivityType diffusivity = KAZE::DIFF_PM_G2); 
# 695
virtual void setExtended(bool extended) = 0; 
# 696
virtual bool getExtended() const = 0; 
# 698
virtual void setUpright(bool upright) = 0; 
# 699
virtual bool getUpright() const = 0; 
# 701
virtual void setThreshold(double threshold) = 0; 
# 702
virtual double getThreshold() const = 0; 
# 704
virtual void setNOctaves(int octaves) = 0; 
# 705
virtual int getNOctaves() const = 0; 
# 707
virtual void setNOctaveLayers(int octaveLayers) = 0; 
# 708
virtual int getNOctaveLayers() const = 0; 
# 710
virtual void setDiffusivity(DiffusivityType diff) = 0; 
# 711
virtual DiffusivityType getDiffusivity() const = 0; 
# 712
virtual String getDefaultName() const override; 
# 713
}; 
# 731 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class AKAZE : public Feature2D { 
# 735
public: enum DescriptorType { 
# 737
DESCRIPTOR_KAZE_UPRIGHT = 2, 
# 738
DESCRIPTOR_KAZE, 
# 739
DESCRIPTOR_MLDB_UPRIGHT, 
# 740
DESCRIPTOR_MLDB
# 741
}; 
# 755 "/usr/include/opencv4/opencv2/features2d.hpp" 3
static Ptr< AKAZE>  create(DescriptorType descriptor_type = AKAZE::DESCRIPTOR_MLDB, int descriptor_size = 0, int descriptor_channels = 3, float threshold = (0.001F), int nOctaves = 4, int nOctaveLayers = 4, KAZE::DiffusivityType diffusivity = KAZE::DIFF_PM_G2); 
# 760
virtual void setDescriptorType(DescriptorType dtype) = 0; 
# 761
virtual DescriptorType getDescriptorType() const = 0; 
# 763
virtual void setDescriptorSize(int dsize) = 0; 
# 764
virtual int getDescriptorSize() const = 0; 
# 766
virtual void setDescriptorChannels(int dch) = 0; 
# 767
virtual int getDescriptorChannels() const = 0; 
# 769
virtual void setThreshold(double threshold) = 0; 
# 770
virtual double getThreshold() const = 0; 
# 772
virtual void setNOctaves(int octaves) = 0; 
# 773
virtual int getNOctaves() const = 0; 
# 775
virtual void setNOctaveLayers(int octaveLayers) = 0; 
# 776
virtual int getNOctaveLayers() const = 0; 
# 778
virtual void setDiffusivity(KAZE::DiffusivityType diff) = 0; 
# 779
virtual KAZE::DiffusivityType getDiffusivity() const = 0; 
# 780
virtual String getDefaultName() const override; 
# 781
}; 
# 789
template< class T> 
# 790
struct Accumulator { 
# 792
typedef T Type; 
# 793
}; 
# 795
template<> struct Accumulator< unsigned char>  { typedef float Type; }; 
# 796
template<> struct Accumulator< unsigned short>  { typedef float Type; }; 
# 797
template<> struct Accumulator< char>  { typedef float Type; }; 
# 798
template<> struct Accumulator< short>  { typedef float Type; }; 
# 803
template< class T> 
# 804
struct SL2 { 
# 806
static const NormTypes normType = NORM_L2SQR; 
# 807
typedef T ValueType; 
# 808
typedef typename Accumulator< T> ::Type ResultType; 
# 810
ResultType operator()(const T *a, const T *b, int size) const 
# 811
{ 
# 812
return normL2Sqr< ValueType, ResultType> (a, b, size); 
# 813
} 
# 814
}; 
# 819
template< class T> 
# 820
struct L2 { 
# 822
static const NormTypes normType = NORM_L2; 
# 823
typedef T ValueType; 
# 824
typedef typename Accumulator< T> ::Type ResultType; 
# 826
ResultType operator()(const T *a, const T *b, int size) const 
# 827
{ 
# 828
return (ResultType)std::sqrt((double)normL2Sqr< ValueType, ResultType> (a, b, size)); 
# 829
} 
# 830
}; 
# 835
template< class T> 
# 836
struct L1 { 
# 838
static const NormTypes normType = NORM_L1; 
# 839
typedef T ValueType; 
# 840
typedef typename Accumulator< T> ::Type ResultType; 
# 842
ResultType operator()(const T *a, const T *b, int size) const 
# 843
{ 
# 844
return normL1< ValueType, ResultType> (a, b, size); 
# 845
} 
# 846
}; 
# 860 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class DescriptorMatcher : public Algorithm { 
# 863
public: enum MatcherType { 
# 865
FLANNBASED = 1, 
# 866
BRUTEFORCE, 
# 867
BRUTEFORCE_L1, 
# 868
BRUTEFORCE_HAMMING, 
# 869
BRUTEFORCE_HAMMINGLUT, 
# 870
BRUTEFORCE_SL2
# 871
}; 
# 873
virtual ~DescriptorMatcher(); 
# 883 "/usr/include/opencv4/opencv2/features2d.hpp" 3
virtual void add(InputArrayOfArrays descriptors); 
# 887
const std::vector< Mat>  &getTrainDescriptors() const; 
# 891
virtual void clear() override; 
# 895
virtual bool empty() const override; 
# 899
virtual bool isMaskSupported() const = 0; 
# 908 "/usr/include/opencv4/opencv2/features2d.hpp" 3
virtual void train(); 
# 926 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void match(InputArray queryDescriptors, InputArray trainDescriptors, std::vector< DMatch>  & matches, InputArray mask = noArray()) const; 
# 947 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void knnMatch(InputArray queryDescriptors, InputArray trainDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArray mask = noArray(), bool compactResult = false) const; 
# 970 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void radiusMatch(InputArray queryDescriptors, InputArray trainDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArray mask = noArray(), bool compactResult = false) const; 
# 981 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void match(InputArray queryDescriptors, std::vector< DMatch>  & matches, InputArrayOfArrays masks = noArray()); 
# 994 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void knnMatch(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArrayOfArrays masks = noArray(), bool compactResult = false); 
# 1008 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void radiusMatch(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArrayOfArrays masks = noArray(), bool compactResult = false); 
# 1012
void write(const String &fileName) const 
# 1013
{ 
# 1014
FileStorage fs(fileName, FileStorage::WRITE); 
# 1015
this->write(fs); 
# 1016
} 
# 1018
void read(const String &fileName) 
# 1019
{ 
# 1020
FileStorage fs(fileName, FileStorage::READ); 
# 1021
this->read(fs.root()); 
# 1022
} 
# 1025
virtual void read(const FileNode &) override; 
# 1027
virtual void write(FileStorage &) const override; 
# 1035
virtual Ptr< DescriptorMatcher>  clone(bool emptyTrainData = false) const = 0; 
# 1048 "/usr/include/opencv4/opencv2/features2d.hpp" 3
static Ptr< DescriptorMatcher>  create(const String & descriptorMatcherType); 
# 1050
static Ptr< DescriptorMatcher>  create(const MatcherType & matcherType); 
# 1054
void write(const Ptr< FileStorage>  &fs, const String &name = String()) const { this->Algorithm::write(fs, name); } 
# 1061
protected: class DescriptorCollection { 
# 1064
public: DescriptorCollection(); 
# 1065
DescriptorCollection(const DescriptorCollection & collection); 
# 1066
virtual ~DescriptorCollection(); 
# 1069
void set(const std::vector< Mat>  & descriptors); 
# 1070
virtual void clear(); 
# 1072
const Mat &getDescriptors() const; 
# 1073
const Mat getDescriptor(int imgIdx, int localDescIdx) const; 
# 1074
const Mat getDescriptor(int globalDescIdx) const; 
# 1075
void getLocalIdx(int globalDescIdx, int & imgIdx, int & localDescIdx) const; 
# 1077
int size() const; 
# 1080
protected: Mat mergedDescriptors; 
# 1081
std::vector< int>  startIdxs; 
# 1082
}; 
# 1087
virtual void knnMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArrayOfArrays masks = noArray(), bool compactResult = false) = 0; 
# 1089
virtual void radiusMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArrayOfArrays masks = noArray(), bool compactResult = false) = 0; 
# 1092
static bool isPossibleMatch(InputArray mask, int queryIdx, int trainIdx); 
# 1093
static bool isMaskedOut(InputArrayOfArrays masks, int queryIdx); 
# 1095
static Mat clone_op(Mat m) { return m.clone(); } 
# 1096
void checkMasks(InputArrayOfArrays masks, int queryDescriptorsCount) const; 
# 1099
std::vector< Mat>  trainDescCollection; 
# 1100
std::vector< UMat>  utrainDescCollection; 
# 1101
}; 
# 1109
class BFMatcher : public DescriptorMatcher { 
# 1116
public: BFMatcher(int normType = NORM_L2, bool crossCheck = false); 
# 1118
virtual ~BFMatcher() { } 
# 1120
virtual bool isMaskSupported() const override { return true; } 
# 1134 "/usr/include/opencv4/opencv2/features2d.hpp" 3
static Ptr< BFMatcher>  create(int normType = NORM_L2, bool crossCheck = false); 
# 1136
virtual Ptr< DescriptorMatcher>  clone(bool emptyTrainData = false) const override; 
# 1138
protected: virtual void knnMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArrayOfArrays masks = noArray(), bool compactResult = false) override; 
# 1140
virtual void radiusMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArrayOfArrays masks = noArray(), bool compactResult = false) override; 
# 1143
int normType; 
# 1144
bool crossCheck; 
# 1145
}; 
# 1156 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class FlannBasedMatcher : public DescriptorMatcher { 
# 1159
public: FlannBasedMatcher(const Ptr< flann::IndexParams>  & indexParams = makePtr< flann::KDTreeIndexParams> (), const Ptr< flann::SearchParams>  & searchParams = makePtr< flann::SearchParams> ()); 
# 1162
virtual void add(InputArrayOfArrays descriptors) override; 
# 1163
virtual void clear() override; 
# 1166
virtual void read(const FileNode &) override; 
# 1168
virtual void write(FileStorage &) const override; 
# 1170
virtual void train() override; 
# 1171
virtual bool isMaskSupported() const override; 
# 1173
static Ptr< FlannBasedMatcher>  create(); 
# 1175
virtual Ptr< DescriptorMatcher>  clone(bool emptyTrainData = false) const override; 
# 1177
protected: static void convertToDMatches(const DescriptorCollection & descriptors, const Mat & indices, const Mat & distances, std::vector< std::vector< DMatch> >  & matches); 
# 1181
virtual void knnMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, int k, InputArrayOfArrays masks = noArray(), bool compactResult = false) override; 
# 1183
virtual void radiusMatchImpl(InputArray queryDescriptors, std::vector< std::vector< DMatch> >  & matches, float maxDistance, InputArrayOfArrays masks = noArray(), bool compactResult = false) override; 
# 1186
Ptr< flann::IndexParams>  indexParams; 
# 1187
Ptr< flann::SearchParams>  searchParams; 
# 1188
Ptr< flann::Index>  flannIndex; 
# 1190
DescriptorCollection mergedDescriptors; 
# 1191
int addedDescCount; 
# 1192
}; 
# 1205 "/usr/include/opencv4/opencv2/features2d.hpp" 3
enum class DrawMatchesFlags { 
# 1207
DEFAULT, 
# 1212
DRAW_OVER_OUTIMG, 
# 1214
NOT_DRAW_SINGLE_POINTS, 
# 1215
DRAW_RICH_KEYPOINTS = 4
# 1217
}; 
# 1218
static inline bool operator!(const DrawMatchesFlags &val) { typedef std::underlying_type< DrawMatchesFlags> ::type UnderlyingType; return !(static_cast< UnderlyingType>(val)); } static inline bool operator==(const DrawMatchesFlags &a, const int &b) { return (static_cast< int>(a)) == (static_cast< int>(b)); } static inline bool operator!=(const DrawMatchesFlags &a, const int &b) { return (static_cast< int>(a)) != (static_cast< int>(b)); } static inline DrawMatchesFlags operator~(const DrawMatchesFlags &val) { typedef std::underlying_type< DrawMatchesFlags> ::type UnderlyingType; return static_cast< DrawMatchesFlags>(~(static_cast< UnderlyingType>(val))); } static inline DrawMatchesFlags operator|(const DrawMatchesFlags &a, const DrawMatchesFlags &b) { typedef std::underlying_type< DrawMatchesFlags> ::type UnderlyingType; return static_cast< DrawMatchesFlags>((static_cast< UnderlyingType>(a)) | (static_cast< UnderlyingType>(b))); } static inline DrawMatchesFlags operator&(const DrawMatchesFlags &a, const DrawMatchesFlags &b) { typedef std::underlying_type< DrawMatchesFlags> ::type UnderlyingType; return static_cast< DrawMatchesFlags>((static_cast< UnderlyingType>(a)) & (static_cast< UnderlyingType>(b))); } static inline DrawMatchesFlags operator^(const DrawMatchesFlags &a, const DrawMatchesFlags &b) { typedef std::underlying_type< DrawMatchesFlags> ::type UnderlyingType; return static_cast< DrawMatchesFlags>((static_cast< UnderlyingType>(a)) ^ (static_cast< UnderlyingType>(b))); } static inline DrawMatchesFlags &operator|=(DrawMatchesFlags &_this, const DrawMatchesFlags &val) { _this = (static_cast< DrawMatchesFlags>((static_cast< int>(_this)) | (static_cast< int>(val)))); return _this; } static inline DrawMatchesFlags &operator&=(DrawMatchesFlags &_this, const DrawMatchesFlags &val) { _this = (static_cast< DrawMatchesFlags>((static_cast< int>(_this)) & (static_cast< int>(val)))); return _this; } static inline DrawMatchesFlags &operator^=(DrawMatchesFlags &_this, const DrawMatchesFlags &val) { _this = (static_cast< DrawMatchesFlags>((static_cast< int>(_this)) ^ (static_cast< int>(val)))); return _this; } 
# 1235 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void drawKeypoints(InputArray image, const std::vector< KeyPoint>  & keypoints, InputOutputArray outImage, const Scalar & color = Scalar::all(-1), DrawMatchesFlags flags = DrawMatchesFlags::DEFAULT); 
# 1260 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void drawMatches(InputArray img1, const std::vector< KeyPoint>  & keypoints1, InputArray img2, const std::vector< KeyPoint>  & keypoints2, const std::vector< DMatch>  & matches1to2, InputOutputArray outImg, const Scalar & matchColor = Scalar::all(-1), const Scalar & singlePointColor = Scalar::all(-1), const std::vector< char>  & matchesMask = std::vector< char> (), DrawMatchesFlags flags = DrawMatchesFlags::DEFAULT); 
# 1267
void drawMatches(InputArray img1, const std::vector< KeyPoint>  & keypoints1, InputArray img2, const std::vector< KeyPoint>  & keypoints2, const std::vector< std::vector< DMatch> >  & matches1to2, InputOutputArray outImg, const Scalar & matchColor = Scalar::all(-1), const Scalar & singlePointColor = Scalar::all(-1), const std::vector< std::vector< char> >  & matchesMask = std::vector< std::vector< char> > (), DrawMatchesFlags flags = DrawMatchesFlags::DEFAULT); 
# 1279
void evaluateFeatureDetector(const Mat & img1, const Mat & img2, const Mat & H1to2, std::vector< KeyPoint>  * keypoints1, std::vector< KeyPoint>  * keypoints2, float & repeatability, int & correspCount, const Ptr< Feature2D>  & fdetector = Ptr< Feature2D> ()); 
# 1284
void computeRecallPrecisionCurve(const std::vector< std::vector< DMatch> >  & matches1to2, const std::vector< std::vector< unsigned char> >  & correctMatches1to2Mask, std::vector< Point_< float> >  & recallPrecisionCurve); 
# 1288
float getRecall(const std::vector< Point_< float> >  & recallPrecisionCurve, float l_precision); 
# 1289
int getNearestPoint(const std::vector< Point_< float> >  & recallPrecisionCurve, float l_precision); 
# 1303 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class BOWTrainer { 
# 1306
public: BOWTrainer(); 
# 1307
virtual ~BOWTrainer(); 
# 1316 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void add(const Mat & descriptors); 
# 1320
const std::vector< Mat>  &getDescriptors() const; 
# 1324
int descriptorsCount() const; 
# 1326
virtual void clear(); 
# 1329
virtual Mat cluster() const = 0; 
# 1340 "/usr/include/opencv4/opencv2/features2d.hpp" 3
virtual Mat cluster(const Mat & descriptors) const = 0; 
# 1343
protected: std::vector< Mat>  descriptors; 
# 1344
int size; 
# 1345
}; 
# 1349
class BOWKMeansTrainer : public BOWTrainer { 
# 1356
public: BOWKMeansTrainer(int clusterCount, const TermCriteria & termcrit = TermCriteria(), int attempts = 3, int flags = KMEANS_PP_CENTERS); 
# 1358
virtual ~BOWKMeansTrainer(); 
# 1361
virtual Mat cluster() const override; 
# 1362
virtual Mat cluster(const Mat & descriptors) const override; 
# 1366
protected: int clusterCount; 
# 1367
TermCriteria termcrit; 
# 1368
int attempts; 
# 1369
int flags; 
# 1370
}; 
# 1382 "/usr/include/opencv4/opencv2/features2d.hpp" 3
class BOWImgDescriptorExtractor { 
# 1392
public: BOWImgDescriptorExtractor(const Ptr< Feature2D>  & dextractor, const Ptr< DescriptorMatcher>  & dmatcher); 
# 1395
BOWImgDescriptorExtractor(const Ptr< DescriptorMatcher>  & dmatcher); 
# 1396
virtual ~BOWImgDescriptorExtractor(); 
# 1403
void setVocabulary(const Mat & vocabulary); 
# 1407
const Mat &getVocabulary() const; 
# 1419 "/usr/include/opencv4/opencv2/features2d.hpp" 3
void compute(InputArray image, std::vector< KeyPoint>  & keypoints, OutputArray imgDescriptor, std::vector< std::vector< int> >  * pointIdxsOfClusters = 0, Mat * descriptors = 0); 
# 1428
void compute(InputArray keypointDescriptors, OutputArray imgDescriptor, std::vector< std::vector< int> >  * pointIdxsOfClusters = 0); 
# 1432
void compute2(const Mat &image, std::vector< KeyPoint>  &keypoints, Mat &imgDescriptor) 
# 1433
{ this->compute(image, keypoints, imgDescriptor); } 
# 1437
int descriptorSize() const; 
# 1441
int descriptorType() const; 
# 1444
protected: Mat vocabulary; 
# 1445
Ptr< Feature2D>  dextractor; 
# 1446
Ptr< DescriptorMatcher>  dmatcher; 
# 1447
}; 
# 1453
}
# 51 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
namespace cv { 
# 125 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
template< class T> 
# 126
class Affine3 { 
# 129
public: typedef T float_type; 
# 130
typedef Matx< float_type, 3, 3>  Mat3; 
# 131
typedef Matx< float_type, 4, 4>  Mat4; 
# 132
typedef Vec< float_type, 3>  Vec3; 
# 135
inline Affine3(); 
# 138
inline Affine3(const Mat4 & affine); 
# 153 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
inline Affine3(const Mat3 & R, const Vec3 & t = Vec3::all(0)); 
# 164 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
inline Affine3(const Vec3 & rvec, const Vec3 & t = Vec3::all(0)); 
# 179 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
inline explicit Affine3(const Mat & data, const Vec3 & t = Vec3::all(0)); 
# 182
inline explicit Affine3(const float_type * vals); 
# 185
static inline Affine3 Identity(); 
# 196 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
inline void rotation(const Mat3 & R); 
# 206 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
inline void rotation(const Vec3 & rvec); 
# 218 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
inline void rotation(const Mat & data); 
# 227 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
inline void linear(const Mat3 & L); 
# 236 "/usr/include/opencv4/opencv2/core/affine.hpp" 3
inline void translation(const Vec3 & t); 
# 239
inline Mat3 rotation() const; 
# 242
inline Mat3 linear() const; 
# 245
inline Vec3 translation() const; 
# 252
inline Vec3 rvec() const; 
# 255
inline Affine3 inv(int method = cv::DECOMP_SVD) const; 
# 258
inline Affine3 rotate(const Mat3 & R) const; 
# 261
inline Affine3 rotate(const Vec3 & rvec) const; 
# 264
inline Affine3 translate(const Vec3 & t) const; 
# 267
inline Affine3 concatenate(const Affine3 & affine) const; 
# 269
template< class Y> inline operator Affine3< Y> () const; 
# 271
template< class Y> inline Affine3< Y>  cast() const; 
# 273
Mat4 matrix; 
# 281
}; 
# 283
template< class T> static inline Affine3< T>  operator*(const Affine3< T>  & affine1, const Affine3< T>  & affine2); 
# 287
template< class T, class V> static inline V operator*(const Affine3< T>  & affine, const V & vector); 
# 290
typedef Affine3< float>  Affine3f; 
# 291
typedef Affine3< double>  Affine3d; 
# 293
static inline Vec3f operator*(const Affine3f & affine, const Vec3f & vector); 
# 294
static inline Vec3d operator*(const Affine3d & affine, const Vec3d & vector); 
# 296
template< class _Tp> class DataType< Affine3< _Tp> >  { 
# 299
public: typedef Affine3< _Tp>  value_type; 
# 300
typedef Affine3< typename cv::DataType< _Tp> ::work_type>  work_type; 
# 301
typedef _Tp channel_type; 
# 303
enum { generic_type, 
# 304
channels = 16, 
# 305
fmt = traits::template SafeFmt< channel_type> ::fmt + (((16) - 1) << 8)
# 310
}; 
# 312
typedef Vec< channel_type, channels>  vec_type; 
# 313
}; 
# 315
namespace traits { 
# 316
template< class _Tp> 
# 317
struct Depth< Affine3< _Tp> >  { enum { value = traits::Depth< _Tp> ::value}; }; 
# 318
template< class _Tp> 
# 319
struct Type< Affine3< _Tp> >  { enum { value = (Depth< _Tp> ::value & ((1 << 3) - 1)) + ((16 - 1) << 3)}; }; 
# 320
}
# 324
}
# 331
template< class T> inline 
# 332
cv::Affine3< T> ::Affine3() : matrix(Mat4::eye()) 
# 334
{ } 
# 336
template< class T> inline 
# 337
cv::Affine3< T> ::Affine3(const Mat4 &affine) : matrix(affine) 
# 339
{ } 
# 341
template< class T> inline 
# 342
cv::Affine3< T> ::Affine3(const Mat3 &R, const Vec3 &t) 
# 343
{ 
# 344
rotation(R); 
# 345
translation(t); 
# 346
(((matrix).val)[12]) = ((((matrix).val)[13]) = ((((matrix).val)[14]) = 0)); 
# 347
(((matrix).val)[15]) = 1; 
# 348
} 
# 350
template< class T> inline 
# 351
cv::Affine3< T> ::Affine3(const Vec3 &_rvec, const Vec3 &t) 
# 352
{ 
# 353
rotation(_rvec); 
# 354
translation(t); 
# 355
(((matrix).val)[12]) = ((((matrix).val)[13]) = ((((matrix).val)[14]) = 0)); 
# 356
(((matrix).val)[15]) = 1; 
# 357
} 
# 359
template< class T> inline 
# 360
cv::Affine3< T> ::Affine3(const Mat &data, const Vec3 &t) 
# 361
{ 
# 362
do { if (!(!(data.type() == cv::traits::template Type< T> ::value))) { ; } else { cv::error(cv::Error::StsAssert, "data.type() == cv::traits::Type<T>::value", __func__, "/usr/include/opencv4/opencv2/core/affine.hpp", 362); }  } while (0); 
# 363
do { if (!(!(data.channels() == 1))) { ; } else { cv::error(cv::Error::StsAssert, "data.channels() == 1", __func__, "/usr/include/opencv4/opencv2/core/affine.hpp", 363); }  } while (0); 
# 365
if (((data.cols) == 4) && ((data.rows) == 4)) 
# 366
{ 
# 367
data.copyTo(matrix); 
# 368
return; 
# 369
} else { 
# 370
if (((data.cols) == 4) && ((data.rows) == 3)) 
# 371
{ 
# 372
rotation(data(Rect(0, 0, 3, 3))); 
# 373
translation(data(Rect(3, 0, 1, 3))); 
# 374
} else 
# 376
{ 
# 377
rotation(data); 
# 378
translation(t); 
# 379
}  }  
# 381
(((matrix).val)[12]) = ((((matrix).val)[13]) = ((((matrix).val)[14]) = 0)); 
# 382
(((matrix).val)[15]) = 1; 
# 383
} 
# 385
template< class T> inline 
# 386
cv::Affine3< T> ::Affine3(const float_type *vals) : matrix(vals) 
# 387
{ } 
# 389
template< class T> inline cv::Affine3< T>  
# 390
cv::Affine3< T> ::Identity() 
# 391
{ 
# 392
return ((Affine3)(cv::template Affine3< T> ::Mat4::eye())); 
# 393
} 
# 395
template< class T> inline void 
# 396
cv::Affine3< T> ::rotation(const Mat3 &R) 
# 397
{ 
# 398
linear(R); 
# 399
} 
# 401
template< class T> inline void 
# 402
cv::Affine3< T> ::rotation(const Vec3 &_rvec) 
# 403
{ 
# 404
double theta = norm(_rvec); 
# 406
if (theta < ((double)(2.2204460492503130808E-16L))) { 
# 407
rotation(Mat3::eye()); } else 
# 409
{ 
# 410
double c = std::cos(theta); 
# 411
double s = std::sin(theta); 
# 412
double c1 = (1.0) - c; 
# 413
double itheta = (theta != (0)) ? (1.0) / theta : (0.0); 
# 415
Point3_< T>  r = _rvec * itheta; 
# 417
Mat3 rrt((r.x) * (r.x), (r.x) * (r.y), (r.x) * (r.z), (r.x) * (r.y), (r.y) * (r.y), (r.y) * (r.z), (r.x) * (r.z), (r.y) * (r.z), (r.z) * (r.z)); 
# 418
Mat3 r_x(0, -(r.z), (r.y), (r.z), 0, -(r.x), -(r.y), (r.x), 0); 
# 422
Mat3 R = ((c * Mat3::eye()) + (c1 * rrt)) + (s * r_x); 
# 424
rotation(R); 
# 425
}  
# 426
} 
# 429
template< class T> inline void 
# 430
cv::Affine3< T> ::rotation(const Mat &data) 
# 431
{ 
# 432
do { if (!(!(data.type() == cv::traits::template Type< T> ::value))) { ; } else { cv::error(cv::Error::StsAssert, "data.type() == cv::traits::Type<T>::value", __func__, "/usr/include/opencv4/opencv2/core/affine.hpp", 432); }  } while (0); 
# 433
do { if (!(!(data.channels() == 1))) { ; } else { cv::error(cv::Error::StsAssert, "data.channels() == 1", __func__, "/usr/include/opencv4/opencv2/core/affine.hpp", 433); }  } while (0); 
# 435
if (((data.cols) == 3) && ((data.rows) == 3)) 
# 436
{ 
# 437
Mat3 R; 
# 438
data.copyTo(R); 
# 439
rotation(R); 
# 440
} else { 
# 441
if ((((data.cols) == 3) && ((data.rows) == 1)) || (((data.cols) == 1) && ((data.rows) == 3))) 
# 442
{ 
# 443
Vec3 _rvec; 
# 444
(data.reshape(1, 3)).copyTo(_rvec); 
# 445
rotation(_rvec); 
# 446
} else { 
# 448
cv::error(Error::StsError, "Input matrix can only be 3x3, 1x3 or 3x1", __func__, "/usr/include/opencv4/opencv2/core/affine.hpp", 448); }  }  
# 449
} 
# 451
template< class T> inline void 
# 452
cv::Affine3< T> ::linear(const Mat3 &L) 
# 453
{ 
# 454
(((matrix).val)[0]) = ((L.val)[0]); (((matrix).val)[1]) = ((L.val)[1]); (((matrix).val)[2]) = ((L.val)[2]); 
# 455
(((matrix).val)[4]) = ((L.val)[3]); (((matrix).val)[5]) = ((L.val)[4]); (((matrix).val)[6]) = ((L.val)[5]); 
# 456
(((matrix).val)[8]) = ((L.val)[6]); (((matrix).val)[9]) = ((L.val)[7]); (((matrix).val)[10]) = ((L.val)[8]); 
# 457
} 
# 459
template< class T> inline void 
# 460
cv::Affine3< T> ::translation(const Vec3 &t) 
# 461
{ 
# 462
(((matrix).val)[3]) = (t[0]); (((matrix).val)[7]) = (t[1]); (((matrix).val)[11]) = (t[2]); 
# 463
} 
# 465
template< class T> inline typename cv::Affine3< T> ::Mat3 
# 466
cv::Affine3< T> ::rotation() const 
# 467
{ 
# 468
return linear(); 
# 469
} 
# 471
template< class T> inline typename cv::Affine3< T> ::Mat3 
# 472
cv::Affine3< T> ::linear() const 
# 473
{ 
# 474
Mat3 R; 
# 475
((R.val)[0]) = (((matrix).val)[0]); ((R.val)[1]) = (((matrix).val)[1]); ((R.val)[2]) = (((matrix).val)[2]); 
# 476
((R.val)[3]) = (((matrix).val)[4]); ((R.val)[4]) = (((matrix).val)[5]); ((R.val)[5]) = (((matrix).val)[6]); 
# 477
((R.val)[6]) = (((matrix).val)[8]); ((R.val)[7]) = (((matrix).val)[9]); ((R.val)[8]) = (((matrix).val)[10]); 
# 478
return R; 
# 479
} 
# 481
template< class T> inline typename cv::Affine3< T> ::Vec3 
# 482
cv::Affine3< T> ::translation() const 
# 483
{ 
# 484
return Vec3(((matrix).val)[3], ((matrix).val)[7], ((matrix).val)[11]); 
# 485
} 
# 487
template< class T> inline typename cv::Affine3< T> ::Vec3 
# 488
cv::Affine3< T> ::rvec() const 
# 489
{ 
# 490
Vec3d w; 
# 491
Matx33d u, vt, R = rotation(); 
# 492
cv::SVD::compute(R, w, u, vt, (cv::SVD::FULL_UV) + (cv::SVD::MODIFY_A)); 
# 493
R = (u * vt); 
# 495
double rx = ((R.val)[7]) - ((R.val)[5]); 
# 496
double ry = ((R.val)[2]) - ((R.val)[6]); 
# 497
double rz = ((R.val)[3]) - ((R.val)[1]); 
# 499
double s = std::sqrt((((rx * rx) + (ry * ry)) + (rz * rz)) * (0.25)); 
# 500
double c = (((((R.val)[0]) + ((R.val)[4])) + ((R.val)[8])) - (1)) * (0.5); 
# 501
c = ((c > (1.0)) ? (1.0) : ((c < (-(1.0))) ? -(1.0) : c)); 
# 502
double theta = acos(c); 
# 504
if (s < (1.0E-5)) 
# 505
{ 
# 506
if (c > (0)) { 
# 507
rx = (ry = (rz = (0))); } else 
# 509
{ 
# 510
double t; 
# 511
t = ((((R.val)[0]) + (1)) * (0.5)); 
# 512
rx = std::sqrt(std::max(t, (0.0))); 
# 513
t = ((((R.val)[4]) + (1)) * (0.5)); 
# 514
ry = (std::sqrt(std::max(t, (0.0))) * ((((R.val)[1]) < (0)) ? -(1.0) : (1.0))); 
# 515
t = ((((R.val)[8]) + (1)) * (0.5)); 
# 516
rz = (std::sqrt(std::max(t, (0.0))) * ((((R.val)[2]) < (0)) ? -(1.0) : (1.0))); 
# 518
if ((fabs(rx) < fabs(ry)) && (fabs(rx) < fabs(rz)) && ((((R.val)[5]) > (0)) != ((ry * rz) > (0)))) { 
# 519
rz = (-rz); }  
# 520
theta /= std::sqrt(((rx * rx) + (ry * ry)) + (rz * rz)); 
# 521
rx *= theta; 
# 522
ry *= theta; 
# 523
rz *= theta; 
# 524
}  
# 525
} else 
# 527
{ 
# 528
double vth = (1) / ((2) * s); 
# 529
vth *= theta; 
# 530
rx *= vth; ry *= vth; rz *= vth; 
# 531
}  
# 533
return Vec3d(rx, ry, rz); 
# 534
} 
# 536
template< class T> inline cv::Affine3< T>  
# 537
cv::Affine3< T> ::inv(int method) const 
# 538
{ 
# 539
return (matrix).inv(method); 
# 540
} 
# 542
template< class T> inline cv::Affine3< T>  
# 543
cv::Affine3< T> ::rotate(const Mat3 &R) const 
# 544
{ 
# 545
Mat3 Lc = linear(); 
# 546
Vec3 tc = translation(); 
# 547
Mat4 result; 
# 548
((result.val)[12]) = (((result.val)[13]) = (((result.val)[14]) = 0)); 
# 549
((result.val)[15]) = 1; 
# 551
for (int j = 0; j < 3; ++j) 
# 552
{ 
# 553
for (int i = 0; i < 3; ++i) 
# 554
{ 
# 555
float_type value = (0); 
# 556
for (int k = 0; k < 3; ++k) { 
# 557
value += (R(j, k) * Lc(k, i)); }  
# 558
result(j, i) = value; 
# 559
}  
# 561
result(j, 3) = R.row(j).dot(tc.t()); 
# 562
}  
# 563
return result; 
# 564
} 
# 566
template< class T> inline cv::Affine3< T>  
# 567
cv::Affine3< T> ::rotate(const Vec3 &_rvec) const 
# 568
{ 
# 569
return rotate(((Affine3< float> )(_rvec)).rotation()); 
# 570
} 
# 572
template< class T> inline cv::Affine3< T>  
# 573
cv::Affine3< T> ::translate(const Vec3 &t) const 
# 574
{ 
# 575
Mat4 m = matrix; 
# 576
((m.val)[3]) += (t[0]); 
# 577
((m.val)[7]) += (t[1]); 
# 578
((m.val)[11]) += (t[2]); 
# 579
return m; 
# 580
} 
# 582
template< class T> inline cv::Affine3< T>  
# 583
cv::Affine3< T> ::concatenate(const Affine3 &affine) const 
# 584
{ 
# 585
return (*this).rotate(affine.rotation()).translate(affine.translation()); 
# 586
} 
# 588
template< class T> template< class Y> inline 
# 589
cv::Affine3< T> ::operator cv::Affine3< Y> () const 
# 590
{ 
# 591
return ((Affine3< Y> )(matrix)); 
# 592
} 
# 594
template< class T> template< class Y> inline cv::Affine3< Y>  
# 595
cv::Affine3< T> ::cast() const 
# 596
{ 
# 597
return ((Affine3< Y> )(matrix)); 
# 598
} 
# 600
template< class T> inline cv::Affine3< T>  
# 601
cv::operator*(const Affine3< T>  &affine1, const Affine3< T>  &affine2) 
# 602
{ 
# 603
return affine2.concatenate(affine1); 
# 604
} 
# 606
template< class T, class V> inline V 
# 607
cv::operator*(const Affine3< T>  &affine, const V &v) 
# 608
{ 
# 609
const typename Affine3< T> ::Mat4 &m = ((affine.matrix)); 
# 611
V r; 
# 612
(r.x) = ((((((m.val)[0]) * (v.x)) + (((m.val)[1]) * (v.y))) + (((m.val)[2]) * (v.z))) + ((m.val)[3])); 
# 613
(r.y) = ((((((m.val)[4]) * (v.x)) + (((m.val)[5]) * (v.y))) + (((m.val)[6]) * (v.z))) + ((m.val)[7])); 
# 614
(r.z) = ((((((m.val)[8]) * (v.x)) + (((m.val)[9]) * (v.y))) + (((m.val)[10]) * (v.z))) + ((m.val)[11])); 
# 615
return r; 
# 616
} 
# 619
static inline cv::Vec3f cv::operator*(const Affine3f &affine, const Vec3f &v) 
# 620
{ 
# 621
const Matx44f &m = affine.matrix; 
# 622
Vec3f r; 
# 623
((r.val)[0]) = ((((((m.val)[0]) * v[0]) + (((m.val)[1]) * v[1])) + (((m.val)[2]) * v[2])) + ((m.val)[3])); 
# 624
((r.val)[1]) = ((((((m.val)[4]) * v[0]) + (((m.val)[5]) * v[1])) + (((m.val)[6]) * v[2])) + ((m.val)[7])); 
# 625
((r.val)[2]) = ((((((m.val)[8]) * v[0]) + (((m.val)[9]) * v[1])) + (((m.val)[10]) * v[2])) + ((m.val)[11])); 
# 626
return r; 
# 627
} 
# 630
static inline cv::Vec3d cv::operator*(const Affine3d &affine, const Vec3d &v) 
# 631
{ 
# 632
const Matx44d &m = affine.matrix; 
# 633
Vec3d r; 
# 634
((r.val)[0]) = ((((((m.val)[0]) * v[0]) + (((m.val)[1]) * v[1])) + (((m.val)[2]) * v[2])) + ((m.val)[3])); 
# 635
((r.val)[1]) = ((((((m.val)[4]) * v[0]) + (((m.val)[5]) * v[1])) + (((m.val)[6]) * v[2])) + ((m.val)[7])); 
# 636
((r.val)[2]) = ((((((m.val)[8]) * v[0]) + (((m.val)[9]) * v[1])) + (((m.val)[10]) * v[2])) + ((m.val)[11])); 
# 637
return r; 
# 638
} 
# 222 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
namespace cv { 
# 229
enum { LMEDS = 4, 
# 230
RANSAC = 8, 
# 231
RHO = 16
# 232
}; 
# 234
enum SolvePnPMethod { 
# 235
SOLVEPNP_ITERATIVE, 
# 236
SOLVEPNP_EPNP, 
# 237
SOLVEPNP_P3P, 
# 238
SOLVEPNP_DLS, 
# 239
SOLVEPNP_UPNP, 
# 240
SOLVEPNP_AP3P, 
# 241
SOLVEPNP_IPPE, 
# 243
SOLVEPNP_IPPE_SQUARE, 
# 251
SOLVEPNP_MAX_COUNT
# 253
}; 
# 255
enum { CALIB_CB_ADAPTIVE_THRESH = 1, 
# 256
CALIB_CB_NORMALIZE_IMAGE, 
# 257
CALIB_CB_FILTER_QUADS = 4, 
# 258
CALIB_CB_FAST_CHECK = 8, 
# 259
CALIB_CB_EXHAUSTIVE = 16, 
# 260
CALIB_CB_ACCURACY = 32
# 261
}; 
# 263
enum { CALIB_CB_SYMMETRIC_GRID = 1, 
# 264
CALIB_CB_ASYMMETRIC_GRID, 
# 265
CALIB_CB_CLUSTERING = 4
# 266
}; 
# 268
enum { CALIB_NINTRINSIC = 18, 
# 269
CALIB_USE_INTRINSIC_GUESS = 1, 
# 270
CALIB_FIX_ASPECT_RATIO, 
# 271
CALIB_FIX_PRINCIPAL_POINT = 4, 
# 272
CALIB_ZERO_TANGENT_DIST = 8, 
# 273
CALIB_FIX_FOCAL_LENGTH = 16, 
# 274
CALIB_FIX_K1 = 32, 
# 275
CALIB_FIX_K2 = 64, 
# 276
CALIB_FIX_K3 = 128, 
# 277
CALIB_FIX_K4 = 2048, 
# 278
CALIB_FIX_K5 = 4096, 
# 279
CALIB_FIX_K6 = 8192, 
# 280
CALIB_RATIONAL_MODEL = 16384, 
# 281
CALIB_THIN_PRISM_MODEL = 32768, 
# 282
CALIB_FIX_S1_S2_S3_S4 = 65536, 
# 283
CALIB_TILTED_MODEL = 262144, 
# 284
CALIB_FIX_TAUX_TAUY = 524288, 
# 285
CALIB_USE_QR = 1048576, 
# 286
CALIB_FIX_TANGENT_DIST = 2097152, 
# 288
CALIB_FIX_INTRINSIC = 256, 
# 289
CALIB_SAME_FOCAL_LENGTH = 512, 
# 291
CALIB_ZERO_DISPARITY = 1024, 
# 292
CALIB_USE_LU = (1 << 17), 
# 293
CALIB_USE_EXTRINSIC_GUESS = (1 << 22)
# 294
}; 
# 297
enum { FM_7POINT = 1, 
# 298
FM_8POINT, 
# 299
FM_LMEDS = 4, 
# 300
FM_RANSAC = 8
# 301
}; 
# 303
enum HandEyeCalibrationMethod { 
# 305
CALIB_HAND_EYE_TSAI, 
# 306
CALIB_HAND_EYE_PARK, 
# 307
CALIB_HAND_EYE_HORAUD, 
# 308
CALIB_HAND_EYE_ANDREFF, 
# 309
CALIB_HAND_EYE_DANIILIDIS
# 310
}; 
# 339 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian = noArray()); 
# 349 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
class LMSolver : public Algorithm { 
# 352
public: class Callback { 
# 355
public: virtual ~Callback() { } 
# 368 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
virtual bool compute(InputArray param, OutputArray err, OutputArray J) const = 0; 
# 369
}; 
# 383 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
virtual int run(InputOutputArray param) const = 0; 
# 389
virtual void setMaxIters(int maxIters) = 0; 
# 393
virtual int getMaxIters() const = 0; 
# 402 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
static Ptr< LMSolver>  create(const Ptr< Callback>  & cb, int maxIters); 
# 403
static Ptr< LMSolver>  create(const Ptr< Callback>  & cb, int maxIters, double eps); 
# 404
}; 
# 473 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method = 0, double ransacReprojThreshold = 3, OutputArray mask = noArray(), const int maxIters = 2000, const double confidence = (0.995)); 
# 479
Mat findHomography(InputArray srcPoints, InputArray dstPoints, OutputArray mask, int method = 0, double ransacReprojThreshold = 3); 
# 501 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Vec3d RQDecomp3x3(InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx = noArray(), OutputArray Qy = noArray(), OutputArray Qz = noArray()); 
# 528 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void decomposeProjectionMatrix(InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX = noArray(), OutputArray rotMatrixY = noArray(), OutputArray rotMatrixZ = noArray(), OutputArray eulerAngles = noArray()); 
# 548 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void matMulDeriv(InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB); 
# 579 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void composeRT(InputArray rvec1, InputArray tvec1, InputArray rvec2, InputArray tvec2, OutputArray rvec3, OutputArray tvec3, OutputArray dr3dr1 = noArray(), OutputArray dr3dt1 = noArray(), OutputArray dr3dr2 = noArray(), OutputArray dr3dt2 = noArray(), OutputArray dt3dr1 = noArray(), OutputArray dt3dt1 = noArray(), OutputArray dt3dr2 = noArray(), OutputArray dt3dt2 = noArray()); 
# 619 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian = noArray(), double aspectRatio = 0); 
# 813 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess = false, int flags = SOLVEPNP_ITERATIVE); 
# 860 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
bool solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess = false, int iterationsCount = 100, float reprojectionError = (8.0), double confidence = (0.99), OutputArray inliers = noArray(), int flags = SOLVEPNP_ITERATIVE); 
# 893 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
int solveP3P(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags); 
# 921 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void solvePnPRefineLM(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, InputOutputArray rvec, InputOutputArray tvec, TermCriteria criteria = TermCriteria((TermCriteria::EPS) + (TermCriteria::COUNT), 20, (1.1920929E-7F))); 
# 951 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void solvePnPRefineVVS(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, InputOutputArray rvec, InputOutputArray tvec, TermCriteria criteria = TermCriteria((TermCriteria::EPS) + (TermCriteria::COUNT), 20, (1.1920929E-7F)), double VVSlambda = 1); 
# 1146 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
int solvePnPGeneric(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, bool useExtrinsicGuess = false, SolvePnPMethod flags = SOLVEPNP_ITERATIVE, InputArray rvec = noArray(), InputArray tvec = noArray(), OutputArray reprojectionError = noArray()); 
# 1168 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat initCameraMatrix2D(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio = (1.0)); 
# 1221 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags = (CALIB_CB_ADAPTIVE_THRESH) + (CALIB_CB_NORMALIZE_IMAGE)); 
# 1228
bool checkChessboard(InputArray img, Size size); 
# 1260 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
bool findChessboardCornersSB(InputArray image, Size patternSize, OutputArray corners, int flags = 0); 
# 1263
bool find4QuadCornerSubpix(InputArray img, InputOutputArray corners, Size region_size); 
# 1277 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void drawChessboardCorners(InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound); 
# 1297 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void drawFrameAxes(InputOutputArray image, InputArray cameraMatrix, InputArray distCoeffs, InputArray rvec, InputArray tvec, float length, int thickness = 3); 
# 1300
struct CirclesGridFinderParameters { 
# 1302
CirclesGridFinderParameters(); 
# 1303
Size2f densityNeighborhoodSize; 
# 1304
float minDensity; 
# 1305
int kmeansAttempts; 
# 1306
int minDistanceToAddKeypoint; 
# 1307
int keypointScale; 
# 1308
float minGraphConfidence; 
# 1309
float vertexGain; 
# 1310
float vertexPenalty; 
# 1311
float existingVertexGain; 
# 1312
float edgeGain; 
# 1313
float edgePenalty; 
# 1314
float convexHullFactor; 
# 1315
float minRNGEdgeSwitchDist; 
# 1317
enum GridType { 
# 1319
SYMMETRIC_GRID, ASYMMETRIC_GRID
# 1320
}; 
# 1321
GridType gridType; 
# 1323
float squareSize; 
# 1324
float maxRectifiedDistance; 
# 1325
}; 
# 1328
typedef CirclesGridFinderParameters CirclesGridFinderParameters2; 
# 1363 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
bool findCirclesGrid(InputArray image, Size patternSize, OutputArray centers, int flags, const Ptr< Feature2D>  & blobDetector, const CirclesGridFinderParameters & parameters); 
# 1369
bool findCirclesGrid(InputArray image, Size patternSize, OutputArray centers, int flags = CALIB_CB_SYMMETRIC_GRID, const Ptr< Feature2D>  & blobDetector = SimpleBlobDetector::create()); 
# 1486 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, OutputArray stdDeviationsIntrinsics, OutputArray stdDeviationsExtrinsics, OutputArray perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (double)(2.2204460492503130808E-16L))); 
# 1497
double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags = 0, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (double)(2.2204460492503130808E-16L))); 
# 1561 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
double calibrateCameraRO(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, int iFixedPoint, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, OutputArray newObjPoints, OutputArray stdDeviationsIntrinsics, OutputArray stdDeviationsExtrinsics, OutputArray stdDeviationsObjPoints, OutputArray perViewErrors, int flags = 0, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (double)(2.2204460492503130808E-16L))); 
# 1574
double calibrateCameraRO(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, int iFixedPoint, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, OutputArray newObjPoints, int flags = 0, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (double)(2.2204460492503130808E-16L))); 
# 1602 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void calibrationMatrixValues(InputArray cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double & fovx, double & fovy, double & focalLength, Point2d & principalPoint, double & aspectRatio); 
# 1703 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, InputOutputArray R, InputOutputArray T, OutputArray E, OutputArray F, OutputArray perViewErrors, int flags = CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (1.0E-6))); 
# 1712
double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, int flags = CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (1.0E-6))); 
# 1799 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags = CALIB_ZERO_DISPARITY, double alpha = -1, Size newImageSize = Size(), Rect * validPixROI1 = 0, Rect * validPixROI2 = 0); 
# 1837 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold = 5); 
# 1843
float rectify3Collinear(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, InputArray cameraMatrix3, InputArray distCoeffs3, InputArrayOfArrays imgpt1, InputArrayOfArrays imgpt3, Size imageSize, InputArray R12, InputArray T12, InputArray R13, InputArray T13, OutputArray R1, OutputArray R2, OutputArray R3, OutputArray P1, OutputArray P2, OutputArray P3, OutputArray Q, double alpha, Size newImgSize, Rect * roi1, Rect * roi2, int flags); 
# 1881 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize = Size(), Rect * validPixROI = 0, bool centerPrincipalPoint = false); 
# 2014 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void calibrateHandEye(InputArrayOfArrays R_gripper2base, InputArrayOfArrays t_gripper2base, InputArrayOfArrays R_target2cam, InputArrayOfArrays t_target2cam, OutputArray R_cam2gripper, OutputArray t_cam2gripper, HandEyeCalibrationMethod method = CALIB_HAND_EYE_TSAI); 
# 2027 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void convertPointsToHomogeneous(InputArray src, OutputArray dst); 
# 2038 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void convertPointsFromHomogeneous(InputArray src, OutputArray dst); 
# 2050 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void convertPointsHomogeneous(InputArray src, OutputArray dst); 
# 2102 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat findFundamentalMat(InputArray points1, InputArray points2, int method = FM_RANSAC, double ransacReprojThreshold = (3.0), double confidence = (0.99), OutputArray mask = noArray()); 
# 2108
Mat findFundamentalMat(InputArray points1, InputArray points2, OutputArray mask, int method = FM_RANSAC, double ransacReprojThreshold = (3.0), double confidence = (0.99)); 
# 2141 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat findEssentialMat(InputArray points1, InputArray points2, InputArray cameraMatrix, int method = RANSAC, double prob = (0.999), double threshold = (1.0), OutputArray mask = noArray()); 
# 2175 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat findEssentialMat(InputArray points1, InputArray points2, double focal = (1.0), Point2d pp = Point2d(0, 0), int method = RANSAC, double prob = (0.999), double threshold = (1.0), OutputArray mask = noArray()); 
# 2191 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void decomposeEssentialMat(InputArray E, OutputArray R1, OutputArray R2, OutputArray t); 
# 2238 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
int recoverPose(InputArray E, InputArray points1, InputArray points2, InputArray cameraMatrix, OutputArray R, OutputArray t, InputOutputArray mask = noArray()); 
# 2267 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
int recoverPose(InputArray E, InputArray points1, InputArray points2, OutputArray R, OutputArray t, double focal = (1.0), Point2d pp = Point2d(0, 0), InputOutputArray mask = noArray()); 
# 2290 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
int recoverPose(InputArray E, InputArray points1, InputArray points2, InputArray cameraMatrix, OutputArray R, OutputArray t, double distanceThresh, InputOutputArray mask = noArray(), OutputArray triangulatedPoints = noArray()); 
# 2317 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void computeCorrespondEpilines(InputArray points, int whichImage, InputArray F, OutputArray lines); 
# 2339 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void triangulatePoints(InputArray projMatr1, InputArray projMatr2, InputArray projPoints1, InputArray projPoints2, OutputArray points4D); 
# 2358 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void correctMatches(InputArray F, InputArray points1, InputArray points2, OutputArray newPoints1, OutputArray newPoints2); 
# 2373 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void filterSpeckles(InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff, InputOutputArray buf = noArray()); 
# 2378
Rect getValidDisparityROI(Rect roi1, Rect roi2, int minDisparity, int numberOfDisparities, int SADWindowSize); 
# 2383
void validateDisparity(InputOutputArray disparity, InputArray cost, int minDisparity, int numberOfDisparities, int disp12MaxDisp = 1); 
# 2416 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues = false, int ddepth = -1); 
# 2438 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
double sampsonDistance(InputArray pt1, InputArray pt2, InputArray F); 
# 2488 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
int estimateAffine3D(InputArray src, InputArray dst, OutputArray out, OutputArray inliers, double ransacThreshold = 3, double confidence = (0.99)); 
# 2554 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat estimateAffine2D(InputArray from, InputArray to, OutputArray inliers = noArray(), int method = RANSAC, double ransacReprojThreshold = 3, size_t maxIters = 2000, double confidence = (0.99), size_t refineIters = 10); 
# 2602 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat estimateAffinePartial2D(InputArray from, InputArray to, OutputArray inliers = noArray(), int method = RANSAC, double ransacReprojThreshold = 3, size_t maxIters = 2000, double confidence = (0.99), size_t refineIters = 10); 
# 2627 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
int decomposeHomographyMat(InputArray H, InputArray K, OutputArrayOfArrays rotations, OutputArrayOfArrays translations, OutputArrayOfArrays normals); 
# 2651 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void filterHomographyDecompByVisibleRefpoints(InputArrayOfArrays rotations, InputArrayOfArrays normals, InputArray beforePoints, InputArray afterPoints, OutputArray possibleSolutions, InputArray pointsMask = noArray()); 
# 2660
class StereoMatcher : public Algorithm { 
# 2663
public: enum { DISP_SHIFT = 4, 
# 2664
DISP_SCALE = (1 << DISP_SHIFT)
# 2665
}; 
# 2675 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
virtual void compute(InputArray left, InputArray right, OutputArray disparity) = 0; 
# 2678
virtual int getMinDisparity() const = 0; 
# 2679
virtual void setMinDisparity(int minDisparity) = 0; 
# 2681
virtual int getNumDisparities() const = 0; 
# 2682
virtual void setNumDisparities(int numDisparities) = 0; 
# 2684
virtual int getBlockSize() const = 0; 
# 2685
virtual void setBlockSize(int blockSize) = 0; 
# 2687
virtual int getSpeckleWindowSize() const = 0; 
# 2688
virtual void setSpeckleWindowSize(int speckleWindowSize) = 0; 
# 2690
virtual int getSpeckleRange() const = 0; 
# 2691
virtual void setSpeckleRange(int speckleRange) = 0; 
# 2693
virtual int getDisp12MaxDiff() const = 0; 
# 2694
virtual void setDisp12MaxDiff(int disp12MaxDiff) = 0; 
# 2695
}; 
# 2701
class StereoBM : public StereoMatcher { 
# 2704
public: enum { PREFILTER_NORMALIZED_RESPONSE, 
# 2705
PREFILTER_XSOBEL
# 2706
}; 
# 2708
virtual int getPreFilterType() const = 0; 
# 2709
virtual void setPreFilterType(int preFilterType) = 0; 
# 2711
virtual int getPreFilterSize() const = 0; 
# 2712
virtual void setPreFilterSize(int preFilterSize) = 0; 
# 2714
virtual int getPreFilterCap() const = 0; 
# 2715
virtual void setPreFilterCap(int preFilterCap) = 0; 
# 2717
virtual int getTextureThreshold() const = 0; 
# 2718
virtual void setTextureThreshold(int textureThreshold) = 0; 
# 2720
virtual int getUniquenessRatio() const = 0; 
# 2721
virtual void setUniquenessRatio(int uniquenessRatio) = 0; 
# 2723
virtual int getSmallerBlockSize() const = 0; 
# 2724
virtual void setSmallerBlockSize(int blockSize) = 0; 
# 2726
virtual Rect getROI1() const = 0; 
# 2727
virtual void setROI1(Rect roi1) = 0; 
# 2729
virtual Rect getROI2() const = 0; 
# 2730
virtual void setROI2(Rect roi2) = 0; 
# 2745 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
static Ptr< StereoBM>  create(int numDisparities = 0, int blockSize = 21); 
# 2746
}; 
# 2766 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
class StereoSGBM : public StereoMatcher { 
# 2770
public: enum { 
# 2771
MODE_SGBM, 
# 2772
MODE_HH, 
# 2773
MODE_SGBM_3WAY, 
# 2774
MODE_HH4
# 2775
}; 
# 2777
virtual int getPreFilterCap() const = 0; 
# 2778
virtual void setPreFilterCap(int preFilterCap) = 0; 
# 2780
virtual int getUniquenessRatio() const = 0; 
# 2781
virtual void setUniquenessRatio(int uniquenessRatio) = 0; 
# 2783
virtual int getP1() const = 0; 
# 2784
virtual void setP1(int P1) = 0; 
# 2786
virtual int getP2() const = 0; 
# 2787
virtual void setP2(int P2) = 0; 
# 2789
virtual int getMode() const = 0; 
# 2790
virtual void setMode(int mode) = 0; 
# 2829 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
static Ptr< StereoSGBM>  create(int minDisparity = 0, int numDisparities = 16, int blockSize = 3, int P1 = 0, int P2 = 0, int disp12MaxDiff = 0, int preFilterCap = 0, int uniquenessRatio = 0, int speckleWindowSize = 0, int speckleRange = 0, int mode = StereoSGBM::MODE_SGBM); 
# 2834
}; 
# 2838
enum UndistortTypes { 
# 2840
PROJ_SPHERICAL_ORTHO, 
# 2841
PROJ_SPHERICAL_EQRECT
# 2842
}; 
# 2873 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix = noArray()); 
# 2941 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2); 
# 2947
float initWideAngleProjMap(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, int destImageWidth, int m1type, OutputArray map1, OutputArray map2, UndistortTypes projType = PROJ_SPHERICAL_EQRECT, double alpha = 0); 
# 2952
static inline float initWideAngleProjMap(InputArray cameraMatrix, InputArray distCoeffs, Size 
# 2953
imageSize, int destImageWidth, int 
# 2954
m1type, OutputArray map1, OutputArray map2, int 
# 2955
projType, double alpha = 0) 
# 2956
{ 
# 2957
return initWideAngleProjMap(cameraMatrix, distCoeffs, imageSize, destImageWidth, m1type, map1, map2, (UndistortTypes)projType, alpha); 
# 2959
} 
# 2984 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
Mat getDefaultNewCameraMatrix(InputArray cameraMatrix, Size imgsize = Size(), bool centerPrincipalPoint = false); 
# 3028 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R = noArray(), InputArray P = noArray()); 
# 3035
void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P, TermCriteria criteria); 
# 3044
namespace fisheye { 
# 3049
enum { 
# 3050
CALIB_USE_INTRINSIC_GUESS = (1 << 0), 
# 3051
CALIB_RECOMPUTE_EXTRINSIC, 
# 3052
CALIB_CHECK_COND = (1 << 2), 
# 3053
CALIB_FIX_SKEW = (1 << 3), 
# 3054
CALIB_FIX_K1 = (1 << 4), 
# 3055
CALIB_FIX_K2 = (1 << 5), 
# 3056
CALIB_FIX_K3 = (1 << 6), 
# 3057
CALIB_FIX_K4 = (1 << 7), 
# 3058
CALIB_FIX_INTRINSIC = (1 << 8), 
# 3059
CALIB_FIX_PRINCIPAL_POINT = (1 << 9)
# 3060
}; 
# 3082 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void projectPoints(InputArray objectPoints, OutputArray imagePoints, const Affine3d & affine, InputArray K, InputArray D, double alpha = 0, OutputArray jacobian = noArray()); 
# 3086
void projectPoints(InputArray objectPoints, OutputArray imagePoints, InputArray rvec, InputArray tvec, InputArray K, InputArray D, double alpha = 0, OutputArray jacobian = noArray()); 
# 3102 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void distortPoints(InputArray undistorted, OutputArray distorted, InputArray K, InputArray D, double alpha = 0); 
# 3115 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void undistortPoints(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray R = noArray(), InputArray P = noArray()); 
# 3132 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void initUndistortRectifyMap(InputArray K, InputArray D, InputArray R, InputArray P, const Size & size, int m1type, OutputArray map1, OutputArray map2); 
# 3163 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void undistortImage(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray Knew = cv::noArray(), const Size & new_size = Size()); 
# 3179 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void estimateNewCameraMatrixForUndistortRectify(InputArray K, InputArray D, const Size & image_size, InputArray R, OutputArray P, double balance = (0.0), const Size & new_size = Size(), double fov_scale = (1.0)); 
# 3215 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
double calibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, const Size & image_size, InputOutputArray K, InputOutputArray D, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags = 0, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 100, (double)(2.2204460492503130808E-16L))); 
# 3249 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
void stereoRectify(InputArray K1, InputArray D1, InputArray K2, InputArray D2, const Size & imageSize, InputArray R, InputArray tvec, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, const Size & newImageSize = Size(), double balance = (0.0), double fov_scale = (1.0)); 
# 3285 "/usr/include/opencv4/opencv2/calib3d.hpp" 3
double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray K1, InputOutputArray D1, InputOutputArray K2, InputOutputArray D2, Size imageSize, OutputArray R, OutputArray T, int flags = fisheye::CALIB_FIX_INTRINSIC, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 100, (double)(2.2204460492503130808E-16L))); 
# 3291
}
# 3293
}
# 15 "/usr/include/opencv4/opencv2/core/async.hpp" 3
namespace cv { 
# 31 "/usr/include/opencv4/opencv2/core/async.hpp" 3
class AsyncArray { 
# 34
public: ~AsyncArray() noexcept; 
# 35
AsyncArray() noexcept; 
# 36
AsyncArray(const AsyncArray & o) noexcept; 
# 37
AsyncArray &operator=(const AsyncArray & o) noexcept; 
# 38
void release() noexcept; 
# 50 "/usr/include/opencv4/opencv2/core/async.hpp" 3
void get(OutputArray dst) const; 
# 60 "/usr/include/opencv4/opencv2/core/async.hpp" 3
bool get(OutputArray dst, int64 timeoutNs) const; 
# 63
bool get(OutputArray dst, double timeoutNs) const { return this->get(dst, (int64)timeoutNs); } 
# 65
bool wait_for(int64 timeoutNs) const; 
# 68
bool wait_for(double timeoutNs) const { return this->wait_for((int64)timeoutNs); } 
# 70
bool valid() const noexcept; 
# 73
AsyncArray(AsyncArray &&o) { (p) = (o.p); (o.p) = (__null); } 
# 74
AsyncArray &operator=(AsyncArray &&o) noexcept { std::swap(p, o.p); return *this; } 
# 76
template< class _Rep, class _Period> bool 
# 77
get(OutputArray dst, const std::chrono::duration< _Rep, _Period>  &timeout) 
# 78
{ 
# 79
return this->get(dst, (int64)((std::chrono::duration< int64_t, std::nano> )(timeout)).count()); 
# 80
} 
# 82
template< class _Rep, class _Period> bool 
# 83
wait_for(const std::chrono::duration< _Rep, _Period>  &timeout) 
# 84
{ 
# 85
return this->wait_for((int64)((std::chrono::duration< int64_t, std::nano> )(timeout)).count()); 
# 86
} 
# 96 "/usr/include/opencv4/opencv2/core/async.hpp" 3
struct Impl; friend struct Impl; 
# 97
void *_getImpl() const noexcept { return p; } 
# 99
protected: Impl *p; 
# 100
}; 
# 104
}
# 15 "/usr/include/opencv4/opencv2/dnn/version.hpp" 3
namespace cv { namespace dnn { namespace dnn4_v20191202 { }using namespace dnn4_v20191202;}}
# 75 "/usr/include/c++/9/bits/stl_tree.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 99 "/usr/include/c++/9/bits/stl_tree.h" 3
enum _Rb_tree_color { _S_red, _S_black}; 
# 101
struct _Rb_tree_node_base { 
# 103
typedef _Rb_tree_node_base *_Base_ptr; 
# 104
typedef const _Rb_tree_node_base *_Const_Base_ptr; 
# 106
_Rb_tree_color _M_color; 
# 107
_Base_ptr _M_parent; 
# 108
_Base_ptr _M_left; 
# 109
_Base_ptr _M_right; 
# 112
static _Base_ptr _S_minimum(_Base_ptr __x) noexcept 
# 113
{ 
# 114
while ((__x->_M_left) != (0)) { __x = (__x->_M_left); }  
# 115
return __x; 
# 116
} 
# 119
static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x) noexcept 
# 120
{ 
# 121
while ((__x->_M_left) != (0)) { __x = (__x->_M_left); }  
# 122
return __x; 
# 123
} 
# 126
static _Base_ptr _S_maximum(_Base_ptr __x) noexcept 
# 127
{ 
# 128
while ((__x->_M_right) != (0)) { __x = (__x->_M_right); }  
# 129
return __x; 
# 130
} 
# 133
static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x) noexcept 
# 134
{ 
# 135
while ((__x->_M_right) != (0)) { __x = (__x->_M_right); }  
# 136
return __x; 
# 137
} 
# 138
}; 
# 141
template< class _Key_compare> 
# 142
struct _Rb_tree_key_compare { 
# 144
_Key_compare _M_key_compare; 
# 146
_Rb_tree_key_compare() noexcept(is_nothrow_default_constructible< _Key_compare> ::value) : _M_key_compare() 
# 150
{ } 
# 152
_Rb_tree_key_compare(const _Key_compare &__comp) : _M_key_compare(__comp) 
# 154
{ } 
# 158
_Rb_tree_key_compare(const _Rb_tree_key_compare &) = default;
# 160
_Rb_tree_key_compare(_Rb_tree_key_compare &&__x) noexcept(is_nothrow_copy_constructible< _Key_compare> ::value) : _M_key_compare(__x._M_key_compare) 
# 163
{ } 
# 165
}; 
# 168
struct _Rb_tree_header { 
# 170
_Rb_tree_node_base _M_header; 
# 171
size_t _M_node_count; 
# 173
_Rb_tree_header() noexcept 
# 174
{ 
# 175
((_M_header)._M_color) = _S_red; 
# 176
this->_M_reset(); 
# 177
} 
# 180
_Rb_tree_header(_Rb_tree_header &&__x) noexcept 
# 181
{ 
# 182
if (((__x._M_header)._M_parent) != (nullptr)) { 
# 183
this->_M_move_data(__x); } else 
# 185
{ 
# 186
((_M_header)._M_color) = _S_red; 
# 187
this->_M_reset(); 
# 188
}  
# 189
} 
# 193
void _M_move_data(_Rb_tree_header &__from) 
# 194
{ 
# 195
((_M_header)._M_color) = ((__from._M_header)._M_color); 
# 196
((_M_header)._M_parent) = ((__from._M_header)._M_parent); 
# 197
((_M_header)._M_left) = ((__from._M_header)._M_left); 
# 198
((_M_header)._M_right) = ((__from._M_header)._M_right); 
# 199
(((_M_header)._M_parent)->_M_parent) = (&(_M_header)); 
# 200
(_M_node_count) = (__from._M_node_count); 
# 202
__from._M_reset(); 
# 203
} 
# 206
void _M_reset() 
# 207
{ 
# 208
((_M_header)._M_parent) = (0); 
# 209
((_M_header)._M_left) = (&(_M_header)); 
# 210
((_M_header)._M_right) = (&(_M_header)); 
# 211
(_M_node_count) = (0); 
# 212
} 
# 213
}; 
# 215
template< class _Val> 
# 216
struct _Rb_tree_node : public _Rb_tree_node_base { 
# 218
typedef _Rb_tree_node *_Link_type; 
# 231 "/usr/include/c++/9/bits/stl_tree.h" 3
__gnu_cxx::__aligned_membuf< _Val>  _M_storage; 
# 234
_Val *_M_valptr() 
# 235
{ return (_M_storage)._M_ptr(); } 
# 238
const _Val *_M_valptr() const 
# 239
{ return (_M_storage)._M_ptr(); } 
# 241
}; 
# 243
__attribute((__pure__)) _Rb_tree_node_base *
# 244
_Rb_tree_increment(_Rb_tree_node_base * __x) throw(); 
# 246
__attribute((__pure__)) const _Rb_tree_node_base *
# 247
_Rb_tree_increment(const _Rb_tree_node_base * __x) throw(); 
# 249
__attribute((__pure__)) _Rb_tree_node_base *
# 250
_Rb_tree_decrement(_Rb_tree_node_base * __x) throw(); 
# 252
__attribute((__pure__)) const _Rb_tree_node_base *
# 253
_Rb_tree_decrement(const _Rb_tree_node_base * __x) throw(); 
# 255
template< class _Tp> 
# 256
struct _Rb_tree_iterator { 
# 258
typedef _Tp value_type; 
# 259
typedef _Tp &reference; 
# 260
typedef _Tp *pointer; 
# 262
typedef bidirectional_iterator_tag iterator_category; 
# 263
typedef ptrdiff_t difference_type; 
# 265
typedef _Rb_tree_iterator _Self; 
# 266
typedef _Rb_tree_node_base::_Base_ptr _Base_ptr; 
# 267
typedef _Rb_tree_node< _Tp>  *_Link_type; 
# 269
_Rb_tree_iterator() noexcept : _M_node() 
# 270
{ } 
# 273
explicit _Rb_tree_iterator(_Base_ptr __x) noexcept : _M_node(__x) 
# 274
{ } 
# 277
reference operator*() const noexcept 
# 278
{ return *(static_cast< _Link_type>(_M_node))->_M_valptr(); } 
# 281
pointer operator->() const noexcept 
# 282
{ return (static_cast< _Link_type>(_M_node))->_M_valptr(); } 
# 285
_Self &operator++() noexcept 
# 286
{ 
# 287
(_M_node) = _Rb_tree_increment(_M_node); 
# 288
return *this; 
# 289
} 
# 292
_Self operator++(int) noexcept 
# 293
{ 
# 294
_Self __tmp = *this; 
# 295
(_M_node) = _Rb_tree_increment(_M_node); 
# 296
return __tmp; 
# 297
} 
# 300
_Self &operator--() noexcept 
# 301
{ 
# 302
(_M_node) = _Rb_tree_decrement(_M_node); 
# 303
return *this; 
# 304
} 
# 307
_Self operator--(int) noexcept 
# 308
{ 
# 309
_Self __tmp = *this; 
# 310
(_M_node) = _Rb_tree_decrement(_M_node); 
# 311
return __tmp; 
# 312
} 
# 315
friend inline bool operator==(const typename _Rb_tree_iterator< _Tp> ::_Self &__x, const typename _Rb_tree_iterator< _Tp> ::_Self &__y) noexcept 
# 316
{ return (__x._M_node) == (__y._M_node); } 
# 319
friend inline bool operator!=(const typename _Rb_tree_iterator< _Tp> ::_Self &__x, const typename _Rb_tree_iterator< _Tp> ::_Self &__y) noexcept 
# 320
{ return (__x._M_node) != (__y._M_node); } 
# 322
_Base_ptr _M_node; 
# 323
}; 
# 325
template< class _Tp> 
# 326
struct _Rb_tree_const_iterator { 
# 328
typedef _Tp value_type; 
# 329
typedef const _Tp &reference; 
# 330
typedef const _Tp *pointer; 
# 332
typedef _Rb_tree_iterator< _Tp>  iterator; 
# 334
typedef bidirectional_iterator_tag iterator_category; 
# 335
typedef ptrdiff_t difference_type; 
# 337
typedef _Rb_tree_const_iterator _Self; 
# 338
typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr; 
# 339
typedef const _Rb_tree_node< _Tp>  *_Link_type; 
# 341
_Rb_tree_const_iterator() noexcept : _M_node() 
# 342
{ } 
# 345
explicit _Rb_tree_const_iterator(_Base_ptr __x) noexcept : _M_node(__x) 
# 346
{ } 
# 348
_Rb_tree_const_iterator(const iterator &__it) noexcept : _M_node(((__it._M_node))) 
# 349
{ } 
# 352
iterator _M_const_cast() const noexcept 
# 353
{ return ((_Rb_tree_iterator< _Tp> )(const_cast< typename _Rb_tree_iterator< _Tp> ::_Base_ptr>(_M_node))); } 
# 356
reference operator*() const noexcept 
# 357
{ return *(static_cast< _Link_type>(_M_node))->_M_valptr(); } 
# 360
pointer operator->() const noexcept 
# 361
{ return (static_cast< _Link_type>(_M_node))->_M_valptr(); } 
# 364
_Self &operator++() noexcept 
# 365
{ 
# 366
(_M_node) = _Rb_tree_increment(_M_node); 
# 367
return *this; 
# 368
} 
# 371
_Self operator++(int) noexcept 
# 372
{ 
# 373
_Self __tmp = *this; 
# 374
(_M_node) = _Rb_tree_increment(_M_node); 
# 375
return __tmp; 
# 376
} 
# 379
_Self &operator--() noexcept 
# 380
{ 
# 381
(_M_node) = _Rb_tree_decrement(_M_node); 
# 382
return *this; 
# 383
} 
# 386
_Self operator--(int) noexcept 
# 387
{ 
# 388
_Self __tmp = *this; 
# 389
(_M_node) = _Rb_tree_decrement(_M_node); 
# 390
return __tmp; 
# 391
} 
# 394
friend inline bool operator==(const typename _Rb_tree_const_iterator< _Tp> ::_Self &__x, const typename _Rb_tree_const_iterator< _Tp> ::_Self &__y) noexcept 
# 395
{ return (__x._M_node) == (__y._M_node); } 
# 398
friend inline bool operator!=(const typename _Rb_tree_const_iterator< _Tp> ::_Self &__x, const typename _Rb_tree_const_iterator< _Tp> ::_Self &__y) noexcept 
# 399
{ return (__x._M_node) != (__y._M_node); } 
# 401
_Base_ptr _M_node; 
# 402
}; 
# 405
void _Rb_tree_insert_and_rebalance(const bool __insert_left, _Rb_tree_node_base * __x, _Rb_tree_node_base * __p, _Rb_tree_node_base & __header) throw(); 
# 411
_Rb_tree_node_base *_Rb_tree_rebalance_for_erase(_Rb_tree_node_base *const __z, _Rb_tree_node_base & __header) throw(); 
# 415
template< class _Cmp, class _SfinaeType, class  = __void_t< > > 
# 416
struct __has_is_transparent { 
# 417
}; 
# 419
template< class _Cmp, class _SfinaeType> 
# 420
struct __has_is_transparent< _Cmp, _SfinaeType, __void_t< typename _Cmp::is_transparent> >  { 
# 422
typedef void type; }; 
# 424
template< class _Cmp, class _SfinaeType> using __has_is_transparent_t = typename __has_is_transparent< _Cmp, _SfinaeType> ::type; 
# 434
template< class _Key, class _Val, class _KeyOfValue, class 
# 435
_Compare, class _Alloc = allocator< _Val> > 
# 436
class _Rb_tree { 
# 439
typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Rb_tree_node< _Val> > ::other _Node_allocator; 
# 441
typedef __gnu_cxx::__alloc_traits< _Node_allocator>  _Alloc_traits; 
# 444
protected: typedef _Rb_tree_node_base *_Base_ptr; 
# 445
typedef const _Rb_tree_node_base *_Const_Base_ptr; 
# 446
typedef _Rb_tree_node< _Val>  *_Link_type; 
# 447
typedef const _Rb_tree_node< _Val>  *_Const_Link_type; 
# 452
private: struct _Reuse_or_alloc_node { 
# 454
_Reuse_or_alloc_node(_Rb_tree &__t) : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t) 
# 456
{ 
# 457
if (_M_root) 
# 458
{ 
# 459
((_M_root)->_M_parent) = (0); 
# 461
if ((_M_nodes)->_M_left) { 
# 462
(_M_nodes) = ((_M_nodes)->_M_left); }  
# 463
} else { 
# 465
(_M_nodes) = (0); }  
# 466
} 
# 469
_Reuse_or_alloc_node(const _Reuse_or_alloc_node &) = delete;
# 472
~_Reuse_or_alloc_node() 
# 473
{ (_M_t)._M_erase(static_cast< _Link_type>(_M_root)); } 
# 475
template< class _Arg> _Link_type 
# 480
operator()(_Arg &&__arg) 
# 482
{ 
# 483
_Link_type __node = static_cast< _Link_type>(_M_extract()); 
# 484
if (__node) 
# 485
{ 
# 486
(_M_t)._M_destroy_node(__node); 
# 487
(_M_t)._M_construct_node(__node, std::forward< _Arg> (__arg)); 
# 488
return __node; 
# 489
}  
# 491
return (_M_t)._M_create_node(std::forward< _Arg> (__arg)); 
# 492
} 
# 496
private: _Base_ptr _M_extract() 
# 497
{ 
# 498
if (!(_M_nodes)) { 
# 499
return _M_nodes; }  
# 501
_Base_ptr __node = _M_nodes; 
# 502
(_M_nodes) = ((_M_nodes)->_M_parent); 
# 503
if (_M_nodes) 
# 504
{ 
# 505
if (((_M_nodes)->_M_right) == __node) 
# 506
{ 
# 507
((_M_nodes)->_M_right) = (0); 
# 509
if ((_M_nodes)->_M_left) 
# 510
{ 
# 511
(_M_nodes) = ((_M_nodes)->_M_left); 
# 513
while ((_M_nodes)->_M_right) { 
# 514
(_M_nodes) = ((_M_nodes)->_M_right); }  
# 516
if ((_M_nodes)->_M_left) { 
# 517
(_M_nodes) = ((_M_nodes)->_M_left); }  
# 518
}  
# 519
} else { 
# 521
((_M_nodes)->_M_left) = (0); }  
# 522
} else { 
# 524
(_M_root) = (0); }  
# 526
return __node; 
# 527
} 
# 529
_Base_ptr _M_root; 
# 530
_Base_ptr _M_nodes; 
# 531
_Rb_tree &_M_t; 
# 532
}; 
# 536
struct _Alloc_node { 
# 538
_Alloc_node(_Rb_tree &__t) : _M_t(__t) 
# 539
{ } 
# 541
template< class _Arg> _Link_type 
# 546
operator()(_Arg &&__arg) const 
# 548
{ return (_M_t)._M_create_node(std::forward< _Arg> (__arg)); } 
# 551
private: _Rb_tree &_M_t; 
# 552
}; 
# 555
public: typedef _Key key_type; 
# 556
typedef _Val value_type; 
# 557
typedef value_type *pointer; 
# 558
typedef const value_type *const_pointer; 
# 559
typedef value_type &reference; 
# 560
typedef const value_type &const_reference; 
# 561
typedef size_t size_type; 
# 562
typedef ptrdiff_t difference_type; 
# 563
typedef _Alloc allocator_type; 
# 566
_Node_allocator &_M_get_Node_allocator() noexcept 
# 567
{ return this->_M_impl; } 
# 570
const _Node_allocator &_M_get_Node_allocator() const noexcept 
# 571
{ return this->_M_impl; } 
# 574
allocator_type get_allocator() const noexcept 
# 575
{ return (allocator_type)_M_get_Node_allocator(); } 
# 579
protected: _Link_type _M_get_node() 
# 580
{ return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); } 
# 583
void _M_put_node(_Link_type __p) noexcept 
# 584
{ _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); } 
# 607 "/usr/include/c++/9/bits/stl_tree.h" 3
template< class ..._Args> void 
# 609
_M_construct_node(_Link_type __node, _Args &&...__args) 
# 610
{ 
# 611
try 
# 612
{ 
# 613
::new (__node) _Rb_tree_node< _Val> ; 
# 614
_Alloc_traits::construct(_M_get_Node_allocator(), __node->_M_valptr(), std::forward< _Args> (__args)...); 
# 617
} 
# 618
catch (...) 
# 619
{ 
# 620
__node->~_Rb_tree_node< _Val> (); 
# 621
_M_put_node(__node); 
# 622
throw; 
# 623
}  
# 624
} 
# 626
template< class ..._Args> _Link_type 
# 628
_M_create_node(_Args &&...__args) 
# 629
{ 
# 630
_Link_type __tmp = _M_get_node(); 
# 631
_M_construct_node(__tmp, std::forward< _Args> (__args)...); 
# 632
return __tmp; 
# 633
} 
# 637
void _M_destroy_node(_Link_type __p) noexcept 
# 638
{ 
# 642
_Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr()); 
# 643
__p->~_Rb_tree_node< _Val> (); 
# 645
} 
# 648
void _M_drop_node(_Link_type __p) noexcept 
# 649
{ 
# 650
_M_destroy_node(__p); 
# 651
_M_put_node(__p); 
# 652
} 
# 654
template< class _NodeGen> _Link_type 
# 656
_M_clone_node(_Const_Link_type __x, _NodeGen &__node_gen) 
# 657
{ 
# 658
_Link_type __tmp = __node_gen(*__x->_M_valptr()); 
# 659
(__tmp->_M_color) = (__x->_M_color); 
# 660
(__tmp->_M_left) = 0; 
# 661
(__tmp->_M_right) = 0; 
# 662
return __tmp; 
# 663
} 
# 670
template< class _Key_compare, bool 
# 671
 = __is_pod(_Key_compare)> 
# 673
struct _Rb_tree_impl : public _Node_allocator, public _Rb_tree_key_compare< _Key_compare> , public std::_Rb_tree_header { 
# 678
typedef _Rb_tree_key_compare< _Key_compare>  _Base_key_compare; 
# 680
_Rb_tree_impl() noexcept(is_nothrow_default_constructible< typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator> ::value && is_nothrow_default_constructible< _Base_key_compare> ::value) : _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator() 
# 685
{ } 
# 687
_Rb_tree_impl(const _Rb_tree_impl &__x) : _Base_key_compare((__x._M_key_compare)), _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(_Alloc_traits::_S_select_on_copy(__x)) 
# 690
{ } 
# 697
_Rb_tree_impl(_Rb_tree_impl &&__x) noexcept(is_nothrow_move_constructible< _Base_key_compare> ::value) : _Base_key_compare(std::move(__x)), std::_Rb_tree_header(std::move(__x)), _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(std::move(__x)) 
# 702
{ } 
# 705
explicit _Rb_tree_impl(typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator &&__a) : _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(std::move(__a)) 
# 707
{ } 
# 709
_Rb_tree_impl(_Rb_tree_impl &&__x, typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator &&__a) : _Base_key_compare(std::move(__x)), std::_Rb_tree_header(std::move(__x)), _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(std::move(__a)) 
# 713
{ } 
# 715
_Rb_tree_impl(const _Key_compare &__comp, typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator &&__a) : _Base_key_compare(__comp), _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_Node_allocator(std::move(__a)) 
# 717
{ } 
# 719
}; 
# 721
_Rb_tree_impl< _Compare>  _M_impl; 
# 725
_Base_ptr &_M_root() noexcept 
# 726
{ return ((this->_M_impl)._M_header)._M_parent; } 
# 729
_Const_Base_ptr _M_root() const noexcept 
# 730
{ return ((this->_M_impl)._M_header)._M_parent; } 
# 733
_Base_ptr &_M_leftmost() noexcept 
# 734
{ return ((this->_M_impl)._M_header)._M_left; } 
# 737
_Const_Base_ptr _M_leftmost() const noexcept 
# 738
{ return ((this->_M_impl)._M_header)._M_left; } 
# 741
_Base_ptr &_M_rightmost() noexcept 
# 742
{ return ((this->_M_impl)._M_header)._M_right; } 
# 745
_Const_Base_ptr _M_rightmost() const noexcept 
# 746
{ return ((this->_M_impl)._M_header)._M_right; } 
# 749
_Link_type _M_begin() noexcept 
# 750
{ return static_cast< _Link_type>(((this->_M_impl)._M_header)._M_parent); } 
# 753
_Const_Link_type _M_begin() const noexcept 
# 754
{ 
# 755
return static_cast< _Const_Link_type>(((this->_M_impl)._M_header)._M_parent); 
# 757
} 
# 760
_Base_ptr _M_end() noexcept 
# 761
{ return &((this->_M_impl)._M_header); } 
# 764
_Const_Base_ptr _M_end() const noexcept 
# 765
{ return &((this->_M_impl)._M_header); } 
# 768
static const_reference _S_value(_Const_Link_type __x) 
# 769
{ return *__x->_M_valptr(); } 
# 772
static const _Key &_S_key(_Const_Link_type __x) 
# 773
{ 
# 777
static_assert((__is_invocable< _Compare &, const _Key &, const _Key &> {}), "comparison object must be invocable with two arguments of key type");
# 790 "/usr/include/c++/9/bits/stl_tree.h" 3
return _KeyOfValue()(*__x->_M_valptr()); 
# 791
} 
# 794
static _Link_type _S_left(_Base_ptr __x) noexcept 
# 795
{ return static_cast< _Link_type>(__x->_M_left); } 
# 798
static _Const_Link_type _S_left(_Const_Base_ptr __x) noexcept 
# 799
{ return static_cast< _Const_Link_type>(__x->_M_left); } 
# 802
static _Link_type _S_right(_Base_ptr __x) noexcept 
# 803
{ return static_cast< _Link_type>(__x->_M_right); } 
# 806
static _Const_Link_type _S_right(_Const_Base_ptr __x) noexcept 
# 807
{ return static_cast< _Const_Link_type>(__x->_M_right); } 
# 810
static const_reference _S_value(_Const_Base_ptr __x) 
# 811
{ return *(static_cast< _Const_Link_type>(__x))->_M_valptr(); } 
# 814
static const _Key &_S_key(_Const_Base_ptr __x) 
# 815
{ return _S_key(static_cast< _Const_Link_type>(__x)); } 
# 818
static _Base_ptr _S_minimum(_Base_ptr __x) noexcept 
# 819
{ return _Rb_tree_node_base::_S_minimum(__x); } 
# 822
static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x) noexcept 
# 823
{ return _Rb_tree_node_base::_S_minimum(__x); } 
# 826
static _Base_ptr _S_maximum(_Base_ptr __x) noexcept 
# 827
{ return _Rb_tree_node_base::_S_maximum(__x); } 
# 830
static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x) noexcept 
# 831
{ return _Rb_tree_node_base::_S_maximum(__x); } 
# 834
public: typedef _Rb_tree_iterator< value_type>  iterator; 
# 835
typedef _Rb_tree_const_iterator< value_type>  const_iterator; 
# 837
typedef std::reverse_iterator< iterator>  reverse_iterator; 
# 838
typedef std::reverse_iterator< const_iterator>  const_reverse_iterator; 
# 848 "/usr/include/c++/9/bits/stl_tree.h" 3
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_unique_pos(const key_type & __k); 
# 851
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_equal_pos(const key_type & __k); 
# 854
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_hint_unique_pos(const_iterator __pos, const key_type & __k); 
# 858
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _M_get_insert_hint_equal_pos(const_iterator __pos, const key_type & __k); 
# 863
private: template< class _Arg, class _NodeGen> iterator _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg && __v, _NodeGen &); 
# 868
iterator _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z); 
# 870
template< class _Arg> iterator _M_insert_lower(_Base_ptr __y, _Arg && __v); 
# 874
template< class _Arg> iterator _M_insert_equal_lower(_Arg && __x); 
# 879
iterator _M_insert_lower_node(_Base_ptr __p, _Link_type __z); 
# 882
iterator _M_insert_equal_lower_node(_Link_type __z); 
# 898 "/usr/include/c++/9/bits/stl_tree.h" 3
template< class _NodeGen> _Link_type _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen &); 
# 902
template< class _NodeGen> _Link_type 
# 904
_M_copy(const _Rb_tree &__x, _NodeGen &__gen) 
# 905
{ 
# 906
_Link_type __root = _M_copy(__x._M_begin(), _M_end(), __gen); 
# 907
_M_leftmost() = _S_minimum(__root); 
# 908
_M_rightmost() = _S_maximum(__root); 
# 909
((_M_impl)._M_node_count) = ((__x._M_impl)._M_node_count); 
# 910
return __root; 
# 911
} 
# 914
_Link_type _M_copy(const _Rb_tree &__x) 
# 915
{ 
# 916
_Alloc_node __an(*this); 
# 917
return _M_copy(__x, __an); 
# 918
} 
# 921
void _M_erase(_Link_type __x); 
# 924
iterator _M_lower_bound(_Link_type __x, _Base_ptr __y, const _Key & __k); 
# 928
const_iterator _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y, const _Key & __k) const; 
# 932
iterator _M_upper_bound(_Link_type __x, _Base_ptr __y, const _Key & __k); 
# 936
const_iterator _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y, const _Key & __k) const; 
# 944
public: _Rb_tree() = default;
# 947
_Rb_tree(const _Compare &__comp, const allocator_type &
# 948
__a = allocator_type()) : _M_impl(__comp, (_Node_allocator)__a) 
# 949
{ } 
# 951
_Rb_tree(const _Rb_tree &__x) : _M_impl(__x._M_impl) 
# 953
{ 
# 954
if (__x._M_root() != (0)) { 
# 955
_M_root() = _M_copy(__x); }  
# 956
} 
# 959
_Rb_tree(const allocator_type &__a) : _M_impl((_Node_allocator)__a) 
# 961
{ } 
# 963
_Rb_tree(const _Rb_tree &__x, const allocator_type &__a) : _M_impl(((__x._M_impl)._M_key_compare), (_Node_allocator)__a) 
# 965
{ 
# 966
if (__x._M_root() != (nullptr)) { 
# 967
_M_root() = _M_copy(__x); }  
# 968
} 
# 970
_Rb_tree(_Rb_tree &&) = default;
# 972
_Rb_tree(_Rb_tree &&__x, const allocator_type &__a) : _Rb_tree(std::move(__x), (_Node_allocator)__a) 
# 974
{ } 
# 977
private: _Rb_tree(_Rb_tree &&__x, _Node_allocator &&__a, true_type) noexcept(is_nothrow_default_constructible< _Compare> ::value) : _M_impl(std::move(__x._M_impl), std::move(__a)) 
# 980
{ } 
# 982
_Rb_tree(_Rb_tree &&__x, _Node_allocator &&__a, false_type) : _M_impl(((__x._M_impl)._M_key_compare), std::move(__a)) 
# 984
{ 
# 985
if (__x._M_root() != (nullptr)) { 
# 986
_M_move_data(__x, false_type{}); }  
# 987
} 
# 990
public: _Rb_tree(_Rb_tree &&__x, _Node_allocator &&__a) noexcept(noexcept((_Rb_tree(std::declval< _Rb_tree &&> (), std::declval< _Node_allocator &&> (), std::declval< typename __gnu_cxx::__alloc_traits< _Node_allocator> ::is_always_equal> ())))) : _Rb_tree(std::move(__x), std::move(__a), typename __gnu_cxx::__alloc_traits< _Node_allocator> ::is_always_equal{}) 
# 996
{ } 
# 999
~_Rb_tree() noexcept 
# 1000
{ _M_erase(_M_begin()); } 
# 1003
_Rb_tree &operator=(const _Rb_tree & __x); 
# 1007
_Compare key_comp() const 
# 1008
{ return (_M_impl)._M_key_compare; } 
# 1011
iterator begin() noexcept 
# 1012
{ return ((_Rb_tree_iterator< value_type> )((((this->_M_impl)._M_header)._M_left))); } 
# 1015
const_iterator begin() const noexcept 
# 1016
{ return ((_Rb_tree_const_iterator< value_type> )((((this->_M_impl)._M_header)._M_left))); } 
# 1019
iterator end() noexcept 
# 1020
{ return ((_Rb_tree_iterator< value_type> )(&((this->_M_impl)._M_header))); } 
# 1023
const_iterator end() const noexcept 
# 1024
{ return ((_Rb_tree_const_iterator< value_type> )(&((this->_M_impl)._M_header))); } 
# 1027
reverse_iterator rbegin() noexcept 
# 1028
{ return ((std::reverse_iterator< iterator> )(end())); } 
# 1031
const_reverse_iterator rbegin() const noexcept 
# 1032
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 1035
reverse_iterator rend() noexcept 
# 1036
{ return ((std::reverse_iterator< iterator> )(begin())); } 
# 1039
const_reverse_iterator rend() const noexcept 
# 1040
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 1043
bool empty() const noexcept 
# 1044
{ return ((_M_impl)._M_node_count) == 0; } 
# 1047
size_type size() const noexcept 
# 1048
{ return (_M_impl)._M_node_count; } 
# 1051
size_type max_size() const noexcept 
# 1052
{ return _Alloc_traits::max_size(_M_get_Node_allocator()); } 
# 1055
void swap(_Rb_tree & __t) noexcept(__is_nothrow_swappable< _Compare> ::value); 
# 1060
template< class _Arg> pair< iterator, bool>  _M_insert_unique(_Arg && __x); 
# 1064
template< class _Arg> iterator _M_insert_equal(_Arg && __x); 
# 1068
template< class _Arg, class _NodeGen> iterator _M_insert_unique_(const_iterator __pos, _Arg && __x, _NodeGen &); 
# 1072
template< class _Arg> iterator 
# 1074
_M_insert_unique_(const_iterator __pos, _Arg &&__x) 
# 1075
{ 
# 1076
_Alloc_node __an(*this); 
# 1077
return _M_insert_unique_(__pos, std::forward< _Arg> (__x), __an); 
# 1078
} 
# 1080
template< class _Arg, class _NodeGen> iterator _M_insert_equal_(const_iterator __pos, _Arg && __x, _NodeGen &); 
# 1084
template< class _Arg> iterator 
# 1086
_M_insert_equal_(const_iterator __pos, _Arg &&__x) 
# 1087
{ 
# 1088
_Alloc_node __an(*this); 
# 1089
return _M_insert_equal_(__pos, std::forward< _Arg> (__x), __an); 
# 1090
} 
# 1092
template< class ..._Args> pair< iterator, bool>  _M_emplace_unique(_Args && ...__args); 
# 1096
template< class ..._Args> iterator _M_emplace_equal(_Args && ...__args); 
# 1100
template< class ..._Args> iterator _M_emplace_hint_unique(const_iterator __pos, _Args && ...__args); 
# 1104
template< class ..._Args> iterator _M_emplace_hint_equal(const_iterator __pos, _Args && ...__args); 
# 1108
template< class _Iter> using __same_value_type = is_same< value_type, typename iterator_traits< _Iter> ::value_type> ; 
# 1112
template< class _InputIterator> __enable_if_t< __same_value_type< _InputIterator> ::value>  
# 1114
_M_insert_range_unique(_InputIterator __first, _InputIterator __last) 
# 1115
{ 
# 1116
_Alloc_node __an(*this); 
# 1117
for (; __first != __last; ++__first) { 
# 1118
_M_insert_unique_(end(), *__first, __an); }  
# 1119
} 
# 1121
template< class _InputIterator> __enable_if_t< !__same_value_type< _InputIterator> ::value>  
# 1123
_M_insert_range_unique(_InputIterator __first, _InputIterator __last) 
# 1124
{ 
# 1125
for (; __first != __last; ++__first) { 
# 1126
_M_emplace_unique(*__first); }  
# 1127
} 
# 1129
template< class _InputIterator> __enable_if_t< __same_value_type< _InputIterator> ::value>  
# 1131
_M_insert_range_equal(_InputIterator __first, _InputIterator __last) 
# 1132
{ 
# 1133
_Alloc_node __an(*this); 
# 1134
for (; __first != __last; ++__first) { 
# 1135
_M_insert_equal_(end(), *__first, __an); }  
# 1136
} 
# 1138
template< class _InputIterator> __enable_if_t< !__same_value_type< _InputIterator> ::value>  
# 1140
_M_insert_range_equal(_InputIterator __first, _InputIterator __last) 
# 1141
{ 
# 1142
_Alloc_node __an(*this); 
# 1143
for (; __first != __last; ++__first) { 
# 1144
_M_emplace_equal(*__first); }  
# 1145
} 
# 1197 "/usr/include/c++/9/bits/stl_tree.h" 3
private: void _M_erase_aux(const_iterator __position); 
# 1200
void _M_erase_aux(const_iterator __first, const_iterator __last); 
# 1208
public: 
# 1206
__attribute((__abi_tag__("cxx11"))) iterator 
# 1208
erase(const_iterator __position) 
# 1209
{ 
# 1210
; 
# 1211
const_iterator __result = __position; 
# 1212
++__result; 
# 1213
_M_erase_aux(__position); 
# 1214
return __result._M_const_cast(); 
# 1215
} 
# 1218
__attribute((__abi_tag__("cxx11"))) iterator 
# 1220
erase(iterator __position) 
# 1221
{ 
# 1222
; 
# 1223
iterator __result = __position; 
# 1224
++__result; 
# 1225
_M_erase_aux(__position); 
# 1226
return __result; 
# 1227
} 
# 1244 "/usr/include/c++/9/bits/stl_tree.h" 3
size_type erase(const key_type & __x); 
# 1249
__attribute((__abi_tag__("cxx11"))) iterator 
# 1251
erase(const_iterator __first, const_iterator __last) 
# 1252
{ 
# 1253
_M_erase_aux(__first, __last); 
# 1254
return __last._M_const_cast(); 
# 1255
} 
# 1266 "/usr/include/c++/9/bits/stl_tree.h" 3
void erase(const key_type * __first, const key_type * __last); 
# 1269
void clear() noexcept 
# 1270
{ 
# 1271
_M_erase(_M_begin()); 
# 1272
(_M_impl)._M_reset(); 
# 1273
} 
# 1277
iterator find(const key_type & __k); 
# 1280
const_iterator find(const key_type & __k) const; 
# 1283
size_type count(const key_type & __k) const; 
# 1286
iterator lower_bound(const key_type &__k) 
# 1287
{ return _M_lower_bound(_M_begin(), _M_end(), __k); } 
# 1290
const_iterator lower_bound(const key_type &__k) const 
# 1291
{ return _M_lower_bound(_M_begin(), _M_end(), __k); } 
# 1294
iterator upper_bound(const key_type &__k) 
# 1295
{ return _M_upper_bound(_M_begin(), _M_end(), __k); } 
# 1298
const_iterator upper_bound(const key_type &__k) const 
# 1299
{ return _M_upper_bound(_M_begin(), _M_end(), __k); } 
# 1302
pair< iterator, iterator>  equal_range(const key_type & __k); 
# 1305
pair< const_iterator, const_iterator>  equal_range(const key_type & __k) const; 
# 1308
template< class _Kt, class 
# 1309
_Req = __has_is_transparent_t< _Compare, _Kt> > iterator 
# 1311
_M_find_tr(const _Kt &__k) 
# 1312
{ 
# 1313
const _Rb_tree *__const_this = this; 
# 1314
return __const_this->_M_find_tr(__k)._M_const_cast(); 
# 1315
} 
# 1317
template< class _Kt, class 
# 1318
_Req = __has_is_transparent_t< _Compare, _Kt> > const_iterator 
# 1320
_M_find_tr(const _Kt &__k) const 
# 1321
{ 
# 1322
auto __j = _M_lower_bound_tr(__k); 
# 1323
if ((__j != end()) && (_M_impl)._M_key_compare(__k, _S_key((__j._M_node)))) { 
# 1324
__j = end(); }  
# 1325
return __j; 
# 1326
} 
# 1328
template< class _Kt, class 
# 1329
_Req = __has_is_transparent_t< _Compare, _Kt> > size_type 
# 1331
_M_count_tr(const _Kt &__k) const 
# 1332
{ 
# 1333
auto __p = _M_equal_range_tr(__k); 
# 1334
return std::distance((__p.first), (__p.second)); 
# 1335
} 
# 1337
template< class _Kt, class 
# 1338
_Req = __has_is_transparent_t< _Compare, _Kt> > iterator 
# 1340
_M_lower_bound_tr(const _Kt &__k) 
# 1341
{ 
# 1342
const _Rb_tree *__const_this = this; 
# 1343
return __const_this->_M_lower_bound_tr(__k)._M_const_cast(); 
# 1344
} 
# 1346
template< class _Kt, class 
# 1347
_Req = __has_is_transparent_t< _Compare, _Kt> > const_iterator 
# 1349
_M_lower_bound_tr(const _Kt &__k) const 
# 1350
{ 
# 1351
auto __x = _M_begin(); 
# 1352
auto __y = _M_end(); 
# 1353
while (__x != 0) { 
# 1354
if (!(_M_impl)._M_key_compare(_S_key(__x), __k)) 
# 1355
{ 
# 1356
__y = __x; 
# 1357
__x = _S_left(__x); 
# 1358
} else { 
# 1360
__x = _S_right(__x); }  }  
# 1361
return ((_Rb_tree_const_iterator< value_type> )(__y)); 
# 1362
} 
# 1364
template< class _Kt, class 
# 1365
_Req = __has_is_transparent_t< _Compare, _Kt> > iterator 
# 1367
_M_upper_bound_tr(const _Kt &__k) 
# 1368
{ 
# 1369
const _Rb_tree *__const_this = this; 
# 1370
return __const_this->_M_upper_bound_tr(__k)._M_const_cast(); 
# 1371
} 
# 1373
template< class _Kt, class 
# 1374
_Req = __has_is_transparent_t< _Compare, _Kt> > const_iterator 
# 1376
_M_upper_bound_tr(const _Kt &__k) const 
# 1377
{ 
# 1378
auto __x = _M_begin(); 
# 1379
auto __y = _M_end(); 
# 1380
while (__x != 0) { 
# 1381
if ((_M_impl)._M_key_compare(__k, _S_key(__x))) 
# 1382
{ 
# 1383
__y = __x; 
# 1384
__x = _S_left(__x); 
# 1385
} else { 
# 1387
__x = _S_right(__x); }  }  
# 1388
return ((_Rb_tree_const_iterator< value_type> )(__y)); 
# 1389
} 
# 1391
template< class _Kt, class 
# 1392
_Req = __has_is_transparent_t< _Compare, _Kt> > pair< iterator, iterator>  
# 1394
_M_equal_range_tr(const _Kt &__k) 
# 1395
{ 
# 1396
const _Rb_tree *__const_this = this; 
# 1397
auto __ret = __const_this->_M_equal_range_tr(__k); 
# 1398
return {(__ret.first)._M_const_cast(), (__ret.second)._M_const_cast()}; 
# 1399
} 
# 1401
template< class _Kt, class 
# 1402
_Req = __has_is_transparent_t< _Compare, _Kt> > pair< const_iterator, const_iterator>  
# 1404
_M_equal_range_tr(const _Kt &__k) const 
# 1405
{ 
# 1406
auto __low = _M_lower_bound_tr(__k); 
# 1407
auto __high = __low; 
# 1408
auto &__cmp = (((_M_impl)._M_key_compare)); 
# 1409
while ((__high != end()) && (!__cmp(__k, _S_key((__high._M_node))))) { 
# 1410
++__high; }  
# 1411
return {__low, __high}; 
# 1412
} 
# 1417
bool __rb_verify() const; 
# 1421
inline _Rb_tree &operator=(_Rb_tree &&) noexcept(_Alloc_traits::_S_nothrow_move() && is_nothrow_move_assignable< _Compare> ::value); 
# 1425
template< class _Iterator> void _M_assign_unique(_Iterator, _Iterator); 
# 1429
template< class _Iterator> void _M_assign_equal(_Iterator, _Iterator); 
# 1436
private: void _M_move_data(_Rb_tree &__x, true_type) 
# 1437
{ (_M_impl)._M_move_data(__x._M_impl); } 
# 1442
void _M_move_data(_Rb_tree &, false_type); 
# 1446
inline void _M_move_assign(_Rb_tree &, true_type); 
# 1451
void _M_move_assign(_Rb_tree &, false_type); 
# 1621 "/usr/include/c++/9/bits/stl_tree.h" 3
friend inline bool operator==(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__y) 
# 1622
{ 
# 1623
return (__x.size() == __y.size()) && std::equal(__x.begin(), __x.end(), __y.begin()); 
# 1625
} 
# 1628
friend inline bool operator<(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__y) 
# 1629
{ 
# 1630
return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end()); 
# 1632
} 
# 1634
__attribute((__deprecated__)) friend inline bool 
# 1635
operator!=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__y) 
# 1636
{ return !(__x == __y); } 
# 1638
__attribute((__deprecated__)) friend inline bool 
# 1639
operator>(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__y) 
# 1640
{ return __y < __x; } 
# 1642
__attribute((__deprecated__)) friend inline bool 
# 1643
operator<=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__y) 
# 1644
{ return !(__y < __x); } 
# 1646
__attribute((__deprecated__)) friend inline bool 
# 1647
operator>=(const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__y) 
# 1648
{ return !(__x < __y); } 
# 1649
}; 
# 1651
template< class _Key, class _Val, class _KeyOfValue, class 
# 1652
_Compare, class _Alloc> inline void 
# 1654
swap(_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &__x, _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1655
__y) 
# 1656
{ __x.swap(__y); } 
# 1659
template< class _Key, class _Val, class _KeyOfValue, class 
# 1660
_Compare, class _Alloc> void 
# 1663
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_move_data(_Rb_tree &__x, false_type) 
# 1664
{ 
# 1665
if (_M_get_Node_allocator() == __x._M_get_Node_allocator()) { 
# 1666
_M_move_data(__x, true_type()); } else 
# 1668
{ 
# 1669
_Alloc_node __an(*this); 
# 1670
auto __lbd = [&__an](const value_type &
# 1671
__cval) 
# 1672
{ 
# 1673
auto &__val = const_cast< value_type &>(__cval); 
# 1674
return (__an)(std::move_if_noexcept(__val)); 
# 1675
} ; 
# 1676
_M_root() = _M_copy(__x, __lbd); 
# 1677
}  
# 1678
} 
# 1680
template< class _Key, class _Val, class _KeyOfValue, class 
# 1681
_Compare, class _Alloc> inline void 
# 1684
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_move_assign(_Rb_tree &__x, true_type) 
# 1685
{ 
# 1686
clear(); 
# 1687
if (__x._M_root() != (nullptr)) { 
# 1688
_M_move_data(__x, true_type()); }  
# 1689
std::__alloc_on_move(_M_get_Node_allocator(), __x._M_get_Node_allocator()); 
# 1691
} 
# 1693
template< class _Key, class _Val, class _KeyOfValue, class 
# 1694
_Compare, class _Alloc> void 
# 1697
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_move_assign(_Rb_tree &__x, false_type) 
# 1698
{ 
# 1699
if (_M_get_Node_allocator() == __x._M_get_Node_allocator()) { 
# 1700
return _M_move_assign(__x, true_type{}); }  
# 1704
_Reuse_or_alloc_node __roan(*this); 
# 1705
(_M_impl)._M_reset(); 
# 1706
if (__x._M_root() != (nullptr)) 
# 1707
{ 
# 1708
auto __lbd = [&__roan](const value_type &
# 1709
__cval) 
# 1710
{ 
# 1711
auto &__val = const_cast< value_type &>(__cval); 
# 1712
return (__roan)(std::move_if_noexcept(__val)); 
# 1713
} ; 
# 1714
_M_root() = _M_copy(__x, __lbd); 
# 1715
__x.clear(); 
# 1716
}  
# 1717
} 
# 1719
template< class _Key, class _Val, class _KeyOfValue, class 
# 1720
_Compare, class _Alloc> inline _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1723
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::operator=(_Rb_tree &&__x) noexcept(_Alloc_traits::_S_nothrow_move() && is_nothrow_move_assignable< _Compare> ::value) 
# 1726
{ 
# 1727
((_M_impl)._M_key_compare) = std::move(((__x._M_impl)._M_key_compare)); 
# 1728
_M_move_assign(__x, __bool_constant< __gnu_cxx::__alloc_traits< _Node_allocator> ::_S_nothrow_move()> ()); 
# 1729
return *this; 
# 1730
} 
# 1732
template< class _Key, class _Val, class _KeyOfValue, class 
# 1733
_Compare, class _Alloc> 
# 1734
template< class _Iterator> void 
# 1737
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_assign_unique(_Iterator __first, _Iterator __last) 
# 1738
{ 
# 1739
_Reuse_or_alloc_node __roan(*this); 
# 1740
(_M_impl)._M_reset(); 
# 1741
for (; __first != __last; ++__first) { 
# 1742
_M_insert_unique_(end(), *__first, __roan); }  
# 1743
} 
# 1745
template< class _Key, class _Val, class _KeyOfValue, class 
# 1746
_Compare, class _Alloc> 
# 1747
template< class _Iterator> void 
# 1750
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_assign_equal(_Iterator __first, _Iterator __last) 
# 1751
{ 
# 1752
_Reuse_or_alloc_node __roan(*this); 
# 1753
(_M_impl)._M_reset(); 
# 1754
for (; __first != __last; ++__first) { 
# 1755
_M_insert_equal_(end(), *__first, __roan); }  
# 1756
} 
# 1759
template< class _Key, class _Val, class _KeyOfValue, class 
# 1760
_Compare, class _Alloc> _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc>  &
# 1763
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::operator=(const _Rb_tree &__x) 
# 1764
{ 
# 1765
if (this != (&__x)) 
# 1766
{ 
# 1769
if (_Alloc_traits::_S_propagate_on_copy_assign()) 
# 1770
{ 
# 1771
auto &__this_alloc = _M_get_Node_allocator(); 
# 1772
auto &__that_alloc = __x._M_get_Node_allocator(); 
# 1773
if ((!_Alloc_traits::_S_always_equal()) && (__this_alloc != __that_alloc)) 
# 1775
{ 
# 1778
clear(); 
# 1779
std::__alloc_on_copy(__this_alloc, __that_alloc); 
# 1780
}  
# 1781
}  
# 1784
_Reuse_or_alloc_node __roan(*this); 
# 1785
(_M_impl)._M_reset(); 
# 1786
((_M_impl)._M_key_compare) = ((__x._M_impl)._M_key_compare); 
# 1787
if (__x._M_root() != (0)) { 
# 1788
_M_root() = _M_copy(__x, __roan); }  
# 1789
}  
# 1791
return *this; 
# 1792
} 
# 1794
template< class _Key, class _Val, class _KeyOfValue, class 
# 1795
_Compare, class _Alloc> 
# 1797
template< class _Arg, class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1803
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_(_Base_ptr __x, _Base_ptr __p, _Arg &&
# 1805
__v, _NodeGen &
# 1809
__node_gen) 
# 1810
{ 
# 1811
bool __insert_left = ((__x != (0)) || (__p == _M_end())) || (_M_impl)._M_key_compare(_KeyOfValue()(__v), _S_key(__p)); 
# 1815
_Link_type __z = __node_gen(std::forward< _Arg> (__v)); 
# 1817
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 1819
++((_M_impl)._M_node_count); 
# 1820
return ((_Rb_tree_iterator< value_type> )(__z)); 
# 1821
} 
# 1823
template< class _Key, class _Val, class _KeyOfValue, class 
# 1824
_Compare, class _Alloc> 
# 1826
template< class _Arg> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1831
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_lower(_Base_ptr __p, _Arg &&__v) 
# 1835
{ 
# 1836
bool __insert_left = (__p == _M_end()) || (!(_M_impl)._M_key_compare(_S_key(__p), _KeyOfValue()(__v))); 
# 1840
_Link_type __z = _M_create_node(std::forward< _Arg> (__v)); 
# 1842
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 1844
++((_M_impl)._M_node_count); 
# 1845
return ((_Rb_tree_iterator< value_type> )(__z)); 
# 1846
} 
# 1848
template< class _Key, class _Val, class _KeyOfValue, class 
# 1849
_Compare, class _Alloc> 
# 1851
template< class _Arg> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1856
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal_lower(_Arg &&__v) 
# 1860
{ 
# 1861
_Link_type __x = _M_begin(); 
# 1862
_Base_ptr __y = _M_end(); 
# 1863
while (__x != 0) 
# 1864
{ 
# 1865
__y = __x; 
# 1866
__x = ((!(_M_impl)._M_key_compare(_S_key(__x), _KeyOfValue()(__v))) ? _S_left(__x) : _S_right(__x)); 
# 1868
}  
# 1869
return _M_insert_lower(__y, std::forward< _Arg> (__v)); 
# 1870
} 
# 1872
template< class _Key, class _Val, class _KoV, class 
# 1873
_Compare, class _Alloc> 
# 1874
template< class _NodeGen> typename _Rb_tree< _Key, _Val, _KoV, _Compare, _Alloc> ::_Link_type 
# 1877
_Rb_tree< _Key, _Val, _KoV, _Compare, _Alloc> ::_M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen &__node_gen) 
# 1878
{ 
# 1880
_Link_type __top = _M_clone_node(__x, __node_gen); 
# 1881
(__top->_M_parent) = __p; 
# 1883
try 
# 1884
{ 
# 1885
if (__x->_M_right) { 
# 1886
(__top->_M_right) = _M_copy(_S_right(__x), __top, __node_gen); }  
# 1887
__p = __top; 
# 1888
__x = _S_left(__x); 
# 1890
while (__x != 0) 
# 1891
{ 
# 1892
_Link_type __y = _M_clone_node(__x, __node_gen); 
# 1893
(__p->_M_left) = __y; 
# 1894
(__y->_M_parent) = __p; 
# 1895
if (__x->_M_right) { 
# 1896
(__y->_M_right) = _M_copy(_S_right(__x), __y, __node_gen); }  
# 1897
__p = __y; 
# 1898
__x = _S_left(__x); 
# 1899
}  
# 1900
} 
# 1901
catch (...) 
# 1902
{ 
# 1903
_M_erase(__top); 
# 1904
throw; 
# 1905
}  
# 1906
return __top; 
# 1907
} 
# 1909
template< class _Key, class _Val, class _KeyOfValue, class 
# 1910
_Compare, class _Alloc> void 
# 1913
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase(_Link_type __x) 
# 1914
{ 
# 1916
while (__x != 0) 
# 1917
{ 
# 1918
_M_erase(_S_right(__x)); 
# 1919
_Link_type __y = _S_left(__x); 
# 1920
_M_drop_node(__x); 
# 1921
__x = __y; 
# 1922
}  
# 1923
} 
# 1925
template< class _Key, class _Val, class _KeyOfValue, class 
# 1926
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1930
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_lower_bound(_Link_type __x, _Base_ptr __y, const _Key &
# 1931
__k) 
# 1932
{ 
# 1933
while (__x != 0) { 
# 1934
if (!(_M_impl)._M_key_compare(_S_key(__x), __k)) { 
# 1935
(__y = __x), (__x = _S_left(__x)); } else { 
# 1937
__x = _S_right(__x); }  }  
# 1938
return ((_Rb_tree_iterator< value_type> )(__y)); 
# 1939
} 
# 1941
template< class _Key, class _Val, class _KeyOfValue, class 
# 1942
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 1946
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y, const _Key &
# 1947
__k) const 
# 1948
{ 
# 1949
while (__x != 0) { 
# 1950
if (!(_M_impl)._M_key_compare(_S_key(__x), __k)) { 
# 1951
(__y = __x), (__x = _S_left(__x)); } else { 
# 1953
__x = _S_right(__x); }  }  
# 1954
return ((_Rb_tree_const_iterator< value_type> )(__y)); 
# 1955
} 
# 1957
template< class _Key, class _Val, class _KeyOfValue, class 
# 1958
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 1962
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_upper_bound(_Link_type __x, _Base_ptr __y, const _Key &
# 1963
__k) 
# 1964
{ 
# 1965
while (__x != 0) { 
# 1966
if ((_M_impl)._M_key_compare(__k, _S_key(__x))) { 
# 1967
(__y = __x), (__x = _S_left(__x)); } else { 
# 1969
__x = _S_right(__x); }  }  
# 1970
return ((_Rb_tree_iterator< value_type> )(__y)); 
# 1971
} 
# 1973
template< class _Key, class _Val, class _KeyOfValue, class 
# 1974
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 1978
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y, const _Key &
# 1979
__k) const 
# 1980
{ 
# 1981
while (__x != 0) { 
# 1982
if ((_M_impl)._M_key_compare(__k, _S_key(__x))) { 
# 1983
(__y = __x), (__x = _S_left(__x)); } else { 
# 1985
__x = _S_right(__x); }  }  
# 1986
return ((_Rb_tree_const_iterator< value_type> )(__y)); 
# 1987
} 
# 1989
template< class _Key, class _Val, class _KeyOfValue, class 
# 1990
_Compare, class _Alloc> pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> >  
# 1996
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::equal_range(const _Key &__k) 
# 1997
{ 
# 1998
_Link_type __x = _M_begin(); 
# 1999
_Base_ptr __y = _M_end(); 
# 2000
while (__x != 0) 
# 2001
{ 
# 2002
if ((_M_impl)._M_key_compare(_S_key(__x), __k)) { 
# 2003
__x = _S_right(__x); } else { 
# 2004
if ((_M_impl)._M_key_compare(__k, _S_key(__x))) { 
# 2005
(__y = __x), (__x = _S_left(__x)); } else 
# 2007
{ 
# 2008
_Link_type __xu(__x); 
# 2009
_Base_ptr __yu(__y); 
# 2010
(__y = __x), (__x = _S_left(__x)); 
# 2011
__xu = _S_right(__xu); 
# 2012
return pair< _Rb_tree_iterator< _Val> , _Rb_tree_iterator< _Val> > (_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k)); 
# 2015
}  }  
# 2016
}  
# 2017
return pair< iterator, iterator> (((_Rb_tree_iterator< value_type> )(__y)), ((_Rb_tree_iterator< value_type> )(__y))); 
# 2019
} 
# 2021
template< class _Key, class _Val, class _KeyOfValue, class 
# 2022
_Compare, class _Alloc> pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> >  
# 2028
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::equal_range(const _Key &__k) const 
# 2029
{ 
# 2030
_Const_Link_type __x = _M_begin(); 
# 2031
_Const_Base_ptr __y = _M_end(); 
# 2032
while (__x != 0) 
# 2033
{ 
# 2034
if ((_M_impl)._M_key_compare(_S_key(__x), __k)) { 
# 2035
__x = _S_right(__x); } else { 
# 2036
if ((_M_impl)._M_key_compare(__k, _S_key(__x))) { 
# 2037
(__y = __x), (__x = _S_left(__x)); } else 
# 2039
{ 
# 2040
_Const_Link_type __xu(__x); 
# 2041
_Const_Base_ptr __yu(__y); 
# 2042
(__y = __x), (__x = _S_left(__x)); 
# 2043
__xu = _S_right(__xu); 
# 2044
return pair< _Rb_tree_const_iterator< _Val> , _Rb_tree_const_iterator< _Val> > (_M_lower_bound(__x, __y, __k), _M_upper_bound(__xu, __yu, __k)); 
# 2047
}  }  
# 2048
}  
# 2049
return pair< const_iterator, const_iterator> (((_Rb_tree_const_iterator< value_type> )(__y)), ((_Rb_tree_const_iterator< value_type> )(__y))); 
# 2051
} 
# 2053
template< class _Key, class _Val, class _KeyOfValue, class 
# 2054
_Compare, class _Alloc> void 
# 2057
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::swap(_Rb_tree &__t) noexcept(__is_nothrow_swappable< _Compare> ::value) 
# 2059
{ 
# 2060
if (_M_root() == (0)) 
# 2061
{ 
# 2062
if (__t._M_root() != (0)) { 
# 2063
(_M_impl)._M_move_data(__t._M_impl); }  
# 2064
} else { 
# 2065
if (__t._M_root() == (0)) { 
# 2066
(__t._M_impl)._M_move_data(_M_impl); } else 
# 2068
{ 
# 2069
std::swap(_M_root(), __t._M_root()); 
# 2070
std::swap(_M_leftmost(), __t._M_leftmost()); 
# 2071
std::swap(_M_rightmost(), __t._M_rightmost()); 
# 2073
(_M_root()->_M_parent) = _M_end(); 
# 2074
(__t._M_root()->_M_parent) = __t._M_end(); 
# 2075
std::swap(((this->_M_impl)._M_node_count), ((__t._M_impl)._M_node_count)); 
# 2076
}  }  
# 2078
std::swap(((this->_M_impl)._M_key_compare), ((__t._M_impl)._M_key_compare)); 
# 2080
_Alloc_traits::_S_on_swap(_M_get_Node_allocator(), __t._M_get_Node_allocator()); 
# 2082
} 
# 2084
template< class _Key, class _Val, class _KeyOfValue, class 
# 2085
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 2091
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_unique_pos(const key_type &__k) 
# 2092
{ 
# 2093
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 2094
_Link_type __x = _M_begin(); 
# 2095
_Base_ptr __y = _M_end(); 
# 2096
bool __comp = true; 
# 2097
while (__x != 0) 
# 2098
{ 
# 2099
__y = __x; 
# 2100
__comp = (_M_impl)._M_key_compare(__k, _S_key(__x)); 
# 2101
__x = (__comp ? _S_left(__x) : _S_right(__x)); 
# 2102
}  
# 2103
iterator __j = ((_Rb_tree_iterator< value_type> )(__y)); 
# 2104
if (__comp) 
# 2105
{ 
# 2106
if (__j == begin()) { 
# 2107
return _Res(__x, __y); } else { 
# 2109
--__j; }  
# 2110
}  
# 2111
if ((_M_impl)._M_key_compare(_S_key((__j._M_node)), __k)) { 
# 2112
return _Res(__x, __y); }  
# 2113
return _Res((__j._M_node), 0); 
# 2114
} 
# 2116
template< class _Key, class _Val, class _KeyOfValue, class 
# 2117
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 2123
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_equal_pos(const key_type &__k) 
# 2124
{ 
# 2125
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 2126
_Link_type __x = _M_begin(); 
# 2127
_Base_ptr __y = _M_end(); 
# 2128
while (__x != 0) 
# 2129
{ 
# 2130
__y = __x; 
# 2131
__x = (((_M_impl)._M_key_compare(__k, _S_key(__x))) ? _S_left(__x) : _S_right(__x)); 
# 2133
}  
# 2134
return _Res(__x, __y); 
# 2135
} 
# 2137
template< class _Key, class _Val, class _KeyOfValue, class 
# 2138
_Compare, class _Alloc> 
# 2140
template< class _Arg> pair< _Rb_tree_iterator< _Val> , bool>  
# 2146
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_unique(_Arg &&__v) 
# 2150
{ 
# 2151
typedef pair< iterator, bool>  _Res; 
# 2152
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_unique_pos(_KeyOfValue()(__v)); 
# 2155
if (__res.second) 
# 2156
{ 
# 2157
_Alloc_node __an(*this); 
# 2158
return _Res(_M_insert_(__res.first, __res.second, std::forward< _Arg> (__v), __an), true); 
# 2161
}  
# 2163
return _Res(((_Rb_tree_iterator< value_type> )(__res.first)), false); 
# 2164
} 
# 2166
template< class _Key, class _Val, class _KeyOfValue, class 
# 2167
_Compare, class _Alloc> 
# 2169
template< class _Arg> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2174
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal(_Arg &&__v) 
# 2178
{ 
# 2179
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_equal_pos(_KeyOfValue()(__v)); 
# 2181
_Alloc_node __an(*this); 
# 2182
return _M_insert_(__res.first, __res.second, std::forward< _Arg> (__v), __an); 
# 2184
} 
# 2186
template< class _Key, class _Val, class _KeyOfValue, class 
# 2187
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 2193
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_hint_unique_pos(const_iterator __position, const key_type &
# 2194
__k) 
# 2195
{ 
# 2196
iterator __pos = __position._M_const_cast(); 
# 2197
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 2200
if ((__pos._M_node) == _M_end()) 
# 2201
{ 
# 2202
if ((size() > 0) && (_M_impl)._M_key_compare(_S_key(_M_rightmost()), __k)) { 
# 2204
return _Res(0, _M_rightmost()); } else { 
# 2206
return _M_get_insert_unique_pos(__k); }  
# 2207
} else { 
# 2208
if ((_M_impl)._M_key_compare(__k, _S_key((__pos._M_node)))) 
# 2209
{ 
# 2211
iterator __before = __pos; 
# 2212
if ((__pos._M_node) == _M_leftmost()) { 
# 2213
return _Res(_M_leftmost(), _M_leftmost()); } else { 
# 2214
if ((_M_impl)._M_key_compare(_S_key(((--__before)._M_node)), __k)) 
# 2215
{ 
# 2216
if (_S_right((__before._M_node)) == 0) { 
# 2217
return _Res(0, (__before._M_node)); } else { 
# 2219
return _Res((__pos._M_node), (__pos._M_node)); }  
# 2220
} else { 
# 2222
return _M_get_insert_unique_pos(__k); }  }  
# 2223
} else { 
# 2224
if ((_M_impl)._M_key_compare(_S_key((__pos._M_node)), __k)) 
# 2225
{ 
# 2227
iterator __after = __pos; 
# 2228
if ((__pos._M_node) == _M_rightmost()) { 
# 2229
return _Res(0, _M_rightmost()); } else { 
# 2230
if ((_M_impl)._M_key_compare(__k, _S_key(((++__after)._M_node)))) 
# 2231
{ 
# 2232
if (_S_right((__pos._M_node)) == 0) { 
# 2233
return _Res(0, (__pos._M_node)); } else { 
# 2235
return _Res((__after._M_node), (__after._M_node)); }  
# 2236
} else { 
# 2238
return _M_get_insert_unique_pos(__k); }  }  
# 2239
} else { 
# 2242
return _Res((__pos._M_node), 0); }  }  }  
# 2243
} 
# 2245
template< class _Key, class _Val, class _KeyOfValue, class 
# 2246
_Compare, class _Alloc> 
# 2248
template< class _Arg, class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2254
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_unique_(const_iterator __position, _Arg &&
# 2256
__v, _NodeGen &
# 2260
__node_gen) 
# 2261
{ 
# 2262
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v)); 
# 2265
if (__res.second) { 
# 2266
return _M_insert_(__res.first, __res.second, std::forward< _Arg> (__v), __node_gen); }  
# 2269
return ((_Rb_tree_iterator< value_type> )(__res.first)); 
# 2270
} 
# 2272
template< class _Key, class _Val, class _KeyOfValue, class 
# 2273
_Compare, class _Alloc> pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  
# 2279
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_get_insert_hint_equal_pos(const_iterator __position, const key_type &__k) 
# 2280
{ 
# 2281
iterator __pos = __position._M_const_cast(); 
# 2282
typedef pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  _Res; 
# 2285
if ((__pos._M_node) == _M_end()) 
# 2286
{ 
# 2287
if ((size() > 0) && (!(_M_impl)._M_key_compare(__k, _S_key(_M_rightmost())))) { 
# 2289
return _Res(0, _M_rightmost()); } else { 
# 2291
return _M_get_insert_equal_pos(__k); }  
# 2292
} else { 
# 2293
if (!(_M_impl)._M_key_compare(_S_key((__pos._M_node)), __k)) 
# 2294
{ 
# 2296
iterator __before = __pos; 
# 2297
if ((__pos._M_node) == _M_leftmost()) { 
# 2298
return _Res(_M_leftmost(), _M_leftmost()); } else { 
# 2299
if (!(_M_impl)._M_key_compare(__k, _S_key(((--__before)._M_node)))) 
# 2300
{ 
# 2301
if (_S_right((__before._M_node)) == 0) { 
# 2302
return _Res(0, (__before._M_node)); } else { 
# 2304
return _Res((__pos._M_node), (__pos._M_node)); }  
# 2305
} else { 
# 2307
return _M_get_insert_equal_pos(__k); }  }  
# 2308
} else 
# 2310
{ 
# 2312
iterator __after = __pos; 
# 2313
if ((__pos._M_node) == _M_rightmost()) { 
# 2314
return _Res(0, _M_rightmost()); } else { 
# 2315
if (!(_M_impl)._M_key_compare(_S_key(((++__after)._M_node)), __k)) 
# 2316
{ 
# 2317
if (_S_right((__pos._M_node)) == 0) { 
# 2318
return _Res(0, (__pos._M_node)); } else { 
# 2320
return _Res((__after._M_node), (__after._M_node)); }  
# 2321
} else { 
# 2323
return _Res(0, 0); }  }  
# 2324
}  }  
# 2325
} 
# 2327
template< class _Key, class _Val, class _KeyOfValue, class 
# 2328
_Compare, class _Alloc> 
# 2330
template< class _Arg, class _NodeGen> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2336
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal_(const_iterator __position, _Arg &&
# 2338
__v, _NodeGen &
# 2342
__node_gen) 
# 2343
{ 
# 2344
pair< _Rb_tree_node_base *, _Rb_tree_node_base *>  __res = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v)); 
# 2347
if (__res.second) { 
# 2348
return _M_insert_(__res.first, __res.second, std::forward< _Arg> (__v), __node_gen); }  
# 2352
return _M_insert_equal_lower(std::forward< _Arg> (__v)); 
# 2353
} 
# 2356
template< class _Key, class _Val, class _KeyOfValue, class 
# 2357
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2360
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z) 
# 2361
{ 
# 2362
bool __insert_left = ((__x != (0)) || (__p == _M_end())) || (_M_impl)._M_key_compare(_S_key(__z), _S_key(__p)); 
# 2366
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 2368
++((_M_impl)._M_node_count); 
# 2369
return ((_Rb_tree_iterator< value_type> )(__z)); 
# 2370
} 
# 2372
template< class _Key, class _Val, class _KeyOfValue, class 
# 2373
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2376
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_lower_node(_Base_ptr __p, _Link_type __z) 
# 2377
{ 
# 2378
bool __insert_left = (__p == _M_end()) || (!(_M_impl)._M_key_compare(_S_key(__p), _S_key(__z))); 
# 2382
_Rb_tree_insert_and_rebalance(__insert_left, __z, __p, ((this->_M_impl)._M_header)); 
# 2384
++((_M_impl)._M_node_count); 
# 2385
return ((_Rb_tree_iterator< value_type> )(__z)); 
# 2386
} 
# 2388
template< class _Key, class _Val, class _KeyOfValue, class 
# 2389
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2392
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_insert_equal_lower_node(_Link_type __z) 
# 2393
{ 
# 2394
_Link_type __x = _M_begin(); 
# 2395
_Base_ptr __y = _M_end(); 
# 2396
while (__x != 0) 
# 2397
{ 
# 2398
__y = __x; 
# 2399
__x = ((!(_M_impl)._M_key_compare(_S_key(__x), _S_key(__z))) ? _S_left(__x) : _S_right(__x)); 
# 2401
}  
# 2402
return _M_insert_lower_node(__y, __z); 
# 2403
} 
# 2405
template< class _Key, class _Val, class _KeyOfValue, class 
# 2406
_Compare, class _Alloc> 
# 2407
template< class ..._Args> pair< _Rb_tree_iterator< _Val> , bool>  
# 2411
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_emplace_unique(_Args &&...__args) 
# 2412
{ 
# 2413
_Link_type __z = _M_create_node(std::forward< _Args> (__args)...); 
# 2415
try 
# 2416
{ 
# 2417
typedef pair< _Rb_tree_iterator< _Val> , bool>  _Res; 
# 2418
auto __res = _M_get_insert_unique_pos(_S_key(__z)); 
# 2419
if (__res.second) { 
# 2420
return _Res(_M_insert_node((__res.first), (__res.second), __z), true); }  
# 2422
_M_drop_node(__z); 
# 2423
return _Res((((_Rb_tree_iterator< _Val> )((__res.first)))), false); 
# 2424
} 
# 2425
catch (...) 
# 2426
{ 
# 2427
_M_drop_node(__z); 
# 2428
throw; 
# 2429
}  
# 2430
} 
# 2432
template< class _Key, class _Val, class _KeyOfValue, class 
# 2433
_Compare, class _Alloc> 
# 2434
template< class ..._Args> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2437
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_emplace_equal(_Args &&...__args) 
# 2438
{ 
# 2439
_Link_type __z = _M_create_node(std::forward< _Args> (__args)...); 
# 2441
try 
# 2442
{ 
# 2443
auto __res = _M_get_insert_equal_pos(_S_key(__z)); 
# 2444
return _M_insert_node((__res.first), (__res.second), __z); 
# 2445
} 
# 2446
catch (...) 
# 2447
{ 
# 2448
_M_drop_node(__z); 
# 2449
throw; 
# 2450
}  
# 2451
} 
# 2453
template< class _Key, class _Val, class _KeyOfValue, class 
# 2454
_Compare, class _Alloc> 
# 2455
template< class ..._Args> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2458
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_emplace_hint_unique(const_iterator __pos, _Args &&...__args) 
# 2459
{ 
# 2460
_Link_type __z = _M_create_node(std::forward< _Args> (__args)...); 
# 2462
try 
# 2463
{ 
# 2464
auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z)); 
# 2466
if (__res.second) { 
# 2467
return _M_insert_node((__res.first), (__res.second), __z); }  
# 2469
_M_drop_node(__z); 
# 2470
return ((_Rb_tree_iterator< _Val> )((__res.first))); 
# 2471
} 
# 2472
catch (...) 
# 2473
{ 
# 2474
_M_drop_node(__z); 
# 2475
throw; 
# 2476
}  
# 2477
} 
# 2479
template< class _Key, class _Val, class _KeyOfValue, class 
# 2480
_Compare, class _Alloc> 
# 2481
template< class ..._Args> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2484
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_emplace_hint_equal(const_iterator __pos, _Args &&...__args) 
# 2485
{ 
# 2486
_Link_type __z = _M_create_node(std::forward< _Args> (__args)...); 
# 2488
try 
# 2489
{ 
# 2490
auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z)); 
# 2492
if (__res.second) { 
# 2493
return _M_insert_node((__res.first), (__res.second), __z); }  
# 2495
return _M_insert_equal_lower_node(__z); 
# 2496
} 
# 2497
catch (...) 
# 2498
{ 
# 2499
_M_drop_node(__z); 
# 2500
throw; 
# 2501
}  
# 2502
} 
# 2506
template< class _Key, class _Val, class _KeyOfValue, class 
# 2507
_Compare, class _Alloc> void 
# 2510
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase_aux(const_iterator __position) 
# 2511
{ 
# 2512
_Link_type __y = static_cast< _Link_type>(_Rb_tree_rebalance_for_erase(const_cast< _Base_ptr>(__position._M_node), ((this->_M_impl)._M_header))); 
# 2516
_M_drop_node(__y); 
# 2517
--((_M_impl)._M_node_count); 
# 2518
} 
# 2520
template< class _Key, class _Val, class _KeyOfValue, class 
# 2521
_Compare, class _Alloc> void 
# 2524
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::_M_erase_aux(const_iterator __first, const_iterator __last) 
# 2525
{ 
# 2526
if ((__first == begin()) && (__last == end())) { 
# 2527
clear(); } else { 
# 2529
while (__first != __last) { 
# 2530
_M_erase_aux(__first++); }  }  
# 2531
} 
# 2533
template< class _Key, class _Val, class _KeyOfValue, class 
# 2534
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::size_type 
# 2537
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::erase(const _Key &__x) 
# 2538
{ 
# 2539
pair< iterator, iterator>  __p = equal_range(__x); 
# 2540
const size_type __old_size = size(); 
# 2541
_M_erase_aux((__p.first), (__p.second)); 
# 2542
return __old_size - size(); 
# 2543
} 
# 2545
template< class _Key, class _Val, class _KeyOfValue, class 
# 2546
_Compare, class _Alloc> void 
# 2549
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::erase(const _Key *__first, const _Key *__last) 
# 2550
{ 
# 2551
while (__first != __last) { 
# 2552
erase(*(__first++)); }  
# 2553
} 
# 2555
template< class _Key, class _Val, class _KeyOfValue, class 
# 2556
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::iterator 
# 2560
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::find(const _Key &__k) 
# 2561
{ 
# 2562
iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k); 
# 2563
return ((__j == end()) || (_M_impl)._M_key_compare(__k, _S_key((__j._M_node)))) ? end() : __j; 
# 2566
} 
# 2568
template< class _Key, class _Val, class _KeyOfValue, class 
# 2569
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::const_iterator 
# 2573
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::find(const _Key &__k) const 
# 2574
{ 
# 2575
const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k); 
# 2576
return ((__j == end()) || (_M_impl)._M_key_compare(__k, _S_key((__j._M_node)))) ? end() : __j; 
# 2579
} 
# 2581
template< class _Key, class _Val, class _KeyOfValue, class 
# 2582
_Compare, class _Alloc> typename _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::size_type 
# 2585
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::count(const _Key &__k) const 
# 2586
{ 
# 2587
pair< const_iterator, const_iterator>  __p = equal_range(__k); 
# 2588
const size_type __n = std::distance((__p.first), (__p.second)); 
# 2589
return __n; 
# 2590
} 
# 2592
__attribute((__pure__)) unsigned 
# 2593
_Rb_tree_black_count(const _Rb_tree_node_base * __node, const _Rb_tree_node_base * __root) throw(); 
# 2596
template< class _Key, class _Val, class _KeyOfValue, class 
# 2597
_Compare, class _Alloc> bool 
# 2599
_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc> ::__rb_verify() const 
# 2600
{ 
# 2601
if ((((_M_impl)._M_node_count) == 0) || (begin() == end())) { 
# 2602
return (((_M_impl)._M_node_count) == 0) && (begin() == end()) && ((((this->_M_impl)._M_header)._M_left) == _M_end()) && ((((this->_M_impl)._M_header)._M_right) == _M_end()); }  
# 2606
unsigned __len = _Rb_tree_black_count(_M_leftmost(), _M_root()); 
# 2607
for (const_iterator __it = begin(); __it != end(); ++__it) 
# 2608
{ 
# 2609
_Const_Link_type __x = static_cast< _Const_Link_type>(__it._M_node); 
# 2610
_Const_Link_type __L = _S_left(__x); 
# 2611
_Const_Link_type __R = _S_right(__x); 
# 2613
if ((__x->_M_color) == _S_red) { 
# 2614
if ((__L && ((__L->_M_color) == _S_red)) || (__R && ((__R->_M_color) == _S_red))) { 
# 2616
return false; }  }  
# 2618
if (__L && (_M_impl)._M_key_compare(_S_key(__x), _S_key(__L))) { 
# 2619
return false; }  
# 2620
if (__R && (_M_impl)._M_key_compare(_S_key(__R), _S_key(__x))) { 
# 2621
return false; }  
# 2623
if ((!__L) && (!__R) && (_Rb_tree_black_count(__x, _M_root()) != __len)) { 
# 2624
return false; }  
# 2625
}  
# 2627
if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root())) { 
# 2628
return false; }  
# 2629
if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root())) { 
# 2630
return false; }  
# 2631
return true; 
# 2632
} 
# 2651 "/usr/include/c++/9/bits/stl_tree.h" 3
}
# 66 "/usr/include/c++/9/bits/stl_map.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
template< class _Key, class _Tp, class _Compare, class _Alloc> class multimap; 
# 98 "/usr/include/c++/9/bits/stl_map.h" 3
template< class _Key, class _Tp, class _Compare = less< _Key> , class 
# 99
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 100
class map { 
# 103
public: typedef _Key key_type; 
# 104
typedef _Tp mapped_type; 
# 105
typedef pair< const _Key, _Tp>  value_type; 
# 106
typedef _Compare key_compare; 
# 107
typedef _Alloc allocator_type; 
# 127 "/usr/include/c++/9/bits/stl_map.h" 3
class value_compare : public binary_function< value_type, value_type, bool>  { 
# 130
friend class map; 
# 132
protected: _Compare comp; 
# 134
value_compare(_Compare __c) : comp(__c) 
# 135
{ } 
# 138
public: bool operator()(const typename map< _Key, _Tp, _Compare, _Alloc> ::value_type &__x, const typename map< _Key, _Tp, _Compare, _Alloc> ::value_type &__y) const 
# 139
{ return (comp)((__x.first), (__y.first)); } 
# 140
}; 
# 145
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< value_type> ::other _Pair_alloc_type; 
# 148
typedef _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type>  _Rep_type; 
# 151
_Rep_type _M_t; 
# 153
typedef __gnu_cxx::__alloc_traits< _Pair_alloc_type>  _Alloc_traits; 
# 158
public: typedef typename __gnu_cxx::__alloc_traits< _Pair_alloc_type> ::pointer pointer; 
# 159
typedef typename __gnu_cxx::__alloc_traits< _Pair_alloc_type> ::const_pointer const_pointer; 
# 160
typedef typename __gnu_cxx::__alloc_traits< _Pair_alloc_type> ::reference reference; 
# 161
typedef typename __gnu_cxx::__alloc_traits< _Pair_alloc_type> ::const_reference const_reference; 
# 162
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::iterator iterator; 
# 163
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::const_iterator const_iterator; 
# 164
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::size_type size_type; 
# 165
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::difference_type difference_type; 
# 166
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::reverse_iterator reverse_iterator; 
# 167
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::const_reverse_iterator const_reverse_iterator; 
# 183 "/usr/include/c++/9/bits/stl_map.h" 3
map() = default;
# 192
explicit map(const _Compare &__comp, const allocator_type &
# 193
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 194
{ } 
# 205 "/usr/include/c++/9/bits/stl_map.h" 3
map(const map &) = default;
# 213
map(map &&) = default;
# 226 "/usr/include/c++/9/bits/stl_map.h" 3
map(initializer_list< value_type>  __l, const _Compare &
# 227
__comp = _Compare(), const allocator_type &
# 228
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 230
{ (_M_t)._M_insert_range_unique(__l.begin(), __l.end()); } 
# 234
explicit map(const allocator_type &__a) : _M_t((_Pair_alloc_type)__a) 
# 235
{ } 
# 238
map(const map &__m, const allocator_type &__a) : _M_t(__m._M_t, (_Pair_alloc_type)__a) 
# 239
{ } 
# 242
map(map &&__m, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare> ::value && _Alloc_traits::_S_always_equal()) : _M_t(std::move(__m._M_t), (_Pair_alloc_type)__a) 
# 245
{ } 
# 248
map(initializer_list< value_type>  __l, const allocator_type &__a) : _M_t((_Pair_alloc_type)__a) 
# 250
{ (_M_t)._M_insert_range_unique(__l.begin(), __l.end()); } 
# 253
template< class _InputIterator> 
# 254
map(_InputIterator __first, _InputIterator __last, const allocator_type &
# 255
__a) : _M_t((_Pair_alloc_type)__a) 
# 257
{ (_M_t)._M_insert_range_unique(__first, __last); } 
# 270 "/usr/include/c++/9/bits/stl_map.h" 3
template< class _InputIterator> 
# 271
map(_InputIterator __first, _InputIterator __last) : _M_t() 
# 273
{ (_M_t)._M_insert_range_unique(__first, __last); } 
# 287 "/usr/include/c++/9/bits/stl_map.h" 3
template< class _InputIterator> 
# 288
map(_InputIterator __first, _InputIterator __last, const _Compare &
# 289
__comp, const allocator_type &
# 290
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 292
{ (_M_t)._M_insert_range_unique(__first, __last); } 
# 300
~map() = default;
# 317 "/usr/include/c++/9/bits/stl_map.h" 3
map &operator=(const map &) = default;
# 321
map &operator=(map &&) = default;
# 335 "/usr/include/c++/9/bits/stl_map.h" 3
map &operator=(initializer_list< value_type>  __l) 
# 336
{ 
# 337
(_M_t)._M_assign_unique(__l.begin(), __l.end()); 
# 338
return *this; 
# 339
} 
# 344
allocator_type get_allocator() const noexcept 
# 345
{ return (allocator_type)(_M_t).get_allocator(); } 
# 354
iterator begin() noexcept 
# 355
{ return (_M_t).begin(); } 
# 363
const_iterator begin() const noexcept 
# 364
{ return (_M_t).begin(); } 
# 372
iterator end() noexcept 
# 373
{ return (_M_t).end(); } 
# 381
const_iterator end() const noexcept 
# 382
{ return (_M_t).end(); } 
# 390
reverse_iterator rbegin() noexcept 
# 391
{ return (_M_t).rbegin(); } 
# 399
const_reverse_iterator rbegin() const noexcept 
# 400
{ return (_M_t).rbegin(); } 
# 408
reverse_iterator rend() noexcept 
# 409
{ return (_M_t).rend(); } 
# 417
const_reverse_iterator rend() const noexcept 
# 418
{ return (_M_t).rend(); } 
# 427
const_iterator cbegin() const noexcept 
# 428
{ return (_M_t).begin(); } 
# 436
const_iterator cend() const noexcept 
# 437
{ return (_M_t).end(); } 
# 445
const_reverse_iterator crbegin() const noexcept 
# 446
{ return (_M_t).rbegin(); } 
# 454
const_reverse_iterator crend() const noexcept 
# 455
{ return (_M_t).rend(); } 
# 463
bool empty() const noexcept 
# 464
{ return (_M_t).empty(); } 
# 468
size_type size() const noexcept 
# 469
{ return (_M_t).size(); } 
# 473
size_type max_size() const noexcept 
# 474
{ return (_M_t).max_size(); } 
# 490 "/usr/include/c++/9/bits/stl_map.h" 3
mapped_type &operator[](const key_type &__k) 
# 491
{ 
# 495
iterator __i = lower_bound(__k); 
# 497
if ((__i == end()) || key_comp()(__k, ((*__i).first))) { 
# 499
__i = (_M_t)._M_emplace_hint_unique(__i, std::piecewise_construct, ((tuple< const _Key &> )(__k)), tuple< > ()); }  
# 505
return (*__i).second; 
# 506
} 
# 510
mapped_type &operator[](key_type &&__k) 
# 511
{ 
# 515
iterator __i = lower_bound(__k); 
# 517
if ((__i == end()) || key_comp()(__k, ((*__i).first))) { 
# 518
__i = (_M_t)._M_emplace_hint_unique(__i, std::piecewise_construct, std::forward_as_tuple(std::move(__k)), tuple< > ()); }  
# 521
return (*__i).second; 
# 522
} 
# 535 "/usr/include/c++/9/bits/stl_map.h" 3
mapped_type &at(const key_type &__k) 
# 536
{ 
# 537
iterator __i = lower_bound(__k); 
# 538
if ((__i == end()) || key_comp()(__k, ((*__i).first))) { 
# 539
__throw_out_of_range("map::at"); }  
# 540
return (*__i).second; 
# 541
} 
# 544
const mapped_type &at(const key_type &__k) const 
# 545
{ 
# 546
const_iterator __i = lower_bound(__k); 
# 547
if ((__i == end()) || key_comp()(__k, ((*__i).first))) { 
# 548
__throw_out_of_range("map::at"); }  
# 549
return (*__i).second; 
# 550
} 
# 572 "/usr/include/c++/9/bits/stl_map.h" 3
template< class ..._Args> pair< iterator, bool>  
# 574
emplace(_Args &&...__args) 
# 575
{ return (_M_t)._M_emplace_unique(std::forward< _Args> (__args)...); } 
# 602 "/usr/include/c++/9/bits/stl_map.h" 3
template< class ..._Args> iterator 
# 604
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 605
{ 
# 606
return (_M_t)._M_emplace_hint_unique(__pos, std::forward< _Args> (__args)...); 
# 608
} 
# 801 "/usr/include/c++/9/bits/stl_map.h" 3
pair< iterator, bool>  insert(const value_type &__x) 
# 802
{ return (_M_t)._M_insert_unique(__x); } 
# 808
pair< iterator, bool>  insert(value_type &&__x) 
# 809
{ return (_M_t)._M_insert_unique(std::move(__x)); } 
# 811
template< class _Pair> __enable_if_t< is_constructible< value_type, _Pair> ::value, pair< iterator, bool> >  
# 814
insert(_Pair &&__x) 
# 815
{ return (_M_t)._M_emplace_unique(std::forward< _Pair> (__x)); } 
# 828 "/usr/include/c++/9/bits/stl_map.h" 3
void insert(initializer_list< value_type>  __list) 
# 829
{ insert(__list.begin(), __list.end()); } 
# 858 "/usr/include/c++/9/bits/stl_map.h" 3
iterator insert(const_iterator __position, const value_type &__x) 
# 862
{ return (_M_t)._M_insert_unique_(__position, __x); } 
# 868
iterator insert(const_iterator __position, value_type &&__x) 
# 869
{ return (_M_t)._M_insert_unique_(__position, std::move(__x)); } 
# 871
template< class _Pair> __enable_if_t< is_constructible< value_type, _Pair> ::value, iterator>  
# 873
insert(const_iterator __position, _Pair &&__x) 
# 874
{ 
# 875
return (_M_t)._M_emplace_hint_unique(__position, std::forward< _Pair> (__x)); 
# 877
} 
# 889 "/usr/include/c++/9/bits/stl_map.h" 3
template< class _InputIterator> void 
# 891
insert(_InputIterator __first, _InputIterator __last) 
# 892
{ (_M_t)._M_insert_range_unique(__first, __last); } 
# 1030 "/usr/include/c++/9/bits/stl_map.h" 3
iterator erase(const_iterator __position) 
# 1031
{ return (_M_t).erase(__position); } 
# 1034
__attribute((__abi_tag__("cxx11"))) iterator 
# 1036
erase(iterator __position) 
# 1037
{ return (_M_t).erase(__position); } 
# 1067 "/usr/include/c++/9/bits/stl_map.h" 3
size_type erase(const key_type &__x) 
# 1068
{ return (_M_t).erase(__x); } 
# 1087 "/usr/include/c++/9/bits/stl_map.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 1088
{ return (_M_t).erase(__first, __last); } 
# 1121 "/usr/include/c++/9/bits/stl_map.h" 3
void swap(map &__x) noexcept(__is_nothrow_swappable< _Compare> ::value) 
# 1123
{ (_M_t).swap(__x._M_t); } 
# 1132
void clear() noexcept 
# 1133
{ (_M_t).clear(); } 
# 1141
key_compare key_comp() const 
# 1142
{ return (_M_t).key_comp(); } 
# 1149
value_compare value_comp() const 
# 1150
{ return (value_compare)(_M_t).key_comp(); } 
# 1168 "/usr/include/c++/9/bits/stl_map.h" 3
iterator find(const key_type &__x) 
# 1169
{ return (_M_t).find(__x); } 
# 1172
template< class _Kt> auto 
# 1174
find(const _Kt &__x)->__decltype(((_M_t)._M_find_tr(__x))) 
# 1175
{ return (_M_t)._M_find_tr(__x); } 
# 1193 "/usr/include/c++/9/bits/stl_map.h" 3
const_iterator find(const key_type &__x) const 
# 1194
{ return (_M_t).find(__x); } 
# 1197
template< class _Kt> auto 
# 1199
find(const _Kt &__x) const->__decltype(((_M_t)._M_find_tr(__x))) 
# 1200
{ return (_M_t)._M_find_tr(__x); } 
# 1214 "/usr/include/c++/9/bits/stl_map.h" 3
size_type count(const key_type &__x) const 
# 1215
{ return ((_M_t).find(__x) == (_M_t).end()) ? 0 : 1; } 
# 1218
template< class _Kt> auto 
# 1220
count(const _Kt &__x) const->__decltype(((_M_t)._M_count_tr(__x))) 
# 1221
{ return (_M_t)._M_count_tr(__x); } 
# 1257 "/usr/include/c++/9/bits/stl_map.h" 3
iterator lower_bound(const key_type &__x) 
# 1258
{ return (_M_t).lower_bound(__x); } 
# 1261
template< class _Kt> auto 
# 1263
lower_bound(const _Kt &__x)->__decltype(((iterator)(_M_t)._M_lower_bound_tr(__x))) 
# 1265
{ return (iterator)(_M_t)._M_lower_bound_tr(__x); } 
# 1282 "/usr/include/c++/9/bits/stl_map.h" 3
const_iterator lower_bound(const key_type &__x) const 
# 1283
{ return (_M_t).lower_bound(__x); } 
# 1286
template< class _Kt> auto 
# 1288
lower_bound(const _Kt &__x) const->__decltype(((const_iterator)(_M_t)._M_lower_bound_tr(__x))) 
# 1290
{ return (const_iterator)(_M_t)._M_lower_bound_tr(__x); } 
# 1302 "/usr/include/c++/9/bits/stl_map.h" 3
iterator upper_bound(const key_type &__x) 
# 1303
{ return (_M_t).upper_bound(__x); } 
# 1306
template< class _Kt> auto 
# 1308
upper_bound(const _Kt &__x)->__decltype(((iterator)(_M_t)._M_upper_bound_tr(__x))) 
# 1310
{ return (iterator)(_M_t)._M_upper_bound_tr(__x); } 
# 1322 "/usr/include/c++/9/bits/stl_map.h" 3
const_iterator upper_bound(const key_type &__x) const 
# 1323
{ return (_M_t).upper_bound(__x); } 
# 1326
template< class _Kt> auto 
# 1328
upper_bound(const _Kt &__x) const->__decltype(((const_iterator)(_M_t)._M_upper_bound_tr(__x))) 
# 1330
{ return (const_iterator)(_M_t)._M_upper_bound_tr(__x); } 
# 1351 "/usr/include/c++/9/bits/stl_map.h" 3
pair< iterator, iterator>  equal_range(const key_type &__x) 
# 1352
{ return (_M_t).equal_range(__x); } 
# 1355
template< class _Kt> auto 
# 1357
equal_range(const _Kt &__x)->__decltype((((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))))) 
# 1359
{ return ((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))); } 
# 1380 "/usr/include/c++/9/bits/stl_map.h" 3
pair< const_iterator, const_iterator>  equal_range(const key_type &__x) const 
# 1381
{ return (_M_t).equal_range(__x); } 
# 1384
template< class _Kt> auto 
# 1386
equal_range(const _Kt &__x) const->__decltype((((pair< const_iterator, const_iterator> )((_M_t)._M_equal_range_tr(__x))))) 
# 1389
{ 
# 1390
return ((pair< const_iterator, const_iterator> )((_M_t)._M_equal_range_tr(__x))); 
# 1392
} 
# 1396
template< class _K1, class _T1, class _C1, class _A1> friend bool operator==(const std::map< _K1, _T1, _C1, _A1>  &, const std::map< _K1, _T1, _C1, _A1>  &); 
# 1401
template< class _K1, class _T1, class _C1, class _A1> friend bool operator<(const std::map< _K1, _T1, _C1, _A1>  &, const std::map< _K1, _T1, _C1, _A1>  &); 
# 1405
}; 
# 1453 "/usr/include/c++/9/bits/stl_map.h" 3
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1455
operator==(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1456
__y) 
# 1457
{ return (__x._M_t) == (__y._M_t); } 
# 1470 "/usr/include/c++/9/bits/stl_map.h" 3
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1472
operator<(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1473
__y) 
# 1474
{ return (__x._M_t) < (__y._M_t); } 
# 1477
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1479
operator!=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1480
__y) 
# 1481
{ return !(__x == __y); } 
# 1484
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1486
operator>(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1487
__y) 
# 1488
{ return __y < __x; } 
# 1491
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1493
operator<=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1494
__y) 
# 1495
{ return !(__y < __x); } 
# 1498
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1500
operator>=(const map< _Key, _Tp, _Compare, _Alloc>  &__x, const map< _Key, _Tp, _Compare, _Alloc>  &
# 1501
__y) 
# 1502
{ return !(__x < __y); } 
# 1505
template< class _Key, class _Tp, class _Compare, class _Alloc> inline void 
# 1507
swap(map< _Key, _Tp, _Compare, _Alloc>  &__x, map< _Key, _Tp, _Compare, _Alloc>  &
# 1508
__y) noexcept(noexcept(__x.swap(__y))) 
# 1510
{ __x.swap(__y); } 
# 1536 "/usr/include/c++/9/bits/stl_map.h" 3
}
# 64 "/usr/include/c++/9/bits/stl_multimap.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 69
template< class _Key, class _Tp, class _Compare, class _Alloc> class map; 
# 96 "/usr/include/c++/9/bits/stl_multimap.h" 3
template< class _Key, class _Tp, class 
# 97
_Compare = less< _Key> , class 
# 98
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 99
class multimap { 
# 102
public: typedef _Key key_type; 
# 103
typedef _Tp mapped_type; 
# 104
typedef pair< const _Key, _Tp>  value_type; 
# 105
typedef _Compare key_compare; 
# 106
typedef _Alloc allocator_type; 
# 126 "/usr/include/c++/9/bits/stl_multimap.h" 3
class value_compare : public binary_function< value_type, value_type, bool>  { 
# 129
friend class multimap; 
# 131
protected: _Compare comp; 
# 133
value_compare(_Compare __c) : comp(__c) 
# 134
{ } 
# 137
public: bool operator()(const typename multimap< _Key, _Tp, _Compare, _Alloc> ::value_type &__x, const typename multimap< _Key, _Tp, _Compare, _Alloc> ::value_type &__y) const 
# 138
{ return (comp)((__x.first), (__y.first)); } 
# 139
}; 
# 144
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< value_type> ::other _Pair_alloc_type; 
# 147
typedef _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type>  _Rep_type; 
# 149
_Rep_type _M_t; 
# 151
typedef __gnu_cxx::__alloc_traits< _Pair_alloc_type>  _Alloc_traits; 
# 156
public: typedef typename __gnu_cxx::__alloc_traits< _Pair_alloc_type> ::pointer pointer; 
# 157
typedef typename __gnu_cxx::__alloc_traits< _Pair_alloc_type> ::const_pointer const_pointer; 
# 158
typedef typename __gnu_cxx::__alloc_traits< _Pair_alloc_type> ::reference reference; 
# 159
typedef typename __gnu_cxx::__alloc_traits< _Pair_alloc_type> ::const_reference const_reference; 
# 160
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::iterator iterator; 
# 161
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::const_iterator const_iterator; 
# 162
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::size_type size_type; 
# 163
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::difference_type difference_type; 
# 164
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::reverse_iterator reverse_iterator; 
# 165
typedef typename _Rb_tree< key_type, value_type, _Select1st< value_type> , key_compare, _Pair_alloc_type> ::const_reverse_iterator const_reverse_iterator; 
# 180 "/usr/include/c++/9/bits/stl_multimap.h" 3
multimap() = default;
# 189
explicit multimap(const _Compare &__comp, const allocator_type &
# 190
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 191
{ } 
# 202 "/usr/include/c++/9/bits/stl_multimap.h" 3
multimap(const multimap &) = default;
# 211 "/usr/include/c++/9/bits/stl_multimap.h" 3
multimap(multimap &&) = default;
# 223 "/usr/include/c++/9/bits/stl_multimap.h" 3
multimap(initializer_list< value_type>  __l, const _Compare &
# 224
__comp = _Compare(), const allocator_type &
# 225
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 227
{ (_M_t)._M_insert_range_equal(__l.begin(), __l.end()); } 
# 231
explicit multimap(const allocator_type &__a) : _M_t((_Pair_alloc_type)__a) 
# 232
{ } 
# 235
multimap(const multimap &__m, const allocator_type &__a) : _M_t(__m._M_t, (_Pair_alloc_type)__a) 
# 236
{ } 
# 239
multimap(multimap &&__m, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare> ::value && _Alloc_traits::_S_always_equal()) : _M_t(std::move(__m._M_t), (_Pair_alloc_type)__a) 
# 242
{ } 
# 245
multimap(initializer_list< value_type>  __l, const allocator_type &__a) : _M_t((_Pair_alloc_type)__a) 
# 247
{ (_M_t)._M_insert_range_equal(__l.begin(), __l.end()); } 
# 250
template< class _InputIterator> 
# 251
multimap(_InputIterator __first, _InputIterator __last, const allocator_type &
# 252
__a) : _M_t((_Pair_alloc_type)__a) 
# 254
{ (_M_t)._M_insert_range_equal(__first, __last); } 
# 266 "/usr/include/c++/9/bits/stl_multimap.h" 3
template< class _InputIterator> 
# 267
multimap(_InputIterator __first, _InputIterator __last) : _M_t() 
# 269
{ (_M_t)._M_insert_range_equal(__first, __last); } 
# 282 "/usr/include/c++/9/bits/stl_multimap.h" 3
template< class _InputIterator> 
# 283
multimap(_InputIterator __first, _InputIterator __last, const _Compare &
# 284
__comp, const allocator_type &
# 285
__a = allocator_type()) : _M_t(__comp, (_Pair_alloc_type)__a) 
# 287
{ (_M_t)._M_insert_range_equal(__first, __last); } 
# 295
~multimap() = default;
# 312 "/usr/include/c++/9/bits/stl_multimap.h" 3
multimap &operator=(const multimap &) = default;
# 316
multimap &operator=(multimap &&) = default;
# 330 "/usr/include/c++/9/bits/stl_multimap.h" 3
multimap &operator=(initializer_list< value_type>  __l) 
# 331
{ 
# 332
(_M_t)._M_assign_equal(__l.begin(), __l.end()); 
# 333
return *this; 
# 334
} 
# 339
allocator_type get_allocator() const noexcept 
# 340
{ return (allocator_type)(_M_t).get_allocator(); } 
# 349
iterator begin() noexcept 
# 350
{ return (_M_t).begin(); } 
# 358
const_iterator begin() const noexcept 
# 359
{ return (_M_t).begin(); } 
# 367
iterator end() noexcept 
# 368
{ return (_M_t).end(); } 
# 376
const_iterator end() const noexcept 
# 377
{ return (_M_t).end(); } 
# 385
reverse_iterator rbegin() noexcept 
# 386
{ return (_M_t).rbegin(); } 
# 394
const_reverse_iterator rbegin() const noexcept 
# 395
{ return (_M_t).rbegin(); } 
# 403
reverse_iterator rend() noexcept 
# 404
{ return (_M_t).rend(); } 
# 412
const_reverse_iterator rend() const noexcept 
# 413
{ return (_M_t).rend(); } 
# 422
const_iterator cbegin() const noexcept 
# 423
{ return (_M_t).begin(); } 
# 431
const_iterator cend() const noexcept 
# 432
{ return (_M_t).end(); } 
# 440
const_reverse_iterator crbegin() const noexcept 
# 441
{ return (_M_t).rbegin(); } 
# 449
const_reverse_iterator crend() const noexcept 
# 450
{ return (_M_t).rend(); } 
# 456
bool empty() const noexcept 
# 457
{ return (_M_t).empty(); } 
# 461
size_type size() const noexcept 
# 462
{ return (_M_t).size(); } 
# 466
size_type max_size() const noexcept 
# 467
{ return (_M_t).max_size(); } 
# 487 "/usr/include/c++/9/bits/stl_multimap.h" 3
template< class ..._Args> iterator 
# 489
emplace(_Args &&...__args) 
# 490
{ return (_M_t)._M_emplace_equal(std::forward< _Args> (__args)...); } 
# 514 "/usr/include/c++/9/bits/stl_multimap.h" 3
template< class ..._Args> iterator 
# 516
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 517
{ 
# 518
return (_M_t)._M_emplace_hint_equal(__pos, std::forward< _Args> (__args)...); 
# 520
} 
# 537 "/usr/include/c++/9/bits/stl_multimap.h" 3
iterator insert(const value_type &__x) 
# 538
{ return (_M_t)._M_insert_equal(__x); } 
# 544
iterator insert(value_type &&__x) 
# 545
{ return (_M_t)._M_insert_equal(std::move(__x)); } 
# 547
template< class _Pair> __enable_if_t< is_constructible< value_type, _Pair> ::value, iterator>  
# 549
insert(_Pair &&__x) 
# 550
{ return (_M_t)._M_emplace_equal(std::forward< _Pair> (__x)); } 
# 577 "/usr/include/c++/9/bits/stl_multimap.h" 3
iterator insert(const_iterator __position, const value_type &__x) 
# 581
{ return (_M_t)._M_insert_equal_(__position, __x); } 
# 587
iterator insert(const_iterator __position, value_type &&__x) 
# 588
{ return (_M_t)._M_insert_equal_(__position, std::move(__x)); } 
# 590
template< class _Pair> __enable_if_t< is_constructible< value_type, _Pair &&> ::value, iterator>  
# 592
insert(const_iterator __position, _Pair &&__x) 
# 593
{ 
# 594
return (_M_t)._M_emplace_hint_equal(__position, std::forward< _Pair> (__x)); 
# 596
} 
# 609 "/usr/include/c++/9/bits/stl_multimap.h" 3
template< class _InputIterator> void 
# 611
insert(_InputIterator __first, _InputIterator __last) 
# 612
{ (_M_t)._M_insert_range_equal(__first, __last); } 
# 623 "/usr/include/c++/9/bits/stl_multimap.h" 3
void insert(initializer_list< value_type>  __l) 
# 624
{ this->insert(__l.begin(), __l.end()); } 
# 700 "/usr/include/c++/9/bits/stl_multimap.h" 3
iterator erase(const_iterator __position) 
# 701
{ return (_M_t).erase(__position); } 
# 704
__attribute((__abi_tag__("cxx11"))) iterator 
# 706
erase(iterator __position) 
# 707
{ return (_M_t).erase(__position); } 
# 737 "/usr/include/c++/9/bits/stl_multimap.h" 3
size_type erase(const key_type &__x) 
# 738
{ return (_M_t).erase(__x); } 
# 758 "/usr/include/c++/9/bits/stl_multimap.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 759
{ return (_M_t).erase(__first, __last); } 
# 795 "/usr/include/c++/9/bits/stl_multimap.h" 3
void swap(multimap &__x) noexcept(__is_nothrow_swappable< _Compare> ::value) 
# 797
{ (_M_t).swap(__x._M_t); } 
# 806
void clear() noexcept 
# 807
{ (_M_t).clear(); } 
# 815
key_compare key_comp() const 
# 816
{ return (_M_t).key_comp(); } 
# 823
value_compare value_comp() const 
# 824
{ return (value_compare)(_M_t).key_comp(); } 
# 841 "/usr/include/c++/9/bits/stl_multimap.h" 3
iterator find(const key_type &__x) 
# 842
{ return (_M_t).find(__x); } 
# 845
template< class _Kt> auto 
# 847
find(const _Kt &__x)->__decltype(((_M_t)._M_find_tr(__x))) 
# 848
{ return (_M_t)._M_find_tr(__x); } 
# 865 "/usr/include/c++/9/bits/stl_multimap.h" 3
const_iterator find(const key_type &__x) const 
# 866
{ return (_M_t).find(__x); } 
# 869
template< class _Kt> auto 
# 871
find(const _Kt &__x) const->__decltype(((_M_t)._M_find_tr(__x))) 
# 872
{ return (_M_t)._M_find_tr(__x); } 
# 883 "/usr/include/c++/9/bits/stl_multimap.h" 3
size_type count(const key_type &__x) const 
# 884
{ return (_M_t).count(__x); } 
# 887
template< class _Kt> auto 
# 889
count(const _Kt &__x) const->__decltype(((_M_t)._M_count_tr(__x))) 
# 890
{ return (_M_t)._M_count_tr(__x); } 
# 926 "/usr/include/c++/9/bits/stl_multimap.h" 3
iterator lower_bound(const key_type &__x) 
# 927
{ return (_M_t).lower_bound(__x); } 
# 930
template< class _Kt> auto 
# 932
lower_bound(const _Kt &__x)->__decltype(((iterator)(_M_t)._M_lower_bound_tr(__x))) 
# 934
{ return (iterator)(_M_t)._M_lower_bound_tr(__x); } 
# 951 "/usr/include/c++/9/bits/stl_multimap.h" 3
const_iterator lower_bound(const key_type &__x) const 
# 952
{ return (_M_t).lower_bound(__x); } 
# 955
template< class _Kt> auto 
# 957
lower_bound(const _Kt &__x) const->__decltype(((const_iterator)(_M_t)._M_lower_bound_tr(__x))) 
# 959
{ return (const_iterator)(_M_t)._M_lower_bound_tr(__x); } 
# 971 "/usr/include/c++/9/bits/stl_multimap.h" 3
iterator upper_bound(const key_type &__x) 
# 972
{ return (_M_t).upper_bound(__x); } 
# 975
template< class _Kt> auto 
# 977
upper_bound(const _Kt &__x)->__decltype(((iterator)(_M_t)._M_upper_bound_tr(__x))) 
# 979
{ return (iterator)(_M_t)._M_upper_bound_tr(__x); } 
# 991 "/usr/include/c++/9/bits/stl_multimap.h" 3
const_iterator upper_bound(const key_type &__x) const 
# 992
{ return (_M_t).upper_bound(__x); } 
# 995
template< class _Kt> auto 
# 997
upper_bound(const _Kt &__x) const->__decltype(((const_iterator)(_M_t)._M_upper_bound_tr(__x))) 
# 999
{ return (const_iterator)(_M_t)._M_upper_bound_tr(__x); } 
# 1018 "/usr/include/c++/9/bits/stl_multimap.h" 3
pair< iterator, iterator>  equal_range(const key_type &__x) 
# 1019
{ return (_M_t).equal_range(__x); } 
# 1022
template< class _Kt> auto 
# 1024
equal_range(const _Kt &__x)->__decltype((((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))))) 
# 1026
{ return ((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))); } 
# 1045 "/usr/include/c++/9/bits/stl_multimap.h" 3
pair< const_iterator, const_iterator>  equal_range(const key_type &__x) const 
# 1046
{ return (_M_t).equal_range(__x); } 
# 1049
template< class _Kt> auto 
# 1051
equal_range(const _Kt &__x) const->__decltype((((pair< const_iterator, const_iterator> )((_M_t)._M_equal_range_tr(__x))))) 
# 1054
{ 
# 1055
return ((pair< const_iterator, const_iterator> )((_M_t)._M_equal_range_tr(__x))); 
# 1057
} 
# 1061
template< class _K1, class _T1, class _C1, class _A1> friend bool operator==(const std::multimap< _K1, _T1, _C1, _A1>  &, const std::multimap< _K1, _T1, _C1, _A1>  &); 
# 1066
template< class _K1, class _T1, class _C1, class _A1> friend bool operator<(const std::multimap< _K1, _T1, _C1, _A1>  &, const std::multimap< _K1, _T1, _C1, _A1>  &); 
# 1070
}; 
# 1117 "/usr/include/c++/9/bits/stl_multimap.h" 3
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1119
operator==(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1120
__y) 
# 1121
{ return (__x._M_t) == (__y._M_t); } 
# 1134 "/usr/include/c++/9/bits/stl_multimap.h" 3
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1136
operator<(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1137
__y) 
# 1138
{ return (__x._M_t) < (__y._M_t); } 
# 1141
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1143
operator!=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1144
__y) 
# 1145
{ return !(__x == __y); } 
# 1148
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1150
operator>(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1151
__y) 
# 1152
{ return __y < __x; } 
# 1155
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1157
operator<=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1158
__y) 
# 1159
{ return !(__y < __x); } 
# 1162
template< class _Key, class _Tp, class _Compare, class _Alloc> inline bool 
# 1164
operator>=(const multimap< _Key, _Tp, _Compare, _Alloc>  &__x, const multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1165
__y) 
# 1166
{ return !(__x < __y); } 
# 1169
template< class _Key, class _Tp, class _Compare, class _Alloc> inline void 
# 1171
swap(multimap< _Key, _Tp, _Compare, _Alloc>  &__x, multimap< _Key, _Tp, _Compare, _Alloc>  &
# 1172
__y) noexcept(noexcept(__x.swap(__y))) 
# 1174
{ __x.swap(__y); } 
# 1200 "/usr/include/c++/9/bits/stl_multimap.h" 3
}
# 37 "/usr/include/c++/9/bits/erase_if.h" 3
namespace std { 
# 45
namespace __detail { 
# 47
template< class _Container, class _Predicate> typename _Container::size_type 
# 49
__erase_nodes_if(_Container &__cont, _Predicate __pred) 
# 50
{ 
# 51
typename _Container::size_type __num = (0); 
# 52
for (auto __iter = __cont.begin(), __last = __cont.end(); __iter != __last;) 
# 54
{ 
# 55
if (__pred(*__iter)) 
# 56
{ 
# 57
__iter = __cont.erase(__iter); 
# 58
++__num; 
# 59
} else { 
# 61
++__iter; }  
# 62
}  
# 63
return __num; 
# 64
} 
# 65
}
# 68
}
# 51 "/usr/include/opencv4/opencv2/dnn/dict.hpp" 3
namespace cv { 
# 52
namespace dnn { 
# 53
namespace dnn4_v20191202 { 
# 60
struct DictValue { 
# 62
inline DictValue(const DictValue & r); 
# 63
DictValue(bool i) : type(Param::INT), pi(new AutoBuffer< signed long, 1UL> ) { ((*(pi))[0]) = (i ? 1 : 0); } 
# 64
DictValue(int64 i = 0) : type(Param::INT), pi(new AutoBuffer< signed long, 1UL> ) { ((*(pi))[0]) = i; } 
# 65
DictValue(int i) : type(Param::INT), pi(new AutoBuffer< signed long, 1UL> ) { ((*(pi))[0]) = i; } 
# 66
DictValue(unsigned p) : type(Param::INT), pi(new AutoBuffer< signed long, 1UL> ) { ((*(pi))[0]) = p; } 
# 67
DictValue(double p) : type(Param::REAL), pd(new AutoBuffer< double, 1UL> ) { ((*(pd))[0]) = p; } 
# 68
DictValue(const String &s) : type(Param::STRING), ps(new AutoBuffer< std::__cxx11::basic_string< char> , 1UL> ) { (((*(ps))[0]) = s); } 
# 69
DictValue(const char *s) : type(Param::STRING), ps(new AutoBuffer< std::__cxx11::basic_string< char> , 1UL> ) { (((*(ps))[0]) = s); } 
# 71
template< class TypeIter> static DictValue arrayInt(TypeIter begin, int size); 
# 73
template< class TypeIter> static DictValue arrayReal(TypeIter begin, int size); 
# 75
template< class TypeIter> static DictValue arrayString(TypeIter begin, int size); 
# 78
template< class T> T get(int idx = -1) const; 
# 81
inline int size() const; 
# 83
inline bool isInt() const; 
# 84
inline bool isString() const; 
# 85
inline bool isReal() const; 
# 87
inline int getIntValue(int idx = -1) const; 
# 88
inline double getRealValue(int idx = -1) const; 
# 89
inline String getStringValue(int idx = -1) const; 
# 91
inline DictValue &operator=(const DictValue & r); 
# 93
friend inline std::ostream &operator<<(std::ostream & stream, const DictValue & dictv); 
# 95
inline ~DictValue(); 
# 99
private: Param type; 
# 102
union { 
# 103
AutoBuffer< signed long, 1UL>  *pi; 
# 104
AutoBuffer< double, 1UL>  *pd; 
# 105
AutoBuffer< std::__cxx11::basic_string< char> , 1UL>  *ps; 
# 106
void *pv; 
# 107
}; 
# 109
DictValue(Param _type, void *_p) : type(_type), pv(_p) { } 
# 110
inline void release(); 
# 111
}; 
# 114
class Dict { 
# 116
typedef std::map< std::__cxx11::basic_string< char> , DictValue>  _Dict; 
# 117
_Dict dict; 
# 122
public: inline bool has(const String & key) const; 
# 125
inline DictValue *ptr(const String & key); 
# 128
inline const DictValue *ptr(const String & key) const; 
# 131
inline const DictValue &get(const String & key) const; 
# 134
template< class T> inline T get(const String & key) const; 
# 138
template< class T> inline T get(const String & key, const T & defaultValue) const; 
# 142
template< class T> inline const T &set(const String & key, const T & value); 
# 146
inline void erase(const String & key); 
# 148
friend inline std::ostream &operator<<(std::ostream & stream, const Dict & dict); 
# 150
inline std::map< std::__cxx11::basic_string< char> , DictValue> ::const_iterator begin() const; 
# 152
inline std::map< std::__cxx11::basic_string< char> , DictValue> ::const_iterator end() const; 
# 153
}; 
# 156
}
# 157
}
# 158
}
# 53 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
namespace cv { 
# 54
namespace dnn { 
# 55
namespace dnn4_v20191202 { 
# 59
typedef std::vector< int>  MatShape; 
# 65
enum Backend { 
# 70
DNN_BACKEND_DEFAULT, 
# 71
DNN_BACKEND_HALIDE, 
# 72
DNN_BACKEND_INFERENCE_ENGINE, 
# 74
DNN_BACKEND_OPENCV, 
# 75
DNN_BACKEND_VKCOM, 
# 76
DNN_BACKEND_CUDA
# 81
}; 
# 87
enum Target { 
# 89
DNN_TARGET_CPU, 
# 90
DNN_TARGET_OPENCL, 
# 91
DNN_TARGET_OPENCL_FP16, 
# 92
DNN_TARGET_MYRIAD, 
# 93
DNN_TARGET_VULKAN, 
# 94
DNN_TARGET_FPGA, 
# 95
DNN_TARGET_CUDA, 
# 96
DNN_TARGET_CUDA_FP16
# 97
}; 
# 99
std::vector< std::pair< Backend, Target> >  getAvailableBackends(); 
# 100
std::vector< Target>  getAvailableTargets(Backend be); 
# 107
class LayerParams : public Dict { 
# 111
public: std::vector< Mat>  blobs; 
# 113
String name; 
# 114
String type; 
# 115
}; 
# 120
class BackendNode { 
# 123
public: BackendNode(int backendId); 
# 125
virtual ~BackendNode(); 
# 127
int backendId; 
# 128
}; 
# 133
class BackendWrapper { 
# 136
public: BackendWrapper(int backendId, int targetId); 
# 145 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
BackendWrapper(int targetId, const Mat & m); 
# 157 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
BackendWrapper(const Ptr< BackendWrapper>  & base, const MatShape & shape); 
# 159
virtual ~BackendWrapper(); 
# 164
virtual void copyToHost() = 0; 
# 169
virtual void setHostDirty() = 0; 
# 171
int backendId; 
# 172
int targetId; 
# 173
}; 
# 175
class ActivationLayer; 
# 182
class Layer : public Algorithm { 
# 187
public: std::vector< Mat>  blobs; 
# 197 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
__attribute((deprecated)) virtual void 
# 198
finalize(const std::vector< Mat *>  & input, std::vector< Mat>  & output); 
# 207 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
virtual void finalize(InputArrayOfArrays inputs, OutputArrayOfArrays outputs); 
# 215
__attribute((deprecated)) virtual void 
# 216
forward(std::vector< Mat *>  & input, std::vector< Mat>  & output, std::vector< Mat>  & internals); 
# 223
virtual void forward(InputArrayOfArrays inputs, OutputArrayOfArrays outputs, OutputArrayOfArrays internals); 
# 230
void forward_fallback(InputArrayOfArrays inputs, OutputArrayOfArrays outputs, OutputArrayOfArrays internals); 
# 236
__attribute((deprecated)) void 
# 237
finalize(const std::vector< Mat>  & inputs, std::vector< Mat>  & outputs); 
# 243
__attribute((deprecated)) std::vector< Mat>  finalize(const std::vector< Mat>  & inputs); 
# 248
__attribute((deprecated)) void run(const std::vector< Mat>  & inputs, std::vector< Mat>  & outputs, std::vector< Mat>  & internals); 
# 257
virtual int inputNameToIndex(String inputName); 
# 261
virtual int outputNameToIndex(const String & outputName); 
# 268
virtual bool supportBackend(int backendId); 
# 280 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
virtual Ptr< BackendNode>  initHalide(const std::vector< Ptr< BackendWrapper> >  & inputs); 
# 282
virtual Ptr< BackendNode>  initInfEngine(const std::vector< Ptr< BackendWrapper> >  & inputs); 
# 284
virtual Ptr< BackendNode>  initNgraph(const std::vector< Ptr< BackendWrapper> >  & inputs, const std::vector< Ptr< BackendNode> >  & nodes); 
# 286
virtual Ptr< BackendNode>  initVkCom(const std::vector< Ptr< BackendWrapper> >  & inputs); 
# 295 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
virtual Ptr< BackendNode>  initCUDA(void * context, const std::vector< Ptr< BackendWrapper> >  & inputs, const std::vector< Ptr< BackendWrapper> >  & outputs); 
# 312 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
virtual void applyHalideScheduler(Ptr< BackendNode>  & node, const std::vector< Mat *>  & inputs, const std::vector< Mat>  & outputs, int targetId) const; 
# 326 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
virtual Ptr< BackendNode>  tryAttach(const Ptr< BackendNode>  & node); 
# 334
virtual bool setActivation(const Ptr< ActivationLayer>  & layer); 
# 341
virtual bool tryFuse(Ptr< Layer>  & top); 
# 356 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
virtual void getScaleShift(Mat & scale, Mat & shift) const; 
# 361
virtual void unsetAttached(); 
# 363
virtual bool getMemoryShapes(const std::vector< std::vector< int> >  & inputs, const int requiredOutputs, std::vector< std::vector< int> >  & outputs, std::vector< std::vector< int> >  & internals) const; 
# 367
virtual int64 getFLOPS(const std::vector< std::vector< int> >  &inputs, const std::vector< std::vector< int> >  &
# 368
outputs) const { (void)inputs; (void)outputs; return 0; } 
# 370
String name; 
# 371
String type; 
# 372
int preferableTarget; 
# 374
Layer(); 
# 375
explicit Layer(const LayerParams & params); 
# 376
void setParamsFrom(const LayerParams & params); 
# 377
virtual ~Layer(); 
# 378
}; 
# 390 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
class Net { 
# 394
public: Net(); 
# 395
~Net(); 
# 403
static Net readFromModelOptimizer(const String & xml, const String & bin); 
# 411
static Net readFromModelOptimizer(const std::vector< unsigned char>  & bufferModelConfig, const std::vector< unsigned char>  & bufferWeights); 
# 421 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
static Net readFromModelOptimizer(const uchar * bufferModelConfigPtr, size_t bufferModelConfigSize, const uchar * bufferWeightsPtr, size_t bufferWeightsSize); 
# 425
bool empty() const; 
# 431
String dump(); 
# 436
void dumpToFile(const String & path); 
# 443
int addLayer(const String & name, const String & type, LayerParams & params); 
# 447
int addLayerToPrev(const String & name, const String & type, LayerParams & params); 
# 452
int getLayerId(const String & layer); 
# 454
std::vector< std::__cxx11::basic_string< char> >  getLayerNames() const; 
# 457
typedef DictValue LayerId; 
# 460
Ptr< Layer>  getLayer(LayerId layerId); 
# 463
std::vector< Ptr< Layer> >  getLayerInputs(LayerId layerId); 
# 478 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void connect(String outPin, String inpPin); 
# 486
void connect(int outLayerId, int outNum, int inpLayerId, int inpNum); 
# 495 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void setInputsNames(const std::vector< std::__cxx11::basic_string< char> >  & inputBlobNames); 
# 502
Mat forward(const String & outputName = String()); 
# 511 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
AsyncArray forwardAsync(const String & outputName = String()); 
# 518
void forward(OutputArrayOfArrays outputBlobs, const String & outputName = String()); 
# 524
void forward(OutputArrayOfArrays outputBlobs, const std::vector< std::__cxx11::basic_string< char> >  & outBlobNames); 
# 531
void forward(std::vector< std::vector< Mat> >  & outputBlobs, const std::vector< std::__cxx11::basic_string< char> >  & outBlobNames); 
# 543 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void setHalideScheduler(const String & scheduler); 
# 553 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void setPreferableBackend(int backendId); 
# 571 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void setPreferableTarget(int targetId); 
# 584 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void setInput(InputArray blob, const String & name = "", double scalefactor = (1.0), const Scalar & mean = Scalar()); 
# 595 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void setParam(LayerId layer, int numParam, const Mat & blob); 
# 602
Mat getParam(LayerId layer, int numParam = 0); 
# 606
std::vector< int>  getUnconnectedOutLayers() const; 
# 610
std::vector< std::__cxx11::basic_string< char> >  getUnconnectedOutLayersNames() const; 
# 621 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void getLayersShapes(const std::vector< std::vector< int> >  & netInputShapes, std::vector< int>  & layersIds, std::vector< std::vector< std::vector< int> > >  & inLayersShapes, std::vector< std::vector< std::vector< int> > >  & outLayersShapes) const; 
# 627
void getLayersShapes(const MatShape & netInputShape, std::vector< int>  & layersIds, std::vector< std::vector< std::vector< int> > >  & inLayersShapes, std::vector< std::vector< std::vector< int> > >  & outLayersShapes) const; 
# 641 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void getLayerShapes(const MatShape & netInputShape, const int layerId, std::vector< std::vector< int> >  & inLayerShapes, std::vector< std::vector< int> >  & outLayerShapes) const; 
# 647
void getLayerShapes(const std::vector< std::vector< int> >  & netInputShapes, const int layerId, std::vector< std::vector< int> >  & inLayerShapes, std::vector< std::vector< int> >  & outLayerShapes) const; 
# 656
int64 getFLOPS(const std::vector< std::vector< int> >  & netInputShapes) const; 
# 658
int64 getFLOPS(const MatShape & netInputShape) const; 
# 660
int64 getFLOPS(const int layerId, const std::vector< std::vector< int> >  & netInputShapes) const; 
# 663
int64 getFLOPS(const int layerId, const MatShape & netInputShape) const; 
# 669
void getLayerTypes(std::vector< std::__cxx11::basic_string< char> >  & layersTypes) const; 
# 675
int getLayersCount(const String & layerType) const; 
# 683
void getMemoryConsumption(const std::vector< std::vector< int> >  & netInputShapes, size_t & weights, size_t & blobs) const; 
# 686
void getMemoryConsumption(const MatShape & netInputShape, size_t & weights, size_t & blobs) const; 
# 689
void getMemoryConsumption(const int layerId, const std::vector< std::vector< int> >  & netInputShapes, size_t & weights, size_t & blobs) const; 
# 693
void getMemoryConsumption(const int layerId, const MatShape & netInputShape, size_t & weights, size_t & blobs) const; 
# 704 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void getMemoryConsumption(const std::vector< std::vector< int> >  & netInputShapes, std::vector< int>  & layerIds, std::vector< unsigned long>  & weights, std::vector< unsigned long>  & blobs) const; 
# 709
void getMemoryConsumption(const MatShape & netInputShape, std::vector< int>  & layerIds, std::vector< unsigned long>  & weights, std::vector< unsigned long>  & blobs) const; 
# 717
void enableFusion(bool fusion); 
# 725
int64 getPerfProfile(std::vector< double>  & timings); 
# 728
private: struct Impl; 
# 729
Ptr< Impl>  impl; 
# 730
}; 
# 738
Net readNetFromDarknet(const String & cfgFile, const String & darknetModel = String()); 
# 745
Net readNetFromDarknet(const std::vector< unsigned char>  & bufferCfg, const std::vector< unsigned char>  & bufferModel = std::vector< unsigned char> ()); 
# 755 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromDarknet(const char * bufferCfg, size_t lenCfg, const char * bufferModel = 0, size_t lenModel = 0); 
# 763
Net readNetFromCaffe(const String & prototxt, const String & caffeModel = String()); 
# 770
Net readNetFromCaffe(const std::vector< unsigned char>  & bufferProto, const std::vector< unsigned char>  & bufferModel = std::vector< unsigned char> ()); 
# 782 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromCaffe(const char * bufferProto, size_t lenProto, const char * bufferModel = 0, size_t lenModel = 0); 
# 792 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromTensorflow(const String & model, const String & config = String()); 
# 799
Net readNetFromTensorflow(const std::vector< unsigned char>  & bufferModel, const std::vector< unsigned char>  & bufferConfig = std::vector< unsigned char> ()); 
# 810 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromTensorflow(const char * bufferModel, size_t lenModel, const char * bufferConfig = 0, size_t lenConfig = 0); 
# 839 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromTorch(const String & model, bool isBinary = true, bool evaluate = true); 
# 865 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNet(const String & model, const String & config = "", const String & framework = ""); 
# 876 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNet(const String & framework, const std::vector< unsigned char>  & bufferModel, const std::vector< unsigned char>  & bufferConfig = std::vector< unsigned char> ()); 
# 882
Mat readTorchBlob(const String & filename, bool isBinary = true); 
# 892 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromModelOptimizer(const String & xml, const String & bin); 
# 902 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromModelOptimizer(const std::vector< unsigned char>  & bufferModelConfig, const std::vector< unsigned char>  & bufferWeights); 
# 914 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromModelOptimizer(const uchar * bufferModelConfigPtr, size_t bufferModelConfigSize, const uchar * bufferWeightsPtr, size_t bufferWeightsSize); 
# 921
Net readNetFromONNX(const String & onnxFile); 
# 930 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Net readNetFromONNX(const char * buffer, size_t sizeBuffer); 
# 938
Net readNetFromONNX(const std::vector< unsigned char>  & buffer); 
# 944
Mat readTensorFromONNX(const String & path); 
# 962 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Mat blobFromImage(InputArray image, double scalefactor = (1.0), const Size & size = Size(), const Scalar & mean = Scalar(), bool swapRB = false, bool crop = false, int ddepth = 5); 
# 970
void blobFromImage(InputArray image, OutputArray blob, double scalefactor = (1.0), const Size & size = Size(), const Scalar & mean = Scalar(), bool swapRB = false, bool crop = false, int ddepth = 5); 
# 992 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
Mat blobFromImages(InputArrayOfArrays images, double scalefactor = (1.0), Size size = Size(), const Scalar & mean = Scalar(), bool swapRB = false, bool crop = false, int ddepth = 5); 
# 1000
void blobFromImages(InputArrayOfArrays images, OutputArray blob, double scalefactor = (1.0), Size size = Size(), const Scalar & mean = Scalar(), bool swapRB = false, bool crop = false, int ddepth = 5); 
# 1013 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void imagesFromBlob(const Mat & blob_, OutputArrayOfArrays images_); 
# 1028 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void shrinkCaffeModel(const String & src, const String & dst, const std::vector< std::__cxx11::basic_string< char> >  & layersTypes = std::vector< std::__cxx11::basic_string< char> > ()); 
# 1037
void writeTextGraph(const String & model, const String & output); 
# 1049 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void NMSBoxes(const std::vector< Rect_< int> >  & bboxes, const std::vector< float>  & scores, const float score_threshold, const float nms_threshold, std::vector< int>  & indices, const float eta = (1.0F), const int top_k = 0); 
# 1054
void NMSBoxes(const std::vector< Rect_< double> >  & bboxes, const std::vector< float>  & scores, const float score_threshold, const float nms_threshold, std::vector< int>  & indices, const float eta = (1.0F), const int top_k = 0); 
# 1059
void NMSBoxes(const std::vector< RotatedRect>  & bboxes, const std::vector< float>  & scores, const float score_threshold, const float nms_threshold, std::vector< int>  & indices, const float eta = (1.0F), const int top_k = 0); 
# 1071 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
class Model : public Net { 
# 1077
public: Model(); 
# 1085
Model(const String & model, const String & config = ""); 
# 1091
Model(const Net & network); 
# 1097
Model &setInputSize(const Size & size); 
# 1105
Model &setInputSize(int width, int height); 
# 1110
Model &setInputMean(const Scalar & mean); 
# 1115
Model &setInputScale(double scale); 
# 1120
Model &setInputCrop(bool crop); 
# 1125
Model &setInputSwapRB(bool swapRB); 
# 1135 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void setInputParams(double scale = (1.0), const Size & size = Size(), const Scalar & mean = Scalar(), bool swapRB = false, bool crop = false); 
# 1142
void predict(InputArray frame, OutputArrayOfArrays outs); 
# 1145
protected: struct Impl; 
# 1146
Ptr< Impl>  impl; 
# 1147
}; 
# 1155
class ClassificationModel : public Model { 
# 1164
public: ClassificationModel(const String & model, const String & config = ""); 
# 1170
ClassificationModel(const Net & network); 
# 1175
std::pair< int, float>  classify(InputArray frame); 
# 1178
void classify(InputArray frame, int & classId, float & conf); 
# 1179
}; 
# 1187
class KeypointsModel : public Model { 
# 1196
public: KeypointsModel(const String & model, const String & config = ""); 
# 1202
KeypointsModel(const Net & network); 
# 1210
std::vector< Point_< float> >  estimate(InputArray frame, float thresh = (0.5)); 
# 1211
}; 
# 1219
class SegmentationModel : public Model { 
# 1228
public: SegmentationModel(const String & model, const String & config = ""); 
# 1234
SegmentationModel(const Net & network); 
# 1240
void segment(InputArray frame, OutputArray mask); 
# 1241
}; 
# 1250 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
class DetectionModel : public Model { 
# 1259
public: DetectionModel(const String & model, const String & config = ""); 
# 1265
DetectionModel(const Net & network); 
# 1275 "/usr/include/opencv4/opencv2/dnn/dnn.hpp" 3
void detect(InputArray frame, std::vector< int>  & classIds, std::vector< float>  & confidences, std::vector< Rect_< int> >  & boxes, float confThreshold = (0.5F), float nmsThreshold = (0.0F)); 
# 1278
}; 
# 1281
}
# 1282
}
# 1283
}
# 46 "/usr/include/opencv4/opencv2/dnn/layer.hpp" 3
namespace cv { 
# 47
namespace dnn { 
# 48
namespace dnn4_v20191202 { 
# 56
class LayerFactory { 
# 61
public: typedef Ptr< Layer>  (*Constructor)(LayerParams & params); 
# 64
static void registerLayer(const String & type, Constructor constructor); 
# 67
static void unregisterLayer(const String & type); 
# 74
static Ptr< Layer>  createLayerInstance(const String & type, LayerParams & params); 
# 77
private: LayerFactory(); 
# 78
}; 
# 82
}
# 83
}
# 84
}
# 47 "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp" 3
namespace cv { 
# 48
namespace dnn { 
# 49
namespace dnn4_v20191202 { 
# 51
template< class TypeIter> DictValue 
# 52
DictValue::arrayInt(TypeIter begin, int size) 
# 53
{ 
# 54
DictValue res(Param::INT, new AutoBuffer< int64, 1UL> (size)); 
# 55
for (int j = 0; j < size; (begin++), (j++)) { 
# 56
((*(res.pi))[j]) = (*begin); }  
# 57
return res; 
# 58
} 
# 60
template< class TypeIter> DictValue 
# 61
DictValue::arrayReal(TypeIter begin, int size) 
# 62
{ 
# 63
DictValue res(Param::REAL, new AutoBuffer< double, 1UL> (size)); 
# 64
for (int j = 0; j < size; (begin++), (j++)) { 
# 65
((*(res.pd))[j]) = (*begin); }  
# 66
return res; 
# 67
} 
# 69
template< class TypeIter> DictValue 
# 70
DictValue::arrayString(TypeIter begin, int size) 
# 71
{ 
# 72
DictValue res(Param::STRING, new AutoBuffer< String, 1UL> (size)); 
# 73
for (int j = 0; j < size; (begin++), (j++)) { 
# 74
((*(res.ps))[j]) = (*begin); }  
# 75
return res; 
# 76
} 
# 79
template<> inline DictValue DictValue::get< DictValue> (int idx) const 
# 80
{ 
# 81
do { if (!(!(idx == (-1)))) { ; } else { cv::error(cv::Error::StsAssert, "idx == -1", __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 81); }  } while (0); 
# 82
return *this; 
# 83
} 
# 86
template<> inline int64 DictValue::get< signed long> (int idx) const 
# 87
{ 
# 88
do { if (!(!(((idx == (-1)) && (this->size() == 1)) || ((idx >= 0) && (idx < this->size()))))) { ; } else { cv::error(cv::Error::StsAssert, "(idx == -1 && size() == 1) || (idx >= 0 && idx < size())", __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 88); }  } while (0); 
# 89
idx = ((idx == (-1)) ? 0 : idx); 
# 91
if ((type) == Param::INT) 
# 92
{ 
# 93
return (*(pi))[idx]; 
# 94
} else { 
# 95
if ((type) == Param::REAL) 
# 96
{ 
# 97
double doubleValue = (*(pd))[idx]; 
# 99
double fracpart, intpart; 
# 100
fracpart = std::modf(doubleValue, &intpart); 
# 101
do { if (!(!(fracpart == (0.0)))) { ; } else { cv::error(cv::Error::StsAssert, "fracpart == 0.0", __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 101); }  } while (0); 
# 103
return (int64)doubleValue; 
# 104
} else { 
# 105
if ((type) == Param::STRING) 
# 106
{ 
# 107
return std::atoi(((*(ps))[idx]).c_str()); 
# 108
} else 
# 110
{ 
# 111
do { if (!(!((this->isInt() || this->isReal()) || this->isString()))) { ; } else { cv::error(cv::Error::StsAssert, "isInt() || isReal() || isString()", __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 111); }  } while (0); 
# 112
return 0; 
# 113
}  }  }  
# 114
} 
# 117
template<> inline int DictValue::get< int> (int idx) const 
# 118
{ 
# 119
return (int)this->get< signed long> (idx); 
# 120
} 
# 122
inline int DictValue::getIntValue(int idx) const 
# 123
{ 
# 124
return (int)this->get< signed long> (idx); 
# 125
} 
# 128
template<> inline unsigned DictValue::get< unsigned> (int idx) const 
# 129
{ 
# 130
return (unsigned)this->get< signed long> (idx); 
# 131
} 
# 134
template<> inline bool DictValue::get< bool> (int idx) const 
# 135
{ 
# 136
return (this->get< signed long> (idx) != (0)); 
# 137
} 
# 140
template<> inline double DictValue::get< double> (int idx) const 
# 141
{ 
# 142
do { if (!(!(((idx == (-1)) && (this->size() == 1)) || ((idx >= 0) && (idx < this->size()))))) { ; } else { cv::error(cv::Error::StsAssert, "(idx == -1 && size() == 1) || (idx >= 0 && idx < size())", __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 142); }  } while (0); 
# 143
idx = ((idx == (-1)) ? 0 : idx); 
# 145
if ((type) == Param::REAL) 
# 146
{ 
# 147
return (*(pd))[idx]; 
# 148
} else { 
# 149
if ((type) == Param::INT) 
# 150
{ 
# 151
return (double)((*(pi))[idx]); 
# 152
} else { 
# 153
if ((type) == Param::STRING) 
# 154
{ 
# 155
return std::atof(((*(ps))[idx]).c_str()); 
# 156
} else 
# 158
{ 
# 159
do { if (!(!((this->isReal() || this->isInt()) || this->isString()))) { ; } else { cv::error(cv::Error::StsAssert, "isReal() || isInt() || isString()", __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 159); }  } while (0); 
# 160
return 0; 
# 161
}  }  }  
# 162
} 
# 164
inline double DictValue::getRealValue(int idx) const 
# 165
{ 
# 166
return this->get< double> (idx); 
# 167
} 
# 170
template<> inline float DictValue::get< float> (int idx) const 
# 171
{ 
# 172
return (float)this->get< double> (idx); 
# 173
} 
# 176
template<> inline String DictValue::get< std::__cxx11::basic_string< char> > (int idx) const 
# 177
{ 
# 178
do { if (!(!this->isString())) { ; } else { cv::error(cv::Error::StsAssert, "isString()", __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 178); }  } while (0); 
# 179
do { if (!(!(((idx == (-1)) && ((ps)->size() == (1))) || ((idx >= 0) && (idx < ((int)(ps)->size())))))) { ; } else { cv::error(cv::Error::StsAssert, "(idx == -1 && ps->size() == 1) || (idx >= 0 && idx < (int)ps->size())", __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 179); }  } while (0); 
# 180
return (*(ps))[(idx == (-1)) ? 0 : idx]; 
# 181
} 
# 184
inline String DictValue::getStringValue(int idx) const 
# 185
{ 
# 186
return this->get< std::__cxx11::basic_string< char> > (idx); 
# 187
} 
# 189
inline void DictValue::release() 
# 190
{ 
# 191
switch (type) 
# 192
{ 
# 193
case Param::INT:  
# 194
delete (pi); 
# 195
break; 
# 196
case Param::STRING:  
# 197
delete (ps); 
# 198
break; 
# 199
case Param::REAL:  
# 200
delete (pd); 
# 201
break; 
# 202
case Param::BOOLEAN:  
# 203
case Param::MAT:  
# 204
case Param::MAT_VECTOR:  
# 205
case Param::ALGORITHM:  
# 206
case Param::FLOAT:  
# 207
case Param::UNSIGNED_INT:  
# 208
case Param::UINT64:  
# 209
case Param::UCHAR:  
# 210
case Param::SCALAR:  
# 211
break; 
# 212
}  
# 213
} 
# 215
inline DictValue::~DictValue() 
# 216
{ 
# 217
this->release(); 
# 218
} 
# 220
inline DictValue &DictValue::operator=(const DictValue &r) 
# 221
{ 
# 222
if ((&r) == this) { 
# 223
return *this; }  
# 225
if ((r.type) == Param::INT) 
# 226
{ 
# 227
AutoBuffer< signed long, 1UL>  *tmp = new AutoBuffer< signed long, 1UL> (*(r.pi)); 
# 228
this->release(); 
# 229
(pi) = tmp; 
# 230
} else { 
# 231
if ((r.type) == Param::STRING) 
# 232
{ 
# 233
AutoBuffer< std::__cxx11::basic_string< char> , 1UL>  *tmp = new AutoBuffer< std::__cxx11::basic_string< char> , 1UL> (*(r.ps)); 
# 234
this->release(); 
# 235
(ps) = tmp; 
# 236
} else { 
# 237
if ((r.type) == Param::REAL) 
# 238
{ 
# 239
AutoBuffer< double, 1UL>  *tmp = new AutoBuffer< double, 1UL> (*(r.pd)); 
# 240
this->release(); 
# 241
(pd) = tmp; 
# 242
}  }  }  
# 244
(type) = (r.type); 
# 246
return *this; 
# 247
} 
# 249
inline DictValue::DictValue(const DictValue &r) 
# 250
{ 
# 251
(type) = (r.type); 
# 253
if ((r.type) == Param::INT) { 
# 254
(pi) = (new AutoBuffer< signed long, 1UL> (*(r.pi))); } else { 
# 255
if ((r.type) == Param::STRING) { 
# 256
(ps) = (new AutoBuffer< std::__cxx11::basic_string< char> , 1UL> (*(r.ps))); } else { 
# 257
if ((r.type) == Param::REAL) { 
# 258
(pd) = (new AutoBuffer< double, 1UL> (*(r.pd))); }  }  }  
# 259
} 
# 261
inline bool DictValue::isString() const 
# 262
{ 
# 263
return ((type) == Param::STRING); 
# 264
} 
# 266
inline bool DictValue::isInt() const 
# 267
{ 
# 268
return ((type) == Param::INT); 
# 269
} 
# 271
inline bool DictValue::isReal() const 
# 272
{ 
# 273
return (((type) == Param::REAL) || ((type) == Param::INT)); 
# 274
} 
# 276
inline int DictValue::size() const 
# 277
{ 
# 278
switch (type) 
# 279
{ 
# 280
case Param::INT:  
# 281
return (int)(pi)->size(); 
# 282
case Param::STRING:  
# 283
return (int)(ps)->size(); 
# 284
case Param::REAL:  
# 285
return (int)(pd)->size(); 
# 286
case Param::BOOLEAN:  
# 287
case Param::MAT:  
# 288
case Param::MAT_VECTOR:  
# 289
case Param::ALGORITHM:  
# 290
case Param::FLOAT:  
# 291
case Param::UNSIGNED_INT:  
# 292
case Param::UINT64:  
# 293
case Param::UCHAR:  
# 294
case Param::SCALAR:  
# 295
break; 
# 296
}  
# 297
cv::error(Error::StsInternal, cv::format("Unhandled type (%d)", static_cast< int>(type)), __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 297); 
# 298
} 
# 300
inline std::ostream &operator<<(std::ostream &stream, const DictValue &dictv) 
# 301
{ 
# 302
int i; 
# 304
if (dictv.isInt()) 
# 305
{ 
# 306
for (i = 0; i < (dictv.size() - 1); i++) { 
# 307
(((stream << (dictv.get< signed long> (i)))) << (", ")); }  
# 308
(stream << (dictv.get< signed long> (i))); 
# 309
} else { 
# 310
if (dictv.isReal()) 
# 311
{ 
# 312
for (i = 0; i < (dictv.size() - 1); i++) { 
# 313
(((stream << (dictv.get< double> (i)))) << (", ")); }  
# 314
(stream << (dictv.get< double> (i))); 
# 315
} else { 
# 316
if (dictv.isString()) 
# 317
{ 
# 318
for (i = 0; i < (dictv.size() - 1); i++) { 
# 319
(((((stream << ("\""))) << (dictv.get< std::__cxx11::basic_string< char> > (i)))) << ("\", ")); }  
# 320
(stream << (dictv.get< std::__cxx11::basic_string< char> > (i))); 
# 321
}  }  }  
# 323
return stream; 
# 324
} 
# 328
inline bool Dict::has(const String &key) const 
# 329
{ 
# 330
return (dict).count(key) != (0); 
# 331
} 
# 333
inline DictValue *Dict::ptr(const String &key) 
# 334
{ 
# 335
std::map< std::__cxx11::basic_string< char> , DictValue> ::iterator i = (dict).find(key); 
# 336
return (i == ((dict).end())) ? __null : (&(i->second)); 
# 337
} 
# 339
inline const DictValue *Dict::ptr(const String &key) const 
# 340
{ 
# 341
std::map< std::__cxx11::basic_string< char> , DictValue> ::const_iterator i = (dict).find(key); 
# 342
return (i == ((dict).end())) ? __null : (&(i->second)); 
# 343
} 
# 345
inline const DictValue &Dict::get(const String &key) const 
# 346
{ 
# 347
std::map< std::__cxx11::basic_string< char> , DictValue> ::const_iterator i = (dict).find(key); 
# 348
if ((i == ((dict).end()))) { 
# 349
cv::error(Error::StsObjectNotFound, (((("Required argument \"") + key)) + ("\" not found into dictionary")), __func__, "/usr/include/opencv4/opencv2/dnn/dnn.inl.hpp", 349); }  
# 350
return i->second; 
# 351
} 
# 353
template< class T> inline T 
# 354
Dict::get(const String &key) const 
# 355
{ 
# 356
return this->get(key).template get< T> (); 
# 357
} 
# 359
template< class T> inline T 
# 360
Dict::get(const String &key, const T &defaultValue) const 
# 361
{ 
# 362
std::map< String, DictValue> ::const_iterator i = (dict).find(key); 
# 364
if ((i != ((dict).end()))) { 
# 365
return (i->second).template get< T> (); } else { 
# 367
return defaultValue; }  
# 368
} 
# 370
template< class T> inline const T &
# 371
Dict::set(const String &key, const T &value) 
# 372
{ 
# 373
std::map< String, DictValue> ::iterator i = (dict).find(key); 
# 375
if ((i != ((dict).end()))) { 
# 376
((i->second) = ((DictValue)(value))); } else { 
# 378
(dict).insert(std::make_pair(key, ((DictValue)(value)))); }  
# 380
return value; 
# 381
} 
# 383
inline void Dict::erase(const String &key) 
# 384
{ 
# 385
(dict).erase(key); 
# 386
} 
# 388
inline std::ostream &operator<<(std::ostream &stream, const Dict &dict) 
# 389
{ 
# 390
std::map< std::__cxx11::basic_string< char> , DictValue> ::const_iterator it; 
# 391
for (it = (dict.dict).begin(); (it != ((dict.dict).end())); it++) { 
# 392
(((((((stream << (it->first))) << (" : "))) << (it->second))) << ("\n")); }  
# 394
return stream; 
# 395
} 
# 397
inline std::map< std::__cxx11::basic_string< char> , DictValue> ::const_iterator Dict::begin() const 
# 398
{ 
# 399
return (dict).begin(); 
# 400
} 
# 402
inline std::map< std::__cxx11::basic_string< char> , DictValue> ::const_iterator Dict::end() const 
# 403
{ 
# 404
return (dict).end(); 
# 405
} 
# 407
}
# 408
}
# 409
}
# 13 "/usr/include/opencv4/opencv2/dnn/utils/inference_engine.hpp" 3
namespace cv { namespace dnn { 
# 14
namespace dnn4_v20191202 { 
# 27 "/usr/include/opencv4/opencv2/dnn/utils/inference_engine.hpp" 3
String getInferenceEngineBackendType(); 
# 35
String setInferenceEngineBackendType(const String & newBackendType); 
# 43
void resetMyriadDevice(); 
# 58 "/usr/include/opencv4/opencv2/dnn/utils/inference_engine.hpp" 3
String getInferenceEngineVPUType(); 
# 61
}
# 62
}}
# 38 "/usr/include/opencv4/opencv2/flann/general.h" 3
namespace cvflann { 
# 41
class FLANNException : public cv::Exception { 
# 44
public: FLANNException(const char *message) : cv::Exception(0, message, "", "/usr/include/opencv4/opencv2/flann/general.h", 44) { } 
# 46
FLANNException(const cv::String &message) : cv::Exception(0, message, "", "/usr/include/opencv4/opencv2/flann/general.h", 46) { } 
# 47
}; 
# 49
}
# 40 "/usr/include/opencv4/opencv2/flann/matrix.h" 3
namespace cvflann { 
# 47
template< class T> 
# 48
class Matrix { 
# 51
public: typedef T type; 
# 53
size_t rows; 
# 54
size_t cols; 
# 55
size_t stride; 
# 56
T *data; 
# 58
Matrix() : rows((0)), cols((0)), stride((0)), data((__null)) 
# 59
{ 
# 60
} 
# 62
Matrix(T *data_, size_t rows_, size_t cols_, size_t stride_ = 0) : rows(rows_), cols(cols_), stride(stride_), data(data_) 
# 64
{ 
# 65
if ((stride) == (0)) { (stride) = (cols); }  
# 66
} 
# 71
__attribute((deprecated)) void free() 
# 72
{ 
# 73
fprintf(stderr, "The cvflann::Matrix<T>::free() method is deprecated and it does not do any memory deallocation any more.  You areresponsible for" " deallocating the matrix memory (by doing\'delete[] matrix.data\' for example)"); 
# 77
} 
# 82
T *operator[](size_t index) const 
# 83
{ 
# 84
return (data) + (index * (stride)); 
# 85
} 
# 86
}; 
# 89
class UntypedMatrix { 
# 92
public: size_t rows; 
# 93
size_t cols; 
# 94
void *data; 
# 95
flann_datatype_t type; 
# 97
UntypedMatrix(void *data_, long rows_, long cols_) : rows(rows_), cols(cols_), data(data_) 
# 99
{ 
# 100
} 
# 102
~UntypedMatrix() 
# 103
{ 
# 104
} 
# 107
template< class T> Matrix< T>  
# 108
as() 
# 109
{ 
# 110
return Matrix< T> ((T *)(data), rows, cols); 
# 111
} 
# 112
}; 
# 116
}
# 22 "/usr/include/opencv4/opencv2/flann/any.h" 3
namespace cvflann { 
# 25
namespace anyimpl { 
# 28
struct bad_any_cast { 
# 30
}; 
# 32
struct empty_any { 
# 34
}; 
# 36
inline std::ostream &operator<<(std::ostream &out, const empty_any &) 
# 37
{ 
# 38
(out << ("[empty_any]")); 
# 39
return out; 
# 40
} 
# 42
struct base_any_policy { 
# 44
virtual void static_delete(void ** x) = 0; 
# 45
virtual void copy_from_value(const void * src, void ** dest) = 0; 
# 46
virtual void clone(void *const * src, void ** dest) = 0; 
# 47
virtual void move(void *const * src, void ** dest) = 0; 
# 48
virtual void *get_value(void ** src) = 0; 
# 49
virtual const void *get_value(void *const * src) = 0; 
# 50
virtual size_t get_size() = 0; 
# 51
virtual const std::type_info &type() = 0; 
# 52
virtual void print(std::ostream & out, void *const * src) = 0; 
# 53
virtual ~base_any_policy() { } 
# 54
}; 
# 56
template< class T> 
# 57
struct typed_base_any_policy : public base_any_policy { 
# 59
virtual size_t get_size() override { return sizeof(T); } 
# 60
virtual const std::type_info &type() override { return typeid(T); } 
# 62
}; 
# 64
template< class T> 
# 65
struct small_any_policy __final : public typed_base_any_policy< T>  { 
# 67
virtual void static_delete(void **) override { } 
# 68
virtual void copy_from_value(const void *src, void **dest) override 
# 69
{ 
# 70
new (dest) T(*(reinterpret_cast< const T *>(src))); 
# 71
} 
# 72
virtual void clone(void *const *src, void **dest) override { (*dest) = (*src); } 
# 73
virtual void move(void *const *src, void **dest) override { (*dest) = (*src); } 
# 74
virtual void *get_value(void **src) override { return reinterpret_cast< void *>(src); } 
# 75
virtual const void *get_value(void *const *src) override { return reinterpret_cast< const void *>(src); } 
# 76
virtual void print(std::ostream &out, void *const *src) override { out << (*(reinterpret_cast< const T *>(src))); } 
# 77
}; 
# 79
template< class T> 
# 80
struct big_any_policy __final : public typed_base_any_policy< T>  { 
# 82
virtual void static_delete(void **x) override 
# 83
{ 
# 84
if (*x) { delete (*(reinterpret_cast< T **>(x))); }  
# 85
(*x) = (__null); 
# 86
} 
# 87
virtual void copy_from_value(const void *src, void **dest) override 
# 88
{ 
# 89
(*dest) = (new T(*(reinterpret_cast< const T *>(src)))); 
# 90
} 
# 91
virtual void clone(void *const *src, void **dest) override 
# 92
{ 
# 93
(*dest) = (new T(*(*(reinterpret_cast< T *const *>(src))))); 
# 94
} 
# 95
virtual void move(void *const *src, void **dest) override 
# 96
{ 
# 97
(*(reinterpret_cast< T **>(dest)))->~T(); 
# 98
(*(*(reinterpret_cast< T **>(dest)))) = (*(*(reinterpret_cast< T *const *>(src)))); 
# 99
} 
# 100
virtual void *get_value(void **src) override { return *src; } 
# 101
virtual const void *get_value(void *const *src) override { return *src; } 
# 102
virtual void print(std::ostream &out, void *const *src) override { out << (*(reinterpret_cast< const T *>(*src))); } 
# 103
}; 
# 105
template<> inline void big_any_policy< flann_centers_init_t> ::print(std::ostream &out, void *const *src) 
# 106
{ 
# 107
(out << ((int)(*(reinterpret_cast< const flann_centers_init_t *>(*src))))); 
# 108
} 
# 110
template<> inline void big_any_policy< flann_algorithm_t> ::print(std::ostream &out, void *const *src) 
# 111
{ 
# 112
(out << ((int)(*(reinterpret_cast< const flann_algorithm_t *>(*src))))); 
# 113
} 
# 115
template<> inline void big_any_policy< std::__cxx11::basic_string< char> > ::print(std::ostream &out, void *const *src) 
# 116
{ 
# 117
(out << ((*(reinterpret_cast< const cv::String *>(*src))).c_str())); 
# 118
} 
# 120
template< class T> 
# 121
struct choose_policy { 
# 123
typedef big_any_policy< T>  type; 
# 124
}; 
# 126
template< class T> 
# 127
struct choose_policy< T *>  { 
# 129
typedef small_any_policy< T *>  type; 
# 130
}; 
# 132
struct any; 
# 137
template<> struct choose_policy< any>  { 
# 139
typedef void type; 
# 140
}; 
# 148
template<> struct choose_policy< signed char>  { typedef small_any_policy< signed char>  type; }; 
# 149
template<> struct choose_policy< unsigned char>  { typedef small_any_policy< unsigned char>  type; }; 
# 150
template<> struct choose_policy< signed short>  { typedef small_any_policy< signed short>  type; }; 
# 151
template<> struct choose_policy< unsigned short>  { typedef small_any_policy< unsigned short>  type; }; 
# 152
template<> struct choose_policy< signed int>  { typedef small_any_policy< signed int>  type; }; 
# 153
template<> struct choose_policy< unsigned>  { typedef small_any_policy< unsigned>  type; }; 
# 154
template<> struct choose_policy< signed long>  { typedef small_any_policy< signed long>  type; }; 
# 155
template<> struct choose_policy< unsigned long>  { typedef small_any_policy< unsigned long>  type; }; 
# 156
template<> struct choose_policy< float>  { typedef small_any_policy< float>  type; }; 
# 157
template<> struct choose_policy< bool>  { typedef small_any_policy< bool>  type; }; 
# 161
template< class T> 
# 162
class SinglePolicy { 
# 164
SinglePolicy(); 
# 165
SinglePolicy(const SinglePolicy & other); 
# 166
SinglePolicy &operator=(const SinglePolicy & other); 
# 169
public: static inline base_any_policy *get_policy(); 
# 172
private: static typename choose_policy< T> ::type policy; 
# 173
}; 
# 175
template< class T> typename choose_policy< T> ::type 
# 176
SinglePolicy< T> ::policy; 
# 179
template< class T> inline base_any_policy *
# 180
SinglePolicy< T> ::get_policy() { return &policy; } 
# 182
}
# 184
struct any { 
# 188
private: anyimpl::base_any_policy *policy; 
# 189
void *object; 
# 194
public: 
# 193
template< class T> 
# 194
any(const T &x) : policy(anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy()), object((__null)) 
# 196
{ 
# 197
assign(x); 
# 198
} 
# 201
any() : policy(anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy()), object((__null)) 
# 203
{ } 
# 206
any(const char *x) : policy(anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy()), object((__null)) 
# 208
{ 
# 209
this->assign(x); 
# 210
} 
# 213
any(const any &x) : policy(anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy()), object((__null)) 
# 215
{ 
# 216
this->assign(x); 
# 217
} 
# 220
~any() 
# 221
{ 
# 222
(policy)->static_delete(&(object)); 
# 223
} 
# 226
any &assign(const any &x) 
# 227
{ 
# 228
this->reset(); 
# 229
(policy) = (x.policy); 
# 230
(policy)->clone(&(x.object), &(object)); 
# 231
return *this; 
# 232
} 
# 235
template< class T> any &
# 236
assign(const T &x) 
# 237
{ 
# 238
this->reset(); 
# 239
(policy) = anyimpl::template SinglePolicy< T> ::get_policy(); 
# 240
(policy)->copy_from_value(&x, &(object)); 
# 241
return *this; 
# 242
} 
# 245
template< class T> any &
# 246
operator=(const T &x) 
# 247
{ 
# 248
return assign(x); 
# 249
} 
# 252
any &operator=(const any &x) 
# 253
{ 
# 254
return this->assign(x); 
# 255
} 
# 259
any &operator=(const char *x) 
# 260
{ 
# 261
return this->assign(x); 
# 262
} 
# 265
any &swap(any &x) 
# 266
{ 
# 267
std::swap(policy, x.policy); 
# 268
std::swap(object, x.object); 
# 269
return *this; 
# 270
} 
# 273
template< class T> T &
# 274
cast() 
# 275
{ 
# 276
if ((((policy)->type()) != (typeid(T)))) { throw anyimpl::bad_any_cast(); }  
# 277
T *r = reinterpret_cast< T *>((policy)->get_value(&(object))); 
# 278
return *r; 
# 279
} 
# 282
template< class T> const T &
# 283
cast() const 
# 284
{ 
# 285
if ((((policy)->type()) != (typeid(T)))) { throw anyimpl::bad_any_cast(); }  
# 286
const T *r = reinterpret_cast< const T *>((policy)->get_value(&(object))); 
# 287
return *r; 
# 288
} 
# 291
bool empty() const 
# 292
{ 
# 293
return (((policy)->type()) == (typeid(anyimpl::empty_any))); 
# 294
} 
# 297
void reset() 
# 298
{ 
# 299
(policy)->static_delete(&(object)); 
# 300
(policy) = anyimpl::SinglePolicy< anyimpl::empty_any> ::get_policy(); 
# 301
} 
# 304
bool compatible(const any &x) const 
# 305
{ 
# 306
return (((policy)->type()) == ((x.policy)->type())); 
# 307
} 
# 310
template< class T> bool 
# 311
has_type() 
# 312
{ 
# 313
return (((policy)->type()) == (typeid(T))); 
# 314
} 
# 316
const std::type_info &type() const 
# 317
{ 
# 318
return (policy)->type(); 
# 319
} 
# 321
friend inline std::ostream &operator<<(std::ostream & out, const any & any_val); 
# 322
}; 
# 324
inline std::ostream &operator<<(std::ostream &out, const any &any_val) 
# 325
{ 
# 326
(any_val.policy)->print(out, &(any_val.object)); 
# 327
return out; 
# 328
} 
# 330
}
# 41 "/usr/include/opencv4/opencv2/flann/params.h" 3
namespace cvflann { 
# 44
typedef std::map< std::__cxx11::basic_string< char> , any>  IndexParams; 
# 46
struct SearchParams : public IndexParams { 
# 48
SearchParams(int checks = 32, float eps = 0, bool sorted = true) 
# 49
{ 
# 51
(((*this)["checks"]) = checks); 
# 53
(((*this)["eps"]) = eps); 
# 55
(((*this)["sorted"]) = sorted); 
# 56
} 
# 57
}; 
# 60
template< class T> T 
# 61
get_param(const IndexParams &params, cv::String name, const T &default_value) 
# 62
{ 
# 63
std::map< cv::String, any> ::const_iterator it = params.find(name); 
# 64
if ((it != (params.end()))) { 
# 65
return (it->second).template cast< T> (); 
# 66
} else 
# 67
{ 
# 68
return default_value; 
# 69
}  
# 70
} 
# 72
template< class T> T 
# 73
get_param(const IndexParams &params, cv::String name) 
# 74
{ 
# 75
std::map< cv::String, any> ::const_iterator it = params.find(name); 
# 76
if ((it != (params.end()))) { 
# 77
return (it->second).template cast< T> (); 
# 78
} else 
# 79
{ 
# 80
throw ((FLANNException)((((((std::__cxx11::basic_string< char> )("Missing parameter \'")) + name)) + ((std::__cxx11::basic_string< char> )("\' in the parameters given"))))); 
# 81
}  
# 82
} 
# 84
inline void print_params(const IndexParams &params, std::ostream &stream) 
# 85
{ 
# 86
std::map< std::__cxx11::basic_string< char> , any> ::const_iterator it; 
# 88
for (it = params.begin(); (it != (params.end())); (++it)) { 
# 89
(((((((stream << (it->first))) << (" : "))) << (it->second))) << (std::endl)); 
# 90
}  
# 91
} 
# 93
inline void print_params(const IndexParams &params) 
# 94
{ 
# 95
print_params(params, std::cout); 
# 96
} 
# 98
}
# 64 "/usr/include/c++/9/bits/stl_set.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 69
template< class _Key, class _Compare, class _Alloc> class multiset; 
# 92 "/usr/include/c++/9/bits/stl_set.h" 3
template< class _Key, class _Compare = less< _Key> , class 
# 93
_Alloc = allocator< _Key> > 
# 94
class set { 
# 108 "/usr/include/c++/9/bits/stl_set.h" 3
static_assert((is_same< typename remove_cv< _Key> ::type, _Key> ::value), "std::set must have a non-const, non-volatile value_type");
# 120
public: typedef _Key key_type; 
# 121
typedef _Key value_type; 
# 122
typedef _Compare key_compare; 
# 123
typedef _Compare value_compare; 
# 124
typedef _Alloc allocator_type; 
# 129
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other _Key_alloc_type; 
# 132
typedef _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type>  _Rep_type; 
# 133
_Rep_type _M_t; 
# 135
typedef __gnu_cxx::__alloc_traits< _Key_alloc_type>  _Alloc_traits; 
# 140
public: typedef typename __gnu_cxx::__alloc_traits< _Key_alloc_type> ::pointer pointer; 
# 141
typedef typename __gnu_cxx::__alloc_traits< _Key_alloc_type> ::const_pointer const_pointer; 
# 142
typedef typename __gnu_cxx::__alloc_traits< _Key_alloc_type> ::reference reference; 
# 143
typedef typename __gnu_cxx::__alloc_traits< _Key_alloc_type> ::const_reference const_reference; 
# 147
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::const_iterator iterator; 
# 148
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::const_iterator const_iterator; 
# 149
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::const_reverse_iterator reverse_iterator; 
# 150
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::const_reverse_iterator const_reverse_iterator; 
# 151
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::size_type size_type; 
# 152
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::difference_type difference_type; 
# 167 "/usr/include/c++/9/bits/stl_set.h" 3
set() = default;
# 176
explicit set(const _Compare &__comp, const allocator_type &
# 177
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 178
{ } 
# 190 "/usr/include/c++/9/bits/stl_set.h" 3
template< class _InputIterator> 
# 191
set(_InputIterator __first, _InputIterator __last) : _M_t() 
# 193
{ (_M_t)._M_insert_range_unique(__first, __last); } 
# 207 "/usr/include/c++/9/bits/stl_set.h" 3
template< class _InputIterator> 
# 208
set(_InputIterator __first, _InputIterator __last, const _Compare &
# 209
__comp, const allocator_type &
# 210
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 212
{ (_M_t)._M_insert_range_unique(__first, __last); } 
# 223 "/usr/include/c++/9/bits/stl_set.h" 3
set(const set &) = default;
# 231
set(set &&) = default;
# 243 "/usr/include/c++/9/bits/stl_set.h" 3
set(initializer_list< value_type>  __l, const _Compare &
# 244
__comp = _Compare(), const allocator_type &
# 245
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 247
{ (_M_t)._M_insert_range_unique(__l.begin(), __l.end()); } 
# 251
explicit set(const allocator_type &__a) : _M_t((_Key_alloc_type)__a) 
# 252
{ } 
# 255
set(const set &__x, const allocator_type &__a) : _M_t(__x._M_t, (_Key_alloc_type)__a) 
# 256
{ } 
# 259
set(set &&__x, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare> ::value && _Alloc_traits::_S_always_equal()) : _M_t(std::move(__x._M_t), (_Key_alloc_type)__a) 
# 262
{ } 
# 265
set(initializer_list< value_type>  __l, const allocator_type &__a) : _M_t((_Key_alloc_type)__a) 
# 267
{ (_M_t)._M_insert_range_unique(__l.begin(), __l.end()); } 
# 270
template< class _InputIterator> 
# 271
set(_InputIterator __first, _InputIterator __last, const allocator_type &
# 272
__a) : _M_t((_Key_alloc_type)__a) 
# 274
{ (_M_t)._M_insert_range_unique(__first, __last); } 
# 281
~set() = default;
# 298 "/usr/include/c++/9/bits/stl_set.h" 3
set &operator=(const set &) = default;
# 302
set &operator=(set &&) = default;
# 316 "/usr/include/c++/9/bits/stl_set.h" 3
set &operator=(initializer_list< value_type>  __l) 
# 317
{ 
# 318
(_M_t)._M_assign_unique(__l.begin(), __l.end()); 
# 319
return *this; 
# 320
} 
# 327
key_compare key_comp() const 
# 328
{ return (_M_t).key_comp(); } 
# 331
value_compare value_comp() const 
# 332
{ return (_M_t).key_comp(); } 
# 335
allocator_type get_allocator() const noexcept 
# 336
{ return (allocator_type)(_M_t).get_allocator(); } 
# 344
iterator begin() const noexcept 
# 345
{ return (_M_t).begin(); } 
# 353
iterator end() const noexcept 
# 354
{ return (_M_t).end(); } 
# 362
reverse_iterator rbegin() const noexcept 
# 363
{ return (_M_t).rbegin(); } 
# 371
reverse_iterator rend() const noexcept 
# 372
{ return (_M_t).rend(); } 
# 381
iterator cbegin() const noexcept 
# 382
{ return (_M_t).begin(); } 
# 390
iterator cend() const noexcept 
# 391
{ return (_M_t).end(); } 
# 399
reverse_iterator crbegin() const noexcept 
# 400
{ return (_M_t).rbegin(); } 
# 408
reverse_iterator crend() const noexcept 
# 409
{ return (_M_t).rend(); } 
# 414
bool empty() const noexcept 
# 415
{ return (_M_t).empty(); } 
# 419
size_type size() const noexcept 
# 420
{ return (_M_t).size(); } 
# 424
size_type max_size() const noexcept 
# 425
{ return (_M_t).max_size(); } 
# 441 "/usr/include/c++/9/bits/stl_set.h" 3
void swap(set &__x) noexcept(__is_nothrow_swappable< _Compare> ::value) 
# 443
{ (_M_t).swap(__x._M_t); } 
# 460 "/usr/include/c++/9/bits/stl_set.h" 3
template< class ..._Args> pair< iterator, bool>  
# 462
emplace(_Args &&...__args) 
# 463
{ return (_M_t)._M_emplace_unique(std::forward< _Args> (__args)...); } 
# 486 "/usr/include/c++/9/bits/stl_set.h" 3
template< class ..._Args> iterator 
# 488
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 489
{ 
# 490
return (_M_t)._M_emplace_hint_unique(__pos, std::forward< _Args> (__args)...); 
# 492
} 
# 509 "/usr/include/c++/9/bits/stl_set.h" 3
pair< iterator, bool>  insert(const value_type &__x) 
# 510
{ 
# 511
pair< typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::iterator, bool>  __p = (_M_t)._M_insert_unique(__x); 
# 513
return pair< iterator, bool> ((__p.first), (__p.second)); 
# 514
} 
# 518
pair< iterator, bool>  insert(value_type &&__x) 
# 519
{ 
# 520
pair< typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::iterator, bool>  __p = (_M_t)._M_insert_unique(std::move(__x)); 
# 522
return pair< iterator, bool> ((__p.first), (__p.second)); 
# 523
} 
# 546 "/usr/include/c++/9/bits/stl_set.h" 3
iterator insert(const_iterator __position, const value_type &__x) 
# 547
{ return (_M_t)._M_insert_unique_(__position, __x); } 
# 551
iterator insert(const_iterator __position, value_type &&__x) 
# 552
{ return (_M_t)._M_insert_unique_(__position, std::move(__x)); } 
# 564 "/usr/include/c++/9/bits/stl_set.h" 3
template< class _InputIterator> void 
# 566
insert(_InputIterator __first, _InputIterator __last) 
# 567
{ (_M_t)._M_insert_range_unique(__first, __last); } 
# 578 "/usr/include/c++/9/bits/stl_set.h" 3
void insert(initializer_list< value_type>  __l) 
# 579
{ this->insert(__l.begin(), __l.end()); } 
# 652 "/usr/include/c++/9/bits/stl_set.h" 3
__attribute((__abi_tag__("cxx11"))) iterator 
# 654
erase(const_iterator __position) 
# 655
{ return (_M_t).erase(__position); } 
# 684 "/usr/include/c++/9/bits/stl_set.h" 3
size_type erase(const key_type &__x) 
# 685
{ return (_M_t).erase(__x); } 
# 704 "/usr/include/c++/9/bits/stl_set.h" 3
__attribute((__abi_tag__("cxx11"))) iterator 
# 706
erase(const_iterator __first, const_iterator __last) 
# 707
{ return (_M_t).erase(__first, __last); } 
# 733 "/usr/include/c++/9/bits/stl_set.h" 3
void clear() noexcept 
# 734
{ (_M_t).clear(); } 
# 748 "/usr/include/c++/9/bits/stl_set.h" 3
size_type count(const key_type &__x) const 
# 749
{ return ((_M_t).find(__x) == (_M_t).end()) ? 0 : 1; } 
# 752
template< class _Kt> auto 
# 754
count(const _Kt &__x) const->__decltype(((_M_t)._M_count_tr(__x))) 
# 756
{ return (_M_t)._M_count_tr(__x); } 
# 794 "/usr/include/c++/9/bits/stl_set.h" 3
iterator find(const key_type &__x) 
# 795
{ return (_M_t).find(__x); } 
# 798
const_iterator find(const key_type &__x) const 
# 799
{ return (_M_t).find(__x); } 
# 802
template< class _Kt> auto 
# 804
find(const _Kt &__x)->__decltype((iterator{(_M_t)._M_find_tr(__x)})) 
# 806
{ return iterator{(_M_t)._M_find_tr(__x)}; } 
# 808
template< class _Kt> auto 
# 810
find(const _Kt &__x) const->__decltype((const_iterator{(_M_t)._M_find_tr(__x)})) 
# 812
{ return const_iterator{(_M_t)._M_find_tr(__x)}; } 
# 829 "/usr/include/c++/9/bits/stl_set.h" 3
iterator lower_bound(const key_type &__x) 
# 830
{ return (_M_t).lower_bound(__x); } 
# 833
const_iterator lower_bound(const key_type &__x) const 
# 834
{ return (_M_t).lower_bound(__x); } 
# 837
template< class _Kt> auto 
# 839
lower_bound(const _Kt &__x)->__decltype(((iterator)(_M_t)._M_lower_bound_tr(__x))) 
# 841
{ return (iterator)(_M_t)._M_lower_bound_tr(__x); } 
# 843
template< class _Kt> auto 
# 845
lower_bound(const _Kt &__x) const->__decltype(((const_iterator)(_M_t)._M_lower_bound_tr(__x))) 
# 847
{ return (const_iterator)(_M_t)._M_lower_bound_tr(__x); } 
# 859 "/usr/include/c++/9/bits/stl_set.h" 3
iterator upper_bound(const key_type &__x) 
# 860
{ return (_M_t).upper_bound(__x); } 
# 863
const_iterator upper_bound(const key_type &__x) const 
# 864
{ return (_M_t).upper_bound(__x); } 
# 867
template< class _Kt> auto 
# 869
upper_bound(const _Kt &__x)->__decltype(((iterator)(_M_t)._M_upper_bound_tr(__x))) 
# 871
{ return (iterator)(_M_t)._M_upper_bound_tr(__x); } 
# 873
template< class _Kt> auto 
# 875
upper_bound(const _Kt &__x) const->__decltype(((iterator)(_M_t)._M_upper_bound_tr(__x))) 
# 877
{ return (const_iterator)(_M_t)._M_upper_bound_tr(__x); } 
# 898 "/usr/include/c++/9/bits/stl_set.h" 3
pair< iterator, iterator>  equal_range(const key_type &__x) 
# 899
{ return (_M_t).equal_range(__x); } 
# 902
pair< iterator, iterator>  equal_range(const key_type &__x) const 
# 903
{ return (_M_t).equal_range(__x); } 
# 906
template< class _Kt> auto 
# 908
equal_range(const _Kt &__x)->__decltype((((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))))) 
# 910
{ return ((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))); } 
# 912
template< class _Kt> auto 
# 914
equal_range(const _Kt &__x) const->__decltype((((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))))) 
# 916
{ return ((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))); } 
# 920
template< class _K1, class _C1, class _A1> friend bool operator==(const std::set< _K1, _C1, _A1>  &, const std::set< _K1, _C1, _A1>  &); 
# 924
template< class _K1, class _C1, class _A1> friend bool operator<(const std::set< _K1, _C1, _A1>  &, const std::set< _K1, _C1, _A1>  &); 
# 927
}; 
# 977 "/usr/include/c++/9/bits/stl_set.h" 3
template< class _Key, class _Compare, class _Alloc> inline bool 
# 979
operator==(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 980
__y) 
# 981
{ return (__x._M_t) == (__y._M_t); } 
# 994 "/usr/include/c++/9/bits/stl_set.h" 3
template< class _Key, class _Compare, class _Alloc> inline bool 
# 996
operator<(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 997
__y) 
# 998
{ return (__x._M_t) < (__y._M_t); } 
# 1001
template< class _Key, class _Compare, class _Alloc> inline bool 
# 1003
operator!=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 1004
__y) 
# 1005
{ return !(__x == __y); } 
# 1008
template< class _Key, class _Compare, class _Alloc> inline bool 
# 1010
operator>(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 1011
__y) 
# 1012
{ return __y < __x; } 
# 1015
template< class _Key, class _Compare, class _Alloc> inline bool 
# 1017
operator<=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 1018
__y) 
# 1019
{ return !(__y < __x); } 
# 1022
template< class _Key, class _Compare, class _Alloc> inline bool 
# 1024
operator>=(const set< _Key, _Compare, _Alloc>  &__x, const set< _Key, _Compare, _Alloc>  &
# 1025
__y) 
# 1026
{ return !(__x < __y); } 
# 1029
template< class _Key, class _Compare, class _Alloc> inline void 
# 1031
swap(set< _Key, _Compare, _Alloc>  &__x, set< _Key, _Compare, _Alloc>  &__y) noexcept(noexcept(__x.swap(__y))) 
# 1033
{ __x.swap(__y); } 
# 1057 "/usr/include/c++/9/bits/stl_set.h" 3
}
# 64 "/usr/include/c++/9/bits/stl_multiset.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 69
template< class _Key, class _Compare, class _Alloc> class set; 
# 94 "/usr/include/c++/9/bits/stl_multiset.h" 3
template< class _Key, class _Compare = less< _Key> , class 
# 95
_Alloc = allocator< _Key> > 
# 96
class multiset { 
# 110 "/usr/include/c++/9/bits/stl_multiset.h" 3
static_assert((is_same< typename remove_cv< _Key> ::type, _Key> ::value), "std::multiset must have a non-const, non-volatile value_type");
# 120
public: typedef _Key key_type; 
# 121
typedef _Key value_type; 
# 122
typedef _Compare key_compare; 
# 123
typedef _Compare value_compare; 
# 124
typedef _Alloc allocator_type; 
# 129
private: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Key> ::other _Key_alloc_type; 
# 132
typedef _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type>  _Rep_type; 
# 134
_Rep_type _M_t; 
# 136
typedef __gnu_cxx::__alloc_traits< _Key_alloc_type>  _Alloc_traits; 
# 139
public: typedef typename __gnu_cxx::__alloc_traits< _Key_alloc_type> ::pointer pointer; 
# 140
typedef typename __gnu_cxx::__alloc_traits< _Key_alloc_type> ::const_pointer const_pointer; 
# 141
typedef typename __gnu_cxx::__alloc_traits< _Key_alloc_type> ::reference reference; 
# 142
typedef typename __gnu_cxx::__alloc_traits< _Key_alloc_type> ::const_reference const_reference; 
# 146
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::const_iterator iterator; 
# 147
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::const_iterator const_iterator; 
# 148
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::const_reverse_iterator reverse_iterator; 
# 149
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::const_reverse_iterator const_reverse_iterator; 
# 150
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::size_type size_type; 
# 151
typedef typename _Rb_tree< key_type, value_type, _Identity< value_type> , key_compare, _Key_alloc_type> ::difference_type difference_type; 
# 164 "/usr/include/c++/9/bits/stl_multiset.h" 3
multiset() = default;
# 173
explicit multiset(const _Compare &__comp, const allocator_type &
# 174
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 175
{ } 
# 186 "/usr/include/c++/9/bits/stl_multiset.h" 3
template< class _InputIterator> 
# 187
multiset(_InputIterator __first, _InputIterator __last) : _M_t() 
# 189
{ (_M_t)._M_insert_range_equal(__first, __last); } 
# 202 "/usr/include/c++/9/bits/stl_multiset.h" 3
template< class _InputIterator> 
# 203
multiset(_InputIterator __first, _InputIterator __last, const _Compare &
# 204
__comp, const allocator_type &
# 205
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 207
{ (_M_t)._M_insert_range_equal(__first, __last); } 
# 218 "/usr/include/c++/9/bits/stl_multiset.h" 3
multiset(const multiset &) = default;
# 227 "/usr/include/c++/9/bits/stl_multiset.h" 3
multiset(multiset &&) = default;
# 239 "/usr/include/c++/9/bits/stl_multiset.h" 3
multiset(initializer_list< value_type>  __l, const _Compare &
# 240
__comp = _Compare(), const allocator_type &
# 241
__a = allocator_type()) : _M_t(__comp, (_Key_alloc_type)__a) 
# 243
{ (_M_t)._M_insert_range_equal(__l.begin(), __l.end()); } 
# 247
explicit multiset(const allocator_type &__a) : _M_t((_Key_alloc_type)__a) 
# 248
{ } 
# 251
multiset(const multiset &__m, const allocator_type &__a) : _M_t(__m._M_t, (_Key_alloc_type)__a) 
# 252
{ } 
# 255
multiset(multiset &&__m, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare> ::value && _Alloc_traits::_S_always_equal()) : _M_t(std::move(__m._M_t), (_Key_alloc_type)__a) 
# 258
{ } 
# 261
multiset(initializer_list< value_type>  __l, const allocator_type &__a) : _M_t((_Key_alloc_type)__a) 
# 263
{ (_M_t)._M_insert_range_equal(__l.begin(), __l.end()); } 
# 266
template< class _InputIterator> 
# 267
multiset(_InputIterator __first, _InputIterator __last, const allocator_type &
# 268
__a) : _M_t((_Key_alloc_type)__a) 
# 270
{ (_M_t)._M_insert_range_equal(__first, __last); } 
# 277
~multiset() = default;
# 294 "/usr/include/c++/9/bits/stl_multiset.h" 3
multiset &operator=(const multiset &) = default;
# 298
multiset &operator=(multiset &&) = default;
# 312 "/usr/include/c++/9/bits/stl_multiset.h" 3
multiset &operator=(initializer_list< value_type>  __l) 
# 313
{ 
# 314
(_M_t)._M_assign_equal(__l.begin(), __l.end()); 
# 315
return *this; 
# 316
} 
# 323
key_compare key_comp() const 
# 324
{ return (_M_t).key_comp(); } 
# 327
value_compare value_comp() const 
# 328
{ return (_M_t).key_comp(); } 
# 331
allocator_type get_allocator() const noexcept 
# 332
{ return (allocator_type)(_M_t).get_allocator(); } 
# 340
iterator begin() const noexcept 
# 341
{ return (_M_t).begin(); } 
# 349
iterator end() const noexcept 
# 350
{ return (_M_t).end(); } 
# 358
reverse_iterator rbegin() const noexcept 
# 359
{ return (_M_t).rbegin(); } 
# 367
reverse_iterator rend() const noexcept 
# 368
{ return (_M_t).rend(); } 
# 377
iterator cbegin() const noexcept 
# 378
{ return (_M_t).begin(); } 
# 386
iterator cend() const noexcept 
# 387
{ return (_M_t).end(); } 
# 395
reverse_iterator crbegin() const noexcept 
# 396
{ return (_M_t).rbegin(); } 
# 404
reverse_iterator crend() const noexcept 
# 405
{ return (_M_t).rend(); } 
# 410
bool empty() const noexcept 
# 411
{ return (_M_t).empty(); } 
# 415
size_type size() const noexcept 
# 416
{ return (_M_t).size(); } 
# 420
size_type max_size() const noexcept 
# 421
{ return (_M_t).max_size(); } 
# 437 "/usr/include/c++/9/bits/stl_multiset.h" 3
void swap(multiset &__x) noexcept(__is_nothrow_swappable< _Compare> ::value) 
# 439
{ (_M_t).swap(__x._M_t); } 
# 455 "/usr/include/c++/9/bits/stl_multiset.h" 3
template< class ..._Args> iterator 
# 457
emplace(_Args &&...__args) 
# 458
{ return (_M_t)._M_emplace_equal(std::forward< _Args> (__args)...); } 
# 481 "/usr/include/c++/9/bits/stl_multiset.h" 3
template< class ..._Args> iterator 
# 483
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 484
{ 
# 485
return (_M_t)._M_emplace_hint_equal(__pos, std::forward< _Args> (__args)...); 
# 487
} 
# 502 "/usr/include/c++/9/bits/stl_multiset.h" 3
iterator insert(const value_type &__x) 
# 503
{ return (_M_t)._M_insert_equal(__x); } 
# 507
iterator insert(value_type &&__x) 
# 508
{ return (_M_t)._M_insert_equal(std::move(__x)); } 
# 532 "/usr/include/c++/9/bits/stl_multiset.h" 3
iterator insert(const_iterator __position, const value_type &__x) 
# 533
{ return (_M_t)._M_insert_equal_(__position, __x); } 
# 537
iterator insert(const_iterator __position, value_type &&__x) 
# 538
{ return (_M_t)._M_insert_equal_(__position, std::move(__x)); } 
# 549 "/usr/include/c++/9/bits/stl_multiset.h" 3
template< class _InputIterator> void 
# 551
insert(_InputIterator __first, _InputIterator __last) 
# 552
{ (_M_t)._M_insert_range_equal(__first, __last); } 
# 563 "/usr/include/c++/9/bits/stl_multiset.h" 3
void insert(initializer_list< value_type>  __l) 
# 564
{ this->insert(__l.begin(), __l.end()); } 
# 637 "/usr/include/c++/9/bits/stl_multiset.h" 3
__attribute((__abi_tag__("cxx11"))) iterator 
# 639
erase(const_iterator __position) 
# 640
{ return (_M_t).erase(__position); } 
# 669 "/usr/include/c++/9/bits/stl_multiset.h" 3
size_type erase(const key_type &__x) 
# 670
{ return (_M_t).erase(__x); } 
# 689 "/usr/include/c++/9/bits/stl_multiset.h" 3
__attribute((__abi_tag__("cxx11"))) iterator 
# 691
erase(const_iterator __first, const_iterator __last) 
# 692
{ return (_M_t).erase(__first, __last); } 
# 718 "/usr/include/c++/9/bits/stl_multiset.h" 3
void clear() noexcept 
# 719
{ (_M_t).clear(); } 
# 730 "/usr/include/c++/9/bits/stl_multiset.h" 3
size_type count(const key_type &__x) const 
# 731
{ return (_M_t).count(__x); } 
# 734
template< class _Kt> auto 
# 736
count(const _Kt &__x) const->__decltype(((_M_t)._M_count_tr(__x))) 
# 737
{ return (_M_t)._M_count_tr(__x); } 
# 775 "/usr/include/c++/9/bits/stl_multiset.h" 3
iterator find(const key_type &__x) 
# 776
{ return (_M_t).find(__x); } 
# 779
const_iterator find(const key_type &__x) const 
# 780
{ return (_M_t).find(__x); } 
# 783
template< class _Kt> auto 
# 785
find(const _Kt &__x)->__decltype((iterator{(_M_t)._M_find_tr(__x)})) 
# 787
{ return iterator{(_M_t)._M_find_tr(__x)}; } 
# 789
template< class _Kt> auto 
# 791
find(const _Kt &__x) const->__decltype((const_iterator{(_M_t)._M_find_tr(__x)})) 
# 793
{ return const_iterator{(_M_t)._M_find_tr(__x)}; } 
# 810 "/usr/include/c++/9/bits/stl_multiset.h" 3
iterator lower_bound(const key_type &__x) 
# 811
{ return (_M_t).lower_bound(__x); } 
# 814
const_iterator lower_bound(const key_type &__x) const 
# 815
{ return (_M_t).lower_bound(__x); } 
# 818
template< class _Kt> auto 
# 820
lower_bound(const _Kt &__x)->__decltype(((iterator)(_M_t)._M_lower_bound_tr(__x))) 
# 822
{ return (iterator)(_M_t)._M_lower_bound_tr(__x); } 
# 824
template< class _Kt> auto 
# 826
lower_bound(const _Kt &__x) const->__decltype(((iterator)(_M_t)._M_lower_bound_tr(__x))) 
# 828
{ return (iterator)(_M_t)._M_lower_bound_tr(__x); } 
# 840 "/usr/include/c++/9/bits/stl_multiset.h" 3
iterator upper_bound(const key_type &__x) 
# 841
{ return (_M_t).upper_bound(__x); } 
# 844
const_iterator upper_bound(const key_type &__x) const 
# 845
{ return (_M_t).upper_bound(__x); } 
# 848
template< class _Kt> auto 
# 850
upper_bound(const _Kt &__x)->__decltype(((iterator)(_M_t)._M_upper_bound_tr(__x))) 
# 852
{ return (iterator)(_M_t)._M_upper_bound_tr(__x); } 
# 854
template< class _Kt> auto 
# 856
upper_bound(const _Kt &__x) const->__decltype(((iterator)(_M_t)._M_upper_bound_tr(__x))) 
# 858
{ return (iterator)(_M_t)._M_upper_bound_tr(__x); } 
# 879 "/usr/include/c++/9/bits/stl_multiset.h" 3
pair< iterator, iterator>  equal_range(const key_type &__x) 
# 880
{ return (_M_t).equal_range(__x); } 
# 883
pair< iterator, iterator>  equal_range(const key_type &__x) const 
# 884
{ return (_M_t).equal_range(__x); } 
# 887
template< class _Kt> auto 
# 889
equal_range(const _Kt &__x)->__decltype((((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))))) 
# 891
{ return ((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))); } 
# 893
template< class _Kt> auto 
# 895
equal_range(const _Kt &__x) const->__decltype((((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))))) 
# 897
{ return ((pair< iterator, iterator> )((_M_t)._M_equal_range_tr(__x))); } 
# 901
template< class _K1, class _C1, class _A1> friend bool operator==(const std::multiset< _K1, _C1, _A1>  &, const std::multiset< _K1, _C1, _A1>  &); 
# 906
template< class _K1, class _C1, class _A1> friend bool operator<(const std::multiset< _K1, _C1, _A1>  &, const std::multiset< _K1, _C1, _A1>  &); 
# 910
}; 
# 962 "/usr/include/c++/9/bits/stl_multiset.h" 3
template< class _Key, class _Compare, class _Alloc> inline bool 
# 964
operator==(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 965
__y) 
# 966
{ return (__x._M_t) == (__y._M_t); } 
# 979 "/usr/include/c++/9/bits/stl_multiset.h" 3
template< class _Key, class _Compare, class _Alloc> inline bool 
# 981
operator<(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 982
__y) 
# 983
{ return (__x._M_t) < (__y._M_t); } 
# 986
template< class _Key, class _Compare, class _Alloc> inline bool 
# 988
operator!=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 989
__y) 
# 990
{ return !(__x == __y); } 
# 993
template< class _Key, class _Compare, class _Alloc> inline bool 
# 995
operator>(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 996
__y) 
# 997
{ return __y < __x; } 
# 1000
template< class _Key, class _Compare, class _Alloc> inline bool 
# 1002
operator<=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 1003
__y) 
# 1004
{ return !(__y < __x); } 
# 1007
template< class _Key, class _Compare, class _Alloc> inline bool 
# 1009
operator>=(const multiset< _Key, _Compare, _Alloc>  &__x, const multiset< _Key, _Compare, _Alloc>  &
# 1010
__y) 
# 1011
{ return !(__x < __y); } 
# 1014
template< class _Key, class _Compare, class _Alloc> inline void 
# 1016
swap(multiset< _Key, _Compare, _Alloc>  &__x, multiset< _Key, _Compare, _Alloc>  &
# 1017
__y) noexcept(noexcept(__x.swap(__y))) 
# 1019
{ __x.swap(__y); } 
# 1045 "/usr/include/c++/9/bits/stl_multiset.h" 3
}
# 43 "/usr/include/opencv4/opencv2/flann/result_set.h" 3
namespace cvflann { 
# 51
template< class T, class DistanceType> 
# 52
struct BranchStruct { 
# 54
T node; 
# 55
DistanceType mindist; 
# 57
BranchStruct() { } 
# 58
BranchStruct(const T &aNode, DistanceType dist) : node(aNode), mindist(dist) { } 
# 60
bool operator<(const BranchStruct &rhs) const 
# 61
{ 
# 62
return (mindist) < (rhs.mindist); 
# 63
} 
# 64
}; 
# 67
template< class DistanceType> 
# 68
class ResultSet { 
# 71
public: virtual ~ResultSet() { } 
# 73
virtual bool full() const = 0; 
# 75
virtual void addPoint(DistanceType dist, int index) = 0; 
# 77
virtual DistanceType worstDist() const = 0; 
# 79
}; 
# 86
template< class DistanceType> 
# 87
class KNNSimpleResultSet : public ResultSet< DistanceType>  { 
# 89
int *indices; 
# 90
DistanceType *dists; 
# 91
int capacity; 
# 92
int count; 
# 93
DistanceType worst_distance_; 
# 96
public: KNNSimpleResultSet(int capacity_) : capacity(capacity_), count(0) 
# 97
{ 
# 98
} 
# 100
void init(int *indices_, DistanceType *dists_) 
# 101
{ 
# 102
(indices) = indices_; 
# 103
(dists) = dists_; 
# 104
(count) = 0; 
# 105
(worst_distance_) = std::template numeric_limits< DistanceType> ::max(); 
# 106
((dists)[(capacity) - 1]) = (worst_distance_); 
# 107
} 
# 109
::size_t size() const 
# 110
{ 
# 111
return count; 
# 112
} 
# 114
bool full() const override 
# 115
{ 
# 116
return (count) == (capacity); 
# 117
} 
# 120
void addPoint(DistanceType dist, int index) override 
# 121
{ 
# 122
if (dist >= (worst_distance_)) { return; }  
# 123
int i; 
# 124
for (i = (count); i > 0; --i) { 
# 128
if (((dists)[i - 1]) > dist) 
# 130
{ 
# 131
if (i < (capacity)) { 
# 132
((dists)[i]) = ((dists)[i - 1]); 
# 133
((indices)[i]) = ((indices)[i - 1]); 
# 134
}  
# 135
} else { 
# 136
break; }  
# 137
}  
# 138
if ((count) < (capacity)) { ++(count); }  
# 139
((dists)[i]) = dist; 
# 140
((indices)[i]) = index; 
# 141
(worst_distance_) = ((dists)[(capacity) - 1]); 
# 142
} 
# 144
DistanceType worstDist() const override 
# 145
{ 
# 146
return worst_distance_; 
# 147
} 
# 148
}; 
# 153
template< class DistanceType> 
# 154
class KNNResultSet : public ResultSet< DistanceType>  { 
# 156
int *indices; 
# 157
DistanceType *dists; 
# 158
int capacity; 
# 159
int count; 
# 160
DistanceType worst_distance_; 
# 163
public: KNNResultSet(int capacity_) : capacity(capacity_), count(0) 
# 164
{ 
# 165
} 
# 167
void init(int *indices_, DistanceType *dists_) 
# 168
{ 
# 169
(indices) = indices_; 
# 170
(dists) = dists_; 
# 171
(count) = 0; 
# 172
(worst_distance_) = std::template numeric_limits< DistanceType> ::max(); 
# 173
((dists)[(capacity) - 1]) = (worst_distance_); 
# 174
} 
# 176
::size_t size() const 
# 177
{ 
# 178
return count; 
# 179
} 
# 181
bool full() const override 
# 182
{ 
# 183
return (count) == (capacity); 
# 184
} 
# 187
void addPoint(DistanceType dist, int index) override 
# 188
{ 
# 189
if (dist >= (worst_distance_)) { return; }  
# 190
int i; 
# 191
for (i = (count); i > 0; --i) { 
# 195
if (((dists)[i - 1]) <= dist) 
# 197
{ 
# 199
int j = i - 1; 
# 200
while ((j >= 0) && (((dists)[j]) == dist)) { 
# 201
if (((indices)[j]) == index) { 
# 202
return; 
# 203
}  
# 204
--j; 
# 205
}  
# 206
break; 
# 207
}  
# 208
}  
# 210
if ((count) < (capacity)) { ++(count); }  
# 211
for (int j = (count) - 1; j > i; --j) { 
# 212
((dists)[j]) = ((dists)[j - 1]); 
# 213
((indices)[j]) = ((indices)[j - 1]); 
# 214
}  
# 215
((dists)[i]) = dist; 
# 216
((indices)[i]) = index; 
# 217
(worst_distance_) = ((dists)[(capacity) - 1]); 
# 218
} 
# 220
DistanceType worstDist() const override 
# 221
{ 
# 222
return worst_distance_; 
# 223
} 
# 224
}; 
# 230
template< class DistanceType> 
# 231
class RadiusResultSet : public ResultSet< DistanceType>  { 
# 233
DistanceType radius; 
# 234
int *indices; 
# 235
DistanceType *dists; 
# 236
::size_t capacity; 
# 237
::size_t count; 
# 240
public: RadiusResultSet(DistanceType radius_, int *indices_, DistanceType *dists_, int capacity_) : radius(radius_), indices(indices_), dists(dists_), capacity(capacity_) 
# 242
{ 
# 243
init(); 
# 244
} 
# 246
~RadiusResultSet() 
# 247
{ 
# 248
} 
# 250
void init() 
# 251
{ 
# 252
(count) = (0); 
# 253
} 
# 255
::size_t size() const 
# 256
{ 
# 257
return count; 
# 258
} 
# 260
bool full() const 
# 261
{ 
# 262
return true; 
# 263
} 
# 265
void addPoint(DistanceType dist, int index) 
# 266
{ 
# 267
if (dist < (radius)) { 
# 268
if (((capacity) > (0)) && ((count) < (capacity))) { 
# 269
((dists)[count]) = dist; 
# 270
((indices)[count]) = index; 
# 271
}  
# 272
(count)++; 
# 273
}  
# 274
} 
# 276
DistanceType worstDist() const 
# 277
{ 
# 278
return radius; 
# 279
} 
# 281
}; 
# 288
template< class DistanceType> 
# 289
class UniqueResultSet : public ResultSet< DistanceType>  { 
# 292
public: struct DistIndex { 
# 294
DistIndex(DistanceType dist, unsigned index) : dist_(dist), index_(index) 
# 296
{ 
# 297
} 
# 298
bool operator<(const DistIndex dist_index) const 
# 299
{ 
# 300
return ((dist_) < (dist_index.dist_)) || (((dist_) == (dist_index.dist_)) && ((index_) < (dist_index.index_))); 
# 301
} 
# 302
DistanceType dist_; 
# 303
unsigned index_; 
# 304
}; 
# 307
UniqueResultSet() : is_full_(false), worst_distance_(std::template numeric_limits< DistanceType> ::max()) 
# 309
{ 
# 310
} 
# 315
bool full() const override 
# 316
{ 
# 317
return is_full_; 
# 318
} 
# 322
virtual void clear() = 0; 
# 329
virtual void copy(int *indices, DistanceType *dist, int n_neighbors = -1) const 
# 330
{ 
# 331
if (n_neighbors < 0) { 
# 332
for (typename std::set< DistIndex> ::const_iterator dist_index = (dist_indices_).begin(), dist_index_end = (dist_indices_).end(); dist_index != dist_index_end; ((++dist_index), (++indices)), (++dist)) 
# 333
{ 
# 334
(*indices) = (dist_index->index_); 
# 335
(*dist) = (dist_index->dist_); 
# 336
}  
# 337
} else 
# 338
{ 
# 339
int i = 0; 
# 340
for (typename std::set< DistIndex> ::const_iterator dist_index = (dist_indices_).begin(), dist_index_end = (dist_indices_).end(); (dist_index != dist_index_end) && (i < n_neighbors); (((++dist_index), (++indices)), (++dist)), (++i)) 
# 341
{ 
# 342
(*indices) = (dist_index->index_); 
# 343
(*dist) = (dist_index->dist_); 
# 344
}  
# 345
}  
# 346
} 
# 353
virtual void sortAndCopy(int *indices, DistanceType *dist, int n_neighbors = -1) const 
# 354
{ 
# 355
copy(indices, dist, n_neighbors); 
# 356
} 
# 361
::size_t size() const 
# 362
{ 
# 363
return (dist_indices_).size(); 
# 364
} 
# 370
DistanceType worstDist() const override 
# 371
{ 
# 372
return worst_distance_; 
# 373
} 
# 376
protected: bool is_full_; 
# 379
DistanceType worst_distance_; 
# 382
std::set< DistIndex>  dist_indices_; 
# 383
}; 
# 390
template< class DistanceType> 
# 391
class KNNUniqueResultSet : public UniqueResultSet< DistanceType>  { 
# 397
public: KNNUniqueResultSet(unsigned capacity) : capacity_(capacity) 
# 398
{ 
# 399
(this->is_full_) = false; 
# 400
clear(); 
# 401
} 
# 407
void addPoint(DistanceType dist, int index) override 
# 408
{ 
# 410
if (dist >= worst_distance_) { return; }  
# 411
(dist_indices_.insert)(DistIndex(dist, index)); 
# 413
if (is_full_) { 
# 414
if ((dist_indices_.size)() > (capacity_)) { 
# 415
(dist_indices_.erase)(*(dist_indices_.rbegin)()); 
# 416
worst_distance_ = ((dist_indices_.rbegin)()->dist_); 
# 417
}  
# 418
} else { 
# 419
if ((dist_indices_.size)() == (capacity_)) { 
# 420
is_full_ = true; 
# 421
worst_distance_ = ((dist_indices_.rbegin)()->dist_); 
# 422
}  }  
# 423
} 
# 427
void clear() override 
# 428
{ 
# 429
(dist_indices_.clear)(); 
# 430
worst_distance_ = std::template numeric_limits< DistanceType> ::max(); 
# 431
is_full_ = false; 
# 432
} 
# 435
protected: typedef typename UniqueResultSet< DistanceType> ::DistIndex DistIndex; 
# 436
using UniqueResultSet< DistanceType> ::is_full_;
# 437
using UniqueResultSet< DistanceType> ::worst_distance_;
# 438
using UniqueResultSet< DistanceType> ::dist_indices_;
# 441
unsigned capacity_; 
# 442
}; 
# 449
template< class DistanceType> 
# 450
class RadiusUniqueResultSet : public UniqueResultSet< DistanceType>  { 
# 456
public: RadiusUniqueResultSet(DistanceType radius) : radius_(radius) 
# 458
{ 
# 459
is_full_ = true; 
# 460
} 
# 466
void addPoint(DistanceType dist, int index) override 
# 467
{ 
# 468
if (dist <= (radius_)) { (dist_indices_.insert)(DistIndex(dist, index)); }  
# 469
} 
# 473
void clear() override 
# 474
{ 
# 475
(dist_indices_.clear)(); 
# 476
} 
# 482
bool full() const override 
# 483
{ 
# 484
return true; 
# 485
} 
# 491
DistanceType worstDist() const override 
# 492
{ 
# 493
return radius_; 
# 494
} 
# 496
private: typedef typename UniqueResultSet< DistanceType> ::DistIndex DistIndex; 
# 497
using UniqueResultSet< DistanceType> ::dist_indices_;
# 498
using UniqueResultSet< DistanceType> ::is_full_;
# 501
DistanceType radius_; 
# 502
}; 
# 508
template< class DistanceType> 
# 509
class KNNRadiusUniqueResultSet : public KNNUniqueResultSet< DistanceType>  { 
# 516
public: KNNRadiusUniqueResultSet(unsigned capacity, DistanceType radius) 
# 517
{ 
# 518
(this->capacity_) = capacity; 
# 519
(this->radius_) = radius; 
# 520
(this->dist_indices_).reserve(capacity_); 
# 521
clear(); 
# 522
} 
# 526
void clear() 
# 527
{ 
# 528
(dist_indices_.clear)(); 
# 529
worst_distance_ = (radius_); 
# 530
is_full_ = false; 
# 531
} 
# 533
private: using KNNUniqueResultSet< DistanceType> ::dist_indices_;
# 534
using KNNUniqueResultSet< DistanceType> ::is_full_;
# 535
using KNNUniqueResultSet< DistanceType> ::worst_distance_;
# 538
unsigned capacity_; 
# 541
DistanceType radius_; 
# 542
}; 
# 543
}
# 41 "/usr/include/opencv4/opencv2/flann/nn_index.h" 3
namespace cvflann { 
# 47
template< class Distance> 
# 48
class NNIndex { 
# 50
typedef typename Distance::ElementType ElementType; 
# 51
typedef typename Distance::ResultType DistanceType; 
# 55
public: virtual ~NNIndex() { } 
# 60
virtual void buildIndex() = 0; 
# 70 "/usr/include/opencv4/opencv2/flann/nn_index.h" 3
virtual void knnSearch(const Matrix< ElementType>  &queries, Matrix< int>  &indices, Matrix< DistanceType>  &dists, int knn, const SearchParams &params) 
# 71
{ 
# 72
(static_cast< bool>((queries.cols) == veclen())) ? (void)0 : __assert_fail("queries.cols == veclen()", "/usr/include/opencv4/opencv2/flann/nn_index.h", 72, __extension__ __PRETTY_FUNCTION__); 
# 73
(static_cast< bool>((indices.rows) >= (queries.rows))) ? (void)0 : __assert_fail("indices.rows >= queries.rows", "/usr/include/opencv4/opencv2/flann/nn_index.h", 73, __extension__ __PRETTY_FUNCTION__); 
# 74
(static_cast< bool>((dists.rows) >= (queries.rows))) ? (void)0 : __assert_fail("dists.rows >= queries.rows", "/usr/include/opencv4/opencv2/flann/nn_index.h", 74, __extension__ __PRETTY_FUNCTION__); 
# 75
(static_cast< bool>(((int)(indices.cols)) >= knn)) ? (void)0 : __assert_fail("int(indices.cols) >= knn", "/usr/include/opencv4/opencv2/flann/nn_index.h", 75, __extension__ __PRETTY_FUNCTION__); 
# 76
(static_cast< bool>(((int)(dists.cols)) >= knn)) ? (void)0 : __assert_fail("int(dists.cols) >= knn", "/usr/include/opencv4/opencv2/flann/nn_index.h", 76, __extension__ __PRETTY_FUNCTION__); 
# 85 "/usr/include/opencv4/opencv2/flann/nn_index.h" 3
KNNUniqueResultSet< DistanceType>  resultSet(knn); 
# 86
for (size_t i = (0); i < (queries.rows); i++) { 
# 87
resultSet.clear(); 
# 88
findNeighbors(resultSet, queries[i], params); 
# 89
if (get_param(params, "sorted", true)) { resultSet.sortAndCopy(indices[i], dists[i], knn); } else { 
# 90
resultSet.copy(indices[i], dists[i], knn); }  
# 91
}  
# 93
} 
# 104 "/usr/include/opencv4/opencv2/flann/nn_index.h" 3
virtual int radiusSearch(const Matrix< ElementType>  &query, Matrix< int>  &indices, Matrix< DistanceType>  &dists, float radius, const SearchParams &params) 
# 105
{ 
# 106
if ((query.rows) != 1) { 
# 107
fprintf(stderr, "I can only search one feature at a time for range search\n"); 
# 108
return -1; 
# 109
}  
# 110
(static_cast< bool>((query.cols) == veclen())) ? (void)0 : __assert_fail("query.cols == veclen()", "/usr/include/opencv4/opencv2/flann/nn_index.h", 110, __extension__ __PRETTY_FUNCTION__); 
# 111
(static_cast< bool>((indices.cols) == (dists.cols))) ? (void)0 : __assert_fail("indices.cols == dists.cols", "/usr/include/opencv4/opencv2/flann/nn_index.h", 111, __extension__ __PRETTY_FUNCTION__); 
# 113
int n = 0; 
# 114
int *indices_ptr = (__null); 
# 115
DistanceType *dists_ptr = (__null); 
# 116
if ((indices.cols) > (0)) { 
# 117
n = ((int)(indices.cols)); 
# 118
indices_ptr = indices[0]; 
# 119
dists_ptr = (dists[0]); 
# 120
}  
# 122
RadiusUniqueResultSet< DistanceType>  resultSet((DistanceType)radius); 
# 123
resultSet.clear(); 
# 124
findNeighbors(resultSet, query[0], params); 
# 125
if (n > 0) { 
# 126
if (get_param(params, "sorted", true)) { resultSet.sortAndCopy(indices_ptr, dists_ptr, n); } else { 
# 127
resultSet.copy(indices_ptr, dists_ptr, n); }  
# 128
}  
# 130
return (int)resultSet.size(); 
# 131
} 
# 137
virtual void saveIndex(FILE * stream) = 0; 
# 143
virtual void loadIndex(FILE * stream) = 0; 
# 148
virtual size_t size() const = 0; 
# 153
virtual size_t veclen() const = 0; 
# 158
virtual int usedMemory() const = 0; 
# 163
virtual flann_algorithm_t getType() const = 0; 
# 168
virtual IndexParams getParameters() const = 0; 
# 174
virtual void findNeighbors(ResultSet< DistanceType>  & result, const ElementType * vec, const SearchParams & searchParams) = 0; 
# 175
}; 
# 177
}
# 45 "/usr/include/opencv4/opencv2/flann/saving.h" 3
namespace cvflann { 
# 48
template< class T> 
# 49
struct Datatype { }; 
# 51
template<> struct Datatype< char>  { static flann_datatype_t type() { return FLANN_INT8; } }; 
# 53
template<> struct Datatype< short>  { static flann_datatype_t type() { return FLANN_INT16; } }; 
# 55
template<> struct Datatype< int>  { static flann_datatype_t type() { return FLANN_INT32; } }; 
# 57
template<> struct Datatype< unsigned char>  { static flann_datatype_t type() { return FLANN_UINT8; } }; 
# 59
template<> struct Datatype< unsigned short>  { static flann_datatype_t type() { return FLANN_UINT16; } }; 
# 61
template<> struct Datatype< unsigned>  { static flann_datatype_t type() { return FLANN_UINT32; } }; 
# 63
template<> struct Datatype< float>  { static flann_datatype_t type() { return FLANN_FLOAT32; } }; 
# 65
template<> struct Datatype< double>  { static flann_datatype_t type() { return FLANN_FLOAT64; } }; 
# 71
struct IndexHeader { 
# 73
char signature[16]; 
# 74
char version[16]; 
# 75
flann_datatype_t data_type; 
# 76
flann_algorithm_t index_type; 
# 77
size_t rows; 
# 78
size_t cols; 
# 79
}; 
# 87
template< class Distance> void 
# 88
save_header(FILE *stream, const NNIndex< Distance>  &index) 
# 89
{ 
# 90
IndexHeader header; 
# 91
memset(header.signature, 0, sizeof (header.signature)); 
# 92
strcpy(header.signature, "FLANN_INDEX"); 
# 93
memset(header.version, 0, sizeof (header.version)); 
# 94
strcpy(header.version, "1.6.10"); 
# 95
(header.data_type) = Datatype< typename Distance::ElementType> ::type(); 
# 96
(header.index_type) = index.getType(); 
# 97
(header.rows) = index.size(); 
# 98
(header.cols) = index.veclen(); 
# 100
std::fwrite(&header, sizeof header, 1, stream); 
# 101
} 
# 109
inline IndexHeader load_header(FILE *stream) 
# 110
{ 
# 111
IndexHeader header; 
# 112
size_t read_size = fread(&header, sizeof header, 1, stream); 
# 114
if (read_size != ((size_t)1)) { 
# 115
throw ((FLANNException)("Invalid index file, cannot read")); 
# 116
}  
# 118
if (strcmp(header.signature, "FLANN_INDEX") != 0) { 
# 119
throw ((FLANNException)("Invalid index file, wrong signature")); 
# 120
}  
# 122
return header; 
# 124
} 
# 127
template< class T> void 
# 128
save_value(FILE *stream, const T &value, size_t count = 1) 
# 129
{ 
# 130
fwrite(&value, sizeof(value), count, stream); 
# 131
} 
# 133
template< class T> void 
# 134
save_value(FILE *stream, const Matrix< T>  &value) 
# 135
{ 
# 136
fwrite(&value, sizeof(value), 1, stream); 
# 137
fwrite((value.data), sizeof(T), (value.rows) * (value.cols), stream); 
# 138
} 
# 140
template< class T> void 
# 141
save_value(FILE *stream, const std::vector< T>  &value) 
# 142
{ 
# 143
size_t size = value.size(); 
# 144
fwrite(&size, sizeof(size_t), 1, stream); 
# 145
fwrite(&(value[0]), sizeof(T), size, stream); 
# 146
} 
# 148
template< class T> void 
# 149
load_value(FILE *stream, T &value, size_t count = 1) 
# 150
{ 
# 151
size_t read_cnt = fread(&value, sizeof(value), count, stream); 
# 152
if (read_cnt != count) { 
# 153
throw ((FLANNException)("Cannot read from file")); 
# 154
}  
# 155
} 
# 157
template< class T> void 
# 158
load_value(FILE *stream, Matrix< T>  &value) 
# 159
{ 
# 160
size_t read_cnt = fread(&value, sizeof(value), 1, stream); 
# 161
if (read_cnt != (1)) { 
# 162
throw ((FLANNException)("Cannot read from file")); 
# 163
}  
# 164
(value.data) = (new T [(value.rows) * (value.cols)]); 
# 165
read_cnt = fread((value.data), sizeof(T), (value.rows) * (value.cols), stream); 
# 166
if (read_cnt != ((size_t)((value.rows) * (value.cols)))) { 
# 167
throw ((FLANNException)("Cannot read from file")); 
# 168
}  
# 169
} 
# 172
template< class T> void 
# 173
load_value(FILE *stream, std::vector< T>  &value) 
# 174
{ 
# 175
size_t size; 
# 176
size_t read_cnt = fread(&size, sizeof(size_t), 1, stream); 
# 177
if (read_cnt != (1)) { 
# 178
throw ((FLANNException)("Cannot read from file")); 
# 179
}  
# 180
value.resize(size); 
# 181
read_cnt = fread(&(value[0]), sizeof(T), size, stream); 
# 182
if (read_cnt != size) { 
# 183
throw ((FLANNException)("Cannot read from file")); 
# 184
}  
# 185
} 
# 187
}
# 56 "/usr/include/opencv4/opencv2/flann/dist.h" 3
namespace cvflann { 
# 59
template< class T> inline T 
# 60
abs(T x) { return (x < 0) ? -x : x; } 
# 63
template<> inline int abs< int> (int x) { return ::abs(x); } 
# 66
template<> inline float abs< float> (float x) { return fabsf(x); } 
# 69
template<> inline double abs< double> (double x) { return fabs(x); } 
# 71
template< class T> 
# 72
struct Accumulator { typedef T Type; }; 
# 74
template<> struct Accumulator< unsigned char>  { typedef float Type; }; 
# 76
template<> struct Accumulator< unsigned short>  { typedef float Type; }; 
# 78
template<> struct Accumulator< unsigned>  { typedef float Type; }; 
# 80
template<> struct Accumulator< char>  { typedef float Type; }; 
# 82
template<> struct Accumulator< short>  { typedef float Type; }; 
# 84
template<> struct Accumulator< int>  { typedef float Type; }; 
# 89
class True { 
# 91
}; 
# 93
class False { 
# 95
}; 
# 104 "/usr/include/opencv4/opencv2/flann/dist.h" 3
template< class T> 
# 105
struct L2_Simple { 
# 107
typedef True is_kdtree_distance; 
# 108
typedef True is_vector_space_distance; 
# 110
typedef T ElementType; 
# 111
typedef typename Accumulator< T> ::Type ResultType; 
# 113
template< class Iterator1, class Iterator2> ResultType 
# 114
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const 
# 115
{ 
# 116
ResultType result = ResultType(); 
# 117
ResultType diff; 
# 118
for (size_t i = (0); i < size; ++i) { 
# 119
diff = ((ResultType)((*(a++)) - (*(b++)))); 
# 120
result += (diff * diff); 
# 121
}  
# 122
return result; 
# 123
} 
# 125
template< class U, class V> ResultType 
# 126
accum_dist(const U &a, const V &b, int) const 
# 127
{ 
# 128
return (a - b) * (a - b); 
# 129
} 
# 130
}; 
# 137
template< class T> 
# 138
struct L2 { 
# 140
typedef True is_kdtree_distance; 
# 141
typedef True is_vector_space_distance; 
# 143
typedef T ElementType; 
# 144
typedef typename Accumulator< T> ::Type ResultType; 
# 155 "/usr/include/opencv4/opencv2/flann/dist.h" 3
template< class Iterator1, class Iterator2> ResultType 
# 156
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 157
{ 
# 158
ResultType result = ResultType(); 
# 159
ResultType diff0, diff1, diff2, diff3; 
# 160
Iterator1 last = a + size; 
# 161
Iterator1 lastgroup = last - 3; 
# 164
while (a < lastgroup) { 
# 165
diff0 = ((ResultType)((a[0]) - (b[0]))); 
# 166
diff1 = ((ResultType)((a[1]) - (b[1]))); 
# 167
diff2 = ((ResultType)((a[2]) - (b[2]))); 
# 168
diff3 = ((ResultType)((a[3]) - (b[3]))); 
# 169
result += ((((diff0 * diff0) + (diff1 * diff1)) + (diff2 * diff2)) + (diff3 * diff3)); 
# 170
a += 4; 
# 171
b += 4; 
# 173
if ((worst_dist > 0) && (result > worst_dist)) { 
# 174
return result; 
# 175
}  
# 176
}  
# 178
while (a < last) { 
# 179
diff0 = ((ResultType)((*(a++)) - (*(b++)))); 
# 180
result += (diff0 * diff0); 
# 181
}  
# 182
return result; 
# 183
} 
# 191
template< class U, class V> ResultType 
# 192
accum_dist(const U &a, const V &b, int) const 
# 193
{ 
# 194
return (a - b) * (a - b); 
# 195
} 
# 196
}; 
# 202
template< class T> 
# 203
struct L1 { 
# 205
typedef True is_kdtree_distance; 
# 206
typedef True is_vector_space_distance; 
# 208
typedef T ElementType; 
# 209
typedef typename Accumulator< T> ::Type ResultType; 
# 217
template< class Iterator1, class Iterator2> ResultType 
# 218
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 219
{ 
# 220
ResultType result = ResultType(); 
# 221
ResultType diff0, diff1, diff2, diff3; 
# 222
Iterator1 last = a + size; 
# 223
Iterator1 lastgroup = last - 3; 
# 226
while (a < lastgroup) { 
# 227
diff0 = ((ResultType)abs((a[0]) - (b[0]))); 
# 228
diff1 = ((ResultType)abs((a[1]) - (b[1]))); 
# 229
diff2 = ((ResultType)abs((a[2]) - (b[2]))); 
# 230
diff3 = ((ResultType)abs((a[3]) - (b[3]))); 
# 231
result += (((diff0 + diff1) + diff2) + diff3); 
# 232
a += 4; 
# 233
b += 4; 
# 235
if ((worst_dist > 0) && (result > worst_dist)) { 
# 236
return result; 
# 237
}  
# 238
}  
# 240
while (a < last) { 
# 241
diff0 = ((ResultType)abs((*(a++)) - (*(b++)))); 
# 242
result += diff0; 
# 243
}  
# 244
return result; 
# 245
} 
# 250
template< class U, class V> ResultType 
# 251
accum_dist(const U &a, const V &b, int) const 
# 252
{ 
# 253
return abs(a - b); 
# 254
} 
# 255
}; 
# 259
template< class T> 
# 260
struct MinkowskiDistance { 
# 262
typedef True is_kdtree_distance; 
# 263
typedef True is_vector_space_distance; 
# 265
typedef T ElementType; 
# 266
typedef typename Accumulator< T> ::Type ResultType; 
# 268
int order; 
# 270
MinkowskiDistance(int order_) : order(order_) { } 
# 281 "/usr/include/opencv4/opencv2/flann/dist.h" 3
template< class Iterator1, class Iterator2> ResultType 
# 282
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 283
{ 
# 284
ResultType result = ResultType(); 
# 285
ResultType diff0, diff1, diff2, diff3; 
# 286
Iterator1 last = a + size; 
# 287
Iterator1 lastgroup = last - 3; 
# 290
while (a < lastgroup) { 
# 291
diff0 = ((ResultType)abs((a[0]) - (b[0]))); 
# 292
diff1 = ((ResultType)abs((a[1]) - (b[1]))); 
# 293
diff2 = ((ResultType)abs((a[2]) - (b[2]))); 
# 294
diff3 = ((ResultType)abs((a[3]) - (b[3]))); 
# 295
result += (((pow(diff0, order) + pow(diff1, order)) + pow(diff2, order)) + pow(diff3, order)); 
# 296
a += 4; 
# 297
b += 4; 
# 299
if ((worst_dist > 0) && (result > worst_dist)) { 
# 300
return result; 
# 301
}  
# 302
}  
# 304
while (a < last) { 
# 305
diff0 = ((ResultType)abs((*(a++)) - (*(b++)))); 
# 306
result += pow(diff0, order); 
# 307
}  
# 308
return result; 
# 309
} 
# 314
template< class U, class V> ResultType 
# 315
accum_dist(const U &a, const V &b, int) const 
# 316
{ 
# 317
return pow(static_cast< ResultType>(abs(a - b)), order); 
# 318
} 
# 319
}; 
# 323
template< class T> 
# 324
struct MaxDistance { 
# 326
typedef False is_kdtree_distance; 
# 327
typedef True is_vector_space_distance; 
# 329
typedef T ElementType; 
# 330
typedef typename Accumulator< T> ::Type ResultType; 
# 337
template< class Iterator1, class Iterator2> ResultType 
# 338
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 339
{ 
# 340
ResultType result = ResultType(); 
# 341
ResultType diff0, diff1, diff2, diff3; 
# 342
Iterator1 last = a + size; 
# 343
Iterator1 lastgroup = last - 3; 
# 346
while (a < lastgroup) { 
# 347
diff0 = abs((a[0]) - (b[0])); 
# 348
diff1 = abs((a[1]) - (b[1])); 
# 349
diff2 = abs((a[2]) - (b[2])); 
# 350
diff3 = abs((a[3]) - (b[3])); 
# 351
if (diff0 > result) { result = diff0; }  
# 352
if (diff1 > result) { result = diff1; }  
# 353
if (diff2 > result) { result = diff2; }  
# 354
if (diff3 > result) { result = diff3; }  
# 355
a += 4; 
# 356
b += 4; 
# 358
if ((worst_dist > 0) && (result > worst_dist)) { 
# 359
return result; 
# 360
}  
# 361
}  
# 363
while (a < last) { 
# 364
diff0 = abs((*(a++)) - (*(b++))); 
# 365
result = ((diff0 > result) ? diff0 : result); 
# 366
}  
# 367
return result; 
# 368
} 
# 373
}; 
# 381
struct HammingLUT { 
# 383
typedef False is_kdtree_distance; 
# 384
typedef False is_vector_space_distance; 
# 386
typedef unsigned char ElementType; 
# 387
typedef int ResultType; 
# 391
ResultType operator()(const unsigned char *a, const unsigned char *b, size_t size) const 
# 392
{ 
# 393
static const uchar popCountTable[] = {(0), (1), (1), (2), (1), (2), (2), (3), (1), (2), (2), (3), (2), (3), (3), (4), (1), (2), (2), (3), (2), (3), (3), (4), (2), (3), (3), (4), (3), (4), (4), (5), (1), (2), (2), (3), (2), (3), (3), (4), (2), (3), (3), (4), (3), (4), (4), (5), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (1), (2), (2), (3), (2), (3), (3), (4), (2), (3), (3), (4), (3), (4), (4), (5), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (3), (4), (4), (5), (4), (5), (5), (6), (4), (5), (5), (6), (5), (6), (6), (7), (1), (2), (2), (3), (2), (3), (3), (4), (2), (3), (3), (4), (3), (4), (4), (5), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (3), (4), (4), (5), (4), (5), (5), (6), (4), (5), (5), (6), (5), (6), (6), (7), (2), (3), (3), (4), (3), (4), (4), (5), (3), (4), (4), (5), (4), (5), (5), (6), (3), (4), (4), (5), (4), (5), (5), (6), (4), (5), (5), (6), (5), (6), (6), (7), (3), (4), (4), (5), (4), (5), (5), (6), (4), (5), (5), (6), (5), (6), (6), (7), (4), (5), (5), (6), (5), (6), (6), (7), (5), (6), (6), (7), (6), (7), (7), (8)}; 
# 404
ResultType result = 0; 
# 405
for (size_t i = (0); i < size; i++) { 
# 406
result += (popCountTable[(a[i]) ^ (b[i])]); 
# 407
}  
# 408
return result; 
# 409
} 
# 410
}; 
# 416
template< class T> 
# 417
struct Hamming { 
# 419
typedef False is_kdtree_distance; 
# 420
typedef False is_vector_space_distance; 
# 423
typedef T ElementType; 
# 424
typedef int ResultType; 
# 426
template< class Iterator1, class Iterator2> ResultType 
# 427
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const 
# 428
{ 
# 429
ResultType result = 0; 
# 447 "/usr/include/opencv4/opencv2/flann/dist.h" 3
{ 
# 449
typedef unsigned long long pop_t; 
# 450
const size_t modulo = size % sizeof(pop_t); 
# 451
const pop_t *a2 = reinterpret_cast< const pop_t *>(a); 
# 452
const pop_t *b2 = reinterpret_cast< const pop_t *>(b); 
# 453
const pop_t *a2_end = a2 + (size / sizeof(pop_t)); 
# 455
for (; a2 != a2_end; (++a2), (++b2)) { result += __builtin_popcountll((*a2) ^ (*b2)); }  
# 457
if (modulo) { 
# 460
pop_t a_final = (0), b_final = (0); 
# 461
memcpy(&a_final, a2, modulo); 
# 462
memcpy(&b_final, b2, modulo); 
# 463
result += __builtin_popcountll(a_final ^ b_final); 
# 464
}  
# 465
} 
# 471
return result; 
# 472
} 
# 473
}; 
# 475
template< class T> 
# 476
struct Hamming2 { 
# 478
typedef False is_kdtree_distance; 
# 479
typedef False is_vector_space_distance; 
# 481
typedef T ElementType; 
# 482
typedef int ResultType; 
# 486
unsigned popcnt32(uint32_t n) const 
# 487
{ 
# 488
n -= ((n >> 1) & (1431655765)); 
# 489
n = ((n & (858993459)) + ((n >> 2) & (858993459))); 
# 490
return (((n + (n >> 4)) & (252645135)) * (16843009)) >> 24; 
# 491
} 
# 494
unsigned popcnt64(uint64_t n) const 
# 495
{ 
# 496
n -= ((n >> 1) & (6148914691236517205L)); 
# 497
n = ((n & (3689348814741910323L)) + ((n >> 2) & (3689348814741910323L))); 
# 498
return (((n + (n >> 4)) & (1085102592571150095L)) * (72340172838076673L)) >> 56; 
# 499
} 
# 502
template< class Iterator1, class Iterator2> ResultType 
# 503
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const 
# 504
{ 
# 506
const uint64_t *pa = reinterpret_cast< const uint64_t *>(a); 
# 507
const uint64_t *pb = reinterpret_cast< const uint64_t *>(b); 
# 508
ResultType result = 0; 
# 509
size /= (sizeof(uint64_t) / sizeof(unsigned char)); 
# 510
for (size_t i = (0); i < size; ++i) { 
# 511
result += popcnt64((*pa) ^ (*pb)); 
# 512
++pa; 
# 513
++pb; 
# 514
}  
# 526 "/usr/include/opencv4/opencv2/flann/dist.h" 3
return result; 
# 527
} 
# 528
}; 
# 534
template< class T> 
# 535
struct HistIntersectionDistance { 
# 537
typedef True is_kdtree_distance; 
# 538
typedef True is_vector_space_distance; 
# 540
typedef T ElementType; 
# 541
typedef typename Accumulator< T> ::Type ResultType; 
# 546
template< class Iterator1, class Iterator2> ResultType 
# 547
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 548
{ 
# 549
ResultType result = ResultType(); 
# 550
ResultType min0, min1, min2, min3; 
# 551
Iterator1 last = a + size; 
# 552
Iterator1 lastgroup = last - 3; 
# 555
while (a < lastgroup) { 
# 556
min0 = ((ResultType)(((a[0]) < (b[0])) ? a[0] : (b[0]))); 
# 557
min1 = ((ResultType)(((a[1]) < (b[1])) ? a[1] : (b[1]))); 
# 558
min2 = ((ResultType)(((a[2]) < (b[2])) ? a[2] : (b[2]))); 
# 559
min3 = ((ResultType)(((a[3]) < (b[3])) ? a[3] : (b[3]))); 
# 560
result += (((min0 + min1) + min2) + min3); 
# 561
a += 4; 
# 562
b += 4; 
# 563
if ((worst_dist > 0) && (result > worst_dist)) { 
# 564
return result; 
# 565
}  
# 566
}  
# 568
while (a < last) { 
# 569
min0 = ((ResultType)(((*a) < (*b)) ? *a : (*b))); 
# 570
result += min0; 
# 571
++a; 
# 572
++b; 
# 573
}  
# 574
return result; 
# 575
} 
# 580
template< class U, class V> ResultType 
# 581
accum_dist(const U &a, const V &b, int) const 
# 582
{ 
# 583
return (a < b) ? a : b; 
# 584
} 
# 585
}; 
# 589
template< class T> 
# 590
struct HellingerDistance { 
# 592
typedef True is_kdtree_distance; 
# 593
typedef True is_vector_space_distance; 
# 595
typedef T ElementType; 
# 596
typedef typename Accumulator< T> ::Type ResultType; 
# 601
template< class Iterator1, class Iterator2> ResultType 
# 602
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType = -1) const 
# 603
{ 
# 604
ResultType result = ResultType(); 
# 605
ResultType diff0, diff1, diff2, diff3; 
# 606
Iterator1 last = a + size; 
# 607
Iterator1 lastgroup = last - 3; 
# 610
while (a < lastgroup) { 
# 611
diff0 = (sqrt(static_cast< ResultType>(a[0])) - sqrt(static_cast< ResultType>(b[0]))); 
# 612
diff1 = (sqrt(static_cast< ResultType>(a[1])) - sqrt(static_cast< ResultType>(b[1]))); 
# 613
diff2 = (sqrt(static_cast< ResultType>(a[2])) - sqrt(static_cast< ResultType>(b[2]))); 
# 614
diff3 = (sqrt(static_cast< ResultType>(a[3])) - sqrt(static_cast< ResultType>(b[3]))); 
# 615
result += ((((diff0 * diff0) + (diff1 * diff1)) + (diff2 * diff2)) + (diff3 * diff3)); 
# 616
a += 4; 
# 617
b += 4; 
# 618
}  
# 619
while (a < last) { 
# 620
diff0 = (sqrt(static_cast< ResultType>(*(a++))) - sqrt(static_cast< ResultType>(*(b++)))); 
# 621
result += (diff0 * diff0); 
# 622
}  
# 623
return result; 
# 624
} 
# 629
template< class U, class V> ResultType 
# 630
accum_dist(const U &a, const V &b, int) const 
# 631
{ 
# 632
ResultType diff = sqrt(static_cast< ResultType>(a)) - sqrt(static_cast< ResultType>(b)); 
# 633
return diff * diff; 
# 634
} 
# 635
}; 
# 638
template< class T> 
# 639
struct ChiSquareDistance { 
# 641
typedef True is_kdtree_distance; 
# 642
typedef True is_vector_space_distance; 
# 644
typedef T ElementType; 
# 645
typedef typename Accumulator< T> ::Type ResultType; 
# 650
template< class Iterator1, class Iterator2> ResultType 
# 651
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 652
{ 
# 653
ResultType result = ResultType(); 
# 654
ResultType sum, diff; 
# 655
Iterator1 last = a + size; 
# 657
while (a < last) { 
# 658
sum = ((ResultType)((*a) + (*b))); 
# 659
if (sum > 0) { 
# 660
diff = ((ResultType)((*a) - (*b))); 
# 661
result += ((diff * diff) / sum); 
# 662
}  
# 663
++a; 
# 664
++b; 
# 666
if ((worst_dist > 0) && (result > worst_dist)) { 
# 667
return result; 
# 668
}  
# 669
}  
# 670
return result; 
# 671
} 
# 676
template< class U, class V> ResultType 
# 677
accum_dist(const U &a, const V &b, int) const 
# 678
{ 
# 679
ResultType result = ResultType(); 
# 680
ResultType sum, diff; 
# 682
sum = ((ResultType)(a + b)); 
# 683
if (sum > 0) { 
# 684
diff = ((ResultType)(a - b)); 
# 685
result = ((diff * diff) / sum); 
# 686
}  
# 687
return result; 
# 688
} 
# 689
}; 
# 692
template< class T> 
# 693
struct KL_Divergence { 
# 695
typedef True is_kdtree_distance; 
# 696
typedef True is_vector_space_distance; 
# 698
typedef T ElementType; 
# 699
typedef typename Accumulator< T> ::Type ResultType; 
# 704
template< class Iterator1, class Iterator2> ResultType 
# 705
operator()(Iterator1 a, Iterator2 b, size_t size, ResultType worst_dist = -1) const 
# 706
{ 
# 707
ResultType result = ResultType(); 
# 708
Iterator1 last = a + size; 
# 710
while (a < last) { 
# 711
if ((*b) != 0) { 
# 712
ResultType ratio = ((ResultType)((*a) / (*b))); 
# 713
if (ratio > 0) { 
# 714
result += ((*a) * log(ratio)); 
# 715
}  
# 716
}  
# 717
++a; 
# 718
++b; 
# 720
if ((worst_dist > 0) && (result > worst_dist)) { 
# 721
return result; 
# 722
}  
# 723
}  
# 724
return result; 
# 725
} 
# 730
template< class U, class V> ResultType 
# 731
accum_dist(const U &a, const V &b, int) const 
# 732
{ 
# 733
ResultType result = ResultType(); 
# 734
if ((*b) != 0) { 
# 735
ResultType ratio = (ResultType)(a / b); 
# 736
if (ratio > 0) { 
# 737
result = (a * log(ratio)); 
# 738
}  
# 739
}  
# 740
return result; 
# 741
} 
# 742
}; 
# 753 "/usr/include/opencv4/opencv2/flann/dist.h" 3
template< class T> 
# 754
struct ZeroIterator { 
# 757
T operator*() 
# 758
{ 
# 759
return 0; 
# 760
} 
# 762
T operator[](int) 
# 763
{ 
# 764
return 0; 
# 765
} 
# 767
const ZeroIterator &operator++() 
# 768
{ 
# 769
return *this; 
# 770
} 
# 772
ZeroIterator operator++(int) 
# 773
{ 
# 774
return *this; 
# 775
} 
# 777
ZeroIterator &operator+=(int) 
# 778
{ 
# 779
return *this; 
# 780
} 
# 782
}; 
# 790
template< class Distance, class ElementType> 
# 791
struct squareDistance { 
# 793
typedef typename Distance::ResultType ResultType; 
# 794
ResultType operator()(ResultType dist) { return dist * dist; } 
# 795
}; 
# 798
template< class ElementType> 
# 799
struct squareDistance< L2_Simple< ElementType> , ElementType>  { 
# 801
typedef typename L2_Simple< ElementType> ::ResultType ResultType; 
# 802
ResultType operator()(ResultType dist) { return dist; } 
# 803
}; 
# 805
template< class ElementType> 
# 806
struct squareDistance< L2< ElementType> , ElementType>  { 
# 808
typedef typename L2< ElementType> ::ResultType ResultType; 
# 809
ResultType operator()(ResultType dist) { return dist; } 
# 810
}; 
# 813
template< class ElementType> 
# 814
struct squareDistance< MinkowskiDistance< ElementType> , ElementType>  { 
# 816
typedef typename MinkowskiDistance< ElementType> ::ResultType ResultType; 
# 817
ResultType operator()(ResultType dist) { return dist; } 
# 818
}; 
# 820
template< class ElementType> 
# 821
struct squareDistance< HellingerDistance< ElementType> , ElementType>  { 
# 823
typedef typename HellingerDistance< ElementType> ::ResultType ResultType; 
# 824
ResultType operator()(ResultType dist) { return dist; } 
# 825
}; 
# 827
template< class ElementType> 
# 828
struct squareDistance< ChiSquareDistance< ElementType> , ElementType>  { 
# 830
typedef typename ChiSquareDistance< ElementType> ::ResultType ResultType; 
# 831
ResultType operator()(ResultType dist) { return dist; } 
# 832
}; 
# 835
template< class Distance> typename Distance::ResultType 
# 836
ensureSquareDistance(typename Distance::ResultType dist) 
# 837
{ 
# 838
typedef typename Distance::ElementType ElementType; 
# 840
squareDistance< Distance, typename Distance::ElementType>  dummy; 
# 841
return dummy(dist); 
# 842
} 
# 850
template< class Distance, class ElementType> 
# 851
struct simpleDistance { 
# 853
typedef typename Distance::ResultType ResultType; 
# 854
ResultType operator()(ResultType dist) { return dist; } 
# 855
}; 
# 858
template< class ElementType> 
# 859
struct simpleDistance< L2_Simple< ElementType> , ElementType>  { 
# 861
typedef typename L2_Simple< ElementType> ::ResultType ResultType; 
# 862
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 863
}; 
# 865
template< class ElementType> 
# 866
struct simpleDistance< L2< ElementType> , ElementType>  { 
# 868
typedef typename L2< ElementType> ::ResultType ResultType; 
# 869
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 870
}; 
# 873
template< class ElementType> 
# 874
struct simpleDistance< MinkowskiDistance< ElementType> , ElementType>  { 
# 876
typedef typename MinkowskiDistance< ElementType> ::ResultType ResultType; 
# 877
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 878
}; 
# 880
template< class ElementType> 
# 881
struct simpleDistance< HellingerDistance< ElementType> , ElementType>  { 
# 883
typedef typename HellingerDistance< ElementType> ::ResultType ResultType; 
# 884
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 885
}; 
# 887
template< class ElementType> 
# 888
struct simpleDistance< ChiSquareDistance< ElementType> , ElementType>  { 
# 890
typedef typename ChiSquareDistance< ElementType> ::ResultType ResultType; 
# 891
ResultType operator()(ResultType dist) { return sqrt(dist); } 
# 892
}; 
# 895
template< class Distance> typename Distance::ResultType 
# 896
ensureSimpleDistance(typename Distance::ResultType dist) 
# 897
{ 
# 898
typedef typename Distance::ElementType ElementType; 
# 900
simpleDistance< Distance, typename Distance::ElementType>  dummy; 
# 901
return dummy(dist); 
# 902
} 
# 904
}
# 53 "/usr/include/opencv4/opencv2/flann/dynamic_bitset.h" 3
namespace cvflann { 
# 59
class DynamicBitset { 
# 64
public: DynamicBitset() : size_((0)) 
# 65
{ 
# 66
} 
# 71
DynamicBitset(size_t sz) 
# 72
{ 
# 73
this->resize(sz); 
# 74
this->reset(); 
# 75
} 
# 79
void clear() 
# 80
{ 
# 81
std::fill((bitset_).begin(), (bitset_).end(), 0); 
# 82
} 
# 87
bool empty() const 
# 88
{ 
# 89
return (bitset_).empty(); 
# 90
} 
# 94
void reset() 
# 95
{ 
# 96
std::fill((bitset_).begin(), (bitset_).end(), 0); 
# 97
} 
# 102
void reset(size_t index) 
# 103
{ 
# 104
(bitset_)[index / cell_bit_size_] &= (~(((size_t)1) << (index % cell_bit_size_))); 
# 105
} 
# 113
void reset_block(size_t index) 
# 114
{ 
# 115
(bitset_)[index / cell_bit_size_] = (0); 
# 116
} 
# 121
void resize(size_t sz) 
# 122
{ 
# 123
(size_) = sz; 
# 124
(bitset_).resize((sz / cell_bit_size_) + (1)); 
# 125
} 
# 130
void set(size_t index) 
# 131
{ 
# 132
(bitset_)[index / cell_bit_size_] |= (((size_t)1) << (index % cell_bit_size_)); 
# 133
} 
# 137
size_t size() const 
# 138
{ 
# 139
return size_; 
# 140
} 
# 146
bool test(size_t index) const 
# 147
{ 
# 148
return ((bitset_)[index / cell_bit_size_] & (((size_t)1) << (index % cell_bit_size_))) != (0); 
# 149
} 
# 152
private: std::vector< unsigned long>  bitset_; 
# 153
size_t size_; 
# 154
static const unsigned cell_bit_size_ = ((8) * sizeof(size_t)); 
# 155
}; 
# 157
}
# 39 "/usr/include/opencv4/opencv2/flann/heap.h" 3
namespace cvflann { 
# 49 "/usr/include/opencv4/opencv2/flann/heap.h" 3
template< class T> 
# 50
class Heap { 
# 57
std::vector< T>  heap; 
# 58
int length; 
# 63
int count; 
# 75
public: Heap(int sz) 
# 76
{ 
# 77
(length) = sz; 
# 78
(heap).reserve(length); 
# 79
(count) = 0; 
# 80
} 
# 86
int size() 
# 87
{ 
# 88
return count; 
# 89
} 
# 96
bool empty() 
# 97
{ 
# 98
return size() == 0; 
# 99
} 
# 104
void clear() 
# 105
{ 
# 106
(heap).clear(); 
# 107
(count) = 0; 
# 108
} 
# 110
struct CompareT { 
# 112
bool operator()(const T &t_1, const T &t_2) const 
# 113
{ 
# 114
return t_2 < t_1; 
# 115
} 
# 116
}; 
# 127 "/usr/include/opencv4/opencv2/flann/heap.h" 3
void insert(T value) 
# 128
{ 
# 130
if ((count) == (length)) { 
# 131
return; 
# 132
}  
# 134
(heap).push_back(value); 
# 135
static CompareT compareT; 
# 136
std::push_heap((heap).begin(), (heap).end(), compareT); 
# 137
++(count); 
# 138
} 
# 149 "/usr/include/opencv4/opencv2/flann/heap.h" 3
bool popMin(T &value) 
# 150
{ 
# 151
if ((count) == 0) { 
# 152
return false; 
# 153
}  
# 155
value = ((heap)[0]); 
# 156
static CompareT compareT; 
# 157
std::pop_heap((heap).begin(), (heap).end(), compareT); 
# 158
(heap).pop_back(); 
# 159
--(count); 
# 161
return true; 
# 162
} 
# 163
}; 
# 165
}
# 40 "/usr/include/opencv4/opencv2/flann/allocator.h" 3
namespace cvflann { 
# 50 "/usr/include/opencv4/opencv2/flann/allocator.h" 3
template< class T> T *
# 51
allocate(size_t count = 1) 
# 52
{ 
# 53
T *mem = (T *)::malloc(sizeof(T) * count); 
# 54
return mem; 
# 55
} 
# 73 "/usr/include/opencv4/opencv2/flann/allocator.h" 3
const size_t WORDSIZE = (16); 
# 74
const size_t BLOCKSIZE = (8192); 
# 76
class PooledAllocator { 
# 84
int remaining; 
# 85
void *base; 
# 86
void *loc; 
# 87
int blocksize; 
# 91
public: int usedMemory; 
# 92
int wastedMemory; 
# 97
PooledAllocator(int blockSize = BLOCKSIZE) 
# 98
{ 
# 99
(blocksize) = blockSize; 
# 100
(remaining) = 0; 
# 101
(base) = (__null); 
# 102
(loc) = (__null); 
# 104
(usedMemory) = 0; 
# 105
(wastedMemory) = 0; 
# 106
} 
# 111
~PooledAllocator() 
# 112
{ 
# 113
void *prev; 
# 115
while ((base) != (__null)) { 
# 116
prev = (*((void **)(base))); 
# 117
::free(base); 
# 118
(base) = prev; 
# 119
}  
# 120
} 
# 126
void *allocateMemory(int size) 
# 127
{ 
# 128
int blockSize; 
# 134
size = ((size + (WORDSIZE - (1))) & (~(WORDSIZE - (1)))); 
# 139
if (size > (remaining)) { 
# 141
(wastedMemory) += (remaining); 
# 144
blockSize = ((((size + sizeof(void *)) + (WORDSIZE - (1))) > BLOCKSIZE) ? (size + sizeof(void *)) + (WORDSIZE - (1)) : BLOCKSIZE); 
# 148
void *m = ::malloc(blockSize); 
# 149
if (!m) { 
# 150
fprintf(stderr, "Failed to allocate memory.\n"); 
# 151
return __null; 
# 152
}  
# 155
(((void **)m)[0]) = (base); 
# 156
(base) = m; 
# 158
int shift = 0; 
# 161
(remaining) = ((blockSize - sizeof(void *)) - shift); 
# 162
(loc) = ((((char *)m) + sizeof(void *)) + shift); 
# 163
}  
# 164
void *rloc = loc; 
# 165
(loc) = (((char *)(loc)) + size); 
# 166
(remaining) -= size; 
# 168
(usedMemory) += size; 
# 170
return rloc; 
# 171
} 
# 180 "/usr/include/opencv4/opencv2/flann/allocator.h" 3
template< class T> T *
# 181
allocate(size_t count = 1) 
# 182
{ 
# 183
T *mem = (T *)this->allocateMemory((int)(sizeof(T) * count)); 
# 184
return mem; 
# 185
} 
# 188
private: PooledAllocator(const PooledAllocator &); 
# 189
PooledAllocator &operator=(const PooledAllocator &); 
# 190
}; 
# 192
}
# 42 "/usr/include/opencv4/opencv2/flann/random.h" 3
namespace cvflann { 
# 45
inline int rand() 
# 46
{ 
# 49
int v = cv::theRNG().next() & (2147483647); 
# 56
return v; 
# 57
} 
# 63
inline void seed_random(unsigned seed) 
# 64
{ 
# 66
cv::theRNG() = ((cv::RNG)(seed)); 
# 70
} 
# 81 "/usr/include/opencv4/opencv2/flann/random.h" 3
inline double rand_double(double high = (1.0), double low = 0) 
# 82
{ 
# 83
return low + ((high - low) * ((rand()) / ((2147483647) + (1.0)))); 
# 84
} 
# 92
inline int rand_int(int high = 2147483647, int low = 0) 
# 93
{ 
# 94
return low + ((int)(((double)(high - low)) * ((rand()) / ((2147483647) + (1.0))))); 
# 95
} 
# 101
class UniqueRandom { 
# 103
std::vector< int>  vals_; 
# 104
int size_; 
# 105
int counter_; 
# 113
public: UniqueRandom(int n) 
# 114
{ 
# 115
this->init(n); 
# 116
} 
# 122
void init(int n) 
# 123
{ 
# 125
(vals_).resize(n); 
# 126
(size_) = n; 
# 127
for (int i = 0; i < (size_); ++i) { (vals_)[i] = i; }  
# 131
cv::randShuffle(vals_); 
# 136
(counter_) = 0; 
# 137
} 
# 144
int next() 
# 145
{ 
# 146
if ((counter_) == (size_)) { 
# 147
return -1; 
# 148
} else 
# 149
{ 
# 150
return (vals_)[(counter_)++]; 
# 151
}  
# 152
} 
# 153
}; 
# 155
}
# 52 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
namespace cvflann { 
# 55
struct KDTreeIndexParams : public IndexParams { 
# 57
KDTreeIndexParams(int trees = 4) 
# 58
{ 
# 59
(((*this)["algorithm"]) = (FLANN_INDEX_KDTREE)); 
# 60
(((*this)["trees"]) = trees); 
# 61
} 
# 62
}; 
# 71 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
template< class Distance> 
# 72
class KDTreeIndex : public NNIndex< Distance>  { 
# 75
public: typedef typename Distance::ElementType ElementType; 
# 76
typedef typename Distance::ResultType DistanceType; 
# 86 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
KDTreeIndex(const Matrix< ElementType>  &inputData, const cvflann::IndexParams &params = cvflann::KDTreeIndexParams(), Distance 
# 87
d = Distance()) : dataset_(inputData), index_params_(params), distance_(d) 
# 89
{ 
# 90
(size_) = ((dataset_).rows); 
# 91
(veclen_) = ((dataset_).cols); 
# 93
(trees_) = get_param(index_params_, "trees", 4); 
# 94
(tree_roots_) = (new NodePtr [trees_]); 
# 97
(vind_).resize(size_); 
# 98
for (::size_t i = (0); i < (size_); ++i) { 
# 99
(vind_)[i] = ((int)i); 
# 100
}  
# 102
(mean_) = (new DistanceType [veclen_]); 
# 103
(var_) = (new DistanceType [veclen_]); 
# 104
} 
# 107
KDTreeIndex(const KDTreeIndex &); 
# 108
KDTreeIndex &operator=(const KDTreeIndex &); 
# 113
~KDTreeIndex() 
# 114
{ 
# 115
if ((tree_roots_) != __null) { 
# 116
delete [] (tree_roots_); 
# 117
}  
# 118
delete [] (mean_); 
# 119
delete [] (var_); 
# 120
} 
# 125
void buildIndex() override 
# 126
{ 
# 128
for (int i = 0; i < (trees_); i++) { 
# 131
cv::randShuffle(vind_); 
# 136
((tree_roots_)[i]) = divideTree(&(vind_)[0], (int)(size_)); 
# 137
}  
# 138
} 
# 141
cvflann::flann_algorithm_t getType() const override 
# 142
{ 
# 143
return FLANN_INDEX_KDTREE; 
# 144
} 
# 147
void saveIndex(::FILE *stream) override 
# 148
{ 
# 149
save_value(stream, trees_); 
# 150
for (int i = 0; i < (trees_); ++i) { 
# 151
save_tree(stream, (tree_roots_)[i]); 
# 152
}  
# 153
} 
# 157
void loadIndex(::FILE *stream) override 
# 158
{ 
# 159
load_value(stream, trees_); 
# 160
if ((tree_roots_) != __null) { 
# 161
delete [] (tree_roots_); 
# 162
}  
# 163
(tree_roots_) = (new NodePtr [trees_]); 
# 164
for (int i = 0; i < (trees_); ++i) { 
# 165
load_tree(stream, (tree_roots_)[i]); 
# 166
}  
# 168
(index_params_)["algorithm"] = getType(); 
# 169
(index_params_)["trees"] = (tree_roots_); 
# 170
} 
# 175
::size_t size() const override 
# 176
{ 
# 177
return size_; 
# 178
} 
# 183
::size_t veclen() const override 
# 184
{ 
# 185
return veclen_; 
# 186
} 
# 192
int usedMemory() const override 
# 193
{ 
# 194
return (int)((((pool_).usedMemory) + ((pool_).wastedMemory)) + (((dataset_).rows) * sizeof(int))); 
# 195
} 
# 206 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
void findNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, const cvflann::SearchParams &searchParams) override 
# 207
{ 
# 208
int maxChecks = get_param(searchParams, "checks", 32); 
# 209
float epsError = (1) + get_param(searchParams, "eps", (0.0F)); 
# 211
if (maxChecks == (FLANN_CHECKS_UNLIMITED)) { 
# 212
getExactNeighbors(result, vec, epsError); 
# 213
} else 
# 214
{ 
# 215
getNeighbors(result, vec, maxChecks, epsError); 
# 216
}  
# 217
} 
# 219
cvflann::IndexParams getParameters() const override 
# 220
{ 
# 221
return index_params_; 
# 222
} 
# 228
private: struct Node { 
# 233
int divfeat; 
# 237
DistanceType divval; 
# 241
Node *child1, *child2; 
# 242
}; 
# 243
typedef Node *NodePtr; 
# 244
typedef BranchStruct< NodePtr, DistanceType>  BranchSt; 
# 245
typedef BranchSt *Branch; 
# 249
void save_tree(::FILE *stream, NodePtr tree) 
# 250
{ 
# 251
save_value(stream, *tree); 
# 252
if ((tree->child1) != __null) { 
# 253
save_tree(stream, (tree->child1)); 
# 254
}  
# 255
if ((tree->child2) != __null) { 
# 256
save_tree(stream, (tree->child2)); 
# 257
}  
# 258
} 
# 261
void load_tree(::FILE *stream, NodePtr &tree) 
# 262
{ 
# 263
tree = (pool_).template allocate< Node> (); 
# 264
load_value(stream, *tree); 
# 265
if ((tree->child1) != __null) { 
# 266
load_tree(stream, (tree->child1)); 
# 267
}  
# 268
if ((tree->child2) != __null) { 
# 269
load_tree(stream, (tree->child2)); 
# 270
}  
# 271
} 
# 283 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
NodePtr divideTree(int *ind, int count) 
# 284
{ 
# 285
NodePtr node = (pool_).template allocate< Node> (); 
# 288
if (count == 1) { 
# 289
(node->child1) = ((node->child2) = __null); 
# 290
(node->divfeat) = (*ind); 
# 291
} else 
# 292
{ 
# 293
int idx; 
# 294
int cutfeat; 
# 295
DistanceType cutval; 
# 296
meanSplit(ind, count, idx, cutfeat, cutval); 
# 298
(node->divfeat) = cutfeat; 
# 299
(node->divval) = cutval; 
# 300
(node->child1) = divideTree(ind, idx); 
# 301
(node->child2) = divideTree(ind + idx, count - idx); 
# 302
}  
# 304
return node; 
# 305
} 
# 313
void meanSplit(int *ind, int count, int &index, int &cutfeat, DistanceType &cutval) 
# 314
{ 
# 315
memset(mean_, 0, (veclen_) * sizeof(DistanceType)); 
# 316
memset(var_, 0, (veclen_) * sizeof(DistanceType)); 
# 321
int cnt = std::min(((int)SAMPLE_MEAN) + 1, count); 
# 322
for (int j = 0; j < cnt; ++j) { 
# 323
ElementType *v = (dataset_)[ind[j]]; 
# 324
for (::size_t k = (0); k < (veclen_); ++k) { 
# 325
((mean_)[k]) += (v[k]); 
# 326
}  
# 327
}  
# 328
for (::size_t k = (0); k < (veclen_); ++k) { 
# 329
((mean_)[k]) /= cnt; 
# 330
}  
# 333
for (int j = 0; j < cnt; ++j) { 
# 334
ElementType *v = (dataset_)[ind[j]]; 
# 335
for (::size_t k = (0); k < (veclen_); ++k) { 
# 336
DistanceType dist = (v[k]) - ((mean_)[k]); 
# 337
((var_)[k]) += (dist * dist); 
# 338
}  
# 339
}  
# 341
cutfeat = selectDivision(var_); 
# 342
cutval = ((mean_)[cutfeat]); 
# 344
int lim1, lim2; 
# 345
planeSplit(ind, count, cutfeat, cutval, lim1, lim2); 
# 347
if (lim1 > (count / 2)) { index = lim1; } else { 
# 348
if (lim2 < (count / 2)) { index = lim2; } else { 
# 349
index = (count / 2); }  }  
# 354
if ((lim1 == count) || (lim2 == 0)) { index = (count / 2); }  
# 355
} 
# 362
int selectDivision(DistanceType *v) 
# 363
{ 
# 364
int num = 0; 
# 365
::size_t topind[RAND_DIM]; 
# 368
for (::size_t i = (0); i < (veclen_); ++i) { 
# 369
if ((num < RAND_DIM) || ((v[i]) > (v[topind[num - 1]]))) { 
# 371
if (num < RAND_DIM) { 
# 372
(topind[num++]) = i; 
# 373
} else 
# 374
{ 
# 375
(topind[num - 1]) = i; 
# 376
}  
# 378
int j = num - 1; 
# 379
while ((j > 0) && ((v[topind[j]]) > (v[topind[j - 1]]))) { 
# 380
std::swap(topind[j], topind[j - 1]); 
# 381
--j; 
# 382
}  
# 383
}  
# 384
}  
# 386
int rnd = rand_int(num); 
# 387
return (int)(topind[rnd]); 
# 388
} 
# 400 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
void planeSplit(int *ind, int count, int cutfeat, DistanceType cutval, int &lim1, int &lim2) 
# 401
{ 
# 403
int left = 0; 
# 404
int right = count - 1; 
# 405
for (; ;) { 
# 406
while ((left <= right) && ((((dataset_)[ind[left]])[cutfeat]) < cutval)) { ++left; }  
# 407
while ((left <= right) && ((((dataset_)[ind[right]])[cutfeat]) >= cutval)) { --right; }  
# 408
if (left > right) { break; }  
# 409
std::swap(ind[left], ind[right]); ++left; --right; 
# 410
}  
# 411
lim1 = left; 
# 412
right = (count - 1); 
# 413
for (; ;) { 
# 414
while ((left <= right) && ((((dataset_)[ind[left]])[cutfeat]) <= cutval)) { ++left; }  
# 415
while ((left <= right) && ((((dataset_)[ind[right]])[cutfeat]) > cutval)) { --right; }  
# 416
if (left > right) { break; }  
# 417
std::swap(ind[left], ind[right]); ++left; --right; 
# 418
}  
# 419
lim2 = left; 
# 420
} 
# 426
void getExactNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, float epsError) 
# 427
{ 
# 430
if ((trees_) > 1) { 
# 431
fprintf(stderr, "It doesn\'t make any sense to use more than one tree for exact search"); 
# 432
}  
# 433
if ((trees_) > 0) { 
# 434
searchLevelExact(result, vec, (tree_roots_)[0], (0.0), epsError); 
# 435
}  
# 436
(static_cast< bool>(result.full())) ? (void)0 : __assert_fail("result.full()", "/usr/include/opencv4/opencv2/flann/kdtree_index.h", 436, __extension__ __PRETTY_FUNCTION__); 
# 437
} 
# 444
void getNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, int maxCheck, float epsError) 
# 445
{ 
# 446
int i; 
# 447
BranchSt branch; 
# 449
int checkCount = 0; 
# 450
Heap< BranchSt>  *heap = new Heap< BranchSt> ((int)(size_)); 
# 451
cvflann::DynamicBitset checked(size_); 
# 454
for (i = 0; i < (trees_); ++i) { 
# 455
searchLevel(result, vec, (tree_roots_)[i], 0, checkCount, maxCheck, epsError, heap, checked); 
# 456
}  
# 459
while (heap->popMin(branch) && ((checkCount < maxCheck) || (!result.full()))) { 
# 460
searchLevel(result, vec, (branch.node), (branch.mindist), checkCount, maxCheck, epsError, heap, checked); 
# 461
}  
# 463
delete heap; 
# 465
(static_cast< bool>(result.full())) ? (void)0 : __assert_fail("result.full()", "/usr/include/opencv4/opencv2/flann/kdtree_index.h", 465, __extension__ __PRETTY_FUNCTION__); 
# 466
} 
# 474
void searchLevel(ResultSet< DistanceType>  &result_set, const ElementType *vec, NodePtr node, DistanceType mindist, int &checkCount, int maxCheck, float 
# 475
epsError, Heap< BranchSt>  *heap, cvflann::DynamicBitset &checked) 
# 476
{ 
# 477
if (result_set.worstDist() < mindist) { 
# 479
return; 
# 480
}  
# 483
if (((node->child1) == __null) && ((node->child2) == __null)) { 
# 488
int index = ((node->divfeat)); 
# 489
if (checked.test(index) || ((checkCount >= maxCheck) && result_set.full())) { return; }  
# 490
checked.set(index); 
# 491
checkCount++; 
# 493
DistanceType dist = (distance_)((dataset_)[index], vec, veclen_); 
# 494
result_set.addPoint(dist, index); 
# 496
return; 
# 497
}  
# 500
ElementType val = vec[node->divfeat]; 
# 501
DistanceType diff = val - (node->divval); 
# 502
NodePtr bestChild = (diff < 0) ? node->child1 : (node->child2); 
# 503
NodePtr otherChild = (diff < 0) ? node->child2 : (node->child1); 
# 513 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
DistanceType new_distsq = mindist + (distance_).accum_dist(val, (node->divval), (node->divfeat)); 
# 515
if (((new_distsq * epsError) < result_set.worstDist()) || (!result_set.full())) { 
# 516
heap->insert(BranchSt(otherChild, new_distsq)); 
# 517
}  
# 520
searchLevel(result_set, vec, bestChild, mindist, checkCount, maxCheck, epsError, heap, checked); 
# 521
} 
# 526
void searchLevelExact(ResultSet< DistanceType>  &result_set, const ElementType *vec, const NodePtr node, DistanceType mindist, const float epsError) 
# 527
{ 
# 529
if (((node->child1) == __null) && ((node->child2) == __null)) { 
# 530
int index = ((node->divfeat)); 
# 531
DistanceType dist = (distance_)((dataset_)[index], vec, veclen_); 
# 532
result_set.addPoint(dist, index); 
# 533
return; 
# 534
}  
# 537
ElementType val = vec[node->divfeat]; 
# 538
DistanceType diff = val - (node->divval); 
# 539
NodePtr bestChild = (diff < 0) ? node->child1 : (node->child2); 
# 540
NodePtr otherChild = (diff < 0) ? node->child2 : (node->child1); 
# 550 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
DistanceType new_distsq = mindist + (distance_).accum_dist(val, (node->divval), (node->divfeat)); 
# 553
searchLevelExact(result_set, vec, bestChild, mindist, epsError); 
# 555
if ((new_distsq * epsError) <= result_set.worstDist()) { 
# 556
searchLevelExact(result_set, vec, otherChild, new_distsq, epsError); 
# 557
}  
# 558
} 
# 564
enum { 
# 570
SAMPLE_MEAN = 100, 
# 578
RAND_DIM = 5
# 579
}; 
# 585
int trees_; 
# 590
std::vector< int>  vind_; 
# 595
const Matrix< ElementType>  dataset_; 
# 597
cvflann::IndexParams index_params_; 
# 599
::size_t size_; 
# 600
::size_t veclen_; 
# 603
DistanceType *mean_; 
# 604
DistanceType *var_; 
# 610
NodePtr *tree_roots_; 
# 619 "/usr/include/opencv4/opencv2/flann/kdtree_index.h" 3
cvflann::PooledAllocator pool_; 
# 621
Distance distance_; 
# 624
}; 
# 626
}
# 50 "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h" 3
namespace cvflann { 
# 53
struct KDTreeSingleIndexParams : public IndexParams { 
# 55
KDTreeSingleIndexParams(int leaf_max_size = 10, bool reorder = true, int dim = -1) 
# 56
{ 
# 57
(((*this)["algorithm"]) = (FLANN_INDEX_KDTREE_SINGLE)); 
# 58
(((*this)["leaf_max_size"]) = leaf_max_size); 
# 59
(((*this)["reorder"]) = reorder); 
# 60
(((*this)["dim"]) = dim); 
# 61
} 
# 62
}; 
# 71 "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h" 3
template< class Distance> 
# 72
class KDTreeSingleIndex : public NNIndex< Distance>  { 
# 75
public: typedef typename Distance::ElementType ElementType; 
# 76
typedef typename Distance::ResultType DistanceType; 
# 86 "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h" 3
KDTreeSingleIndex(const Matrix< ElementType>  &inputData, const cvflann::IndexParams &params = cvflann::KDTreeSingleIndexParams(), Distance 
# 87
d = Distance()) : dataset_(inputData), index_params_(params), distance_(d) 
# 89
{ 
# 90
(size_) = ((dataset_).rows); 
# 91
(dim_) = ((dataset_).cols); 
# 92
(root_node_) = 0; 
# 93
int dim_param = get_param(params, "dim", -1); 
# 94
if (dim_param > 0) { (dim_) = dim_param; }  
# 95
(leaf_max_size_) = get_param(params, "leaf_max_size", 10); 
# 96
(reorder_) = get_param(params, "reorder", true); 
# 99
(vind_).resize(size_); 
# 100
for (::size_t i = (0); i < (size_); i++) { 
# 101
(vind_)[i] = ((int)i); 
# 102
}  
# 103
} 
# 105
KDTreeSingleIndex(const KDTreeSingleIndex &); 
# 106
KDTreeSingleIndex &operator=(const KDTreeSingleIndex &); 
# 111
~KDTreeSingleIndex() 
# 112
{ 
# 113
if (reorder_) { delete [] ((data_).data); }  
# 114
} 
# 119
void buildIndex() override 
# 120
{ 
# 121
computeBoundingBox(root_bbox_); 
# 122
(root_node_) = divideTree(0, (int)(size_), root_bbox_); 
# 124
if (reorder_) { 
# 125
delete [] ((data_).data); 
# 126
(data_) = Matrix< typename Distance::ElementType> (new ElementType [(size_) * (dim_)], size_, dim_); 
# 127
for (::size_t i = (0); i < (size_); ++i) { 
# 128
for (::size_t j = (0); j < (dim_); ++j) { 
# 129
(((data_)[i])[j]) = (((dataset_)[(vind_)[i]])[j]); 
# 130
}  
# 131
}  
# 132
} else 
# 133
{ 
# 134
(data_) = (dataset_); 
# 135
}  
# 136
} 
# 138
cvflann::flann_algorithm_t getType() const override 
# 139
{ 
# 140
return FLANN_INDEX_KDTREE_SINGLE; 
# 141
} 
# 144
void saveIndex(::FILE *stream) override 
# 145
{ 
# 146
save_value(stream, size_); 
# 147
save_value(stream, dim_); 
# 148
save_value(stream, root_bbox_); 
# 149
save_value(stream, reorder_); 
# 150
save_value(stream, leaf_max_size_); 
# 151
save_value(stream, vind_); 
# 152
if (reorder_) { 
# 153
save_value(stream, data_); 
# 154
}  
# 155
save_tree(stream, root_node_); 
# 156
} 
# 159
void loadIndex(::FILE *stream) override 
# 160
{ 
# 161
load_value(stream, size_); 
# 162
load_value(stream, dim_); 
# 163
load_value(stream, root_bbox_); 
# 164
load_value(stream, reorder_); 
# 165
load_value(stream, leaf_max_size_); 
# 166
load_value(stream, vind_); 
# 167
if (reorder_) { 
# 168
load_value(stream, data_); 
# 169
} else 
# 170
{ 
# 171
(data_) = (dataset_); 
# 172
}  
# 173
load_tree(stream, root_node_); 
# 176
(index_params_)["algorithm"] = getType(); 
# 177
(((index_params_)["leaf_max_size"]) = (leaf_max_size_)); 
# 178
(((index_params_)["reorder"]) = (reorder_)); 
# 179
} 
# 184
::size_t size() const override 
# 185
{ 
# 186
return size_; 
# 187
} 
# 192
::size_t veclen() const override 
# 193
{ 
# 194
return dim_; 
# 195
} 
# 201
int usedMemory() const override 
# 202
{ 
# 203
return (int)((((pool_).usedMemory) + ((pool_).wastedMemory)) + (((dataset_).rows) * sizeof(int))); 
# 204
} 
# 215 "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h" 3
void knnSearch(const Matrix< ElementType>  &queries, cvflann::Matrix< int>  &indices, Matrix< DistanceType>  &dists, int knn, const cvflann::SearchParams &params) override 
# 216
{ 
# 217
(static_cast< bool>((queries.cols) == veclen())) ? (void)0 : __assert_fail("queries.cols == veclen()", "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h", 217, __extension__ __PRETTY_FUNCTION__); 
# 218
(static_cast< bool>((indices.rows) >= (queries.rows))) ? (void)0 : __assert_fail("indices.rows >= queries.rows", "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h", 218, __extension__ __PRETTY_FUNCTION__); 
# 219
(static_cast< bool>((dists.rows) >= (queries.rows))) ? (void)0 : __assert_fail("dists.rows >= queries.rows", "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h", 219, __extension__ __PRETTY_FUNCTION__); 
# 220
(static_cast< bool>(((int)(indices.cols)) >= knn)) ? (void)0 : __assert_fail("int(indices.cols) >= knn", "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h", 220, __extension__ __PRETTY_FUNCTION__); 
# 221
(static_cast< bool>(((int)(dists.cols)) >= knn)) ? (void)0 : __assert_fail("int(dists.cols) >= knn", "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h", 221, __extension__ __PRETTY_FUNCTION__); 
# 223
KNNSimpleResultSet< DistanceType>  resultSet(knn); 
# 224
for (::size_t i = (0); i < (queries.rows); i++) { 
# 225
resultSet.init(indices[i], dists[i]); 
# 226
findNeighbors(resultSet, queries[i], params); 
# 227
}  
# 228
} 
# 230
cvflann::IndexParams getParameters() const override 
# 231
{ 
# 232
return index_params_; 
# 233
} 
# 244 "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h" 3
void findNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, const cvflann::SearchParams &searchParams) override 
# 245
{ 
# 246
float epsError = (1) + get_param(searchParams, "eps", (0.0F)); 
# 248
std::vector< DistanceType>  dists(dim_, 0); 
# 249
DistanceType distsq = computeInitialDistances(vec, dists); 
# 250
searchLevel(result, vec, root_node_, distsq, dists, epsError); 
# 251
} 
# 257
private: struct Node { 
# 262
int left, right; 
# 266
int divfeat; 
# 270
DistanceType divlow, divhigh; 
# 274
Node *child1, *child2; 
# 275
}; 
# 276
typedef Node *NodePtr; 
# 279
struct Interval { 
# 281
DistanceType low, high; 
# 282
}; 
# 284
typedef std::vector< Interval>  BoundingBox; 
# 286
typedef BranchStruct< NodePtr, DistanceType>  BranchSt; 
# 287
typedef BranchSt *Branch; 
# 292
void save_tree(::FILE *stream, NodePtr tree) 
# 293
{ 
# 294
save_value(stream, *tree); 
# 295
if ((tree->child1) != __null) { 
# 296
save_tree(stream, (tree->child1)); 
# 297
}  
# 298
if ((tree->child2) != __null) { 
# 299
save_tree(stream, (tree->child2)); 
# 300
}  
# 301
} 
# 304
void load_tree(::FILE *stream, NodePtr &tree) 
# 305
{ 
# 306
tree = (pool_).template allocate< Node> (); 
# 307
load_value(stream, *tree); 
# 308
if ((tree->child1) != __null) { 
# 309
load_tree(stream, (tree->child1)); 
# 310
}  
# 311
if ((tree->child2) != __null) { 
# 312
load_tree(stream, (tree->child2)); 
# 313
}  
# 314
} 
# 317
void computeBoundingBox(BoundingBox &bbox) 
# 318
{ 
# 319
bbox.resize(dim_); 
# 320
for (::size_t i = (0); i < (dim_); ++i) { 
# 321
((bbox[i]).low) = ((DistanceType)(((dataset_)[0])[i])); 
# 322
((bbox[i]).high) = ((DistanceType)(((dataset_)[0])[i])); 
# 323
}  
# 324
for (::size_t k = (1); k < ((dataset_).rows); ++k) { 
# 325
for (::size_t i = (0); i < (dim_); ++i) { 
# 326
if ((((dataset_)[k])[i]) < ((bbox[i]).low)) { ((bbox[i]).low) = ((DistanceType)(((dataset_)[k])[i])); }  
# 327
if ((((dataset_)[k])[i]) > ((bbox[i]).high)) { ((bbox[i]).high) = ((DistanceType)(((dataset_)[k])[i])); }  
# 328
}  
# 329
}  
# 330
} 
# 342 "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h" 3
NodePtr divideTree(int left, int right, BoundingBox &bbox) 
# 343
{ 
# 344
NodePtr node = (pool_).template allocate< Node> (); 
# 347
if ((right - left) <= (leaf_max_size_)) { 
# 348
(node->child1) = ((node->child2) = __null); 
# 349
(node->left) = left; 
# 350
(node->right) = right; 
# 353
for (::size_t i = (0); i < (dim_); ++i) { 
# 354
((bbox[i]).low) = ((DistanceType)(((dataset_)[(vind_)[left]])[i])); 
# 355
((bbox[i]).high) = ((DistanceType)(((dataset_)[(vind_)[left]])[i])); 
# 356
}  
# 357
for (int k = left + 1; k < right; ++k) { 
# 358
for (::size_t i = (0); i < (dim_); ++i) { 
# 359
if (((bbox[i]).low) > (((dataset_)[(vind_)[k]])[i])) { ((bbox[i]).low) = ((DistanceType)(((dataset_)[(vind_)[k]])[i])); }  
# 360
if (((bbox[i]).high) < (((dataset_)[(vind_)[k]])[i])) { ((bbox[i]).high) = ((DistanceType)(((dataset_)[(vind_)[k]])[i])); }  
# 361
}  
# 362
}  
# 363
} else 
# 364
{ 
# 365
int idx; 
# 366
int cutfeat; 
# 367
DistanceType cutval; 
# 368
middleSplit_((&(vind_)[0]) + left, right - left, idx, cutfeat, cutval, bbox); 
# 370
(node->divfeat) = cutfeat; 
# 372
BoundingBox left_bbox(bbox); 
# 373
((left_bbox[cutfeat]).high) = cutval; 
# 374
(node->child1) = divideTree(left, left + idx, left_bbox); 
# 376
BoundingBox right_bbox(bbox); 
# 377
((right_bbox[cutfeat]).low) = cutval; 
# 378
(node->child2) = divideTree(left + idx, right, right_bbox); 
# 380
(node->divlow) = ((left_bbox[cutfeat]).high); 
# 381
(node->divhigh) = ((right_bbox[cutfeat]).low); 
# 383
for (::size_t i = (0); i < (dim_); ++i) { 
# 384
((bbox[i]).low) = std::min(((left_bbox[i]).low), ((right_bbox[i]).low)); 
# 385
((bbox[i]).high) = std::max(((left_bbox[i]).high), ((right_bbox[i]).high)); 
# 386
}  
# 387
}  
# 389
return node; 
# 390
} 
# 392
void computeMinMax(int *ind, int count, int dim, ElementType &min_elem, ElementType &max_elem) 
# 393
{ 
# 394
min_elem = (((dataset_)[ind[0]])[dim]); 
# 395
max_elem = (((dataset_)[ind[0]])[dim]); 
# 396
for (int i = 1; i < count; ++i) { 
# 397
ElementType val = ((dataset_)[ind[i]])[dim]; 
# 398
if (val < min_elem) { min_elem = val; }  
# 399
if (val > max_elem) { max_elem = val; }  
# 400
}  
# 401
} 
# 403
void middleSplit(int *ind, int count, int &index, int &cutfeat, DistanceType &cutval, const BoundingBox &bbox) 
# 404
{ 
# 406
ElementType max_span = ((bbox[0]).high) - ((bbox[0]).low); 
# 407
cutfeat = 0; 
# 408
cutval = ((((bbox[0]).high) + ((bbox[0]).low)) / 2); 
# 409
for (::size_t i = (1); i < (dim_); ++i) { 
# 410
ElementType span = ((bbox[i]).high) - ((bbox[i]).low); 
# 411
if (span > max_span) { 
# 412
max_span = span; 
# 413
cutfeat = i; 
# 414
cutval = ((((bbox[i]).high) + ((bbox[i]).low)) / 2); 
# 415
}  
# 416
}  
# 419
ElementType min_elem, max_elem; 
# 420
computeMinMax(ind, count, cutfeat, min_elem, max_elem); 
# 421
cutval = ((min_elem + max_elem) / 2); 
# 422
max_span = (max_elem - min_elem); 
# 425
::size_t k = cutfeat; 
# 426
for (::size_t i = (0); i < (dim_); ++i) { 
# 427
if (i == k) { continue; }  
# 428
ElementType span = ((bbox[i]).high) - ((bbox[i]).low); 
# 429
if (span > max_span) { 
# 430
computeMinMax(ind, count, i, min_elem, max_elem); 
# 431
span = (max_elem - min_elem); 
# 432
if (span > max_span) { 
# 433
max_span = span; 
# 434
cutfeat = i; 
# 435
cutval = ((min_elem + max_elem) / 2); 
# 436
}  
# 437
}  
# 438
}   
# 439
int lim1, lim2; 
# 440
planeSplit(ind, count, cutfeat, cutval, lim1, lim2); 
# 442
if (lim1 > (count / 2)) { index = lim1; } else { 
# 443
if (lim2 < (count / 2)) { index = lim2; } else { 
# 444
index = (count / 2); }  }  
# 445
} 
# 448
void middleSplit_(int *ind, int count, int &index, int &cutfeat, DistanceType &cutval, const BoundingBox &bbox) 
# 449
{ 
# 450
const float EPS = (1.0E-5F); 
# 451
DistanceType max_span = ((bbox[0]).high) - ((bbox[0]).low); 
# 452
for (::size_t i = (1); i < (dim_); ++i) { 
# 453
DistanceType span = ((bbox[i]).high) - ((bbox[i]).low); 
# 454
if (span > max_span) { 
# 455
max_span = span; 
# 456
}  
# 457
}  
# 458
DistanceType max_spread = (-1); 
# 459
cutfeat = 0; 
# 460
for (::size_t i = (0); i < (dim_); ++i) { 
# 461
DistanceType span = ((bbox[i]).high) - ((bbox[i]).low); 
# 462
if (span > ((DistanceType)(((1) - EPS) * max_span))) { 
# 463
ElementType min_elem, max_elem; 
# 464
computeMinMax(ind, count, cutfeat, min_elem, max_elem); 
# 465
DistanceType spread = (DistanceType)(max_elem - min_elem); 
# 466
if (spread > max_spread) { 
# 467
cutfeat = ((int)i); 
# 468
max_spread = spread; 
# 469
}  
# 470
}  
# 471
}  
# 473
DistanceType split_val = (((bbox[cutfeat]).low) + ((bbox[cutfeat]).high)) / 2; 
# 474
ElementType min_elem, max_elem; 
# 475
computeMinMax(ind, count, cutfeat, min_elem, max_elem); 
# 477
if (split_val < min_elem) { cutval = ((DistanceType)min_elem); } else { 
# 478
if (split_val > max_elem) { cutval = ((DistanceType)max_elem); } else { 
# 479
cutval = split_val; }  }  
# 481
int lim1, lim2; 
# 482
planeSplit(ind, count, cutfeat, cutval, lim1, lim2); 
# 484
if (lim1 > (count / 2)) { index = lim1; } else { 
# 485
if (lim2 < (count / 2)) { index = lim2; } else { 
# 486
index = (count / 2); }  }  
# 487
} 
# 499 "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h" 3
void planeSplit(int *ind, int count, int cutfeat, DistanceType cutval, int &lim1, int &lim2) 
# 500
{ 
# 502
int left = 0; 
# 503
int right = count - 1; 
# 504
for (; ;) { 
# 505
while ((left <= right) && ((((dataset_)[ind[left]])[cutfeat]) < cutval)) { ++left; }  
# 506
while ((left <= right) && ((((dataset_)[ind[right]])[cutfeat]) >= cutval)) { --right; }  
# 507
if (left > right) { break; }  
# 508
std::swap(ind[left], ind[right]); ++left; --right; 
# 509
}  
# 513
lim1 = left; 
# 514
right = (count - 1); 
# 515
for (; ;) { 
# 516
while ((left <= right) && ((((dataset_)[ind[left]])[cutfeat]) <= cutval)) { ++left; }  
# 517
while ((left <= right) && ((((dataset_)[ind[right]])[cutfeat]) > cutval)) { --right; }  
# 518
if (left > right) { break; }  
# 519
std::swap(ind[left], ind[right]); ++left; --right; 
# 520
}  
# 521
lim2 = left; 
# 522
} 
# 524
DistanceType computeInitialDistances(const ElementType *vec, std::vector< DistanceType>  &dists) 
# 525
{ 
# 526
DistanceType distsq = ((0.0)); 
# 528
for (::size_t i = (0); i < (dim_); ++i) { 
# 529
if ((vec[i]) < (((root_bbox_)[i]).low)) { 
# 530
(dists[i]) = (distance_).accum_dist(vec[i], (((root_bbox_)[i]).low), (int)i); 
# 531
distsq += (dists[i]); 
# 532
}  
# 533
if ((vec[i]) > (((root_bbox_)[i]).high)) { 
# 534
(dists[i]) = (distance_).accum_dist(vec[i], (((root_bbox_)[i]).high), (int)i); 
# 535
distsq += (dists[i]); 
# 536
}  
# 537
}  
# 539
return distsq; 
# 540
} 
# 545
void searchLevel(ResultSet< DistanceType>  &result_set, const ElementType *vec, const NodePtr node, DistanceType mindistsq, std::vector< DistanceType>  &
# 546
dists, const float epsError) 
# 547
{ 
# 549
if (((node->child1) == __null) && ((node->child2) == __null)) { 
# 550
DistanceType worst_dist = result_set.worstDist(); 
# 551
for (int i = ((node->left)); i < (node->right); ++i) { 
# 552
int index = (reorder_) ? i : (vind_)[i]; 
# 553
DistanceType dist = (distance_)(vec, (data_)[index], dim_, worst_dist); 
# 554
if (dist < worst_dist) { 
# 555
result_set.addPoint(dist, (vind_)[i]); 
# 556
}  
# 557
}  
# 558
return; 
# 559
}  
# 562
int idx = ((node->divfeat)); 
# 563
ElementType val = vec[idx]; 
# 564
DistanceType diff1 = val - (node->divlow); 
# 565
DistanceType diff2 = val - (node->divhigh); 
# 567
NodePtr bestChild; 
# 568
NodePtr otherChild; 
# 569
DistanceType cut_dist; 
# 570
if ((diff1 + diff2) < 0) { 
# 571
bestChild = (node->child1); 
# 572
otherChild = (node->child2); 
# 573
cut_dist = (distance_).accum_dist(val, (node->divhigh), idx); 
# 574
} else 
# 575
{ 
# 576
bestChild = (node->child2); 
# 577
otherChild = (node->child1); 
# 578
cut_dist = (distance_).accum_dist(val, (node->divlow), idx); 
# 579
}  
# 582
searchLevel(result_set, vec, bestChild, mindistsq, dists, epsError); 
# 584
DistanceType dst = dists[idx]; 
# 585
mindistsq = ((mindistsq + cut_dist) - dst); 
# 586
(dists[idx]) = cut_dist; 
# 587
if ((mindistsq * epsError) <= result_set.worstDist()) { 
# 588
searchLevel(result_set, vec, otherChild, mindistsq, dists, epsError); 
# 589
}  
# 590
(dists[idx]) = dst; 
# 591
} 
# 598
const Matrix< ElementType>  dataset_; 
# 600
cvflann::IndexParams index_params_; 
# 602
int leaf_max_size_; 
# 603
bool reorder_; 
# 609
std::vector< int>  vind_; 
# 611
Matrix< ElementType>  data_; 
# 613
::size_t size_; 
# 614
::size_t dim_; 
# 619
NodePtr root_node_; 
# 621
BoundingBox root_bbox_; 
# 630 "/usr/include/opencv4/opencv2/flann/kdtree_single_index.h" 3
cvflann::PooledAllocator pool_; 
# 632
Distance distance_; 
# 633
}; 
# 635
}
# 42 "/usr/include/opencv4/opencv2/flann/logger.h" 3
namespace cvflann { 
# 45
class Logger { 
# 47
Logger() : stream(stdout), logLevel((FLANN_LOG_WARN)) { } 
# 49
~Logger() 
# 50
{ 
# 51
if (((stream) != (__null)) && ((stream) != stdout)) { 
# 52
fclose(stream); 
# 53
}  
# 54
} 
# 56
static Logger &instance() 
# 57
{ 
# 58
static Logger logger; 
# 59
return logger; 
# 60
} 
# 62
void _setDestination(const char *name) 
# 63
{ 
# 64
if (name == (__null)) { 
# 65
(stream) = stdout; 
# 66
} else 
# 67
{ 
# 72
(stream) = fopen(name, "w"); 
# 74
if ((stream) == (__null)) { 
# 75
(stream) = stdout; 
# 76
}  
# 77
}  
# 78
} 
# 80
int _log(int level, const char *fmt, va_list arglist) 
# 81
{ 
# 82
if (level > (logLevel)) { return -1; }  
# 83
int ret = vfprintf(stream, fmt, arglist); 
# 84
return ret; 
# 85
} 
# 92
public: static void setLevel(int level) { (instance().logLevel) = level; } 
# 98
static void setDestination(const char *name) { instance()._setDestination(name); } 
# 106
static int log(int level, const char *fmt, ...) 
# 107
{ 
# 108
va_list arglist; 
# 109
__builtin_va_start((arglist),fmt); 
# 110
int ret = instance()._log(level, fmt, arglist); 
# 111
__builtin_va_end(arglist); 
# 112
return ret; 
# 113
} 
# 125 "/usr/include/opencv4/opencv2/flann/logger.h" 3
static int fatal(const char *fmt, ...) { va_list ap; __builtin_va_start((ap),fmt); int ret = instance()._log(FLANN_LOG_FATAL, fmt, ap); __builtin_va_end(ap); return ret; } 
# 126
static int error(const char *fmt, ...) { va_list ap; __builtin_va_start((ap),fmt); int ret = instance()._log(FLANN_LOG_ERROR, fmt, ap); __builtin_va_end(ap); return ret; } 
# 127
static int warn(const char *fmt, ...) { va_list ap; __builtin_va_start((ap),fmt); int ret = instance()._log(FLANN_LOG_WARN, fmt, ap); __builtin_va_end(ap); return ret; } 
# 128
static int info(const char *fmt, ...) { va_list ap; __builtin_va_start((ap),fmt); int ret = instance()._log(FLANN_LOG_INFO, fmt, ap); __builtin_va_end(ap); return ret; } 
# 131
private: FILE *stream; 
# 132
int logLevel; 
# 133
}; 
# 135
}
# 54 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
namespace cvflann { 
# 57
struct KMeansIndexParams : public IndexParams { 
# 59
KMeansIndexParams(int branching = 32, int iterations = 11, flann_centers_init_t 
# 60
centers_init = FLANN_CENTERS_RANDOM, float cb_index = (0.2)) 
# 61
{ 
# 62
(((*this)["algorithm"]) = (FLANN_INDEX_KMEANS)); 
# 64
(((*this)["branching"]) = branching); 
# 66
(((*this)["iterations"]) = iterations); 
# 68
(((*this)["centers_init"]) = centers_init); 
# 70
(((*this)["cb_index"]) = cb_index); 
# 71
} 
# 72
}; 
# 81 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
template< class Distance> 
# 82
class KMeansIndex : public NNIndex< Distance>  { 
# 85
public: typedef typename Distance::ElementType ElementType; 
# 86
typedef typename Distance::ResultType DistanceType; 
# 90
typedef void (KMeansIndex< Distance> ::*centersAlgFunction)(int, int *, int, int *, int &); 
# 95
centersAlgFunction chooseCenters; 
# 109 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
void chooseCentersRandom(int k, int *indices, int indices_length, int *centers, int &centers_length) 
# 110
{ 
# 111
cvflann::UniqueRandom r(indices_length); 
# 113
int index; 
# 114
for (index = 0; index < k; ++index) { 
# 115
bool duplicate = true; 
# 116
int rnd; 
# 117
while (duplicate) { 
# 118
duplicate = false; 
# 119
rnd = r.next(); 
# 120
if (rnd < 0) { 
# 121
centers_length = index; 
# 122
return; 
# 123
}  
# 125
(centers[index]) = (indices[rnd]); 
# 127
for (int j = 0; j < index; ++j) { 
# 128
DistanceType sq = (distance_)((dataset_)[centers[index]], (dataset_)[centers[j]], ((dataset_).cols)); 
# 129
if (sq < (1.0E-16)) { 
# 130
duplicate = true; 
# 131
}  
# 132
}  
# 133
}  
# 134
}  
# 136
centers_length = index; 
# 137
} 
# 150 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
void chooseCentersGonzales(int k, int *indices, int indices_length, int *centers, int &centers_length) 
# 151
{ 
# 152
int n = indices_length; 
# 154
int rnd = rand_int(n); 
# 155
(static_cast< bool>((rnd >= 0) && (rnd < n))) ? (void)0 : __assert_fail("rnd >=0 && rnd < n", "/usr/include/opencv4/opencv2/flann/kmeans_index.h", 155, __extension__ __PRETTY_FUNCTION__); 
# 157
(centers[0]) = (indices[rnd]); 
# 159
int index; 
# 160
for (index = 1; index < k; ++index) { 
# 162
int best_index = (-1); 
# 163
DistanceType best_val = (0); 
# 164
for (int j = 0; j < n; ++j) { 
# 165
DistanceType dist = (distance_)((dataset_)[centers[0]], (dataset_)[indices[j]], ((dataset_).cols)); 
# 166
for (int i = 1; i < index; ++i) { 
# 167
DistanceType tmp_dist = (distance_)((dataset_)[centers[i]], (dataset_)[indices[j]], ((dataset_).cols)); 
# 168
if (tmp_dist < dist) { 
# 169
dist = tmp_dist; 
# 170
}  
# 171
}  
# 172
if (dist > best_val) { 
# 173
best_val = dist; 
# 174
best_index = j; 
# 175
}  
# 176
}  
# 177
if (best_index != (-1)) { 
# 178
(centers[index]) = (indices[best_index]); 
# 179
} else 
# 180
{ 
# 181
break; 
# 182
}  
# 183
}  
# 184
centers_length = index; 
# 185
} 
# 201 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
void chooseCentersKMeanspp(int k, int *indices, int indices_length, int *centers, int &centers_length) 
# 202
{ 
# 203
int n = indices_length; 
# 205
double currentPot = (0); 
# 206
DistanceType *closestDistSq = new DistanceType [n]; 
# 209
int index = rand_int(n); 
# 210
(static_cast< bool>((index >= 0) && (index < n))) ? (void)0 : __assert_fail("index >=0 && index < n", "/usr/include/opencv4/opencv2/flann/kmeans_index.h", 210, __extension__ __PRETTY_FUNCTION__); 
# 211
(centers[0]) = (indices[index]); 
# 213
for (int i = 0; i < n; i++) { 
# 214
(closestDistSq[i]) = (distance_)((dataset_)[indices[i]], (dataset_)[indices[index]], ((dataset_).cols)); 
# 215
(closestDistSq[i]) = ensureSquareDistance< Distance> (closestDistSq[i]); 
# 216
currentPot += (closestDistSq[i]); 
# 217
}  
# 220
const int numLocalTries = 1; 
# 223
int centerCount; 
# 224
for (centerCount = 1; centerCount < k; centerCount++) { 
# 227
double bestNewPot = (-1); 
# 228
int bestNewIndex = (-1); 
# 229
for (int localTrial = 0; localTrial < numLocalTries; localTrial++) { 
# 233
double randVal = rand_double(currentPot); 
# 234
for (index = 0; index < (n - 1); index++) { 
# 235
if (randVal <= (closestDistSq[index])) { break; } else { 
# 236
randVal -= (closestDistSq[index]); }  
# 237
}  
# 240
double newPot = (0); 
# 241
for (int i = 0; i < n; i++) { 
# 242
DistanceType dist = (distance_)((dataset_)[indices[i]], (dataset_)[indices[index]], ((dataset_).cols)); 
# 243
newPot += std::min(ensureSquareDistance< Distance> (dist), closestDistSq[i]); 
# 244
}  
# 247
if ((bestNewPot < (0)) || (newPot < bestNewPot)) { 
# 248
bestNewPot = newPot; 
# 249
bestNewIndex = index; 
# 250
}  
# 251
}  
# 254
(centers[centerCount]) = (indices[bestNewIndex]); 
# 255
currentPot = bestNewPot; 
# 256
for (int i = 0; i < n; i++) { 
# 257
DistanceType dist = (distance_)((dataset_)[indices[i]], (dataset_)[indices[bestNewIndex]], ((dataset_).cols)); 
# 258
(closestDistSq[i]) = std::min(ensureSquareDistance< Distance> (dist), closestDistSq[i]); 
# 259
}  
# 260
}  
# 262
centers_length = centerCount; 
# 264
delete [] closestDistSq; 
# 265
} 
# 271
cvflann::flann_algorithm_t getType() const override 
# 272
{ 
# 273
return FLANN_INDEX_KMEANS; 
# 274
} 
# 276
class KMeansDistanceComputer : public cv::ParallelLoopBody { 
# 279
public: KMeansDistanceComputer(Distance _distance, const Matrix< ElementType>  &_dataset, const int 
# 280
_branching, const int *_indices, const cvflann::Matrix< double>  &_dcenters, const ::size_t _veclen, std::vector< int>  &
# 281
_new_centroids, std::vector< DistanceType>  &_sq_dists) : distance(_distance), dataset(_dataset), branching(_branching), indices(_indices), dcenters(_dcenters), veclen(_veclen), new_centroids(_new_centroids), sq_dists(_sq_dists) 
# 290
{ 
# 291
} 
# 293
virtual void operator()(const cv::Range &range) const override 
# 294
{ 
# 295
const int begin = range.start; 
# 296
const int end = range.end; 
# 298
for (int i = begin; i < end; ++i) 
# 299
{ 
# 300
DistanceType sq_dist((distance)((dataset)[(indices)[i]], (dcenters)[0], veclen)); 
# 301
int new_centroid(0); 
# 302
for (int j = 1; j < (branching); ++j) { 
# 303
DistanceType new_sq_dist = (distance)((dataset)[(indices)[i]], (dcenters)[j], veclen); 
# 304
if (sq_dist > new_sq_dist) { 
# 305
new_centroid = j; 
# 306
sq_dist = new_sq_dist; 
# 307
}  
# 308
}  
# 309
((sq_dists)[i]) = sq_dist; 
# 310
(new_centroids)[i] = new_centroid; 
# 311
}  
# 312
} 
# 315
private: Distance distance; 
# 316
const Matrix< ElementType>  &dataset; 
# 317
const int branching; 
# 318
const int *indices; 
# 319
const cvflann::Matrix< double>  &dcenters; 
# 320
const ::size_t veclen; 
# 321
std::vector< int>  &new_centroids; 
# 322
std::vector< DistanceType>  &sq_dists; 
# 323
KMeansDistanceComputer &operator=(const KMeansDistanceComputer &) { return *this; } 
# 324
}; 
# 333 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
KMeansIndex(const Matrix< ElementType>  &inputData, const cvflann::IndexParams &params = cvflann::KMeansIndexParams(), Distance 
# 334
d = Distance()) : dataset_(inputData), index_params_(params), root_((__null)), indices_((__null)), distance_(d) 
# 336
{ 
# 337
(memoryCounter_) = 0; 
# 339
(size_) = ((dataset_).rows); 
# 340
(veclen_) = ((dataset_).cols); 
# 342
(branching_) = get_param(params, "branching", 32); 
# 343
(iterations_) = get_param(params, "iterations", 11); 
# 344
if ((iterations_) < 0) { 
# 345
(iterations_) = std::numeric_limits< int> ::max(); 
# 346
}  
# 347
(centers_init_) = get_param(params, "centers_init", FLANN_CENTERS_RANDOM); 
# 349
if ((centers_init_) == (FLANN_CENTERS_RANDOM)) { 
# 350
(chooseCenters) = (&KMeansIndex< Distance> ::chooseCentersRandom); 
# 351
} else { 
# 352
if ((centers_init_) == (FLANN_CENTERS_GONZALES)) { 
# 353
(chooseCenters) = (&KMeansIndex< Distance> ::chooseCentersGonzales); 
# 354
} else { 
# 355
if ((centers_init_) == (FLANN_CENTERS_KMEANSPP)) { 
# 356
(chooseCenters) = (&KMeansIndex< Distance> ::chooseCentersKMeanspp); 
# 357
} else 
# 358
{ 
# 359
throw ((cvflann::FLANNException)("Unknown algorithm for choosing initial centers.")); 
# 360
}  }  }  
# 361
(cb_index_) = (0.4F); 
# 363
} 
# 366
KMeansIndex(const KMeansIndex &); 
# 367
KMeansIndex &operator=(const KMeansIndex &); 
# 375
virtual ~KMeansIndex() 
# 376
{ 
# 377
if ((root_) != __null) { 
# 378
free_centers(root_); 
# 379
}  
# 380
if ((indices_) != (__null)) { 
# 381
delete [] (indices_); 
# 382
}  
# 383
} 
# 388
::size_t size() const override 
# 389
{ 
# 390
return size_; 
# 391
} 
# 396
::size_t veclen() const override 
# 397
{ 
# 398
return veclen_; 
# 399
} 
# 402
void set_cb_index(float index) 
# 403
{ 
# 404
(cb_index_) = index; 
# 405
} 
# 411
int usedMemory() const override 
# 412
{ 
# 413
return (((pool_).usedMemory) + ((pool_).wastedMemory)) + (memoryCounter_); 
# 414
} 
# 419
void buildIndex() override 
# 420
{ 
# 421
if ((branching_) < 2) { 
# 422
throw ((cvflann::FLANNException)("Branching factor must be at least 2")); 
# 423
}  
# 425
(indices_) = (new int [size_]); 
# 426
for (::size_t i = (0); i < (size_); ++i) { 
# 427
((indices_)[i]) = ((int)i); 
# 428
}  
# 430
(root_) = (pool_).template allocate< KMeansNode> (); 
# 431
std::memset(root_, 0, sizeof(KMeansNode)); 
# 433
computeNodeStatistics(root_, indices_, (int)(size_)); 
# 434
computeClustering(root_, indices_, (int)(size_), branching_, 0); 
# 435
} 
# 438
void saveIndex(::FILE *stream) override 
# 439
{ 
# 440
save_value(stream, branching_); 
# 441
save_value(stream, iterations_); 
# 442
save_value(stream, memoryCounter_); 
# 443
save_value(stream, cb_index_); 
# 444
save_value(stream, *(indices_), (int)(size_)); 
# 446
save_tree(stream, root_); 
# 447
} 
# 450
void loadIndex(::FILE *stream) override 
# 451
{ 
# 452
load_value(stream, branching_); 
# 453
load_value(stream, iterations_); 
# 454
load_value(stream, memoryCounter_); 
# 455
load_value(stream, cb_index_); 
# 456
if ((indices_) != (__null)) { 
# 457
delete [] (indices_); 
# 458
}  
# 459
(indices_) = (new int [size_]); 
# 460
load_value(stream, *(indices_), size_); 
# 462
if ((root_) != __null) { 
# 463
free_centers(root_); 
# 464
}  
# 465
load_tree(stream, root_); 
# 467
(index_params_)["algorithm"] = getType(); 
# 468
(((index_params_)["branching"]) = (branching_)); 
# 469
(((index_params_)["iterations"]) = (iterations_)); 
# 470
(((index_params_)["centers_init"]) = (centers_init_)); 
# 471
(((index_params_)["cb_index"]) = (cb_index_)); 
# 473
} 
# 485 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
void findNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, const cvflann::SearchParams &searchParams) override 
# 486
{ 
# 488
int maxChecks = get_param(searchParams, "checks", 32); 
# 490
if (maxChecks == (FLANN_CHECKS_UNLIMITED)) { 
# 491
findExactNN(root_, result, vec); 
# 492
} else 
# 493
{ 
# 495
Heap< BranchStruct< KMeansNode *, typename Distance::ResultType> >  *heap = new Heap< BranchStruct< KMeansNode *, typename Distance::ResultType> > ((int)(size_)); 
# 497
int checks = 0; 
# 498
findNN(root_, result, vec, checks, maxChecks, heap); 
# 500
BranchSt branch; 
# 501
while (heap->popMin(branch) && ((checks < maxChecks) || (!result.full()))) { 
# 502
KMeansNodePtr node = ((branch.node)); 
# 503
findNN(node, result, vec, checks, maxChecks, heap); 
# 504
}  
# 505
(static_cast< bool>(result.full())) ? (void)0 : __assert_fail("result.full()", "/usr/include/opencv4/opencv2/flann/kmeans_index.h", 505, __extension__ __PRETTY_FUNCTION__); 
# 507
delete heap; 
# 508
}  
# 510
} 
# 519 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
int getClusterCenters(Matrix< DistanceType>  &centers) 
# 520
{ 
# 521
int numClusters = ((centers.rows)); 
# 522
if (numClusters < 1) { 
# 523
throw ((cvflann::FLANNException)("Number of clusters must be at least 1")); 
# 524
}  
# 526
DistanceType variance; 
# 527
KMeansNodePtr *clusters = new KMeansNodePtr [numClusters]; 
# 529
int clusterCount = getMinVarianceClusters(root_, clusters, numClusters, variance); 
# 531
Logger::info("Clusters requested: %d, returning %d\n", numClusters, clusterCount); 
# 533
for (int i = 0; i < clusterCount; ++i) { 
# 534
DistanceType *center = (((clusters[i])->pivot)); 
# 535
for (::size_t j = (0); j < (veclen_); ++j) { 
# 536
((centers[i])[j]) = (center[j]); 
# 537
}  
# 538
}  
# 539
delete [] clusters; 
# 541
return clusterCount; 
# 542
} 
# 544
cvflann::IndexParams getParameters() const override 
# 545
{ 
# 546
return index_params_; 
# 547
} 
# 554
private: struct KMeansNode { 
# 559
DistanceType *pivot; 
# 563
DistanceType radius; 
# 567
DistanceType mean_radius; 
# 571
DistanceType variance; 
# 575
int size; 
# 579
KMeansNode **childs; 
# 583
int *indices; 
# 587
int level; 
# 588
}; 
# 589
typedef KMeansNode *KMeansNodePtr; 
# 594
typedef BranchStruct< KMeansNodePtr, DistanceType>  BranchSt; 
# 599
void save_tree(::FILE *stream, KMeansNodePtr node) 
# 600
{ 
# 601
save_value(stream, *node); 
# 602
save_value(stream, *(node->pivot), (int)(veclen_)); 
# 603
if ((node->childs) == __null) { 
# 604
int indices_offset = (int)((node->indices) - (indices_)); 
# 605
save_value(stream, indices_offset); 
# 606
} else 
# 607
{ 
# 608
for (int i = 0; i < (branching_); ++i) { 
# 609
save_tree(stream, (node->childs)[i]); 
# 610
}  
# 611
}  
# 612
} 
# 615
void load_tree(::FILE *stream, KMeansNodePtr &node) 
# 616
{ 
# 617
node = (pool_).template allocate< KMeansNode> (); 
# 618
load_value(stream, *node); 
# 619
(node->pivot) = (new DistanceType [veclen_]); 
# 620
load_value(stream, *(node->pivot), (int)(veclen_)); 
# 621
if ((node->childs) == __null) { 
# 622
int indices_offset; 
# 623
load_value(stream, indices_offset); 
# 624
(node->indices) = ((indices_) + indices_offset); 
# 625
} else 
# 626
{ 
# 627
(node->childs) = (pool_).template allocate< KMeansNodePtr> (branching_); 
# 628
for (int i = 0; i < (branching_); ++i) { 
# 629
load_tree(stream, (node->childs)[i]); 
# 630
}  
# 631
}  
# 632
} 
# 638
void free_centers(KMeansNodePtr node) 
# 639
{ 
# 640
delete [] (node->pivot); 
# 641
if ((node->childs) != __null) { 
# 642
for (int k = 0; k < (branching_); ++k) { 
# 643
free_centers((node->childs)[k]); 
# 644
}  
# 645
}  
# 646
} 
# 655 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
void computeNodeStatistics(KMeansNodePtr node, int *indices, int indices_length) 
# 656
{ 
# 658
DistanceType radius = (0); 
# 659
DistanceType variance = (0); 
# 660
DistanceType *mean = new DistanceType [veclen_]; 
# 661
(memoryCounter_) += ((int)((veclen_) * sizeof(DistanceType))); 
# 663
memset(mean, 0, (veclen_) * sizeof(DistanceType)); 
# 665
for (::size_t i = (0); i < (size_); ++i) { 
# 666
ElementType *vec = (dataset_)[indices[i]]; 
# 667
for (::size_t j = (0); j < (veclen_); ++j) { 
# 668
(mean[j]) += (vec[j]); 
# 669
}  
# 670
variance += (distance_)(vec, ZeroIterator< typename Distance::ElementType> (), veclen_); 
# 671
}  
# 672
for (::size_t j = (0); j < (veclen_); ++j) { 
# 673
(mean[j]) /= (size_); 
# 674
}  
# 675
variance /= (size_); 
# 676
variance -= (distance_)(mean, ZeroIterator< ElementType> (), veclen_); 
# 678
DistanceType tmp = (0); 
# 679
for (int i = 0; i < indices_length; ++i) { 
# 680
tmp = (distance_)(mean, (dataset_)[indices[i]], veclen_); 
# 681
if (tmp > radius) { 
# 682
radius = tmp; 
# 683
}  
# 684
}  
# 686
(node->variance) = variance; 
# 687
(node->radius) = radius; 
# 688
(node->pivot) = mean; 
# 689
} 
# 703 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
void computeClustering(KMeansNodePtr node, int *indices, int indices_length, int branching, int level) 
# 704
{ 
# 705
(node->size) = indices_length; 
# 706
(node->level) = level; 
# 708
if (indices_length < branching) { 
# 709
(node->indices) = indices; 
# 710
std::sort((node->indices), (node->indices) + indices_length); 
# 711
(node->childs) = __null; 
# 712
return; 
# 713
}  
# 715
cv::AutoBuffer< int>  centers_idx_buf(branching); 
# 716
int *centers_idx = centers_idx_buf.data(); 
# 717
int centers_length; 
# 718
(this->*(chooseCenters))(branching, indices, indices_length, centers_idx, centers_length); 
# 720
if (centers_length < branching) { 
# 721
(node->indices) = indices; 
# 722
std::sort((node->indices), (node->indices) + indices_length); 
# 723
(node->childs) = __null; 
# 724
return; 
# 725
}  
# 728
cv::AutoBuffer< double>  dcenters_buf(branching * (veclen_)); 
# 729
cvflann::Matrix< double>  dcenters(dcenters_buf.data(), branching, veclen_); 
# 730
for (int i = 0; i < centers_length; ++i) { 
# 731
ElementType *vec = (dataset_)[centers_idx[i]]; 
# 732
for (::size_t k = (0); k < (veclen_); ++k) { 
# 733
(dcenters[i][k]) = ((double)(vec[k])); 
# 734
}  
# 735
}  
# 737
std::vector< DistanceType>  radiuses(branching); 
# 738
cv::AutoBuffer< int>  count_buf(branching); 
# 739
int *count = count_buf.data(); 
# 740
for (int i = 0; i < branching; ++i) { 
# 741
(radiuses[i]) = 0; 
# 742
(count[i]) = 0; 
# 743
}  
# 746
cv::AutoBuffer< int>  belongs_to_buf(indices_length); 
# 747
int *belongs_to = belongs_to_buf.data(); 
# 748
for (int i = 0; i < indices_length; ++i) { 
# 750
DistanceType sq_dist = (distance_)((dataset_)[indices[i]], dcenters[0], veclen_); 
# 751
(belongs_to[i]) = 0; 
# 752
for (int j = 1; j < branching; ++j) { 
# 753
DistanceType new_sq_dist = (distance_)((dataset_)[indices[i]], dcenters[j], veclen_); 
# 754
if (sq_dist > new_sq_dist) { 
# 755
(belongs_to[i]) = j; 
# 756
sq_dist = new_sq_dist; 
# 757
}  
# 758
}  
# 759
if (sq_dist > (radiuses[belongs_to[i]])) { 
# 760
(radiuses[belongs_to[i]]) = sq_dist; 
# 761
}  
# 762
(count[belongs_to[i]])++; 
# 763
}  
# 765
bool converged = false; 
# 766
int iteration = 0; 
# 767
while ((!converged) && (iteration < (iterations_))) { 
# 768
converged = true; 
# 769
iteration++; 
# 772
for (int i = 0; i < branching; ++i) { 
# 773
memset(dcenters[i], 0, sizeof(double) * (veclen_)); 
# 774
(radiuses[i]) = 0; 
# 775
}  
# 776
for (int i = 0; i < indices_length; ++i) { 
# 777
ElementType *vec = (dataset_)[indices[i]]; 
# 778
double *center = dcenters[belongs_to[i]]; 
# 779
for (::size_t k = (0); k < (veclen_); ++k) { 
# 780
(center[k]) += (vec[k]); 
# 781
}  
# 782
}  
# 783
for (int i = 0; i < branching; ++i) { 
# 784
int cnt = count[i]; 
# 785
for (::size_t k = (0); k < (veclen_); ++k) { 
# 786
(dcenters[i][k]) /= cnt; 
# 787
}  
# 788
}  
# 790
std::vector< int>  new_centroids(indices_length); 
# 791
std::vector< typename Distance::ResultType>  sq_dists(indices_length); 
# 794
KMeansDistanceComputer invoker(distance_, dataset_, branching, indices, dcenters, veclen_, new_centroids, sq_dists); 
# 795
parallel_for_(cv::Range(0, (int)indices_length), invoker); 
# 797
for (int i = 0; i < ((int)indices_length); ++i) { 
# 798
DistanceType sq_dist(sq_dists[i]); 
# 799
int new_centroid(new_centroids[i]); 
# 800
if (sq_dist > (radiuses[new_centroid])) { 
# 801
(radiuses[new_centroid]) = sq_dist; 
# 802
}  
# 803
if (new_centroid != (belongs_to[i])) { 
# 804
(count[belongs_to[i]])--; 
# 805
(count[new_centroid])++; 
# 806
(belongs_to[i]) = new_centroid; 
# 807
converged = false; 
# 808
}  
# 809
}  
# 811
for (int i = 0; i < branching; ++i) { 
# 814
if ((count[i]) == 0) { 
# 815
int j = (i + 1) % branching; 
# 816
while ((count[j]) <= 1) { 
# 817
j = ((j + 1) % branching); 
# 818
}  
# 820
for (int k = 0; k < indices_length; ++k) { 
# 821
if ((belongs_to[k]) == j) { 
# 823
if ((distance_)((dataset_)[indices[k]], dcenters[j], veclen_) == (radiuses[j])) { 
# 824
(belongs_to[k]) = i; 
# 825
(count[j])--; 
# 826
(count[i])++; 
# 827
break; 
# 828
}  
# 829
}  
# 830
}  
# 831
converged = false; 
# 832
}  
# 833
}  
# 835
}  
# 837
DistanceType **centers = new DistanceType *[branching]; 
# 839
for (int i = 0; i < branching; ++i) { 
# 840
(centers[i]) = (new DistanceType [veclen_]); 
# 841
(memoryCounter_) += ((int)((veclen_) * sizeof(DistanceType))); 
# 842
for (::size_t k = (0); k < (veclen_); ++k) { 
# 843
((centers[i])[k]) = ((DistanceType)(dcenters[i][k])); 
# 844
}  
# 845
}  
# 849
(node->childs) = (pool_).template allocate< KMeansNodePtr> (branching); 
# 850
int start = 0; 
# 851
int end = start; 
# 852
for (int c = 0; c < branching; ++c) { 
# 853
int s = count[c]; 
# 855
DistanceType variance = (0); 
# 856
DistanceType mean_radius = (0); 
# 857
for (int i = 0; i < indices_length; ++i) { 
# 858
if ((belongs_to[i]) == c) { 
# 859
DistanceType d = (distance_)((dataset_)[indices[i]], ZeroIterator< typename Distance::ElementType> (), veclen_); 
# 860
variance += d; 
# 861
mean_radius += sqrt(d); 
# 862
std::swap(indices[i], indices[end]); 
# 863
std::swap(belongs_to[i], belongs_to[end]); 
# 864
end++; 
# 865
}  
# 866
}  
# 867
variance /= s; 
# 868
mean_radius /= s; 
# 869
variance -= (distance_)(centers[c], ZeroIterator< typename Distance::ElementType> (), veclen_); 
# 871
((node->childs)[c]) = (pool_).template allocate< KMeansNode> (); 
# 872
std::memset((node->childs)[c], 0, sizeof(KMeansNode)); 
# 873
(((node->childs)[c])->radius) = (radiuses[c]); 
# 874
(((node->childs)[c])->pivot) = (centers[c]); 
# 875
(((node->childs)[c])->variance) = variance; 
# 876
(((node->childs)[c])->mean_radius) = mean_radius; 
# 877
computeClustering((node->childs)[c], indices + start, end - start, branching, level + 1); 
# 878
start = end; 
# 879
}  
# 881
delete [] centers; 
# 882
} 
# 899 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
void findNN(KMeansNodePtr node, ResultSet< DistanceType>  &result, const ElementType *vec, int &checks, int maxChecks, Heap< BranchSt>  *
# 900
heap) 
# 901
{ 
# 903
{ 
# 904
DistanceType bsq = (distance_)(vec, (node->pivot), veclen_); 
# 905
DistanceType rsq = ((node->radius)); 
# 906
DistanceType wsq = result.worstDist(); 
# 908
DistanceType val = (bsq - rsq) - wsq; 
# 909
DistanceType val2 = (val * val) - ((4 * rsq) * wsq); 
# 912
if ((val > 0) && (val2 > 0)) { 
# 913
return; 
# 914
}  
# 915
} 
# 917
if ((node->childs) == __null) { 
# 918
if (checks >= maxChecks) { 
# 919
if (result.full()) { return; }  
# 920
}  
# 921
checks += (node->size); 
# 922
for (int i = 0; i < (node->size); ++i) { 
# 923
int index = (node->indices)[i]; 
# 924
DistanceType dist = (distance_)((dataset_)[index], vec, veclen_); 
# 925
result.addPoint(dist, index); 
# 926
}  
# 927
} else 
# 928
{ 
# 929
DistanceType *domain_distances = new DistanceType [branching_]; 
# 930
int closest_center = exploreNodeBranches(node, vec, domain_distances, heap); 
# 931
delete [] domain_distances; 
# 932
findNN((node->childs)[closest_center], result, vec, checks, maxChecks, heap); 
# 933
}  
# 934
} 
# 944 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
int exploreNodeBranches(KMeansNodePtr node, const ElementType *q, DistanceType *domain_distances, Heap< BranchSt>  *heap) 
# 945
{ 
# 947
int best_index = 0; 
# 948
(domain_distances[best_index]) = (distance_)(q, (((node->childs)[best_index])->pivot), veclen_); 
# 949
for (int i = 1; i < (branching_); ++i) { 
# 950
(domain_distances[i]) = (distance_)(q, (((node->childs)[i])->pivot), veclen_); 
# 951
if ((domain_distances[i]) < (domain_distances[best_index])) { 
# 952
best_index = i; 
# 953
}  
# 954
}  
# 957
for (int i = 0; i < (branching_); ++i) { 
# 958
if (i != best_index) { 
# 959
(domain_distances[i]) -= ((cb_index_) * (((node->childs)[i])->variance)); 
# 965
heap->insert(BranchSt((node->childs)[i], domain_distances[i])); 
# 966
}  
# 967
}  
# 969
return best_index; 
# 970
} 
# 976
void findExactNN(KMeansNodePtr node, ResultSet< DistanceType>  &result, const ElementType *vec) 
# 977
{ 
# 979
{ 
# 980
DistanceType bsq = (distance_)(vec, (node->pivot), veclen_); 
# 981
DistanceType rsq = ((node->radius)); 
# 982
DistanceType wsq = result.worstDist(); 
# 984
DistanceType val = (bsq - rsq) - wsq; 
# 985
DistanceType val2 = (val * val) - ((4 * rsq) * wsq); 
# 988
if ((val > 0) && (val2 > 0)) { 
# 989
return; 
# 990
}  
# 991
} 
# 994
if ((node->childs) == __null) { 
# 995
for (int i = 0; i < (node->size); ++i) { 
# 996
int index = (node->indices)[i]; 
# 997
DistanceType dist = (distance_)((dataset_)[index], vec, veclen_); 
# 998
result.addPoint(dist, index); 
# 999
}  
# 1000
} else 
# 1001
{ 
# 1002
int *sort_indices = new int [branching_]; 
# 1004
getCenterOrdering(node, vec, sort_indices); 
# 1006
for (int i = 0; i < (branching_); ++i) { 
# 1007
findExactNN((node->childs)[sort_indices[i]], result, vec); 
# 1008
}  
# 1010
delete [] sort_indices; 
# 1011
}  
# 1012
} 
# 1020
void getCenterOrdering(KMeansNodePtr node, const ElementType *q, int *sort_indices) 
# 1021
{ 
# 1022
DistanceType *domain_distances = new DistanceType [branching_]; 
# 1023
for (int i = 0; i < (branching_); ++i) { 
# 1024
DistanceType dist = (distance_)(q, (((node->childs)[i])->pivot), veclen_); 
# 1026
int j = 0; 
# 1027
while (((domain_distances[j]) < dist) && (j < i)) { j++; }  
# 1028
for (int k = i; k > j; --k) { 
# 1029
(domain_distances[k]) = (domain_distances[k - 1]); 
# 1030
(sort_indices[k]) = (sort_indices[k - 1]); 
# 1031
}  
# 1032
(domain_distances[j]) = dist; 
# 1033
(sort_indices[j]) = i; 
# 1034
}  
# 1035
delete [] domain_distances; 
# 1036
} 
# 1043
DistanceType getDistanceToBorder(DistanceType *p, DistanceType *c, DistanceType *q) 
# 1044
{ 
# 1045
DistanceType sum = (0); 
# 1046
DistanceType sum2 = (0); 
# 1048
for (int i = 0; i < (veclen_); ++i) { 
# 1049
DistanceType t = (c[i]) - (p[i]); 
# 1050
sum += (t * ((q[i]) - (((c[i]) + (p[i])) / 2))); 
# 1051
sum2 += (t * t); 
# 1052
}  
# 1054
return (sum * sum) / sum2; 
# 1055
} 
# 1067 "/usr/include/opencv4/opencv2/flann/kmeans_index.h" 3
int getMinVarianceClusters(KMeansNodePtr root, KMeansNodePtr *clusters, int clusters_length, DistanceType &varianceValue) 
# 1068
{ 
# 1069
int clusterCount = 1; 
# 1070
(clusters[0]) = root; 
# 1072
DistanceType meanVariance = (root->variance) * (root->size); 
# 1074
while (clusterCount < clusters_length) { 
# 1075
DistanceType minVariance = std::template numeric_limits< typename Distance::ResultType> ::max(); 
# 1076
int splitIndex = (-1); 
# 1078
for (int i = 0; i < clusterCount; ++i) { 
# 1079
if (((clusters[i])->childs) != __null) { 
# 1081
DistanceType variance = meanVariance - (((clusters[i])->variance) * ((clusters[i])->size)); 
# 1083
for (int j = 0; j < (branching_); ++j) { 
# 1084
variance += (((((clusters[i])->childs)[j])->variance) * ((((clusters[i])->childs)[j])->size)); 
# 1085
}  
# 1086
if (variance < minVariance) { 
# 1087
minVariance = variance; 
# 1088
splitIndex = i; 
# 1089
}  
# 1090
}  
# 1091
}  
# 1093
if (splitIndex == (-1)) { break; }  
# 1094
if ((((branching_) + clusterCount) - 1) > clusters_length) { break; }  
# 1096
meanVariance = minVariance; 
# 1099
KMeansNodePtr toSplit = clusters[splitIndex]; 
# 1100
(clusters[splitIndex]) = ((toSplit->childs)[0]); 
# 1101
for (int i = 1; i < (branching_); ++i) { 
# 1102
(clusters[clusterCount++]) = ((toSplit->childs)[i]); 
# 1103
}  
# 1104
}  
# 1106
varianceValue = (meanVariance / (root->size)); 
# 1107
return clusterCount; 
# 1108
} 
# 1112
int branching_; 
# 1115
int iterations_; 
# 1118
cvflann::flann_centers_init_t centers_init_; 
# 1126
float cb_index_; 
# 1131
const Matrix< ElementType>  dataset_; 
# 1134
cvflann::IndexParams index_params_; 
# 1139
::size_t size_; 
# 1144
::size_t veclen_; 
# 1149
KMeansNodePtr root_; 
# 1154
int *indices_; 
# 1159
Distance distance_; 
# 1164
cvflann::PooledAllocator pool_; 
# 1169
int memoryCounter_; 
# 1170
}; 
# 1172
}
# 41 "/usr/include/opencv4/opencv2/flann/composite_index.h" 3
namespace cvflann { 
# 47
struct CompositeIndexParams : public IndexParams { 
# 49
CompositeIndexParams(int trees = 4, int branching = 32, int iterations = 11, flann_centers_init_t 
# 50
centers_init = FLANN_CENTERS_RANDOM, float cb_index = (0.2)) 
# 51
{ 
# 52
(((*this)["algorithm"]) = (FLANN_INDEX_KMEANS)); 
# 54
(((*this)["trees"]) = trees); 
# 56
(((*this)["branching"]) = branching); 
# 58
(((*this)["iterations"]) = iterations); 
# 60
(((*this)["centers_init"]) = centers_init); 
# 62
(((*this)["cb_index"]) = cb_index); 
# 63
} 
# 64
}; 
# 72
template< class Distance> 
# 73
class CompositeIndex : public NNIndex< Distance>  { 
# 76
public: typedef typename Distance::ElementType ElementType; 
# 77
typedef typename Distance::ResultType DistanceType; 
# 86 "/usr/include/opencv4/opencv2/flann/composite_index.h" 3
CompositeIndex(const Matrix< ElementType>  &inputData, const cvflann::IndexParams &params = cvflann::CompositeIndexParams(), Distance 
# 87
d = Distance()) : index_params_(params) 
# 88
{ 
# 89
(kdtree_index_) = (new KDTreeIndex< Distance> (inputData, params, d)); 
# 90
(kmeans_index_) = (new KMeansIndex< Distance> (inputData, params, d)); 
# 92
} 
# 94
CompositeIndex(const CompositeIndex &); 
# 95
CompositeIndex &operator=(const CompositeIndex &); 
# 97
virtual ~CompositeIndex() 
# 98
{ 
# 99
delete (kdtree_index_); 
# 100
delete (kmeans_index_); 
# 101
} 
# 106
cvflann::flann_algorithm_t getType() const override 
# 107
{ 
# 108
return FLANN_INDEX_COMPOSITE; 
# 109
} 
# 114
::size_t size() const override 
# 115
{ 
# 116
return (kdtree_index_)->size(); 
# 117
} 
# 122
::size_t veclen() const override 
# 123
{ 
# 124
return (kdtree_index_)->veclen(); 
# 125
} 
# 130
int usedMemory() const override 
# 131
{ 
# 132
return (kmeans_index_)->usedMemory() + (kdtree_index_)->usedMemory(); 
# 133
} 
# 138
void buildIndex() override 
# 139
{ 
# 140
Logger::info("Building kmeans tree...\n"); 
# 141
(kmeans_index_)->buildIndex(); 
# 142
Logger::info("Building kdtree tree...\n"); 
# 143
(kdtree_index_)->buildIndex(); 
# 144
} 
# 150
void saveIndex(::FILE *stream) override 
# 151
{ 
# 152
(kmeans_index_)->saveIndex(stream); 
# 153
(kdtree_index_)->saveIndex(stream); 
# 154
} 
# 160
void loadIndex(::FILE *stream) override 
# 161
{ 
# 162
(kmeans_index_)->loadIndex(stream); 
# 163
(kdtree_index_)->loadIndex(stream); 
# 164
} 
# 169
cvflann::IndexParams getParameters() const override 
# 170
{ 
# 171
return index_params_; 
# 172
} 
# 177
void findNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, const cvflann::SearchParams &searchParams) override 
# 178
{ 
# 179
(kmeans_index_)->findNeighbors(result, vec, searchParams); 
# 180
(kdtree_index_)->findNeighbors(result, vec, searchParams); 
# 181
} 
# 185
private: KMeansIndex< Distance>  *kmeans_index_; 
# 188
KDTreeIndex< Distance>  *kdtree_index_; 
# 191
const cvflann::IndexParams index_params_; 
# 192
}; 
# 194
}
# 39 "/usr/include/opencv4/opencv2/flann/linear_index.h" 3
namespace cvflann { 
# 42
struct LinearIndexParams : public IndexParams { 
# 44
LinearIndexParams() 
# 45
{ 
# 46
(((*this)["algorithm"]) = (FLANN_INDEX_LINEAR)); 
# 47
} 
# 48
}; 
# 50
template< class Distance> 
# 51
class LinearIndex : public NNIndex< Distance>  { 
# 55
public: typedef typename Distance::ElementType ElementType; 
# 56
typedef typename Distance::ResultType DistanceType; 
# 59
LinearIndex(const Matrix< ElementType>  &inputData, const cvflann::IndexParams &params = cvflann::LinearIndexParams(), Distance 
# 60
d = Distance()) : dataset_(inputData), index_params_(params), distance_(d) 
# 62
{ 
# 63
} 
# 65
LinearIndex(const LinearIndex &); 
# 66
LinearIndex &operator=(const LinearIndex &); 
# 68
cvflann::flann_algorithm_t getType() const override 
# 69
{ 
# 70
return FLANN_INDEX_LINEAR; 
# 71
} 
# 74
::size_t size() const override 
# 75
{ 
# 76
return (dataset_).rows; 
# 77
} 
# 79
::size_t veclen() const override 
# 80
{ 
# 81
return (dataset_).cols; 
# 82
} 
# 85
int usedMemory() const override 
# 86
{ 
# 87
return 0; 
# 88
} 
# 90
void buildIndex() override 
# 91
{ 
# 93
} 
# 95
void saveIndex(::FILE *) override 
# 96
{ 
# 98
} 
# 101
void loadIndex(::FILE *) override 
# 102
{ 
# 105
(index_params_)["algorithm"] = getType(); 
# 106
} 
# 108
void findNeighbors(ResultSet< DistanceType>  &resultSet, const ElementType *vec, const cvflann::SearchParams &) override 
# 109
{ 
# 110
ElementType *data = (((dataset_).data)); 
# 111
for (::size_t i = (0); i < ((dataset_).rows); (++i), (data += ((dataset_).cols))) { 
# 112
DistanceType dist = (distance_)(data, vec, ((dataset_).cols)); 
# 113
resultSet.addPoint(dist, (int)i); 
# 114
}  
# 115
} 
# 117
cvflann::IndexParams getParameters() const override 
# 118
{ 
# 119
return index_params_; 
# 120
} 
# 124
private: const Matrix< ElementType>  dataset_; 
# 126
cvflann::IndexParams index_params_; 
# 128
Distance distance_; 
# 130
}; 
# 132
}
# 53 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
namespace cvflann { 
# 56
struct HierarchicalClusteringIndexParams : public IndexParams { 
# 58
HierarchicalClusteringIndexParams(int branching = 32, flann_centers_init_t 
# 59
centers_init = FLANN_CENTERS_RANDOM, int 
# 60
trees = 4, int leaf_size = 100) 
# 61
{ 
# 62
(((*this)["algorithm"]) = (FLANN_INDEX_HIERARCHICAL)); 
# 64
(((*this)["branching"]) = branching); 
# 66
(((*this)["centers_init"]) = centers_init); 
# 68
(((*this)["trees"]) = trees); 
# 70
(((*this)["leaf_size"]) = leaf_size); 
# 71
} 
# 72
}; 
# 81 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
template< class Distance> 
# 82
class HierarchicalClusteringIndex : public NNIndex< Distance>  { 
# 85
public: typedef typename Distance::ElementType ElementType; 
# 86
typedef typename Distance::ResultType DistanceType; 
# 91
private: typedef void (HierarchicalClusteringIndex< Distance> ::*centersAlgFunction)(int, int *, int, int *, int &); 
# 96
centersAlgFunction chooseCenters; 
# 110 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
void chooseCentersRandom(int k, int *dsindices, int indices_length, int *centers, int &centers_length) 
# 111
{ 
# 112
cvflann::UniqueRandom r(indices_length); 
# 114
int index; 
# 115
for (index = 0; index < k; ++index) { 
# 116
bool duplicate = true; 
# 117
int rnd; 
# 118
while (duplicate) { 
# 119
duplicate = false; 
# 120
rnd = r.next(); 
# 121
if (rnd < 0) { 
# 122
centers_length = index; 
# 123
return; 
# 124
}  
# 126
(centers[index]) = (dsindices[rnd]); 
# 128
for (int j = 0; j < index; ++j) { 
# 129
DistanceType sq = (distance)((dataset)[centers[index]], (dataset)[centers[j]], ((dataset).cols)); 
# 130
if (sq < (1.0E-16)) { 
# 131
duplicate = true; 
# 132
}  
# 133
}  
# 134
}  
# 135
}  
# 137
centers_length = index; 
# 138
} 
# 151 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
void chooseCentersGonzales(int k, int *dsindices, int indices_length, int *centers, int &centers_length) 
# 152
{ 
# 153
int n = indices_length; 
# 155
int rnd = rand_int(n); 
# 156
(static_cast< bool>((rnd >= 0) && (rnd < n))) ? (void)0 : __assert_fail("rnd >=0 && rnd < n", "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h", 156, __extension__ __PRETTY_FUNCTION__); 
# 158
(centers[0]) = (dsindices[rnd]); 
# 160
int index; 
# 161
for (index = 1; index < k; ++index) { 
# 163
int best_index = (-1); 
# 164
DistanceType best_val = (0); 
# 165
for (int j = 0; j < n; ++j) { 
# 166
DistanceType dist = (distance)((dataset)[centers[0]], (dataset)[dsindices[j]], ((dataset).cols)); 
# 167
for (int i = 1; i < index; ++i) { 
# 168
DistanceType tmp_dist = (distance)((dataset)[centers[i]], (dataset)[dsindices[j]], ((dataset).cols)); 
# 169
if (tmp_dist < dist) { 
# 170
dist = tmp_dist; 
# 171
}  
# 172
}  
# 173
if (dist > best_val) { 
# 174
best_val = dist; 
# 175
best_index = j; 
# 176
}  
# 177
}  
# 178
if (best_index != (-1)) { 
# 179
(centers[index]) = (dsindices[best_index]); 
# 180
} else 
# 181
{ 
# 182
break; 
# 183
}  
# 184
}  
# 185
centers_length = index; 
# 186
} 
# 202 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
void chooseCentersKMeanspp(int k, int *dsindices, int indices_length, int *centers, int &centers_length) 
# 203
{ 
# 204
int n = indices_length; 
# 206
double currentPot = (0); 
# 207
DistanceType *closestDistSq = new DistanceType [n]; 
# 210
int index = rand_int(n); 
# 211
(static_cast< bool>((index >= 0) && (index < n))) ? (void)0 : __assert_fail("index >=0 && index < n", "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h", 211, __extension__ __PRETTY_FUNCTION__); 
# 212
(centers[0]) = (dsindices[index]); 
# 216
for (int i = 0; i < n; i++) { 
# 217
(closestDistSq[i]) = (distance)((dataset)[dsindices[i]], (dataset)[dsindices[index]], ((dataset).cols)); 
# 218
(closestDistSq[i]) = ensureSquareDistance< Distance> (closestDistSq[i]); 
# 219
currentPot += (closestDistSq[i]); 
# 220
}  
# 223
const int numLocalTries = 1; 
# 226
int centerCount; 
# 227
for (centerCount = 1; centerCount < k; centerCount++) { 
# 230
double bestNewPot = (-1); 
# 231
int bestNewIndex = 0; 
# 232
for (int localTrial = 0; localTrial < numLocalTries; localTrial++) { 
# 236
double randVal = rand_double(currentPot); 
# 237
for (index = 0; index < (n - 1); index++) { 
# 238
if (randVal <= (closestDistSq[index])) { break; } else { 
# 239
randVal -= (closestDistSq[index]); }  
# 240
}  
# 243
double newPot = (0); 
# 244
for (int i = 0; i < n; i++) { 
# 245
DistanceType dist = (distance)((dataset)[dsindices[i]], (dataset)[dsindices[index]], ((dataset).cols)); 
# 246
newPot += std::min(ensureSquareDistance< Distance> (dist), closestDistSq[i]); 
# 247
}  
# 250
if ((bestNewPot < (0)) || (newPot < bestNewPot)) { 
# 251
bestNewPot = newPot; 
# 252
bestNewIndex = index; 
# 253
}  
# 254
}  
# 257
(centers[centerCount]) = (dsindices[bestNewIndex]); 
# 258
currentPot = bestNewPot; 
# 259
for (int i = 0; i < n; i++) { 
# 260
DistanceType dist = (distance)((dataset)[dsindices[i]], (dataset)[dsindices[bestNewIndex]], ((dataset).cols)); 
# 261
(closestDistSq[i]) = std::min(ensureSquareDistance< Distance> (dist), closestDistSq[i]); 
# 262
}  
# 263
}  
# 265
centers_length = centerCount; 
# 267
delete [] closestDistSq; 
# 268
} 
# 288 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
void GroupWiseCenterChooser(int k, int *dsindices, int indices_length, int *centers, int &centers_length) 
# 289
{ 
# 290
const float kSpeedUpFactor = (1.3F); 
# 292
int n = indices_length; 
# 294
DistanceType *closestDistSq = new DistanceType [n]; 
# 297
int index = rand_int(n); 
# 298
(static_cast< bool>((index >= 0) && (index < n))) ? (void)0 : __assert_fail("index >=0 && index < n", "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h", 298, __extension__ __PRETTY_FUNCTION__); 
# 299
(centers[0]) = (dsindices[index]); 
# 301
for (int i = 0; i < n; i++) { 
# 302
(closestDistSq[i]) = (distance)((dataset)[dsindices[i]], (dataset)[dsindices[index]], ((dataset).cols)); 
# 303
}  
# 307
int centerCount; 
# 308
for (centerCount = 1; centerCount < k; centerCount++) { 
# 311
double bestNewPot = (-1); 
# 312
int bestNewIndex = 0; 
# 313
DistanceType furthest = (0); 
# 314
for (index = 0; index < n; index++) { 
# 317
if ((closestDistSq[index]) > (kSpeedUpFactor * ((float)furthest))) { 
# 320
double newPot = (0); 
# 321
for (int i = 0; i < n; i++) { 
# 322
newPot += std::min((distance)((dataset)[dsindices[i]], (dataset)[dsindices[index]], ((dataset).cols)), closestDistSq[i]); 
# 324
}  
# 327
if ((bestNewPot < (0)) || (newPot <= bestNewPot)) { 
# 328
bestNewPot = newPot; 
# 329
bestNewIndex = index; 
# 330
furthest = (closestDistSq[index]); 
# 331
}  
# 332
}  
# 333
}  
# 336
(centers[centerCount]) = (dsindices[bestNewIndex]); 
# 337
for (int i = 0; i < n; i++) { 
# 338
(closestDistSq[i]) = std::min((distance)((dataset)[dsindices[i]], (dataset)[dsindices[bestNewIndex]], ((dataset).cols)), closestDistSq[i]); 
# 340
}  
# 341
}  
# 343
centers_length = centerCount; 
# 345
delete [] closestDistSq; 
# 346
} 
# 359 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
public: HierarchicalClusteringIndex(const Matrix< ElementType>  &inputData, const cvflann::IndexParams &index_params = cvflann::HierarchicalClusteringIndexParams(), Distance 
# 360
d = Distance()) : dataset(inputData), params(index_params), root((__null)), indices((__null)), distance(d) 
# 362
{ 
# 363
(memoryCounter) = 0; 
# 365
(size_) = ((dataset).rows); 
# 366
(veclen_) = ((dataset).cols); 
# 368
(branching_) = get_param(params, "branching", 32); 
# 369
(centers_init_) = get_param(params, "centers_init", FLANN_CENTERS_RANDOM); 
# 370
(trees_) = get_param(params, "trees", 4); 
# 371
(leaf_size_) = get_param(params, "leaf_size", 100); 
# 373
if ((centers_init_) == (FLANN_CENTERS_RANDOM)) { 
# 374
(chooseCenters) = (&HierarchicalClusteringIndex< Distance> ::chooseCentersRandom); 
# 375
} else { 
# 376
if ((centers_init_) == (FLANN_CENTERS_GONZALES)) { 
# 377
(chooseCenters) = (&HierarchicalClusteringIndex< Distance> ::chooseCentersGonzales); 
# 378
} else { 
# 379
if ((centers_init_) == (FLANN_CENTERS_KMEANSPP)) { 
# 380
(chooseCenters) = (&HierarchicalClusteringIndex< Distance> ::chooseCentersKMeanspp); 
# 381
} else { 
# 382
if ((centers_init_) == (FLANN_CENTERS_GROUPWISE)) { 
# 383
(chooseCenters) = (&HierarchicalClusteringIndex< Distance> ::GroupWiseCenterChooser); 
# 384
} else 
# 385
{ 
# 386
throw ((cvflann::FLANNException)("Unknown algorithm for choosing initial centers.")); 
# 387
}  }  }  }  
# 389
(trees_) = get_param(params, "trees", 4); 
# 390
(root) = (new NodePtr [trees_]); 
# 391
(indices) = (new int *[trees_]); 
# 393
for (int i = 0; i < (trees_); ++i) { 
# 394
((root)[i]) = __null; 
# 395
((indices)[i]) = (__null); 
# 396
}  
# 397
} 
# 399
HierarchicalClusteringIndex(const HierarchicalClusteringIndex &); 
# 400
HierarchicalClusteringIndex &operator=(const HierarchicalClusteringIndex &); 
# 407
virtual ~HierarchicalClusteringIndex() 
# 408
{ 
# 409
free_elements(); 
# 411
if ((root) != __null) { 
# 412
delete [] (root); 
# 413
}  
# 415
if ((indices) != (__null)) { 
# 416
delete [] (indices); 
# 417
}  
# 418
} 
# 424
void free_elements() 
# 425
{ 
# 426
if ((indices) != (__null)) { 
# 427
for (int i = 0; i < (trees_); ++i) { 
# 428
if (((indices)[i]) != (__null)) { 
# 429
delete [] ((indices)[i]); 
# 430
((indices)[i]) = (__null); 
# 431
}  
# 432
}  
# 433
}  
# 434
} 
# 440
::size_t size() const override 
# 441
{ 
# 442
return size_; 
# 443
} 
# 448
::size_t veclen() const override 
# 449
{ 
# 450
return veclen_; 
# 451
} 
# 458
int usedMemory() const override 
# 459
{ 
# 460
return (((pool).usedMemory) + ((pool).wastedMemory)) + (memoryCounter); 
# 461
} 
# 466
void buildIndex() override 
# 467
{ 
# 468
if ((branching_) < 2) { 
# 469
throw ((cvflann::FLANNException)("Branching factor must be at least 2")); 
# 470
}  
# 472
free_elements(); 
# 474
for (int i = 0; i < (trees_); ++i) { 
# 475
((indices)[i]) = (new int [size_]); 
# 476
for (::size_t j = (0); j < (size_); ++j) { 
# 477
(((indices)[i])[j]) = ((int)j); 
# 478
}  
# 479
((root)[i]) = (pool).template allocate< Node> (); 
# 480
computeClustering((root)[i], (indices)[i], (int)(size_), branching_, 0); 
# 481
}  
# 482
} 
# 485
cvflann::flann_algorithm_t getType() const override 
# 486
{ 
# 487
return FLANN_INDEX_HIERARCHICAL; 
# 488
} 
# 491
void saveIndex(::FILE *stream) override 
# 492
{ 
# 493
save_value(stream, branching_); 
# 494
save_value(stream, trees_); 
# 495
save_value(stream, centers_init_); 
# 496
save_value(stream, leaf_size_); 
# 497
save_value(stream, memoryCounter); 
# 498
for (int i = 0; i < (trees_); ++i) { 
# 499
save_value(stream, *((indices)[i]), size_); 
# 500
save_tree(stream, (root)[i], i); 
# 501
}  
# 503
} 
# 506
void loadIndex(::FILE *stream) override 
# 507
{ 
# 508
free_elements(); 
# 510
if ((root) != __null) { 
# 511
delete [] (root); 
# 512
}  
# 514
if ((indices) != (__null)) { 
# 515
delete [] (indices); 
# 516
}  
# 518
load_value(stream, branching_); 
# 519
load_value(stream, trees_); 
# 520
load_value(stream, centers_init_); 
# 521
load_value(stream, leaf_size_); 
# 522
load_value(stream, memoryCounter); 
# 524
(indices) = (new int *[trees_]); 
# 525
(root) = (new NodePtr [trees_]); 
# 526
for (int i = 0; i < (trees_); ++i) { 
# 527
((indices)[i]) = (new int [size_]); 
# 528
load_value(stream, *((indices)[i]), size_); 
# 529
load_tree(stream, (root)[i], i); 
# 530
}  
# 532
(params)["algorithm"] = getType(); 
# 533
(((params)["branching"]) = (branching_)); 
# 534
(((params)["trees"]) = (trees_)); 
# 535
(((params)["centers_init"]) = (centers_init_)); 
# 536
(((params)["leaf_size"]) = (leaf_size_)); 
# 537
} 
# 549 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
void findNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, const cvflann::SearchParams &searchParams) override 
# 550
{ 
# 552
int maxChecks = get_param(searchParams, "checks", 32); 
# 555
Heap< BranchSt>  *heap = new Heap< BranchSt> ((int)(size_)); 
# 557
std::vector< bool>  checked(size_, false); 
# 558
int checks = 0; 
# 559
for (int i = 0; i < (trees_); ++i) { 
# 560
findNN((root)[i], result, vec, checks, maxChecks, heap, checked); 
# 561
}  
# 563
BranchSt branch; 
# 564
while (heap->popMin(branch) && ((checks < maxChecks) || (!result.full()))) { 
# 565
NodePtr node = ((branch.node)); 
# 566
findNN(node, result, vec, checks, maxChecks, heap, checked); 
# 567
}  
# 568
(static_cast< bool>(result.full())) ? (void)0 : __assert_fail("result.full()", "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h", 568, __extension__ __PRETTY_FUNCTION__); 
# 570
delete heap; 
# 572
} 
# 574
cvflann::IndexParams getParameters() const override 
# 575
{ 
# 576
return params; 
# 577
} 
# 585
private: struct Node { 
# 590
int pivot; 
# 594
int size; 
# 598
Node **childs; 
# 602
int *indices; 
# 606
int level; 
# 607
}; 
# 608
typedef Node *NodePtr; 
# 615
typedef BranchStruct< NodePtr, DistanceType>  BranchSt; 
# 619
void save_tree(::FILE *stream, NodePtr node, int num) 
# 620
{ 
# 621
save_value(stream, *node); 
# 622
if ((node->childs) == __null) { 
# 623
int indices_offset = (int)((node->indices) - ((indices)[num])); 
# 624
save_value(stream, indices_offset); 
# 625
} else 
# 626
{ 
# 627
for (int i = 0; i < (branching_); ++i) { 
# 628
save_tree(stream, (node->childs)[i], num); 
# 629
}  
# 630
}  
# 631
} 
# 634
void load_tree(::FILE *stream, NodePtr &node, int num) 
# 635
{ 
# 636
node = (pool).template allocate< Node> (); 
# 637
load_value(stream, *node); 
# 638
if ((node->childs) == __null) { 
# 639
int indices_offset; 
# 640
load_value(stream, indices_offset); 
# 641
(node->indices) = (((indices)[num]) + indices_offset); 
# 642
} else 
# 643
{ 
# 644
(node->childs) = (pool).template allocate< NodePtr> (branching_); 
# 645
for (int i = 0; i < (branching_); ++i) { 
# 646
load_tree(stream, (node->childs)[i], num); 
# 647
}  
# 648
}  
# 649
} 
# 654
void computeLabels(int *dsindices, int indices_length, int *centers, int centers_length, int *labels, DistanceType &cost) 
# 655
{ 
# 656
cost = 0; 
# 657
for (int i = 0; i < indices_length; ++i) { 
# 658
ElementType *point = (dataset)[dsindices[i]]; 
# 659
DistanceType dist = (distance)(point, (dataset)[centers[0]], veclen_); 
# 660
(labels[i]) = 0; 
# 661
for (int j = 1; j < centers_length; ++j) { 
# 662
DistanceType new_dist = (distance)(point, (dataset)[centers[j]], veclen_); 
# 663
if (dist > new_dist) { 
# 664
(labels[i]) = j; 
# 665
dist = new_dist; 
# 666
}  
# 667
}  
# 668
cost += dist; 
# 669
}  
# 670
} 
# 683 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
void computeClustering(NodePtr node, int *dsindices, int indices_length, int branching, int level) 
# 684
{ 
# 685
(node->size) = indices_length; 
# 686
(node->level) = level; 
# 688
if (indices_length < (leaf_size_)) { 
# 689
(node->indices) = dsindices; 
# 690
std::sort((node->indices), (node->indices) + indices_length); 
# 691
(node->childs) = __null; 
# 692
return; 
# 693
}  
# 695
std::vector< int>  centers(branching); 
# 696
std::vector< int>  labels(indices_length); 
# 698
int centers_length; 
# 699
(this->*(chooseCenters))(branching, dsindices, indices_length, &centers[0], centers_length); 
# 701
if (centers_length < branching) { 
# 702
(node->indices) = dsindices; 
# 703
std::sort((node->indices), (node->indices) + indices_length); 
# 704
(node->childs) = __null; 
# 705
return; 
# 706
}  
# 710
DistanceType cost; 
# 711
computeLabels(dsindices, indices_length, &centers[0], centers_length, &labels[0], cost); 
# 713
(node->childs) = (pool).template allocate< NodePtr> (branching); 
# 714
int start = 0; 
# 715
int end = start; 
# 716
for (int i = 0; i < branching; ++i) { 
# 717
for (int j = 0; j < indices_length; ++j) { 
# 718
if (labels[j] == i) { 
# 719
std::swap(dsindices[j], dsindices[end]); 
# 720
std::swap(labels[j], labels[end]); 
# 721
end++; 
# 722
}  
# 723
}  
# 725
((node->childs)[i]) = (pool).template allocate< Node> (); 
# 726
(((node->childs)[i])->pivot) = centers[i]; 
# 727
(((node->childs)[i])->indices) = __null; 
# 728
computeClustering((node->childs)[i], dsindices + start, end - start, branching, level + 1); 
# 729
start = end; 
# 730
}  
# 731
} 
# 748 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
void findNN(NodePtr node, ResultSet< DistanceType>  &result, const ElementType *vec, int &checks, int maxChecks, Heap< BranchSt>  *
# 749
heap, std::vector< bool>  &checked) 
# 750
{ 
# 751
if ((node->childs) == __null) { 
# 752
if (checks >= maxChecks) { 
# 753
if (result.full()) { return; }  
# 754
}  
# 755
for (int i = 0; i < (node->size); ++i) { 
# 756
int index = (node->indices)[i]; 
# 757
if (!checked[index]) { 
# 758
DistanceType dist = (distance)((dataset)[index], vec, veclen_); 
# 759
result.addPoint(dist, index); 
# 760
((checked[index]) = (true)); 
# 761
++checks; 
# 762
}  
# 763
}  
# 764
} else 
# 765
{ 
# 766
DistanceType *domain_distances = new DistanceType [branching_]; 
# 767
int best_index = 0; 
# 768
(domain_distances[best_index]) = (distance)(vec, (dataset)[((node->childs)[best_index])->pivot], veclen_); 
# 769
for (int i = 1; i < (branching_); ++i) { 
# 770
(domain_distances[i]) = (distance)(vec, (dataset)[((node->childs)[i])->pivot], veclen_); 
# 771
if ((domain_distances[i]) < (domain_distances[best_index])) { 
# 772
best_index = i; 
# 773
}  
# 774
}  
# 775
for (int i = 0; i < (branching_); ++i) { 
# 776
if (i != best_index) { 
# 777
heap->insert(BranchSt((node->childs)[i], domain_distances[i])); 
# 778
}  
# 779
}  
# 780
delete [] domain_distances; 
# 781
findNN((node->childs)[best_index], result, vec, checks, maxChecks, heap, checked); 
# 782
}  
# 783
} 
# 791
const Matrix< ElementType>  dataset; 
# 796
cvflann::IndexParams params; 
# 802
::size_t size_; 
# 807
::size_t veclen_; 
# 812
NodePtr *root; 
# 817
int **indices; 
# 823
Distance distance; 
# 832 "/usr/include/opencv4/opencv2/flann/hierarchical_clustering_index.h" 3
cvflann::PooledAllocator pool; 
# 837
int memoryCounter; 
# 840
int branching_; 
# 841
int trees_; 
# 842
cvflann::flann_centers_init_t centers_init_; 
# 843
int leaf_size_; 
# 846
}; 
# 848
}
# 41 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
class time_base { 
# 55
public: enum dateorder { no_order, dmy, mdy, ymd, ydm}; 
# 56
}; 
# 58
template< class _CharT> 
# 59
struct __timepunct_cache : public locale::facet { 
# 62
static const _CharT *_S_timezones[14]; 
# 64
const _CharT *_M_date_format; 
# 65
const _CharT *_M_date_era_format; 
# 66
const _CharT *_M_time_format; 
# 67
const _CharT *_M_time_era_format; 
# 68
const _CharT *_M_date_time_format; 
# 69
const _CharT *_M_date_time_era_format; 
# 70
const _CharT *_M_am; 
# 71
const _CharT *_M_pm; 
# 72
const _CharT *_M_am_pm_format; 
# 75
const _CharT *_M_day1; 
# 76
const _CharT *_M_day2; 
# 77
const _CharT *_M_day3; 
# 78
const _CharT *_M_day4; 
# 79
const _CharT *_M_day5; 
# 80
const _CharT *_M_day6; 
# 81
const _CharT *_M_day7; 
# 84
const _CharT *_M_aday1; 
# 85
const _CharT *_M_aday2; 
# 86
const _CharT *_M_aday3; 
# 87
const _CharT *_M_aday4; 
# 88
const _CharT *_M_aday5; 
# 89
const _CharT *_M_aday6; 
# 90
const _CharT *_M_aday7; 
# 93
const _CharT *_M_month01; 
# 94
const _CharT *_M_month02; 
# 95
const _CharT *_M_month03; 
# 96
const _CharT *_M_month04; 
# 97
const _CharT *_M_month05; 
# 98
const _CharT *_M_month06; 
# 99
const _CharT *_M_month07; 
# 100
const _CharT *_M_month08; 
# 101
const _CharT *_M_month09; 
# 102
const _CharT *_M_month10; 
# 103
const _CharT *_M_month11; 
# 104
const _CharT *_M_month12; 
# 107
const _CharT *_M_amonth01; 
# 108
const _CharT *_M_amonth02; 
# 109
const _CharT *_M_amonth03; 
# 110
const _CharT *_M_amonth04; 
# 111
const _CharT *_M_amonth05; 
# 112
const _CharT *_M_amonth06; 
# 113
const _CharT *_M_amonth07; 
# 114
const _CharT *_M_amonth08; 
# 115
const _CharT *_M_amonth09; 
# 116
const _CharT *_M_amonth10; 
# 117
const _CharT *_M_amonth11; 
# 118
const _CharT *_M_amonth12; 
# 120
bool _M_allocated; 
# 122
__timepunct_cache(size_t __refs = 0) : locale::facet(__refs), _M_date_format((0)), _M_date_era_format((0)), _M_time_format((0)), _M_time_era_format((0)), _M_date_time_format((0)), _M_date_time_era_format((0)), _M_am((0)), _M_pm((0)), _M_am_pm_format((0)), _M_day1((0)), _M_day2((0)), _M_day3((0)), _M_day4((0)), _M_day5((0)), _M_day6((0)), _M_day7((0)), _M_aday1((0)), _M_aday2((0)), _M_aday3((0)), _M_aday4((0)), _M_aday5((0)), _M_aday6((0)), _M_aday7((0)), _M_month01((0)), _M_month02((0)), _M_month03((0)), _M_month04((0)), _M_month05((0)), _M_month06((0)), _M_month07((0)), _M_month08((0)), _M_month09((0)), _M_month10((0)), _M_month11((0)), _M_month12((0)), _M_amonth01((0)), _M_amonth02((0)), _M_amonth03((0)), _M_amonth04((0)), _M_amonth05((0)), _M_amonth06((0)), _M_amonth07((0)), _M_amonth08((0)), _M_amonth09((0)), _M_amonth10((0)), _M_amonth11((0)), _M_amonth12((0)), _M_allocated(false) 
# 137
{ } 
# 139
virtual ~__timepunct_cache(); 
# 143
private: __timepunct_cache &operator=(const __timepunct_cache &); 
# 146
explicit __timepunct_cache(const __timepunct_cache &); 
# 147
}; 
# 149
template< class _CharT> 
# 150
__timepunct_cache< _CharT> ::~__timepunct_cache() 
# 151
{ 
# 152
if (_M_allocated) 
# 153
{ 
# 155
}  
# 156
} 
# 161
template<> const char *__timepunct_cache< char> ::_S_timezones[14]; 
# 166
template<> const wchar_t *__timepunct_cache< wchar_t> ::_S_timezones[14]; 
# 170
template< class _CharT> const _CharT *
# 171
__timepunct_cache< _CharT> ::_S_timezones[14]; 
# 173
template< class _CharT> 
# 174
class __timepunct : public locale::facet { 
# 178
public: typedef _CharT __char_type; 
# 179
typedef __timepunct_cache< _CharT>  __cache_type; 
# 182
protected: __cache_type *_M_data; 
# 183
__c_locale _M_c_locale_timepunct; 
# 184
const char *_M_name_timepunct; 
# 188
public: static locale::id id; 
# 191
explicit __timepunct(size_t __refs = 0); 
# 194
explicit __timepunct(__cache_type * __cache, size_t __refs = 0); 
# 207 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit __timepunct(__c_locale __cloc, const char * __s, size_t __refs = 0); 
# 212
void _M_put(_CharT * __s, size_t __maxlen, const _CharT * __format, const tm * __tm) const throw(); 
# 216
void _M_date_formats(const _CharT **__date) const 
# 217
{ 
# 219
(__date[0]) = ((_M_data)->_M_date_format); 
# 220
(__date[1]) = ((_M_data)->_M_date_era_format); 
# 221
} 
# 224
void _M_time_formats(const _CharT **__time) const 
# 225
{ 
# 227
(__time[0]) = ((_M_data)->_M_time_format); 
# 228
(__time[1]) = ((_M_data)->_M_time_era_format); 
# 229
} 
# 232
void _M_date_time_formats(const _CharT **__dt) const 
# 233
{ 
# 235
(__dt[0]) = ((_M_data)->_M_date_time_format); 
# 236
(__dt[1]) = ((_M_data)->_M_date_time_era_format); 
# 237
} 
# 241
void _M_am_pm_format(const _CharT *) const 
# 242
{ } 
# 246
void _M_am_pm(const _CharT **__ampm) const 
# 247
{ 
# 248
(__ampm[0]) = ((_M_data)->_M_am); 
# 249
(__ampm[1]) = ((_M_data)->_M_pm); 
# 250
} 
# 253
void _M_days(const _CharT **__days) const 
# 254
{ 
# 255
(__days[0]) = ((_M_data)->_M_day1); 
# 256
(__days[1]) = ((_M_data)->_M_day2); 
# 257
(__days[2]) = ((_M_data)->_M_day3); 
# 258
(__days[3]) = ((_M_data)->_M_day4); 
# 259
(__days[4]) = ((_M_data)->_M_day5); 
# 260
(__days[5]) = ((_M_data)->_M_day6); 
# 261
(__days[6]) = ((_M_data)->_M_day7); 
# 262
} 
# 265
void _M_days_abbreviated(const _CharT **__days) const 
# 266
{ 
# 267
(__days[0]) = ((_M_data)->_M_aday1); 
# 268
(__days[1]) = ((_M_data)->_M_aday2); 
# 269
(__days[2]) = ((_M_data)->_M_aday3); 
# 270
(__days[3]) = ((_M_data)->_M_aday4); 
# 271
(__days[4]) = ((_M_data)->_M_aday5); 
# 272
(__days[5]) = ((_M_data)->_M_aday6); 
# 273
(__days[6]) = ((_M_data)->_M_aday7); 
# 274
} 
# 277
void _M_months(const _CharT **__months) const 
# 278
{ 
# 279
(__months[0]) = ((_M_data)->_M_month01); 
# 280
(__months[1]) = ((_M_data)->_M_month02); 
# 281
(__months[2]) = ((_M_data)->_M_month03); 
# 282
(__months[3]) = ((_M_data)->_M_month04); 
# 283
(__months[4]) = ((_M_data)->_M_month05); 
# 284
(__months[5]) = ((_M_data)->_M_month06); 
# 285
(__months[6]) = ((_M_data)->_M_month07); 
# 286
(__months[7]) = ((_M_data)->_M_month08); 
# 287
(__months[8]) = ((_M_data)->_M_month09); 
# 288
(__months[9]) = ((_M_data)->_M_month10); 
# 289
(__months[10]) = ((_M_data)->_M_month11); 
# 290
(__months[11]) = ((_M_data)->_M_month12); 
# 291
} 
# 294
void _M_months_abbreviated(const _CharT **__months) const 
# 295
{ 
# 296
(__months[0]) = ((_M_data)->_M_amonth01); 
# 297
(__months[1]) = ((_M_data)->_M_amonth02); 
# 298
(__months[2]) = ((_M_data)->_M_amonth03); 
# 299
(__months[3]) = ((_M_data)->_M_amonth04); 
# 300
(__months[4]) = ((_M_data)->_M_amonth05); 
# 301
(__months[5]) = ((_M_data)->_M_amonth06); 
# 302
(__months[6]) = ((_M_data)->_M_amonth07); 
# 303
(__months[7]) = ((_M_data)->_M_amonth08); 
# 304
(__months[8]) = ((_M_data)->_M_amonth09); 
# 305
(__months[9]) = ((_M_data)->_M_amonth10); 
# 306
(__months[10]) = ((_M_data)->_M_amonth11); 
# 307
(__months[11]) = ((_M_data)->_M_amonth12); 
# 308
} 
# 312
protected: virtual ~__timepunct(); 
# 316
void _M_initialize_timepunct(__c_locale __cloc = 0); 
# 317
}; 
# 319
template< class _CharT> locale::id 
# 320
__timepunct< _CharT> ::id; 
# 325
template<> void __timepunct< char> ::_M_initialize_timepunct(__c_locale __cloc); 
# 329
template<> void __timepunct< char> ::_M_put(char *, size_t, const char *, const tm *) const throw(); 
# 334
template<> void __timepunct< wchar_t> ::_M_initialize_timepunct(__c_locale __cloc); 
# 338
template<> void __timepunct< wchar_t> ::_M_put(wchar_t *, size_t, const wchar_t *, const tm *) const throw(); 
# 343
}
# 37 "/usr/include/x86_64-linux-gnu/c++/9/bits/time_members.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 41
template< class _CharT> 
# 42
__timepunct< _CharT> ::__timepunct(size_t __refs) : locale::facet(__refs), _M_data((0)), _M_c_locale_timepunct((0)), _M_name_timepunct(_S_get_c_name()) 
# 45
{ _M_initialize_timepunct(); } 
# 47
template< class _CharT> 
# 48
__timepunct< _CharT> ::__timepunct(__cache_type *__cache, size_t __refs) : locale::facet(__refs), _M_data(__cache), _M_c_locale_timepunct((0)), _M_name_timepunct(_S_get_c_name()) 
# 51
{ _M_initialize_timepunct(); } 
# 53
template< class _CharT> 
# 54
__timepunct< _CharT> ::__timepunct(__c_locale __cloc, const char *__s, size_t 
# 55
__refs) : locale::facet(__refs), _M_data((0)), _M_c_locale_timepunct((0)), _M_name_timepunct((0)) 
# 58
{ 
# 59
if (__builtin_strcmp(__s, _S_get_c_name()) != 0) 
# 60
{ 
# 61
const size_t __len = __builtin_strlen(__s) + (1); 
# 62
char *__tmp = new char [__len]; 
# 63
__builtin_memcpy(__tmp, __s, __len); 
# 64
(_M_name_timepunct) = __tmp; 
# 65
} else { 
# 67
(_M_name_timepunct) = _S_get_c_name(); }  
# 69
try 
# 70
{ _M_initialize_timepunct(__cloc); } 
# 71
catch (...) 
# 72
{ 
# 73
if ((_M_name_timepunct) != _S_get_c_name()) { 
# 74
delete [] (_M_name_timepunct); }  
# 75
throw; 
# 76
}  
# 77
} 
# 79
template< class _CharT> 
# 80
__timepunct< _CharT> ::~__timepunct() 
# 81
{ 
# 82
if ((_M_name_timepunct) != _S_get_c_name()) { 
# 83
delete [] (_M_name_timepunct); }  
# 84
delete (_M_data); 
# 85
_S_destroy_c_locale(_M_c_locale_timepunct); 
# 86
} 
# 89
}
# 348 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 352
inline namespace __cxx11 { 
# 367 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
template< class _CharT, class _InIter> 
# 368
class time_get : public locale::facet, public time_base { 
# 374
public: typedef _CharT char_type; 
# 375
typedef _InIter iter_type; 
# 379
static locale::id id; 
# 389 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit time_get(size_t __refs = 0) : locale::facet(__refs) 
# 390
{ } 
# 406 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
dateorder date_order() const 
# 407
{ return do_date_order(); } 
# 430 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type get_time(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 431
__err, tm *__tm) const 
# 432
{ return do_get_time(__beg, __end, __io, __err, __tm); } 
# 455 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type get_date(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 456
__err, tm *__tm) const 
# 457
{ return do_get_date(__beg, __end, __io, __err, __tm); } 
# 483 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type get_weekday(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 484
__err, tm *__tm) const 
# 485
{ return do_get_weekday(__beg, __end, __io, __err, __tm); } 
# 512 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type get_monthname(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 513
__err, tm *__tm) const 
# 514
{ return do_get_monthname(__beg, __end, __io, __err, __tm); } 
# 538 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type get_year(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 539
__err, tm *__tm) const 
# 540
{ return do_get_year(__beg, __end, __io, __err, __tm); } 
# 559 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type get(iter_type __s, iter_type __end, ios_base &__io, ios_base::iostate &
# 560
__err, tm *__tm, char __format, char 
# 561
__modifier = 0) const 
# 562
{ 
# 563
return do_get(__s, __end, __io, __err, __tm, __format, __modifier); 
# 565
} 
# 585 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
inline iter_type get(iter_type __s, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm, const char_type * __fmt, const char_type * __fmtend) const; 
# 593
protected: virtual ~time_get() { } 
# 606 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual dateorder do_date_order() const; 
# 624 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_time(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm) const; 
# 643 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_date(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm) const; 
# 662 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_weekday(iter_type __beg, iter_type __end, ios_base &, ios_base::iostate & __err, tm * __tm) const; 
# 681 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_monthname(iter_type __beg, iter_type __end, ios_base &, ios_base::iostate & __err, tm * __tm) const; 
# 700 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_get_year(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm) const; 
# 725 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
inline virtual iter_type do_get(iter_type __s, iter_type __end, ios_base & __f, ios_base::iostate & __err, tm * __tm, char __format, char __modifier) const; 
# 732
iter_type _M_extract_num(iter_type __beg, iter_type __end, int & __member, int __min, int __max, size_t __len, ios_base & __io, ios_base::iostate & __err) const; 
# 738
iter_type _M_extract_name(iter_type __beg, iter_type __end, int & __member, const _CharT ** __names, size_t __indexlen, ios_base & __io, ios_base::iostate & __err) const; 
# 744
iter_type _M_extract_wday_or_month(iter_type __beg, iter_type __end, int & __member, const _CharT ** __names, size_t __indexlen, ios_base & __io, ios_base::iostate & __err) const; 
# 750
iter_type _M_extract_via_format(iter_type __beg, iter_type __end, ios_base & __io, ios_base::iostate & __err, tm * __tm, const _CharT * __format) const; 
# 753
}; 
# 755
template< class _CharT, class _InIter> locale::id 
# 756
time_get< _CharT, _InIter> ::id; 
# 759
template< class _CharT, class _InIter> 
# 760
class time_get_byname : public time_get< _CharT, _InIter>  { 
# 764
public: typedef _CharT char_type; 
# 765
typedef _InIter iter_type; 
# 768
explicit time_get_byname(const char *, std::size_t __refs = 0) : time_get< _CharT, _InIter> (__refs) 
# 769
{ } 
# 773
explicit time_get_byname(const std::string &__s, std::size_t __refs = 0) : time_get_byname(__s.c_str(), __refs) 
# 774
{ } 
# 779
protected: virtual ~time_get_byname() { } 
# 780
}; 
# 782
}
# 796 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
template< class _CharT, class _OutIter> 
# 797
class time_put : public locale::facet { 
# 803
public: typedef _CharT char_type; 
# 804
typedef _OutIter iter_type; 
# 808
static locale::id id; 
# 818 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit time_put(size_t __refs = 0) : locale::facet(__refs) 
# 819
{ } 
# 837 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type put(iter_type __s, ios_base & __io, char_type __fill, const tm * __tm, const _CharT * __beg, const _CharT * __end) const; 
# 857 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type put(iter_type __s, ios_base &__io, char_type __fill, const tm *
# 858
__tm, char __format, char __mod = 0) const 
# 859
{ return do_put(__s, __io, __fill, __tm, __format, __mod); } 
# 864
protected: virtual ~time_put() 
# 865
{ } 
# 884 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_put(iter_type __s, ios_base & __io, char_type __fill, const tm * __tm, char __format, char __mod) const; 
# 886
}; 
# 888
template< class _CharT, class _OutIter> locale::id 
# 889
time_put< _CharT, _OutIter> ::id; 
# 892
template< class _CharT, class _OutIter> 
# 893
class time_put_byname : public time_put< _CharT, _OutIter>  { 
# 897
public: typedef _CharT char_type; 
# 898
typedef _OutIter iter_type; 
# 901
explicit time_put_byname(const char *, std::size_t __refs = 0) : time_put< _CharT, _OutIter> (__refs) 
# 903
{ } 
# 907
explicit time_put_byname(const std::string &__s, std::size_t __refs = 0) : time_put_byname(__s.c_str(), __refs) 
# 908
{ } 
# 913
protected: virtual ~time_put_byname() { } 
# 914
}; 
# 928 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
class money_base { 
# 931
public: enum part { none, space, symbol, sign, value}; 
# 932
struct pattern { char field[4]; }; 
# 934
static const pattern _S_default_pattern; 
# 937
enum { 
# 938
_S_minus, 
# 939
_S_zero, 
# 940
_S_end = 11
# 941
}; 
# 945
static const char *_S_atoms; 
# 949
__attribute((const)) static pattern 
# 950
_S_construct_pattern(char __precedes, char __space, char __posn) throw(); 
# 951
}; 
# 953
template< class _CharT, bool _Intl> 
# 954
struct __moneypunct_cache : public locale::facet { 
# 956
const char *_M_grouping; 
# 957
size_t _M_grouping_size; 
# 958
bool _M_use_grouping; 
# 959
_CharT _M_decimal_point; 
# 960
_CharT _M_thousands_sep; 
# 961
const _CharT *_M_curr_symbol; 
# 962
size_t _M_curr_symbol_size; 
# 963
const _CharT *_M_positive_sign; 
# 964
size_t _M_positive_sign_size; 
# 965
const _CharT *_M_negative_sign; 
# 966
size_t _M_negative_sign_size; 
# 967
int _M_frac_digits; 
# 968
money_base::pattern _M_pos_format; 
# 969
money_base::pattern _M_neg_format; 
# 974
_CharT _M_atoms[money_base::_S_end]; 
# 976
bool _M_allocated; 
# 978
__moneypunct_cache(size_t __refs = 0) : locale::facet(__refs), _M_grouping((0)), _M_grouping_size((0)), _M_use_grouping(false), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_curr_symbol((0)), _M_curr_symbol_size((0)), _M_positive_sign((0)), _M_positive_sign_size((0)), _M_negative_sign((0)), _M_negative_sign_size((0)), _M_frac_digits(0), _M_pos_format(money_base::pattern()), _M_neg_format(money_base::pattern()), _M_allocated(false) 
# 987
{ } 
# 989
virtual ~__moneypunct_cache(); 
# 992
void _M_cache(const locale & __loc); 
# 996
private: __moneypunct_cache &operator=(const __moneypunct_cache &); 
# 999
explicit __moneypunct_cache(const __moneypunct_cache &); 
# 1000
}; 
# 1002
template< class _CharT, bool _Intl> 
# 1003
__moneypunct_cache< _CharT, _Intl> ::~__moneypunct_cache() 
# 1004
{ 
# 1005
if (_M_allocated) 
# 1006
{ 
# 1007
delete [] (_M_grouping); 
# 1008
delete [] (_M_curr_symbol); 
# 1009
delete [] (_M_positive_sign); 
# 1010
delete [] (_M_negative_sign); 
# 1011
}  
# 1012
} 
# 1014
inline namespace __cxx11 { 
# 1023 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
template< class _CharT, bool _Intl> 
# 1024
class moneypunct : public locale::facet, public money_base { 
# 1030
public: typedef _CharT char_type; 
# 1031
typedef basic_string< _CharT>  string_type; 
# 1033
typedef __moneypunct_cache< _CharT, _Intl>  __cache_type; 
# 1036
private: __cache_type *_M_data; 
# 1041
public: static const bool intl = _Intl; 
# 1043
static locale::id id; 
# 1053 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit moneypunct(size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1055
{ _M_initialize_moneypunct(); } 
# 1066 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit moneypunct(__cache_type *__cache, size_t __refs = 0) : locale::facet(__refs), _M_data(__cache) 
# 1068
{ _M_initialize_moneypunct(); } 
# 1081 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit moneypunct(__c_locale __cloc, const char *__s, size_t __refs = 0) : locale::facet(__refs), _M_data((0)) 
# 1083
{ _M_initialize_moneypunct(__cloc, __s); } 
# 1095 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
char_type decimal_point() const 
# 1096
{ return do_decimal_point(); } 
# 1108 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
char_type thousands_sep() const 
# 1109
{ return do_thousands_sep(); } 
# 1138 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
string grouping() const 
# 1139
{ return do_grouping(); } 
# 1151 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
string_type curr_symbol() const 
# 1152
{ return do_curr_symbol(); } 
# 1168 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
string_type positive_sign() const 
# 1169
{ return do_positive_sign(); } 
# 1185 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
string_type negative_sign() const 
# 1186
{ return do_negative_sign(); } 
# 1201 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
int frac_digits() const 
# 1202
{ return do_frac_digits(); } 
# 1237 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
pattern pos_format() const 
# 1238
{ return do_pos_format(); } 
# 1241
pattern neg_format() const 
# 1242
{ return do_neg_format(); } 
# 1248
protected: virtual ~moneypunct(); 
# 1259 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual char_type do_decimal_point() const 
# 1260
{ return (_M_data)->_M_decimal_point; } 
# 1271 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual char_type do_thousands_sep() const 
# 1272
{ return (_M_data)->_M_thousands_sep; } 
# 1284 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual string do_grouping() const 
# 1285
{ return (_M_data)->_M_grouping; } 
# 1297 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual string_type do_curr_symbol() const 
# 1298
{ return (_M_data)->_M_curr_symbol; } 
# 1310 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual string_type do_positive_sign() const 
# 1311
{ return (_M_data)->_M_positive_sign; } 
# 1323 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual string_type do_negative_sign() const 
# 1324
{ return (_M_data)->_M_negative_sign; } 
# 1337 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual int do_frac_digits() const 
# 1338
{ return (_M_data)->_M_frac_digits; } 
# 1351 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual pattern do_pos_format() const 
# 1352
{ return (_M_data)->_M_pos_format; } 
# 1365 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual pattern do_neg_format() const 
# 1366
{ return (_M_data)->_M_neg_format; } 
# 1370
void _M_initialize_moneypunct(__c_locale __cloc = 0, const char * __name = 0); 
# 1372
}; 
# 1374
template< class _CharT, bool _Intl> locale::id 
# 1375
moneypunct< _CharT, _Intl> ::id; 
# 1377
template< class _CharT, bool _Intl> const bool moneypunct< _CharT, _Intl> ::intl; 
# 1381
template<> moneypunct< char, true> ::~moneypunct(); 
# 1384
template<> moneypunct< char> ::~moneypunct(); 
# 1388
template<> void moneypunct< char, true> ::_M_initialize_moneypunct(__c_locale, const char *); 
# 1392
template<> void moneypunct< char> ::_M_initialize_moneypunct(__c_locale, const char *); 
# 1396
template<> moneypunct< wchar_t, true> ::~moneypunct(); 
# 1399
template<> moneypunct< wchar_t> ::~moneypunct(); 
# 1403
template<> void moneypunct< wchar_t, true> ::_M_initialize_moneypunct(__c_locale, const char *); 
# 1408
template<> void moneypunct< wchar_t> ::_M_initialize_moneypunct(__c_locale, const char *); 
# 1413
template< class _CharT, bool _Intl> 
# 1414
class moneypunct_byname : public moneypunct< _CharT, _Intl>  { 
# 1417
public: typedef _CharT char_type; 
# 1418
typedef basic_string< _CharT>  string_type; 
# 1420
static const bool intl = _Intl; 
# 1423
explicit moneypunct_byname(const char *__s, std::size_t __refs = 0) : moneypunct< _CharT, _Intl> (__refs) 
# 1425
{ 
# 1426
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 1428
{ 
# 1429
std::__c_locale __tmp; 
# 1430
this->_S_create_c_locale(__tmp, __s); 
# 1431
this->_M_initialize_moneypunct(__tmp); 
# 1432
this->_S_destroy_c_locale(__tmp); 
# 1433
}  
# 1434
} 
# 1438
explicit moneypunct_byname(const std::string &__s, std::size_t __refs = 0) : moneypunct_byname(__s.c_str(), __refs) 
# 1439
{ } 
# 1444
protected: virtual ~moneypunct_byname() { } 
# 1445
}; 
# 1447
template< class _CharT, bool _Intl> const bool moneypunct_byname< _CharT, _Intl> ::intl; 
# 1450
}
# 1452
inline namespace __cxx11 { 
# 1467 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
template< class _CharT, class _InIter> 
# 1468
class money_get : public locale::facet { 
# 1474
public: typedef _CharT char_type; 
# 1475
typedef _InIter iter_type; 
# 1476
typedef basic_string< _CharT>  string_type; 
# 1480
static locale::id id; 
# 1490 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit money_get(size_t __refs = 0) : locale::facet(__refs) { } 
# 1520 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type get(iter_type __s, iter_type __end, bool __intl, ios_base &__io, ios_base::iostate &
# 1521
__err, long double &__units) const 
# 1522
{ return this->do_get(__s, __end, __intl, __io, __err, __units); } 
# 1551 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type get(iter_type __s, iter_type __end, bool __intl, ios_base &__io, ios_base::iostate &
# 1552
__err, string_type &__digits) const 
# 1553
{ return this->do_get(__s, __end, __intl, __io, __err, __digits); } 
# 1558
protected: virtual ~money_get() { } 
# 1575 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_get(iter_type __s, iter_type __end, bool __intl, ios_base & __io, ios_base::iostate & __err, long double & __units) const; 
# 1587 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_get(iter_type __s, iter_type __end, bool __intl, ios_base & __io, ios_base::iostate & __err, string_type & __digits) const; 
# 1598 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
template< bool _Intl> iter_type _M_extract(iter_type __s, iter_type __end, ios_base & __io, ios_base::iostate & __err, string & __digits) const; 
# 1602
}; 
# 1604
template< class _CharT, class _InIter> locale::id 
# 1605
money_get< _CharT, _InIter> ::id; 
# 1620 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
template< class _CharT, class _OutIter> 
# 1621
class money_put : public locale::facet { 
# 1626
public: typedef _CharT char_type; 
# 1627
typedef _OutIter iter_type; 
# 1628
typedef basic_string< _CharT>  string_type; 
# 1632
static locale::id id; 
# 1642 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit money_put(size_t __refs = 0) : locale::facet(__refs) { } 
# 1662 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type put(iter_type __s, bool __intl, ios_base &__io, char_type 
# 1663
__fill, long double __units) const 
# 1664
{ return this->do_put(__s, __intl, __io, __fill, __units); } 
# 1685 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
iter_type put(iter_type __s, bool __intl, ios_base &__io, char_type 
# 1686
__fill, const string_type &__digits) const 
# 1687
{ return this->do_put(__s, __intl, __io, __fill, __digits); } 
# 1692
protected: virtual ~money_put() { } 
# 1720 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_put(iter_type __s, bool __intl, ios_base & __io, char_type __fill, long double __units) const; 
# 1744 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual iter_type do_put(iter_type __s, bool __intl, ios_base & __io, char_type __fill, const string_type & __digits) const; 
# 1755 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
template< bool _Intl> iter_type _M_insert(iter_type __s, ios_base & __io, char_type __fill, const string_type & __digits) const; 
# 1759
}; 
# 1761
template< class _CharT, class _OutIter> locale::id 
# 1762
money_put< _CharT, _OutIter> ::id; 
# 1764
}
# 1770
struct messages_base { 
# 1772
typedef int catalog; 
# 1773
}; 
# 1775
inline namespace __cxx11 { 
# 1798 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
template< class _CharT> 
# 1799
class messages : public locale::facet, public messages_base { 
# 1805
public: typedef _CharT char_type; 
# 1806
typedef basic_string< _CharT>  string_type; 
# 1812
protected: __c_locale _M_c_locale_messages; 
# 1813
const char *_M_name_messages; 
# 1817
public: static locale::id id; 
# 1827 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit messages(size_t __refs = 0); 
# 1841 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
explicit messages(__c_locale __cloc, const char * __s, size_t __refs = 0); 
# 1854 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
catalog open(const basic_string< char>  &__s, const locale &__loc) const 
# 1855
{ return do_open(__s, __loc); } 
# 1872 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
catalog open(const basic_string< char>  &, const locale &, const char *) const; 
# 1890 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
string_type get(catalog __c, int __set, int __msgid, const string_type &__s) const 
# 1891
{ return do_get(__c, __set, __msgid, __s); } 
# 1901 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
void close(catalog __c) const 
# 1902
{ return do_close(__c); } 
# 1907
protected: virtual ~messages(); 
# 1921 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual catalog do_open(const basic_string< char>  &, const locale &) const; 
# 1940 "/usr/include/c++/9/bits/locale_facets_nonio.h" 3
virtual string_type do_get(catalog, int, int, const string_type & __dfault) const; 
# 1948
virtual void do_close(catalog) const; 
# 1952
char *_M_convert_to_char(const string_type &__msg) const 
# 1953
{ 
# 1955
return reinterpret_cast< char *>(const_cast< _CharT *>(__msg.c_str())); 
# 1956
} 
# 1960
string_type _M_convert_from_char(char *) const 
# 1961
{ 
# 1963
return string_type(); 
# 1964
} 
# 1965
}; 
# 1967
template< class _CharT> locale::id 
# 1968
messages< _CharT> ::id; 
# 1973
template<> string messages< char> ::do_get(catalog, int, int, const string &) const; 
# 1978
template<> wstring messages< wchar_t> ::do_get(catalog, int, int, const wstring &) const; 
# 1982
template< class _CharT> 
# 1983
class messages_byname : public messages< _CharT>  { 
# 1986
public: typedef _CharT char_type; 
# 1987
typedef basic_string< _CharT>  string_type; 
# 1990
explicit messages_byname(const char * __s, std::size_t __refs = 0); 
# 1994
explicit messages_byname(const std::string &__s, std::size_t __refs = 0) : messages_byname(__s.c_str(), __refs) 
# 1995
{ } 
# 2000
protected: virtual ~messages_byname() 
# 2001
{ } 
# 2002
}; 
# 2004
}
# 2007
}
# 34 "/usr/include/libintl.h" 3
extern "C" {
# 39
extern char *gettext(const char * __msgid) throw()
# 40
 __attribute((__format_arg__(1))); 
# 44
extern char *dgettext(const char * __domainname, const char * __msgid) throw()
# 45
 __attribute((__format_arg__(2))); 
# 46
extern char *__dgettext(const char * __domainname, const char * __msgid) throw()
# 47
 __attribute((__format_arg__(2))); 
# 51
extern char *dcgettext(const char * __domainname, const char * __msgid, int __category) throw()
# 53
 __attribute((__format_arg__(2))); 
# 54
extern char *__dcgettext(const char * __domainname, const char * __msgid, int __category) throw()
# 56
 __attribute((__format_arg__(2))); 
# 61
extern char *ngettext(const char * __msgid1, const char * __msgid2, unsigned long __n) throw()
# 63
 __attribute((__format_arg__(1))) __attribute((__format_arg__(2))); 
# 67
extern char *dngettext(const char * __domainname, const char * __msgid1, const char * __msgid2, unsigned long __n) throw()
# 69
 __attribute((__format_arg__(2))) __attribute((__format_arg__(3))); 
# 73
extern char *dcngettext(const char * __domainname, const char * __msgid1, const char * __msgid2, unsigned long __n, int __category) throw()
# 76
 __attribute((__format_arg__(2))) __attribute((__format_arg__(3))); 
# 82
extern char *textdomain(const char * __domainname) throw(); 
# 86
extern char *bindtextdomain(const char * __domainname, const char * __dirname) throw(); 
# 91
extern char *bind_textdomain_codeset(const char * __domainname, const char * __codeset) throw(); 
# 121 "/usr/include/libintl.h" 3
}
# 38 "/usr/include/x86_64-linux-gnu/c++/9/bits/messages_members.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 43
template< class _CharT> 
# 44
__cxx11::messages< _CharT> ::messages(size_t __refs) : locale::facet(__refs), _M_c_locale_messages(_S_get_c_locale()), _M_name_messages(_S_get_c_name()) 
# 47
{ } 
# 49
template< class _CharT> 
# 50
__cxx11::messages< _CharT> ::messages(__c_locale __cloc, const char *__s, size_t 
# 51
__refs) : locale::facet(__refs), _M_c_locale_messages((0)), _M_name_messages((0)) 
# 53
{ 
# 54
if (__builtin_strcmp(__s, _S_get_c_name()) != 0) 
# 55
{ 
# 56
const size_t __len = __builtin_strlen(__s) + (1); 
# 57
char *__tmp = new char [__len]; 
# 58
__builtin_memcpy(__tmp, __s, __len); 
# 59
(_M_name_messages) = __tmp; 
# 60
} else { 
# 62
(_M_name_messages) = _S_get_c_name(); }  
# 65
(_M_c_locale_messages) = _S_clone_c_locale(__cloc); 
# 66
} 
# 68
template< class _CharT> messages_base::catalog 
# 70
__cxx11::messages< _CharT> ::open(const basic_string< char>  &__s, const locale &__loc, const char *
# 71
__dir) const 
# 72
{ 
# 73
bindtextdomain(__s.c_str(), __dir); 
# 74
return do_open(__s, __loc); 
# 75
} 
# 78
template< class _CharT> 
# 79
__cxx11::messages< _CharT> ::~messages() 
# 80
{ 
# 81
if ((_M_name_messages) != _S_get_c_name()) { 
# 82
delete [] (_M_name_messages); }  
# 83
_S_destroy_c_locale(_M_c_locale_messages); 
# 84
} 
# 86
template< class _CharT> messages_base::catalog 
# 88
__cxx11::messages< _CharT> ::do_open(const basic_string< char>  &__s, const locale &) const 
# 90
{ 
# 93
textdomain(__s.c_str()); 
# 94
return 0; 
# 95
} 
# 97
template< class _CharT> void 
# 99
__cxx11::messages< _CharT> ::do_close(catalog) const 
# 100
{ } 
# 103
template< class _CharT> 
# 104
__cxx11::messages_byname< _CharT> ::messages_byname(const char *__s, std::size_t __refs) : messages< _CharT> (__refs) 
# 106
{ 
# 107
if ((this->_M_name_messages) != locale::facet::_S_get_c_name()) 
# 108
{ 
# 109
delete [] (this->_M_name_messages); 
# 110
if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0) 
# 111
{ 
# 112
const std::size_t __len = __builtin_strlen(__s) + (1); 
# 113
char *__tmp = new char [__len]; 
# 114
__builtin_memcpy(__tmp, __s, __len); 
# 115
(this->_M_name_messages) = __tmp; 
# 116
} else { 
# 118
(this->_M_name_messages) = locale::facet::_S_get_c_name(); }  
# 119
}  
# 121
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 123
{ 
# 124
this->_S_destroy_c_locale((this->_M_c_locale_messages)); 
# 125
this->_S_create_c_locale((this->_M_c_locale_messages), __s); 
# 126
}  
# 127
} 
# 132
template<> messages_base::catalog messages< char> ::do_open(const basic_string< char>  &, const locale &) const; 
# 137
template<> void messages< char> ::do_close(catalog) const; 
# 142
template<> messages_base::catalog messages< wchar_t> ::do_open(const basic_string< char>  &, const locale &) const; 
# 147
template<> void messages< wchar_t> ::do_close(catalog) const; 
# 151
}
# 41 "/usr/include/c++/9/bits/codecvt.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 46
class codecvt_base { 
# 49
public: enum result { 
# 51
ok, 
# 52
partial, 
# 53
error, 
# 54
noconv
# 55
}; 
# 56
}; 
# 67 "/usr/include/c++/9/bits/codecvt.h" 3
template< class _InternT, class _ExternT, class _StateT> 
# 68
class __codecvt_abstract_base : public locale::facet, public codecvt_base { 
# 73
public: typedef codecvt_base::result result; 
# 74
typedef _InternT intern_type; 
# 75
typedef _ExternT extern_type; 
# 76
typedef _StateT state_type; 
# 116 "/usr/include/c++/9/bits/codecvt.h" 3
result out(state_type &__state, const intern_type *__from, const intern_type *
# 117
__from_end, const intern_type *&__from_next, extern_type *
# 118
__to, extern_type *__to_end, extern_type *&
# 119
__to_next) const 
# 120
{ 
# 121
return do_out(__state, __from, __from_end, __from_next, __to, __to_end, __to_next); 
# 123
} 
# 155 "/usr/include/c++/9/bits/codecvt.h" 3
result unshift(state_type &__state, extern_type *__to, extern_type *__to_end, extern_type *&
# 156
__to_next) const 
# 157
{ return do_unshift(__state, __to, __to_end, __to_next); } 
# 196 "/usr/include/c++/9/bits/codecvt.h" 3
result in(state_type &__state, const extern_type *__from, const extern_type *
# 197
__from_end, const extern_type *&__from_next, intern_type *
# 198
__to, intern_type *__to_end, intern_type *&
# 199
__to_next) const 
# 200
{ 
# 201
return do_in(__state, __from, __from_end, __from_next, __to, __to_end, __to_next); 
# 203
} 
# 206
int encoding() const throw() 
# 207
{ return do_encoding(); } 
# 210
bool always_noconv() const throw() 
# 211
{ return do_always_noconv(); } 
# 214
int length(state_type &__state, const extern_type *__from, const extern_type *
# 215
__end, size_t __max) const 
# 216
{ return do_length(__state, __from, __end, __max); } 
# 219
int max_length() const throw() 
# 220
{ return do_max_length(); } 
# 224
protected: explicit __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { } 
# 227
virtual ~__codecvt_abstract_base() { } 
# 237 "/usr/include/c++/9/bits/codecvt.h" 3
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const = 0; 
# 243
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const = 0; 
# 247
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const = 0; 
# 253
virtual int do_encoding() const throw() = 0; 
# 256
virtual bool do_always_noconv() const throw() = 0; 
# 259
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const = 0; 
# 263
virtual int do_max_length() const throw() = 0; 
# 264
}; 
# 273 "/usr/include/c++/9/bits/codecvt.h" 3
template< class _InternT, class _ExternT, class _StateT> 
# 274
class codecvt : public __codecvt_abstract_base< _InternT, _ExternT, _StateT>  { 
# 279
public: typedef std::codecvt_base::result result; 
# 280
typedef _InternT intern_type; 
# 281
typedef _ExternT extern_type; 
# 282
typedef _StateT state_type; 
# 285
protected: std::__c_locale _M_c_locale_codecvt; 
# 288
public: static std::locale::id id; 
# 291
explicit codecvt(std::size_t __refs = 0) : __codecvt_abstract_base< _InternT, _ExternT, _StateT> (__refs), _M_c_locale_codecvt((0)) 
# 294
{ } 
# 297
explicit codecvt(std::__c_locale __cloc, std::size_t __refs = 0); 
# 301
protected: virtual ~codecvt() { } 
# 304
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 310
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 314
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 320
virtual int do_encoding() const throw(); 
# 323
virtual bool do_always_noconv() const throw(); 
# 326
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, std::size_t __max) const; 
# 330
virtual int do_max_length() const throw(); 
# 331
}; 
# 333
template< class _InternT, class _ExternT, class _StateT> locale::id 
# 334
codecvt< _InternT, _ExternT, _StateT> ::id; 
# 338
template<> class codecvt< char, char, __mbstate_t>  : public __codecvt_abstract_base< char, char, __mbstate_t>  { 
# 341
friend class __cxx11::messages< char> ; 
# 345
public: typedef char intern_type; 
# 346
typedef char extern_type; 
# 347
typedef mbstate_t state_type; 
# 350
protected: __c_locale _M_c_locale_codecvt; 
# 353
public: static locale::id id; 
# 356
explicit codecvt(size_t __refs = 0); 
# 359
explicit codecvt(__c_locale __cloc, size_t __refs = 0); 
# 363
protected: virtual ~codecvt(); 
# 366
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 372
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 376
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 382
virtual int do_encoding() const throw(); 
# 385
virtual bool do_always_noconv() const throw(); 
# 388
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 
# 392
virtual int do_max_length() const throw(); 
# 393
}; 
# 401
template<> class codecvt< wchar_t, char, __mbstate_t>  : public __codecvt_abstract_base< wchar_t, char, __mbstate_t>  { 
# 404
friend class __cxx11::messages< wchar_t> ; 
# 408
public: typedef wchar_t intern_type; 
# 409
typedef char extern_type; 
# 410
typedef mbstate_t state_type; 
# 413
protected: __c_locale _M_c_locale_codecvt; 
# 416
public: static locale::id id; 
# 419
explicit codecvt(size_t __refs = 0); 
# 422
explicit codecvt(__c_locale __cloc, size_t __refs = 0); 
# 426
protected: virtual ~codecvt(); 
# 429
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 435
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 440
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 447
virtual int do_encoding() const throw(); 
# 450
virtual bool do_always_noconv() const throw(); 
# 453
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 
# 457
virtual int do_max_length() const throw(); 
# 458
}; 
# 467
template<> class codecvt< char16_t, char, __mbstate_t>  : public __codecvt_abstract_base< char16_t, char, __mbstate_t>  { 
# 472
public: typedef char16_t intern_type; 
# 473
typedef char extern_type; 
# 474
typedef mbstate_t state_type; 
# 477
static locale::id id; 
# 480
explicit codecvt(size_t __refs = 0) : std::__codecvt_abstract_base< char16_t, char, __mbstate_t> (__refs) 
# 481
{ } 
# 485
protected: virtual ~codecvt(); 
# 488
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 494
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 499
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 506
virtual int do_encoding() const throw(); 
# 509
virtual bool do_always_noconv() const throw(); 
# 512
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 
# 516
virtual int do_max_length() const throw(); 
# 517
}; 
# 524
template<> class codecvt< char32_t, char, __mbstate_t>  : public __codecvt_abstract_base< char32_t, char, __mbstate_t>  { 
# 529
public: typedef char32_t intern_type; 
# 530
typedef char extern_type; 
# 531
typedef mbstate_t state_type; 
# 534
static locale::id id; 
# 537
explicit codecvt(size_t __refs = 0) : std::__codecvt_abstract_base< char32_t, char, __mbstate_t> (__refs) 
# 538
{ } 
# 542
protected: virtual ~codecvt(); 
# 545
virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 551
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 556
virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 563
virtual int do_encoding() const throw(); 
# 566
virtual bool do_always_noconv() const throw(); 
# 569
virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 
# 573
virtual int do_max_length() const throw(); 
# 574
}; 
# 695 "/usr/include/c++/9/bits/codecvt.h" 3
template< class _InternT, class _ExternT, class _StateT> 
# 696
class codecvt_byname : public codecvt< _InternT, _ExternT, _StateT>  { 
# 700
public: explicit codecvt_byname(const char *__s, std::size_t __refs = 0) : codecvt< _InternT, _ExternT, _StateT> (__refs) 
# 702
{ 
# 703
if ((__builtin_strcmp(__s, "C") != 0) && (__builtin_strcmp(__s, "POSIX") != 0)) 
# 705
{ 
# 706
this->_S_destroy_c_locale((this->_M_c_locale_codecvt)); 
# 707
this->_S_create_c_locale((this->_M_c_locale_codecvt), __s); 
# 708
}  
# 709
} 
# 713
explicit codecvt_byname(const std::string &__s, std::size_t __refs = 0) : codecvt_byname(__s.c_str(), __refs) 
# 714
{ } 
# 719
protected: virtual ~codecvt_byname() { } 
# 720
}; 
# 724
template<> class codecvt_byname< char16_t, char, __mbstate_t>  : public codecvt< char16_t, char, __mbstate_t>  { 
# 729
public: explicit codecvt_byname(const char *, size_t __refs = 0) : std::codecvt< char16_t, char, __mbstate_t> (__refs) 
# 730
{ } 
# 733
explicit codecvt_byname(const string &__s, size_t __refs = 0) : codecvt_byname(__s.c_str(), __refs) 
# 734
{ } 
# 738
protected: virtual ~codecvt_byname() { } 
# 739
}; 
# 742
template<> class codecvt_byname< char32_t, char, __mbstate_t>  : public codecvt< char32_t, char, __mbstate_t>  { 
# 747
public: explicit codecvt_byname(const char *, size_t __refs = 0) : std::codecvt< char32_t, char, __mbstate_t> (__refs) 
# 748
{ } 
# 751
explicit codecvt_byname(const string &__s, size_t __refs = 0) : codecvt_byname(__s.c_str(), __refs) 
# 752
{ } 
# 756
protected: virtual ~codecvt_byname() { } 
# 757
}; 
# 802 "/usr/include/c++/9/bits/codecvt.h" 3
extern template class codecvt_byname< char, char, __mbstate_t> ;
# 804
extern template const codecvt< char, char, __mbstate_t>  &use_facet< codecvt< char, char, __mbstate_t> > (const locale &);
# 808
extern template bool has_facet< codecvt< char, char, __mbstate_t> > (const locale &) throw();
# 813
extern template class codecvt_byname< wchar_t, char, __mbstate_t> ;
# 815
extern template const codecvt< wchar_t, char, __mbstate_t>  &use_facet< codecvt< wchar_t, char, __mbstate_t> > (const locale &);
# 819
extern template bool has_facet< codecvt< wchar_t, char, __mbstate_t> > (const locale &) throw();
# 838 "/usr/include/c++/9/bits/codecvt.h" 3
}
# 35 "/usr/include/c++/9/bits/locale_facets_nonio.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 39
template< class _CharT, bool _Intl> 
# 40
struct __use_cache< __moneypunct_cache< _CharT, _Intl> >  { 
# 43
const __moneypunct_cache< _CharT, _Intl>  *operator()(const locale &__loc) const 
# 44
{ 
# 45
const size_t __i = (moneypunct< _CharT, _Intl> ::id._M_id)(); 
# 46
const locale::facet **__caches = (__loc._M_impl)->_M_caches; 
# 47
if (!(__caches[__i])) 
# 48
{ 
# 49
__moneypunct_cache< _CharT, _Intl>  *__tmp = (0); 
# 50
try 
# 51
{ 
# 52
__tmp = (new __moneypunct_cache< _CharT, _Intl> ); 
# 53
__tmp->_M_cache(__loc); 
# 54
} 
# 55
catch (...) 
# 56
{ 
# 57
delete __tmp; 
# 58
throw; 
# 59
}  
# 60
(__loc._M_impl)->_M_install_cache(__tmp, __i); 
# 61
}  
# 62
return static_cast< const __moneypunct_cache< _CharT, _Intl>  *>(__caches[__i]); 
# 64
} 
# 65
}; 
# 67
template< class _CharT, bool _Intl> void 
# 69
__moneypunct_cache< _CharT, _Intl> ::_M_cache(const locale &__loc) 
# 70
{ 
# 71
const __cxx11::moneypunct< _CharT, _Intl>  &__mp = use_facet< __cxx11::moneypunct< _CharT, _Intl> > (__loc); 
# 74
(_M_decimal_point) = __mp.decimal_point(); 
# 75
(_M_thousands_sep) = __mp.thousands_sep(); 
# 76
(_M_frac_digits) = __mp.frac_digits(); 
# 78
char *__grouping = (0); 
# 79
_CharT *__curr_symbol = (0); 
# 80
_CharT *__positive_sign = (0); 
# 81
_CharT *__negative_sign = (0); 
# 82
try 
# 83
{ 
# 84
const string &__g = __mp.grouping(); 
# 85
(_M_grouping_size) = __g.size(); 
# 86
__grouping = (new char [_M_grouping_size]); 
# 87
__g.copy(__grouping, _M_grouping_size); 
# 88
(_M_use_grouping) = ((_M_grouping_size) && ((static_cast< signed char>(__grouping[0])) > 0) && ((__grouping[0]) != __gnu_cxx::__numeric_traits_integer< char> ::__max)); 
# 93
const __cxx11::basic_string< _CharT>  &__cs = __mp.curr_symbol(); 
# 94
(_M_curr_symbol_size) = __cs.size(); 
# 95
__curr_symbol = (new _CharT [_M_curr_symbol_size]); 
# 96
__cs.copy(__curr_symbol, _M_curr_symbol_size); 
# 98
const __cxx11::basic_string< _CharT>  &__ps = __mp.positive_sign(); 
# 99
(_M_positive_sign_size) = __ps.size(); 
# 100
__positive_sign = (new _CharT [_M_positive_sign_size]); 
# 101
__ps.copy(__positive_sign, _M_positive_sign_size); 
# 103
const __cxx11::basic_string< _CharT>  &__ns = __mp.negative_sign(); 
# 104
(_M_negative_sign_size) = __ns.size(); 
# 105
__negative_sign = (new _CharT [_M_negative_sign_size]); 
# 106
__ns.copy(__negative_sign, _M_negative_sign_size); 
# 108
(_M_pos_format) = __mp.pos_format(); 
# 109
(_M_neg_format) = __mp.neg_format(); 
# 111
const ctype< _CharT>  &__ct = use_facet< ctype< _CharT> > (__loc); 
# 112
__ct.widen(money_base::_S_atoms, money_base::_S_atoms + money_base::_S_end, _M_atoms); 
# 115
(_M_grouping) = __grouping; 
# 116
(_M_curr_symbol) = __curr_symbol; 
# 117
(_M_positive_sign) = __positive_sign; 
# 118
(_M_negative_sign) = __negative_sign; 
# 119
(_M_allocated) = true; 
# 120
} 
# 121
catch (...) 
# 122
{ 
# 123
delete [] __grouping; 
# 124
delete [] __curr_symbol; 
# 125
delete [] __positive_sign; 
# 126
delete [] __negative_sign; 
# 127
throw; 
# 128
}  
# 129
} 
# 131
inline namespace __cxx11 { 
# 133
template< class _CharT, class _InIter> 
# 134
template< bool _Intl> _InIter 
# 137
money_get< _CharT, _InIter> ::_M_extract(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 138
__err, string &__units) const 
# 139
{ 
# 140
typedef char_traits< _CharT>  __traits_type; 
# 141
typedef typename basic_string< _CharT> ::size_type size_type; 
# 142
typedef money_base::part part; 
# 143
typedef __moneypunct_cache< _CharT, _Intl>  __cache_type; 
# 145
const locale &__loc = __io._M_getloc(); 
# 146
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 148
__use_cache< __moneypunct_cache< _CharT, _Intl> >  __uc; 
# 149
const __cache_type *__lc = __uc(__loc); 
# 150
const char_type *__lit = ((__lc->_M_atoms)); 
# 153
bool __negative = false; 
# 155
size_type __sign_size = (0); 
# 157
const bool __mandatory_sign = (__lc->_M_positive_sign_size) && (__lc->_M_negative_sign_size); 
# 160
string __grouping_tmp; 
# 161
if (__lc->_M_use_grouping) { 
# 162
__grouping_tmp.reserve(32); }  
# 164
int __last_pos = 0; 
# 166
int __n = 0; 
# 168
bool __testvalid = true; 
# 170
bool __testdecfound = false; 
# 173
string __res; 
# 174
__res.reserve(32); 
# 176
const char_type *__lit_zero = __lit + money_base::_S_zero; 
# 177
const money_base::pattern __p = ((__lc->_M_neg_format)); 
# 178
for (int __i = 0; (__i < 4) && __testvalid; ++__i) 
# 179
{ 
# 180
const part __which = static_cast< part>((__p.field)[__i]); 
# 181
switch (__which) 
# 182
{ 
# 183
case money_base::symbol:  
# 188
if ((((((__io.flags()) & ios_base::showbase) || (__sign_size > 1)) || (__i == 0)) || ((__i == 1) && ((__mandatory_sign || ((static_cast< part>((__p.field)[0])) == (money_base::sign))) || ((static_cast< part>((__p.field)[2])) == (money_base::space))))) || ((__i == 2) && (((static_cast< part>((__p.field)[3])) == (money_base::value)) || (__mandatory_sign && ((static_cast< part>((__p.field)[3])) == (money_base::sign)))))) 
# 200
{ 
# 201
const size_type __len = ((__lc->_M_curr_symbol_size)); 
# 202
size_type __j = (0); 
# 203
for (; (__beg != __end) && (__j < __len) && ((*__beg) == ((__lc->_M_curr_symbol)[__j])); (++__beg), ((void)(++__j))) { 
# 205
; }  
# 206
if ((__j != __len) && (__j || ((__io.flags()) & ios_base::showbase))) { 
# 208
__testvalid = false; }  
# 209
}  
# 210
break; 
# 211
case money_base::sign:  
# 213
if ((__lc->_M_positive_sign_size) && (__beg != __end) && ((*__beg) == ((__lc->_M_positive_sign)[0]))) 
# 215
{ 
# 216
__sign_size = (__lc->_M_positive_sign_size); 
# 217
++__beg; 
# 218
} else { 
# 219
if ((__lc->_M_negative_sign_size) && (__beg != __end) && ((*__beg) == ((__lc->_M_negative_sign)[0]))) 
# 221
{ 
# 222
__negative = true; 
# 223
__sign_size = (__lc->_M_negative_sign_size); 
# 224
++__beg; 
# 225
} else { 
# 226
if ((__lc->_M_positive_sign_size) && (!(__lc->_M_negative_sign_size))) { 
# 230
__negative = true; } else { 
# 231
if (__mandatory_sign) { 
# 232
__testvalid = false; }  }  }  }  
# 233
break; 
# 234
case money_base::value:  
# 237
for (; __beg != __end; ++__beg) 
# 238
{ 
# 239
const char_type __c = (*__beg); 
# 240
const char_type *__q = __traits_type::find(__lit_zero, 10, __c); 
# 242
if (__q != 0) 
# 243
{ 
# 244
__res += (money_base::_S_atoms[__q - __lit]); 
# 245
++__n; 
# 246
} else { 
# 247
if ((__c == (__lc->_M_decimal_point)) && (!__testdecfound)) 
# 249
{ 
# 250
if ((__lc->_M_frac_digits) <= 0) { 
# 251
break; }  
# 253
__last_pos = __n; 
# 254
__n = 0; 
# 255
__testdecfound = true; 
# 256
} else { 
# 257
if ((__lc->_M_use_grouping) && (__c == (__lc->_M_thousands_sep)) && (!__testdecfound)) 
# 260
{ 
# 261
if (__n) 
# 262
{ 
# 264
(__grouping_tmp += (static_cast< char>(__n))); 
# 265
__n = 0; 
# 266
} else 
# 268
{ 
# 269
__testvalid = false; 
# 270
break; 
# 271
}  
# 272
} else { 
# 274
break; }  }  }  
# 275
}  
# 276
if (__res.empty()) { 
# 277
__testvalid = false; }  
# 278
break; 
# 279
case money_base::space:  
# 281
if ((__beg != __end) && __ctype.is(ctype_base::space, *__beg)) { 
# 282
++__beg; } else { 
# 284
__testvalid = false; }  
# 286
case money_base::none:  
# 288
if (__i != 3) { 
# 289
for (; (__beg != __end) && __ctype.is(ctype_base::space, *__beg); ++__beg) { 
# 290
; }  }  
# 291
break; 
# 292
}  
# 293
}  
# 296
if ((__sign_size > 1) && __testvalid) 
# 297
{ 
# 298
const char_type *__sign = __negative ? __lc->_M_negative_sign : (__lc->_M_positive_sign); 
# 300
size_type __i = (1); 
# 301
for (; (__beg != __end) && (__i < __sign_size) && ((*__beg) == (__sign[__i])); (++__beg), ((void)(++__i))) { 
# 302
; }  
# 304
if (__i != __sign_size) { 
# 305
__testvalid = false; }  
# 306
}  
# 308
if (__testvalid) 
# 309
{ 
# 311
if (__res.size() > (1)) 
# 312
{ 
# 313
const size_type __first = __res.find_first_not_of('0'); 
# 314
const bool __only_zeros = __first == string::npos; 
# 315
if (__first) { 
# 316
__res.erase(0, __only_zeros ? __res.size() - (1) : __first); }  
# 317
}  
# 320
if (__negative && ((__res[0]) != ('0'))) { 
# 321
__res.insert(__res.begin(), '-'); }  
# 324
if (__grouping_tmp.size()) 
# 325
{ 
# 327
(__grouping_tmp += (static_cast< char>(__testdecfound ? __last_pos : __n))); 
# 329
if (!std::__verify_grouping((__lc->_M_grouping), (__lc->_M_grouping_size), __grouping_tmp)) { 
# 332
(__err |= ios_base::failbit); }  
# 333
}  
# 336
if (__testdecfound && (__n != (__lc->_M_frac_digits))) { 
# 337
__testvalid = false; }  
# 338
}  
# 341
if (!__testvalid) { 
# 342
(__err |= ios_base::failbit); } else { 
# 344
__units.swap(__res); }  
# 347
if (__beg == __end) { 
# 348
(__err |= ios_base::eofbit); }  
# 349
return __beg; 
# 350
} 
# 368 "/usr/include/c++/9/bits/locale_facets_nonio.tcc" 3
template< class _CharT, class _InIter> _InIter 
# 371
money_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, bool __intl, ios_base &__io, ios_base::iostate &
# 372
__err, long double &__units) const 
# 373
{ 
# 374
string __str; 
# 375
__beg = (__intl ? _M_extract< true> (__beg, __end, __io, __err, __str) : _M_extract< false> (__beg, __end, __io, __err, __str)); 
# 377
std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale()); 
# 378
return __beg; 
# 379
} 
# 381
template< class _CharT, class _InIter> _InIter 
# 384
money_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, bool __intl, ios_base &__io, ios_base::iostate &
# 385
__err, string_type &__digits) const 
# 386
{ 
# 387
typedef basic_string< char> ::size_type size_type; 
# 389
const locale &__loc = __io._M_getloc(); 
# 390
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 392
string __str; 
# 393
__beg = (__intl ? _M_extract< true> (__beg, __end, __io, __err, __str) : _M_extract< false> (__beg, __end, __io, __err, __str)); 
# 395
const size_type __len = __str.size(); 
# 396
if (__len) 
# 397
{ 
# 398
__digits.resize(__len); 
# 399
__ctype.widen(__str.data(), __str.data() + __len, &(__digits[0])); 
# 400
}  
# 401
return __beg; 
# 402
} 
# 404
template< class _CharT, class _OutIter> 
# 405
template< bool _Intl> _OutIter 
# 408
money_put< _CharT, _OutIter> ::_M_insert(iter_type __s, ios_base &__io, char_type __fill, const string_type &
# 409
__digits) const 
# 410
{ 
# 411
typedef typename basic_string< _CharT> ::size_type size_type; 
# 412
typedef money_base::part part; 
# 413
typedef __moneypunct_cache< _CharT, _Intl>  __cache_type; 
# 415
const locale &__loc = __io._M_getloc(); 
# 416
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 418
__use_cache< __moneypunct_cache< _CharT, _Intl> >  __uc; 
# 419
const __cache_type *__lc = __uc(__loc); 
# 420
const char_type *__lit = ((__lc->_M_atoms)); 
# 424
const char_type *__beg = __digits.data(); 
# 426
money_base::pattern __p; 
# 427
const char_type *__sign; 
# 428
size_type __sign_size; 
# 429
if (!((*__beg) == (__lit[money_base::_S_minus]))) 
# 430
{ 
# 431
__p = (__lc->_M_pos_format); 
# 432
__sign = (__lc->_M_positive_sign); 
# 433
__sign_size = (__lc->_M_positive_sign_size); 
# 434
} else 
# 436
{ 
# 437
__p = (__lc->_M_neg_format); 
# 438
__sign = (__lc->_M_negative_sign); 
# 439
__sign_size = (__lc->_M_negative_sign_size); 
# 440
if (__digits.size()) { 
# 441
++__beg; }  
# 442
}  
# 445
size_type __len = __ctype.scan_not(ctype_base::digit, __beg, __beg + __digits.size()) - __beg; 
# 447
if (__len) 
# 448
{ 
# 452
string_type __value; 
# 453
__value.reserve(2 * __len); 
# 457
long __paddec = __len - (__lc->_M_frac_digits); 
# 458
if (__paddec > (0)) 
# 459
{ 
# 460
if ((__lc->_M_frac_digits) < 0) { 
# 461
__paddec = __len; }  
# 462
if (__lc->_M_grouping_size) 
# 463
{ 
# 464
__value.assign((2) * __paddec, char_type()); 
# 465
_CharT *__vend = std::__add_grouping(&(__value[0]), (__lc->_M_thousands_sep), (__lc->_M_grouping), (__lc->_M_grouping_size), __beg, __beg + __paddec); 
# 470
__value.erase(__vend - (&(__value[0]))); 
# 471
} else { 
# 473
__value.assign(__beg, __paddec); }  
# 474
}  
# 477
if ((__lc->_M_frac_digits) > 0) 
# 478
{ 
# 479
__value += (__lc->_M_decimal_point); 
# 480
if (__paddec >= (0)) { 
# 481
__value.append(__beg + __paddec, (__lc->_M_frac_digits)); } else 
# 483
{ 
# 485
__value.append(-__paddec, __lit[money_base::_S_zero]); 
# 486
__value.append(__beg, __len); 
# 487
}  
# 488
}  
# 491
const ios_base::fmtflags __f = ((__io.flags()) & ios_base::adjustfield); 
# 493
__len = (__value.size() + __sign_size); 
# 494
__len += ((((__io.flags()) & ios_base::showbase)) ? __lc->_M_curr_symbol_size : 0); 
# 497
string_type __res; 
# 498
__res.reserve(2 * __len); 
# 500
const size_type __width = static_cast< size_type>(__io.width()); 
# 501
const bool __testipad = (__f == ios_base::internal) && (__len < __width); 
# 504
for (int __i = 0; __i < 4; ++__i) 
# 505
{ 
# 506
const part __which = static_cast< part>((__p.field)[__i]); 
# 507
switch (__which) 
# 508
{ 
# 509
case money_base::symbol:  
# 510
if (((__io.flags()) & ios_base::showbase)) { 
# 511
__res.append((__lc->_M_curr_symbol), (__lc->_M_curr_symbol_size)); }  
# 513
break; 
# 514
case money_base::sign:  
# 518
if (__sign_size) { 
# 519
__res += (__sign[0]); }  
# 520
break; 
# 521
case money_base::value:  
# 522
__res += __value; 
# 523
break; 
# 524
case money_base::space:  
# 528
if (__testipad) { 
# 529
__res.append(__width - __len, __fill); } else { 
# 531
__res += __fill; }  
# 532
break; 
# 533
case money_base::none:  
# 534
if (__testipad) { 
# 535
__res.append(__width - __len, __fill); }  
# 536
break; 
# 537
}  
# 538
}  
# 541
if (__sign_size > 1) { 
# 542
__res.append(__sign + 1, __sign_size - 1); }  
# 545
__len = __res.size(); 
# 546
if (__width > __len) 
# 547
{ 
# 548
if (__f == ios_base::left) { 
# 550
__res.append(__width - __len, __fill); } else { 
# 553
__res.insert(0, __width - __len, __fill); }  
# 554
__len = __width; 
# 555
}  
# 558
__s = std::__write(__s, __res.data(), __len); 
# 559
}  
# 560
__io.width(0); 
# 561
return __s; 
# 562
} 
# 574 "/usr/include/c++/9/bits/locale_facets_nonio.tcc" 3
template< class _CharT, class _OutIter> _OutIter 
# 577
money_put< _CharT, _OutIter> ::do_put(iter_type __s, bool __intl, ios_base &__io, char_type __fill, long double 
# 578
__units) const 
# 579
{ 
# 580
const locale __loc = __io.getloc(); 
# 581
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 584
int __cs_size = 64; 
# 585
char *__cs = static_cast< char *>(__builtin_alloca(__cs_size)); 
# 588
int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, "%.*Lf", 0, __units); 
# 591
if (__len >= __cs_size) 
# 592
{ 
# 593
__cs_size = (__len + 1); 
# 594
__cs = (static_cast< char *>(__builtin_alloca(__cs_size))); 
# 595
__len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, "%.*Lf", 0, __units); 
# 597
}  
# 606 "/usr/include/c++/9/bits/locale_facets_nonio.tcc" 3
string_type __digits(__len, char_type()); 
# 607
__ctype.widen(__cs, __cs + __len, &(__digits[0])); 
# 608
return __intl ? _M_insert< true> (__s, __io, __fill, __digits) : _M_insert< false> (__s, __io, __fill, __digits); 
# 610
} 
# 612
template< class _CharT, class _OutIter> _OutIter 
# 615
money_put< _CharT, _OutIter> ::do_put(iter_type __s, bool __intl, ios_base &__io, char_type __fill, const string_type &
# 616
__digits) const 
# 617
{ return __intl ? _M_insert< true> (__s, __io, __fill, __digits) : _M_insert< false> (__s, __io, __fill, __digits); 
# 618
} 
# 620
}
# 625
template< class _CharT, class _InIter> time_base::dateorder 
# 627
__cxx11::time_get< _CharT, _InIter> ::do_date_order() const 
# 628
{ return time_base::no_order; } 
# 632
template< class _CharT, class _InIter> _InIter 
# 635
__cxx11::time_get< _CharT, _InIter> ::_M_extract_via_format(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 636
__err, tm *__tm, const _CharT *
# 637
__format) const 
# 638
{ 
# 639
const locale &__loc = __io._M_getloc(); 
# 640
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 641
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 642
const size_t __len = char_traits< _CharT> ::length(__format); 
# 644
ios_base::iostate __tmperr = ios_base::goodbit; 
# 645
size_t __i = (0); 
# 646
for (; (__beg != __end) && (__i < __len) && (!__tmperr); ++__i) 
# 647
{ 
# 648
if (__ctype.narrow(__format[__i], 0) == '%') 
# 649
{ 
# 651
char __c = __ctype.narrow(__format[++__i], 0); 
# 652
int __mem = 0; 
# 653
if ((__c == ('E')) || (__c == ('O'))) { 
# 654
__c = __ctype.narrow(__format[++__i], 0); }  
# 655
switch (__c) 
# 656
{ 
# 657
const char *__cs; 
# 658
_CharT __wcs[10]; 
# 659
case 'a':  
# 661
const char_type *__days1[7]; 
# 662
__tp._M_days_abbreviated(__days1); 
# 663
__beg = _M_extract_name(__beg, __end, __mem, __days1, 7, __io, __tmperr); 
# 665
if (!__tmperr) { 
# 666
(__tm->tm_wday) = __mem; }  
# 667
break; 
# 668
case 'A':  
# 670
const char_type *__days2[7]; 
# 671
__tp._M_days(__days2); 
# 672
__beg = _M_extract_name(__beg, __end, __mem, __days2, 7, __io, __tmperr); 
# 674
if (!__tmperr) { 
# 675
(__tm->tm_wday) = __mem; }  
# 676
break; 
# 677
case 'h':  
# 678
case 'b':  
# 680
const char_type *__months1[12]; 
# 681
__tp._M_months_abbreviated(__months1); 
# 682
__beg = _M_extract_name(__beg, __end, __mem, __months1, 12, __io, __tmperr); 
# 684
if (!__tmperr) { 
# 685
(__tm->tm_mon) = __mem; }  
# 686
break; 
# 687
case 'B':  
# 689
const char_type *__months2[12]; 
# 690
__tp._M_months(__months2); 
# 691
__beg = _M_extract_name(__beg, __end, __mem, __months2, 12, __io, __tmperr); 
# 693
if (!__tmperr) { 
# 694
(__tm->tm_mon) = __mem; }  
# 695
break; 
# 696
case 'c':  
# 698
const char_type *__dt[2]; 
# 699
__tp._M_date_time_formats(__dt); 
# 700
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __dt[0]); 
# 702
break; 
# 703
case 'd':  
# 705
__beg = _M_extract_num(__beg, __end, __mem, 1, 31, 2, __io, __tmperr); 
# 707
if (!__tmperr) { 
# 708
(__tm->tm_mday) = __mem; }  
# 709
break; 
# 710
case 'e':  
# 713
if (__ctype.is(ctype_base::space, *__beg)) { 
# 714
__beg = _M_extract_num(++__beg, __end, __mem, 1, 9, 1, __io, __tmperr); } else { 
# 717
__beg = _M_extract_num(__beg, __end, __mem, 10, 31, 2, __io, __tmperr); }  
# 719
if (!__tmperr) { 
# 720
(__tm->tm_mday) = __mem; }  
# 721
break; 
# 722
case 'D':  
# 724
__cs = ("%m/%d/%y"); 
# 725
__ctype.widen(__cs, __cs + 9, __wcs); 
# 726
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs); 
# 728
break; 
# 729
case 'H':  
# 731
__beg = _M_extract_num(__beg, __end, __mem, 0, 23, 2, __io, __tmperr); 
# 733
if (!__tmperr) { 
# 734
(__tm->tm_hour) = __mem; }  
# 735
break; 
# 736
case 'I':  
# 738
__beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2, __io, __tmperr); 
# 740
if (!__tmperr) { 
# 741
(__tm->tm_hour) = __mem; }  
# 742
break; 
# 743
case 'm':  
# 745
__beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2, __io, __tmperr); 
# 747
if (!__tmperr) { 
# 748
(__tm->tm_mon) = (__mem - 1); }  
# 749
break; 
# 750
case 'M':  
# 752
__beg = _M_extract_num(__beg, __end, __mem, 0, 59, 2, __io, __tmperr); 
# 754
if (!__tmperr) { 
# 755
(__tm->tm_min) = __mem; }  
# 756
break; 
# 757
case 'n':  
# 758
if (__ctype.narrow(*__beg, 0) == '\n') { 
# 759
++__beg; } else { 
# 761
(__tmperr |= ios_base::failbit); }  
# 762
break; 
# 763
case 'R':  
# 765
__cs = ("%H:%M"); 
# 766
__ctype.widen(__cs, __cs + 6, __wcs); 
# 767
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs); 
# 769
break; 
# 770
case 'S':  
# 774
__beg = _M_extract_num(__beg, __end, __mem, 0, 60, 2, __io, __tmperr); 
# 779
if (!__tmperr) { 
# 780
(__tm->tm_sec) = __mem; }  
# 781
break; 
# 782
case 't':  
# 783
if (__ctype.narrow(*__beg, 0) == '\t') { 
# 784
++__beg; } else { 
# 786
(__tmperr |= ios_base::failbit); }  
# 787
break; 
# 788
case 'T':  
# 790
__cs = ("%H:%M:%S"); 
# 791
__ctype.widen(__cs, __cs + 9, __wcs); 
# 792
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __wcs); 
# 794
break; 
# 795
case 'x':  
# 797
const char_type *__dates[2]; 
# 798
__tp._M_date_formats(__dates); 
# 799
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __dates[0]); 
# 801
break; 
# 802
case 'X':  
# 804
const char_type *__times[2]; 
# 805
__tp._M_time_formats(__times); 
# 806
__beg = _M_extract_via_format(__beg, __end, __io, __tmperr, __tm, __times[0]); 
# 808
break; 
# 809
case 'y':  
# 810
case 'C':  
# 812
case 'Y':  
# 817
__beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4, __io, __tmperr); 
# 819
if (!__tmperr) { 
# 820
(__tm->tm_year) = ((__mem < 0) ? __mem + 100 : (__mem - 1900)); }  
# 821
break; 
# 822
case 'Z':  
# 824
if (__ctype.is(ctype_base::upper, *__beg)) 
# 825
{ 
# 826
int __tmp; 
# 827
__beg = _M_extract_name(__beg, __end, __tmp, __timepunct_cache< _CharT> ::_S_timezones, 14, __io, __tmperr); 
# 832
if ((__beg != __end) && (!__tmperr) && (__tmp == 0) && (((*__beg) == __ctype.widen('-')) || ((*__beg) == __ctype.widen('+')))) 
# 835
{ 
# 836
__beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2, __io, __tmperr); 
# 838
__beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2, __io, __tmperr); 
# 840
}  
# 841
} else { 
# 843
(__tmperr |= ios_base::failbit); }  
# 844
break; 
# 845
default:  
# 847
(__tmperr |= ios_base::failbit); 
# 848
}  
# 849
} else 
# 851
{ 
# 853
if ((__format[__i]) == (*__beg)) { 
# 854
++__beg; } else { 
# 856
(__tmperr |= ios_base::failbit); }  
# 857
}  
# 858
}  
# 860
if (__tmperr || (__i != __len)) { 
# 861
(__err |= ios_base::failbit); }  
# 863
return __beg; 
# 864
} 
# 866
template< class _CharT, class _InIter> _InIter 
# 869
__cxx11::time_get< _CharT, _InIter> ::_M_extract_num(iter_type __beg, iter_type __end, int &__member, int 
# 870
__min, int __max, size_t __len, ios_base &
# 871
__io, ios_base::iostate &__err) const 
# 872
{ 
# 873
const locale &__loc = __io._M_getloc(); 
# 874
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 877
int __mult = (__len == (2)) ? 10 : ((__len == (4)) ? 1000 : 1); 
# 879
++__min; 
# 880
size_t __i = (0); 
# 881
int __value = 0; 
# 882
for (; (__beg != __end) && (__i < __len); (++__beg), ((void)(++__i))) 
# 883
{ 
# 884
const char __c = __ctype.narrow(*__beg, '*'); 
# 885
if ((__c >= ('0')) && (__c <= ('9'))) 
# 886
{ 
# 887
__value = ((__value * 10) + (__c - ('0'))); 
# 888
const int __valuec = __value * __mult; 
# 889
if ((__valuec > __max) || ((__valuec + __mult) < __min)) { 
# 890
break; }  
# 891
__mult /= 10; 
# 892
} else { 
# 894
break; }  
# 895
}  
# 896
if (__i == __len) { 
# 897
__member = __value; } else { 
# 899
if ((__len == (4)) && (__i == (2))) { 
# 900
__member = (__value - 100); } else { 
# 902
(__err |= ios_base::failbit); }  }  
# 904
return __beg; 
# 905
} 
# 909
template< class _CharT, class _InIter> _InIter 
# 912
__cxx11::time_get< _CharT, _InIter> ::_M_extract_name(iter_type __beg, iter_type __end, int &__member, const _CharT **
# 913
__names, size_t __indexlen, ios_base &
# 914
__io, ios_base::iostate &__err) const 
# 915
{ 
# 916
typedef char_traits< _CharT>  __traits_type; 
# 917
const locale &__loc = __io._M_getloc(); 
# 918
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 920
int *__matches = static_cast< int *>(__builtin_alloca(sizeof(int) * __indexlen)); 
# 922
size_t __nmatches = (0); 
# 923
size_t __pos = (0); 
# 924
bool __testvalid = true; 
# 925
const char_type *__name; 
# 931
if (__beg != __end) 
# 932
{ 
# 933
const char_type __c = (*__beg); 
# 934
for (size_t __i1 = (0); __i1 < __indexlen; ++__i1) { 
# 935
if ((__c == ((__names[__i1])[0])) || (__c == __ctype.toupper((__names[__i1])[0]))) { 
# 937
(__matches[__nmatches++]) = __i1; }  }  
# 938
}  
# 940
while (__nmatches > (1)) 
# 941
{ 
# 943
size_t __minlen = __traits_type::length(__names[__matches[0]]); 
# 944
for (size_t __i2 = (1); __i2 < __nmatches; ++__i2) { 
# 945
__minlen = std::min(__minlen, __traits_type::length(__names[__matches[__i2]])); }  
# 947
++__beg; 
# 948
++__pos; 
# 949
if ((__pos < __minlen) && (__beg != __end)) { 
# 950
for (size_t __i3 = (0); __i3 < __nmatches;) 
# 951
{ 
# 952
__name = (__names[__matches[__i3]]); 
# 953
if (!((__name[__pos]) == (*__beg))) { 
# 954
(__matches[__i3]) = (__matches[--__nmatches]); } else { 
# 956
++__i3; }  
# 957
}  } else { 
# 959
break; }  
# 960
}  
# 962
if (__nmatches == (1)) 
# 963
{ 
# 965
++__beg; 
# 966
++__pos; 
# 967
__name = (__names[__matches[0]]); 
# 968
const size_t __len = __traits_type::length(__name); 
# 969
while ((__pos < __len) && (__beg != __end) && ((__name[__pos]) == (*__beg))) { 
# 970
(++__beg), ((void)(++__pos)); }  
# 972
if (__len == __pos) { 
# 973
__member = (__matches[0]); } else { 
# 975
__testvalid = false; }  
# 976
} else { 
# 978
__testvalid = false; }  
# 979
if (!__testvalid) { 
# 980
(__err |= ios_base::failbit); }  
# 982
return __beg; 
# 983
} 
# 985
template< class _CharT, class _InIter> _InIter 
# 988
__cxx11::time_get< _CharT, _InIter> ::_M_extract_wday_or_month(iter_type __beg, iter_type __end, int &__member, const _CharT **
# 989
__names, size_t __indexlen, ios_base &
# 990
__io, ios_base::iostate &__err) const 
# 991
{ 
# 992
typedef char_traits< _CharT>  __traits_type; 
# 993
const locale &__loc = __io._M_getloc(); 
# 994
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 996
int *__matches = static_cast< int *>(__builtin_alloca(((2) * sizeof(int)) * __indexlen)); 
# 998
size_t __nmatches = (0); 
# 999
size_t *__matches_lengths = (0); 
# 1000
size_t __pos = (0); 
# 1002
if (__beg != __end) 
# 1003
{ 
# 1004
const char_type __c = (*__beg); 
# 1005
for (size_t __i = (0); __i < ((2) * __indexlen); ++__i) { 
# 1006
if ((__c == ((__names[__i])[0])) || (__c == __ctype.toupper((__names[__i])[0]))) { 
# 1008
(__matches[__nmatches++]) = __i; }  }  
# 1009
}  
# 1011
if (__nmatches) 
# 1012
{ 
# 1013
++__beg; 
# 1014
++__pos; 
# 1016
__matches_lengths = (static_cast< size_t *>(__builtin_alloca(sizeof(size_t) * __nmatches))); 
# 1019
for (size_t __i = (0); __i < __nmatches; ++__i) { 
# 1020
(__matches_lengths[__i]) = __traits_type::length(__names[__matches[__i]]); }  
# 1022
}  
# 1024
for (; __beg != __end; (++__beg), ((void)(++__pos))) 
# 1025
{ 
# 1026
size_t __nskipped = (0); 
# 1027
const char_type __c = (*__beg); 
# 1028
for (size_t __i = (0); __i < __nmatches;) 
# 1029
{ 
# 1030
const char_type *__name = __names[__matches[__i]]; 
# 1031
if (__pos >= (__matches_lengths[__i])) { 
# 1032
(++__nskipped), (++__i); } else { 
# 1033
if (!((__name[__pos]) == __c)) 
# 1034
{ 
# 1035
--__nmatches; 
# 1036
(__matches[__i]) = (__matches[__nmatches]); 
# 1037
(__matches_lengths[__i]) = (__matches_lengths[__nmatches]); 
# 1038
} else { 
# 1040
++__i; }  }  
# 1041
}  
# 1042
if (__nskipped == __nmatches) { 
# 1043
break; }  
# 1044
}  
# 1046
if (((__nmatches == (1)) && ((__matches_lengths[0]) == __pos)) || ((__nmatches == (2)) && (((__matches_lengths[0]) == __pos) || ((__matches_lengths[1]) == __pos)))) { 
# 1049
__member = (((__matches[0]) >= __indexlen) ? (__matches[0]) - __indexlen : (__matches[0])); } else { 
# 1052
(__err |= ios_base::failbit); }  
# 1054
return __beg; 
# 1055
} 
# 1057
template< class _CharT, class _InIter> _InIter 
# 1060
__cxx11::time_get< _CharT, _InIter> ::do_get_time(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1061
__err, tm *__tm) const 
# 1062
{ 
# 1063
const locale &__loc = __io._M_getloc(); 
# 1064
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1065
const char_type *__times[2]; 
# 1066
__tp._M_time_formats(__times); 
# 1067
__beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __times[0]); 
# 1069
if (__beg == __end) { 
# 1070
(__err |= ios_base::eofbit); }  
# 1071
return __beg; 
# 1072
} 
# 1074
template< class _CharT, class _InIter> _InIter 
# 1077
__cxx11::time_get< _CharT, _InIter> ::do_get_date(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1078
__err, tm *__tm) const 
# 1079
{ 
# 1080
const locale &__loc = __io._M_getloc(); 
# 1081
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1082
const char_type *__dates[2]; 
# 1083
__tp._M_date_formats(__dates); 
# 1084
__beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __dates[0]); 
# 1086
if (__beg == __end) { 
# 1087
(__err |= ios_base::eofbit); }  
# 1088
return __beg; 
# 1089
} 
# 1091
template< class _CharT, class _InIter> _InIter 
# 1094
__cxx11::time_get< _CharT, _InIter> ::do_get_weekday(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1095
__err, tm *__tm) const 
# 1096
{ 
# 1097
const locale &__loc = __io._M_getloc(); 
# 1098
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1099
const char_type *__days[14]; 
# 1100
__tp._M_days_abbreviated(__days); 
# 1101
__tp._M_days(__days + 7); 
# 1102
int __tmpwday; 
# 1103
ios_base::iostate __tmperr = ios_base::goodbit; 
# 1105
__beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7, __io, __tmperr); 
# 1107
if (!__tmperr) { 
# 1108
(__tm->tm_wday) = __tmpwday; } else { 
# 1110
(__err |= ios_base::failbit); }  
# 1112
if (__beg == __end) { 
# 1113
(__err |= ios_base::eofbit); }  
# 1114
return __beg; 
# 1115
} 
# 1117
template< class _CharT, class _InIter> _InIter 
# 1120
__cxx11::time_get< _CharT, _InIter> ::do_get_monthname(iter_type __beg, iter_type __end, ios_base &
# 1121
__io, ios_base::iostate &__err, tm *__tm) const 
# 1122
{ 
# 1123
const locale &__loc = __io._M_getloc(); 
# 1124
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1125
const char_type *__months[24]; 
# 1126
__tp._M_months_abbreviated(__months); 
# 1127
__tp._M_months(__months + 12); 
# 1128
int __tmpmon; 
# 1129
ios_base::iostate __tmperr = ios_base::goodbit; 
# 1131
__beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12, __io, __tmperr); 
# 1133
if (!__tmperr) { 
# 1134
(__tm->tm_mon) = __tmpmon; } else { 
# 1136
(__err |= ios_base::failbit); }  
# 1138
if (__beg == __end) { 
# 1139
(__err |= ios_base::eofbit); }  
# 1140
return __beg; 
# 1141
} 
# 1143
template< class _CharT, class _InIter> _InIter 
# 1146
__cxx11::time_get< _CharT, _InIter> ::do_get_year(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1147
__err, tm *__tm) const 
# 1148
{ 
# 1149
int __tmpyear; 
# 1150
ios_base::iostate __tmperr = ios_base::goodbit; 
# 1152
__beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4, __io, __tmperr); 
# 1154
if (!__tmperr) { 
# 1155
(__tm->tm_year) = ((__tmpyear < 0) ? __tmpyear + 100 : (__tmpyear - 1900)); } else { 
# 1157
(__err |= ios_base::failbit); }  
# 1159
if (__beg == __end) { 
# 1160
(__err |= ios_base::eofbit); }  
# 1161
return __beg; 
# 1162
} 
# 1165
template< class _CharT, class _InIter> inline _InIter 
# 1169
__cxx11::time_get< _CharT, _InIter> ::get(iter_type __s, iter_type __end, ios_base &__io, ios_base::iostate &
# 1170
__err, tm *__tm, const char_type *__fmt, const char_type *
# 1171
__fmtend) const 
# 1172
{ 
# 1173
const locale &__loc = __io._M_getloc(); 
# 1174
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1175
__err = ios_base::goodbit; 
# 1176
while ((__fmt != __fmtend) && (__err == ios_base::goodbit)) 
# 1178
{ 
# 1179
if (__s == __end) 
# 1180
{ 
# 1181
__err = (ios_base::eofbit | ios_base::failbit); 
# 1182
break; 
# 1183
} else { 
# 1184
if (__ctype.narrow(*__fmt, 0) == '%') 
# 1185
{ 
# 1186
char __format; 
# 1187
char __mod = (0); 
# 1188
if ((++__fmt) == __fmtend) 
# 1189
{ 
# 1190
__err = ios_base::failbit; 
# 1191
break; 
# 1192
}  
# 1193
const char __c = __ctype.narrow(*__fmt, 0); 
# 1194
if ((__c != ('E')) && (__c != ('O'))) { 
# 1195
__format = __c; } else { 
# 1196
if ((++__fmt) != __fmtend) 
# 1197
{ 
# 1198
__mod = __c; 
# 1199
__format = __ctype.narrow(*__fmt, 0); 
# 1200
} else 
# 1202
{ 
# 1203
__err = ios_base::failbit; 
# 1204
break; 
# 1205
}  }  
# 1206
__s = do_get(__s, __end, __io, __err, __tm, __format, __mod); 
# 1208
++__fmt; 
# 1209
} else { 
# 1210
if (__ctype.is(ctype_base::space, *__fmt)) 
# 1211
{ 
# 1212
++__fmt; 
# 1213
while ((__fmt != __fmtend) && __ctype.is(ctype_base::space, *__fmt)) { 
# 1215
++__fmt; }  
# 1217
while ((__s != __end) && __ctype.is(ctype_base::space, *__s)) { 
# 1219
++__s; }  
# 1220
} else { 
# 1222
if ((__ctype.tolower(*__s) == __ctype.tolower(*__fmt)) || (__ctype.toupper(*__s) == __ctype.toupper(*__fmt))) 
# 1224
{ 
# 1225
++__s; 
# 1226
++__fmt; 
# 1227
} else 
# 1229
{ 
# 1230
__err = ios_base::failbit; 
# 1231
break; 
# 1232
}  }  }  }  
# 1233
}  
# 1234
return __s; 
# 1235
} 
# 1237
template< class _CharT, class _InIter> inline _InIter 
# 1241
__cxx11::time_get< _CharT, _InIter> ::do_get(iter_type __beg, iter_type __end, ios_base &__io, ios_base::iostate &
# 1242
__err, tm *__tm, char 
# 1243
__format, char __mod) const 
# 1244
{ 
# 1245
const locale &__loc = __io._M_getloc(); 
# 1246
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1247
__err = ios_base::goodbit; 
# 1249
char_type __fmt[4]; 
# 1250
(__fmt[0]) = __ctype.widen('%'); 
# 1251
if (!__mod) 
# 1252
{ 
# 1253
(__fmt[1]) = __format; 
# 1254
(__fmt[2]) = char_type(); 
# 1255
} else 
# 1257
{ 
# 1258
(__fmt[1]) = __mod; 
# 1259
(__fmt[2]) = __format; 
# 1260
(__fmt[3]) = char_type(); 
# 1261
}  
# 1263
__beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt); 
# 1264
if (__beg == __end) { 
# 1265
(__err |= ios_base::eofbit); }  
# 1266
return __beg; 
# 1267
} 
# 1271
template< class _CharT, class _OutIter> _OutIter 
# 1274
time_put< _CharT, _OutIter> ::put(iter_type __s, ios_base &__io, char_type __fill, const tm *__tm, const _CharT *
# 1275
__beg, const _CharT *__end) const 
# 1276
{ 
# 1277
const locale &__loc = __io._M_getloc(); 
# 1278
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1279
for (; __beg != __end; ++__beg) { 
# 1280
if (__ctype.narrow(*__beg, 0) != '%') 
# 1281
{ 
# 1282
(*__s) = (*__beg); 
# 1283
++__s; 
# 1284
} else { 
# 1285
if ((++__beg) != __end) 
# 1286
{ 
# 1287
char __format; 
# 1288
char __mod = (0); 
# 1289
const char __c = __ctype.narrow(*__beg, 0); 
# 1290
if ((__c != ('E')) && (__c != ('O'))) { 
# 1291
__format = __c; } else { 
# 1292
if ((++__beg) != __end) 
# 1293
{ 
# 1294
__mod = __c; 
# 1295
__format = __ctype.narrow(*__beg, 0); 
# 1296
} else { 
# 1298
break; }  }  
# 1299
__s = do_put(__s, __io, __fill, __tm, __format, __mod); 
# 1300
} else { 
# 1302
break; }  }  }  
# 1303
return __s; 
# 1304
} 
# 1306
template< class _CharT, class _OutIter> _OutIter 
# 1309
time_put< _CharT, _OutIter> ::do_put(iter_type __s, ios_base &__io, char_type, const tm *__tm, char 
# 1310
__format, char __mod) const 
# 1311
{ 
# 1312
const locale &__loc = __io._M_getloc(); 
# 1313
const ctype< _CharT>  &__ctype = use_facet< ctype< _CharT> > (__loc); 
# 1314
const __timepunct< _CharT>  &__tp = use_facet< __timepunct< _CharT> > (__loc); 
# 1318
const size_t __maxlen = (128); 
# 1319
char_type __res[__maxlen]; 
# 1326
char_type __fmt[4]; 
# 1327
(__fmt[0]) = __ctype.widen('%'); 
# 1328
if (!__mod) 
# 1329
{ 
# 1330
(__fmt[1]) = __format; 
# 1331
(__fmt[2]) = char_type(); 
# 1332
} else 
# 1334
{ 
# 1335
(__fmt[1]) = __mod; 
# 1336
(__fmt[2]) = __format; 
# 1337
(__fmt[3]) = char_type(); 
# 1338
}  
# 1340
__tp._M_put(__res, __maxlen, __fmt, __tm); 
# 1343
return std::__write(__s, __res, char_traits< char_type> ::length(__res)); 
# 1344
} 
# 1350
extern template class __cxx11::moneypunct< char> ;
# 1351
extern template class __cxx11::moneypunct< char, true> ;
# 1352
extern template class __cxx11::moneypunct_byname< char, false> ;
# 1353
extern template class __cxx11::moneypunct_byname< char, true> ;
# 1354
extern template class __cxx11::money_get< char> ;
# 1355
extern template class __cxx11::money_put< char> ;
# 1356
extern template class __timepunct< char> ;
# 1357
extern template class time_put< char> ;
# 1358
extern template class time_put_byname< char> ;
# 1359
extern template class __cxx11::time_get< char> ;
# 1360
extern template class __cxx11::time_get_byname< char> ;
# 1361
extern template class __cxx11::messages< char> ;
# 1362
extern template class __cxx11::messages_byname< char> ;
# 1364
extern template const __cxx11::moneypunct< char, true>  &use_facet< __cxx11::moneypunct< char, true> > (const locale &);
# 1368
extern template const __cxx11::moneypunct< char>  &use_facet< __cxx11::moneypunct< char> > (const locale &);
# 1372
extern template const __cxx11::money_put< char>  &use_facet< __cxx11::money_put< char> > (const locale &);
# 1376
extern template const __cxx11::money_get< char>  &use_facet< __cxx11::money_get< char> > (const locale &);
# 1380
extern template const __timepunct< char>  &use_facet< __timepunct< char> > (const locale &);
# 1384
extern template const time_put< char>  &use_facet< time_put< char> > (const locale &);
# 1388
extern template const __cxx11::time_get< char>  &use_facet< __cxx11::time_get< char> > (const locale &);
# 1392
extern template const __cxx11::messages< char>  &use_facet< __cxx11::messages< char> > (const locale &);
# 1396
extern template bool has_facet< __cxx11::moneypunct< char> > (const locale &) throw();
# 1400
extern template bool has_facet< __cxx11::money_put< char> > (const locale &) throw();
# 1404
extern template bool has_facet< __cxx11::money_get< char> > (const locale &) throw();
# 1408
extern template bool has_facet< __timepunct< char> > (const locale &) throw();
# 1412
extern template bool has_facet< time_put< char> > (const locale &) throw();
# 1416
extern template bool has_facet< __cxx11::time_get< char> > (const locale &) throw();
# 1420
extern template bool has_facet< __cxx11::messages< char> > (const locale &) throw();
# 1425
extern template class __cxx11::moneypunct< wchar_t> ;
# 1426
extern template class __cxx11::moneypunct< wchar_t, true> ;
# 1427
extern template class __cxx11::moneypunct_byname< wchar_t, false> ;
# 1428
extern template class __cxx11::moneypunct_byname< wchar_t, true> ;
# 1429
extern template class __cxx11::money_get< wchar_t> ;
# 1430
extern template class __cxx11::money_put< wchar_t> ;
# 1431
extern template class __timepunct< wchar_t> ;
# 1432
extern template class time_put< wchar_t> ;
# 1433
extern template class time_put_byname< wchar_t> ;
# 1434
extern template class __cxx11::time_get< wchar_t> ;
# 1435
extern template class __cxx11::time_get_byname< wchar_t> ;
# 1436
extern template class __cxx11::messages< wchar_t> ;
# 1437
extern template class __cxx11::messages_byname< wchar_t> ;
# 1439
extern template const __cxx11::moneypunct< wchar_t, true>  &use_facet< __cxx11::moneypunct< wchar_t, true> > (const locale &);
# 1443
extern template const __cxx11::moneypunct< wchar_t>  &use_facet< __cxx11::moneypunct< wchar_t> > (const locale &);
# 1447
extern template const __cxx11::money_put< wchar_t>  &use_facet< __cxx11::money_put< wchar_t> > (const locale &);
# 1451
extern template const __cxx11::money_get< wchar_t>  &use_facet< __cxx11::money_get< wchar_t> > (const locale &);
# 1455
extern template const __timepunct< wchar_t>  &use_facet< __timepunct< wchar_t> > (const locale &);
# 1459
extern template const time_put< wchar_t>  &use_facet< time_put< wchar_t> > (const locale &);
# 1463
extern template const __cxx11::time_get< wchar_t>  &use_facet< __cxx11::time_get< wchar_t> > (const locale &);
# 1467
extern template const __cxx11::messages< wchar_t>  &use_facet< __cxx11::messages< wchar_t> > (const locale &);
# 1471
extern template bool has_facet< __cxx11::moneypunct< wchar_t> > (const locale &) throw();
# 1475
extern template bool has_facet< __cxx11::money_put< wchar_t> > (const locale &) throw();
# 1479
extern template bool has_facet< __cxx11::money_get< wchar_t> > (const locale &) throw();
# 1483
extern template bool has_facet< __timepunct< wchar_t> > (const locale &) throw();
# 1487
extern template bool has_facet< time_put< wchar_t> > (const locale &) throw();
# 1491
extern template bool has_facet< __cxx11::time_get< wchar_t> > (const locale &) throw();
# 1495
extern template bool has_facet< __cxx11::messages< wchar_t> > (const locale &) throw();
# 1502
}
# 43 "/usr/include/c++/9/bits/locale_conv.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 52
template< class _OutStr, class _InChar, class _Codecvt, class 
# 53
_State, class _Fn> bool 
# 55
__do_str_codecvt(const _InChar *__first, const _InChar *__last, _OutStr &
# 56
__outstr, const _Codecvt &__cvt, _State &__state, size_t &
# 57
__count, _Fn __fn) 
# 58
{ 
# 59
if (__first == __last) 
# 60
{ 
# 61
__outstr.clear(); 
# 62
__count = (0); 
# 63
return true; 
# 64
}  
# 66
size_t __outchars = (0); 
# 67
auto __next = __first; 
# 68
const auto __maxlen = __cvt.max_length() + 1; 
# 70
codecvt_base::result __result; 
# 71
do 
# 72
{ 
# 73
__outstr.resize(__outstr.size() + ((__last - __next) * __maxlen)); 
# 74
auto __outnext = (&__outstr.front()) + __outchars; 
# 75
const auto __outlast = ((&__outstr.back()) + 1); 
# 76
__result = (__cvt.*__fn)(__state, __next, __last, __next, __outnext, __outlast, __outnext); 
# 78
__outchars = (__outnext - (&__outstr.front())); 
# 79
} 
# 80
while ((__result == (codecvt_base::partial)) && (__next != __last) && ((__outstr.size() - __outchars) < __maxlen)); 
# 83
if (__result == (codecvt_base::error)) 
# 84
{ 
# 85
__count = (__next - __first); 
# 86
return false; 
# 87
}  
# 91
if (is_same< typename _Codecvt::intern_type, typename _Codecvt::extern_type> ()) { 
# 93
if (__result == (codecvt_base::noconv)) 
# 94
{ 
# 95
__outstr.assign(__first, __last); 
# 96
__count = (__last - __first); 
# 97
return true; 
# 98
}  }  
# 100
__outstr.resize(__outchars); 
# 101
__count = (__next - __first); 
# 102
return true; 
# 103
} 
# 106
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 108
__str_codecvt_in(const char *__first, const char *__last, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 109
__outstr, const codecvt< _CharT, char, _State>  &
# 110
__cvt, _State &
# 111
__state, size_t &__count) 
# 112
{ 
# 113
using _Codecvt = codecvt< _CharT, char, _State> ; 
# 114
using _ConvFn = codecvt_base::result (codecvt< _CharT, char, _State> ::*)(_State &, const char *, const char *, const char *&, _CharT *, _CharT *, _CharT *&) const; 
# 118
_ConvFn __fn = (&codecvt< _CharT, char, _State> ::in); 
# 119
return __do_str_codecvt(__first, __last, __outstr, __cvt, __state, __count, __fn); 
# 121
} 
# 124
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 126
__str_codecvt_in(const char *__first, const char *__last, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 127
__outstr, const codecvt< _CharT, char, _State>  &
# 128
__cvt) 
# 129
{ 
# 130
_State __state = {}; 
# 131
size_t __n; 
# 132
return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n); 
# 133
} 
# 136
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 138
__str_codecvt_in_all(const char *__first, const char *__last, __cxx11::basic_string< _CharT, _Traits, _Alloc>  &
# 139
__outstr, const codecvt< _CharT, char, _State>  &
# 140
__cvt) 
# 141
{ 
# 142
_State __state = {}; 
# 143
size_t __n; 
# 144
return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n) && (__n == (__last - __first)); 
# 146
} 
# 149
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 151
__str_codecvt_out(const _CharT *__first, const _CharT *__last, __cxx11::basic_string< char, _Traits, _Alloc>  &
# 152
__outstr, const codecvt< _CharT, char, _State>  &
# 153
__cvt, _State &
# 154
__state, size_t &__count) 
# 155
{ 
# 156
using _Codecvt = codecvt< _CharT, char, _State> ; 
# 157
using _ConvFn = codecvt_base::result (codecvt< _CharT, char, _State> ::*)(_State &, const _CharT *, const _CharT *, const _CharT *&, char *, char *, char *&) const; 
# 161
_ConvFn __fn = (&codecvt< _CharT, char, _State> ::out); 
# 162
return __do_str_codecvt(__first, __last, __outstr, __cvt, __state, __count, __fn); 
# 164
} 
# 167
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 169
__str_codecvt_out(const _CharT *__first, const _CharT *__last, __cxx11::basic_string< char, _Traits, _Alloc>  &
# 170
__outstr, const codecvt< _CharT, char, _State>  &
# 171
__cvt) 
# 172
{ 
# 173
_State __state = {}; 
# 174
size_t __n; 
# 175
return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n); 
# 176
} 
# 179
template< class _CharT, class _Traits, class _Alloc, class _State> inline bool 
# 181
__str_codecvt_out_all(const _CharT *__first, const _CharT *__last, __cxx11::basic_string< char, _Traits, _Alloc>  &
# 182
__outstr, const codecvt< _CharT, char, _State>  &
# 183
__cvt) 
# 184
{ 
# 185
_State __state = {}; 
# 186
size_t __n; 
# 187
return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n) && (__n == (__last - __first)); 
# 189
} 
# 226 "/usr/include/c++/9/bits/locale_conv.h" 3
inline namespace __cxx11 { 
# 229
template< class _Codecvt, class _Elem = wchar_t, class 
# 230
_Wide_alloc = allocator< _Elem> , class 
# 231
_Byte_alloc = allocator< char> > 
# 232
class wstring_convert { 
# 235
public: typedef basic_string< char, char_traits< char> , _Byte_alloc>  byte_string; 
# 236
typedef basic_string< _Elem, char_traits< _Elem> , _Wide_alloc>  wide_string; 
# 237
typedef typename _Codecvt::state_type state_type; 
# 238
typedef typename basic_string< _Elem, char_traits< _Elem> , _Wide_alloc> ::traits_type::int_type int_type; 
# 241
wstring_convert() : _M_cvt(new _Codecvt()) { } 
# 250
explicit wstring_convert(_Codecvt *__pcvt) : _M_cvt(__pcvt) 
# 251
{ 
# 252
if (!(_M_cvt)) { 
# 253
__throw_logic_error("wstring_convert"); }  
# 254
} 
# 264 "/usr/include/c++/9/bits/locale_conv.h" 3
wstring_convert(_Codecvt *__pcvt, state_type __state) : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true) 
# 266
{ 
# 267
if (!(_M_cvt)) { 
# 268
__throw_logic_error("wstring_convert"); }  
# 269
} 
# 277
explicit wstring_convert(const byte_string &__byte_err, const wide_string &
# 278
__wide_err = wide_string()) : _M_cvt(new _Codecvt), _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err), _M_with_strings(true) 
# 282
{ 
# 283
if (!(_M_cvt)) { 
# 284
__throw_logic_error("wstring_convert"); }  
# 285
} 
# 287
~wstring_convert() = default;
# 291
wstring_convert(const wstring_convert &) = delete;
# 292
wstring_convert &operator=(const wstring_convert &) = delete;
# 296
wide_string from_bytes(char __byte) 
# 297
{ 
# 298
char __bytes[2] = {__byte}; 
# 299
return from_bytes(__bytes, __bytes + 1); 
# 300
} 
# 303
wide_string from_bytes(const char *__ptr) 
# 304
{ return from_bytes(__ptr, __ptr + char_traits< char> ::length(__ptr)); } 
# 307
wide_string from_bytes(const byte_string &__str) 
# 308
{ 
# 309
auto __ptr = __str.data(); 
# 310
return from_bytes(__ptr, __ptr + __str.size()); 
# 311
} 
# 314
wide_string from_bytes(const char *__first, const char *__last) 
# 315
{ 
# 316
if (!(_M_with_cvtstate)) { 
# 317
(_M_state) = state_type(); }  
# 318
wide_string __out{(_M_wide_err_string).get_allocator()}; 
# 319
if (__str_codecvt_in(__first, __last, __out, *(_M_cvt), _M_state, _M_count)) { 
# 321
return __out; }  
# 322
if (_M_with_strings) { 
# 323
return _M_wide_err_string; }  
# 324
__throw_range_error("wstring_convert::from_bytes"); 
# 325
} 
# 330
byte_string to_bytes(_Elem __wchar) 
# 331
{ 
# 332
_Elem __wchars[2] = {__wchar}; 
# 333
return to_bytes(__wchars, __wchars + 1); 
# 334
} 
# 337
byte_string to_bytes(const _Elem *__ptr) 
# 338
{ 
# 339
return to_bytes(__ptr, __ptr + wide_string::traits_type::length(__ptr)); 
# 340
} 
# 343
byte_string to_bytes(const wide_string &__wstr) 
# 344
{ 
# 345
auto __ptr = __wstr.data(); 
# 346
return to_bytes(__ptr, __ptr + __wstr.size()); 
# 347
} 
# 350
byte_string to_bytes(const _Elem *__first, const _Elem *__last) 
# 351
{ 
# 352
if (!(_M_with_cvtstate)) { 
# 353
(_M_state) = state_type(); }  
# 354
byte_string __out{(_M_byte_err_string).get_allocator()}; 
# 355
if (__str_codecvt_out(__first, __last, __out, *(_M_cvt), _M_state, _M_count)) { 
# 357
return __out; }  
# 358
if (_M_with_strings) { 
# 359
return _M_byte_err_string; }  
# 360
__throw_range_error("wstring_convert::to_bytes"); 
# 361
} 
# 367
size_t converted() const noexcept { return _M_count; } 
# 370
state_type state() const { return _M_state; } 
# 373
private: unique_ptr< _Codecvt>  _M_cvt; 
# 374
byte_string _M_byte_err_string; 
# 375
wide_string _M_wide_err_string; 
# 376
state_type _M_state = state_type(); 
# 377
size_t _M_count = (0); 
# 378
bool _M_with_cvtstate = false; 
# 379
bool _M_with_strings = false; 
# 380
}; 
# 382
}
# 385
template< class _Codecvt, class _Elem = wchar_t, class 
# 386
_Tr = char_traits< _Elem> > 
# 387
class wbuffer_convert : public basic_streambuf< _Elem, _Tr>  { 
# 389
typedef basic_streambuf< _Elem, _Tr>  _Wide_streambuf; 
# 392
public: typedef typename _Codecvt::state_type state_type; 
# 395
wbuffer_convert() : wbuffer_convert(nullptr) { } 
# 406 "/usr/include/c++/9/bits/locale_conv.h" 3
explicit wbuffer_convert(std::streambuf *__bytebuf, _Codecvt *__pcvt = new _Codecvt, state_type 
# 407
__state = state_type()) : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state) 
# 409
{ 
# 410
if (!(_M_cvt)) { 
# 411
__throw_logic_error("wbuffer_convert"); }  
# 413
(_M_always_noconv) = (_M_cvt)->always_noconv(); 
# 415
if (_M_buf) 
# 416
{ 
# 417
this->setp(_M_put_area, (_M_put_area) + _S_buffer_length); 
# 418
this->setg((_M_get_area) + _S_putback_length, (_M_get_area) + _S_putback_length, (_M_get_area) + _S_putback_length); 
# 421
}  
# 422
} 
# 424
~wbuffer_convert() = default;
# 428
wbuffer_convert(const wbuffer_convert &) = delete;
# 429
wbuffer_convert &operator=(const wbuffer_convert &) = delete;
# 431
std::streambuf *rdbuf() const noexcept { return _M_buf; } 
# 434
std::streambuf *rdbuf(std::streambuf *__bytebuf) noexcept 
# 435
{ 
# 436
auto __prev = _M_buf; 
# 437
(_M_buf) = __bytebuf; 
# 438
return __prev; 
# 439
} 
# 442
state_type state() const noexcept { return _M_state; } 
# 446
protected: int sync() 
# 447
{ return ((_M_buf) && _M_conv_put() && (!((_M_buf)->pubsync()))) ? 0 : (-1); } 
# 450
typename basic_streambuf< _Elem, _Tr> ::int_type overflow(typename basic_streambuf< _Elem, _Tr> ::int_type __out) 
# 451
{ 
# 452
if ((!(_M_buf)) || (!_M_conv_put())) { 
# 453
return _Tr::eof(); } else { 
# 454
if (!_Tr::eq_int_type(__out, _Tr::eof())) { 
# 455
return this->sputc(__out); }  }  
# 456
return _Tr::not_eof(__out); 
# 457
} 
# 460
typename basic_streambuf< _Elem, _Tr> ::int_type underflow() 
# 461
{ 
# 462
if (!(_M_buf)) { 
# 463
return _Tr::eof(); }  
# 465
if ((this->gptr() < this->egptr()) || ((_M_buf) && _M_conv_get())) { 
# 466
return _Tr::to_int_type(*this->gptr()); } else { 
# 468
return _Tr::eof(); }  
# 469
} 
# 472
std::streamsize xsputn(const typename basic_streambuf< _Elem, _Tr> ::char_type *__s, std::streamsize __n) 
# 473
{ 
# 474
if ((!(_M_buf)) || (__n == (0))) { 
# 475
return 0; }  
# 476
std::streamsize __done = (0); 
# 477
do 
# 478
{ 
# 479
auto __nn = std::min< std::streamsize> (this->epptr() - this->pptr(), __n - __done); 
# 481
_Tr::copy(this->pptr(), __s + __done, __nn); 
# 482
this->pbump(__nn); 
# 483
__done += __nn; 
# 484
} while ((__done < __n) && _M_conv_put()); 
# 485
return __done; 
# 486
} 
# 491
private: bool _M_conv_get() 
# 492
{ 
# 493
const std::streamsize __pb1 = this->gptr() - this->eback(); 
# 494
const std::streamsize __pb2 = _S_putback_length; 
# 495
const std::streamsize __npb = std::min(__pb1, __pb2); 
# 497
_Tr::move(((_M_get_area) + _S_putback_length) - __npb, this->gptr() - __npb, __npb); 
# 500
std::streamsize __nbytes = sizeof((_M_get_buf)) - (_M_unconv); 
# 501
__nbytes = std::min(__nbytes, (_M_buf)->in_avail()); 
# 502
if (__nbytes < (1)) { 
# 503
__nbytes = (1); }  
# 504
__nbytes = (_M_buf)->sgetn((_M_get_buf) + (_M_unconv), __nbytes); 
# 505
if (__nbytes < (1)) { 
# 506
return false; }  
# 507
__nbytes += (_M_unconv); 
# 511
_Elem *__outbuf = (_M_get_area) + _S_putback_length; 
# 512
_Elem *__outnext = __outbuf; 
# 513
const char *__bnext = _M_get_buf; 
# 515
std::codecvt_base::result __result; 
# 516
if (_M_always_noconv) { 
# 517
__result = codecvt_base::noconv; } else 
# 519
{ 
# 520
_Elem *__outend = (_M_get_area) + _S_buffer_length; 
# 522
__result = (_M_cvt)->in(_M_state, __bnext, __bnext + __nbytes, __bnext, __outbuf, __outend, __outnext); 
# 525
}  
# 527
if (__result == (codecvt_base::noconv)) 
# 528
{ 
# 530
auto __get_buf = reinterpret_cast< const _Elem *>(_M_get_buf); 
# 531
_Tr::copy(__outbuf, __get_buf, __nbytes); 
# 532
(_M_unconv) = (0); 
# 533
return true; 
# 534
}  
# 536
if (((_M_unconv) = (((_M_get_buf) + __nbytes) - __bnext))) { 
# 537
char_traits< char> ::move(_M_get_buf, __bnext, _M_unconv); }  
# 539
this->setg(__outbuf, __outbuf, __outnext); 
# 541
return __result != (codecvt_base::error); 
# 542
} 
# 546
bool _M_put(...) 
# 547
{ return false; } 
# 550
bool _M_put(const char *__p, std::streamsize __n) 
# 551
{ 
# 552
if ((_M_buf)->sputn(__p, __n) < __n) { 
# 553
return false; }  
# 554
return true; 
# 555
} 
# 559
bool _M_conv_put() 
# 560
{ 
# 561
_Elem *const __first = this->pbase(); 
# 562
const _Elem *const __last = this->pptr(); 
# 563
const std::streamsize __pending = (__last - __first); 
# 565
if (_M_always_noconv) { 
# 566
return _M_put(__first, __pending); }  
# 568
char __outbuf[(2) * _S_buffer_length]; 
# 570
const _Elem *__next = (__first); 
# 571
const _Elem *__start; 
# 572
do 
# 573
{ 
# 574
__start = __next; 
# 575
char *__outnext = __outbuf; 
# 576
char *const __outlast = __outbuf + sizeof __outbuf; 
# 577
auto __result = (_M_cvt)->out(_M_state, __next, __last, __next, __outnext, __outlast, __outnext); 
# 579
if (__result == codecvt_base::error) { 
# 580
return false; } else { 
# 581
if (__result == codecvt_base::noconv) { 
# 582
return _M_put(__next, __pending); }  }  
# 584
if (!_M_put(__outbuf, __outnext - __outbuf)) { 
# 585
return false; }  
# 586
} 
# 587
while ((__next != __last) && (__next != __start)); 
# 589
if (__next != __last) { 
# 590
_Tr::move(__first, __next, __last - __next); }  
# 592
this->pbump(__first - __next); 
# 593
return __next != __first; 
# 594
} 
# 596
std::streambuf *_M_buf; 
# 597
unique_ptr< _Codecvt>  _M_cvt; 
# 598
state_type _M_state; 
# 600
static const std::streamsize _S_buffer_length = (32); 
# 601
static const std::streamsize _S_putback_length = (3); 
# 602
_Elem _M_put_area[_S_buffer_length]; 
# 603
_Elem _M_get_area[_S_buffer_length]; 
# 604
std::streamsize _M_unconv = (0); 
# 605
char _M_get_buf[_S_buffer_length - _S_putback_length]; 
# 606
bool _M_always_noconv; 
# 607
}; 
# 614
}
# 40 "/usr/include/c++/9/bits/quoted_string.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 44
namespace __detail { 
# 48
template< class _String, class _CharT> 
# 49
struct _Quoted_string { 
# 51
static_assert((is_reference< _String> ::value || is_pointer< _String> ::value), "String type must be pointer or reference");
# 55
_Quoted_string(_String __str, _CharT __del, _CharT __esc) : _M_string(__str), _M_delim{__del}, _M_escape{__esc} 
# 57
{ } 
# 60
_Quoted_string &operator=(_Quoted_string &) = delete;
# 62
_String _M_string; 
# 63
_CharT _M_delim; 
# 64
_CharT _M_escape; 
# 65
}; 
# 91 "/usr/include/c++/9/bits/quoted_string.h" 3
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 93
operator<<(basic_ostream< _CharT, _Traits>  &__os, const _Quoted_string< const _CharT *, _CharT>  &
# 94
__str) 
# 95
{ 
# 96
__cxx11::basic_ostringstream< _CharT, _Traits>  __ostr; 
# 97
__ostr << (__str._M_delim); 
# 98
for (const _CharT *__c = ((__str._M_string)); *__c; ++__c) 
# 99
{ 
# 100
if (((*__c) == (__str._M_delim)) || ((*__c) == (__str._M_escape))) { 
# 101
__ostr << (__str._M_escape); }  
# 102
__ostr << (*__c); 
# 103
}  
# 104
__ostr << (__str._M_delim); 
# 106
return __os << __ostr.str(); 
# 107
} 
# 115
template< class _CharT, class _Traits, class _String> basic_ostream< _CharT, _Traits>  &
# 117
operator<<(basic_ostream< _CharT, _Traits>  &__os, const _Quoted_string< _String, _CharT>  &
# 118
__str) 
# 119
{ 
# 120
__cxx11::basic_ostringstream< _CharT, _Traits>  __ostr; 
# 121
__ostr << (__str._M_delim); 
# 122
for (auto __c : ((__str._M_string))) 
# 123
{ 
# 124
if ((__c == (__str._M_delim)) || (__c == (__str._M_escape))) { 
# 125
__ostr << (__str._M_escape); }  
# 126
__ostr << __c; 
# 127
}  
# 128
__ostr << (__str._M_delim); 
# 130
return __os << __ostr.str(); 
# 131
} 
# 137
template< class _CharT, class _Traits, class _Alloc> basic_istream< _CharT, _Traits>  &
# 139
operator>>(basic_istream< _CharT, _Traits>  &__is, const _Quoted_string< __cxx11::basic_string< _CharT, _Traits, _Alloc>  &, _CharT>  &
# 141
__str) 
# 142
{ 
# 143
_CharT __c; 
# 144
__is >> __c; 
# 145
if (!__is.good()) { 
# 146
return __is; }  
# 147
if (__c != (__str._M_delim)) 
# 148
{ 
# 149
__is.unget(); 
# 150
__is >> (__str._M_string); 
# 151
return __is; 
# 152
}  
# 153
(__str._M_string).clear(); 
# 154
ios_base::fmtflags __flags = __is.flags(__is.flags() & (~ios_base::skipws)); 
# 156
do 
# 157
{ 
# 158
__is >> __c; 
# 159
if (!__is.good()) { 
# 160
break; }  
# 161
if (__c == (__str._M_escape)) 
# 162
{ 
# 163
__is >> __c; 
# 164
if (!__is.good()) { 
# 165
break; }  
# 166
} else { 
# 167
if (__c == (__str._M_delim)) { 
# 168
break; }  }  
# 169
(__str._M_string) += __c; 
# 170
} 
# 171
while (true); 
# 172
__is.setf(__flags); 
# 174
return __is; 
# 175
} 
# 176
}
# 179
}
# 49 "/usr/include/c++/9/iomanip" 3
namespace std __attribute((__visibility__("default"))) { 
# 56
struct _Resetiosflags { ios_base::fmtflags _M_mask; }; 
# 66 "/usr/include/c++/9/iomanip" 3
inline _Resetiosflags resetiosflags(ios_base::fmtflags __mask) 
# 67
{ return {__mask}; } 
# 69
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 71
operator>>(basic_istream< _CharT, _Traits>  &__is, _Resetiosflags __f) 
# 72
{ 
# 73
__is.setf((ios_base::fmtflags)0, __f._M_mask); 
# 74
return __is; 
# 75
} 
# 77
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 79
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Resetiosflags __f) 
# 80
{ 
# 81
__os.setf((ios_base::fmtflags)0, __f._M_mask); 
# 82
return __os; 
# 83
} 
# 86
struct _Setiosflags { ios_base::fmtflags _M_mask; }; 
# 96 "/usr/include/c++/9/iomanip" 3
inline _Setiosflags setiosflags(ios_base::fmtflags __mask) 
# 97
{ return {__mask}; } 
# 99
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 101
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setiosflags __f) 
# 102
{ 
# 103
__is.setf(__f._M_mask); 
# 104
return __is; 
# 105
} 
# 107
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 109
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setiosflags __f) 
# 110
{ 
# 111
__os.setf(__f._M_mask); 
# 112
return __os; 
# 113
} 
# 116
struct _Setbase { int _M_base; }; 
# 127 "/usr/include/c++/9/iomanip" 3
inline _Setbase setbase(int __base) 
# 128
{ return {__base}; } 
# 130
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 132
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setbase __f) 
# 133
{ 
# 134
__is.setf(((__f._M_base) == 8) ? ios_base::oct : (((__f._M_base) == 10) ? ios_base::dec : (((__f._M_base) == 16) ? ios_base::hex : ((ios_base::fmtflags)0))), ios_base::basefield); 
# 138
return __is; 
# 139
} 
# 141
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 143
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setbase __f) 
# 144
{ 
# 145
__os.setf(((__f._M_base) == 8) ? ios_base::oct : (((__f._M_base) == 10) ? ios_base::dec : (((__f._M_base) == 16) ? ios_base::hex : ((ios_base::fmtflags)0))), ios_base::basefield); 
# 149
return __os; 
# 150
} 
# 153
template< class _CharT> 
# 154
struct _Setfill { _CharT _M_c; }; 
# 163 "/usr/include/c++/9/iomanip" 3
template< class _CharT> inline _Setfill< _CharT>  
# 165
setfill(_CharT __c) 
# 166
{ return {__c}; } 
# 168
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 170
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setfill< _CharT>  __f) 
# 171
{ 
# 172
__is.fill((__f._M_c)); 
# 173
return __is; 
# 174
} 
# 176
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 178
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setfill< _CharT>  __f) 
# 179
{ 
# 180
__os.fill((__f._M_c)); 
# 181
return __os; 
# 182
} 
# 185
struct _Setprecision { int _M_n; }; 
# 195 "/usr/include/c++/9/iomanip" 3
inline _Setprecision setprecision(int __n) 
# 196
{ return {__n}; } 
# 198
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 200
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setprecision __f) 
# 201
{ 
# 202
__is.precision(__f._M_n); 
# 203
return __is; 
# 204
} 
# 206
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 208
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setprecision __f) 
# 209
{ 
# 210
__os.precision(__f._M_n); 
# 211
return __os; 
# 212
} 
# 215
struct _Setw { int _M_n; }; 
# 225 "/usr/include/c++/9/iomanip" 3
inline _Setw setw(int __n) 
# 226
{ return {__n}; } 
# 228
template< class _CharT, class _Traits> inline basic_istream< _CharT, _Traits>  &
# 230
operator>>(basic_istream< _CharT, _Traits>  &__is, _Setw __f) 
# 231
{ 
# 232
__is.width(__f._M_n); 
# 233
return __is; 
# 234
} 
# 236
template< class _CharT, class _Traits> inline basic_ostream< _CharT, _Traits>  &
# 238
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Setw __f) 
# 239
{ 
# 240
__os.width(__f._M_n); 
# 241
return __os; 
# 242
} 
# 246
template< class _MoneyT> 
# 247
struct _Get_money { _MoneyT &_M_mon; bool _M_intl; }; 
# 257 "/usr/include/c++/9/iomanip" 3
template< class _MoneyT> inline _Get_money< _MoneyT>  
# 259
get_money(_MoneyT &__mon, bool __intl = false) 
# 260
{ return {__mon, __intl}; } 
# 262
template< class _CharT, class _Traits, class _MoneyT> basic_istream< _CharT, _Traits>  &
# 264
operator>>(basic_istream< _CharT, _Traits>  &__is, _Get_money< _MoneyT>  __f) 
# 265
{ 
# 266
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__is, false); 
# 267
if (__cerb) 
# 268
{ 
# 269
ios_base::iostate __err = ios_base::goodbit; 
# 270
try 
# 271
{ 
# 272
typedef istreambuf_iterator< _CharT, _Traits>  _Iter; 
# 273
typedef __cxx11::money_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  _MoneyGet; 
# 275
const _MoneyGet &__mg = use_facet< __cxx11::money_get< _CharT, istreambuf_iterator< _CharT, _Traits> > > (__is.getloc()); 
# 276
__mg.get(((istreambuf_iterator< _CharT, _Traits> )(__is.rdbuf())), _Iter(), (__f._M_intl), __is, __err, (__f._M_mon)); 
# 278
} 
# 279
catch (__cxxabiv1::__forced_unwind &) 
# 280
{ 
# 281
__is._M_setstate(ios_base::badbit); 
# 282
throw; 
# 283
} 
# 284
catch (...) 
# 285
{ __is._M_setstate(ios_base::badbit); }  
# 286
if (__err) { 
# 287
__is.setstate(__err); }  
# 288
}  
# 289
return __is; 
# 290
} 
# 293
template< class _MoneyT> 
# 294
struct _Put_money { const _MoneyT &_M_mon; bool _M_intl; }; 
# 304 "/usr/include/c++/9/iomanip" 3
template< class _MoneyT> inline _Put_money< _MoneyT>  
# 306
put_money(const _MoneyT &__mon, bool __intl = false) 
# 307
{ return {__mon, __intl}; } 
# 309
template< class _CharT, class _Traits, class _MoneyT> basic_ostream< _CharT, _Traits>  &
# 311
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Put_money< _MoneyT>  __f) 
# 312
{ 
# 313
typename basic_ostream< _CharT, _Traits> ::sentry __cerb(__os); 
# 314
if (__cerb) 
# 315
{ 
# 316
ios_base::iostate __err = ios_base::goodbit; 
# 317
try 
# 318
{ 
# 319
typedef ostreambuf_iterator< _CharT, _Traits>  _Iter; 
# 320
typedef __cxx11::money_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  _MoneyPut; 
# 322
const _MoneyPut &__mp = use_facet< __cxx11::money_put< _CharT, ostreambuf_iterator< _CharT, _Traits> > > (__os.getloc()); 
# 323
if (__mp.put(((ostreambuf_iterator< _CharT, _Traits> )(__os.rdbuf())), (__f._M_intl), __os, __os.fill(), (__f._M_mon)).failed()) { 
# 325
(__err |= ios_base::badbit); }  
# 326
} 
# 327
catch (__cxxabiv1::__forced_unwind &) 
# 328
{ 
# 329
__os._M_setstate(ios_base::badbit); 
# 330
throw; 
# 331
} 
# 332
catch (...) 
# 333
{ __os._M_setstate(ios_base::badbit); }  
# 334
if (__err) { 
# 335
__os.setstate(__err); }  
# 336
}  
# 337
return __os; 
# 338
} 
# 340
template< class _CharT> 
# 341
struct _Put_time { 
# 343
const tm *_M_tmb; 
# 344
const _CharT *_M_fmt; 
# 345
}; 
# 356 "/usr/include/c++/9/iomanip" 3
template< class _CharT> inline _Put_time< _CharT>  
# 358
put_time(const tm *__tmb, const _CharT *__fmt) 
# 359
{ return {__tmb, __fmt}; } 
# 361
template< class _CharT, class _Traits> basic_ostream< _CharT, _Traits>  &
# 363
operator<<(basic_ostream< _CharT, _Traits>  &__os, _Put_time< _CharT>  __f) 
# 364
{ 
# 365
typename basic_ostream< _CharT, _Traits> ::sentry __cerb(__os); 
# 366
if (__cerb) 
# 367
{ 
# 368
ios_base::iostate __err = ios_base::goodbit; 
# 369
try 
# 370
{ 
# 371
typedef ostreambuf_iterator< _CharT, _Traits>  _Iter; 
# 372
typedef time_put< _CharT, ostreambuf_iterator< _CharT, _Traits> >  _TimePut; 
# 374
const _CharT *const __fmt_end = (__f._M_fmt) + _Traits::length((__f._M_fmt)); 
# 377
const _TimePut &__mp = use_facet< time_put< _CharT, ostreambuf_iterator< _CharT, _Traits> > > (__os.getloc()); 
# 378
if (__mp.put(((ostreambuf_iterator< _CharT, _Traits> )(__os.rdbuf())), __os, __os.fill(), (__f._M_tmb), (__f._M_fmt), __fmt_end).failed()) { 
# 380
(__err |= ios_base::badbit); }  
# 381
} 
# 382
catch (__cxxabiv1::__forced_unwind &) 
# 383
{ 
# 384
__os._M_setstate(ios_base::badbit); 
# 385
throw; 
# 386
} 
# 387
catch (...) 
# 388
{ __os._M_setstate(ios_base::badbit); }  
# 389
if (__err) { 
# 390
__os.setstate(__err); }  
# 391
}  
# 392
return __os; 
# 393
} 
# 395
template< class _CharT> 
# 396
struct _Get_time { 
# 398
tm *_M_tmb; 
# 399
const _CharT *_M_fmt; 
# 400
}; 
# 411 "/usr/include/c++/9/iomanip" 3
template< class _CharT> inline _Get_time< _CharT>  
# 413
get_time(tm *__tmb, const _CharT *__fmt) 
# 414
{ return {__tmb, __fmt}; } 
# 416
template< class _CharT, class _Traits> basic_istream< _CharT, _Traits>  &
# 418
operator>>(basic_istream< _CharT, _Traits>  &__is, _Get_time< _CharT>  __f) 
# 419
{ 
# 420
typename basic_istream< _CharT, _Traits> ::sentry __cerb(__is, false); 
# 421
if (__cerb) 
# 422
{ 
# 423
ios_base::iostate __err = ios_base::goodbit; 
# 424
try 
# 425
{ 
# 426
typedef istreambuf_iterator< _CharT, _Traits>  _Iter; 
# 427
typedef __cxx11::time_get< _CharT, istreambuf_iterator< _CharT, _Traits> >  _TimeGet; 
# 429
const _CharT *const __fmt_end = (__f._M_fmt) + _Traits::length((__f._M_fmt)); 
# 432
const _TimeGet &__mg = use_facet< __cxx11::time_get< _CharT, istreambuf_iterator< _CharT, _Traits> > > (__is.getloc()); 
# 433
__mg.get(((istreambuf_iterator< _CharT, _Traits> )(__is.rdbuf())), _Iter(), __is, __err, (__f._M_tmb), (__f._M_fmt), __fmt_end); 
# 435
} 
# 436
catch (__cxxabiv1::__forced_unwind &) 
# 437
{ 
# 438
__is._M_setstate(ios_base::badbit); 
# 439
throw; 
# 440
} 
# 441
catch (...) 
# 442
{ __is._M_setstate(ios_base::badbit); }  
# 443
if (__err) { 
# 444
__is.setstate(__err); }  
# 445
}  
# 446
return __is; 
# 447
} 
# 459 "/usr/include/c++/9/iomanip" 3
template< class _CharT> inline auto 
# 461
quoted(const _CharT *__string, _CharT 
# 462
__delim = (_CharT)'\"', _CharT __escape = (_CharT)'\\') 
# 463
{ 
# 464
return __detail::_Quoted_string< const _CharT *, _CharT> (__string, __delim, __escape); 
# 466
} 
# 468
template< class _CharT, class _Traits, class _Alloc> inline auto 
# 470
quoted(const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &__string, _CharT 
# 471
__delim = (_CharT)'\"', _CharT __escape = (_CharT)'\\') 
# 472
{ 
# 473
return __detail::_Quoted_string< const __cxx11::basic_string< _CharT, _Traits, _Alloc>  &, _CharT> (__string, __delim, __escape); 
# 476
} 
# 478
template< class _CharT, class _Traits, class _Alloc> inline auto 
# 480
quoted(__cxx11::basic_string< _CharT, _Traits, _Alloc>  &__string, _CharT 
# 481
__delim = (_CharT)'\"', _CharT __escape = (_CharT)'\\') 
# 482
{ 
# 483
return __detail::_Quoted_string< __cxx11::basic_string< _CharT, _Traits, _Alloc>  &, _CharT> (__string, __delim, __escape); 
# 486
} 
# 508 "/usr/include/c++/9/iomanip" 3
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setfill< char>  __f);
# 509
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setiosflags __f);
# 510
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Resetiosflags __f);
# 511
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setbase __f);
# 512
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setprecision __f);
# 513
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setw __f);
# 514
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setfill< char>  __f);
# 515
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setiosflags __f);
# 516
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Resetiosflags __f);
# 517
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setbase __f);
# 518
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setprecision __f);
# 519
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setw __f);
# 522
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setfill< wchar_t>  __f);
# 523
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setiosflags __f);
# 524
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Resetiosflags __f);
# 525
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setbase __f);
# 526
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setprecision __f);
# 527
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setw __f);
# 528
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setfill< wchar_t>  __f);
# 529
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setiosflags __f);
# 530
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Resetiosflags __f);
# 531
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setbase __f);
# 532
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setprecision __f);
# 533
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setw __f);
# 538
}
# 38 "/usr/include/c++/9/bits/hashtable_policy.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 42
template< class _Key, class _Value, class _Alloc, class 
# 43
_ExtractKey, class _Equal, class 
# 44
_H1, class _H2, class _Hash, class 
# 45
_RehashPolicy, class _Traits> class _Hashtable; 
# 48
namespace __detail { 
# 55
template< class _Key, class _Value, class 
# 56
_ExtractKey, class _Equal, class 
# 57
_H1, class _H2, class _Hash, class _Traits> struct _Hashtable_base; 
# 62
template< class _Iterator> inline typename iterator_traits< _Iterator> ::difference_type 
# 64
__distance_fw(_Iterator __first, _Iterator __last, input_iterator_tag) 
# 66
{ return (__first != __last) ? 1 : 0; } 
# 68
template< class _Iterator> inline typename iterator_traits< _Iterator> ::difference_type 
# 70
__distance_fw(_Iterator __first, _Iterator __last, forward_iterator_tag) 
# 72
{ return std::distance(__first, __last); } 
# 74
template< class _Iterator> inline typename iterator_traits< _Iterator> ::difference_type 
# 76
__distance_fw(_Iterator __first, _Iterator __last) 
# 77
{ return __distance_fw(__first, __last, std::__iterator_category(__first)); 
# 78
} 
# 80
struct _Identity { 
# 82
template< class _Tp> _Tp &&
# 84
operator()(_Tp &&__x) const 
# 85
{ return std::forward< _Tp> (__x); } 
# 86
}; 
# 88
struct _Select1st { 
# 90
template< class _Tp> auto 
# 92
operator()(_Tp &&__x) const->__decltype((std::get< 0> (std::forward< _Tp> (__x)))) 
# 94
{ return std::get< 0> (std::forward< _Tp> (__x)); } 
# 95
}; 
# 97
template< class _NodeAlloc> struct _Hashtable_alloc; 
# 102
template< class _NodeAlloc> 
# 103
struct _ReuseOrAllocNode { 
# 106
private: using __node_alloc_type = _NodeAlloc; 
# 107
using __hashtable_alloc = _Hashtable_alloc< __node_alloc_type> ; 
# 108
using __node_alloc_traits = typename _Hashtable_alloc< __node_alloc_type> ::__node_alloc_traits; 
# 110
using __node_type = typename _Hashtable_alloc< __node_alloc_type> ::__node_type; 
# 113
public: _ReuseOrAllocNode(__node_type *__nodes, __hashtable_alloc &__h) : _M_nodes(__nodes), _M_h(__h) 
# 114
{ } 
# 115
_ReuseOrAllocNode(const _ReuseOrAllocNode &) = delete;
# 117
~_ReuseOrAllocNode() 
# 118
{ (_M_h)._M_deallocate_nodes(_M_nodes); } 
# 120
template< class _Arg> __node_type *
# 122
operator()(_Arg &&__arg) const 
# 123
{ 
# 124
if (_M_nodes) 
# 125
{ 
# 126
__node_type *__node = _M_nodes; 
# 127
(_M_nodes) = (_M_nodes)->_M_next(); 
# 128
(__node->_M_nxt) = nullptr; 
# 129
auto &__a = (_M_h)._M_node_allocator(); 
# 130
__node_alloc_traits::destroy(__a, __node->_M_valptr()); 
# 131
try 
# 132
{ 
# 133
__node_alloc_traits::construct(__a, __node->_M_valptr(), std::forward< _Arg> (__arg)); 
# 135
} 
# 136
catch (...) 
# 137
{ 
# 138
(_M_h)._M_deallocate_node_ptr(__node); 
# 139
throw; 
# 140
}  
# 141
return __node; 
# 142
}  
# 143
return (_M_h)._M_allocate_node(std::forward< _Arg> (__arg)); 
# 144
} 
# 147
private: mutable __node_type *_M_nodes; 
# 148
__hashtable_alloc &_M_h; 
# 149
}; 
# 153
template< class _NodeAlloc> 
# 154
struct _AllocNode { 
# 157
private: using __hashtable_alloc = _Hashtable_alloc< _NodeAlloc> ; 
# 158
using __node_type = typename _Hashtable_alloc< _NodeAlloc> ::__node_type; 
# 161
public: _AllocNode(__hashtable_alloc &__h) : _M_h(__h) 
# 162
{ } 
# 164
template< class _Arg> __node_type *
# 166
operator()(_Arg &&__arg) const 
# 167
{ return (_M_h)._M_allocate_node(std::forward< _Arg> (__arg)); } 
# 170
private: __hashtable_alloc &_M_h; 
# 171
}; 
# 198 "/usr/include/c++/9/bits/hashtable_policy.h" 3
template< bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys> 
# 199
struct _Hashtable_traits { 
# 201
using __hash_cached = __bool_constant< _Cache_hash_code> ; 
# 202
using __constant_iterators = __bool_constant< _Constant_iterators> ; 
# 203
using __unique_keys = __bool_constant< _Unique_keys> ; 
# 204
}; 
# 214 "/usr/include/c++/9/bits/hashtable_policy.h" 3
struct _Hash_node_base { 
# 216
_Hash_node_base *_M_nxt; 
# 218
_Hash_node_base() noexcept : _M_nxt() { } 
# 220
_Hash_node_base(_Hash_node_base *__next) noexcept : _M_nxt(__next) { } 
# 221
}; 
# 228
template< class _Value> 
# 229
struct _Hash_node_value_base : public _Hash_node_base { 
# 231
typedef _Value value_type; 
# 233
__gnu_cxx::__aligned_buffer< _Value>  _M_storage; 
# 236
_Value *_M_valptr() noexcept 
# 237
{ return (_M_storage)._M_ptr(); } 
# 240
const _Value *_M_valptr() const noexcept 
# 241
{ return (_M_storage)._M_ptr(); } 
# 244
_Value &_M_v() noexcept 
# 245
{ return *_M_valptr(); } 
# 248
const _Value &_M_v() const noexcept 
# 249
{ return *_M_valptr(); } 
# 250
}; 
# 255
template< class _Value, bool _Cache_hash_code> struct _Hash_node; 
# 263
template< class _Value> 
# 264
struct _Hash_node< _Value, true>  : public _Hash_node_value_base< _Value>  { 
# 266
std::size_t _M_hash_code; 
# 269
__detail::_Hash_node< _Value, true>  *_M_next() const noexcept 
# 270
{ return static_cast< __detail::_Hash_node< _Value, true>  *>(this->_M_nxt); } 
# 271
}; 
# 278
template< class _Value> 
# 279
struct _Hash_node< _Value, false>  : public _Hash_node_value_base< _Value>  { 
# 282
__detail::_Hash_node< _Value, false>  *_M_next() const noexcept 
# 283
{ return static_cast< __detail::_Hash_node< _Value, false>  *>(this->_M_nxt); } 
# 284
}; 
# 287
template< class _Value, bool _Cache_hash_code> 
# 288
struct _Node_iterator_base { 
# 290
using __node_type = _Hash_node< _Value, _Cache_hash_code> ; 
# 292
__node_type *_M_cur; 
# 294
_Node_iterator_base(__node_type *__p) noexcept : _M_cur(__p) 
# 295
{ } 
# 298
void _M_incr() noexcept 
# 299
{ (_M_cur) = (_M_cur)->_M_next(); } 
# 300
}; 
# 302
template< class _Value, bool _Cache_hash_code> inline bool 
# 304
operator==(const _Node_iterator_base< _Value, _Cache_hash_code>  &__x, const _Node_iterator_base< _Value, _Cache_hash_code>  &
# 305
__y) noexcept 
# 307
{ return (__x._M_cur) == (__y._M_cur); } 
# 309
template< class _Value, bool _Cache_hash_code> inline bool 
# 311
operator!=(const _Node_iterator_base< _Value, _Cache_hash_code>  &__x, const _Node_iterator_base< _Value, _Cache_hash_code>  &
# 312
__y) noexcept 
# 314
{ return (__x._M_cur) != (__y._M_cur); } 
# 317
template< class _Value, bool __constant_iterators, bool __cache> 
# 318
struct _Node_iterator : public _Node_iterator_base< _Value, __cache>  { 
# 322
private: using __base_type = _Node_iterator_base< _Value, __cache> ; 
# 323
using __node_type = typename _Node_iterator_base< _Value, __cache> ::__node_type; 
# 326
public: typedef _Value value_type; 
# 327
typedef std::ptrdiff_t difference_type; 
# 328
typedef std::forward_iterator_tag iterator_category; 
# 330
using pointer = typename conditional< __constant_iterators, const _Value *, _Value *> ::type; 
# 333
using reference = typename conditional< __constant_iterators, const _Value &, _Value &> ::type; 
# 336
_Node_iterator() noexcept : __base_type(0) 
# 337
{ } 
# 340
explicit _Node_iterator(__node_type *__p) noexcept : __base_type(__p) 
# 341
{ } 
# 344
reference operator*() const noexcept 
# 345
{ return (this->_M_cur)->_M_v(); } 
# 348
pointer operator->() const noexcept 
# 349
{ return (this->_M_cur)->_M_valptr(); } 
# 352
_Node_iterator &operator++() noexcept 
# 353
{ 
# 354
this->_M_incr(); 
# 355
return *this; 
# 356
} 
# 359
_Node_iterator operator++(int) noexcept 
# 360
{ 
# 361
_Node_iterator __tmp(*this); 
# 362
this->_M_incr(); 
# 363
return __tmp; 
# 364
} 
# 365
}; 
# 368
template< class _Value, bool __constant_iterators, bool __cache> 
# 369
struct _Node_const_iterator : public _Node_iterator_base< _Value, __cache>  { 
# 373
private: using __base_type = _Node_iterator_base< _Value, __cache> ; 
# 374
using __node_type = typename _Node_iterator_base< _Value, __cache> ::__node_type; 
# 377
public: typedef _Value value_type; 
# 378
typedef std::ptrdiff_t difference_type; 
# 379
typedef std::forward_iterator_tag iterator_category; 
# 381
typedef const _Value *pointer; 
# 382
typedef const _Value &reference; 
# 384
_Node_const_iterator() noexcept : __base_type(0) 
# 385
{ } 
# 388
explicit _Node_const_iterator(__node_type *__p) noexcept : __base_type(__p) 
# 389
{ } 
# 391
_Node_const_iterator(const _Node_iterator< _Value, __constant_iterators, __cache>  &
# 392
__x) noexcept : __base_type((__x._M_cur)) 
# 393
{ } 
# 396
reference operator*() const noexcept 
# 397
{ return (this->_M_cur)->_M_v(); } 
# 400
pointer operator->() const noexcept 
# 401
{ return (this->_M_cur)->_M_valptr(); } 
# 404
_Node_const_iterator &operator++() noexcept 
# 405
{ 
# 406
this->_M_incr(); 
# 407
return *this; 
# 408
} 
# 411
_Node_const_iterator operator++(int) noexcept 
# 412
{ 
# 413
_Node_const_iterator __tmp(*this); 
# 414
this->_M_incr(); 
# 415
return __tmp; 
# 416
} 
# 417
}; 
# 424
struct _Mod_range_hashing { 
# 426
typedef size_t first_argument_type; 
# 427
typedef size_t second_argument_type; 
# 428
typedef size_t result_type; 
# 431
result_type operator()(first_argument_type __num, second_argument_type 
# 432
__den) const noexcept 
# 433
{ return __num % __den; } 
# 434
}; 
# 441
struct _Default_ranged_hash { }; 
# 445
struct _Prime_rehash_policy { 
# 447
using __has_load_factor = true_type; 
# 449
_Prime_rehash_policy(float __z = (1.0)) noexcept : _M_max_load_factor(__z), _M_next_resize((0)) 
# 450
{ } 
# 453
float max_load_factor() const noexcept 
# 454
{ return _M_max_load_factor; } 
# 458
size_t _M_next_bkt(size_t __n) const; 
# 462
size_t _M_bkt_for_elements(size_t __n) const 
# 463
{ return __builtin_ceil(__n / ((long double)(_M_max_load_factor))); } 
# 470
pair< bool, unsigned long>  _M_need_rehash(size_t __n_bkt, size_t __n_elt, size_t __n_ins) const; 
# 473
typedef size_t _State; 
# 476
_State _M_state() const 
# 477
{ return _M_next_resize; } 
# 480
void _M_reset() noexcept 
# 481
{ (_M_next_resize) = (0); } 
# 484
void _M_reset(_State __state) 
# 485
{ (_M_next_resize) = __state; } 
# 487
static const size_t _S_growth_factor = (2); 
# 489
float _M_max_load_factor; 
# 490
mutable size_t _M_next_resize; 
# 491
}; 
# 494
struct _Mask_range_hashing { 
# 496
typedef size_t first_argument_type; 
# 497
typedef size_t second_argument_type; 
# 498
typedef size_t result_type; 
# 501
result_type operator()(first_argument_type __num, second_argument_type 
# 502
__den) const noexcept 
# 503
{ return __num & (__den - (1)); } 
# 504
}; 
# 508
inline size_t __clp2(size_t __n) noexcept 
# 509
{ 
# 511
if (__n < (2)) { 
# 512
return __n; }  
# 513
const unsigned __lz = (sizeof(size_t) > sizeof(long)) ? __builtin_clzll(__n - 1ULL) : __builtin_clzl(__n - 1UL); 
# 517
return (((size_t)1) << ((numeric_limits< unsigned long> ::digits - __lz) - (1))) << 1; 
# 518
} 
# 522
struct _Power2_rehash_policy { 
# 524
using __has_load_factor = true_type; 
# 526
_Power2_rehash_policy(float __z = (1.0)) noexcept : _M_max_load_factor(__z), _M_next_resize((0)) 
# 527
{ } 
# 530
float max_load_factor() const noexcept 
# 531
{ return _M_max_load_factor; } 
# 536
size_t _M_next_bkt(size_t __n) noexcept 
# 537
{ 
# 538
const auto __max_width = (std::min< unsigned long> (sizeof(size_t), 8)); 
# 539
const auto __max_bkt = (((size_t)1) << ((__max_width * (8)) - (1))); 
# 540
size_t __res = __clp2(__n); 
# 542
if (__res == __n) { 
# 543
__res <<= 1; }  
# 545
if (__res == (0)) { 
# 546
__res = __max_bkt; }  
# 548
if (__res == __max_bkt) { 
# 552
(_M_next_resize) = ((size_t)(-1)); } else { 
# 554
(_M_next_resize) = (__builtin_ceil(__res * ((long double)(_M_max_load_factor)))); }  
# 557
return __res; 
# 558
} 
# 562
size_t _M_bkt_for_elements(size_t __n) const noexcept 
# 563
{ return __builtin_ceil(__n / ((long double)(_M_max_load_factor))); } 
# 570
pair< bool, unsigned long>  _M_need_rehash(size_t __n_bkt, size_t __n_elt, size_t 
# 571
__n_ins) noexcept 
# 572
{ 
# 573
if ((__n_elt + __n_ins) >= (_M_next_resize)) 
# 574
{ 
# 575
long double __min_bkts = (__n_elt + __n_ins) / ((long double)(_M_max_load_factor)); 
# 577
if (__min_bkts >= __n_bkt) { 
# 578
return std::make_pair(true, this->_M_next_bkt(std::max< unsigned long> (__builtin_floor(__min_bkts) + (1), __n_bkt * _S_growth_factor))); }  
# 582
(_M_next_resize) = (__builtin_floor(__n_bkt * ((long double)(_M_max_load_factor)))); 
# 584
return std::make_pair(false, 0); 
# 585
} else { 
# 587
return std::make_pair(false, 0); }  
# 588
} 
# 590
typedef size_t _State; 
# 593
_State _M_state() const noexcept 
# 594
{ return _M_next_resize; } 
# 597
void _M_reset() noexcept 
# 598
{ (_M_next_resize) = (0); } 
# 601
void _M_reset(_State __state) noexcept 
# 602
{ (_M_next_resize) = __state; } 
# 604
static const size_t _S_growth_factor = (2); 
# 606
float _M_max_load_factor; 
# 607
size_t _M_next_resize; 
# 608
}; 
# 628 "/usr/include/c++/9/bits/hashtable_policy.h" 3
template< class _Key, class _Value, class _Alloc, class 
# 629
_ExtractKey, class _Equal, class 
# 630
_H1, class _H2, class _Hash, class 
# 631
_RehashPolicy, class _Traits, bool 
# 632
_Unique_keys = _Traits::__unique_keys::value> 
# 633
struct _Map_base { }; 
# 636
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 637
_H1, class _H2, class _Hash, class 
# 638
_RehashPolicy, class _Traits> 
# 639
struct _Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>  { 
# 642
using mapped_type = typename tuple_element< 1UL, _Pair> ::type; 
# 643
}; 
# 646
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 647
_H1, class _H2, class _Hash, class 
# 648
_RehashPolicy, class _Traits> 
# 649
struct _Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>  { 
# 653
private: using __hashtable_base = _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ; 
# 658
using __hashtable = _Hashtable< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 662
using __hash_code = typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::__hash_code; 
# 663
using __node_type = typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::__node_type; 
# 666
public: using key_type = typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::key_type; 
# 667
using iterator = typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::iterator; 
# 668
using mapped_type = typename tuple_element< 1UL, _Pair> ::type; 
# 671
mapped_type &operator[](const key_type & __k); 
# 674
mapped_type &operator[](key_type && __k); 
# 679
mapped_type &at(const key_type & __k); 
# 682
const mapped_type &at(const key_type & __k) const; 
# 683
}; 
# 685
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 686
_H1, class _H2, class _Hash, class 
# 687
_RehashPolicy, class _Traits> auto 
# 691
_Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::operator[](const key_type &__k)->mapped_type & 
# 693
{ 
# 694
__hashtable *__h = static_cast< __hashtable *>(this); 
# 695
__hash_code __code = __h->_M_hash_code(__k); 
# 696
size_t __n = __h->_M_bucket_index(__k, __code); 
# 697
__node_type *__p = __h->_M_find_node(__n, __k, __code); 
# 699
if (!__p) 
# 700
{ 
# 701
__p = __h->_M_allocate_node(std::piecewise_construct, ((tuple< const typename _Hashtable_base< _Key, _Pair, _Select1st, _Equal, _H1, _H2, _Hash, _Traits> ::key_type &> )(__k)), tuple< > ()); 
# 704
return __h->_M_insert_unique_node(__n, __code, __p)->second; 
# 705
}  
# 707
return __p->_M_v().second; 
# 708
} 
# 710
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 711
_H1, class _H2, class _Hash, class 
# 712
_RehashPolicy, class _Traits> auto 
# 716
_Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::operator[](key_type &&__k)->mapped_type & 
# 718
{ 
# 719
__hashtable *__h = static_cast< __hashtable *>(this); 
# 720
__hash_code __code = __h->_M_hash_code(__k); 
# 721
size_t __n = __h->_M_bucket_index(__k, __code); 
# 722
__node_type *__p = __h->_M_find_node(__n, __k, __code); 
# 724
if (!__p) 
# 725
{ 
# 726
__p = __h->_M_allocate_node(std::piecewise_construct, std::forward_as_tuple(std::move(__k)), tuple< > ()); 
# 729
return __h->_M_insert_unique_node(__n, __code, __p)->second; 
# 730
}  
# 732
return __p->_M_v().second; 
# 733
} 
# 735
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 736
_H1, class _H2, class _Hash, class 
# 737
_RehashPolicy, class _Traits> auto 
# 741
_Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::at(const key_type &__k)->mapped_type & 
# 743
{ 
# 744
__hashtable *__h = static_cast< __hashtable *>(this); 
# 745
__hash_code __code = __h->_M_hash_code(__k); 
# 746
size_t __n = __h->_M_bucket_index(__k, __code); 
# 747
__node_type *__p = __h->_M_find_node(__n, __k, __code); 
# 749
if (!__p) { 
# 750
__throw_out_of_range("_Map_base::at"); }  
# 751
return __p->_M_v().second; 
# 752
} 
# 754
template< class _Key, class _Pair, class _Alloc, class _Equal, class 
# 755
_H1, class _H2, class _Hash, class 
# 756
_RehashPolicy, class _Traits> auto 
# 760
_Map_base< _Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::at(const key_type &__k) const->const mapped_type & 
# 762
{ 
# 763
const __hashtable *__h = static_cast< const __hashtable *>(this); 
# 764
__hash_code __code = __h->_M_hash_code(__k); 
# 765
size_t __n = __h->_M_bucket_index(__k, __code); 
# 766
__node_type *__p = __h->_M_find_node(__n, __k, __code); 
# 768
if (!__p) { 
# 769
__throw_out_of_range("_Map_base::at"); }  
# 770
return __p->_M_v().second; 
# 771
} 
# 778
template< class _Key, class _Value, class _Alloc, class 
# 779
_ExtractKey, class _Equal, class 
# 780
_H1, class _H2, class _Hash, class 
# 781
_RehashPolicy, class _Traits> 
# 782
struct _Insert_base { 
# 785
protected: using __hashtable = _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 789
using __hashtable_base = _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ; 
# 793
using value_type = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::value_type; 
# 794
using iterator = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator; 
# 795
using const_iterator = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_iterator; 
# 796
using size_type = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::size_type; 
# 798
using __unique_keys = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__unique_keys; 
# 799
using __ireturn_type = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__ireturn_type; 
# 800
using __node_type = _Hash_node< _Value, _Traits::__hash_cached::value> ; 
# 801
using __node_alloc_type = __alloc_rebind< _Alloc, __node_type> ; 
# 802
using __node_gen_type = _AllocNode< __node_alloc_type> ; 
# 805
__hashtable &_M_conjure_hashtable() 
# 806
{ return *(static_cast< __hashtable *>(this)); } 
# 808
template< class _InputIterator, class _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &, true_type); 
# 813
template< class _InputIterator, class _NodeGetter> void _M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &, false_type); 
# 820
public: __ireturn_type insert(const value_type &__v) 
# 821
{ 
# 822
__hashtable &__h = _M_conjure_hashtable(); 
# 823
__node_gen_type __node_gen(__h); 
# 824
return __h._M_insert(__v, __node_gen, __unique_keys()); 
# 825
} 
# 828
iterator insert(const_iterator __hint, const value_type &__v) 
# 829
{ 
# 830
__hashtable &__h = _M_conjure_hashtable(); 
# 831
__node_gen_type __node_gen(__h); 
# 832
return __h._M_insert(__hint, __v, __node_gen, __unique_keys()); 
# 833
} 
# 836
void insert(initializer_list< value_type>  __l) 
# 837
{ this->insert(__l.begin(), __l.end()); } 
# 839
template< class _InputIterator> void 
# 841
insert(_InputIterator __first, _InputIterator __last) 
# 842
{ 
# 843
__hashtable &__h = _M_conjure_hashtable(); 
# 844
__node_gen_type __node_gen(__h); 
# 845
return _M_insert_range(__first, __last, __node_gen, __unique_keys()); 
# 846
} 
# 847
}; 
# 849
template< class _Key, class _Value, class _Alloc, class 
# 850
_ExtractKey, class _Equal, class 
# 851
_H1, class _H2, class _Hash, class 
# 852
_RehashPolicy, class _Traits> 
# 853
template< class _InputIterator, class _NodeGetter> void 
# 857
_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &
# 858
__node_gen, true_type) 
# 859
{ 
# 860
size_type __n_elt = __detail::__distance_fw(__first, __last); 
# 861
if (__n_elt == 0) { 
# 862
return; }  
# 864
__hashtable &__h = _M_conjure_hashtable(); 
# 865
for (; __first != __last; ++__first) 
# 866
{ 
# 867
if (__h._M_insert(*__first, __node_gen, __unique_keys(), __n_elt).second) { 
# 869
__n_elt = 1; } else { 
# 870
if (__n_elt != 1) { 
# 871
--__n_elt; }  }  
# 872
}  
# 873
} 
# 875
template< class _Key, class _Value, class _Alloc, class 
# 876
_ExtractKey, class _Equal, class 
# 877
_H1, class _H2, class _Hash, class 
# 878
_RehashPolicy, class _Traits> 
# 879
template< class _InputIterator, class _NodeGetter> void 
# 883
_Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_range(_InputIterator __first, _InputIterator __last, const _NodeGetter &
# 884
__node_gen, false_type) 
# 885
{ 
# 886
using __rehash_type = typename _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__rehash_type; 
# 887
using __rehash_state = typename _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__rehash_state; 
# 888
using pair_type = pair< bool, size_t> ; 
# 890
size_type __n_elt = __detail::__distance_fw(__first, __last); 
# 891
if (__n_elt == 0) { 
# 892
return; }  
# 894
__hashtable &__h = _M_conjure_hashtable(); 
# 895
__rehash_type &__rehash = ((__h._M_rehash_policy)); 
# 896
const __rehash_state &__saved_state = __rehash._M_state(); 
# 897
pair_type __do_rehash = __rehash._M_need_rehash((__h._M_bucket_count), (__h._M_element_count), __n_elt); 
# 901
if (__do_rehash.first) { 
# 902
__h._M_rehash(__do_rehash.second, __saved_state); }  
# 904
for (; __first != __last; ++__first) { 
# 905
__h._M_insert(*__first, __node_gen, __unique_keys()); }  
# 906
} 
# 914
template< class _Key, class _Value, class _Alloc, class 
# 915
_ExtractKey, class _Equal, class 
# 916
_H1, class _H2, class _Hash, class 
# 917
_RehashPolicy, class _Traits, bool 
# 918
_Constant_iterators = _Traits::__constant_iterators::value> struct _Insert; 
# 922
template< class _Key, class _Value, class _Alloc, class 
# 923
_ExtractKey, class _Equal, class 
# 924
_H1, class _H2, class _Hash, class 
# 925
_RehashPolicy, class _Traits> 
# 926
struct _Insert< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>  : public _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>  { 
# 931
using __base_type = _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 935
using __hashtable_base = _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ; 
# 939
using value_type = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::value_type; 
# 940
using iterator = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::iterator; 
# 941
using const_iterator = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::const_iterator; 
# 943
using __unique_keys = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__unique_keys; 
# 944
using __ireturn_type = typename _Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__ireturn_type; 
# 945
using __hashtable = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__hashtable; 
# 946
using __node_gen_type = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__node_gen_type; 
# 948
using _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::insert;
# 951
__ireturn_type insert(value_type &&__v) 
# 952
{ 
# 953
__hashtable &__h = this->_M_conjure_hashtable(); 
# 954
__node_gen_type __node_gen(__h); 
# 955
return __h._M_insert(std::move(__v), __node_gen, __unique_keys()); 
# 956
} 
# 959
iterator insert(const_iterator __hint, value_type &&__v) 
# 960
{ 
# 961
__hashtable &__h = this->_M_conjure_hashtable(); 
# 962
__node_gen_type __node_gen(__h); 
# 963
return __h._M_insert(__hint, std::move(__v), __node_gen, __unique_keys()); 
# 965
} 
# 966
}; 
# 969
template< class _Key, class _Value, class _Alloc, class 
# 970
_ExtractKey, class _Equal, class 
# 971
_H1, class _H2, class _Hash, class 
# 972
_RehashPolicy, class _Traits> 
# 973
struct _Insert< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>  : public _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>  { 
# 978
using __base_type = _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 981
using value_type = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::value_type; 
# 982
using iterator = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::iterator; 
# 983
using const_iterator = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::const_iterator; 
# 985
using __unique_keys = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__unique_keys; 
# 986
using __hashtable = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__hashtable; 
# 987
using __ireturn_type = typename _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::__ireturn_type; 
# 989
using _Insert_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::insert;
# 991
template< class _Pair> using __is_cons = is_constructible< value_type, _Pair &&> ; 
# 994
template< class _Pair> using _IFcons = enable_if< __is_cons< _Pair> ::value> ; 
# 997
template< class _Pair> using _IFconsp = typename enable_if< __is_cons< _Pair> ::value> ::type; 
# 1000
template< class _Pair, class  = _IFconsp< _Pair> > __ireturn_type 
# 1002
insert(_Pair &&__v) 
# 1003
{ 
# 1004
__hashtable &__h = this->_M_conjure_hashtable(); 
# 1005
return __h._M_emplace(__unique_keys(), std::forward< _Pair> (__v)); 
# 1006
} 
# 1008
template< class _Pair, class  = _IFconsp< _Pair> > iterator 
# 1010
insert(const_iterator __hint, _Pair &&__v) 
# 1011
{ 
# 1012
__hashtable &__h = this->_M_conjure_hashtable(); 
# 1013
return __h._M_emplace(__hint, __unique_keys(), std::forward< _Pair> (__v)); 
# 1015
} 
# 1016
}; 
# 1018
template< class _Policy> using __has_load_factor = typename _Policy::__has_load_factor; 
# 1027
template< class _Key, class _Value, class _Alloc, class 
# 1028
_ExtractKey, class _Equal, class 
# 1029
_H1, class _H2, class _Hash, class 
# 1030
_RehashPolicy, class _Traits, class 
# 1031
 = __detected_or_t< integral_constant< bool, false> , __has_load_factor, _RehashPolicy> > struct _Rehash_base; 
# 1036
template< class _Key, class _Value, class _Alloc, class 
# 1037
_ExtractKey, class _Equal, class 
# 1038
_H1, class _H2, class _Hash, class 
# 1039
_RehashPolicy, class _Traits> 
# 1040
struct _Rehash_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, integral_constant< bool, false> >  { 
# 1044
}; 
# 1047
template< class _Key, class _Value, class _Alloc, class 
# 1048
_ExtractKey, class _Equal, class 
# 1049
_H1, class _H2, class _Hash, class 
# 1050
_RehashPolicy, class _Traits> 
# 1051
struct _Rehash_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, integral_constant< bool, true> >  { 
# 1055
using __hashtable = _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 1060
float max_load_factor() const noexcept 
# 1061
{ 
# 1062
const __hashtable *__this = static_cast< const __hashtable *>(this); 
# 1063
return __this->__rehash_policy().max_load_factor(); 
# 1064
} 
# 1067
void max_load_factor(float __z) 
# 1068
{ 
# 1069
__hashtable *__this = static_cast< __hashtable *>(this); 
# 1070
__this->__rehash_policy((_RehashPolicy)__z); 
# 1071
} 
# 1074
void reserve(size_t __n) 
# 1075
{ 
# 1076
__hashtable *__this = static_cast< __hashtable *>(this); 
# 1077
__this->rehash(__builtin_ceil(__n / max_load_factor())); 
# 1078
} 
# 1079
}; 
# 1087
template< int _Nm, class _Tp, bool 
# 1088
__use_ebo = (!__is_final(_Tp)) && __is_empty(_Tp)> struct _Hashtable_ebo_helper; 
# 1092
template< int _Nm, class _Tp> 
# 1093
struct _Hashtable_ebo_helper< _Nm, _Tp, true>  : private _Tp { 
# 1096
_Hashtable_ebo_helper() = default;
# 1098
template< class _OtherTp> 
# 1099
_Hashtable_ebo_helper(_OtherTp &&__tp) : _Tp(std::forward< _OtherTp> (__tp)) 
# 1101
{ } 
# 1104
static const _Tp &_S_cget(const __detail::_Hashtable_ebo_helper< _Nm, _Tp, true>  &__eboh) 
# 1105
{ return static_cast< const _Tp &>(__eboh); } 
# 1108
static _Tp &_S_get(__detail::_Hashtable_ebo_helper< _Nm, _Tp, true>  &__eboh) 
# 1109
{ return static_cast< _Tp &>(__eboh); } 
# 1110
}; 
# 1113
template< int _Nm, class _Tp> 
# 1114
struct _Hashtable_ebo_helper< _Nm, _Tp, false>  { 
# 1116
_Hashtable_ebo_helper() = default;
# 1118
template< class _OtherTp> 
# 1119
_Hashtable_ebo_helper(_OtherTp &&__tp) : _M_tp(std::forward< _OtherTp> (__tp)) 
# 1121
{ } 
# 1124
static const _Tp &_S_cget(const __detail::_Hashtable_ebo_helper< _Nm, _Tp, false>  &__eboh) 
# 1125
{ return __eboh._M_tp; } 
# 1128
static _Tp &_S_get(__detail::_Hashtable_ebo_helper< _Nm, _Tp, false>  &__eboh) 
# 1129
{ return __eboh._M_tp; } 
# 1132
private: _Tp _M_tp; 
# 1133
}; 
# 1141
template< class _Key, class _Value, class _ExtractKey, class 
# 1142
_H1, class _H2, class _Hash, bool 
# 1143
__cache_hash_code> struct _Local_iterator_base; 
# 1166 "/usr/include/c++/9/bits/hashtable_policy.h" 3
template< class _Key, class _Value, class _ExtractKey, class 
# 1167
_H1, class _H2, class _Hash, bool 
# 1168
__cache_hash_code> struct _Hash_code_base; 
# 1173
template< class _Key, class _Value, class _ExtractKey, class 
# 1174
_H1, class _H2, class _Hash> 
# 1175
struct _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  : private _Hashtable_ebo_helper< 0, _ExtractKey> , private _Hashtable_ebo_helper< 1, _Hash>  { 
# 1180
private: using __ebo_extract_key = _Hashtable_ebo_helper< 0, _ExtractKey> ; 
# 1181
using __ebo_hash = _Hashtable_ebo_helper< 1, _Hash> ; 
# 1184
protected: typedef void *__hash_code; 
# 1185
typedef _Hash_node< _Value, false>  __node_type; 
# 1189
_Hash_code_base() = default;
# 1191
_Hash_code_base(const _ExtractKey &__ex, const _H1 &, const _H2 &, const _Hash &
# 1192
__h) : __ebo_extract_key(__ex), __ebo_hash(__h) 
# 1193
{ } 
# 1196
__hash_code _M_hash_code(const _Key &__key) const 
# 1197
{ return 0; } 
# 1200
std::size_t _M_bucket_index(const _Key &__k, __hash_code, std::size_t __n) const 
# 1201
{ return _M_ranged_hash()(__k, __n); } 
# 1204
std::size_t _M_bucket_index(const __node_type *__p, std::size_t __n) const noexcept(noexcept(declval< const _Hash &> ()(declval< const _Key &> (), (std::size_t)0))) 
# 1207
{ return _M_ranged_hash()(_M_extract()(__p->_M_v()), __n); } 
# 1210
void _M_store_code(__node_type *, __hash_code) const 
# 1211
{ } 
# 1214
void _M_copy_code(__node_type *, const __node_type *) const 
# 1215
{ } 
# 1218
void _M_swap(__detail::_Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  &__x) 
# 1219
{ 
# 1220
std::swap(_M_extract(), __x._M_extract()); 
# 1221
std::swap(_M_ranged_hash(), __x._M_ranged_hash()); 
# 1222
} 
# 1225
const _ExtractKey &_M_extract() const { return __ebo_extract_key::_S_cget(*this); } 
# 1228
_ExtractKey &_M_extract() { return __ebo_extract_key::_S_get(*this); } 
# 1231
const _Hash &_M_ranged_hash() const { return __ebo_hash::_S_cget(*this); } 
# 1234
_Hash &_M_ranged_hash() { return __ebo_hash::_S_get(*this); } 
# 1235
}; 
# 1243
template< class _Key, class _Value, class _ExtractKey, class 
# 1244
_H1, class _H2, class _Hash> struct _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, true> ; 
# 1250
template< class _Key, class _Value, class _ExtractKey, class 
# 1251
_H1, class _H2> 
# 1252
struct _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, false>  : private _Hashtable_ebo_helper< 0, _ExtractKey> , private _Hashtable_ebo_helper< 1, _H1> , private _Hashtable_ebo_helper< 2, _H2>  { 
# 1259
private: using __ebo_extract_key = _Hashtable_ebo_helper< 0, _ExtractKey> ; 
# 1260
using __ebo_h1 = _Hashtable_ebo_helper< 1, _H1> ; 
# 1261
using __ebo_h2 = _Hashtable_ebo_helper< 2, _H2> ; 
# 1264
friend struct _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, __detail::_Default_ranged_hash, false> ; 
# 1268
public: typedef _H1 hasher; 
# 1271
hasher hash_function() const 
# 1272
{ return _M_h1(); } 
# 1275
protected: typedef std::size_t __hash_code; 
# 1276
typedef _Hash_node< _Value, false>  __node_type; 
# 1280
_Hash_code_base() = default;
# 1282
_Hash_code_base(const _ExtractKey &__ex, const _H1 &
# 1283
__h1, const _H2 &__h2, const __detail::_Default_ranged_hash &) : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) 
# 1285
{ } 
# 1288
__hash_code _M_hash_code(const _Key &__k) const 
# 1289
{ 
# 1290
static_assert((__is_invocable< const _H1 &, const _Key &> {}), "hash function must be invocable with an argument of key type");
# 1292
return _M_h1()(__k); 
# 1293
} 
# 1296
std::size_t _M_bucket_index(const _Key &, __hash_code __c, std::size_t __n) const 
# 1297
{ return _M_h2()(__c, __n); } 
# 1300
std::size_t _M_bucket_index(const __node_type *__p, std::size_t __n) const noexcept(noexcept(declval< const _H1 &> ()(declval< const _Key &> ())) && noexcept(declval< const _H2 &> ()((__hash_code)0, (std::size_t)0))) 
# 1304
{ return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __n); } 
# 1307
void _M_store_code(__node_type *, __hash_code) const 
# 1308
{ } 
# 1311
void _M_copy_code(__node_type *, const __node_type *) const 
# 1312
{ } 
# 1315
void _M_swap(__detail::_Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, __detail::_Default_ranged_hash, false>  &__x) 
# 1316
{ 
# 1317
std::swap(_M_extract(), __x._M_extract()); 
# 1318
std::swap(_M_h1(), __x._M_h1()); 
# 1319
std::swap(_M_h2(), __x._M_h2()); 
# 1320
} 
# 1323
const _ExtractKey &_M_extract() const { return __ebo_extract_key::_S_cget(*this); } 
# 1326
_ExtractKey &_M_extract() { return __ebo_extract_key::_S_get(*this); } 
# 1329
const _H1 &_M_h1() const { return __ebo_h1::_S_cget(*this); } 
# 1332
_H1 &_M_h1() { return __ebo_h1::_S_get(*this); } 
# 1335
const _H2 &_M_h2() const { return __ebo_h2::_S_cget(*this); } 
# 1338
_H2 &_M_h2() { return __ebo_h2::_S_get(*this); } 
# 1339
}; 
# 1344
template< class _Key, class _Value, class _ExtractKey, class 
# 1345
_H1, class _H2> 
# 1346
struct _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, true>  : private _Hashtable_ebo_helper< 0, _ExtractKey> , private _Hashtable_ebo_helper< 1, _H1> , private _Hashtable_ebo_helper< 2, _H2>  { 
# 1354
friend struct _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, __detail::_Default_ranged_hash, true> ; 
# 1357
private: using __ebo_extract_key = _Hashtable_ebo_helper< 0, _ExtractKey> ; 
# 1358
using __ebo_h1 = _Hashtable_ebo_helper< 1, _H1> ; 
# 1359
using __ebo_h2 = _Hashtable_ebo_helper< 2, _H2> ; 
# 1362
public: typedef _H1 hasher; 
# 1365
hasher hash_function() const 
# 1366
{ return _M_h1(); } 
# 1369
protected: typedef std::size_t __hash_code; 
# 1370
typedef _Hash_node< _Value, true>  __node_type; 
# 1373
_Hash_code_base() = default;
# 1374
_Hash_code_base(const _ExtractKey &__ex, const _H1 &
# 1375
__h1, const _H2 &__h2, const __detail::_Default_ranged_hash &) : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) 
# 1377
{ } 
# 1380
__hash_code _M_hash_code(const _Key &__k) const 
# 1381
{ 
# 1382
static_assert((__is_invocable< const _H1 &, const _Key &> {}), "hash function must be invocable with an argument of key type");
# 1384
return _M_h1()(__k); 
# 1385
} 
# 1388
std::size_t _M_bucket_index(const _Key &, __hash_code __c, std::size_t 
# 1389
__n) const 
# 1390
{ return _M_h2()(__c, __n); } 
# 1393
std::size_t _M_bucket_index(const __node_type *__p, std::size_t __n) const noexcept(noexcept(declval< const _H2 &> ()((__hash_code)0, (std::size_t)0))) 
# 1396
{ return _M_h2()((__p->_M_hash_code), __n); } 
# 1399
void _M_store_code(__node_type *__n, __hash_code __c) const 
# 1400
{ (__n->_M_hash_code) = __c; } 
# 1403
void _M_copy_code(__node_type *__to, const __node_type *__from) const 
# 1404
{ (__to->_M_hash_code) = (__from->_M_hash_code); } 
# 1407
void _M_swap(__detail::_Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, __detail::_Default_ranged_hash, true>  &__x) 
# 1408
{ 
# 1409
std::swap(_M_extract(), __x._M_extract()); 
# 1410
std::swap(_M_h1(), __x._M_h1()); 
# 1411
std::swap(_M_h2(), __x._M_h2()); 
# 1412
} 
# 1415
const _ExtractKey &_M_extract() const { return __ebo_extract_key::_S_cget(*this); } 
# 1418
_ExtractKey &_M_extract() { return __ebo_extract_key::_S_get(*this); } 
# 1421
const _H1 &_M_h1() const { return __ebo_h1::_S_cget(*this); } 
# 1424
_H1 &_M_h1() { return __ebo_h1::_S_get(*this); } 
# 1427
const _H2 &_M_h2() const { return __ebo_h2::_S_cget(*this); } 
# 1430
_H2 &_M_h2() { return __ebo_h2::_S_get(*this); } 
# 1431
}; 
# 1437
template< class _Key, class _Value, class _ExtractKey, class 
# 1438
_Equal, class _HashCodeType, bool 
# 1439
__cache_hash_code> struct _Equal_helper; 
# 1443
template< class _Key, class _Value, class _ExtractKey, class 
# 1444
_Equal, class _HashCodeType> 
# 1445
struct _Equal_helper< _Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>  { 
# 1448
static bool _S_equals(const _Equal &__eq, const _ExtractKey &__extract, const _Key &
# 1449
__k, _HashCodeType __c, _Hash_node< _Value, true>  *__n) 
# 1450
{ return (__c == (__n->_M_hash_code)) && __eq(__k, __extract(__n->_M_v())); } 
# 1451
}; 
# 1454
template< class _Key, class _Value, class _ExtractKey, class 
# 1455
_Equal, class _HashCodeType> 
# 1456
struct _Equal_helper< _Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>  { 
# 1459
static bool _S_equals(const _Equal &__eq, const _ExtractKey &__extract, const _Key &
# 1460
__k, _HashCodeType, _Hash_node< _Value, false>  *__n) 
# 1461
{ return __eq(__k, __extract(__n->_M_v())); } 
# 1462
}; 
# 1466
template< class _Key, class _Value, class _ExtractKey, class 
# 1467
_H1, class _H2, class _Hash> 
# 1468
struct _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>  : private _Hashtable_ebo_helper< 0, _H2>  { 
# 1473
protected: using __base_type = _Hashtable_ebo_helper< 0, _H2> ; 
# 1474
using __hash_code_base = _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, true> ; 
# 1477
_Local_iterator_base() = default;
# 1478
_Local_iterator_base(const __hash_code_base &__base, _Hash_node< _Value, true>  *
# 1479
__p, std::size_t 
# 1480
__bkt, std::size_t __bkt_count) : __base_type(__base._M_h2()), _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) 
# 1482
{ } 
# 1485
void _M_incr() 
# 1486
{ 
# 1487
(_M_cur) = (_M_cur)->_M_next(); 
# 1488
if (_M_cur) 
# 1489
{ 
# 1490
std::size_t __bkt = __base_type::_S_get(*this)(((_M_cur)->_M_hash_code), _M_bucket_count); 
# 1493
if (__bkt != (_M_bucket)) { 
# 1494
(_M_cur) = nullptr; }  
# 1495
}  
# 1496
} 
# 1498
_Hash_node< _Value, true>  *_M_cur; 
# 1499
std::size_t _M_bucket; 
# 1500
std::size_t _M_bucket_count; 
# 1504
public: const void *_M_curr() const { return _M_cur; } 
# 1507
std::size_t _M_get_bucket() const { return _M_bucket; } 
# 1508
}; 
# 1514
template< class _Tp, bool _IsEmpty = std::template is_empty< _Tp> ::value> 
# 1515
struct _Hash_code_storage { 
# 1517
__gnu_cxx::__aligned_buffer< _Tp>  _M_storage; 
# 1520
_Tp *_M_h() { return (_M_storage)._M_ptr(); } 
# 1523
const _Tp *_M_h() const { return (_M_storage)._M_ptr(); } 
# 1524
}; 
# 1527
template< class _Tp> 
# 1528
struct _Hash_code_storage< _Tp, true>  { 
# 1530
static_assert((std::template is_empty< _Tp> ::value), "Type must be empty");
# 1535
_Tp *_M_h() { return reinterpret_cast< _Tp *>(this); } 
# 1538
const _Tp *_M_h() const { return reinterpret_cast< const _Tp *>(this); } 
# 1539
}; 
# 1541
template< class _Key, class _Value, class _ExtractKey, class 
# 1542
_H1, class _H2, class _Hash> using __hash_code_for_local_iter = _Hash_code_storage< _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> > ; 
# 1548
template< class _Key, class _Value, class _ExtractKey, class 
# 1549
_H1, class _H2, class _Hash> 
# 1550
struct _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  : public __hash_code_for_local_iter< _Key, _Value, _ExtractKey, _H1, _H2, _Hash>  { 
# 1555
protected: using __hash_code_base = _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> ; 
# 1558
_Local_iterator_base() : _M_bucket_count((-1)) { } 
# 1560
_Local_iterator_base(const __hash_code_base &__base, _Hash_node< _Value, false>  *
# 1561
__p, std::size_t 
# 1562
__bkt, std::size_t __bkt_count) : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) 
# 1564
{ _M_init(__base); } 
# 1566
~_Local_iterator_base() 
# 1567
{ 
# 1568
if ((_M_bucket_count) != (-1)) { 
# 1569
_M_destroy(); }  
# 1570
} 
# 1572
_Local_iterator_base(const __detail::_Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  &__iter) : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket), _M_bucket_count(__iter._M_bucket_count) 
# 1575
{ 
# 1576
if ((_M_bucket_count) != (-1)) { 
# 1577
_M_init(*__iter._M_h()); }  
# 1578
} 
# 1581
__detail::_Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  &operator=(const __detail::_Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>  &__iter) 
# 1582
{ 
# 1583
if ((_M_bucket_count) != (-1)) { 
# 1584
_M_destroy(); }  
# 1585
(_M_cur) = (__iter._M_cur); 
# 1586
(_M_bucket) = (__iter._M_bucket); 
# 1587
(_M_bucket_count) = (__iter._M_bucket_count); 
# 1588
if ((_M_bucket_count) != (-1)) { 
# 1589
_M_init(*__iter._M_h()); }  
# 1590
return *this; 
# 1591
} 
# 1594
void _M_incr() 
# 1595
{ 
# 1596
(_M_cur) = (_M_cur)->_M_next(); 
# 1597
if (_M_cur) 
# 1598
{ 
# 1599
std::size_t __bkt = this->_M_h()->_M_bucket_index(_M_cur, _M_bucket_count); 
# 1601
if (__bkt != (_M_bucket)) { 
# 1602
(_M_cur) = nullptr; }  
# 1603
}  
# 1604
} 
# 1606
_Hash_node< _Value, false>  *_M_cur; 
# 1607
std::size_t _M_bucket; 
# 1608
std::size_t _M_bucket_count; 
# 1611
void _M_init(const __hash_code_base &__base) 
# 1612
{ ::new (this->_M_h()) __hash_code_base(__base); } 
# 1615
void _M_destroy() { this->_M_h()->~__hash_code_base(); } 
# 1619
public: const void *_M_curr() const { return _M_cur; } 
# 1622
std::size_t _M_get_bucket() const { return _M_bucket; } 
# 1623
}; 
# 1625
template< class _Key, class _Value, class _ExtractKey, class 
# 1626
_H1, class _H2, class _Hash, bool __cache> inline bool 
# 1628
operator==(const _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  &
# 1629
__x, const _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  &
# 1631
__y) 
# 1632
{ return __x._M_curr() == __y._M_curr(); } 
# 1634
template< class _Key, class _Value, class _ExtractKey, class 
# 1635
_H1, class _H2, class _Hash, bool __cache> inline bool 
# 1637
operator!=(const _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  &
# 1638
__x, const _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  &
# 1640
__y) 
# 1641
{ return __x._M_curr() != __y._M_curr(); } 
# 1644
template< class _Key, class _Value, class _ExtractKey, class 
# 1645
_H1, class _H2, class _Hash, bool 
# 1646
__constant_iterators, bool __cache> 
# 1647
struct _Local_iterator : public _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  { 
# 1652
private: using __base_type = _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> ; 
# 1654
using __hash_code_base = typename _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> ::__hash_code_base; 
# 1656
public: typedef _Value value_type; 
# 1659
typedef typename conditional< __constant_iterators, const _Value *, _Value *> ::type pointer; 
# 1662
typedef typename conditional< __constant_iterators, const _Value &, _Value &> ::type reference; 
# 1663
typedef std::ptrdiff_t difference_type; 
# 1664
typedef std::forward_iterator_tag iterator_category; 
# 1666
_Local_iterator() = default;
# 1668
_Local_iterator(const __hash_code_base &__base, _Hash_node< _Value, __cache>  *
# 1669
__p, std::size_t 
# 1670
__bkt, std::size_t __bkt_count) : __base_type(__base, __p, __bkt, __bkt_count) 
# 1672
{ } 
# 1675
reference operator*() const 
# 1676
{ return (this->_M_cur)->_M_v(); } 
# 1679
pointer operator->() const 
# 1680
{ return (this->_M_cur)->_M_valptr(); } 
# 1683
_Local_iterator &operator++() 
# 1684
{ 
# 1685
this->_M_incr(); 
# 1686
return *this; 
# 1687
} 
# 1690
_Local_iterator operator++(int) 
# 1691
{ 
# 1692
_Local_iterator __tmp(*this); 
# 1693
this->_M_incr(); 
# 1694
return __tmp; 
# 1695
} 
# 1696
}; 
# 1699
template< class _Key, class _Value, class _ExtractKey, class 
# 1700
_H1, class _H2, class _Hash, bool 
# 1701
__constant_iterators, bool __cache> 
# 1702
struct _Local_const_iterator : public _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>  { 
# 1707
private: using __base_type = _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> ; 
# 1709
using __hash_code_base = typename _Local_iterator_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> ::__hash_code_base; 
# 1712
public: typedef _Value value_type; 
# 1713
typedef const _Value *pointer; 
# 1714
typedef const _Value &reference; 
# 1715
typedef std::ptrdiff_t difference_type; 
# 1716
typedef std::forward_iterator_tag iterator_category; 
# 1718
_Local_const_iterator() = default;
# 1720
_Local_const_iterator(const __hash_code_base &__base, _Hash_node< _Value, __cache>  *
# 1721
__p, std::size_t 
# 1722
__bkt, std::size_t __bkt_count) : __base_type(__base, __p, __bkt, __bkt_count) 
# 1724
{ } 
# 1726
_Local_const_iterator(const _Local_iterator< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>  &
# 1729
__x) : __base_type(__x) 
# 1731
{ } 
# 1734
reference operator*() const 
# 1735
{ return (this->_M_cur)->_M_v(); } 
# 1738
pointer operator->() const 
# 1739
{ return (this->_M_cur)->_M_valptr(); } 
# 1742
_Local_const_iterator &operator++() 
# 1743
{ 
# 1744
this->_M_incr(); 
# 1745
return *this; 
# 1746
} 
# 1749
_Local_const_iterator operator++(int) 
# 1750
{ 
# 1751
_Local_const_iterator __tmp(*this); 
# 1752
this->_M_incr(); 
# 1753
return __tmp; 
# 1754
} 
# 1755
}; 
# 1767 "/usr/include/c++/9/bits/hashtable_policy.h" 3
template< class _Key, class _Value, class 
# 1768
_ExtractKey, class _Equal, class 
# 1769
_H1, class _H2, class _Hash, class _Traits> 
# 1770
struct _Hashtable_base : public _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> , private _Hashtable_ebo_helper< 0, _Equal>  { 
# 1776
typedef _Key key_type; 
# 1777
typedef _Value value_type; 
# 1778
typedef _Equal key_equal; 
# 1779
typedef std::size_t size_type; 
# 1780
typedef std::ptrdiff_t difference_type; 
# 1782
using __traits_type = _Traits; 
# 1783
using __hash_cached = typename _Traits::__hash_cached; 
# 1784
using __constant_iterators = typename _Traits::__constant_iterators; 
# 1785
using __unique_keys = typename _Traits::__unique_keys; 
# 1787
using __hash_code_base = _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> ; 
# 1791
using __hash_code = typename _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> ::__hash_code; 
# 1792
using __node_type = typename _Hash_code_base< _Key, _Value, _ExtractKey, _H1, _H2, _Hash, _Traits::__hash_cached::value> ::__node_type; 
# 1794
using iterator = _Node_iterator< value_type, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> ; 
# 1798
using const_iterator = _Node_const_iterator< value_type, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> ; 
# 1802
using local_iterator = _Local_iterator< key_type, value_type, _ExtractKey, _H1, _H2, _Hash, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> ; 
# 1807
using const_local_iterator = _Local_const_iterator< key_type, value_type, _ExtractKey, _H1, _H2, _Hash, _Traits::__constant_iterators::value, _Traits::__hash_cached::value> ; 
# 1813
using __ireturn_type = typename conditional< _Traits::__unique_keys::value, pair< iterator, bool> , iterator> ::type; 
# 1817
private: using _EqualEBO = _Hashtable_ebo_helper< 0, _Equal> ; 
# 1818
using _EqualHelper = _Equal_helper< _Key, _Value, _ExtractKey, _Equal, __hash_code, _Traits::__hash_cached::value> ; 
# 1822
protected: _Hashtable_base() = default;
# 1823
_Hashtable_base(const _ExtractKey &__ex, const _H1 &__h1, const _H2 &__h2, const _Hash &
# 1824
__hash, const _Equal &__eq) : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq) 
# 1826
{ } 
# 1829
bool _M_equals(const _Key &__k, __hash_code __c, __node_type *__n) const 
# 1830
{ 
# 1831
static_assert((__is_invocable< const _Equal &, const _Key &, const _Key &> {}), "key equality predicate must be invocable with two arguments of key type");
# 1834
return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(), __k, __c, __n); 
# 1836
} 
# 1839
void _M_swap(_Hashtable_base &__x) 
# 1840
{ 
# 1841
__hash_code_base::_M_swap(__x); 
# 1842
std::swap(_M_eq(), __x._M_eq()); 
# 1843
} 
# 1846
const _Equal &_M_eq() const { return _EqualEBO::_S_cget(*this); } 
# 1849
_Equal &_M_eq() { return _EqualEBO::_S_get(*this); } 
# 1850
}; 
# 1857
struct _Equality_base { 
# 1860
protected: template< class _Uiterator> static bool _S_is_permutation(_Uiterator, _Uiterator, _Uiterator); 
# 1863
}; 
# 1866
template< class _Uiterator> bool 
# 1869
_Equality_base::_S_is_permutation(_Uiterator __first1, _Uiterator __last1, _Uiterator 
# 1870
__first2) 
# 1871
{ 
# 1872
for (; __first1 != __last1; (++__first1), (++__first2)) { 
# 1873
if (!((*__first1) == (*__first2))) { 
# 1874
break; }  }  
# 1876
if (__first1 == __last1) { 
# 1877
return true; }  
# 1879
_Uiterator __last2 = __first2; 
# 1880
std::advance(__last2, std::distance(__first1, __last1)); 
# 1882
for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1) 
# 1883
{ 
# 1884
_Uiterator __tmp = __first1; 
# 1885
while ((__tmp != __it1) && (!((bool)((*__tmp) == (*__it1))))) { 
# 1886
++__tmp; }  
# 1889
if (__tmp != __it1) { 
# 1890
continue; }  
# 1892
ptrdiff_t __n2 = (0); 
# 1893
for (__tmp = __first2; __tmp != __last2; ++__tmp) { 
# 1894
if ((*__tmp) == (*__it1)) { 
# 1895
++__n2; }  }  
# 1897
if (!__n2) { 
# 1898
return false; }  
# 1900
ptrdiff_t __n1 = (0); 
# 1901
for (__tmp = __it1; __tmp != __last1; ++__tmp) { 
# 1902
if ((*__tmp) == (*__it1)) { 
# 1903
++__n1; }  }  
# 1905
if (__n1 != __n2) { 
# 1906
return false; }  
# 1907
}   
# 1908
return true; 
# 1909
} 
# 1919 "/usr/include/c++/9/bits/hashtable_policy.h" 3
template< class _Key, class _Value, class _Alloc, class 
# 1920
_ExtractKey, class _Equal, class 
# 1921
_H1, class _H2, class _Hash, class 
# 1922
_RehashPolicy, class _Traits, bool 
# 1923
_Unique_keys = _Traits::__unique_keys::value> struct _Equality; 
# 1927
template< class _Key, class _Value, class _Alloc, class 
# 1928
_ExtractKey, class _Equal, class 
# 1929
_H1, class _H2, class _Hash, class 
# 1930
_RehashPolicy, class _Traits> 
# 1931
struct _Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>  { 
# 1934
using __hashtable = _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 1938
bool _M_equal(const __hashtable &) const; 
# 1939
}; 
# 1941
template< class _Key, class _Value, class _Alloc, class 
# 1942
_ExtractKey, class _Equal, class 
# 1943
_H1, class _H2, class _Hash, class 
# 1944
_RehashPolicy, class _Traits> bool 
# 1948
_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> ::_M_equal(const __hashtable &__other) const 
# 1949
{ 
# 1950
const __hashtable *__this = static_cast< const __hashtable *>(this); 
# 1952
if (__this->size() != __other.size()) { 
# 1953
return false; }  
# 1955
for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx) 
# 1956
{ 
# 1957
const auto __ity = __other.find(_ExtractKey()(*__itx)); 
# 1958
if ((__ity == __other.end()) || (!((bool)((*__ity) == (*__itx))))) { 
# 1959
return false; }  
# 1960
}  
# 1961
return true; 
# 1962
} 
# 1965
template< class _Key, class _Value, class _Alloc, class 
# 1966
_ExtractKey, class _Equal, class 
# 1967
_H1, class _H2, class _Hash, class 
# 1968
_RehashPolicy, class _Traits> 
# 1969
struct _Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>  : public _Equality_base { 
# 1973
using __hashtable = _Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 1977
bool _M_equal(const __hashtable &) const; 
# 1978
}; 
# 1980
template< class _Key, class _Value, class _Alloc, class 
# 1981
_ExtractKey, class _Equal, class 
# 1982
_H1, class _H2, class _Hash, class 
# 1983
_RehashPolicy, class _Traits> bool 
# 1987
_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false> ::_M_equal(const __hashtable &__other) const 
# 1988
{ 
# 1989
const __hashtable *__this = static_cast< const __hashtable *>(this); 
# 1991
if (__this->size() != __other.size()) { 
# 1992
return false; }  
# 1994
for (auto __itx = __this->begin(); __itx != __this->end();) 
# 1995
{ 
# 1996
const auto __xrange = __this->equal_range(_ExtractKey()(*__itx)); 
# 1997
const auto __yrange = __other.equal_range(_ExtractKey()(*__itx)); 
# 1999
if (std::distance((__xrange.first), (__xrange.second)) != std::distance((__yrange.first), (__yrange.second))) { 
# 2001
return false; }  
# 2003
if (!_S_is_permutation((__xrange.first), (__xrange.second), (__yrange.first))) { 
# 2005
return false; }  
# 2007
__itx = (__xrange.second); 
# 2008
}  
# 2009
return true; 
# 2010
} 
# 2016
template< class _NodeAlloc> 
# 2017
struct _Hashtable_alloc : private _Hashtable_ebo_helper< 0, _NodeAlloc>  { 
# 2020
private: using __ebo_node_alloc = _Hashtable_ebo_helper< 0, _NodeAlloc> ; 
# 2022
public: using __node_type = typename _NodeAlloc::value_type; 
# 2023
using __node_alloc_type = _NodeAlloc; 
# 2025
using __node_alloc_traits = __gnu_cxx::__alloc_traits< __node_alloc_type> ; 
# 2027
using __value_alloc_traits = typename __gnu_cxx::__alloc_traits< __node_alloc_type> ::template rebind_traits< typename _NodeAlloc::value_type::value_type> ; 
# 2030
using __node_base = __detail::_Hash_node_base; 
# 2031
using __bucket_type = __node_base *; 
# 2032
using __bucket_alloc_type = std::__alloc_rebind< __node_alloc_type, __detail::_Hash_node_base *> ; 
# 2034
using __bucket_alloc_traits = allocator_traits< __bucket_alloc_type> ; 
# 2036
_Hashtable_alloc() = default;
# 2037
_Hashtable_alloc(const _Hashtable_alloc &) = default;
# 2038
_Hashtable_alloc(_Hashtable_alloc &&) = default;
# 2040
template< class _Alloc> 
# 2041
_Hashtable_alloc(_Alloc &&__a) : __ebo_node_alloc(std::forward< _Alloc> (__a)) 
# 2043
{ } 
# 2046
__node_alloc_type &_M_node_allocator() 
# 2047
{ return __ebo_node_alloc::_S_get(*this); } 
# 2050
const __node_alloc_type &_M_node_allocator() const 
# 2051
{ return __ebo_node_alloc::_S_cget(*this); } 
# 2053
template< class ..._Args> __node_type *_M_allocate_node(_Args && ...__args); 
# 2058
void _M_deallocate_node(__node_type * __n); 
# 2061
void _M_deallocate_node_ptr(__node_type * __n); 
# 2065
void _M_deallocate_nodes(__node_type * __n); 
# 2068
__bucket_type *_M_allocate_buckets(std::size_t __n); 
# 2071
void _M_deallocate_buckets(__bucket_type *, std::size_t __n); 
# 2072
}; 
# 2076
template< class _NodeAlloc> 
# 2077
template< class ..._Args> typename _Hashtable_alloc< _NodeAlloc> ::__node_type *
# 2079
_Hashtable_alloc< _NodeAlloc> ::_M_allocate_node(_Args &&...__args) 
# 2080
{ 
# 2081
auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1); 
# 2082
__node_type *__n = std::__to_address(__nptr); 
# 2083
try 
# 2084
{ 
# 2085
::new ((void *)__n) __node_type; 
# 2086
__node_alloc_traits::construct(_M_node_allocator(), __n->_M_valptr(), std::forward< _Args> (__args)...); 
# 2089
return __n; 
# 2090
} 
# 2091
catch (...) 
# 2092
{ 
# 2093
__node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1); 
# 2094
throw; 
# 2095
}  
# 2096
} 
# 2098
template< class _NodeAlloc> void 
# 2100
_Hashtable_alloc< _NodeAlloc> ::_M_deallocate_node(__node_type *__n) 
# 2101
{ 
# 2102
__node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr()); 
# 2103
_M_deallocate_node_ptr(__n); 
# 2104
} 
# 2106
template< class _NodeAlloc> void 
# 2108
_Hashtable_alloc< _NodeAlloc> ::_M_deallocate_node_ptr(__node_type *__n) 
# 2109
{ 
# 2110
typedef typename __gnu_cxx::__alloc_traits< __node_alloc_type> ::pointer _Ptr; 
# 2111
auto __ptr = std::template pointer_traits< typename __gnu_cxx::__alloc_traits< __node_alloc_type> ::pointer> ::pointer_to(*__n); 
# 2112
__n->~__node_type(); 
# 2113
__node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1); 
# 2114
} 
# 2116
template< class _NodeAlloc> void 
# 2118
_Hashtable_alloc< _NodeAlloc> ::_M_deallocate_nodes(__node_type *__n) 
# 2119
{ 
# 2120
while (__n) 
# 2121
{ 
# 2122
__node_type *__tmp = __n; 
# 2123
__n = __n->_M_next(); 
# 2124
_M_deallocate_node(__tmp); 
# 2125
}  
# 2126
} 
# 2128
template< class _NodeAlloc> typename _Hashtable_alloc< _NodeAlloc> ::__bucket_type *
# 2130
_Hashtable_alloc< _NodeAlloc> ::_M_allocate_buckets(std::size_t __n) 
# 2131
{ 
# 2132
__bucket_alloc_type __alloc(_M_node_allocator()); 
# 2134
auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n); 
# 2135
__bucket_type *__p = std::__to_address(__ptr); 
# 2136
__builtin_memset(__p, 0, __n * sizeof(__bucket_type)); 
# 2137
return __p; 
# 2138
} 
# 2140
template< class _NodeAlloc> void 
# 2142
_Hashtable_alloc< _NodeAlloc> ::_M_deallocate_buckets(__bucket_type *__bkts, std::size_t 
# 2143
__n) 
# 2144
{ 
# 2145
typedef typename allocator_traits< __bucket_alloc_type> ::pointer _Ptr; 
# 2146
auto __ptr = std::template pointer_traits< typename allocator_traits< __bucket_alloc_type> ::pointer> ::pointer_to(*__bkts); 
# 2147
__bucket_alloc_type __alloc(_M_node_allocator()); 
# 2148
__bucket_alloc_traits::deallocate(__alloc, __ptr, __n); 
# 2149
} 
# 2152
}
# 2154
}
# 40 "/usr/include/c++/9/bits/hashtable.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 44
template< class _Tp, class _Hash> using __cache_default = __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Tp &> > > ; 
# 169 "/usr/include/c++/9/bits/hashtable.h" 3
template< class _Key, class _Value, class _Alloc, class 
# 170
_ExtractKey, class _Equal, class 
# 171
_H1, class _H2, class _Hash, class 
# 172
_RehashPolicy, class _Traits> 
# 173
class _Hashtable : public __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> , public __detail::_Map_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> , public __detail::_Insert< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> , public __detail::_Rehash_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> , public __detail::_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> , private __detail::_Hashtable_alloc< __alloc_rebind< _Alloc, __detail::_Hash_node< _Value, _Traits::__hash_cached::value> > >  { 
# 189
static_assert((is_same< typename remove_cv< _Value> ::type, _Value> ::value), "unordered container must have a non-const, non-volatile value_type");
# 196
using __traits_type = _Traits; 
# 197
using __hash_cached = typename _Traits::__hash_cached; 
# 198
using __node_type = __detail::_Hash_node< _Value, _Traits::__hash_cached::value> ; 
# 199
using __node_alloc_type = std::__alloc_rebind< _Alloc, __node_type> ; 
# 201
using __hashtable_alloc = __detail::_Hashtable_alloc< __node_alloc_type> ; 
# 203
using __value_alloc_traits = typename __detail::_Hashtable_alloc< __node_alloc_type> ::__value_alloc_traits; 
# 205
using __node_alloc_traits = typename __detail::_Hashtable_alloc< __node_alloc_type> ::__node_alloc_traits; 
# 207
using __node_base = typename __detail::_Hashtable_alloc< __node_alloc_type> ::__node_base; 
# 208
using __bucket_type = typename __detail::_Hashtable_alloc< __node_alloc_type> ::__bucket_type; 
# 211
public: typedef _Key key_type; 
# 212
typedef _Value value_type; 
# 213
typedef _Alloc allocator_type; 
# 214
typedef _Equal key_equal; 
# 218
typedef typename __detail::_Hashtable_alloc< __node_alloc_type> ::__value_alloc_traits::pointer pointer; 
# 219
typedef typename __detail::_Hashtable_alloc< __node_alloc_type> ::__value_alloc_traits::const_pointer const_pointer; 
# 220
typedef value_type &reference; 
# 221
typedef const value_type &const_reference; 
# 224
private: using __rehash_type = _RehashPolicy; 
# 225
using __rehash_state = typename _RehashPolicy::_State; 
# 227
using __constant_iterators = typename _Traits::__constant_iterators; 
# 228
using __unique_keys = typename _Traits::__unique_keys; 
# 230
using __key_extract = typename conditional< _Traits::__constant_iterators::value, __detail::_Identity, __detail::_Select1st> ::type; 
# 235
using __hashtable_base = __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ; 
# 239
using __hash_code_base = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__hash_code_base; 
# 240
using __hash_code = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__hash_code; 
# 241
using __ireturn_type = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__ireturn_type; 
# 243
using __map_base = __detail::_Map_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 247
using __rehash_base = __detail::_Rehash_base< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 252
using __eq_base = __detail::_Equality< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ; 
# 256
using __reuse_or_alloc_node_type = __detail::_ReuseOrAllocNode< __node_alloc_type> ; 
# 260
template< class _Cond> using __if_hash_cached = __or_< __not_< __hash_cached> , _Cond> ; 
# 263
template< class _Cond> using __if_hash_not_cached = __or_< __hash_cached, _Cond> ; 
# 270
struct __hash_code_base_access : public __hash_code_base { 
# 271
using __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::__hash_code_base::_M_bucket_index;}; 
# 275
static_assert(noexcept(declval< const __hash_code_base_access &> ()._M_bucket_index((const __node_type *)nullptr, (std::size_t)0)), "Cache the hash code or qualify your functors involved in hash code and bucket index computation with noexcept");
# 286
static_assert((__if_hash_cached< is_default_constructible< _H2> > ::value), "Functor used to map hash code to bucket index must be default constructible");
# 290
template< class _Keya, class _Valuea, class _Alloca, class 
# 291
_ExtractKeya, class _Equala, class 
# 292
_H1a, class _H2a, class _Hasha, class 
# 293
_RehashPolicya, class _Traitsa, bool 
# 294
_Unique_keysa> friend struct __detail::_Map_base; 
# 297
template< class _Keya, class _Valuea, class _Alloca, class 
# 298
_ExtractKeya, class _Equala, class 
# 299
_H1a, class _H2a, class _Hasha, class 
# 300
_RehashPolicya, class _Traitsa> friend struct __detail::_Insert_base; 
# 303
template< class _Keya, class _Valuea, class _Alloca, class 
# 304
_ExtractKeya, class _Equala, class 
# 305
_H1a, class _H2a, class _Hasha, class 
# 306
_RehashPolicya, class _Traitsa, bool 
# 307
_Constant_iteratorsa> friend struct __detail::_Insert; 
# 311
public: using size_type = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::size_type; 
# 312
using difference_type = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::difference_type; 
# 314
using iterator = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::iterator; 
# 315
using const_iterator = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_iterator; 
# 317
using local_iterator = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::local_iterator; 
# 318
using const_local_iterator = typename __detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::const_local_iterator; 
# 327
private: __bucket_type *_M_buckets = (&(_M_single_bucket)); 
# 328
size_type _M_bucket_count = (1); 
# 329
__node_base _M_before_begin; 
# 330
size_type _M_element_count = (0); 
# 331
_RehashPolicy _M_rehash_policy; 
# 339
__bucket_type _M_single_bucket = (nullptr); 
# 342
bool _M_uses_single_bucket(__bucket_type *__bkts) const 
# 343
{ return __builtin_expect(__bkts == (&(_M_single_bucket)), false); } 
# 346
bool _M_uses_single_bucket() const 
# 347
{ return _M_uses_single_bucket(_M_buckets); } 
# 350
__hashtable_alloc &_M_base_alloc() { return *this; } 
# 353
__bucket_type *_M_allocate_buckets(size_type __n) 
# 354
{ 
# 355
if (__builtin_expect(__n == 1, false)) 
# 356
{ 
# 357
(_M_single_bucket) = nullptr; 
# 358
return &(_M_single_bucket); 
# 359
}  
# 361
return __hashtable_alloc::_M_allocate_buckets(__n); 
# 362
} 
# 365
void _M_deallocate_buckets(__bucket_type *__bkts, size_type __n) 
# 366
{ 
# 367
if (_M_uses_single_bucket(__bkts)) { 
# 368
return; }  
# 370
__hashtable_alloc::_M_deallocate_buckets(__bkts, __n); 
# 371
} 
# 374
void _M_deallocate_buckets() 
# 375
{ _M_deallocate_buckets(_M_buckets, _M_bucket_count); } 
# 380
__node_type *_M_bucket_begin(size_type __bkt) const; 
# 383
__node_type *_M_begin() const 
# 384
{ return static_cast< __node_type *>((_M_before_begin)._M_nxt); } 
# 388
template< class _Ht, class _NodeGenerator> void _M_assign_elements(_Ht &&, const _NodeGenerator &); 
# 392
template< class _NodeGenerator> void _M_assign(const _Hashtable &, const _NodeGenerator &); 
# 397
void _M_move_assign(_Hashtable &&, std::true_type); 
# 400
void _M_move_assign(_Hashtable &&, std::false_type); 
# 403
void _M_reset() noexcept; 
# 405
_Hashtable(const _H1 &__h1, const _H2 &__h2, const _Hash &__h, const _Equal &
# 406
__eq, const _ExtractKey &__exk, const allocator_type &
# 407
__a) : __hashtable_base(__exk, __h1, __h2, __h, __eq), __hashtable_alloc((__node_alloc_type)__a) 
# 410
{ } 
# 412
template< bool _No_realloc = true> static constexpr bool 
# 414
_S_nothrow_move() 
# 415
{ 
# 417
return __and_< std::__bool_constant< _No_realloc> , is_nothrow_copy_constructible< _H1> , is_nothrow_copy_constructible< _Equal> > ::value; 
# 426
} 
# 428
_Hashtable(_Hashtable && __ht, __node_alloc_type && __a, std::true_type) noexcept(_S_nothrow_move()); 
# 432
_Hashtable(_Hashtable &&, __node_alloc_type &&, std::false_type); 
# 438
public: _Hashtable() = default;
# 439
_Hashtable(size_type __bucket_hint, const _H1 &, const _H2 &, const _Hash &, const _Equal &, const _ExtractKey &, const allocator_type &); 
# 444
template< class _InputIterator> _Hashtable(_InputIterator __first, _InputIterator __last, size_type __bucket_hint, const _H1 &, const _H2 &, const _Hash &, const _Equal &, const _ExtractKey &, const allocator_type &); 
# 451
_Hashtable(const _Hashtable &); 
# 453
_Hashtable(_Hashtable &&__ht) noexcept(_S_nothrow_move()) : _Hashtable(std::move(__ht), std::move(__ht._M_node_allocator()), std::true_type{}) 
# 457
{ } 
# 459
_Hashtable(const _Hashtable &, const allocator_type &); 
# 461
_Hashtable(_Hashtable &&__ht, const allocator_type &__a) noexcept(_S_nothrow_move< __detail::_Hashtable_alloc< __node_alloc_type> ::__node_alloc_traits::_S_always_equal()> ()) : _Hashtable(std::move(__ht), (__node_alloc_type)__a, typename __detail::_Hashtable_alloc< __node_alloc_type> ::__node_alloc_traits::is_always_equal{}) 
# 465
{ } 
# 469
explicit _Hashtable(const allocator_type &__a) : __hashtable_alloc((__node_alloc_type)__a) 
# 471
{ } 
# 474
explicit _Hashtable(size_type __n, const _H1 &
# 475
__hf = _H1(), const key_equal &
# 476
__eql = key_equal(), const allocator_type &
# 477
__a = allocator_type()) : _Hashtable(__n, __hf, _H2(), _Hash(), __eql, __key_extract(), __a) 
# 480
{ } 
# 482
template< class _InputIterator> 
# 483
_Hashtable(_InputIterator __f, _InputIterator __l, size_type 
# 484
__n = 0, const _H1 &
# 485
__hf = _H1(), const key_equal &
# 486
__eql = key_equal(), const allocator_type &
# 487
__a = allocator_type()) : _Hashtable(__f, __l, __n, __hf, _H2(), _Hash(), __eql, __key_extract(), __a) 
# 490
{ } 
# 492
_Hashtable(initializer_list< value_type>  __l, size_type 
# 493
__n = 0, const _H1 &
# 494
__hf = _H1(), const key_equal &
# 495
__eql = key_equal(), const allocator_type &
# 496
__a = allocator_type()) : _Hashtable(__l.begin(), __l.end(), __n, __hf, _H2(), _Hash(), __eql, __key_extract(), __a) 
# 499
{ } 
# 502
_Hashtable &operator=(const _Hashtable & __ht); 
# 505
_Hashtable &operator=(_Hashtable &&__ht) noexcept(__node_alloc_traits::_S_nothrow_move() && is_nothrow_move_assignable< _H1> ::value && is_nothrow_move_assignable< _Equal> ::value) 
# 509
{ 
# 510
constexpr bool __move_storage = (__node_alloc_traits::_S_propagate_on_move_assign() || __node_alloc_traits::_S_always_equal()); 
# 513
_M_move_assign(std::move(__ht), std::__bool_constant< __move_storage> ()); 
# 514
return *this; 
# 515
} 
# 518
_Hashtable &operator=(initializer_list< value_type>  __l) 
# 519
{ 
# 520
__reuse_or_alloc_node_type __roan(_M_begin(), *this); 
# 521
((_M_before_begin)._M_nxt) = nullptr; 
# 522
clear(); 
# 523
this->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys()); 
# 524
return *this; 
# 525
} 
# 527
~_Hashtable() noexcept; 
# 530
void swap(_Hashtable &) noexcept(__and_< __is_nothrow_swappable< _H1> , __is_nothrow_swappable< _Equal> > ::value); 
# 536
iterator begin() noexcept 
# 537
{ return (iterator)_M_begin(); } 
# 540
const_iterator begin() const noexcept 
# 541
{ return (const_iterator)_M_begin(); } 
# 544
iterator end() noexcept 
# 545
{ return (iterator)nullptr; } 
# 548
const_iterator end() const noexcept 
# 549
{ return (const_iterator)nullptr; } 
# 552
const_iterator cbegin() const noexcept 
# 553
{ return (const_iterator)_M_begin(); } 
# 556
const_iterator cend() const noexcept 
# 557
{ return (const_iterator)nullptr; } 
# 560
size_type size() const noexcept 
# 561
{ return _M_element_count; } 
# 564
bool empty() const noexcept 
# 565
{ return size() == 0; } 
# 568
allocator_type get_allocator() const noexcept 
# 569
{ return (allocator_type)this->_M_node_allocator(); } 
# 572
size_type max_size() const noexcept 
# 573
{ return __node_alloc_traits::max_size(this->_M_node_allocator()); } 
# 577
key_equal key_eq() const 
# 578
{ return this->_M_eq(); } 
# 584
size_type bucket_count() const noexcept 
# 585
{ return _M_bucket_count; } 
# 588
size_type max_bucket_count() const noexcept 
# 589
{ return max_size(); } 
# 592
size_type bucket_size(size_type __n) const 
# 593
{ return std::distance(begin(__n), end(__n)); } 
# 596
size_type bucket(const key_type &__k) const 
# 597
{ return _M_bucket_index(__k, this->_M_hash_code(__k)); } 
# 600
local_iterator begin(size_type __n) 
# 601
{ 
# 602
return local_iterator(*this, _M_bucket_begin(__n), __n, _M_bucket_count); 
# 604
} 
# 607
local_iterator end(size_type __n) 
# 608
{ return local_iterator(*this, nullptr, __n, _M_bucket_count); } 
# 611
const_local_iterator begin(size_type __n) const 
# 612
{ 
# 613
return const_local_iterator(*this, _M_bucket_begin(__n), __n, _M_bucket_count); 
# 615
} 
# 618
const_local_iterator end(size_type __n) const 
# 619
{ return const_local_iterator(*this, nullptr, __n, _M_bucket_count); } 
# 623
const_local_iterator cbegin(size_type __n) const 
# 624
{ 
# 625
return const_local_iterator(*this, _M_bucket_begin(__n), __n, _M_bucket_count); 
# 627
} 
# 630
const_local_iterator cend(size_type __n) const 
# 631
{ return const_local_iterator(*this, nullptr, __n, _M_bucket_count); } 
# 634
float load_factor() const noexcept 
# 635
{ 
# 636
return (static_cast< float>(size())) / (static_cast< float>(bucket_count())); 
# 637
} 
# 645
const _RehashPolicy &__rehash_policy() const 
# 646
{ return _M_rehash_policy; } 
# 649
void __rehash_policy(const _RehashPolicy &__pol) 
# 650
{ (_M_rehash_policy) = __pol; } 
# 654
iterator find(const key_type & __k); 
# 657
const_iterator find(const key_type & __k) const; 
# 660
size_type count(const key_type & __k) const; 
# 663
pair< iterator, iterator>  equal_range(const key_type & __k); 
# 666
pair< const_iterator, const_iterator>  equal_range(const key_type & __k) const; 
# 671
protected: size_type _M_bucket_index(__node_type *__n) const noexcept 
# 672
{ return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); } 
# 675
size_type _M_bucket_index(const key_type &__k, __hash_code __c) const 
# 676
{ return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); } 
# 681
__node_base *_M_find_before_node(size_type, const key_type &, __hash_code) const; 
# 684
__node_type *_M_find_node(size_type __bkt, const key_type &__key, __hash_code 
# 685
__c) const 
# 686
{ 
# 687
__node_base *__before_n = _M_find_before_node(__bkt, __key, __c); 
# 688
if (__before_n) { 
# 689
return static_cast< __node_type *>(__before_n->_M_nxt); }  
# 690
return nullptr; 
# 691
} 
# 695
void _M_insert_bucket_begin(size_type, __node_type *); 
# 699
void _M_remove_bucket_begin(size_type __bkt, __node_type * __next_n, size_type __next_bkt); 
# 704
__node_base *_M_get_previous_node(size_type __bkt, __node_base * __n); 
# 710
iterator _M_insert_unique_node(size_type __bkt, __hash_code __code, __node_type * __n, size_type __n_elt = 1); 
# 716
iterator _M_insert_multi_node(__node_type * __hint, __hash_code __code, __node_type * __n); 
# 719
template< class ..._Args> pair< iterator, bool>  _M_emplace(std::true_type, _Args && ...__args); 
# 723
template< class ..._Args> iterator 
# 725
_M_emplace(std::false_type __uk, _Args &&...__args) 
# 726
{ return _M_emplace(cend(), __uk, std::forward< _Args> (__args)...); } 
# 729
template< class ..._Args> iterator 
# 731
_M_emplace(const_iterator, std::true_type __uk, _Args &&...__args) 
# 732
{ return _M_emplace(__uk, std::forward< _Args> (__args)...).first; } 
# 734
template< class ..._Args> iterator _M_emplace(const_iterator, std::false_type, _Args && ...__args); 
# 738
template< class _Arg, class _NodeGenerator> pair< iterator, bool>  _M_insert(_Arg &&, const _NodeGenerator &, std::true_type, size_type = 1); 
# 742
template< class _Arg, class _NodeGenerator> iterator 
# 744
_M_insert(_Arg &&__arg, const _NodeGenerator &__node_gen, std::false_type 
# 745
__uk) 
# 746
{ 
# 747
return _M_insert(cend(), std::forward< _Arg> (__arg), __node_gen, __uk); 
# 749
} 
# 752
template< class _Arg, class _NodeGenerator> iterator 
# 754
_M_insert(const_iterator, _Arg &&__arg, const _NodeGenerator &
# 755
__node_gen, std::true_type __uk) 
# 756
{ 
# 757
return _M_insert(std::forward< _Arg> (__arg), __node_gen, __uk).first; 
# 759
} 
# 762
template< class _Arg, class _NodeGenerator> iterator _M_insert(const_iterator, _Arg &&, const _NodeGenerator &, std::false_type); 
# 768
size_type _M_erase(std::true_type, const key_type &); 
# 771
size_type _M_erase(std::false_type, const key_type &); 
# 774
iterator _M_erase(size_type __bkt, __node_base * __prev_n, __node_type * __n); 
# 780
public: 
# 778
template< class ..._Args> __ireturn_type 
# 780
emplace(_Args &&...__args) 
# 781
{ return _M_emplace(__unique_keys(), std::forward< _Args> (__args)...); } 
# 783
template< class ..._Args> iterator 
# 785
emplace_hint(const_iterator __hint, _Args &&...__args) 
# 786
{ 
# 787
return _M_emplace(__hint, __unique_keys(), std::forward< _Args> (__args)...); 
# 789
} 
# 795
iterator erase(const_iterator); 
# 799
iterator erase(iterator __it) 
# 800
{ return erase((const_iterator)__it); } 
# 803
size_type erase(const key_type &__k) 
# 804
{ return _M_erase(__unique_keys(), __k); } 
# 807
iterator erase(const_iterator, const_iterator); 
# 810
void clear() noexcept; 
# 813
void rehash(size_type __n); 
# 953 "/usr/include/c++/9/bits/hashtable.h" 3
private: void _M_rehash_aux(size_type __n, std::true_type); 
# 956
void _M_rehash_aux(size_type __n, std::false_type); 
# 960
void _M_rehash(size_type __n, const __rehash_state & __state); 
# 961
}; 
# 965
template< class _Key, class _Value, class 
# 966
_Alloc, class _ExtractKey, class _Equal, class 
# 967
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 968
_Traits> auto 
# 972
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_bucket_begin(size_type __bkt) const->__node_type * 
# 974
{ 
# 975
__node_base *__n = (_M_buckets)[__bkt]; 
# 976
return (__n) ? static_cast< __node_type *>(__n->_M_nxt) : nullptr; 
# 977
} 
# 979
template< class _Key, class _Value, class 
# 980
_Alloc, class _ExtractKey, class _Equal, class 
# 981
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 982
_Traits> 
# 985
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(size_type __bucket_hint, const _H1 &
# 986
__h1, const _H2 &__h2, const _Hash &__h, const _Equal &
# 987
__eq, const _ExtractKey &__exk, const allocator_type &
# 988
__a) : _Hashtable(__h1, __h2, __h, __eq, __exk, __a) 
# 990
{ 
# 991
auto __bkt = (_M_rehash_policy)._M_next_bkt(__bucket_hint); 
# 992
if (__bkt > (_M_bucket_count)) 
# 993
{ 
# 994
(_M_buckets) = _M_allocate_buckets(__bkt); 
# 995
(_M_bucket_count) = __bkt; 
# 996
}  
# 997
} 
# 999
template< class _Key, class _Value, class 
# 1000
_Alloc, class _ExtractKey, class _Equal, class 
# 1001
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1002
_Traits> 
# 1003
template< class _InputIterator> 
# 1006
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(_InputIterator __f, _InputIterator __l, size_type 
# 1007
__bucket_hint, const _H1 &
# 1008
__h1, const _H2 &__h2, const _Hash &__h, const _Equal &
# 1009
__eq, const _ExtractKey &__exk, const allocator_type &
# 1010
__a) : _Hashtable(__h1, __h2, __h, __eq, __exk, __a) 
# 1012
{ 
# 1013
auto __nb_elems = __detail::__distance_fw(__f, __l); 
# 1014
auto __bkt_count = (_M_rehash_policy)._M_next_bkt(std::max((_M_rehash_policy)._M_bkt_for_elements(__nb_elems), __bucket_hint)); 
# 1019
if (__bkt_count > (_M_bucket_count)) 
# 1020
{ 
# 1021
(_M_buckets) = _M_allocate_buckets(__bkt_count); 
# 1022
(_M_bucket_count) = __bkt_count; 
# 1023
}  
# 1025
for (; __f != __l; ++__f) { 
# 1026
this->insert(*__f); }  
# 1027
} 
# 1029
template< class _Key, class _Value, class 
# 1030
_Alloc, class _ExtractKey, class _Equal, class 
# 1031
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1032
_Traits> auto 
# 1036
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::operator=(const _Hashtable &__ht)->_Hashtable & 
# 1038
{ 
# 1039
if ((&__ht) == this) { 
# 1040
return *this; }  
# 1042
if (__node_alloc_traits::_S_propagate_on_copy_assign()) 
# 1043
{ 
# 1044
auto &__this_alloc = this->_M_node_allocator(); 
# 1045
auto &__that_alloc = __ht._M_node_allocator(); 
# 1046
if ((!__node_alloc_traits::_S_always_equal()) && (__this_alloc != __that_alloc)) 
# 1048
{ 
# 1050
this->_M_deallocate_nodes(_M_begin()); 
# 1051
((_M_before_begin)._M_nxt) = nullptr; 
# 1052
_M_deallocate_buckets(); 
# 1053
(_M_buckets) = nullptr; 
# 1054
std::__alloc_on_copy(__this_alloc, __that_alloc); 
# 1055
__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::operator=(__ht); 
# 1056
(_M_bucket_count) = (__ht._M_bucket_count); 
# 1057
(_M_element_count) = (__ht._M_element_count); 
# 1058
(_M_rehash_policy) = (__ht._M_rehash_policy); 
# 1059
try 
# 1060
{ 
# 1061
_M_assign(__ht, [this](const __node_type *
# 1062
__n) 
# 1063
{ return (this)->_M_allocate_node(__n->_M_v()); } ); 
# 1064
} 
# 1065
catch (...) 
# 1066
{ 
# 1069
_M_reset(); 
# 1070
throw; 
# 1071
}  
# 1072
return *this; 
# 1073
}  
# 1074
std::__alloc_on_copy(__this_alloc, __that_alloc); 
# 1075
}  
# 1078
_M_assign_elements(__ht, [](const __reuse_or_alloc_node_type &
# 1079
__roan, const __node_type *__n) 
# 1080
{ return __roan(__n->_M_v()); } ); 
# 1081
return *this; 
# 1082
} 
# 1084
template< class _Key, class _Value, class 
# 1085
_Alloc, class _ExtractKey, class _Equal, class 
# 1086
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1087
_Traits> 
# 1088
template< class _Ht, class _NodeGenerator> void 
# 1092
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_assign_elements(_Ht &&__ht, const _NodeGenerator &__node_gen) 
# 1093
{ 
# 1094
__bucket_type *__former_buckets = (nullptr); 
# 1095
std::size_t __former_bucket_count = _M_bucket_count; 
# 1096
const __rehash_state &__former_state = (_M_rehash_policy)._M_state(); 
# 1098
if ((_M_bucket_count) != (__ht._M_bucket_count)) 
# 1099
{ 
# 1100
__former_buckets = (_M_buckets); 
# 1101
(_M_buckets) = _M_allocate_buckets((__ht._M_bucket_count)); 
# 1102
(_M_bucket_count) = (__ht._M_bucket_count); 
# 1103
} else { 
# 1105
__builtin_memset(_M_buckets, 0, (_M_bucket_count) * sizeof(__bucket_type)); }  
# 1108
try 
# 1109
{ 
# 1110
__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::operator=(std::forward< _Ht> (__ht)); 
# 1111
(_M_element_count) = (__ht._M_element_count); 
# 1112
(_M_rehash_policy) = (__ht._M_rehash_policy); 
# 1113
__reuse_or_alloc_node_type __roan(_M_begin(), *this); 
# 1114
((_M_before_begin)._M_nxt) = nullptr; 
# 1115
_M_assign(__ht, [&__node_gen, &__roan](__node_type *
# 1116
__n) 
# 1117
{ return (__node_gen)(__roan, __n); } ); 
# 1118
if (__former_buckets) { 
# 1119
_M_deallocate_buckets(__former_buckets, __former_bucket_count); }  
# 1120
} 
# 1121
catch (...) 
# 1122
{ 
# 1123
if (__former_buckets) 
# 1124
{ 
# 1126
_M_deallocate_buckets(); 
# 1127
(_M_rehash_policy)._M_reset(__former_state); 
# 1128
(_M_buckets) = __former_buckets; 
# 1129
(_M_bucket_count) = __former_bucket_count; 
# 1130
}  
# 1131
__builtin_memset(_M_buckets, 0, (_M_bucket_count) * sizeof(__bucket_type)); 
# 1133
throw; 
# 1134
}  
# 1135
} 
# 1137
template< class _Key, class _Value, class 
# 1138
_Alloc, class _ExtractKey, class _Equal, class 
# 1139
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1140
_Traits> 
# 1141
template< class _NodeGenerator> void 
# 1145
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_assign(const _Hashtable &__ht, const _NodeGenerator &__node_gen) 
# 1146
{ 
# 1147
__bucket_type *__buckets = (nullptr); 
# 1148
if (!(_M_buckets)) { 
# 1149
(_M_buckets) = (__buckets = _M_allocate_buckets(_M_bucket_count)); }  
# 1151
try 
# 1152
{ 
# 1153
if (!((__ht._M_before_begin)._M_nxt)) { 
# 1154
return; }  
# 1158
__node_type *__ht_n = __ht._M_begin(); 
# 1159
__node_type *__this_n = __node_gen(__ht_n); 
# 1160
this->_M_copy_code(__this_n, __ht_n); 
# 1161
((_M_before_begin)._M_nxt) = __this_n; 
# 1162
((_M_buckets)[_M_bucket_index(__this_n)]) = (&(_M_before_begin)); 
# 1165
__node_base *__prev_n = __this_n; 
# 1166
for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next()) 
# 1167
{ 
# 1168
__this_n = __node_gen(__ht_n); 
# 1169
(__prev_n->_M_nxt) = __this_n; 
# 1170
this->_M_copy_code(__this_n, __ht_n); 
# 1171
size_type __bkt = _M_bucket_index(__this_n); 
# 1172
if (!((_M_buckets)[__bkt])) { 
# 1173
((_M_buckets)[__bkt]) = __prev_n; }  
# 1174
__prev_n = __this_n; 
# 1175
}  
# 1176
} 
# 1177
catch (...) 
# 1178
{ 
# 1179
clear(); 
# 1180
if (__buckets) { 
# 1181
_M_deallocate_buckets(); }  
# 1182
throw; 
# 1183
}  
# 1184
} 
# 1186
template< class _Key, class _Value, class 
# 1187
_Alloc, class _ExtractKey, class _Equal, class 
# 1188
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1189
_Traits> void 
# 1193
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_reset() noexcept 
# 1194
{ 
# 1195
(_M_rehash_policy)._M_reset(); 
# 1196
(_M_bucket_count) = 1; 
# 1197
(_M_single_bucket) = nullptr; 
# 1198
(_M_buckets) = (&(_M_single_bucket)); 
# 1199
((_M_before_begin)._M_nxt) = nullptr; 
# 1200
(_M_element_count) = 0; 
# 1201
} 
# 1203
template< class _Key, class _Value, class 
# 1204
_Alloc, class _ExtractKey, class _Equal, class 
# 1205
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1206
_Traits> void 
# 1210
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_move_assign(_Hashtable &&__ht, std::true_type) 
# 1211
{ 
# 1212
this->_M_deallocate_nodes(_M_begin()); 
# 1213
_M_deallocate_buckets(); 
# 1214
__detail::_Hashtable_base< _Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> ::operator=(std::move(__ht)); 
# 1215
(_M_rehash_policy) = (__ht._M_rehash_policy); 
# 1216
if (!__ht._M_uses_single_bucket()) { 
# 1217
(_M_buckets) = (__ht._M_buckets); } else 
# 1219
{ 
# 1220
(_M_buckets) = (&(_M_single_bucket)); 
# 1221
(_M_single_bucket) = (__ht._M_single_bucket); 
# 1222
}  
# 1223
(_M_bucket_count) = (__ht._M_bucket_count); 
# 1224
((_M_before_begin)._M_nxt) = ((__ht._M_before_begin)._M_nxt); 
# 1225
(_M_element_count) = (__ht._M_element_count); 
# 1226
std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator()); 
# 1230
if (_M_begin()) { 
# 1231
((_M_buckets)[_M_bucket_index(_M_begin())]) = (&(_M_before_begin)); }  
# 1232
__ht._M_reset(); 
# 1233
} 
# 1235
template< class _Key, class _Value, class 
# 1236
_Alloc, class _ExtractKey, class _Equal, class 
# 1237
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1238
_Traits> void 
# 1242
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_move_assign(_Hashtable &&__ht, std::false_type) 
# 1243
{ 
# 1244
if (__ht._M_node_allocator() == this->_M_node_allocator()) { 
# 1245
_M_move_assign(std::move(__ht), std::true_type()); } else 
# 1247
{ 
# 1249
_M_assign_elements(std::move(__ht), [](const __reuse_or_alloc_node_type &
# 1250
__roan, __node_type *__n) 
# 1251
{ return __roan(std::move_if_noexcept(__n->_M_v())); } ); 
# 1252
__ht.clear(); 
# 1253
}  
# 1254
} 
# 1256
template< class _Key, class _Value, class 
# 1257
_Alloc, class _ExtractKey, class _Equal, class 
# 1258
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1259
_Traits> 
# 1262
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(const _Hashtable &__ht) : __hashtable_base(__ht), __rehash_base(__ht), __map_base(__ht), __hashtable_alloc(__node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())), _M_buckets((nullptr)), _M_bucket_count(__ht._M_bucket_count), _M_element_count(__ht._M_element_count), _M_rehash_policy(__ht._M_rehash_policy) 
# 1272
{ 
# 1273
_M_assign(__ht, [this](const __node_type *
# 1274
__n) 
# 1275
{ return (this)->_M_allocate_node(__n->_M_v()); } ); 
# 1276
} 
# 1278
template< class _Key, class _Value, class 
# 1279
_Alloc, class _ExtractKey, class _Equal, class 
# 1280
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1281
_Traits> 
# 1284
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(_Hashtable &&__ht, __node_alloc_type &&__a, std::true_type) noexcept(_S_nothrow_move()) : __hashtable_base(__ht), __rehash_base(__ht), __map_base(__ht), __hashtable_alloc(std::move(__a)), _M_buckets(__ht._M_buckets), _M_bucket_count(__ht._M_bucket_count), _M_before_begin(((__ht._M_before_begin)._M_nxt)), _M_element_count(__ht._M_element_count), _M_rehash_policy(__ht._M_rehash_policy) 
# 1296
{ 
# 1298
if (__ht._M_uses_single_bucket()) 
# 1299
{ 
# 1300
(_M_buckets) = (&(_M_single_bucket)); 
# 1301
(_M_single_bucket) = (__ht._M_single_bucket); 
# 1302
}  
# 1306
if (_M_begin()) { 
# 1307
((_M_buckets)[_M_bucket_index(_M_begin())]) = (&(_M_before_begin)); }  
# 1309
__ht._M_reset(); 
# 1310
} 
# 1312
template< class _Key, class _Value, class 
# 1313
_Alloc, class _ExtractKey, class _Equal, class 
# 1314
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1315
_Traits> 
# 1318
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(const _Hashtable &__ht, const allocator_type &__a) : __hashtable_base(__ht), __rehash_base(__ht), __map_base(__ht), __hashtable_alloc((__node_alloc_type)__a), _M_buckets(), _M_bucket_count(__ht._M_bucket_count), _M_element_count(__ht._M_element_count), _M_rehash_policy(__ht._M_rehash_policy) 
# 1327
{ 
# 1328
_M_assign(__ht, [this](const __node_type *
# 1329
__n) 
# 1330
{ return (this)->_M_allocate_node(__n->_M_v()); } ); 
# 1331
} 
# 1333
template< class _Key, class _Value, class 
# 1334
_Alloc, class _ExtractKey, class _Equal, class 
# 1335
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1336
_Traits> 
# 1339
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_Hashtable(_Hashtable &&__ht, __node_alloc_type &&__a, std::false_type) : __hashtable_base(__ht), __rehash_base(__ht), __map_base(__ht), __hashtable_alloc(std::move(__a)), _M_buckets((nullptr)), _M_bucket_count(__ht._M_bucket_count), _M_element_count(__ht._M_element_count), _M_rehash_policy(__ht._M_rehash_policy) 
# 1349
{ 
# 1350
if (__ht._M_node_allocator() == this->_M_node_allocator()) 
# 1351
{ 
# 1352
if (__ht._M_uses_single_bucket()) 
# 1353
{ 
# 1354
(_M_buckets) = (&(_M_single_bucket)); 
# 1355
(_M_single_bucket) = (__ht._M_single_bucket); 
# 1356
} else { 
# 1358
(_M_buckets) = (__ht._M_buckets); }  
# 1360
((_M_before_begin)._M_nxt) = ((__ht._M_before_begin)._M_nxt); 
# 1363
if (_M_begin()) { 
# 1364
((_M_buckets)[_M_bucket_index(_M_begin())]) = (&(_M_before_begin)); }  
# 1365
__ht._M_reset(); 
# 1366
} else 
# 1368
{ 
# 1369
_M_assign(__ht, [this](__node_type *
# 1370
__n) 
# 1371
{ 
# 1372
return (this)->_M_allocate_node(std::move_if_noexcept(__n->_M_v())); 
# 1374
} ); 
# 1375
__ht.clear(); 
# 1376
}  
# 1377
} 
# 1379
template< class _Key, class _Value, class 
# 1380
_Alloc, class _ExtractKey, class _Equal, class 
# 1381
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1382
_Traits> 
# 1385
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::~_Hashtable() noexcept 
# 1386
{ 
# 1387
clear(); 
# 1388
_M_deallocate_buckets(); 
# 1389
} 
# 1391
template< class _Key, class _Value, class 
# 1392
_Alloc, class _ExtractKey, class _Equal, class 
# 1393
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1394
_Traits> void 
# 1398
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::swap(_Hashtable &__x) noexcept(__and_< __is_nothrow_swappable< _H1> , __is_nothrow_swappable< _Equal> > ::value) 
# 1401
{ 
# 1405
this->_M_swap(__x); 
# 1407
std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator()); 
# 1408
std::swap(_M_rehash_policy, __x._M_rehash_policy); 
# 1411
if (this->_M_uses_single_bucket()) 
# 1412
{ 
# 1413
if (!__x._M_uses_single_bucket()) 
# 1414
{ 
# 1415
(_M_buckets) = (__x._M_buckets); 
# 1416
(__x._M_buckets) = (&(__x._M_single_bucket)); 
# 1417
}  
# 1418
} else { 
# 1419
if (__x._M_uses_single_bucket()) 
# 1420
{ 
# 1421
(__x._M_buckets) = (_M_buckets); 
# 1422
(_M_buckets) = (&(_M_single_bucket)); 
# 1423
} else { 
# 1425
std::swap(_M_buckets, __x._M_buckets); }  }  
# 1427
std::swap(_M_bucket_count, __x._M_bucket_count); 
# 1428
std::swap(((_M_before_begin)._M_nxt), ((__x._M_before_begin)._M_nxt)); 
# 1429
std::swap(_M_element_count, __x._M_element_count); 
# 1430
std::swap(_M_single_bucket, __x._M_single_bucket); 
# 1434
if (_M_begin()) { 
# 1435
((_M_buckets)[_M_bucket_index(_M_begin())]) = (&(_M_before_begin)); }  
# 1437
if (__x._M_begin()) { 
# 1438
((__x._M_buckets)[__x._M_bucket_index(__x._M_begin())]) = (&(__x._M_before_begin)); }  
# 1440
} 
# 1442
template< class _Key, class _Value, class 
# 1443
_Alloc, class _ExtractKey, class _Equal, class 
# 1444
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1445
_Traits> auto 
# 1449
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::find(const key_type &__k)->iterator 
# 1451
{ 
# 1452
__hash_code __code = this->_M_hash_code(__k); 
# 1453
std::size_t __n = _M_bucket_index(__k, __code); 
# 1454
__node_type *__p = _M_find_node(__n, __k, __code); 
# 1455
return (__p) ? (iterator)__p : end(); 
# 1456
} 
# 1458
template< class _Key, class _Value, class 
# 1459
_Alloc, class _ExtractKey, class _Equal, class 
# 1460
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1461
_Traits> auto 
# 1465
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::find(const key_type &__k) const->const_iterator 
# 1467
{ 
# 1468
__hash_code __code = this->_M_hash_code(__k); 
# 1469
std::size_t __n = _M_bucket_index(__k, __code); 
# 1470
__node_type *__p = _M_find_node(__n, __k, __code); 
# 1471
return (__p) ? (const_iterator)__p : end(); 
# 1472
} 
# 1474
template< class _Key, class _Value, class 
# 1475
_Alloc, class _ExtractKey, class _Equal, class 
# 1476
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1477
_Traits> auto 
# 1481
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::count(const key_type &__k) const->size_type 
# 1483
{ 
# 1484
__hash_code __code = this->_M_hash_code(__k); 
# 1485
std::size_t __n = _M_bucket_index(__k, __code); 
# 1486
__node_type *__p = _M_bucket_begin(__n); 
# 1487
if (!__p) { 
# 1488
return 0; }  
# 1490
std::size_t __result = (0); 
# 1491
for (; ; __p = __p->_M_next()) 
# 1492
{ 
# 1493
if (this->_M_equals(__k, __code, __p)) { 
# 1494
++__result; } else { 
# 1495
if (__result) { 
# 1499
break; }  }  
# 1500
if ((!(__p->_M_nxt)) || (_M_bucket_index(__p->_M_next()) != __n)) { 
# 1501
break; }  
# 1502
}  
# 1503
return __result; 
# 1504
} 
# 1506
template< class _Key, class _Value, class 
# 1507
_Alloc, class _ExtractKey, class _Equal, class 
# 1508
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1509
_Traits> auto 
# 1513
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::equal_range(const key_type &__k)->pair< iterator, iterator>  
# 1515
{ 
# 1516
__hash_code __code = this->_M_hash_code(__k); 
# 1517
std::size_t __n = _M_bucket_index(__k, __code); 
# 1518
__node_type *__p = _M_find_node(__n, __k, __code); 
# 1520
if (__p) 
# 1521
{ 
# 1522
__node_type *__p1 = __p->_M_next(); 
# 1523
while (__p1 && (_M_bucket_index(__p1) == __n) && this->_M_equals(__k, __code, __p1)) { 
# 1525
__p1 = __p1->_M_next(); }  
# 1527
return std::make_pair((iterator)__p, (iterator)__p1); 
# 1528
} else { 
# 1530
return std::make_pair(end(), end()); }  
# 1531
} 
# 1533
template< class _Key, class _Value, class 
# 1534
_Alloc, class _ExtractKey, class _Equal, class 
# 1535
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1536
_Traits> auto 
# 1540
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::equal_range(const key_type &__k) const->pair< const_iterator, const_iterator>  
# 1542
{ 
# 1543
__hash_code __code = this->_M_hash_code(__k); 
# 1544
std::size_t __n = _M_bucket_index(__k, __code); 
# 1545
__node_type *__p = _M_find_node(__n, __k, __code); 
# 1547
if (__p) 
# 1548
{ 
# 1549
__node_type *__p1 = __p->_M_next(); 
# 1550
while (__p1 && (_M_bucket_index(__p1) == __n) && this->_M_equals(__k, __code, __p1)) { 
# 1552
__p1 = __p1->_M_next(); }  
# 1554
return std::make_pair((const_iterator)__p, (const_iterator)__p1); 
# 1555
} else { 
# 1557
return std::make_pair(end(), end()); }  
# 1558
} 
# 1562
template< class _Key, class _Value, class 
# 1563
_Alloc, class _ExtractKey, class _Equal, class 
# 1564
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1565
_Traits> auto 
# 1569
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_find_before_node(size_type __n, const key_type &__k, __hash_code 
# 1570
__code) const->__node_base * 
# 1572
{ 
# 1573
__node_base *__prev_p = (_M_buckets)[__n]; 
# 1574
if (!__prev_p) { 
# 1575
return nullptr; }  
# 1577
for (__node_type *__p = static_cast< __node_type *>(__prev_p->_M_nxt); ; __p = __p->_M_next()) 
# 1579
{ 
# 1580
if (this->_M_equals(__k, __code, __p)) { 
# 1581
return __prev_p; }  
# 1583
if ((!(__p->_M_nxt)) || (_M_bucket_index(__p->_M_next()) != __n)) { 
# 1584
break; }  
# 1585
__prev_p = __p; 
# 1586
}  
# 1587
return nullptr; 
# 1588
} 
# 1590
template< class _Key, class _Value, class 
# 1591
_Alloc, class _ExtractKey, class _Equal, class 
# 1592
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1593
_Traits> void 
# 1597
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_bucket_begin(size_type __bkt, __node_type *__node) 
# 1598
{ 
# 1599
if ((_M_buckets)[__bkt]) 
# 1600
{ 
# 1603
(__node->_M_nxt) = (((_M_buckets)[__bkt])->_M_nxt); 
# 1604
(((_M_buckets)[__bkt])->_M_nxt) = __node; 
# 1605
} else 
# 1607
{ 
# 1611
(__node->_M_nxt) = ((_M_before_begin)._M_nxt); 
# 1612
((_M_before_begin)._M_nxt) = __node; 
# 1613
if (__node->_M_nxt) { 
# 1616
((_M_buckets)[_M_bucket_index(__node->_M_next())]) = __node; }  
# 1617
((_M_buckets)[__bkt]) = (&(_M_before_begin)); 
# 1618
}  
# 1619
} 
# 1621
template< class _Key, class _Value, class 
# 1622
_Alloc, class _ExtractKey, class _Equal, class 
# 1623
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1624
_Traits> void 
# 1628
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_remove_bucket_begin(size_type __bkt, __node_type *__next, size_type 
# 1629
__next_bkt) 
# 1630
{ 
# 1631
if ((!__next) || (__next_bkt != __bkt)) 
# 1632
{ 
# 1635
if (__next) { 
# 1636
((_M_buckets)[__next_bkt]) = ((_M_buckets)[__bkt]); }  
# 1639
if ((&(_M_before_begin)) == ((_M_buckets)[__bkt])) { 
# 1640
((_M_before_begin)._M_nxt) = __next; }  
# 1641
((_M_buckets)[__bkt]) = nullptr; 
# 1642
}  
# 1643
} 
# 1645
template< class _Key, class _Value, class 
# 1646
_Alloc, class _ExtractKey, class _Equal, class 
# 1647
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1648
_Traits> auto 
# 1652
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_get_previous_node(size_type __bkt, __node_base *__n)->__node_base * 
# 1654
{ 
# 1655
__node_base *__prev_n = (_M_buckets)[__bkt]; 
# 1656
while ((__prev_n->_M_nxt) != __n) { 
# 1657
__prev_n = (__prev_n->_M_nxt); }  
# 1658
return __prev_n; 
# 1659
} 
# 1661
template< class _Key, class _Value, class 
# 1662
_Alloc, class _ExtractKey, class _Equal, class 
# 1663
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1664
_Traits> 
# 1665
template< class ..._Args> auto 
# 1669
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_emplace(std::true_type, _Args &&...__args)->pair< iterator, bool>  
# 1671
{ 
# 1673
__node_type *__node = this->_M_allocate_node(std::forward< _Args> (__args)...); 
# 1674
const key_type &__k = this->_M_extract()(__node->_M_v()); 
# 1675
__hash_code __code; 
# 1676
try 
# 1677
{ 
# 1678
__code = this->_M_hash_code(__k); 
# 1679
} 
# 1680
catch (...) 
# 1681
{ 
# 1682
this->_M_deallocate_node(__node); 
# 1683
throw; 
# 1684
}  
# 1686
size_type __bkt = _M_bucket_index(__k, __code); 
# 1687
if (__node_type *__p = _M_find_node(__bkt, __k, __code)) 
# 1688
{ 
# 1690
this->_M_deallocate_node(__node); 
# 1691
return std::make_pair((iterator)__p, false); 
# 1692
}  
# 1695
return std::make_pair(_M_insert_unique_node(__bkt, __code, __node), true); 
# 1697
} 
# 1699
template< class _Key, class _Value, class 
# 1700
_Alloc, class _ExtractKey, class _Equal, class 
# 1701
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1702
_Traits> 
# 1703
template< class ..._Args> auto 
# 1707
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_emplace(const_iterator __hint, std::false_type, _Args &&...__args)->iterator 
# 1709
{ 
# 1711
__node_type *__node = this->_M_allocate_node(std::forward< _Args> (__args)...); 
# 1714
__hash_code __code; 
# 1715
try 
# 1716
{ 
# 1717
__code = this->_M_hash_code(this->_M_extract()(__node->_M_v())); 
# 1718
} 
# 1719
catch (...) 
# 1720
{ 
# 1721
this->_M_deallocate_node(__node); 
# 1722
throw; 
# 1723
}  
# 1725
return _M_insert_multi_node((__hint._M_cur), __code, __node); 
# 1726
} 
# 1728
template< class _Key, class _Value, class 
# 1729
_Alloc, class _ExtractKey, class _Equal, class 
# 1730
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1731
_Traits> auto 
# 1735
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_unique_node(size_type __bkt, __hash_code __code, __node_type *
# 1736
__node, size_type __n_elt)->iterator 
# 1738
{ 
# 1739
const __rehash_state &__saved_state = (_M_rehash_policy)._M_state(); 
# 1740
std::pair< bool, std::size_t>  __do_rehash = (_M_rehash_policy)._M_need_rehash(_M_bucket_count, _M_element_count, __n_elt); 
# 1744
try 
# 1745
{ 
# 1746
if (__do_rehash.first) 
# 1747
{ 
# 1748
_M_rehash(__do_rehash.second, __saved_state); 
# 1749
__bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code); 
# 1750
}  
# 1752
this->_M_store_code(__node, __code); 
# 1755
_M_insert_bucket_begin(__bkt, __node); 
# 1756
++(_M_element_count); 
# 1757
return (iterator)__node; 
# 1758
} 
# 1759
catch (...) 
# 1760
{ 
# 1761
this->_M_deallocate_node(__node); 
# 1762
throw; 
# 1763
}  
# 1764
} 
# 1768
template< class _Key, class _Value, class 
# 1769
_Alloc, class _ExtractKey, class _Equal, class 
# 1770
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1771
_Traits> auto 
# 1775
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert_multi_node(__node_type *__hint, __hash_code __code, __node_type *
# 1776
__node)->iterator 
# 1778
{ 
# 1779
const __rehash_state &__saved_state = (_M_rehash_policy)._M_state(); 
# 1780
std::pair< bool, std::size_t>  __do_rehash = (_M_rehash_policy)._M_need_rehash(_M_bucket_count, _M_element_count, 1); 
# 1783
try 
# 1784
{ 
# 1785
if (__do_rehash.first) { 
# 1786
_M_rehash(__do_rehash.second, __saved_state); }  
# 1788
this->_M_store_code(__node, __code); 
# 1789
const key_type &__k = this->_M_extract()(__node->_M_v()); 
# 1790
size_type __bkt = _M_bucket_index(__k, __code); 
# 1794
__node_base *__prev = (__builtin_expect(__hint != nullptr, false) && this->_M_equals(__k, __code, __hint)) ? __hint : _M_find_before_node(__bkt, __k, __code); 
# 1799
if (__prev) 
# 1800
{ 
# 1802
(__node->_M_nxt) = (__prev->_M_nxt); 
# 1803
(__prev->_M_nxt) = __node; 
# 1804
if (__builtin_expect(__prev == __hint, false)) { 
# 1807
if ((__node->_M_nxt) && (!this->_M_equals(__k, __code, __node->_M_next()))) 
# 1809
{ 
# 1810
size_type __next_bkt = _M_bucket_index(__node->_M_next()); 
# 1811
if (__next_bkt != __bkt) { 
# 1812
((_M_buckets)[__next_bkt]) = __node; }  
# 1813
}  }  
# 1814
} else { 
# 1820
_M_insert_bucket_begin(__bkt, __node); }  
# 1821
++(_M_element_count); 
# 1822
return (iterator)__node; 
# 1823
} 
# 1824
catch (...) 
# 1825
{ 
# 1826
this->_M_deallocate_node(__node); 
# 1827
throw; 
# 1828
}  
# 1829
} 
# 1832
template< class _Key, class _Value, class 
# 1833
_Alloc, class _ExtractKey, class _Equal, class 
# 1834
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1835
_Traits> 
# 1836
template< class _Arg, class _NodeGenerator> auto 
# 1840
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert(_Arg &&__v, const _NodeGenerator &__node_gen, std::true_type, size_type 
# 1841
__n_elt)->pair< iterator, bool>  
# 1843
{ 
# 1844
const key_type &__k = this->_M_extract()(__v); 
# 1845
__hash_code __code = this->_M_hash_code(__k); 
# 1846
size_type __bkt = _M_bucket_index(__k, __code); 
# 1848
__node_type *__n = _M_find_node(__bkt, __k, __code); 
# 1849
if (__n) { 
# 1850
return std::make_pair((iterator)__n, false); }  
# 1852
__n = __node_gen(std::forward< _Arg> (__v)); 
# 1853
return {_M_insert_unique_node(__bkt, __code, __n, __n_elt), true}; 
# 1854
} 
# 1857
template< class _Key, class _Value, class 
# 1858
_Alloc, class _ExtractKey, class _Equal, class 
# 1859
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1860
_Traits> 
# 1861
template< class _Arg, class _NodeGenerator> auto 
# 1865
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_insert(const_iterator __hint, _Arg &&__v, const _NodeGenerator &
# 1866
__node_gen, std::false_type)->iterator 
# 1868
{ 
# 1871
__hash_code __code = this->_M_hash_code(this->_M_extract()(__v)); 
# 1874
__node_type *__node = __node_gen(std::forward< _Arg> (__v)); 
# 1876
return _M_insert_multi_node((__hint._M_cur), __code, __node); 
# 1877
} 
# 1879
template< class _Key, class _Value, class 
# 1880
_Alloc, class _ExtractKey, class _Equal, class 
# 1881
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1882
_Traits> auto 
# 1886
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::erase(const_iterator __it)->iterator 
# 1888
{ 
# 1889
__node_type *__n = ((__it._M_cur)); 
# 1890
std::size_t __bkt = _M_bucket_index(__n); 
# 1895
__node_base *__prev_n = _M_get_previous_node(__bkt, __n); 
# 1896
return _M_erase(__bkt, __prev_n, __n); 
# 1897
} 
# 1899
template< class _Key, class _Value, class 
# 1900
_Alloc, class _ExtractKey, class _Equal, class 
# 1901
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1902
_Traits> auto 
# 1906
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_erase(size_type __bkt, __node_base *__prev_n, __node_type *__n)->iterator 
# 1908
{ 
# 1909
if (__prev_n == ((_M_buckets)[__bkt])) { 
# 1910
_M_remove_bucket_begin(__bkt, __n->_M_next(), (__n->_M_nxt) ? _M_bucket_index(__n->_M_next()) : 0); } else { 
# 1912
if (__n->_M_nxt) 
# 1913
{ 
# 1914
size_type __next_bkt = _M_bucket_index(__n->_M_next()); 
# 1915
if (__next_bkt != __bkt) { 
# 1916
((_M_buckets)[__next_bkt]) = __prev_n; }  
# 1917
}  }  
# 1919
(__prev_n->_M_nxt) = (__n->_M_nxt); 
# 1920
iterator __result(__n->_M_next()); 
# 1921
this->_M_deallocate_node(__n); 
# 1922
--(_M_element_count); 
# 1924
return __result; 
# 1925
} 
# 1927
template< class _Key, class _Value, class 
# 1928
_Alloc, class _ExtractKey, class _Equal, class 
# 1929
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1930
_Traits> auto 
# 1934
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_erase(std::true_type, const key_type &__k)->size_type 
# 1936
{ 
# 1937
__hash_code __code = this->_M_hash_code(__k); 
# 1938
std::size_t __bkt = _M_bucket_index(__k, __code); 
# 1941
__node_base *__prev_n = _M_find_before_node(__bkt, __k, __code); 
# 1942
if (!__prev_n) { 
# 1943
return 0; }  
# 1946
__node_type *__n = static_cast< __node_type *>(__prev_n->_M_nxt); 
# 1947
_M_erase(__bkt, __prev_n, __n); 
# 1948
return 1; 
# 1949
} 
# 1951
template< class _Key, class _Value, class 
# 1952
_Alloc, class _ExtractKey, class _Equal, class 
# 1953
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 1954
_Traits> auto 
# 1958
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_erase(std::false_type, const key_type &__k)->size_type 
# 1960
{ 
# 1961
__hash_code __code = this->_M_hash_code(__k); 
# 1962
std::size_t __bkt = _M_bucket_index(__k, __code); 
# 1965
__node_base *__prev_n = _M_find_before_node(__bkt, __k, __code); 
# 1966
if (!__prev_n) { 
# 1967
return 0; }  
# 1975
__node_type *__n = static_cast< __node_type *>(__prev_n->_M_nxt); 
# 1976
__node_type *__n_last = __n; 
# 1977
std::size_t __n_last_bkt = __bkt; 
# 1978
do 
# 1979
{ 
# 1980
__n_last = __n_last->_M_next(); 
# 1981
if (!__n_last) { 
# 1982
break; }  
# 1983
__n_last_bkt = _M_bucket_index(__n_last); 
# 1984
} 
# 1985
while ((__n_last_bkt == __bkt) && this->_M_equals(__k, __code, __n_last)); 
# 1988
size_type __result = (0); 
# 1989
do 
# 1990
{ 
# 1991
__node_type *__p = __n->_M_next(); 
# 1992
this->_M_deallocate_node(__n); 
# 1993
__n = __p; 
# 1994
++__result; 
# 1995
--(_M_element_count); 
# 1996
} 
# 1997
while (__n != __n_last); 
# 1999
if (__prev_n == ((_M_buckets)[__bkt])) { 
# 2000
_M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt); } else { 
# 2001
if (__n_last && (__n_last_bkt != __bkt)) { 
# 2002
((_M_buckets)[__n_last_bkt]) = __prev_n; }  }  
# 2003
(__prev_n->_M_nxt) = __n_last; 
# 2004
return __result; 
# 2005
} 
# 2007
template< class _Key, class _Value, class 
# 2008
_Alloc, class _ExtractKey, class _Equal, class 
# 2009
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 2010
_Traits> auto 
# 2014
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::erase(const_iterator __first, const_iterator __last)->iterator 
# 2016
{ 
# 2017
__node_type *__n = ((__first._M_cur)); 
# 2018
__node_type *__last_n = ((__last._M_cur)); 
# 2019
if (__n == __last_n) { 
# 2020
return (iterator)__n; }  
# 2022
std::size_t __bkt = _M_bucket_index(__n); 
# 2024
__node_base *__prev_n = _M_get_previous_node(__bkt, __n); 
# 2025
bool __is_bucket_begin = __n == _M_bucket_begin(__bkt); 
# 2026
std::size_t __n_bkt = __bkt; 
# 2027
for (; ;) 
# 2028
{ 
# 2029
do 
# 2030
{ 
# 2031
__node_type *__tmp = __n; 
# 2032
__n = __n->_M_next(); 
# 2033
this->_M_deallocate_node(__tmp); 
# 2034
--(_M_element_count); 
# 2035
if (!__n) { 
# 2036
break; }  
# 2037
__n_bkt = _M_bucket_index(__n); 
# 2038
} 
# 2039
while ((__n != __last_n) && (__n_bkt == __bkt)); 
# 2040
if (__is_bucket_begin) { 
# 2041
_M_remove_bucket_begin(__bkt, __n, __n_bkt); }  
# 2042
if (__n == __last_n) { 
# 2043
break; }  
# 2044
__is_bucket_begin = true; 
# 2045
__bkt = __n_bkt; 
# 2046
}  
# 2048
if (__n && ((__n_bkt != __bkt) || __is_bucket_begin)) { 
# 2049
((_M_buckets)[__n_bkt]) = __prev_n; }  
# 2050
(__prev_n->_M_nxt) = __n; 
# 2051
return (iterator)__n; 
# 2052
} 
# 2054
template< class _Key, class _Value, class 
# 2055
_Alloc, class _ExtractKey, class _Equal, class 
# 2056
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 2057
_Traits> void 
# 2061
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::clear() noexcept 
# 2062
{ 
# 2063
this->_M_deallocate_nodes(_M_begin()); 
# 2064
__builtin_memset(_M_buckets, 0, (_M_bucket_count) * sizeof(__bucket_type)); 
# 2065
(_M_element_count) = 0; 
# 2066
((_M_before_begin)._M_nxt) = nullptr; 
# 2067
} 
# 2069
template< class _Key, class _Value, class 
# 2070
_Alloc, class _ExtractKey, class _Equal, class 
# 2071
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 2072
_Traits> void 
# 2076
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::rehash(size_type __n) 
# 2077
{ 
# 2078
const __rehash_state &__saved_state = (_M_rehash_policy)._M_state(); 
# 2079
std::size_t __buckets = std::max((_M_rehash_policy)._M_bkt_for_elements((_M_element_count) + 1), __n); 
# 2082
__buckets = (_M_rehash_policy)._M_next_bkt(__buckets); 
# 2084
if (__buckets != (_M_bucket_count)) { 
# 2085
_M_rehash(__buckets, __saved_state); } else { 
# 2088
(_M_rehash_policy)._M_reset(__saved_state); }  
# 2089
} 
# 2091
template< class _Key, class _Value, class 
# 2092
_Alloc, class _ExtractKey, class _Equal, class 
# 2093
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 2094
_Traits> void 
# 2098
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_rehash(size_type __n, const __rehash_state &__state) 
# 2099
{ 
# 2100
try 
# 2101
{ 
# 2102
_M_rehash_aux(__n, __unique_keys()); 
# 2103
} 
# 2104
catch (...) 
# 2105
{ 
# 2108
(_M_rehash_policy)._M_reset(__state); 
# 2109
throw; 
# 2110
}  
# 2111
} 
# 2114
template< class _Key, class _Value, class 
# 2115
_Alloc, class _ExtractKey, class _Equal, class 
# 2116
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 2117
_Traits> void 
# 2121
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_rehash_aux(size_type __n, std::true_type) 
# 2122
{ 
# 2123
__bucket_type *__new_buckets = _M_allocate_buckets(__n); 
# 2124
__node_type *__p = _M_begin(); 
# 2125
((_M_before_begin)._M_nxt) = nullptr; 
# 2126
std::size_t __bbegin_bkt = (0); 
# 2127
while (__p) 
# 2128
{ 
# 2129
__node_type *__next = __p->_M_next(); 
# 2130
std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n); 
# 2131
if (!(__new_buckets[__bkt])) 
# 2132
{ 
# 2133
(__p->_M_nxt) = ((_M_before_begin)._M_nxt); 
# 2134
((_M_before_begin)._M_nxt) = __p; 
# 2135
(__new_buckets[__bkt]) = (&(_M_before_begin)); 
# 2136
if (__p->_M_nxt) { 
# 2137
(__new_buckets[__bbegin_bkt]) = __p; }  
# 2138
__bbegin_bkt = __bkt; 
# 2139
} else 
# 2141
{ 
# 2142
(__p->_M_nxt) = ((__new_buckets[__bkt])->_M_nxt); 
# 2143
((__new_buckets[__bkt])->_M_nxt) = __p; 
# 2144
}  
# 2145
__p = __next; 
# 2146
}  
# 2148
_M_deallocate_buckets(); 
# 2149
(_M_bucket_count) = __n; 
# 2150
(_M_buckets) = __new_buckets; 
# 2151
} 
# 2155
template< class _Key, class _Value, class 
# 2156
_Alloc, class _ExtractKey, class _Equal, class 
# 2157
_H1, class _H2, class _Hash, class _RehashPolicy, class 
# 2158
_Traits> void 
# 2162
_Hashtable< _Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> ::_M_rehash_aux(size_type __n, std::false_type) 
# 2163
{ 
# 2164
__bucket_type *__new_buckets = _M_allocate_buckets(__n); 
# 2166
__node_type *__p = _M_begin(); 
# 2167
((_M_before_begin)._M_nxt) = nullptr; 
# 2168
std::size_t __bbegin_bkt = (0); 
# 2169
std::size_t __prev_bkt = (0); 
# 2170
__node_type *__prev_p = (nullptr); 
# 2171
bool __check_bucket = false; 
# 2173
while (__p) 
# 2174
{ 
# 2175
__node_type *__next = __p->_M_next(); 
# 2176
std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n); 
# 2178
if (__prev_p && (__prev_bkt == __bkt)) 
# 2179
{ 
# 2183
(__p->_M_nxt) = (__prev_p->_M_nxt); 
# 2184
(__prev_p->_M_nxt) = __p; 
# 2191
__check_bucket = true; 
# 2192
} else 
# 2194
{ 
# 2195
if (__check_bucket) 
# 2196
{ 
# 2199
if (__prev_p->_M_nxt) 
# 2200
{ 
# 2201
std::size_t __next_bkt = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n); 
# 2204
if (__next_bkt != __prev_bkt) { 
# 2205
(__new_buckets[__next_bkt]) = __prev_p; }  
# 2206
}  
# 2207
__check_bucket = false; 
# 2208
}  
# 2210
if (!(__new_buckets[__bkt])) 
# 2211
{ 
# 2212
(__p->_M_nxt) = ((_M_before_begin)._M_nxt); 
# 2213
((_M_before_begin)._M_nxt) = __p; 
# 2214
(__new_buckets[__bkt]) = (&(_M_before_begin)); 
# 2215
if (__p->_M_nxt) { 
# 2216
(__new_buckets[__bbegin_bkt]) = __p; }  
# 2217
__bbegin_bkt = __bkt; 
# 2218
} else 
# 2220
{ 
# 2221
(__p->_M_nxt) = ((__new_buckets[__bkt])->_M_nxt); 
# 2222
((__new_buckets[__bkt])->_M_nxt) = __p; 
# 2223
}  
# 2224
}  
# 2225
__prev_p = __p; 
# 2226
__prev_bkt = __bkt; 
# 2227
__p = __next; 
# 2228
}  
# 2230
if (__check_bucket && (__prev_p->_M_nxt)) 
# 2231
{ 
# 2232
std::size_t __next_bkt = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n); 
# 2234
if (__next_bkt != __prev_bkt) { 
# 2235
(__new_buckets[__next_bkt]) = __prev_p; }  
# 2236
}  
# 2238
_M_deallocate_buckets(); 
# 2239
(_M_bucket_count) = __n; 
# 2240
(_M_buckets) = __new_buckets; 
# 2241
} 
# 2255 "/usr/include/c++/9/bits/hashtable.h" 3
}
# 33 "/usr/include/c++/9/bits/unordered_map.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 39
template< bool _Cache> using __umap_traits = __detail::_Hashtable_traits< _Cache, false, true> ; 
# 42
template< class _Key, class 
# 43
_Tp, class 
# 44
_Hash = hash< _Key> , class 
# 45
_Pred = equal_to< _Key> , class 
# 46
_Alloc = allocator< pair< const _Key, _Tp> > , class 
# 47
_Tr = __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > using __umap_hashtable = _Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, _Tr> ; 
# 56
template< bool _Cache> using __ummap_traits = __detail::_Hashtable_traits< _Cache, false, false> ; 
# 59
template< class _Key, class 
# 60
_Tp, class 
# 61
_Hash = hash< _Key> , class 
# 62
_Pred = equal_to< _Key> , class 
# 63
_Alloc = allocator< pair< const _Key, _Tp> > , class 
# 64
_Tr = __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > using __ummap_hashtable = _Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, _Tr> ; 
# 72
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> class unordered_multimap; 
# 98 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class _Key, class _Tp, class 
# 99
_Hash = hash< _Key> , class 
# 100
_Pred = equal_to< _Key> , class 
# 101
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 102
class unordered_map { 
# 104
typedef __umap_hashtable< _Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable; 
# 105
_Hashtable _M_h; 
# 111
public: typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::key_type key_type; 
# 112
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::value_type value_type; 
# 113
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::mapped_type mapped_type; 
# 114
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::hasher hasher; 
# 115
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::key_equal key_equal; 
# 116
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::allocator_type allocator_type; 
# 121
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::pointer pointer; 
# 122
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::const_pointer const_pointer; 
# 123
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::reference reference; 
# 124
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::const_reference const_reference; 
# 125
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::iterator iterator; 
# 126
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::const_iterator const_iterator; 
# 127
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::local_iterator local_iterator; 
# 128
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::const_local_iterator const_local_iterator; 
# 129
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::size_type size_type; 
# 130
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __umap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::difference_type difference_type; 
# 141 "/usr/include/c++/9/bits/unordered_map.h" 3
unordered_map() = default;
# 151 "/usr/include/c++/9/bits/unordered_map.h" 3
explicit unordered_map(size_type __n, const hasher &
# 152
__hf = hasher(), const key_equal &
# 153
__eql = key_equal(), const allocator_type &
# 154
__a = allocator_type()) : _M_h(__n, __hf, __eql, __a) 
# 156
{ } 
# 171 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class _InputIterator> 
# 172
unordered_map(_InputIterator __first, _InputIterator __last, size_type 
# 173
__n = 0, const hasher &
# 174
__hf = hasher(), const key_equal &
# 175
__eql = key_equal(), const allocator_type &
# 176
__a = allocator_type()) : _M_h(__first, __last, __n, __hf, __eql, __a) 
# 178
{ } 
# 181
unordered_map(const unordered_map &) = default;
# 184
unordered_map(unordered_map &&) = default;
# 191
explicit unordered_map(const allocator_type &__a) : _M_h(__a) 
# 193
{ } 
# 200
unordered_map(const unordered_map &__umap, const allocator_type &
# 201
__a) : _M_h(__umap._M_h, __a) 
# 203
{ } 
# 210
unordered_map(unordered_map &&__umap, const allocator_type &
# 211
__a) noexcept(noexcept((_Hashtable(std::move(__umap._M_h), __a)))) : _M_h(std::move(__umap._M_h), __a) 
# 214
{ } 
# 227 "/usr/include/c++/9/bits/unordered_map.h" 3
unordered_map(initializer_list< value_type>  __l, size_type 
# 228
__n = 0, const hasher &
# 229
__hf = hasher(), const key_equal &
# 230
__eql = key_equal(), const allocator_type &
# 231
__a = allocator_type()) : _M_h(__l, __n, __hf, __eql, __a) 
# 233
{ } 
# 235
unordered_map(size_type __n, const allocator_type &__a) : unordered_map(__n, hasher(), key_equal(), __a) 
# 237
{ } 
# 239
unordered_map(size_type __n, const hasher &__hf, const allocator_type &
# 240
__a) : unordered_map(__n, __hf, key_equal(), __a) 
# 242
{ } 
# 244
template< class _InputIterator> 
# 245
unordered_map(_InputIterator __first, _InputIterator __last, size_type 
# 246
__n, const allocator_type &
# 247
__a) : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) 
# 249
{ } 
# 251
template< class _InputIterator> 
# 252
unordered_map(_InputIterator __first, _InputIterator __last, size_type 
# 253
__n, const hasher &__hf, const allocator_type &
# 254
__a) : unordered_map(__first, __last, __n, __hf, key_equal(), __a) 
# 256
{ } 
# 258
unordered_map(initializer_list< value_type>  __l, size_type 
# 259
__n, const allocator_type &
# 260
__a) : unordered_map(__l, __n, hasher(), key_equal(), __a) 
# 262
{ } 
# 264
unordered_map(initializer_list< value_type>  __l, size_type 
# 265
__n, const hasher &__hf, const allocator_type &
# 266
__a) : unordered_map(__l, __n, __hf, key_equal(), __a) 
# 268
{ } 
# 272
unordered_map &operator=(const unordered_map &) = default;
# 276
unordered_map &operator=(unordered_map &&) = default;
# 290 "/usr/include/c++/9/bits/unordered_map.h" 3
unordered_map &operator=(initializer_list< value_type>  __l) 
# 291
{ 
# 292
(_M_h) = __l; 
# 293
return *this; 
# 294
} 
# 298
allocator_type get_allocator() const noexcept 
# 299
{ return (_M_h).get_allocator(); } 
# 305
bool empty() const noexcept 
# 306
{ return (_M_h).empty(); } 
# 310
size_type size() const noexcept 
# 311
{ return (_M_h).size(); } 
# 315
size_type max_size() const noexcept 
# 316
{ return (_M_h).max_size(); } 
# 325
iterator begin() noexcept 
# 326
{ return (_M_h).begin(); } 
# 334
const_iterator begin() const noexcept 
# 335
{ return (_M_h).begin(); } 
# 338
const_iterator cbegin() const noexcept 
# 339
{ return (_M_h).begin(); } 
# 347
iterator end() noexcept 
# 348
{ return (_M_h).end(); } 
# 356
const_iterator end() const noexcept 
# 357
{ return (_M_h).end(); } 
# 360
const_iterator cend() const noexcept 
# 361
{ return (_M_h).end(); } 
# 386 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class ..._Args> pair< iterator, bool>  
# 388
emplace(_Args &&...__args) 
# 389
{ return (_M_h).emplace(std::forward< _Args> (__args)...); } 
# 417 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class ..._Args> iterator 
# 419
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 420
{ return (_M_h).emplace_hint(__pos, std::forward< _Args> (__args)...); } 
# 580 "/usr/include/c++/9/bits/unordered_map.h" 3
pair< iterator, bool>  insert(const value_type &__x) 
# 581
{ return (_M_h).insert(__x); } 
# 586
pair< iterator, bool>  insert(value_type &&__x) 
# 587
{ return (_M_h).insert(std::move(__x)); } 
# 589
template< class _Pair> __enable_if_t< is_constructible< value_type, _Pair &&> ::value, pair< iterator, bool> >  
# 592
insert(_Pair &&__x) 
# 593
{ return (_M_h).emplace(std::forward< _Pair> (__x)); } 
# 619 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator insert(const_iterator __hint, const value_type &__x) 
# 620
{ return (_M_h).insert(__hint, __x); } 
# 625
iterator insert(const_iterator __hint, value_type &&__x) 
# 626
{ return (_M_h).insert(__hint, std::move(__x)); } 
# 628
template< class _Pair> __enable_if_t< is_constructible< value_type, _Pair &&> ::value, iterator>  
# 630
insert(const_iterator __hint, _Pair &&__x) 
# 631
{ return (_M_h).emplace_hint(__hint, std::forward< _Pair> (__x)); } 
# 643 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class _InputIterator> void 
# 645
insert(_InputIterator __first, _InputIterator __last) 
# 646
{ (_M_h).insert(__first, __last); } 
# 656 "/usr/include/c++/9/bits/unordered_map.h" 3
void insert(initializer_list< value_type>  __l) 
# 657
{ (_M_h).insert(__l); } 
# 793 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator erase(const_iterator __position) 
# 794
{ return (_M_h).erase(__position); } 
# 798
iterator erase(iterator __position) 
# 799
{ return (_M_h).erase(__position); } 
# 815 "/usr/include/c++/9/bits/unordered_map.h" 3
size_type erase(const key_type &__x) 
# 816
{ return (_M_h).erase(__x); } 
# 833 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 834
{ return (_M_h).erase(__first, __last); } 
# 843
void clear() noexcept 
# 844
{ (_M_h).clear(); } 
# 857 "/usr/include/c++/9/bits/unordered_map.h" 3
void swap(unordered_map &__x) noexcept(noexcept((_M_h).swap(__x._M_h))) 
# 859
{ (_M_h).swap(__x._M_h); } 
# 897 "/usr/include/c++/9/bits/unordered_map.h" 3
hasher hash_function() const 
# 898
{ return (_M_h).hash_function(); } 
# 903
key_equal key_eq() const 
# 904
{ return (_M_h).key_eq(); } 
# 921 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator find(const key_type &__x) 
# 922
{ return (_M_h).find(__x); } 
# 925
const_iterator find(const key_type &__x) const 
# 926
{ return (_M_h).find(__x); } 
# 939 "/usr/include/c++/9/bits/unordered_map.h" 3
size_type count(const key_type &__x) const 
# 940
{ return (_M_h).count(__x); } 
# 963 "/usr/include/c++/9/bits/unordered_map.h" 3
pair< iterator, iterator>  equal_range(const key_type &__x) 
# 964
{ return (_M_h).equal_range(__x); } 
# 967
pair< const_iterator, const_iterator>  equal_range(const key_type &__x) const 
# 968
{ return (_M_h).equal_range(__x); } 
# 985 "/usr/include/c++/9/bits/unordered_map.h" 3
mapped_type &operator[](const key_type &__k) 
# 986
{ return (_M_h)[__k]; } 
# 989
mapped_type &operator[](key_type &&__k) 
# 990
{ return (_M_h)[std::move(__k)]; } 
# 1002 "/usr/include/c++/9/bits/unordered_map.h" 3
mapped_type &at(const key_type &__k) 
# 1003
{ return (_M_h).at(__k); } 
# 1006
const mapped_type &at(const key_type &__k) const 
# 1007
{ return (_M_h).at(__k); } 
# 1014
size_type bucket_count() const noexcept 
# 1015
{ return (_M_h).bucket_count(); } 
# 1019
size_type max_bucket_count() const noexcept 
# 1020
{ return (_M_h).max_bucket_count(); } 
# 1028
size_type bucket_size(size_type __n) const 
# 1029
{ return (_M_h).bucket_size(__n); } 
# 1037
size_type bucket(const key_type &__key) const 
# 1038
{ return (_M_h).bucket(__key); } 
# 1047
local_iterator begin(size_type __n) 
# 1048
{ return (_M_h).begin(__n); } 
# 1058 "/usr/include/c++/9/bits/unordered_map.h" 3
const_local_iterator begin(size_type __n) const 
# 1059
{ return (_M_h).begin(__n); } 
# 1062
const_local_iterator cbegin(size_type __n) const 
# 1063
{ return (_M_h).cbegin(__n); } 
# 1073 "/usr/include/c++/9/bits/unordered_map.h" 3
local_iterator end(size_type __n) 
# 1074
{ return (_M_h).end(__n); } 
# 1084 "/usr/include/c++/9/bits/unordered_map.h" 3
const_local_iterator end(size_type __n) const 
# 1085
{ return (_M_h).end(__n); } 
# 1088
const_local_iterator cend(size_type __n) const 
# 1089
{ return (_M_h).cend(__n); } 
# 1096
float load_factor() const noexcept 
# 1097
{ return (_M_h).load_factor(); } 
# 1102
float max_load_factor() const noexcept 
# 1103
{ return (_M_h).max_load_factor(); } 
# 1110
void max_load_factor(float __z) 
# 1111
{ (_M_h).max_load_factor(__z); } 
# 1121 "/usr/include/c++/9/bits/unordered_map.h" 3
void rehash(size_type __n) 
# 1122
{ (_M_h).rehash(__n); } 
# 1132 "/usr/include/c++/9/bits/unordered_map.h" 3
void reserve(size_type __n) 
# 1133
{ (_M_h).reserve(__n); } 
# 1135
template< class _Key1, class _Tp1, class _Hash1, class _Pred1, class 
# 1136
_Alloc1> friend bool 
# 1135
operator==(const std::unordered_map< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1>  &, const std::unordered_map< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1>  &); 
# 1140
}; 
# 1247 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class _Key, class _Tp, class 
# 1248
_Hash = hash< _Key> , class 
# 1249
_Pred = equal_to< _Key> , class 
# 1250
_Alloc = allocator< pair< const _Key, _Tp> > > 
# 1251
class unordered_multimap { 
# 1253
typedef __ummap_hashtable< _Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable; 
# 1254
_Hashtable _M_h; 
# 1260
public: typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::key_type key_type; 
# 1261
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::value_type value_type; 
# 1262
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::mapped_type mapped_type; 
# 1263
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::hasher hasher; 
# 1264
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::key_equal key_equal; 
# 1265
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::allocator_type allocator_type; 
# 1270
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::pointer pointer; 
# 1271
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::const_pointer const_pointer; 
# 1272
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::reference reference; 
# 1273
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::const_reference const_reference; 
# 1274
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::iterator iterator; 
# 1275
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::const_iterator const_iterator; 
# 1276
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::local_iterator local_iterator; 
# 1277
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::const_local_iterator const_local_iterator; 
# 1278
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::size_type size_type; 
# 1279
typedef typename std::_Hashtable< _Key, pair< const _Key, _Tp> , _Alloc, __detail::_Select1st, _Pred, _Hash, __detail::_Mod_range_hashing, __detail::_Default_ranged_hash, __detail::_Prime_rehash_policy, __ummap_traits< __not_< __and_< __is_fast_hash< _Hash> , __is_nothrow_invocable< const _Hash &, const _Key &> > > ::value> > ::difference_type difference_type; 
# 1289 "/usr/include/c++/9/bits/unordered_map.h" 3
unordered_multimap() = default;
# 1299 "/usr/include/c++/9/bits/unordered_map.h" 3
explicit unordered_multimap(size_type __n, const hasher &
# 1300
__hf = hasher(), const key_equal &
# 1301
__eql = key_equal(), const allocator_type &
# 1302
__a = allocator_type()) : _M_h(__n, __hf, __eql, __a) 
# 1304
{ } 
# 1319 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class _InputIterator> 
# 1320
unordered_multimap(_InputIterator __first, _InputIterator __last, size_type 
# 1321
__n = 0, const hasher &
# 1322
__hf = hasher(), const key_equal &
# 1323
__eql = key_equal(), const allocator_type &
# 1324
__a = allocator_type()) : _M_h(__first, __last, __n, __hf, __eql, __a) 
# 1326
{ } 
# 1329
unordered_multimap(const unordered_multimap &) = default;
# 1332
unordered_multimap(unordered_multimap &&) = default;
# 1339
explicit unordered_multimap(const allocator_type &__a) : _M_h(__a) 
# 1341
{ } 
# 1348
unordered_multimap(const unordered_multimap &__ummap, const allocator_type &
# 1349
__a) : _M_h(__ummap._M_h, __a) 
# 1351
{ } 
# 1358
unordered_multimap(unordered_multimap &&__ummap, const allocator_type &
# 1359
__a) noexcept(noexcept((_Hashtable(std::move(__ummap._M_h), __a)))) : _M_h(std::move(__ummap._M_h), __a) 
# 1362
{ } 
# 1375 "/usr/include/c++/9/bits/unordered_map.h" 3
unordered_multimap(initializer_list< value_type>  __l, size_type 
# 1376
__n = 0, const hasher &
# 1377
__hf = hasher(), const key_equal &
# 1378
__eql = key_equal(), const allocator_type &
# 1379
__a = allocator_type()) : _M_h(__l, __n, __hf, __eql, __a) 
# 1381
{ } 
# 1383
unordered_multimap(size_type __n, const allocator_type &__a) : unordered_multimap(__n, hasher(), key_equal(), __a) 
# 1385
{ } 
# 1387
unordered_multimap(size_type __n, const hasher &__hf, const allocator_type &
# 1388
__a) : unordered_multimap(__n, __hf, key_equal(), __a) 
# 1390
{ } 
# 1392
template< class _InputIterator> 
# 1393
unordered_multimap(_InputIterator __first, _InputIterator __last, size_type 
# 1394
__n, const allocator_type &
# 1395
__a) : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) 
# 1397
{ } 
# 1399
template< class _InputIterator> 
# 1400
unordered_multimap(_InputIterator __first, _InputIterator __last, size_type 
# 1401
__n, const hasher &__hf, const allocator_type &
# 1402
__a) : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) 
# 1404
{ } 
# 1406
unordered_multimap(initializer_list< value_type>  __l, size_type 
# 1407
__n, const allocator_type &
# 1408
__a) : unordered_multimap(__l, __n, hasher(), key_equal(), __a) 
# 1410
{ } 
# 1412
unordered_multimap(initializer_list< value_type>  __l, size_type 
# 1413
__n, const hasher &__hf, const allocator_type &
# 1414
__a) : unordered_multimap(__l, __n, __hf, key_equal(), __a) 
# 1416
{ } 
# 1420
unordered_multimap &operator=(const unordered_multimap &) = default;
# 1424
unordered_multimap &operator=(unordered_multimap &&) = default;
# 1438 "/usr/include/c++/9/bits/unordered_map.h" 3
unordered_multimap &operator=(initializer_list< value_type>  __l) 
# 1439
{ 
# 1440
(_M_h) = __l; 
# 1441
return *this; 
# 1442
} 
# 1446
allocator_type get_allocator() const noexcept 
# 1447
{ return (_M_h).get_allocator(); } 
# 1453
bool empty() const noexcept 
# 1454
{ return (_M_h).empty(); } 
# 1458
size_type size() const noexcept 
# 1459
{ return (_M_h).size(); } 
# 1463
size_type max_size() const noexcept 
# 1464
{ return (_M_h).max_size(); } 
# 1473
iterator begin() noexcept 
# 1474
{ return (_M_h).begin(); } 
# 1482
const_iterator begin() const noexcept 
# 1483
{ return (_M_h).begin(); } 
# 1486
const_iterator cbegin() const noexcept 
# 1487
{ return (_M_h).begin(); } 
# 1495
iterator end() noexcept 
# 1496
{ return (_M_h).end(); } 
# 1504
const_iterator end() const noexcept 
# 1505
{ return (_M_h).end(); } 
# 1508
const_iterator cend() const noexcept 
# 1509
{ return (_M_h).end(); } 
# 1529 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class ..._Args> iterator 
# 1531
emplace(_Args &&...__args) 
# 1532
{ return (_M_h).emplace(std::forward< _Args> (__args)...); } 
# 1556 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class ..._Args> iterator 
# 1558
emplace_hint(const_iterator __pos, _Args &&...__args) 
# 1559
{ return (_M_h).emplace_hint(__pos, std::forward< _Args> (__args)...); } 
# 1572 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator insert(const value_type &__x) 
# 1573
{ return (_M_h).insert(__x); } 
# 1576
iterator insert(value_type &&__x) 
# 1577
{ return (_M_h).insert(std::move(__x)); } 
# 1579
template< class _Pair> __enable_if_t< is_constructible< value_type, _Pair &&> ::value, iterator>  
# 1581
insert(_Pair &&__x) 
# 1582
{ return (_M_h).emplace(std::forward< _Pair> (__x)); } 
# 1606 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator insert(const_iterator __hint, const value_type &__x) 
# 1607
{ return (_M_h).insert(__hint, __x); } 
# 1612
iterator insert(const_iterator __hint, value_type &&__x) 
# 1613
{ return (_M_h).insert(__hint, std::move(__x)); } 
# 1615
template< class _Pair> __enable_if_t< is_constructible< value_type, _Pair &&> ::value, iterator>  
# 1617
insert(const_iterator __hint, _Pair &&__x) 
# 1618
{ return (_M_h).emplace_hint(__hint, std::forward< _Pair> (__x)); } 
# 1630 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class _InputIterator> void 
# 1632
insert(_InputIterator __first, _InputIterator __last) 
# 1633
{ (_M_h).insert(__first, __last); } 
# 1644 "/usr/include/c++/9/bits/unordered_map.h" 3
void insert(initializer_list< value_type>  __l) 
# 1645
{ (_M_h).insert(__l); } 
# 1687 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator erase(const_iterator __position) 
# 1688
{ return (_M_h).erase(__position); } 
# 1692
iterator erase(iterator __position) 
# 1693
{ return (_M_h).erase(__position); } 
# 1708 "/usr/include/c++/9/bits/unordered_map.h" 3
size_type erase(const key_type &__x) 
# 1709
{ return (_M_h).erase(__x); } 
# 1727 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 1728
{ return (_M_h).erase(__first, __last); } 
# 1737
void clear() noexcept 
# 1738
{ (_M_h).clear(); } 
# 1751 "/usr/include/c++/9/bits/unordered_map.h" 3
void swap(unordered_multimap &__x) noexcept(noexcept((_M_h).swap(__x._M_h))) 
# 1753
{ (_M_h).swap(__x._M_h); } 
# 1793 "/usr/include/c++/9/bits/unordered_map.h" 3
hasher hash_function() const 
# 1794
{ return (_M_h).hash_function(); } 
# 1799
key_equal key_eq() const 
# 1800
{ return (_M_h).key_eq(); } 
# 1817 "/usr/include/c++/9/bits/unordered_map.h" 3
iterator find(const key_type &__x) 
# 1818
{ return (_M_h).find(__x); } 
# 1821
const_iterator find(const key_type &__x) const 
# 1822
{ return (_M_h).find(__x); } 
# 1831
size_type count(const key_type &__x) const 
# 1832
{ return (_M_h).count(__x); } 
# 1853 "/usr/include/c++/9/bits/unordered_map.h" 3
pair< iterator, iterator>  equal_range(const key_type &__x) 
# 1854
{ return (_M_h).equal_range(__x); } 
# 1857
pair< const_iterator, const_iterator>  equal_range(const key_type &__x) const 
# 1858
{ return (_M_h).equal_range(__x); } 
# 1865
size_type bucket_count() const noexcept 
# 1866
{ return (_M_h).bucket_count(); } 
# 1870
size_type max_bucket_count() const noexcept 
# 1871
{ return (_M_h).max_bucket_count(); } 
# 1879
size_type bucket_size(size_type __n) const 
# 1880
{ return (_M_h).bucket_size(__n); } 
# 1888
size_type bucket(const key_type &__key) const 
# 1889
{ return (_M_h).bucket(__key); } 
# 1898
local_iterator begin(size_type __n) 
# 1899
{ return (_M_h).begin(__n); } 
# 1909 "/usr/include/c++/9/bits/unordered_map.h" 3
const_local_iterator begin(size_type __n) const 
# 1910
{ return (_M_h).begin(__n); } 
# 1913
const_local_iterator cbegin(size_type __n) const 
# 1914
{ return (_M_h).cbegin(__n); } 
# 1924 "/usr/include/c++/9/bits/unordered_map.h" 3
local_iterator end(size_type __n) 
# 1925
{ return (_M_h).end(__n); } 
# 1935 "/usr/include/c++/9/bits/unordered_map.h" 3
const_local_iterator end(size_type __n) const 
# 1936
{ return (_M_h).end(__n); } 
# 1939
const_local_iterator cend(size_type __n) const 
# 1940
{ return (_M_h).cend(__n); } 
# 1947
float load_factor() const noexcept 
# 1948
{ return (_M_h).load_factor(); } 
# 1953
float max_load_factor() const noexcept 
# 1954
{ return (_M_h).max_load_factor(); } 
# 1961
void max_load_factor(float __z) 
# 1962
{ (_M_h).max_load_factor(__z); } 
# 1972 "/usr/include/c++/9/bits/unordered_map.h" 3
void rehash(size_type __n) 
# 1973
{ (_M_h).rehash(__n); } 
# 1983 "/usr/include/c++/9/bits/unordered_map.h" 3
void reserve(size_type __n) 
# 1984
{ (_M_h).reserve(__n); } 
# 1986
template< class _Key1, class _Tp1, class _Hash1, class _Pred1, class 
# 1987
_Alloc1> friend bool 
# 1986
operator==(const std::unordered_multimap< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1>  &, const std::unordered_multimap< _Key1, _Tp1, _Hash1, _Pred1, _Alloc1>  &); 
# 1993
}; 
# 2077 "/usr/include/c++/9/bits/unordered_map.h" 3
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline void 
# 2079
swap(unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 2080
__y) noexcept(noexcept(__x.swap(__y))) 
# 2082
{ __x.swap(__y); } 
# 2084
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline void 
# 2086
swap(unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 2087
__y) noexcept(noexcept(__x.swap(__y))) 
# 2089
{ __x.swap(__y); } 
# 2091
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool 
# 2093
operator==(const unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, const unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 2094
__y) 
# 2095
{ return (__x._M_h)._M_equal((__y._M_h)); } 
# 2097
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool 
# 2099
operator!=(const unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, const unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 2100
__y) 
# 2101
{ return !(__x == __y); } 
# 2103
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool 
# 2105
operator==(const unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, const unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 2106
__y) 
# 2107
{ return (__x._M_h)._M_equal((__y._M_h)); } 
# 2109
template< class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> inline bool 
# 2111
operator!=(const unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &__x, const unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc>  &
# 2112
__y) 
# 2113
{ return !(__x == __y); } 
# 2168 "/usr/include/c++/9/bits/unordered_map.h" 3
}
# 61 "/usr/include/opencv4/opencv2/flann/lsh_table.h" 3
namespace cvflann { 
# 64
namespace lsh { 
# 71
typedef uint32_t FeatureIndex; 
# 74
typedef unsigned BucketKey; 
# 78
typedef std::vector< unsigned>  Bucket; 
# 84
struct LshStats { 
# 86
std::vector< unsigned>  bucket_sizes_; 
# 87
size_t n_buckets_; 
# 88
size_t bucket_size_mean_; 
# 89
size_t bucket_size_median_; 
# 90
size_t bucket_size_min_; 
# 91
size_t bucket_size_max_; 
# 92
size_t bucket_size_std_dev; 
# 95
std::vector< std::vector< unsigned> >  size_histogram_; 
# 96
}; 
# 103
inline std::ostream &operator<<(std::ostream &out, const LshStats &stats) 
# 104
{ 
# 105
int w = 20; 
# 106
(((((((((((((((((((((((((((((((((((((((((((((((((((((((out << ("Lsh Table Stats:\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("N buckets : "))) << (stats.n_buckets_))) << ("\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("mean size : "))) << (std::setiosflags(std::ios_base::left)))) << (stats.bucket_size_mean_))) << ("\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("median size : "))) << (stats.bucket_size_median_))) << ("\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("min size : "))) << (std::setiosflags(std::ios_base::left)))) << (stats.bucket_size_min_))) << ("\n"))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("max size : "))) << (std::setiosflags(std::ios_base::left)))) << (stats.bucket_size_max_)); 
# 115
(((((((((out << (std::endl))) << (std::setw(w)))) << (std::setiosflags(std::ios_base::right)))) << ("histogram : "))) << (std::setiosflags(std::ios_base::left))); 
# 117
for (std::vector< std::vector< unsigned> > ::const_iterator iterator = (stats.size_histogram_).begin(), end = (stats.size_histogram_).end(); (iterator != end); (++iterator)) { 
# 118
(((((((((((out << (((*iterator))[0]))) << ("-"))) << (((*iterator))[1]))) << (": "))) << (((*iterator))[2]))) << (",  ")); }  
# 120
return out; 
# 121
} 
# 131 "/usr/include/opencv4/opencv2/flann/lsh_table.h" 3
template< class ElementType> 
# 132
class LshTable { 
# 138
public: typedef std::unordered_map< BucketKey, Bucket>  BucketsSpace; 
# 145
typedef std::vector< std::vector< FeatureIndex> >  BucketsSpeed; 
# 149
LshTable() 
# 150
{ 
# 151
(key_size_) = (0); 
# 152
(feature_size_) = (0); 
# 153
(speed_level_) = kArray; 
# 154
} 
# 161
LshTable(unsigned feature_size, unsigned key_size) 
# 162
{ 
# 163
(feature_size_) = feature_size; 
# 164
(void)key_size; 
# 165
(((std::cerr << ("LSH is not implemented for that type"))) << (std::endl)); 
# 166
(static_cast< bool>(0)) ? (void)0 : __assert_fail("0", "/usr/include/opencv4/opencv2/flann/lsh_table.h", 166, __extension__ __PRETTY_FUNCTION__); 
# 167
} 
# 173
void add(unsigned value, const ElementType *feature) 
# 174
{ 
# 176
BucketKey key = (BucketKey)getKey(feature); 
# 178
switch (speed_level_) { 
# 179
case kArray:  
# 181
(buckets_speed_)[key].push_back(value); 
# 182
break; 
# 183
case kBitsetHash:  
# 185
(key_bitset_).set(key); 
# 186
(buckets_space_)[key].push_back(value); 
# 187
break; 
# 188
case kHash:  
# 189
{ 
# 191
(buckets_space_)[key].push_back(value); 
# 192
break; 
# 193
} 
# 194
}  
# 195
} 
# 200
void add(Matrix< ElementType>  dataset) 
# 201
{ 
# 203
(buckets_space_).rehash(((buckets_space_).size() + (dataset.rows)) * (1.2)); 
# 206
for (unsigned i = (0); i < (dataset.rows); ++i) { add(i, dataset[i]); }  
# 208
optimize(); 
# 209
} 
# 215
const Bucket *getBucketFromKey(BucketKey key) const 
# 216
{ 
# 218
switch (speed_level_) { 
# 219
case kArray:  
# 221
return &(buckets_speed_)[key]; 
# 222
break; 
# 223
case kBitsetHash:  
# 225
if ((key_bitset_).test(key)) { return &(((buckets_space_).find(key))->second); } else { 
# 226
return 0; }  
# 227
break; 
# 228
case kHash:  
# 229
{ 
# 231
std::unordered_map< unsigned, std::vector< unsigned> > ::const_iterator bucket_it, bucket_end = (buckets_space_).end(); 
# 232
bucket_it = (buckets_space_).find(key); 
# 234
if ((bucket_it == bucket_end)) { return 0; } else { 
# 235
return &(bucket_it->second); }  
# 236
break; 
# 237
} 
# 238
}  
# 239
return 0; 
# 240
} 
# 244
size_t getKey(const ElementType *) const 
# 245
{ 
# 246
(((std::cerr << ("LSH is not implemented for that type"))) << (std::endl)); 
# 247
(static_cast< bool>(0)) ? (void)0 : __assert_fail("0", "/usr/include/opencv4/opencv2/flann/lsh_table.h", 247, __extension__ __PRETTY_FUNCTION__); 
# 248
return 1; 
# 249
} 
# 254
LshStats getStats() const; 
# 262
private: enum SpeedLevel { 
# 264
kArray, kBitsetHash, kHash
# 265
}; 
# 269
void initialize(size_t key_size) 
# 270
{ 
# 271
const size_t key_size_lower_bound = (1); 
# 273
const size_t key_size_upper_bound = ((std::min)((sizeof(BucketKey) * (8)) + (1), sizeof(size_t) * (8))); 
# 274
if ((key_size < key_size_lower_bound) || (key_size >= key_size_upper_bound)) 
# 275
{ 
# 276
cv::error(cv::Error::StsBadArg, cv::format("Invalid key_size (=%d). Valid values for your system are %d <= key_size < %d.", (int)key_size, (int)key_size_lower_bound, (int)key_size_upper_bound), __func__, "/usr/include/opencv4/opencv2/flann/lsh_table.h", 276); 
# 277
}  
# 279
(speed_level_) = kHash; 
# 280
(key_size_) = ((unsigned)key_size); 
# 281
} 
# 285
void optimize() 
# 286
{ 
# 288
if ((speed_level_) == kArray) { return; }  
# 291
if ((buckets_space_).size() > ((((size_t)1) << (key_size_)) / (2))) { 
# 292
(speed_level_) = kArray; 
# 294
(buckets_speed_).resize(((size_t)1) << (key_size_)); 
# 295
for (std::unordered_map< unsigned, std::vector< unsigned> > ::const_iterator key_bucket = (buckets_space_).begin(); (key_bucket != ((buckets_space_).end())); (++key_bucket)) { (((buckets_speed_)[key_bucket->first]) = (key_bucket->second)); }  
# 298
(buckets_space_).clear(); 
# 299
return; 
# 300
}  
# 304
if ((((((std::max((buckets_space_).size(), (buckets_speed_).size()) * (8)) * (3)) * sizeof(BucketKey)) / (10)) >= (((size_t)1) << (key_size_))) || ((key_size_) <= (32))) 
# 305
{ 
# 306
(speed_level_) = kBitsetHash; 
# 307
(key_bitset_).resize(((size_t)1) << (key_size_)); 
# 308
(key_bitset_).reset(); 
# 310
for (std::unordered_map< unsigned, std::vector< unsigned> > ::const_iterator key_bucket = (buckets_space_).begin(); (key_bucket != ((buckets_space_).end())); (++key_bucket)) { (key_bitset_).set(key_bucket->first); }  
# 311
} else 
# 312
{ 
# 313
(speed_level_) = kHash; 
# 314
(key_bitset_).clear(); 
# 315
}  
# 316
} 
# 320
BucketsSpeed buckets_speed_; 
# 324
BucketsSpace buckets_space_; 
# 327
SpeedLevel speed_level_; 
# 332
DynamicBitset key_bitset_; 
# 336
unsigned key_size_; 
# 338
unsigned feature_size_; 
# 344
std::vector< size_t>  mask_; 
# 345
}; 
# 351
template<> inline LshTable< unsigned char> ::LshTable(unsigned feature_size, unsigned subsignature_size) 
# 352
{ 
# 353
(feature_size_) = feature_size; 
# 354
this->initialize(subsignature_size); 
# 356
((mask_) = std::vector< unsigned long> ((((feature_size * sizeof(char)) + sizeof(size_t)) - (1)) / sizeof(size_t), 0)); 
# 359
std::vector< int>  indices(feature_size * (8)); 
# 360
for (size_t i = (0); i < (feature_size * (8)); ++i) { indices[i] = ((int)i); }  
# 362
cv::randShuffle(indices); 
# 368
for (unsigned i = (0); i < (key_size_); ++i) { 
# 369
size_t index = indices[i]; 
# 372
size_t divisor = ((8) * sizeof(size_t)); 
# 373
size_t idx = index / divisor; 
# 374
(mask_)[idx] |= (((size_t)1) << (index % divisor)); 
# 375
}  
# 391 "/usr/include/opencv4/opencv2/flann/lsh_table.h" 3
} 
# 397
template<> inline size_t LshTable< unsigned char> ::getKey(const unsigned char *feature) const 
# 398
{ 
# 402
const size_t *feature_block_ptr = reinterpret_cast< const size_t *>((const void *)feature); 
# 407
size_t subsignature = (0); 
# 408
size_t bit_index = (1); 
# 410
for (unsigned i = (0); i < (feature_size_); i += sizeof(size_t)) { 
# 412
size_t feature_block; 
# 413
if (i <= ((feature_size_) - sizeof(size_t))) 
# 414
{ 
# 415
feature_block = (*feature_block_ptr); 
# 416
} else 
# 418
{ 
# 419
size_t tmp = (0); 
# 420
memcpy(&tmp, feature_block_ptr, (feature_size_) - i); 
# 421
feature_block = tmp; 
# 422
}  
# 423
size_t mask_block = (mask_)[i / sizeof(size_t)]; 
# 424
while (mask_block) { 
# 426
size_t lowest_bit = mask_block & (-((ptrdiff_t)mask_block)); 
# 428
subsignature += ((feature_block & lowest_bit) ? bit_index : (0)); 
# 430
mask_block ^= lowest_bit; 
# 432
bit_index <<= 1; 
# 433
}  
# 435
++feature_block_ptr; 
# 436
}  
# 437
return subsignature; 
# 438
} 
# 441
template<> inline LshStats LshTable< unsigned char> ::getStats() const 
# 442
{ 
# 443
LshStats stats; 
# 444
(stats.bucket_size_mean_) = (0); 
# 445
if ((buckets_speed_).empty() && (buckets_space_).empty()) { 
# 446
(stats.n_buckets_) = (0); 
# 447
(stats.bucket_size_median_) = (0); 
# 448
(stats.bucket_size_min_) = (0); 
# 449
(stats.bucket_size_max_) = (0); 
# 450
return stats; 
# 451
}  
# 453
if (!(buckets_speed_).empty()) { 
# 454
for (std::vector< std::vector< unsigned> > ::const_iterator pbucket = (buckets_speed_).begin(); (pbucket != ((buckets_speed_).end())); (++pbucket)) { 
# 455
(stats.bucket_sizes_).push_back((FeatureIndex)pbucket->size()); 
# 456
(stats.bucket_size_mean_) += pbucket->size(); 
# 457
}  
# 458
(stats.bucket_size_mean_) /= (buckets_speed_).size(); 
# 459
(stats.n_buckets_) = (buckets_speed_).size(); 
# 460
} else 
# 461
{ 
# 462
for (std::unordered_map< unsigned, std::vector< unsigned> > ::const_iterator x = (buckets_space_).begin(); (x != ((buckets_space_).end())); (++x)) { 
# 463
(stats.bucket_sizes_).push_back((FeatureIndex)(x->second).size()); 
# 464
(stats.bucket_size_mean_) += (x->second).size(); 
# 465
}  
# 466
(stats.bucket_size_mean_) /= (buckets_space_).size(); 
# 467
(stats.n_buckets_) = (buckets_space_).size(); 
# 468
}  
# 470
std::sort((stats.bucket_sizes_).begin(), (stats.bucket_sizes_).end()); 
# 475
(stats.bucket_size_median_) = ((stats.bucket_sizes_)[(stats.bucket_sizes_).size() / (2)]); 
# 476
(stats.bucket_size_min_) = ((stats.bucket_sizes_).front()); 
# 477
(stats.bucket_size_max_) = ((stats.bucket_sizes_).back()); 
# 485
unsigned bin_start = (0); 
# 486
unsigned bin_end = (20); 
# 487
bool is_new_bin = true; 
# 488
for (std::vector< unsigned> ::iterator iterator = (stats.bucket_sizes_).begin(), end = (stats.bucket_sizes_).end(); (iterator != end);) { 
# 490
if ((*iterator) < bin_end) { 
# 491
if (is_new_bin) { 
# 492
(stats.size_histogram_).push_back(std::vector< unsigned> (3, 0)); 
# 493
((stats.size_histogram_).back())[0] = bin_start; 
# 494
((stats.size_histogram_).back())[1] = (bin_end - (1)); 
# 495
is_new_bin = false; 
# 496
}  
# 497
++((stats.size_histogram_).back())[2]; 
# 498
(++iterator); 
# 499
} else 
# 500
{ 
# 501
bin_start += (20); 
# 502
bin_end += (20); 
# 503
is_new_bin = true; 
# 504
}  }  
# 506
return stats; 
# 507
} 
# 510
}
# 511
}
# 56 "/usr/include/opencv4/opencv2/flann/lsh_index.h" 3
namespace cvflann { 
# 59
struct LshIndexParams : public IndexParams { 
# 61
LshIndexParams(unsigned table_number = 12, unsigned key_size = 20, unsigned multi_probe_level = 2) 
# 62
{ 
# 63
(((*this)["algorithm"]) = (FLANN_INDEX_LSH)); 
# 65
(((*this)["table_number"]) = table_number); 
# 67
(((*this)["key_size"]) = key_size); 
# 69
(((*this)["multi_probe_level"]) = multi_probe_level); 
# 70
} 
# 71
}; 
# 79
template< class Distance> 
# 80
class LshIndex : public NNIndex< Distance>  { 
# 83
public: typedef typename Distance::ElementType ElementType; 
# 84
typedef typename Distance::ResultType DistanceType; 
# 91
LshIndex(const Matrix< ElementType>  &input_data, const cvflann::IndexParams &params = cvflann::LshIndexParams(), Distance 
# 92
d = Distance()) : dataset_(input_data), index_params_(params), distance_(d) 
# 94
{ 
# 97
(table_number_) = ((unsigned)get_param< int> (index_params_, "table_number", 12)); 
# 98
(key_size_) = ((unsigned)get_param< int> (index_params_, "key_size", 20)); 
# 99
(multi_probe_level_) = ((unsigned)get_param< int> (index_params_, "multi_probe_level", 2)); 
# 101
(feature_size_) = ((unsigned)((dataset_).cols)); 
# 102
fill_xor_mask(0, key_size_, multi_probe_level_, xor_masks_); 
# 103
} 
# 106
LshIndex(const LshIndex &); 
# 107
LshIndex &operator=(const LshIndex &); 
# 112
void buildIndex() override 
# 113
{ 
# 114
(tables_).resize(table_number_); 
# 115
for (unsigned i = (0); i < (table_number_); ++i) { 
# 116
lsh::LshTable< typename Distance::ElementType>  &table = (tables_)[i]; 
# 117
table = lsh::LshTable< typename Distance::ElementType> (feature_size_, key_size_); 
# 120
table.add(dataset_); 
# 121
}  
# 122
} 
# 124
cvflann::flann_algorithm_t getType() const override 
# 125
{ 
# 126
return FLANN_INDEX_LSH; 
# 127
} 
# 130
void saveIndex(::FILE *stream) override 
# 131
{ 
# 132
save_value(stream, table_number_); 
# 133
save_value(stream, key_size_); 
# 134
save_value(stream, multi_probe_level_); 
# 135
save_value(stream, dataset_); 
# 136
} 
# 138
void loadIndex(::FILE *stream) override 
# 139
{ 
# 140
load_value(stream, table_number_); 
# 141
load_value(stream, key_size_); 
# 142
load_value(stream, multi_probe_level_); 
# 143
load_value(stream, dataset_); 
# 145
buildIndex(); 
# 147
(index_params_)["algorithm"] = getType(); 
# 148
(((index_params_)["table_number"]) = (table_number_)); 
# 149
(((index_params_)["key_size"]) = (key_size_)); 
# 150
(((index_params_)["multi_probe_level"]) = (multi_probe_level_)); 
# 151
} 
# 156
::size_t size() const override 
# 157
{ 
# 158
return (dataset_).rows; 
# 159
} 
# 164
::size_t veclen() const override 
# 165
{ 
# 166
return feature_size_; 
# 167
} 
# 173
int usedMemory() const override 
# 174
{ 
# 175
return (int)(((dataset_).rows) * sizeof(int)); 
# 176
} 
# 179
cvflann::IndexParams getParameters() const override 
# 180
{ 
# 181
return index_params_; 
# 182
} 
# 192 "/usr/include/opencv4/opencv2/flann/lsh_index.h" 3
virtual void knnSearch(const Matrix< ElementType>  &queries, cvflann::Matrix< int>  &indices, Matrix< DistanceType>  &dists, int knn, const cvflann::SearchParams &params) override 
# 193
{ 
# 194
(static_cast< bool>((queries.cols) == veclen())) ? (void)0 : __assert_fail("queries.cols == veclen()", "/usr/include/opencv4/opencv2/flann/lsh_index.h", 194, __extension__ __PRETTY_FUNCTION__); 
# 195
(static_cast< bool>((indices.rows) >= (queries.rows))) ? (void)0 : __assert_fail("indices.rows >= queries.rows", "/usr/include/opencv4/opencv2/flann/lsh_index.h", 195, __extension__ __PRETTY_FUNCTION__); 
# 196
(static_cast< bool>((dists.rows) >= (queries.rows))) ? (void)0 : __assert_fail("dists.rows >= queries.rows", "/usr/include/opencv4/opencv2/flann/lsh_index.h", 196, __extension__ __PRETTY_FUNCTION__); 
# 197
(static_cast< bool>(((int)(indices.cols)) >= knn)) ? (void)0 : __assert_fail("int(indices.cols) >= knn", "/usr/include/opencv4/opencv2/flann/lsh_index.h", 197, __extension__ __PRETTY_FUNCTION__); 
# 198
(static_cast< bool>(((int)(dists.cols)) >= knn)) ? (void)0 : __assert_fail("int(dists.cols) >= knn", "/usr/include/opencv4/opencv2/flann/lsh_index.h", 198, __extension__ __PRETTY_FUNCTION__); 
# 201
KNNUniqueResultSet< DistanceType>  resultSet(knn); 
# 202
for (::size_t i = (0); i < (queries.rows); i++) { 
# 203
resultSet.clear(); 
# 204
std::fill_n(indices[i], knn, -1); 
# 205
std::fill_n(dists[i], knn, std::template numeric_limits< typename Distance::ResultType> ::max()); 
# 206
findNeighbors(resultSet, queries[i], params); 
# 207
if (get_param(params, "sorted", true)) { resultSet.sortAndCopy(indices[i], dists[i], knn); } else { 
# 208
resultSet.copy(indices[i], dists[i], knn); }  
# 209
}  
# 210
} 
# 222 "/usr/include/opencv4/opencv2/flann/lsh_index.h" 3
void findNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, const cvflann::SearchParams &) override 
# 223
{ 
# 224
getNeighbors(vec, result); 
# 225
} 
# 230
private: typedef std::pair< float, unsigned>  ScoreIndexPair; 
# 231
struct SortScoreIndexPairOnSecond { 
# 233
bool operator()(const ScoreIndexPair &left, const ScoreIndexPair &right) const 
# 234
{ 
# 235
return (left.second) < (right.second); 
# 236
} 
# 237
}; 
# 245
void fill_xor_mask(lsh::BucketKey key, int lowest_index, unsigned level, std::vector< lsh::FeatureIndex>  &
# 246
xor_masks) 
# 247
{ 
# 248
xor_masks.push_back(key); 
# 249
if (level == (0)) { return; }  
# 250
for (int index = lowest_index - 1; index >= 0; --index) { 
# 252
lsh::BucketKey new_key = key | (1 << index); 
# 253
fill_xor_mask(new_key, index, level - (1), xor_masks); 
# 254
}  
# 255
} 
# 265 "/usr/include/opencv4/opencv2/flann/lsh_index.h" 3
void getNeighbors(const ElementType *vec, bool, float radius, bool do_k, unsigned k_nn, float &) 
# 267
{ 
# 268
static std::vector< std::pair< float, unsigned> >  score_index_heap; 
# 270
if (do_k) { 
# 271
unsigned worst_score = std::numeric_limits< unsigned> ::max(); 
# 272
typename std::vector< lsh::LshTable< typename Distance::ElementType> > ::const_iterator table = (tables_).begin(); 
# 273
typename std::vector< lsh::LshTable< typename Distance::ElementType> > ::const_iterator table_end = (tables_).end(); 
# 274
for (; table != table_end; ++table) { 
# 275
::size_t key = (table->getKey)(vec); 
# 276
std::vector< unsigned> ::const_iterator xor_mask = (xor_masks_).begin(); 
# 277
std::vector< unsigned> ::const_iterator xor_mask_end = (xor_masks_).end(); 
# 278
for (; (xor_mask != xor_mask_end); (++xor_mask)) { 
# 279
::size_t sub_key = key ^ ((*xor_mask)); 
# 280
const lsh::Bucket *bucket = (table->getBucketFromKey)(sub_key); 
# 281
if (bucket == (0)) { continue; }  
# 284
std::vector< unsigned> ::const_iterator training_index = bucket->begin(); 
# 285
std::vector< unsigned> ::const_iterator last_training_index = bucket->end(); 
# 286
DistanceType hamming_distance; 
# 289
for (; (training_index < last_training_index); (++training_index)) { 
# 290
hamming_distance = (distance_)(vec, (dataset_)[(*training_index)], ((dataset_).cols)); 
# 292
if (hamming_distance < worst_score) { 
# 294
score_index_heap.push_back(ScoreIndexPair(hamming_distance, training_index)); 
# 295
std::push_heap(score_index_heap.begin(), score_index_heap.end()); 
# 297
if (score_index_heap.size() > ((unsigned)k_nn)) { 
# 299
std::pop_heap(score_index_heap.begin(), score_index_heap.end()); 
# 300
score_index_heap.pop_back(); 
# 302
worst_score = (score_index_heap.front().first); 
# 303
}  
# 304
}  
# 305
}  
# 306
}   
# 307
}  
# 308
} else 
# 309
{ 
# 310
typename std::vector< lsh::LshTable< typename Distance::ElementType> > ::const_iterator table = (tables_).begin(); 
# 311
typename std::vector< lsh::LshTable< typename Distance::ElementType> > ::const_iterator table_end = (tables_).end(); 
# 312
for (; table != table_end; ++table) { 
# 313
::size_t key = (table->getKey)(vec); 
# 314
std::vector< unsigned> ::const_iterator xor_mask = (xor_masks_).begin(); 
# 315
std::vector< unsigned> ::const_iterator xor_mask_end = (xor_masks_).end(); 
# 316
for (; (xor_mask != xor_mask_end); (++xor_mask)) { 
# 317
::size_t sub_key = key ^ ((*xor_mask)); 
# 318
const lsh::Bucket *bucket = (table->getBucketFromKey)(sub_key); 
# 319
if (bucket == (0)) { continue; }  
# 322
std::vector< unsigned> ::const_iterator training_index = bucket->begin(); 
# 323
std::vector< unsigned> ::const_iterator last_training_index = bucket->end(); 
# 324
DistanceType hamming_distance; 
# 327
for (; (training_index < last_training_index); (++training_index)) { 
# 329
hamming_distance = (distance_)(vec, (dataset_)[(*training_index)], ((dataset_).cols)); 
# 330
if (hamming_distance < radius) { score_index_heap.push_back(ScoreIndexPair(hamming_distance, training_index)); }  
# 331
}  
# 332
}   
# 333
}  
# 334
}  
# 335
} 
# 341
void getNeighbors(const ElementType *vec, ResultSet< DistanceType>  &result) 
# 342
{ 
# 343
typename std::vector< lsh::LshTable< ElementType> > ::const_iterator table = (tables_).begin(); 
# 344
typename std::vector< lsh::LshTable< ElementType> > ::const_iterator table_end = (tables_).end(); 
# 345
for (; table != table_end; ++table) { 
# 346
::size_t key = (table->getKey)(vec); 
# 347
std::vector< unsigned> ::const_iterator xor_mask = (xor_masks_).begin(); 
# 348
std::vector< unsigned> ::const_iterator xor_mask_end = (xor_masks_).end(); 
# 349
for (; (xor_mask != xor_mask_end); (++xor_mask)) { 
# 350
::size_t sub_key = key ^ ((*xor_mask)); 
# 351
const lsh::Bucket *bucket = (table->getBucketFromKey)((lsh::BucketKey)sub_key); 
# 352
if (bucket == (0)) { continue; }  
# 355
std::vector< unsigned> ::const_iterator training_index = bucket->begin(); 
# 356
std::vector< unsigned> ::const_iterator last_training_index = bucket->end(); 
# 357
DistanceType hamming_distance; 
# 360
for (; (training_index < last_training_index); (++training_index)) { 
# 362
hamming_distance = (distance_)(vec, (dataset_)[(*training_index)], (int)((dataset_).cols)); 
# 363
result.addPoint(hamming_distance, (*training_index)); 
# 364
}  
# 365
}   
# 366
}  
# 367
} 
# 370
std::vector< lsh::LshTable< ElementType> >  tables_; 
# 373
Matrix< ElementType>  dataset_; 
# 376
unsigned feature_size_; 
# 378
cvflann::IndexParams index_params_; 
# 381
unsigned table_number_; 
# 383
unsigned key_size_; 
# 385
unsigned multi_probe_level_; 
# 388
std::vector< lsh::FeatureIndex>  xor_masks_; 
# 390
Distance distance_; 
# 391
}; 
# 392
}
# 40 "/usr/include/opencv4/opencv2/flann/ground_truth.h" 3
namespace cvflann { 
# 43
template< class Distance> void 
# 44
find_nearest(const Matrix< typename Distance::ElementType>  &dataset, typename Distance::ElementType *query, int *matches, int nn, int 
# 45
skip = 0, Distance distance = Distance()) 
# 46
{ 
# 47
typedef typename Distance::ResultType DistanceType; 
# 48
int n = nn + skip; 
# 50
std::vector< int>  match(n); 
# 51
std::vector< typename Distance::ResultType>  dists(n); 
# 53
(dists[0]) = distance(dataset[0], query, (dataset.cols)); 
# 54
match[0] = 0; 
# 55
int dcnt = 1; 
# 57
for (size_t i = (1); i < (dataset.rows); ++i) { 
# 58
DistanceType tmp = distance(dataset[i], query, (dataset.cols)); 
# 60
if (dcnt < n) { 
# 61
match[dcnt] = ((int)i); 
# 62
(dists[dcnt++]) = tmp; 
# 63
} else { 
# 64
if (tmp < (dists[dcnt - 1])) { 
# 65
(dists[dcnt - 1]) = tmp; 
# 66
match[dcnt - 1] = ((int)i); 
# 67
}  }  
# 69
int j = dcnt - 1; 
# 71
while ((j >= 1) && ((dists[j]) < (dists[j - 1]))) { 
# 72
std::swap(dists[j], dists[j - 1]); 
# 73
std::swap(match[j], match[j - 1]); 
# 74
j--; 
# 75
}  
# 76
}  
# 78
for (int i = 0; i < nn; ++i) { 
# 79
(matches[i]) = match[i + skip]; 
# 80
}  
# 81
} 
# 84
template< class Distance> void 
# 85
compute_ground_truth(const Matrix< typename Distance::ElementType>  &dataset, const Matrix< typename Distance::ElementType>  &testset, Matrix< int>  &matches, int 
# 86
skip = 0, Distance d = Distance()) 
# 87
{ 
# 88
for (size_t i = (0); i < (testset.rows); ++i) { 
# 89
find_nearest< Distance> (dataset, testset[i], matches[i], (int)(matches.cols), skip, d); 
# 90
}  
# 91
} 
# 94
}
# 40 "/usr/include/opencv4/opencv2/flann/timer.h" 3
namespace cvflann { 
# 48
class StartStopTimer { 
# 50
int64 startTime; 
# 56
public: double value; 
# 62
StartStopTimer() 
# 63
{ 
# 64
this->reset(); 
# 65
} 
# 70
void start() 
# 71
{ 
# 72
(startTime) = cv::getTickCount(); 
# 73
} 
# 78
void stop() 
# 79
{ 
# 80
int64 stopTime = cv::getTickCount(); 
# 81
(value) += ((((double)stopTime) - (startTime)) / cv::getTickFrequency()); 
# 82
} 
# 87
void reset() 
# 88
{ 
# 89
(value) = (0); 
# 90
} 
# 92
}; 
# 94
}
# 47 "/usr/include/opencv4/opencv2/flann/index_testing.h" 3
namespace cvflann { 
# 50
inline int countCorrectMatches(int *neighbors, int *groundTruth, int n) 
# 51
{ 
# 52
int count = 0; 
# 53
for (int i = 0; i < n; ++i) { 
# 54
for (int k = 0; k < n; ++k) { 
# 55
if ((neighbors[i]) == (groundTruth[k])) { 
# 56
count++; 
# 57
break; 
# 58
}  
# 59
}  
# 60
}  
# 61
return count; 
# 62
} 
# 65
template< class Distance> typename Distance::ResultType 
# 66
computeDistanceRaport(const Matrix< typename Distance::ElementType>  &inputData, typename Distance::ElementType *target, int *
# 67
neighbors, int *groundTruth, int veclen, int n, const Distance &distance) 
# 68
{ 
# 69
typedef typename Distance::ResultType DistanceType; 
# 71
DistanceType ret = (0); 
# 72
for (int i = 0; i < n; ++i) { 
# 73
DistanceType den = distance(inputData[groundTruth[i]], target, veclen); 
# 74
DistanceType num = distance(inputData[neighbors[i]], target, veclen); 
# 76
if ((den == 0) && (num == 0)) { 
# 77
ret += 1; 
# 78
} else 
# 79
{ 
# 80
ret += (num / den); 
# 81
}  
# 82
}  
# 84
return ret; 
# 85
} 
# 87
template< class Distance> float 
# 88
search_with_ground_truth(NNIndex< Distance>  &index, const Matrix< typename Distance::ElementType>  &inputData, const Matrix< typename Distance::ElementType>  &
# 89
testData, const Matrix< int>  &matches, int nn, int checks, float &
# 90
time, typename Distance::ResultType &dist, const Distance &distance, int skipMatches) 
# 91
{ 
# 92
typedef typename Distance::ResultType DistanceType; 
# 94
if ((matches.cols) < ((size_t)nn)) { 
# 95
Logger::info("matches.cols=%d, nn=%d\n", matches.cols, nn); 
# 97
throw ((FLANNException)("Ground truth is not computed for as many neighbors as requested")); 
# 98
}  
# 100
KNNResultSet< typename Distance::ResultType>  resultSet(nn + skipMatches); 
# 101
SearchParams searchParams(checks); 
# 103
std::vector< int>  indices(nn + skipMatches); 
# 104
std::vector< typename Distance::ResultType>  dists(nn + skipMatches); 
# 105
int *neighbors = &indices[skipMatches]; 
# 107
int correct = 0; 
# 108
DistanceType distR = (0); 
# 109
StartStopTimer t; 
# 110
int repeats = 0; 
# 111
while ((t.value) < (0.2)) { 
# 112
repeats++; 
# 113
t.start(); 
# 114
correct = 0; 
# 115
distR = 0; 
# 116
for (size_t i = (0); i < (testData.rows); i++) { 
# 117
resultSet.init(&indices[0], &(dists[0])); 
# 118
index.findNeighbors(resultSet, testData[i], searchParams); 
# 120
correct += countCorrectMatches(neighbors, matches[i], nn); 
# 121
distR += computeDistanceRaport< Distance> (inputData, testData[i], neighbors, matches[i], (int)(testData.cols), nn, distance); 
# 122
}  
# 123
t.stop(); 
# 124
}  
# 125
time = ((float)((t.value) / repeats)); 
# 127
float precicion = ((float)correct) / (nn * (testData.rows)); 
# 129
dist = (distR / ((testData.rows) * nn)); 
# 131
Logger::info("%8d %10.4g %10.5g %10.5g %10.5g\n", checks, precicion, time, ((1000.0) * time) / (testData.rows), dist); 
# 134
return precicion; 
# 135
} 
# 138
template< class Distance> float 
# 139
test_index_checks(NNIndex< Distance>  &index, const Matrix< typename Distance::ElementType>  &inputData, const Matrix< typename Distance::ElementType>  &
# 140
testData, const Matrix< int>  &matches, int 
# 141
checks, float &precision, const Distance &distance, int nn = 1, int skipMatches = 0) 
# 142
{ 
# 143
typedef typename Distance::ResultType DistanceType; 
# 145
Logger::info("  Nodes  Precision(%)   Time(s)   Time/vec(ms)  Mean dist\n"); 
# 146
Logger::info("---------------------------------------------------------\n"); 
# 148
float time = (0); 
# 149
DistanceType dist = (0); 
# 150
precision = search_with_ground_truth(index, inputData, testData, matches, nn, checks, time, dist, distance, skipMatches); 
# 152
return time; 
# 153
} 
# 155
template< class Distance> float 
# 156
test_index_precision(NNIndex< Distance>  &index, const Matrix< typename Distance::ElementType>  &inputData, const Matrix< typename Distance::ElementType>  &
# 157
testData, const Matrix< int>  &matches, float 
# 158
precision, int &checks, const Distance &distance, int nn = 1, int skipMatches = 0) 
# 159
{ 
# 160
typedef typename Distance::ResultType DistanceType; 
# 161
const float SEARCH_EPS = (0.001F); 
# 163
Logger::info("  Nodes  Precision(%)   Time(s)   Time/vec(ms)  Mean dist\n"); 
# 164
Logger::info("---------------------------------------------------------\n"); 
# 166
int c2 = 1; 
# 167
float p2; 
# 168
int c1 = 1; 
# 170
float time; 
# 171
DistanceType dist; 
# 173
p2 = search_with_ground_truth(index, inputData, testData, matches, nn, c2, time, dist, distance, skipMatches); 
# 175
if (p2 > precision) { 
# 176
Logger::info("Got as close as I can\n"); 
# 177
checks = c2; 
# 178
return time; 
# 179
}  
# 181
while (p2 < precision) { 
# 182
c1 = c2; 
# 184
c2 *= 2; 
# 185
p2 = search_with_ground_truth(index, inputData, testData, matches, nn, c2, time, dist, distance, skipMatches); 
# 186
}  
# 188
int cx; 
# 189
float realPrecision; 
# 190
if (fabs(p2 - precision) > SEARCH_EPS) { 
# 191
Logger::info("Start linear estimation\n"); 
# 195
cx = ((c1 + c2) / 2); 
# 196
realPrecision = search_with_ground_truth(index, inputData, testData, matches, nn, cx, time, dist, distance, skipMatches); 
# 197
while (fabs(realPrecision - precision) > SEARCH_EPS) { 
# 199
if (realPrecision < precision) { 
# 200
c1 = cx; 
# 201
} else 
# 202
{ 
# 203
c2 = cx; 
# 204
}  
# 205
cx = ((c1 + c2) / 2); 
# 206
if (cx == c1) { 
# 207
Logger::info("Got as close as I can\n"); 
# 208
break; 
# 209
}  
# 210
realPrecision = search_with_ground_truth(index, inputData, testData, matches, nn, cx, time, dist, distance, skipMatches); 
# 211
}  
# 213
c2 = cx; 
# 214
p2 = realPrecision; 
# 216
} else 
# 217
{ 
# 218
Logger::info("No need for linear estimation\n"); 
# 219
cx = c2; 
# 220
realPrecision = p2; 
# 221
}  
# 223
checks = cx; 
# 224
return time; 
# 225
} 
# 228
template< class Distance> void 
# 229
test_index_precisions(NNIndex< Distance>  &index, const Matrix< typename Distance::ElementType>  &inputData, const Matrix< typename Distance::ElementType>  &
# 230
testData, const Matrix< int>  &matches, float *
# 231
precisions, int precisions_length, const Distance &distance, int nn = 1, int skipMatches = 0, float maxTime = 0) 
# 232
{ 
# 233
typedef typename Distance::ResultType DistanceType; 
# 235
const float SEARCH_EPS = ((0.001)); 
# 238
std::sort(precisions, precisions + precisions_length); 
# 240
int pindex = 0; 
# 241
float precision = precisions[pindex]; 
# 243
Logger::info("  Nodes  Precision(%)   Time(s)   Time/vec(ms)  Mean dist\n"); 
# 244
Logger::info("---------------------------------------------------------\n"); 
# 246
int c2 = 1; 
# 247
float p2; 
# 249
int c1 = 1; 
# 250
float p1; 
# 252
float time; 
# 253
DistanceType dist; 
# 255
p2 = search_with_ground_truth(index, inputData, testData, matches, nn, c2, time, dist, distance, skipMatches); 
# 260
while (((precisions[pindex]) < p2) && (pindex < precisions_length)) { 
# 261
pindex++; 
# 262
}  
# 264
if (pindex == precisions_length) { 
# 265
Logger::info("Got as close as I can\n"); 
# 266
return; 
# 267
}  
# 269
for (int i = pindex; i < precisions_length; ++i) { 
# 271
precision = (precisions[i]); 
# 272
while (p2 < precision) { 
# 273
c1 = c2; 
# 274
p1 = p2; 
# 275
c2 *= 2; 
# 276
p2 = search_with_ground_truth(index, inputData, testData, matches, nn, c2, time, dist, distance, skipMatches); 
# 277
if ((maxTime > (0)) && (time > maxTime) && (p2 < precision)) { return; }  
# 278
}  
# 280
int cx; 
# 281
float realPrecision; 
# 282
if (fabs(p2 - precision) > SEARCH_EPS) { 
# 283
Logger::info("Start linear estimation\n"); 
# 287
cx = ((c1 + c2) / 2); 
# 288
realPrecision = search_with_ground_truth(index, inputData, testData, matches, nn, cx, time, dist, distance, skipMatches); 
# 289
while (fabs(realPrecision - precision) > SEARCH_EPS) { 
# 291
if (realPrecision < precision) { 
# 292
c1 = cx; 
# 293
} else 
# 294
{ 
# 295
c2 = cx; 
# 296
}  
# 297
cx = ((c1 + c2) / 2); 
# 298
if (cx == c1) { 
# 299
Logger::info("Got as close as I can\n"); 
# 300
break; 
# 301
}  
# 302
realPrecision = search_with_ground_truth(index, inputData, testData, matches, nn, cx, time, dist, distance, skipMatches); 
# 303
}  
# 305
c2 = cx; 
# 306
p2 = realPrecision; 
# 308
} else 
# 309
{ 
# 310
Logger::info("No need for linear estimation\n"); 
# 311
cx = c2; 
# 312
realPrecision = p2; 
# 313
}  
# 315
}  
# 316
} 
# 318
}
# 38 "/usr/include/opencv4/opencv2/flann/sampling.h" 3
namespace cvflann { 
# 41
template< class T> Matrix< T>  
# 42
random_sample(Matrix< T>  &srcMatrix, long size, bool remove = false) 
# 43
{ 
# 44
Matrix< T>  newSet(new T [size * (srcMatrix.cols)], size, (srcMatrix.cols)); 
# 46
T *src, *dest; 
# 47
for (long i = (0); i < size; ++i) { 
# 48
long r = rand_int((int)((srcMatrix.rows) - i)); 
# 49
dest = (newSet[i]); 
# 50
src = (srcMatrix[r]); 
# 51
std::copy(src, src + (srcMatrix.cols), dest); 
# 52
if (remove) { 
# 53
src = (srcMatrix[((srcMatrix.rows) - i) - 1]); 
# 54
dest = (srcMatrix[r]); 
# 55
std::copy(src, src + (srcMatrix.cols), dest); 
# 56
}  
# 57
}  
# 58
if (remove) { 
# 59
(srcMatrix.rows) -= size; 
# 60
}  
# 61
return newSet; 
# 62
} 
# 64
template< class T> Matrix< T>  
# 65
random_sample(const Matrix< T>  &srcMatrix, size_t size) 
# 66
{ 
# 67
UniqueRandom rand((int)(srcMatrix.rows)); 
# 68
Matrix< T>  newSet(new T [size * (srcMatrix.cols)], size, (srcMatrix.cols)); 
# 70
T *src, *dest; 
# 71
for (size_t i = (0); i < size; ++i) { 
# 72
long r = rand.next(); 
# 73
dest = (newSet[i]); 
# 74
src = (srcMatrix[r]); 
# 75
std::copy(src, src + (srcMatrix.cols), dest); 
# 76
}  
# 77
return newSet; 
# 78
} 
# 80
}
# 49 "/usr/include/opencv4/opencv2/flann/autotuned_index.h" 3
namespace cvflann { 
# 52
template< class Distance> NNIndex< Distance>  *create_index_by_type(const Matrix< typename Distance::ElementType>  & dataset, const IndexParams & params, const Distance & distance); 
# 56
struct AutotunedIndexParams : public IndexParams { 
# 58
AutotunedIndexParams(float target_precision = (0.8), float build_weight = (0.01), float memory_weight = 0, float sample_fraction = (0.1)) 
# 59
{ 
# 60
(((*this)["algorithm"]) = (FLANN_INDEX_AUTOTUNED)); 
# 62
(((*this)["target_precision"]) = target_precision); 
# 64
(((*this)["build_weight"]) = build_weight); 
# 66
(((*this)["memory_weight"]) = memory_weight); 
# 68
(((*this)["sample_fraction"]) = sample_fraction); 
# 69
} 
# 70
}; 
# 73
template< class Distance> 
# 74
class AutotunedIndex : public NNIndex< Distance>  { 
# 77
public: typedef typename Distance::ElementType ElementType; 
# 78
typedef typename Distance::ResultType DistanceType; 
# 80
AutotunedIndex(const Matrix< ElementType>  &inputData, const cvflann::IndexParams &params = cvflann::AutotunedIndexParams(), Distance d = Distance()) : dataset_(inputData), distance_(d) 
# 82
{ 
# 83
(target_precision_) = get_param(params, "target_precision", (0.8F)); 
# 84
(build_weight_) = get_param(params, "build_weight", (0.01F)); 
# 85
(memory_weight_) = get_param(params, "memory_weight", (0.0F)); 
# 86
(sample_fraction_) = get_param(params, "sample_fraction", (0.1F)); 
# 87
(bestIndex_) = __null; 
# 88
(speedup_) = (0); 
# 89
} 
# 91
AutotunedIndex(const AutotunedIndex &); 
# 92
AutotunedIndex &operator=(const AutotunedIndex &); 
# 94
virtual ~AutotunedIndex() 
# 95
{ 
# 96
if ((bestIndex_) != __null) { 
# 97
delete (bestIndex_); 
# 98
(bestIndex_) = __null; 
# 99
}  
# 100
} 
# 105
virtual void buildIndex() override 
# 106
{ 
# 107
std::ostringstream stream; 
# 108
(bestParams_) = estimateBuildParams(); 
# 109
print_params(bestParams_, stream); 
# 110
Logger::info("----------------------------------------------------\n"); 
# 111
Logger::info("Autotuned parameters:\n"); 
# 112
Logger::info("%s", (stream.str()).c_str()); 
# 113
Logger::info("----------------------------------------------------\n"); 
# 115
(bestIndex_) = create_index_by_type(dataset_, bestParams_, distance_); 
# 116
(bestIndex_)->buildIndex(); 
# 117
(speedup_) = estimateSearchParams(bestSearchParams_); 
# 118
stream.str(std::string()); 
# 119
print_params(bestSearchParams_, stream); 
# 120
Logger::info("----------------------------------------------------\n"); 
# 121
Logger::info("Search parameters:\n"); 
# 122
Logger::info("%s", (stream.str()).c_str()); 
# 123
Logger::info("----------------------------------------------------\n"); 
# 124
} 
# 129
virtual void saveIndex(::FILE *stream) override 
# 130
{ 
# 131
save_value(stream, (int)(bestIndex_)->getType()); 
# 132
(bestIndex_)->saveIndex(stream); 
# 133
save_value(stream, get_param< int> (bestSearchParams_, "checks")); 
# 134
} 
# 139
virtual void loadIndex(::FILE *stream) override 
# 140
{ 
# 141
int index_type; 
# 143
load_value(stream, index_type); 
# 144
cvflann::IndexParams params; 
# 145
((params["algorithm"]) = ((cvflann::flann_algorithm_t)index_type)); 
# 146
(bestIndex_) = create_index_by_type< Distance> (dataset_, params, distance_); 
# 147
(bestIndex_)->loadIndex(stream); 
# 148
int checks; 
# 149
load_value(stream, checks); 
# 150
(((bestSearchParams_)["checks"]) = checks); 
# 151
} 
# 156
virtual void findNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, const cvflann::SearchParams &searchParams) override 
# 157
{ 
# 158
int checks = get_param< int> (searchParams, "checks", FLANN_CHECKS_AUTOTUNED); 
# 159
if (checks == (FLANN_CHECKS_AUTOTUNED)) { 
# 160
(bestIndex_)->findNeighbors(result, vec, bestSearchParams_); 
# 161
} else 
# 162
{ 
# 163
(bestIndex_)->findNeighbors(result, vec, searchParams); 
# 164
}  
# 165
} 
# 168
cvflann::IndexParams getParameters() const override 
# 169
{ 
# 170
return (bestIndex_)->getParameters(); 
# 171
} 
# 173
cvflann::SearchParams getSearchParameters() const 
# 174
{ 
# 175
return bestSearchParams_; 
# 176
} 
# 178
float getSpeedup() const 
# 179
{ 
# 180
return speedup_; 
# 181
} 
# 187
virtual ::size_t size() const override 
# 188
{ 
# 189
return (bestIndex_)->size(); 
# 190
} 
# 195
virtual ::size_t veclen() const override 
# 196
{ 
# 197
return (bestIndex_)->veclen(); 
# 198
} 
# 203
virtual int usedMemory() const override 
# 204
{ 
# 205
return (bestIndex_)->usedMemory(); 
# 206
} 
# 211
virtual cvflann::flann_algorithm_t getType() const override 
# 212
{ 
# 213
return FLANN_INDEX_AUTOTUNED; 
# 214
} 
# 218
private: struct CostData { 
# 220
float searchTimeCost; 
# 221
float buildTimeCost; 
# 222
float memoryCost; 
# 223
float totalCost; 
# 224
cvflann::IndexParams params; 
# 225
}; 
# 227
void evaluate_kmeans(CostData &cost) 
# 228
{ 
# 229
cvflann::StartStopTimer t; 
# 230
int checks; 
# 231
const int nn = 1; 
# 233
Logger::info("KMeansTree using params: max_iterations=%d, branching=%d\n", get_param< int> ((cost.params), "iterations"), get_param< int> ((cost.params), "branching")); 
# 236
KMeansIndex< Distance>  kmeans(sampledDataset_, (cost.params), distance_); 
# 238
t.start(); 
# 239
kmeans.buildIndex(); 
# 240
t.stop(); 
# 241
float buildTime = (float)(t.value); 
# 244
float searchTime = test_index_precision(kmeans, sampledDataset_, testDataset_, gt_matches_, target_precision_, checks, distance_, nn); 
# 246
float datasetMemory = (float)((((sampledDataset_).rows) * ((sampledDataset_).cols)) * sizeof(float)); 
# 247
(cost.memoryCost) = ((kmeans.usedMemory() + datasetMemory) / datasetMemory); 
# 248
(cost.searchTimeCost) = searchTime; 
# 249
(cost.buildTimeCost) = buildTime; 
# 250
Logger::info("KMeansTree buildTime=%g, searchTime=%g, build_weight=%g\n", buildTime, searchTime, build_weight_); 
# 251
} 
# 254
void evaluate_kdtree(CostData &cost) 
# 255
{ 
# 256
cvflann::StartStopTimer t; 
# 257
int checks; 
# 258
const int nn = 1; 
# 260
Logger::info("KDTree using params: trees=%d\n", get_param< int> ((cost.params), "trees")); 
# 261
KDTreeIndex< Distance>  kdtree(sampledDataset_, (cost.params), distance_); 
# 263
t.start(); 
# 264
kdtree.buildIndex(); 
# 265
t.stop(); 
# 266
float buildTime = (float)(t.value); 
# 269
float searchTime = test_index_precision(kdtree, sampledDataset_, testDataset_, gt_matches_, target_precision_, checks, distance_, nn); 
# 271
float datasetMemory = (float)((((sampledDataset_).rows) * ((sampledDataset_).cols)) * sizeof(float)); 
# 272
(cost.memoryCost) = ((kdtree.usedMemory() + datasetMemory) / datasetMemory); 
# 273
(cost.searchTimeCost) = searchTime; 
# 274
(cost.buildTimeCost) = buildTime; 
# 275
Logger::info("KDTree buildTime=%g, searchTime=%g\n", buildTime, searchTime); 
# 276
} 
# 327 "/usr/include/opencv4/opencv2/flann/autotuned_index.h" 3
void optimizeKMeans(std::vector< CostData>  &costs) 
# 328
{ 
# 329
Logger::info("KMEANS, Step 1: Exploring parameter space\n"); 
# 332
int maxIterations[] = {1, 5, 10, 15}; 
# 333
int branchingFactors[] = {16, 32, 64, 128, 256}; 
# 335
int kmeansParamSpaceSize = ((sizeof maxIterations / sizeof (maxIterations[0])) * (sizeof branchingFactors / sizeof (branchingFactors[0]))); 
# 336
costs.reserve(costs.size() + kmeansParamSpaceSize); 
# 339
for (::size_t i = (0); i < (sizeof maxIterations / sizeof (maxIterations[0])); ++i) { 
# 340
for (::size_t j = (0); j < (sizeof branchingFactors / sizeof (branchingFactors[0])); ++j) { 
# 341
CostData cost; 
# 342
((cost.params)["algorithm"]) = FLANN_INDEX_KMEANS; 
# 343
((cost.params)["centers_init"]) = FLANN_CENTERS_RANDOM; 
# 344
((cost.params)["iterations"]) = (maxIterations[i]); 
# 345
((cost.params)["branching"]) = (branchingFactors[j]); 
# 347
evaluate_kmeans(cost); 
# 348
costs.push_back(cost); 
# 349
}  
# 350
}  
# 372 "/usr/include/opencv4/opencv2/flann/autotuned_index.h" 3
} 
# 375
void optimizeKDTree(std::vector< CostData>  &costs) 
# 376
{ 
# 377
Logger::info("KD-TREE, Step 1: Exploring parameter space\n"); 
# 380
int testTrees[] = {1, 4, 8, 16, 32}; 
# 383
for (::size_t i = (0); i < (sizeof testTrees / sizeof (testTrees[0])); ++i) { 
# 384
CostData cost; 
# 385
((cost.params)["algorithm"]) = FLANN_INDEX_KDTREE; 
# 386
((cost.params)["trees"]) = (testTrees[i]); 
# 388
evaluate_kdtree(cost); 
# 389
costs.push_back(cost); 
# 390
}  
# 410 "/usr/include/opencv4/opencv2/flann/autotuned_index.h" 3
} 
# 417
cvflann::IndexParams estimateBuildParams() 
# 418
{ 
# 419
std::vector< CostData>  costs; 
# 421
int sampleSize = (int)((sample_fraction_) * ((dataset_).rows)); 
# 422
int testSampleSize = std::min(sampleSize / 10, 1000); 
# 424
Logger::info("Entering autotuning, dataset size: %d, sampleSize: %d, testSampleSize: %d, target precision: %g\n", ((dataset_).rows), sampleSize, testSampleSize, target_precision_); 
# 428
if (testSampleSize < 10) { 
# 429
Logger::info("Choosing linear, dataset too small\n"); 
# 430
return cvflann::LinearIndexParams(); 
# 431
}  
# 434
(sampledDataset_) = random_sample(dataset_, sampleSize); 
# 436
(testDataset_) = random_sample(sampledDataset_, testSampleSize, true); 
# 439
Logger::info("Computing ground truth... \n"); 
# 440
(gt_matches_) = cvflann::Matrix< int> (new int [(testDataset_).rows], ((testDataset_).rows), 1); 
# 441
cvflann::StartStopTimer t; 
# 442
t.start(); 
# 443
compute_ground_truth< Distance> (sampledDataset_, testDataset_, gt_matches_, 0, distance_); 
# 444
t.stop(); 
# 446
CostData linear_cost; 
# 447
(linear_cost.searchTimeCost) = ((float)(t.value)); 
# 448
(linear_cost.buildTimeCost) = 0; 
# 449
(linear_cost.memoryCost) = 0; 
# 450
((linear_cost.params)["algorithm"]) = FLANN_INDEX_LINEAR; 
# 452
costs.push_back(linear_cost); 
# 455
Logger::info("Autotuning parameters...\n"); 
# 457
optimizeKMeans(costs); 
# 458
optimizeKDTree(costs); 
# 460
float bestTimeCost = (((costs[0]).searchTimeCost)); 
# 461
for (::size_t i = (0); i < costs.size(); ++i) { 
# 462
float timeCost = (((costs[i]).buildTimeCost) * (build_weight_)) + ((costs[i]).searchTimeCost); 
# 463
if (timeCost < bestTimeCost) { 
# 464
bestTimeCost = timeCost; 
# 465
}  
# 466
}  
# 468
float bestCost = ((costs[0]).searchTimeCost) / bestTimeCost; 
# 469
cvflann::IndexParams bestParams = (((costs[0]).params)); 
# 470
if (bestTimeCost > (0)) { 
# 471
for (::size_t i = (0); i < costs.size(); ++i) { 
# 472
float crtCost = (((((costs[i]).buildTimeCost) * (build_weight_)) + ((costs[i]).searchTimeCost)) / bestTimeCost) + ((memory_weight_) * ((costs[i]).memoryCost)); 
# 474
if (crtCost < bestCost) { 
# 475
bestCost = crtCost; 
# 476
bestParams = ((costs[i]).params); 
# 477
}  
# 478
}  
# 479
}  
# 481
delete [] ((gt_matches_).data); 
# 482
delete [] ((testDataset_).data); 
# 483
delete [] ((sampledDataset_).data); 
# 485
return bestParams; 
# 486
} 
# 495 "/usr/include/opencv4/opencv2/flann/autotuned_index.h" 3
float estimateSearchParams(cvflann::SearchParams &searchParams) 
# 496
{ 
# 497
const int nn = 1; 
# 498
const ::size_t SAMPLE_COUNT = (1000); 
# 500
(static_cast< bool>((bestIndex_) != __null)) ? (void)0 : __assert_fail("bestIndex_ != NULL", "/usr/include/opencv4/opencv2/flann/autotuned_index.h", 500, __extension__ __PRETTY_FUNCTION__); 
# 502
float speedup = (0); 
# 504
int samples = (int)std::min(((dataset_).rows) / 10, SAMPLE_COUNT); 
# 505
if (samples > 0) { 
# 506
Matrix< typename Distance::ElementType>  testDataset = random_sample(dataset_, samples); 
# 508
Logger::info("Computing ground truth\n"); 
# 511
cvflann::Matrix< int>  gt_matches(new int [testDataset.rows], (testDataset.rows), 1); 
# 512
cvflann::StartStopTimer t; 
# 513
t.start(); 
# 514
compute_ground_truth< Distance> (dataset_, testDataset, gt_matches, 1, distance_); 
# 515
t.stop(); 
# 516
float linear = (float)(t.value); 
# 518
int checks; 
# 519
Logger::info("Estimating number of checks\n"); 
# 521
float searchTime; 
# 522
float cb_index; 
# 523
if ((bestIndex_)->getType() == FLANN_INDEX_KMEANS) { 
# 524
Logger::info("KMeans algorithm, estimating cluster border factor\n"); 
# 525
KMeansIndex< Distance>  *kmeans = (KMeansIndex< Distance>  *)(bestIndex_); 
# 526
float bestSearchTime = (-1); 
# 527
float best_cb_index = (-1); 
# 528
int best_checks = (-1); 
# 529
for (cb_index = (0); cb_index < (1.1F); cb_index += (0.2F)) { 
# 530
kmeans->set_cb_index(cb_index); 
# 531
searchTime = test_index_precision(*kmeans, dataset_, testDataset, gt_matches, target_precision_, checks, distance_, nn, 1); 
# 532
if ((searchTime < bestSearchTime) || (bestSearchTime == (-1))) { 
# 533
bestSearchTime = searchTime; 
# 534
best_cb_index = cb_index; 
# 535
best_checks = checks; 
# 536
}  
# 537
}  
# 538
searchTime = bestSearchTime; 
# 539
cb_index = best_cb_index; 
# 540
checks = best_checks; 
# 542
kmeans->set_cb_index(best_cb_index); 
# 543
Logger::info("Optimum cb_index: %g\n", cb_index); 
# 544
(((bestParams_)["cb_index"]) = cb_index); 
# 545
} else 
# 546
{ 
# 547
searchTime = test_index_precision(*(bestIndex_), dataset_, testDataset, gt_matches, target_precision_, checks, distance_, nn, 1); 
# 548
}  
# 550
Logger::info("Required number of checks: %d \n", checks); 
# 551
((searchParams["checks"]) = checks); 
# 553
speedup = (linear / searchTime); 
# 555
delete [] (gt_matches.data); 
# 556
delete [] (testDataset.data); 
# 557
}  
# 559
return speedup; 
# 560
} 
# 563
NNIndex< Distance>  *bestIndex_; 
# 565
cvflann::IndexParams bestParams_; 
# 566
cvflann::SearchParams bestSearchParams_; 
# 568
Matrix< ElementType>  sampledDataset_; 
# 569
Matrix< ElementType>  testDataset_; 
# 570
cvflann::Matrix< int>  gt_matches_; 
# 572
float speedup_; 
# 577
const Matrix< ElementType>  dataset_; 
# 582
float target_precision_; 
# 583
float build_weight_; 
# 584
float memory_weight_; 
# 585
float sample_fraction_; 
# 587
Distance distance_; 
# 590
}; 
# 591
}
# 48 "/usr/include/opencv4/opencv2/flann/all_indices.h" 3
namespace cvflann { 
# 51
template< class KDTreeCapability, class VectorSpace, class Distance> 
# 52
struct index_creator { 
# 54
static NNIndex< Distance>  *create(const Matrix< typename Distance::ElementType>  &dataset, const IndexParams &params, const Distance &distance) 
# 55
{ 
# 56
flann_algorithm_t index_type = get_param< flann_algorithm_t> (params, "algorithm"); 
# 58
NNIndex< Distance>  *nnIndex; 
# 59
switch (index_type) { 
# 60
case FLANN_INDEX_LINEAR:  
# 61
nnIndex = (new LinearIndex< Distance> (dataset, params, distance)); 
# 62
break; 
# 63
case FLANN_INDEX_KDTREE_SINGLE:  
# 64
nnIndex = (new KDTreeSingleIndex< Distance> (dataset, params, distance)); 
# 65
break; 
# 66
case FLANN_INDEX_KDTREE:  
# 67
nnIndex = (new KDTreeIndex< Distance> (dataset, params, distance)); 
# 68
break; 
# 69
case FLANN_INDEX_KMEANS:  
# 70
nnIndex = (new KMeansIndex< Distance> (dataset, params, distance)); 
# 71
break; 
# 72
case FLANN_INDEX_COMPOSITE:  
# 73
nnIndex = (new CompositeIndex< Distance> (dataset, params, distance)); 
# 74
break; 
# 75
case FLANN_INDEX_AUTOTUNED:  
# 76
nnIndex = (new AutotunedIndex< Distance> (dataset, params, distance)); 
# 77
break; 
# 78
case FLANN_INDEX_HIERARCHICAL:  
# 79
nnIndex = (new HierarchicalClusteringIndex< Distance> (dataset, params, distance)); 
# 80
break; 
# 81
case FLANN_INDEX_LSH:  
# 82
nnIndex = (new LshIndex< Distance> (dataset, params, distance)); 
# 83
break; 
# 84
default:  
# 85
throw ((FLANNException)("Unknown index type")); 
# 86
}  
# 88
return nnIndex; 
# 89
} 
# 90
}; 
# 92
template< class VectorSpace, class Distance> 
# 93
struct index_creator< False, VectorSpace, Distance>  { 
# 95
static NNIndex< Distance>  *create(const Matrix< typename Distance::ElementType>  &dataset, const IndexParams &params, const Distance &distance) 
# 96
{ 
# 97
flann_algorithm_t index_type = get_param< flann_algorithm_t> (params, "algorithm"); 
# 99
NNIndex< Distance>  *nnIndex; 
# 100
switch (index_type) { 
# 101
case FLANN_INDEX_LINEAR:  
# 102
nnIndex = (new LinearIndex< Distance> (dataset, params, distance)); 
# 103
break; 
# 104
case FLANN_INDEX_KMEANS:  
# 105
nnIndex = (new KMeansIndex< Distance> (dataset, params, distance)); 
# 106
break; 
# 107
case FLANN_INDEX_HIERARCHICAL:  
# 108
nnIndex = (new HierarchicalClusteringIndex< Distance> (dataset, params, distance)); 
# 109
break; 
# 110
case FLANN_INDEX_LSH:  
# 111
nnIndex = (new LshIndex< Distance> (dataset, params, distance)); 
# 112
break; 
# 113
default:  
# 114
throw ((FLANNException)("Unknown index type")); 
# 115
}  
# 117
return nnIndex; 
# 118
} 
# 119
}; 
# 121
template< class Distance> 
# 122
struct index_creator< False, False, Distance>  { 
# 124
static NNIndex< Distance>  *create(const Matrix< typename Distance::ElementType>  &dataset, const IndexParams &params, const Distance &distance) 
# 125
{ 
# 126
flann_algorithm_t index_type = get_param< flann_algorithm_t> (params, "algorithm"); 
# 128
NNIndex< Distance>  *nnIndex; 
# 129
switch (index_type) { 
# 130
case FLANN_INDEX_LINEAR:  
# 131
nnIndex = (new LinearIndex< Distance> (dataset, params, distance)); 
# 132
break; 
# 133
case FLANN_INDEX_HIERARCHICAL:  
# 134
nnIndex = (new HierarchicalClusteringIndex< Distance> (dataset, params, distance)); 
# 135
break; 
# 136
case FLANN_INDEX_LSH:  
# 137
nnIndex = (new LshIndex< Distance> (dataset, params, distance)); 
# 138
break; 
# 139
default:  
# 140
throw ((FLANNException)("Unknown index type")); 
# 141
}  
# 143
return nnIndex; 
# 144
} 
# 145
}; 
# 147
template< class Distance> NNIndex< Distance>  *
# 148
create_index_by_type(const Matrix< typename Distance::ElementType>  &dataset, const IndexParams &params, const Distance &distance) 
# 149
{ 
# 150
return index_creator< typename Distance::is_kdtree_distance, typename Distance::is_vector_space_distance, Distance> ::create(dataset, params, distance); 
# 153
} 
# 155
}
# 47 "/usr/include/opencv4/opencv2/flann/flann_base.hpp" 3
namespace cvflann { 
# 54
inline void log_verbosity(int level) 
# 55
{ 
# 56
if (level >= 0) { 
# 57
Logger::setLevel(level); 
# 58
}  
# 59
} 
# 64
struct SavedIndexParams : public IndexParams { 
# 66
SavedIndexParams(cv::String filename) 
# 67
{ 
# 68
(((*this)["algorithm"]) = (FLANN_INDEX_SAVED)); 
# 69
(((*this)["filename"]) = filename); 
# 70
} 
# 71
}; 
# 74
template< class Distance> NNIndex< Distance>  *
# 75
load_saved_index(const Matrix< typename Distance::ElementType>  &dataset, const cv::String &filename, Distance distance) 
# 76
{ 
# 77
typedef typename Distance::ElementType ElementType; 
# 79
FILE *fin = fopen(filename.c_str(), "rb"); 
# 80
if (fin == (__null)) { 
# 81
return __null; 
# 82
}  
# 83
IndexHeader header = load_header(fin); 
# 84
if ((header.data_type) != Datatype< typename Distance::ElementType> ::type()) { 
# 85
fclose(fin); 
# 86
throw ((FLANNException)("Datatype of saved index is different than of the one to be created.")); 
# 87
}  
# 88
if ((((size_t)(header.rows)) != (dataset.rows)) || (((size_t)(header.cols)) != (dataset.cols))) { 
# 89
fclose(fin); 
# 90
throw ((FLANNException)("The index saved belongs to a different dataset")); 
# 91
}  
# 93
IndexParams params; 
# 94
((params["algorithm"]) = (header.index_type)); 
# 95
NNIndex< Distance>  *nnIndex = create_index_by_type< Distance> (dataset, params, distance); 
# 96
nnIndex->loadIndex(fin); 
# 97
fclose(fin); 
# 99
return nnIndex; 
# 100
} 
# 103
template< class Distance> 
# 104
class Index : public NNIndex< Distance>  { 
# 107
public: typedef typename Distance::ElementType ElementType; 
# 108
typedef typename Distance::ResultType DistanceType; 
# 110
Index(const Matrix< ElementType>  &features, const cvflann::IndexParams &params, Distance distance = Distance()) : index_params_(params) 
# 112
{ 
# 113
cvflann::flann_algorithm_t index_type = get_param< cvflann::flann_algorithm_t> (params, "algorithm"); 
# 114
(loaded_) = false; 
# 116
if (index_type == (FLANN_INDEX_SAVED)) { 
# 117
(nnIndex_) = load_saved_index< Distance> (features, get_param< std::__cxx11::basic_string< char> > (params, "filename"), distance); 
# 118
(loaded_) = true; 
# 119
} else 
# 120
{ 
# 121
(nnIndex_) = create_index_by_type< Distance> (features, params, distance); 
# 122
}  
# 123
} 
# 125
~Index() 
# 126
{ 
# 127
delete (nnIndex_); 
# 128
} 
# 133
void buildIndex() override 
# 134
{ 
# 135
if (!(loaded_)) { 
# 136
(nnIndex_)->buildIndex(); 
# 137
}  
# 138
} 
# 140
void save(cv::String filename) 
# 141
{ 
# 142
::FILE *fout = fopen(filename.c_str(), "wb"); 
# 143
if (fout == (__null)) { 
# 144
throw ((cvflann::FLANNException)("Cannot open file")); 
# 145
}  
# 146
save_header(fout, *(nnIndex_)); 
# 147
saveIndex(fout); 
# 148
fclose(fout); 
# 149
} 
# 155
virtual void saveIndex(::FILE *stream) override 
# 156
{ 
# 157
(nnIndex_)->saveIndex(stream); 
# 158
} 
# 164
virtual void loadIndex(::FILE *stream) override 
# 165
{ 
# 166
(nnIndex_)->loadIndex(stream); 
# 167
} 
# 172
::size_t veclen() const override 
# 173
{ 
# 174
return (nnIndex_)->veclen(); 
# 175
} 
# 180
::size_t size() const override 
# 181
{ 
# 182
return (nnIndex_)->size(); 
# 183
} 
# 188
cvflann::flann_algorithm_t getType() const override 
# 189
{ 
# 190
return (nnIndex_)->getType(); 
# 191
} 
# 196
virtual int usedMemory() const override 
# 197
{ 
# 198
return (nnIndex_)->usedMemory(); 
# 199
} 
# 205
cvflann::IndexParams getParameters() const override 
# 206
{ 
# 207
return (nnIndex_)->getParameters(); 
# 208
} 
# 218 "/usr/include/opencv4/opencv2/flann/flann_base.hpp" 3
void knnSearch(const Matrix< ElementType>  &queries, cvflann::Matrix< int>  &indices, Matrix< DistanceType>  &dists, int knn, const cvflann::SearchParams &params) override 
# 219
{ 
# 220
(nnIndex_)->knnSearch(queries, indices, dists, knn, params); 
# 221
} 
# 232 "/usr/include/opencv4/opencv2/flann/flann_base.hpp" 3
int radiusSearch(const Matrix< ElementType>  &query, cvflann::Matrix< int>  &indices, Matrix< DistanceType>  &dists, float radius, const cvflann::SearchParams &params) override 
# 233
{ 
# 234
return (nnIndex_)->radiusSearch(query, indices, dists, radius, params); 
# 235
} 
# 240
void findNeighbors(ResultSet< DistanceType>  &result, const ElementType *vec, const cvflann::SearchParams &searchParams) override 
# 241
{ 
# 242
(nnIndex_)->findNeighbors(result, vec, searchParams); 
# 243
} 
# 248
__attribute((deprecated)) NNIndex< Distance>  *getIndex() 
# 249
{ 
# 250
return nnIndex_; 
# 251
} 
# 257
__attribute((deprecated)) const cvflann::IndexParams *getIndexParameters() 
# 258
{ 
# 259
return &(index_params_); 
# 260
} 
# 264
private: NNIndex< Distance>  *nnIndex_; 
# 266
bool loaded_; 
# 268
cvflann::IndexParams index_params_; 
# 270
Index(const Index &); 
# 271
Index &operator=(const Index &); 
# 272
}; 
# 285 "/usr/include/opencv4/opencv2/flann/flann_base.hpp" 3
template< class Distance> int 
# 286
hierarchicalClustering(const Matrix< typename Distance::ElementType>  &points, Matrix< typename Distance::ResultType>  &centers, const KMeansIndexParams &
# 287
params, Distance d = Distance()) 
# 288
{ 
# 289
KMeansIndex< Distance>  kmeans(points, params, d); 
# 290
kmeans.buildIndex(); 
# 292
int clusterNum = kmeans.getClusterCenters(centers); 
# 293
return clusterNum; 
# 294
} 
# 296
}
# 59 "/usr/include/opencv4/opencv2/flann.hpp" 3
namespace cvflann { 
# 61
flann_distance_t flann_distance_type(); 
# 62
__attribute((deprecated)) void set_distance_type(flann_distance_t distance_type, int order); 
# 63
}
# 66
namespace cv { 
# 68
namespace flann { 
# 75
template< class T> struct CvType { }; 
# 76
template<> struct CvType< unsigned char>  { static int type() { return 0; } }; 
# 77
template<> struct CvType< char>  { static int type() { return 1; } }; 
# 78
template<> struct CvType< unsigned short>  { static int type() { return 2; } }; 
# 79
template<> struct CvType< short>  { static int type() { return 3; } }; 
# 80
template<> struct CvType< int>  { static int type() { return 4; } }; 
# 81
template<> struct CvType< float>  { static int type() { return 5; } }; 
# 82
template<> struct CvType< double>  { static int type() { return 6; } }; 
# 86
using cvflann::get_param;
# 87
using cvflann::print_params;
# 90
using cvflann::L2_Simple;
# 91
using cvflann::L2;
# 92
using cvflann::L1;
# 93
using cvflann::MinkowskiDistance;
# 94
using cvflann::MaxDistance;
# 95
using cvflann::HammingLUT;
# 96
using cvflann::Hamming;
# 97
using cvflann::Hamming2;
# 98
using cvflann::HistIntersectionDistance;
# 99
using cvflann::HellingerDistance;
# 100
using cvflann::ChiSquareDistance;
# 101
using cvflann::KL_Divergence;
# 159 "/usr/include/opencv4/opencv2/flann.hpp" 3
template< class Distance> 
# 160
class GenericIndex { 
# 163
public: typedef typename Distance::ElementType ElementType; 
# 164
typedef typename Distance::ResultType DistanceType; 
# 254 "/usr/include/opencv4/opencv2/flann.hpp" 3
GenericIndex(const Mat & features, const cvflann::IndexParams & params, Distance distance = Distance()); 
# 256
~GenericIndex(); 
# 268 "/usr/include/opencv4/opencv2/flann.hpp" 3
void knnSearch(const std::vector< ElementType>  & query, std::vector< int>  & indices, std::vector< DistanceType>  & dists, int knn, const cvflann::SearchParams & params); 
# 270
void knnSearch(const Mat & queries, Mat & indices, Mat & dists, int knn, const cvflann::SearchParams & params); 
# 283 "/usr/include/opencv4/opencv2/flann.hpp" 3
int radiusSearch(const std::vector< ElementType>  & query, std::vector< int>  & indices, std::vector< DistanceType>  & dists, DistanceType radius, const cvflann::SearchParams & params); 
# 285
int radiusSearch(const Mat & query, Mat & indices, Mat & dists, DistanceType radius, const cvflann::SearchParams & params); 
# 288
void save(String filename) { (nnIndex)->save(filename); } 
# 290
int veclen() const { return (nnIndex)->veclen(); } 
# 292
int size() const { return (int)(nnIndex)->size(); } 
# 294
cvflann::IndexParams getParameters() { return (nnIndex)->getParameters(); } 
# 296
__attribute((deprecated)) const cvflann::IndexParams *getIndexParameters() { return (nnIndex)->getIndexParameters(); } 
# 299
private: cvflann::Index< Distance>  *nnIndex; 
# 300
Mat _dataset; 
# 301
}; 
# 314 "/usr/include/opencv4/opencv2/flann.hpp" 3
template< class Distance> 
# 315
GenericIndex< Distance> ::GenericIndex(const Mat &dataset, const cvflann::IndexParams &params, Distance distance) : _dataset(dataset) 
# 317
{ 
# 318
do { if (!(!(dataset.type() == CvType< ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dataset.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 318); }  } while (0); 
# 319
do { if (!(!dataset.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dataset.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 319); }  } while (0); 
# 320
cvflann::Matrix< ElementType>  m_dataset((ElementType *)(_dataset).template ptr< ElementType> (0), (_dataset).rows, (_dataset).cols); 
# 322
(nnIndex) = (new cvflann::Index< Distance> (m_dataset, params, distance)); 
# 324
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 326
(nnIndex)->buildIndex(); 
# 327
} 
# 329
template< class Distance> 
# 330
GenericIndex< Distance> ::~GenericIndex() 
# 331
{ 
# 332
delete (nnIndex); 
# 333
} 
# 335
template< class Distance> void 
# 336
GenericIndex< Distance> ::knnSearch(const std::vector< ElementType>  &query, std::vector< int>  &indices, std::vector< DistanceType>  &dists, int knn, const cvflann::SearchParams &searchParams) 
# 337
{ 
# 338
cvflann::Matrix< ElementType>  m_query((ElementType *)(&(query[0])), 1, query.size()); 
# 339
cvflann::Matrix< int>  m_indices(&indices[0], 1, indices.size()); 
# 340
cvflann::Matrix< DistanceType>  m_dists(&(dists[0]), 1, dists.size()); 
# 342
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 344
(nnIndex)->knnSearch(m_query, m_indices, m_dists, knn, searchParams); 
# 345
} 
# 348
template< class Distance> void 
# 349
GenericIndex< Distance> ::knnSearch(const Mat &queries, Mat &indices, Mat &dists, int knn, const cvflann::SearchParams &searchParams) 
# 350
{ 
# 351
do { if (!(!(queries.type() == CvType< ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "queries.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 351); }  } while (0); 
# 352
do { if (!(!queries.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "queries.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 352); }  } while (0); 
# 353
cvflann::Matrix< ElementType>  m_queries((ElementType *)queries.template ptr< ElementType> (0), queries.rows, queries.cols); 
# 355
do { if (!(!(indices.type() == 4))) { ; } else { cv::error(cv::Error::StsAssert, "indices.type() == CV_32S", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 355); }  } while (0); 
# 356
do { if (!(!indices.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "indices.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 356); }  } while (0); 
# 357
cvflann::Matrix< int>  m_indices((int *)indices.template ptr< int> (0), indices.rows, indices.cols); 
# 359
do { if (!(!(dists.type() == CvType< DistanceType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dists.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 359); }  } while (0); 
# 360
do { if (!(!dists.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dists.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 360); }  } while (0); 
# 361
cvflann::Matrix< DistanceType>  m_dists((DistanceType *)dists.template ptr< DistanceType> (0), dists.rows, dists.cols); 
# 363
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 365
(nnIndex)->knnSearch(m_queries, m_indices, m_dists, knn, searchParams); 
# 366
} 
# 368
template< class Distance> int 
# 369
GenericIndex< Distance> ::radiusSearch(const std::vector< ElementType>  &query, std::vector< int>  &indices, std::vector< DistanceType>  &dists, DistanceType radius, const cvflann::SearchParams &searchParams) 
# 370
{ 
# 371
cvflann::Matrix< ElementType>  m_query((ElementType *)(&(query[0])), 1, query.size()); 
# 372
cvflann::Matrix< int>  m_indices(&indices[0], 1, indices.size()); 
# 373
cvflann::Matrix< DistanceType>  m_dists(&(dists[0]), 1, dists.size()); 
# 375
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 377
return (nnIndex)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams); 
# 378
} 
# 380
template< class Distance> int 
# 381
GenericIndex< Distance> ::radiusSearch(const Mat &query, Mat &indices, Mat &dists, DistanceType radius, const cvflann::SearchParams &searchParams) 
# 382
{ 
# 383
do { if (!(!(query.type() == CvType< ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "query.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 383); }  } while (0); 
# 384
do { if (!(!query.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "query.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 384); }  } while (0); 
# 385
cvflann::Matrix< ElementType>  m_query((ElementType *)query.template ptr< ElementType> (0), query.rows, query.cols); 
# 387
do { if (!(!(indices.type() == 4))) { ; } else { cv::error(cv::Error::StsAssert, "indices.type() == CV_32S", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 387); }  } while (0); 
# 388
do { if (!(!indices.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "indices.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 388); }  } while (0); 
# 389
cvflann::Matrix< int>  m_indices((int *)indices.template ptr< int> (0), indices.rows, indices.cols); 
# 391
do { if (!(!(dists.type() == CvType< DistanceType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dists.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 391); }  } while (0); 
# 392
do { if (!(!dists.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dists.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 392); }  } while (0); 
# 393
cvflann::Matrix< DistanceType>  m_dists((DistanceType *)dists.template ptr< DistanceType> (0), dists.rows, dists.cols); 
# 395
if ((::cvflann::flann_distance_type()) != (cvflann::FLANN_DIST_L2)) { printf("[WARNING] You are using cv::flann::Index (or cv::flann::GenericIndex) and have also changed the distance using cvflann::set_dist" "ance_type. This is no longer working as expected (cv::flann::Index always uses L2). You should create the index templated on the" " distance, for example for L1 distance use: GenericIndex< L1<float> > \n"); }  
# 397
return (nnIndex)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams); 
# 398
} 
# 403
template< class T> 
# 404
class Index_ { 
# 407
public: typedef typename cvflann::L2< T> ::ElementType ElementType; 
# 408
typedef typename cvflann::L2< T> ::ResultType DistanceType; 
# 410
__attribute((deprecated)) Index_(const Mat &dataset, const cvflann::IndexParams &params) 
# 411
{ 
# 412
printf("[WARNING] The cv::flann::Index_<T> class is deperecated, use cv::flann::GenericIndex<Distance> instead\n"); 
# 414
do { if (!(!(dataset.type() == CvType< ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dataset.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 414); }  } while (0); 
# 415
do { if (!(!dataset.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dataset.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 415); }  } while (0); 
# 416
cvflann::Matrix< ElementType>  m_dataset((ElementType *)dataset.template ptr< ElementType> (0), dataset.rows, dataset.cols); 
# 418
if ((::cvflann::flann_distance_type()) == (cvflann::FLANN_DIST_L2)) { 
# 419
(nnIndex_L1) = __null; 
# 420
(nnIndex_L2) = (new cvflann::Index< cvflann::L2< ElementType> > (m_dataset, params)); 
# 421
} else { 
# 422
if ((::cvflann::flann_distance_type()) == (cvflann::FLANN_DIST_L1)) { 
# 423
(nnIndex_L1) = (new cvflann::Index< cvflann::L1< ElementType> > (m_dataset, params)); 
# 424
(nnIndex_L2) = __null; 
# 425
} else 
# 426
{ 
# 427
printf("[ERROR] cv::flann::Index_<T> only provides backwards compatibility for the L1 and L2 distances. For other distance types you mus" "t use cv::flann::GenericIndex<Distance>\n"); 
# 429
do { if (!(!(0))) { ; } else { cv::error(cv::Error::StsAssert, "0", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 429); }  } while (0); 
# 430
}  }  
# 431
if (nnIndex_L1) { (nnIndex_L1)->buildIndex(); }  
# 432
if (nnIndex_L2) { (nnIndex_L2)->buildIndex(); }  
# 433
} 
# 434
__attribute((deprecated)) ~Index_() 
# 435
{ 
# 436
if (nnIndex_L1) { delete (nnIndex_L1); }  
# 437
if (nnIndex_L2) { delete (nnIndex_L2); }  
# 438
} 
# 440
__attribute((deprecated)) void knnSearch(const std::vector< ElementType>  &query, std::vector< int>  &indices, std::vector< DistanceType>  &dists, int knn, const cvflann::SearchParams &searchParams) 
# 441
{ 
# 442
cvflann::Matrix< ElementType>  m_query((ElementType *)(&(query[0])), 1, query.size()); 
# 443
cvflann::Matrix< int>  m_indices(&indices[0], 1, indices.size()); 
# 444
cvflann::Matrix< DistanceType>  m_dists(&(dists[0]), 1, dists.size()); 
# 446
if (nnIndex_L1) { (nnIndex_L1)->knnSearch(m_query, m_indices, m_dists, knn, searchParams); }  
# 447
if (nnIndex_L2) { (nnIndex_L2)->knnSearch(m_query, m_indices, m_dists, knn, searchParams); }  
# 448
} 
# 449
__attribute((deprecated)) void knnSearch(const Mat &queries, Mat &indices, Mat &dists, int knn, const cvflann::SearchParams &searchParams) 
# 450
{ 
# 451
do { if (!(!(queries.type() == CvType< ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "queries.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 451); }  } while (0); 
# 452
do { if (!(!queries.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "queries.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 452); }  } while (0); 
# 453
cvflann::Matrix< ElementType>  m_queries((ElementType *)queries.template ptr< ElementType> (0), queries.rows, queries.cols); 
# 455
do { if (!(!(indices.type() == 4))) { ; } else { cv::error(cv::Error::StsAssert, "indices.type() == CV_32S", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 455); }  } while (0); 
# 456
do { if (!(!indices.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "indices.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 456); }  } while (0); 
# 457
cvflann::Matrix< int>  m_indices((int *)indices.template ptr< int> (0), indices.rows, indices.cols); 
# 459
do { if (!(!(dists.type() == CvType< DistanceType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dists.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 459); }  } while (0); 
# 460
do { if (!(!dists.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dists.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 460); }  } while (0); 
# 461
cvflann::Matrix< DistanceType>  m_dists((DistanceType *)dists.template ptr< DistanceType> (0), dists.rows, dists.cols); 
# 463
if (nnIndex_L1) { (nnIndex_L1)->knnSearch(m_queries, m_indices, m_dists, knn, searchParams); }  
# 464
if (nnIndex_L2) { (nnIndex_L2)->knnSearch(m_queries, m_indices, m_dists, knn, searchParams); }  
# 465
} 
# 467
__attribute((deprecated)) int radiusSearch(const std::vector< ElementType>  &query, std::vector< int>  &indices, std::vector< DistanceType>  &dists, DistanceType radius, const cvflann::SearchParams &searchParams) 
# 468
{ 
# 469
cvflann::Matrix< ElementType>  m_query((ElementType *)(&(query[0])), 1, query.size()); 
# 470
cvflann::Matrix< int>  m_indices(&indices[0], 1, indices.size()); 
# 471
cvflann::Matrix< DistanceType>  m_dists(&(dists[0]), 1, dists.size()); 
# 473
if (nnIndex_L1) { return (nnIndex_L1)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams); }  
# 474
if (nnIndex_L2) { return (nnIndex_L2)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams); }  
# 475
} 
# 477
__attribute((deprecated)) int radiusSearch(const Mat &query, Mat &indices, Mat &dists, DistanceType radius, const cvflann::SearchParams &searchParams) 
# 478
{ 
# 479
do { if (!(!(query.type() == CvType< ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "query.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 479); }  } while (0); 
# 480
do { if (!(!query.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "query.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 480); }  } while (0); 
# 481
cvflann::Matrix< ElementType>  m_query((ElementType *)query.template ptr< ElementType> (0), query.rows, query.cols); 
# 483
do { if (!(!(indices.type() == 4))) { ; } else { cv::error(cv::Error::StsAssert, "indices.type() == CV_32S", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 483); }  } while (0); 
# 484
do { if (!(!indices.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "indices.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 484); }  } while (0); 
# 485
cvflann::Matrix< int>  m_indices((int *)indices.template ptr< int> (0), indices.rows, indices.cols); 
# 487
do { if (!(!(dists.type() == CvType< DistanceType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "dists.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 487); }  } while (0); 
# 488
do { if (!(!dists.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "dists.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 488); }  } while (0); 
# 489
cvflann::Matrix< DistanceType>  m_dists((DistanceType *)dists.template ptr< DistanceType> (0), dists.rows, dists.cols); 
# 491
if (nnIndex_L1) { return (nnIndex_L1)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams); }  
# 492
if (nnIndex_L2) { return (nnIndex_L2)->radiusSearch(m_query, m_indices, m_dists, radius, searchParams); }  
# 493
} 
# 495
__attribute((deprecated)) void save(String filename) 
# 496
{ 
# 497
if (nnIndex_L1) { (nnIndex_L1)->save(filename); }  
# 498
if (nnIndex_L2) { (nnIndex_L2)->save(filename); }  
# 499
} 
# 501
__attribute((deprecated)) int veclen() const 
# 502
{ 
# 503
if (nnIndex_L1) { return (nnIndex_L1)->veclen(); }  
# 504
if (nnIndex_L2) { return (nnIndex_L2)->veclen(); }  
# 505
} 
# 507
__attribute((deprecated)) int size() const 
# 508
{ 
# 509
if (nnIndex_L1) { return (nnIndex_L1)->size(); }  
# 510
if (nnIndex_L2) { return (nnIndex_L2)->size(); }  
# 511
} 
# 513
__attribute((deprecated)) cvflann::IndexParams getParameters() 
# 514
{ 
# 515
if (nnIndex_L1) { return (nnIndex_L1)->getParameters(); }  
# 516
if (nnIndex_L2) { return (nnIndex_L2)->getParameters(); }  
# 518
} 
# 520
__attribute((deprecated)) const cvflann::IndexParams *getIndexParameters() 
# 521
{ 
# 522
if (nnIndex_L1) { return (nnIndex_L1)->getIndexParameters(); }  
# 523
if (nnIndex_L2) { return (nnIndex_L2)->getIndexParameters(); }  
# 524
} 
# 528
private: cvflann::Index< cvflann::L2< ElementType> >  *nnIndex_L2; 
# 529
cvflann::Index< cvflann::L1< ElementType> >  *nnIndex_L1; 
# 530
}; 
# 551 "/usr/include/opencv4/opencv2/flann.hpp" 3
template< class Distance> int 
# 552
hierarchicalClustering(const Mat &features, Mat &centers, const cvflann::KMeansIndexParams &params, Distance 
# 553
d = Distance()) 
# 554
{ 
# 555
typedef typename Distance::ElementType ElementType; 
# 556
typedef typename Distance::ResultType DistanceType; 
# 558
do { if (!(!(features.type() == CvType< typename Distance::ElementType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "features.type() == CvType<ElementType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 558); }  } while (0); 
# 559
do { if (!(!features.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "features.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 559); }  } while (0); 
# 560
cvflann::Matrix< typename Distance::ElementType>  m_features((ElementType *)features.template ptr< typename Distance::ElementType> (0), features.rows, features.cols); 
# 562
do { if (!(!(centers.type() == CvType< typename Distance::ResultType> ::type()))) { ; } else { cv::error(cv::Error::StsAssert, "centers.type() == CvType<DistanceType>::type()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 562); }  } while (0); 
# 563
do { if (!(!centers.isContinuous())) { ; } else { cv::error(cv::Error::StsAssert, "centers.isContinuous()", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 563); }  } while (0); 
# 564
cvflann::Matrix< typename Distance::ResultType>  m_centers((DistanceType *)centers.template ptr< typename Distance::ResultType> (0), centers.rows, centers.cols); 
# 566
return cvflann::hierarchicalClustering< Distance> (m_features, m_centers, params, d); 
# 567
} 
# 571
template< class ELEM_TYPE, class DIST_TYPE> 
# 572
__attribute((deprecated)) int hierarchicalClustering(const Mat &features, Mat &centers, const cvflann::KMeansIndexParams &params) 
# 573
{ 
# 574
printf("[WARNING] cv::flann::hierarchicalClustering<ELEM_TYPE,DIST_TYPE> is deprecated, use cv::flann::hierarchicalClustering<Distance> " "instead\n"); 
# 577
if ((::cvflann::flann_distance_type()) == (cvflann::FLANN_DIST_L2)) { 
# 578
return hierarchicalClustering< cvflann::L2< ELEM_TYPE> > (features, centers, params); 
# 579
} else { 
# 580
if ((::cvflann::flann_distance_type()) == (cvflann::FLANN_DIST_L1)) { 
# 581
return hierarchicalClustering< cvflann::L1< ELEM_TYPE> > (features, centers, params); 
# 582
} else 
# 583
{ 
# 584
printf("[ERROR] cv::flann::hierarchicalClustering<ELEM_TYPE,DIST_TYPE> only provides backwards compatibility for the L1 and L2 distances" ". For other distance types you must use cv::flann::hierarchicalClustering<Distance>\n"); 
# 587
do { if (!(!(0))) { ; } else { cv::error(cv::Error::StsAssert, "0", __func__, "/usr/include/opencv4/opencv2/flann.hpp", 587); }  } while (0); 
# 588
}  }  
# 589
} 
# 595
}}
# 57 "/usr/include/opencv4/opencv2/imgcodecs.hpp" 3
namespace cv { 
# 64
enum ImreadModes { 
# 65
IMREAD_UNCHANGED = (-1), 
# 66
IMREAD_GRAYSCALE = 0, 
# 67
IMREAD_COLOR, 
# 68
IMREAD_ANYDEPTH, 
# 69
IMREAD_ANYCOLOR = 4, 
# 70
IMREAD_LOAD_GDAL = 8, 
# 71
IMREAD_REDUCED_GRAYSCALE_2 = 16, 
# 72
IMREAD_REDUCED_COLOR_2, 
# 73
IMREAD_REDUCED_GRAYSCALE_4 = 32, 
# 74
IMREAD_REDUCED_COLOR_4, 
# 75
IMREAD_REDUCED_GRAYSCALE_8 = 64, 
# 76
IMREAD_REDUCED_COLOR_8, 
# 77
IMREAD_IGNORE_ORIENTATION = 128
# 78
}; 
# 81
enum ImwriteFlags { 
# 82
IMWRITE_JPEG_QUALITY = 1, 
# 83
IMWRITE_JPEG_PROGRESSIVE, 
# 84
IMWRITE_JPEG_OPTIMIZE, 
# 85
IMWRITE_JPEG_RST_INTERVAL, 
# 86
IMWRITE_JPEG_LUMA_QUALITY, 
# 87
IMWRITE_JPEG_CHROMA_QUALITY, 
# 88
IMWRITE_PNG_COMPRESSION = 16, 
# 89
IMWRITE_PNG_STRATEGY, 
# 90
IMWRITE_PNG_BILEVEL, 
# 91
IMWRITE_PXM_BINARY = 32, 
# 92
IMWRITE_EXR_TYPE = ((3 << 4) + 0), 
# 93
IMWRITE_WEBP_QUALITY = 64, 
# 94
IMWRITE_PAM_TUPLETYPE = 128, 
# 95
IMWRITE_TIFF_RESUNIT = 256, 
# 96
IMWRITE_TIFF_XDPI, 
# 97
IMWRITE_TIFF_YDPI, 
# 98
IMWRITE_TIFF_COMPRESSION, 
# 99
IMWRITE_JPEG2000_COMPRESSION_X1000 = 272
# 100
}; 
# 102
enum ImwriteEXRTypeFlags { 
# 104
IMWRITE_EXR_TYPE_HALF = 1, 
# 105
IMWRITE_EXR_TYPE_FLOAT
# 106
}; 
# 116 "/usr/include/opencv4/opencv2/imgcodecs.hpp" 3
enum ImwritePNGFlags { 
# 117
IMWRITE_PNG_STRATEGY_DEFAULT, 
# 118
IMWRITE_PNG_STRATEGY_FILTERED, 
# 119
IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY, 
# 120
IMWRITE_PNG_STRATEGY_RLE, 
# 121
IMWRITE_PNG_STRATEGY_FIXED
# 122
}; 
# 125
enum ImwritePAMFlags { 
# 126
IMWRITE_PAM_FORMAT_NULL, 
# 127
IMWRITE_PAM_FORMAT_BLACKANDWHITE, 
# 128
IMWRITE_PAM_FORMAT_GRAYSCALE, 
# 129
IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA, 
# 130
IMWRITE_PAM_FORMAT_RGB, 
# 131
IMWRITE_PAM_FORMAT_RGB_ALPHA
# 132
}; 
# 184 "/usr/include/opencv4/opencv2/imgcodecs.hpp" 3
Mat imread(const String & filename, int flags = IMREAD_COLOR); 
# 194 "/usr/include/opencv4/opencv2/imgcodecs.hpp" 3
bool imreadmulti(const String & filename, std::vector< Mat>  & mats, int flags = IMREAD_ANYCOLOR); 
# 222 "/usr/include/opencv4/opencv2/imgcodecs.hpp" 3
bool imwrite(const String & filename, InputArray img, const std::vector< int>  & params = std::vector< int> ()); 
# 236 "/usr/include/opencv4/opencv2/imgcodecs.hpp" 3
Mat imdecode(InputArray buf, int flags); 
# 244
Mat imdecode(InputArray buf, int flags, Mat * dst); 
# 256 "/usr/include/opencv4/opencv2/imgcodecs.hpp" 3
bool imencode(const String & ext, InputArray img, std::vector< unsigned char>  & buf, const std::vector< int>  & params = std::vector< int> ()); 
# 264
bool haveImageReader(const String & filename); 
# 270
bool haveImageWriter(const String & filename); 
# 275
}
# 68 "/usr/include/opencv4/opencv2/videoio.hpp" 3
typedef struct CvCapture CvCapture; 
# 69
typedef struct CvVideoWriter CvVideoWriter; 
# 71
namespace cv { 
# 89 "/usr/include/opencv4/opencv2/videoio.hpp" 3
enum VideoCaptureAPIs { 
# 90
CAP_ANY, 
# 91
CAP_VFW = 200, 
# 92
CAP_V4L = 200, 
# 93
CAP_V4L2 = CAP_V4L, 
# 94
CAP_FIREWIRE = 300, 
# 95
CAP_FIREWARE = CAP_FIREWIRE, 
# 96
CAP_IEEE1394 = CAP_FIREWIRE, 
# 97
CAP_DC1394 = CAP_FIREWIRE, 
# 98
CAP_CMU1394 = CAP_FIREWIRE, 
# 99
CAP_QT = 500, 
# 100
CAP_UNICAP = 600, 
# 101
CAP_DSHOW = 700, 
# 102
CAP_PVAPI = 800, 
# 103
CAP_OPENNI = 900, 
# 104
CAP_OPENNI_ASUS = 910, 
# 105
CAP_ANDROID = 1000, 
# 106
CAP_XIAPI = 1100, 
# 107
CAP_AVFOUNDATION = 1200, 
# 108
CAP_GIGANETIX = 1300, 
# 109
CAP_MSMF = 1400, 
# 110
CAP_WINRT = 1410, 
# 111
CAP_INTELPERC = 1500, 
# 112
CAP_REALSENSE = 1500, 
# 113
CAP_OPENNI2 = 1600, 
# 114
CAP_OPENNI2_ASUS = 1610, 
# 115
CAP_GPHOTO2 = 1700, 
# 116
CAP_GSTREAMER = 1800, 
# 117
CAP_FFMPEG = 1900, 
# 118
CAP_IMAGES = 2000, 
# 119
CAP_ARAVIS = 2100, 
# 120
CAP_OPENCV_MJPEG = 2200, 
# 121
CAP_INTEL_MFX = 2300, 
# 122
CAP_XINE = 2400
# 123
}; 
# 131
enum VideoCaptureProperties { 
# 132
CAP_PROP_POS_MSEC, 
# 133
CAP_PROP_POS_FRAMES, 
# 134
CAP_PROP_POS_AVI_RATIO, 
# 135
CAP_PROP_FRAME_WIDTH, 
# 136
CAP_PROP_FRAME_HEIGHT, 
# 137
CAP_PROP_FPS, 
# 138
CAP_PROP_FOURCC, 
# 139
CAP_PROP_FRAME_COUNT, 
# 140
CAP_PROP_FORMAT, 
# 142
CAP_PROP_MODE, 
# 143
CAP_PROP_BRIGHTNESS, 
# 144
CAP_PROP_CONTRAST, 
# 145
CAP_PROP_SATURATION, 
# 146
CAP_PROP_HUE, 
# 147
CAP_PROP_GAIN, 
# 148
CAP_PROP_EXPOSURE, 
# 149
CAP_PROP_CONVERT_RGB, 
# 150
CAP_PROP_WHITE_BALANCE_BLUE_U, 
# 151
CAP_PROP_RECTIFICATION, 
# 152
CAP_PROP_MONOCHROME, 
# 153
CAP_PROP_SHARPNESS, 
# 154
CAP_PROP_AUTO_EXPOSURE, 
# 155
CAP_PROP_GAMMA, 
# 156
CAP_PROP_TEMPERATURE, 
# 157
CAP_PROP_TRIGGER, 
# 158
CAP_PROP_TRIGGER_DELAY, 
# 159
CAP_PROP_WHITE_BALANCE_RED_V, 
# 160
CAP_PROP_ZOOM, 
# 161
CAP_PROP_FOCUS, 
# 162
CAP_PROP_GUID, 
# 163
CAP_PROP_ISO_SPEED, 
# 164
CAP_PROP_BACKLIGHT = 32, 
# 165
CAP_PROP_PAN, 
# 166
CAP_PROP_TILT, 
# 167
CAP_PROP_ROLL, 
# 168
CAP_PROP_IRIS, 
# 169
CAP_PROP_SETTINGS, 
# 170
CAP_PROP_BUFFERSIZE, 
# 171
CAP_PROP_AUTOFOCUS, 
# 172
CAP_PROP_SAR_NUM, 
# 173
CAP_PROP_SAR_DEN, 
# 174
CAP_PROP_BACKEND, 
# 175
CAP_PROP_CHANNEL, 
# 176
CAP_PROP_AUTO_WB, 
# 177
CAP_PROP_WB_TEMPERATURE, 
# 178
CAP_PROP_CODEC_PIXEL_FORMAT, 
# 180
CV__CAP_PROP_LATEST
# 182
}; 
# 187
enum VideoWriterProperties { 
# 188
VIDEOWRITER_PROP_QUALITY = 1, 
# 189
VIDEOWRITER_PROP_FRAMEBYTES, 
# 190
VIDEOWRITER_PROP_NSTRIPES
# 191
}; 
# 206 "/usr/include/opencv4/opencv2/videoio.hpp" 3
enum { CAP_PROP_DC1394_OFF = (-4), 
# 207
CAP_PROP_DC1394_MODE_MANUAL, 
# 208
CAP_PROP_DC1394_MODE_AUTO, 
# 209
CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO, 
# 210
CAP_PROP_DC1394_MAX = 31
# 211
}; 
# 220 "/usr/include/opencv4/opencv2/videoio.hpp" 3
enum { CAP_OPENNI_DEPTH_GENERATOR = (1 << 31), 
# 221
CAP_OPENNI_IMAGE_GENERATOR = (1 << 30), 
# 222
CAP_OPENNI_IR_GENERATOR = (1 << 29), 
# 223
CAP_OPENNI_GENERATORS_MASK = ((CAP_OPENNI_DEPTH_GENERATOR + CAP_OPENNI_IMAGE_GENERATOR) + CAP_OPENNI_IR_GENERATOR)
# 224
}; 
# 227
enum { CAP_PROP_OPENNI_OUTPUT_MODE = 100, 
# 228
CAP_PROP_OPENNI_FRAME_MAX_DEPTH, 
# 229
CAP_PROP_OPENNI_BASELINE, 
# 230
CAP_PROP_OPENNI_FOCAL_LENGTH, 
# 231
CAP_PROP_OPENNI_REGISTRATION, 
# 234
CAP_PROP_OPENNI_REGISTRATION_ON = CAP_PROP_OPENNI_REGISTRATION, 
# 235
CAP_PROP_OPENNI_APPROX_FRAME_SYNC, 
# 236
CAP_PROP_OPENNI_MAX_BUFFER_SIZE, 
# 237
CAP_PROP_OPENNI_CIRCLE_BUFFER, 
# 238
CAP_PROP_OPENNI_MAX_TIME_DURATION, 
# 239
CAP_PROP_OPENNI_GENERATOR_PRESENT, 
# 240
CAP_PROP_OPENNI2_SYNC, 
# 241
CAP_PROP_OPENNI2_MIRROR
# 242
}; 
# 245
enum { CAP_OPENNI_IMAGE_GENERATOR_PRESENT = ((CAP_OPENNI_IMAGE_GENERATOR) + (CAP_PROP_OPENNI_GENERATOR_PRESENT)), 
# 246
CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE = ((CAP_OPENNI_IMAGE_GENERATOR) + (CAP_PROP_OPENNI_OUTPUT_MODE)), 
# 247
CAP_OPENNI_DEPTH_GENERATOR_PRESENT = ((CAP_OPENNI_DEPTH_GENERATOR) + (CAP_PROP_OPENNI_GENERATOR_PRESENT)), 
# 248
CAP_OPENNI_DEPTH_GENERATOR_BASELINE = ((CAP_OPENNI_DEPTH_GENERATOR) + (CAP_PROP_OPENNI_BASELINE)), 
# 249
CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH, 
# 250
CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION, 
# 251
CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON = CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION, 
# 252
CAP_OPENNI_IR_GENERATOR_PRESENT = ((CAP_OPENNI_IR_GENERATOR) + (CAP_PROP_OPENNI_GENERATOR_PRESENT))
# 253
}; 
# 256
enum { CAP_OPENNI_DEPTH_MAP, 
# 257
CAP_OPENNI_POINT_CLOUD_MAP, 
# 258
CAP_OPENNI_DISPARITY_MAP, 
# 259
CAP_OPENNI_DISPARITY_MAP_32F, 
# 260
CAP_OPENNI_VALID_DEPTH_MASK, 
# 262
CAP_OPENNI_BGR_IMAGE, 
# 263
CAP_OPENNI_GRAY_IMAGE, 
# 265
CAP_OPENNI_IR_IMAGE
# 266
}; 
# 269
enum { CAP_OPENNI_VGA_30HZ, 
# 270
CAP_OPENNI_SXGA_15HZ, 
# 271
CAP_OPENNI_SXGA_30HZ, 
# 272
CAP_OPENNI_QVGA_30HZ, 
# 273
CAP_OPENNI_QVGA_60HZ
# 274
}; 
# 282
enum { CAP_PROP_GSTREAMER_QUEUE_LENGTH = 200
# 283
}; 
# 292 "/usr/include/opencv4/opencv2/videoio.hpp" 3
enum { CAP_PROP_PVAPI_MULTICASTIP = 300, 
# 293
CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE, 
# 294
CAP_PROP_PVAPI_DECIMATIONHORIZONTAL, 
# 295
CAP_PROP_PVAPI_DECIMATIONVERTICAL, 
# 296
CAP_PROP_PVAPI_BINNINGX, 
# 297
CAP_PROP_PVAPI_BINNINGY, 
# 298
CAP_PROP_PVAPI_PIXELFORMAT
# 299
}; 
# 302
enum { CAP_PVAPI_FSTRIGMODE_FREERUN, 
# 303
CAP_PVAPI_FSTRIGMODE_SYNCIN1, 
# 304
CAP_PVAPI_FSTRIGMODE_SYNCIN2, 
# 305
CAP_PVAPI_FSTRIGMODE_FIXEDRATE, 
# 306
CAP_PVAPI_FSTRIGMODE_SOFTWARE
# 307
}; 
# 310
enum { CAP_PVAPI_DECIMATION_OFF = 1, 
# 311
CAP_PVAPI_DECIMATION_2OUTOF4, 
# 312
CAP_PVAPI_DECIMATION_2OUTOF8 = 4, 
# 313
CAP_PVAPI_DECIMATION_2OUTOF16 = 8
# 314
}; 
# 317
enum { CAP_PVAPI_PIXELFORMAT_MONO8 = 1, 
# 318
CAP_PVAPI_PIXELFORMAT_MONO16, 
# 319
CAP_PVAPI_PIXELFORMAT_BAYER8, 
# 320
CAP_PVAPI_PIXELFORMAT_BAYER16, 
# 321
CAP_PVAPI_PIXELFORMAT_RGB24, 
# 322
CAP_PVAPI_PIXELFORMAT_BGR24, 
# 323
CAP_PVAPI_PIXELFORMAT_RGBA32, 
# 324
CAP_PVAPI_PIXELFORMAT_BGRA32
# 325
}; 
# 334 "/usr/include/opencv4/opencv2/videoio.hpp" 3
enum { CAP_PROP_XI_DOWNSAMPLING = 400, 
# 335
CAP_PROP_XI_DATA_FORMAT, 
# 336
CAP_PROP_XI_OFFSET_X, 
# 337
CAP_PROP_XI_OFFSET_Y, 
# 338
CAP_PROP_XI_TRG_SOURCE, 
# 339
CAP_PROP_XI_TRG_SOFTWARE, 
# 340
CAP_PROP_XI_GPI_SELECTOR, 
# 341
CAP_PROP_XI_GPI_MODE, 
# 342
CAP_PROP_XI_GPI_LEVEL, 
# 343
CAP_PROP_XI_GPO_SELECTOR, 
# 344
CAP_PROP_XI_GPO_MODE, 
# 345
CAP_PROP_XI_LED_SELECTOR, 
# 346
CAP_PROP_XI_LED_MODE, 
# 347
CAP_PROP_XI_MANUAL_WB, 
# 348
CAP_PROP_XI_AUTO_WB, 
# 349
CAP_PROP_XI_AEAG, 
# 350
CAP_PROP_XI_EXP_PRIORITY, 
# 351
CAP_PROP_XI_AE_MAX_LIMIT, 
# 352
CAP_PROP_XI_AG_MAX_LIMIT, 
# 353
CAP_PROP_XI_AEAG_LEVEL, 
# 354
CAP_PROP_XI_TIMEOUT, 
# 355
CAP_PROP_XI_EXPOSURE, 
# 356
CAP_PROP_XI_EXPOSURE_BURST_COUNT, 
# 357
CAP_PROP_XI_GAIN_SELECTOR, 
# 358
CAP_PROP_XI_GAIN, 
# 359
CAP_PROP_XI_DOWNSAMPLING_TYPE = 426, 
# 360
CAP_PROP_XI_BINNING_SELECTOR, 
# 361
CAP_PROP_XI_BINNING_VERTICAL, 
# 362
CAP_PROP_XI_BINNING_HORIZONTAL, 
# 363
CAP_PROP_XI_BINNING_PATTERN, 
# 364
CAP_PROP_XI_DECIMATION_SELECTOR, 
# 365
CAP_PROP_XI_DECIMATION_VERTICAL, 
# 366
CAP_PROP_XI_DECIMATION_HORIZONTAL, 
# 367
CAP_PROP_XI_DECIMATION_PATTERN, 
# 368
CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR = 587, 
# 369
CAP_PROP_XI_TEST_PATTERN, 
# 370
CAP_PROP_XI_IMAGE_DATA_FORMAT = 435, 
# 371
CAP_PROP_XI_SHUTTER_TYPE, 
# 372
CAP_PROP_XI_SENSOR_TAPS, 
# 373
CAP_PROP_XI_AEAG_ROI_OFFSET_X = 439, 
# 374
CAP_PROP_XI_AEAG_ROI_OFFSET_Y, 
# 375
CAP_PROP_XI_AEAG_ROI_WIDTH, 
# 376
CAP_PROP_XI_AEAG_ROI_HEIGHT, 
# 377
CAP_PROP_XI_BPC = 445, 
# 378
CAP_PROP_XI_WB_KR = 448, 
# 379
CAP_PROP_XI_WB_KG, 
# 380
CAP_PROP_XI_WB_KB, 
# 381
CAP_PROP_XI_WIDTH, 
# 382
CAP_PROP_XI_HEIGHT, 
# 383
CAP_PROP_XI_REGION_SELECTOR = 589, 
# 384
CAP_PROP_XI_REGION_MODE = 595, 
# 385
CAP_PROP_XI_LIMIT_BANDWIDTH = 459, 
# 386
CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH, 
# 387
CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH, 
# 388
CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH, 
# 389
CAP_PROP_XI_OUTPUT_DATA_PACKING, 
# 390
CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE, 
# 391
CAP_PROP_XI_IS_COOLED, 
# 392
CAP_PROP_XI_COOLING, 
# 393
CAP_PROP_XI_TARGET_TEMP, 
# 394
CAP_PROP_XI_CHIP_TEMP, 
# 395
CAP_PROP_XI_HOUS_TEMP, 
# 396
CAP_PROP_XI_HOUS_BACK_SIDE_TEMP = 590, 
# 397
CAP_PROP_XI_SENSOR_BOARD_TEMP = 596, 
# 398
CAP_PROP_XI_CMS = 470, 
# 399
CAP_PROP_XI_APPLY_CMS, 
# 400
CAP_PROP_XI_IMAGE_IS_COLOR = 474, 
# 401
CAP_PROP_XI_COLOR_FILTER_ARRAY, 
# 402
CAP_PROP_XI_GAMMAY, 
# 403
CAP_PROP_XI_GAMMAC, 
# 404
CAP_PROP_XI_SHARPNESS, 
# 405
CAP_PROP_XI_CC_MATRIX_00, 
# 406
CAP_PROP_XI_CC_MATRIX_01, 
# 407
CAP_PROP_XI_CC_MATRIX_02, 
# 408
CAP_PROP_XI_CC_MATRIX_03, 
# 409
CAP_PROP_XI_CC_MATRIX_10, 
# 410
CAP_PROP_XI_CC_MATRIX_11, 
# 411
CAP_PROP_XI_CC_MATRIX_12, 
# 412
CAP_PROP_XI_CC_MATRIX_13, 
# 413
CAP_PROP_XI_CC_MATRIX_20, 
# 414
CAP_PROP_XI_CC_MATRIX_21, 
# 415
CAP_PROP_XI_CC_MATRIX_22, 
# 416
CAP_PROP_XI_CC_MATRIX_23, 
# 417
CAP_PROP_XI_CC_MATRIX_30, 
# 418
CAP_PROP_XI_CC_MATRIX_31, 
# 419
CAP_PROP_XI_CC_MATRIX_32, 
# 420
CAP_PROP_XI_CC_MATRIX_33, 
# 421
CAP_PROP_XI_DEFAULT_CC_MATRIX, 
# 422
CAP_PROP_XI_TRG_SELECTOR = 498, 
# 423
CAP_PROP_XI_ACQ_FRAME_BURST_COUNT, 
# 424
CAP_PROP_XI_DEBOUNCE_EN = 507, 
# 425
CAP_PROP_XI_DEBOUNCE_T0, 
# 426
CAP_PROP_XI_DEBOUNCE_T1, 
# 427
CAP_PROP_XI_DEBOUNCE_POL, 
# 428
CAP_PROP_XI_LENS_MODE, 
# 429
CAP_PROP_XI_LENS_APERTURE_VALUE, 
# 430
CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE, 
# 431
CAP_PROP_XI_LENS_FOCUS_MOVE, 
# 432
CAP_PROP_XI_LENS_FOCUS_DISTANCE, 
# 433
CAP_PROP_XI_LENS_FOCAL_LENGTH, 
# 434
CAP_PROP_XI_LENS_FEATURE_SELECTOR, 
# 435
CAP_PROP_XI_LENS_FEATURE, 
# 436
CAP_PROP_XI_DEVICE_MODEL_ID = 521, 
# 437
CAP_PROP_XI_DEVICE_SN, 
# 438
CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA = 529, 
# 439
CAP_PROP_XI_IMAGE_PAYLOAD_SIZE, 
# 440
CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT, 
# 441
CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ, 
# 442
CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX, 
# 443
CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT, 
# 444
CAP_PROP_XI_FRAMERATE, 
# 445
CAP_PROP_XI_COUNTER_SELECTOR, 
# 446
CAP_PROP_XI_COUNTER_VALUE, 
# 447
CAP_PROP_XI_ACQ_TIMING_MODE, 
# 448
CAP_PROP_XI_AVAILABLE_BANDWIDTH, 
# 449
CAP_PROP_XI_BUFFER_POLICY, 
# 450
CAP_PROP_XI_LUT_EN, 
# 451
CAP_PROP_XI_LUT_INDEX, 
# 452
CAP_PROP_XI_LUT_VALUE, 
# 453
CAP_PROP_XI_TRG_DELAY, 
# 454
CAP_PROP_XI_TS_RST_MODE, 
# 455
CAP_PROP_XI_TS_RST_SOURCE, 
# 456
CAP_PROP_XI_IS_DEVICE_EXIST, 
# 457
CAP_PROP_XI_ACQ_BUFFER_SIZE, 
# 458
CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT, 
# 459
CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE, 
# 460
CAP_PROP_XI_BUFFERS_QUEUE_SIZE, 
# 461
CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT, 
# 462
CAP_PROP_XI_RECENT_FRAME, 
# 463
CAP_PROP_XI_DEVICE_RESET, 
# 464
CAP_PROP_XI_COLUMN_FPN_CORRECTION, 
# 465
CAP_PROP_XI_ROW_FPN_CORRECTION = 591, 
# 466
CAP_PROP_XI_SENSOR_MODE = 558, 
# 467
CAP_PROP_XI_HDR, 
# 468
CAP_PROP_XI_HDR_KNEEPOINT_COUNT, 
# 469
CAP_PROP_XI_HDR_T1, 
# 470
CAP_PROP_XI_HDR_T2, 
# 471
CAP_PROP_XI_KNEEPOINT1, 
# 472
CAP_PROP_XI_KNEEPOINT2, 
# 473
CAP_PROP_XI_IMAGE_BLACK_LEVEL, 
# 474
CAP_PROP_XI_HW_REVISION = 571, 
# 475
CAP_PROP_XI_DEBUG_LEVEL, 
# 476
CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION, 
# 477
CAP_PROP_XI_FFS_FILE_ID = 594, 
# 478
CAP_PROP_XI_FFS_FILE_SIZE = 580, 
# 479
CAP_PROP_XI_FREE_FFS_SIZE, 
# 480
CAP_PROP_XI_USED_FFS_SIZE, 
# 481
CAP_PROP_XI_FFS_ACCESS_KEY, 
# 482
CAP_PROP_XI_SENSOR_FEATURE_SELECTOR = 585, 
# 483
CAP_PROP_XI_SENSOR_FEATURE_VALUE
# 484
}; 
# 494 "/usr/include/opencv4/opencv2/videoio.hpp" 3
enum { CAP_PROP_IOS_DEVICE_FOCUS = 9001, 
# 495
CAP_PROP_IOS_DEVICE_EXPOSURE, 
# 496
CAP_PROP_IOS_DEVICE_FLASH, 
# 497
CAP_PROP_IOS_DEVICE_WHITEBALANCE, 
# 498
CAP_PROP_IOS_DEVICE_TORCH
# 499
}; 
# 507
enum { CAP_PROP_GIGA_FRAME_OFFSET_X = 10001, 
# 508
CAP_PROP_GIGA_FRAME_OFFSET_Y, 
# 509
CAP_PROP_GIGA_FRAME_WIDTH_MAX, 
# 510
CAP_PROP_GIGA_FRAME_HEIGH_MAX, 
# 511
CAP_PROP_GIGA_FRAME_SENS_WIDTH, 
# 512
CAP_PROP_GIGA_FRAME_SENS_HEIGH
# 513
}; 
# 520
enum { CAP_PROP_INTELPERC_PROFILE_COUNT = 11001, 
# 521
CAP_PROP_INTELPERC_PROFILE_IDX, 
# 522
CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE, 
# 523
CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE, 
# 524
CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD, 
# 525
CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ, 
# 526
CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT
# 527
}; 
# 530
enum { CAP_INTELPERC_DEPTH_GENERATOR = (1 << 29), 
# 531
CAP_INTELPERC_IMAGE_GENERATOR = (1 << 28), 
# 532
CAP_INTELPERC_IR_GENERATOR = (1 << 27), 
# 533
CAP_INTELPERC_GENERATORS_MASK = ((CAP_INTELPERC_DEPTH_GENERATOR + CAP_INTELPERC_IMAGE_GENERATOR) + CAP_INTELPERC_IR_GENERATOR)
# 534
}; 
# 536
enum { CAP_INTELPERC_DEPTH_MAP, 
# 537
CAP_INTELPERC_UVDEPTH_MAP, 
# 538
CAP_INTELPERC_IR_MAP, 
# 539
CAP_INTELPERC_IMAGE
# 540
}; 
# 554 "/usr/include/opencv4/opencv2/videoio.hpp" 3
enum { CAP_PROP_GPHOTO2_PREVIEW = 17001, 
# 555
CAP_PROP_GPHOTO2_WIDGET_ENUMERATE, 
# 556
CAP_PROP_GPHOTO2_RELOAD_CONFIG, 
# 557
CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE, 
# 558
CAP_PROP_GPHOTO2_COLLECT_MSGS, 
# 559
CAP_PROP_GPHOTO2_FLUSH_MSGS, 
# 560
CAP_PROP_SPEED, 
# 561
CAP_PROP_APERTURE, 
# 562
CAP_PROP_EXPOSUREPROGRAM, 
# 563
CAP_PROP_VIEWFINDER
# 564
}; 
# 576 "/usr/include/opencv4/opencv2/videoio.hpp" 3
enum { CAP_PROP_IMAGES_BASE = 18000, 
# 577
CAP_PROP_IMAGES_LAST = 19000
# 578
}; 
# 585
class IVideoCapture; 
# 587
namespace internal { class VideoCapturePrivateAccessor; }
# 608 "/usr/include/opencv4/opencv2/videoio.hpp" 3
class VideoCapture { 
# 616
public: VideoCapture(); 
# 631 "/usr/include/opencv4/opencv2/videoio.hpp" 3
VideoCapture(const String & filename, int apiPreference = CAP_ANY); 
# 643 "/usr/include/opencv4/opencv2/videoio.hpp" 3
VideoCapture(int index, int apiPreference = CAP_ANY); 
# 649
virtual ~VideoCapture(); 
# 660 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual bool open(const String & filename, int apiPreference = CAP_ANY); 
# 671 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual bool open(int index, int apiPreference = CAP_ANY); 
# 678
virtual bool isOpened() const; 
# 687 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual void release(); 
# 708 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual bool grab(); 
# 726 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual bool retrieve(OutputArray image, int flag = 0); 
# 731
virtual VideoCapture &operator>>(Mat & image); 
# 736
virtual VideoCapture &operator>>(UMat & image); 
# 752 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual bool read(OutputArray image); 
# 763 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual bool set(int propId, double value); 
# 782 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual double get(int propId) const; 
# 788
String getBackendName() const; 
# 794
void setExceptionMode(bool enable) { (throwOnFail) = enable; } 
# 797
bool getExceptionMode() { return throwOnFail; } 
# 815 "/usr/include/opencv4/opencv2/videoio.hpp" 3
static bool waitAny(const std::vector< VideoCapture>  & streams, std::vector< int>  & readyIndex, int64 timeoutNs = 0); 
# 821
protected: Ptr< CvCapture>  cap; 
# 822
Ptr< IVideoCapture>  icap; 
# 823
bool throwOnFail; 
# 825
friend class internal::VideoCapturePrivateAccessor; 
# 826
}; 
# 828
class IVideoWriter; 
# 842 "/usr/include/opencv4/opencv2/videoio.hpp" 3
class VideoWriter { 
# 852
public: VideoWriter(); 
# 875 "/usr/include/opencv4/opencv2/videoio.hpp" 3
VideoWriter(const String & filename, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 882
VideoWriter(const String & filename, int apiPreference, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 889
virtual ~VideoWriter(); 
# 899 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual bool open(const String & filename, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 904
bool open(const String & filename, int apiPreference, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 909
virtual bool isOpened() const; 
# 916
virtual void release(); 
# 921
virtual VideoWriter &operator<<(const Mat & image); 
# 926
virtual VideoWriter &operator<<(const UMat & image); 
# 935 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual void write(InputArray image); 
# 945 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual bool set(int propId, double value); 
# 955 "/usr/include/opencv4/opencv2/videoio.hpp" 3
virtual double get(int propId) const; 
# 964 "/usr/include/opencv4/opencv2/videoio.hpp" 3
static int fourcc(char c1, char c2, char c3, char c4); 
# 970
String getBackendName() const; 
# 973
protected: Ptr< CvVideoWriter>  writer; 
# 974
Ptr< IVideoWriter>  iwriter; 
# 976
static Ptr< IVideoWriter>  create(const String & filename, int fourcc, double fps, Size frameSize, bool isColor = true); 
# 978
}; 
# 980
template<> struct DefaultDeleter< CvCapture>  { void operator()(CvCapture * obj) const; }; 
# 981
template<> struct DefaultDeleter< CvVideoWriter>  { void operator()(CvVideoWriter * obj) const; }; 
# 985
}
# 175 "/usr/include/opencv4/opencv2/highgui.hpp" 3
namespace cv { 
# 182
enum WindowFlags { 
# 183
WINDOW_NORMAL, 
# 184
WINDOW_AUTOSIZE, 
# 185
WINDOW_OPENGL = 4096, 
# 187
WINDOW_FULLSCREEN = 1, 
# 188
WINDOW_FREERATIO = 256, 
# 189
WINDOW_KEEPRATIO = 0, 
# 190
WINDOW_GUI_EXPANDED = 0, 
# 191
WINDOW_GUI_NORMAL = 16
# 192
}; 
# 195
enum WindowPropertyFlags { 
# 196
WND_PROP_FULLSCREEN, 
# 197
WND_PROP_AUTOSIZE, 
# 198
WND_PROP_ASPECT_RATIO, 
# 199
WND_PROP_OPENGL, 
# 200
WND_PROP_VISIBLE, 
# 201
WND_PROP_TOPMOST
# 202
}; 
# 205
enum MouseEventTypes { 
# 206
EVENT_MOUSEMOVE, 
# 207
EVENT_LBUTTONDOWN, 
# 208
EVENT_RBUTTONDOWN, 
# 209
EVENT_MBUTTONDOWN, 
# 210
EVENT_LBUTTONUP, 
# 211
EVENT_RBUTTONUP, 
# 212
EVENT_MBUTTONUP, 
# 213
EVENT_LBUTTONDBLCLK, 
# 214
EVENT_RBUTTONDBLCLK, 
# 215
EVENT_MBUTTONDBLCLK, 
# 216
EVENT_MOUSEWHEEL, 
# 217
EVENT_MOUSEHWHEEL
# 218
}; 
# 221
enum MouseEventFlags { 
# 222
EVENT_FLAG_LBUTTON = 1, 
# 223
EVENT_FLAG_RBUTTON, 
# 224
EVENT_FLAG_MBUTTON = 4, 
# 225
EVENT_FLAG_CTRLKEY = 8, 
# 226
EVENT_FLAG_SHIFTKEY = 16, 
# 227
EVENT_FLAG_ALTKEY = 32
# 228
}; 
# 231
enum QtFontWeights { 
# 232
QT_FONT_LIGHT = 25, 
# 233
QT_FONT_NORMAL = 50, 
# 234
QT_FONT_DEMIBOLD = 63, 
# 235
QT_FONT_BOLD = 75, 
# 236
QT_FONT_BLACK = 87
# 237
}; 
# 240
enum QtFontStyles { 
# 241
QT_STYLE_NORMAL, 
# 242
QT_STYLE_ITALIC, 
# 243
QT_STYLE_OBLIQUE
# 244
}; 
# 247
enum QtButtonTypes { 
# 248
QT_PUSH_BUTTON, 
# 249
QT_CHECKBOX, 
# 250
QT_RADIOBOX, 
# 251
QT_NEW_BUTTONBAR = 1024
# 252
}; 
# 261 "/usr/include/opencv4/opencv2/highgui.hpp" 3
typedef void (*MouseCallback)(int event, int x, int y, int flags, void * userdata); 
# 267
typedef void (*TrackbarCallback)(int pos, void * userdata); 
# 272
typedef void (*OpenGlDrawCallback)(void * userdata); 
# 278
typedef void (*ButtonCallback)(int state, void * userdata); 
# 306 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void namedWindow(const String & winname, int flags = WINDOW_AUTOSIZE); 
# 314
void destroyWindow(const String & winname); 
# 320
void destroyAllWindows(); 
# 322
int startWindowThread(); 
# 331 "/usr/include/opencv4/opencv2/highgui.hpp" 3
int waitKeyEx(int delay = 0); 
# 354 "/usr/include/opencv4/opencv2/highgui.hpp" 3
int waitKey(int delay = 0); 
# 390 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void imshow(const String & winname, InputArray mat); 
# 403 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void resizeWindow(const String & winname, int width, int height); 
# 409
void resizeWindow(const String & winname, const Size & size); 
# 417
void moveWindow(const String & winname, int x, int y); 
# 427 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void setWindowProperty(const String & winname, int prop_id, double prop_value); 
# 433
void setWindowTitle(const String & winname, const String & title); 
# 444 "/usr/include/opencv4/opencv2/highgui.hpp" 3
double getWindowProperty(const String & winname, int prop_id); 
# 454 "/usr/include/opencv4/opencv2/highgui.hpp" 3
Rect getWindowImageRect(const String & winname); 
# 465 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void setMouseCallback(const String & winname, MouseCallback onMouse, void * userdata = 0); 
# 487 "/usr/include/opencv4/opencv2/highgui.hpp" 3
int getMouseWheelDelta(int flags); 
# 503 "/usr/include/opencv4/opencv2/highgui.hpp" 3
Rect selectROI(const String & windowName, InputArray img, bool showCrosshair = true, bool fromCenter = false); 
# 507
Rect selectROI(InputArray img, bool showCrosshair = true, bool fromCenter = false); 
# 524 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void selectROIs(const String & windowName, InputArray img, std::vector< Rect_< int> >  & boundingBoxes, bool showCrosshair = true, bool fromCenter = false); 
# 553 "/usr/include/opencv4/opencv2/highgui.hpp" 3
int createTrackbar(const String & trackbarname, const String & winname, int * value, int count, TrackbarCallback onChange = 0, void * userdata = 0); 
# 570 "/usr/include/opencv4/opencv2/highgui.hpp" 3
int getTrackbarPos(const String & trackbarname, const String & winname); 
# 585 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void setTrackbarPos(const String & trackbarname, const String & winname, int pos); 
# 600 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void setTrackbarMax(const String & trackbarname, const String & winname, int maxval); 
# 615 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void setTrackbarMin(const String & trackbarname, const String & winname, int minval); 
# 625 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void imshow(const String & winname, const ogl::Texture2D & tex); 
# 667 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void setOpenGlDrawCallback(const String & winname, OpenGlDrawCallback onOpenGlDraw, void * userdata = 0); 
# 673
void setOpenGlContext(const String & winname); 
# 679
void updateWindow(const String & winname); 
# 688 "/usr/include/opencv4/opencv2/highgui.hpp" 3
struct QtFont { 
# 690
const char *nameFont; 
# 691
Scalar color; 
# 692
int font_face; 
# 693
const int *ascii; 
# 694
const int *greek; 
# 695
const int *cyrillic; 
# 696
float hscale, vscale; 
# 697
float shear; 
# 698
int thickness; 
# 699
float dx; 
# 700
int line_type; 
# 701
}; 
# 723 "/usr/include/opencv4/opencv2/highgui.hpp" 3
QtFont fontQt(const String & nameFont, int pointSize = -1, Scalar color = Scalar::all(0), int weight = QT_FONT_NORMAL, int style = QT_STYLE_NORMAL, int spacing = 0); 
# 737 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void addText(const Mat & img, const String & text, Point org, const QtFont & font); 
# 753 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void addText(const Mat & img, const String & text, Point org, const String & nameFont, int pointSize = -1, Scalar color = Scalar::all(0), int weight = QT_FONT_NORMAL, int style = QT_STYLE_NORMAL, int spacing = 0); 
# 768 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void displayOverlay(const String & winname, const String & text, int delayms = 0); 
# 782 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void displayStatusBar(const String & winname, const String & text, int delayms = 0); 
# 791 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void saveWindowParameters(const String & windowName); 
# 800 "/usr/include/opencv4/opencv2/highgui.hpp" 3
void loadWindowParameters(const String & windowName); 
# 802
int startLoop(int (* pt2Func)(int argc, char * argv[]), int argc, char * argv[]); 
# 804
void stopLoop(); 
# 832 "/usr/include/opencv4/opencv2/highgui.hpp" 3
int createButton(const String & bar_name, ButtonCallback on_change, void * userdata = 0, int type = QT_PUSH_BUTTON, bool initial_button_state = false); 
# 840
}
# 197 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
namespace cv { 
# 207 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
enum SpecialFilter { 
# 208
FILTER_SCHARR = (-1)
# 209
}; 
# 212
enum MorphTypes { 
# 213
MORPH_ERODE, 
# 214
MORPH_DILATE, 
# 215
MORPH_OPEN, 
# 217
MORPH_CLOSE, 
# 219
MORPH_GRADIENT, 
# 221
MORPH_TOPHAT, 
# 223
MORPH_BLACKHAT, 
# 225
MORPH_HITMISS
# 227
}; 
# 230
enum MorphShapes { 
# 231
MORPH_RECT, 
# 232
MORPH_CROSS, 
# 234
MORPH_ELLIPSE
# 236
}; 
# 244
enum InterpolationFlags { 
# 246
INTER_NEAREST, 
# 248
INTER_LINEAR, 
# 250
INTER_CUBIC, 
# 254
INTER_AREA, 
# 256
INTER_LANCZOS4, 
# 258
INTER_LINEAR_EXACT, 
# 260
INTER_MAX = 7, 
# 263
WARP_FILL_OUTLIERS, 
# 270
WARP_INVERSE_MAP = 16
# 271
}; 
# 276
enum WarpPolarMode { 
# 278
WARP_POLAR_LINEAR, 
# 279
WARP_POLAR_LOG = 256
# 280
}; 
# 282
enum InterpolationMasks { 
# 283
INTER_BITS = 5, 
# 284
INTER_BITS2 = (INTER_BITS * 2), 
# 285
INTER_TAB_SIZE = (1 << INTER_BITS), 
# 286
INTER_TAB_SIZE2 = (INTER_TAB_SIZE * INTER_TAB_SIZE)
# 287
}; 
# 296 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
enum DistanceTypes { 
# 297
DIST_USER = (-1), 
# 298
DIST_L1 = 1, 
# 299
DIST_L2, 
# 300
DIST_C, 
# 301
DIST_L12, 
# 302
DIST_FAIR, 
# 303
DIST_WELSCH, 
# 304
DIST_HUBER
# 305
}; 
# 308
enum DistanceTransformMasks { 
# 309
DIST_MASK_3 = 3, 
# 310
DIST_MASK_5 = 5, 
# 311
DIST_MASK_PRECISE = 0
# 312
}; 
# 316
enum ThresholdTypes { 
# 317
THRESH_BINARY, 
# 318
THRESH_BINARY_INV, 
# 319
THRESH_TRUNC, 
# 320
THRESH_TOZERO, 
# 321
THRESH_TOZERO_INV, 
# 322
THRESH_MASK = 7, 
# 323
THRESH_OTSU, 
# 324
THRESH_TRIANGLE = 16
# 325
}; 
# 329
enum AdaptiveThresholdTypes { 
# 332
ADAPTIVE_THRESH_MEAN_C, 
# 337
ADAPTIVE_THRESH_GAUSSIAN_C
# 338
}; 
# 341
enum GrabCutClasses { 
# 342
GC_BGD, 
# 343
GC_FGD, 
# 344
GC_PR_BGD, 
# 345
GC_PR_FGD
# 346
}; 
# 349
enum GrabCutModes { 
# 352
GC_INIT_WITH_RECT, 
# 356
GC_INIT_WITH_MASK, 
# 358
GC_EVAL, 
# 360
GC_EVAL_FREEZE_MODEL
# 361
}; 
# 364
enum DistanceTransformLabelTypes { 
# 367
DIST_LABEL_CCOMP, 
# 369
DIST_LABEL_PIXEL
# 370
}; 
# 373
enum FloodFillFlags { 
# 376
FLOODFILL_FIXED_RANGE = (1 << 16), 
# 380
FLOODFILL_MASK_ONLY = (1 << 17)
# 381
}; 
# 389
enum ConnectedComponentsTypes { 
# 390
CC_STAT_LEFT, 
# 392
CC_STAT_TOP, 
# 394
CC_STAT_WIDTH, 
# 395
CC_STAT_HEIGHT, 
# 396
CC_STAT_AREA, 
# 398
CC_STAT_MAX
# 400
}; 
# 403
enum ConnectedComponentsAlgorithmsTypes { 
# 404
CCL_WU, 
# 405
CCL_DEFAULT = (-1), 
# 406
CCL_GRANA = 1
# 407
}; 
# 410
enum RetrievalModes { 
# 413
RETR_EXTERNAL, 
# 415
RETR_LIST, 
# 420
RETR_CCOMP, 
# 422
RETR_TREE, 
# 423
RETR_FLOODFILL
# 424
}; 
# 427
enum ContourApproximationModes { 
# 431
CHAIN_APPROX_NONE = 1, 
# 434
CHAIN_APPROX_SIMPLE, 
# 436
CHAIN_APPROX_TC89_L1, 
# 438
CHAIN_APPROX_TC89_KCOS
# 439
}; 
# 449 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
enum ShapeMatchModes { 
# 450
CONTOURS_MATCH_I1 = 1, 
# 451
CONTOURS_MATCH_I2, 
# 452
CONTOURS_MATCH_I3
# 453
}; 
# 461
enum HoughModes { 
# 467
HOUGH_STANDARD, 
# 472
HOUGH_PROBABILISTIC, 
# 475
HOUGH_MULTI_SCALE, 
# 476
HOUGH_GRADIENT
# 477
}; 
# 480
enum LineSegmentDetectorModes { 
# 481
LSD_REFINE_NONE, 
# 482
LSD_REFINE_STD, 
# 483
LSD_REFINE_ADV
# 485
}; 
# 492
enum HistCompMethods { 
# 498
HISTCMP_CORREL, 
# 501
HISTCMP_CHISQR, 
# 504
HISTCMP_INTERSECT, 
# 508
HISTCMP_BHATTACHARYYA, 
# 509
HISTCMP_HELLINGER = HISTCMP_BHATTACHARYYA, 
# 513
HISTCMP_CHISQR_ALT, 
# 516
HISTCMP_KL_DIV
# 517
}; 
# 523
enum ColorConversionCodes { 
# 524
COLOR_BGR2BGRA, 
# 525
COLOR_RGB2RGBA = COLOR_BGR2BGRA, 
# 527
COLOR_BGRA2BGR, 
# 528
COLOR_RGBA2RGB = COLOR_BGRA2BGR, 
# 530
COLOR_BGR2RGBA, 
# 531
COLOR_RGB2BGRA = COLOR_BGR2RGBA, 
# 533
COLOR_RGBA2BGR, 
# 534
COLOR_BGRA2RGB = COLOR_RGBA2BGR, 
# 536
COLOR_BGR2RGB, 
# 537
COLOR_RGB2BGR = COLOR_BGR2RGB, 
# 539
COLOR_BGRA2RGBA, 
# 540
COLOR_RGBA2BGRA = COLOR_BGRA2RGBA, 
# 542
COLOR_BGR2GRAY, 
# 543
COLOR_RGB2GRAY, 
# 544
COLOR_GRAY2BGR, 
# 545
COLOR_GRAY2RGB = COLOR_GRAY2BGR, 
# 546
COLOR_GRAY2BGRA, 
# 547
COLOR_GRAY2RGBA = COLOR_GRAY2BGRA, 
# 548
COLOR_BGRA2GRAY, 
# 549
COLOR_RGBA2GRAY, 
# 551
COLOR_BGR2BGR565, 
# 552
COLOR_RGB2BGR565, 
# 553
COLOR_BGR5652BGR, 
# 554
COLOR_BGR5652RGB, 
# 555
COLOR_BGRA2BGR565, 
# 556
COLOR_RGBA2BGR565, 
# 557
COLOR_BGR5652BGRA, 
# 558
COLOR_BGR5652RGBA, 
# 560
COLOR_GRAY2BGR565, 
# 561
COLOR_BGR5652GRAY, 
# 563
COLOR_BGR2BGR555, 
# 564
COLOR_RGB2BGR555, 
# 565
COLOR_BGR5552BGR, 
# 566
COLOR_BGR5552RGB, 
# 567
COLOR_BGRA2BGR555, 
# 568
COLOR_RGBA2BGR555, 
# 569
COLOR_BGR5552BGRA, 
# 570
COLOR_BGR5552RGBA, 
# 572
COLOR_GRAY2BGR555, 
# 573
COLOR_BGR5552GRAY, 
# 575
COLOR_BGR2XYZ, 
# 576
COLOR_RGB2XYZ, 
# 577
COLOR_XYZ2BGR, 
# 578
COLOR_XYZ2RGB, 
# 580
COLOR_BGR2YCrCb, 
# 581
COLOR_RGB2YCrCb, 
# 582
COLOR_YCrCb2BGR, 
# 583
COLOR_YCrCb2RGB, 
# 585
COLOR_BGR2HSV, 
# 586
COLOR_RGB2HSV, 
# 588
COLOR_BGR2Lab = 44, 
# 589
COLOR_RGB2Lab, 
# 591
COLOR_BGR2Luv = 50, 
# 592
COLOR_RGB2Luv, 
# 593
COLOR_BGR2HLS, 
# 594
COLOR_RGB2HLS, 
# 596
COLOR_HSV2BGR, 
# 597
COLOR_HSV2RGB, 
# 599
COLOR_Lab2BGR, 
# 600
COLOR_Lab2RGB, 
# 601
COLOR_Luv2BGR, 
# 602
COLOR_Luv2RGB, 
# 603
COLOR_HLS2BGR, 
# 604
COLOR_HLS2RGB, 
# 606
COLOR_BGR2HSV_FULL = 66, 
# 607
COLOR_RGB2HSV_FULL, 
# 608
COLOR_BGR2HLS_FULL, 
# 609
COLOR_RGB2HLS_FULL, 
# 611
COLOR_HSV2BGR_FULL, 
# 612
COLOR_HSV2RGB_FULL, 
# 613
COLOR_HLS2BGR_FULL, 
# 614
COLOR_HLS2RGB_FULL, 
# 616
COLOR_LBGR2Lab, 
# 617
COLOR_LRGB2Lab, 
# 618
COLOR_LBGR2Luv, 
# 619
COLOR_LRGB2Luv, 
# 621
COLOR_Lab2LBGR, 
# 622
COLOR_Lab2LRGB, 
# 623
COLOR_Luv2LBGR, 
# 624
COLOR_Luv2LRGB, 
# 626
COLOR_BGR2YUV, 
# 627
COLOR_RGB2YUV, 
# 628
COLOR_YUV2BGR, 
# 629
COLOR_YUV2RGB, 
# 632
COLOR_YUV2RGB_NV12 = 90, 
# 633
COLOR_YUV2BGR_NV12, 
# 634
COLOR_YUV2RGB_NV21, 
# 635
COLOR_YUV2BGR_NV21, 
# 636
COLOR_YUV420sp2RGB = COLOR_YUV2RGB_NV21, 
# 637
COLOR_YUV420sp2BGR, 
# 639
COLOR_YUV2RGBA_NV12, 
# 640
COLOR_YUV2BGRA_NV12, 
# 641
COLOR_YUV2RGBA_NV21, 
# 642
COLOR_YUV2BGRA_NV21, 
# 643
COLOR_YUV420sp2RGBA = COLOR_YUV2RGBA_NV21, 
# 644
COLOR_YUV420sp2BGRA, 
# 646
COLOR_YUV2RGB_YV12, 
# 647
COLOR_YUV2BGR_YV12, 
# 648
COLOR_YUV2RGB_IYUV, 
# 649
COLOR_YUV2BGR_IYUV, 
# 650
COLOR_YUV2RGB_I420 = COLOR_YUV2RGB_IYUV, 
# 651
COLOR_YUV2BGR_I420, 
# 652
COLOR_YUV420p2RGB = COLOR_YUV2RGB_YV12, 
# 653
COLOR_YUV420p2BGR, 
# 655
COLOR_YUV2RGBA_YV12 = 102, 
# 656
COLOR_YUV2BGRA_YV12, 
# 657
COLOR_YUV2RGBA_IYUV, 
# 658
COLOR_YUV2BGRA_IYUV, 
# 659
COLOR_YUV2RGBA_I420 = COLOR_YUV2RGBA_IYUV, 
# 660
COLOR_YUV2BGRA_I420, 
# 661
COLOR_YUV420p2RGBA = COLOR_YUV2RGBA_YV12, 
# 662
COLOR_YUV420p2BGRA, 
# 664
COLOR_YUV2GRAY_420 = 106, 
# 665
COLOR_YUV2GRAY_NV21 = COLOR_YUV2GRAY_420, 
# 666
COLOR_YUV2GRAY_NV12 = COLOR_YUV2GRAY_420, 
# 667
COLOR_YUV2GRAY_YV12 = COLOR_YUV2GRAY_420, 
# 668
COLOR_YUV2GRAY_IYUV = COLOR_YUV2GRAY_420, 
# 669
COLOR_YUV2GRAY_I420 = COLOR_YUV2GRAY_420, 
# 670
COLOR_YUV420sp2GRAY = COLOR_YUV2GRAY_420, 
# 671
COLOR_YUV420p2GRAY = COLOR_YUV2GRAY_420, 
# 674
COLOR_YUV2RGB_UYVY, 
# 675
COLOR_YUV2BGR_UYVY, 
# 678
COLOR_YUV2RGB_Y422 = COLOR_YUV2RGB_UYVY, 
# 679
COLOR_YUV2BGR_Y422, 
# 680
COLOR_YUV2RGB_UYNV = COLOR_YUV2RGB_UYVY, 
# 681
COLOR_YUV2BGR_UYNV, 
# 683
COLOR_YUV2RGBA_UYVY = 111, 
# 684
COLOR_YUV2BGRA_UYVY, 
# 687
COLOR_YUV2RGBA_Y422 = COLOR_YUV2RGBA_UYVY, 
# 688
COLOR_YUV2BGRA_Y422, 
# 689
COLOR_YUV2RGBA_UYNV = COLOR_YUV2RGBA_UYVY, 
# 690
COLOR_YUV2BGRA_UYNV, 
# 692
COLOR_YUV2RGB_YUY2 = 115, 
# 693
COLOR_YUV2BGR_YUY2, 
# 694
COLOR_YUV2RGB_YVYU, 
# 695
COLOR_YUV2BGR_YVYU, 
# 696
COLOR_YUV2RGB_YUYV = COLOR_YUV2RGB_YUY2, 
# 697
COLOR_YUV2BGR_YUYV, 
# 698
COLOR_YUV2RGB_YUNV = COLOR_YUV2RGB_YUY2, 
# 699
COLOR_YUV2BGR_YUNV, 
# 701
COLOR_YUV2RGBA_YUY2 = 119, 
# 702
COLOR_YUV2BGRA_YUY2, 
# 703
COLOR_YUV2RGBA_YVYU, 
# 704
COLOR_YUV2BGRA_YVYU, 
# 705
COLOR_YUV2RGBA_YUYV = COLOR_YUV2RGBA_YUY2, 
# 706
COLOR_YUV2BGRA_YUYV, 
# 707
COLOR_YUV2RGBA_YUNV = COLOR_YUV2RGBA_YUY2, 
# 708
COLOR_YUV2BGRA_YUNV, 
# 710
COLOR_YUV2GRAY_UYVY = 123, 
# 711
COLOR_YUV2GRAY_YUY2, 
# 713
COLOR_YUV2GRAY_Y422 = COLOR_YUV2GRAY_UYVY, 
# 714
COLOR_YUV2GRAY_UYNV = COLOR_YUV2GRAY_UYVY, 
# 715
COLOR_YUV2GRAY_YVYU, 
# 716
COLOR_YUV2GRAY_YUYV = COLOR_YUV2GRAY_YUY2, 
# 717
COLOR_YUV2GRAY_YUNV = COLOR_YUV2GRAY_YUY2, 
# 720
COLOR_RGBA2mRGBA, 
# 721
COLOR_mRGBA2RGBA, 
# 724
COLOR_RGB2YUV_I420, 
# 725
COLOR_BGR2YUV_I420, 
# 726
COLOR_RGB2YUV_IYUV = COLOR_RGB2YUV_I420, 
# 727
COLOR_BGR2YUV_IYUV, 
# 729
COLOR_RGBA2YUV_I420, 
# 730
COLOR_BGRA2YUV_I420, 
# 731
COLOR_RGBA2YUV_IYUV = COLOR_RGBA2YUV_I420, 
# 732
COLOR_BGRA2YUV_IYUV, 
# 733
COLOR_RGB2YUV_YV12, 
# 734
COLOR_BGR2YUV_YV12, 
# 735
COLOR_RGBA2YUV_YV12, 
# 736
COLOR_BGRA2YUV_YV12, 
# 739
COLOR_BayerBG2BGR = 46, 
# 740
COLOR_BayerGB2BGR, 
# 741
COLOR_BayerRG2BGR, 
# 742
COLOR_BayerGR2BGR, 
# 744
COLOR_BayerBG2RGB = COLOR_BayerRG2BGR, 
# 745
COLOR_BayerGB2RGB, 
# 746
COLOR_BayerRG2RGB = COLOR_BayerBG2BGR, 
# 747
COLOR_BayerGR2RGB, 
# 749
COLOR_BayerBG2GRAY = 86, 
# 750
COLOR_BayerGB2GRAY, 
# 751
COLOR_BayerRG2GRAY, 
# 752
COLOR_BayerGR2GRAY, 
# 755
COLOR_BayerBG2BGR_VNG = 62, 
# 756
COLOR_BayerGB2BGR_VNG, 
# 757
COLOR_BayerRG2BGR_VNG, 
# 758
COLOR_BayerGR2BGR_VNG, 
# 760
COLOR_BayerBG2RGB_VNG = COLOR_BayerRG2BGR_VNG, 
# 761
COLOR_BayerGB2RGB_VNG, 
# 762
COLOR_BayerRG2RGB_VNG = COLOR_BayerBG2BGR_VNG, 
# 763
COLOR_BayerGR2RGB_VNG, 
# 766
COLOR_BayerBG2BGR_EA = 135, 
# 767
COLOR_BayerGB2BGR_EA, 
# 768
COLOR_BayerRG2BGR_EA, 
# 769
COLOR_BayerGR2BGR_EA, 
# 771
COLOR_BayerBG2RGB_EA = COLOR_BayerRG2BGR_EA, 
# 772
COLOR_BayerGB2RGB_EA, 
# 773
COLOR_BayerRG2RGB_EA = COLOR_BayerBG2BGR_EA, 
# 774
COLOR_BayerGR2RGB_EA, 
# 777
COLOR_BayerBG2BGRA = 139, 
# 778
COLOR_BayerGB2BGRA, 
# 779
COLOR_BayerRG2BGRA, 
# 780
COLOR_BayerGR2BGRA, 
# 782
COLOR_BayerBG2RGBA = COLOR_BayerRG2BGRA, 
# 783
COLOR_BayerGB2RGBA, 
# 784
COLOR_BayerRG2RGBA = COLOR_BayerBG2BGRA, 
# 785
COLOR_BayerGR2RGBA, 
# 787
COLOR_COLORCVT_MAX = 143
# 788
}; 
# 794
enum RectanglesIntersectTypes { 
# 795
INTERSECT_NONE, 
# 796
INTERSECT_PARTIAL, 
# 797
INTERSECT_FULL
# 798
}; 
# 803
enum LineTypes { 
# 804
FILLED = (-1), 
# 805
LINE_4 = 4, 
# 806
LINE_8 = 8, 
# 807
LINE_AA = 16
# 808
}; 
# 813
enum HersheyFonts { 
# 814
FONT_HERSHEY_SIMPLEX, 
# 815
FONT_HERSHEY_PLAIN, 
# 816
FONT_HERSHEY_DUPLEX, 
# 817
FONT_HERSHEY_COMPLEX, 
# 818
FONT_HERSHEY_TRIPLEX, 
# 819
FONT_HERSHEY_COMPLEX_SMALL, 
# 820
FONT_HERSHEY_SCRIPT_SIMPLEX, 
# 821
FONT_HERSHEY_SCRIPT_COMPLEX, 
# 822
FONT_ITALIC = 16
# 823
}; 
# 828
enum MarkerTypes { 
# 830
MARKER_CROSS, 
# 831
MARKER_TILTED_CROSS, 
# 832
MARKER_STAR, 
# 833
MARKER_DIAMOND, 
# 834
MARKER_SQUARE, 
# 835
MARKER_TRIANGLE_UP, 
# 836
MARKER_TRIANGLE_DOWN
# 837
}; 
# 841
class GeneralizedHough : public Algorithm { 
# 845
public: virtual void setTemplate(InputArray templ, Point templCenter = Point(-1, -1)) = 0; 
# 846
virtual void setTemplate(InputArray edges, InputArray dx, InputArray dy, Point templCenter = Point(-1, -1)) = 0; 
# 849
virtual void detect(InputArray image, OutputArray positions, OutputArray votes = noArray()) = 0; 
# 850
virtual void detect(InputArray edges, InputArray dx, InputArray dy, OutputArray positions, OutputArray votes = noArray()) = 0; 
# 853
virtual void setCannyLowThresh(int cannyLowThresh) = 0; 
# 854
virtual int getCannyLowThresh() const = 0; 
# 857
virtual void setCannyHighThresh(int cannyHighThresh) = 0; 
# 858
virtual int getCannyHighThresh() const = 0; 
# 861
virtual void setMinDist(double minDist) = 0; 
# 862
virtual double getMinDist() const = 0; 
# 865
virtual void setDp(double dp) = 0; 
# 866
virtual double getDp() const = 0; 
# 869
virtual void setMaxBufferSize(int maxBufferSize) = 0; 
# 870
virtual int getMaxBufferSize() const = 0; 
# 871
}; 
# 877
class GeneralizedHoughBallard : public GeneralizedHough { 
# 881
public: virtual void setLevels(int levels) = 0; 
# 882
virtual int getLevels() const = 0; 
# 885
virtual void setVotesThreshold(int votesThreshold) = 0; 
# 886
virtual int getVotesThreshold() const = 0; 
# 887
}; 
# 893
class GeneralizedHoughGuil : public GeneralizedHough { 
# 897
public: virtual void setXi(double xi) = 0; 
# 898
virtual double getXi() const = 0; 
# 901
virtual void setLevels(int levels) = 0; 
# 902
virtual int getLevels() const = 0; 
# 905
virtual void setAngleEpsilon(double angleEpsilon) = 0; 
# 906
virtual double getAngleEpsilon() const = 0; 
# 909
virtual void setMinAngle(double minAngle) = 0; 
# 910
virtual double getMinAngle() const = 0; 
# 913
virtual void setMaxAngle(double maxAngle) = 0; 
# 914
virtual double getMaxAngle() const = 0; 
# 917
virtual void setAngleStep(double angleStep) = 0; 
# 918
virtual double getAngleStep() const = 0; 
# 921
virtual void setAngleThresh(int angleThresh) = 0; 
# 922
virtual int getAngleThresh() const = 0; 
# 925
virtual void setMinScale(double minScale) = 0; 
# 926
virtual double getMinScale() const = 0; 
# 929
virtual void setMaxScale(double maxScale) = 0; 
# 930
virtual double getMaxScale() const = 0; 
# 933
virtual void setScaleStep(double scaleStep) = 0; 
# 934
virtual double getScaleStep() const = 0; 
# 937
virtual void setScaleThresh(int scaleThresh) = 0; 
# 938
virtual int getScaleThresh() const = 0; 
# 941
virtual void setPosThresh(int posThresh) = 0; 
# 942
virtual int getPosThresh() const = 0; 
# 943
}; 
# 952 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
class CLAHE : public Algorithm { 
# 960
public: virtual void apply(InputArray src, OutputArray dst) = 0; 
# 966
virtual void setClipLimit(double clipLimit) = 0; 
# 969
virtual double getClipLimit() const = 0; 
# 976
virtual void setTilesGridSize(Size tileGridSize) = 0; 
# 979
virtual Size getTilesGridSize() const = 0; 
# 981
virtual void collectGarbage() = 0; 
# 982
}; 
# 989
class Subdiv2D { 
# 993
public: enum { PTLOC_ERROR = (-2), 
# 994
PTLOC_OUTSIDE_RECT, 
# 995
PTLOC_INSIDE = 0, 
# 996
PTLOC_VERTEX, 
# 997
PTLOC_ON_EDGE
# 998
}; 
# 1001
enum { NEXT_AROUND_ORG, 
# 1002
NEXT_AROUND_DST = 34, 
# 1003
PREV_AROUND_ORG = 17, 
# 1004
PREV_AROUND_DST = 51, 
# 1005
NEXT_AROUND_LEFT = 19, 
# 1006
NEXT_AROUND_RIGHT = 49, 
# 1007
PREV_AROUND_LEFT = 32, 
# 1008
PREV_AROUND_RIGHT = 2
# 1009
}; 
# 1014
Subdiv2D(); 
# 1024 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Subdiv2D(Rect rect); 
# 1031
void initDelaunay(Rect rect); 
# 1043 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int insert(Point2f pt); 
# 1052 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void insert(const std::vector< Point_< float> >  & ptvec); 
# 1074 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int locate(Point2f pt, int & edge, int & vertex); 
# 1088 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int findNearest(Point2f pt, Point2f * nearestPt = 0); 
# 1097 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void getEdgeList(std::vector< Vec< float, 4> >  & edgeList) const; 
# 1105
void getLeadingEdgeList(std::vector< int>  & leadingEdgeList) const; 
# 1114 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void getTriangleList(std::vector< Vec< float, 6> >  & triangleList) const; 
# 1123 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void getVoronoiFacetList(const std::vector< int>  & idx, std::vector< std::vector< Point_< float> > >  & facetList, std::vector< Point_< float> >  & facetCenters); 
# 1133 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Point2f getVertex(int vertex, int * firstEdge = 0) const; 
# 1153 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int getEdge(int edge, int nextEdgeType) const; 
# 1162 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int nextEdge(int edge) const; 
# 1176 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int rotateEdge(int edge, int rotate) const; 
# 1177
int symEdge(int edge) const; 
# 1186 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int edgeOrg(int edge, Point2f * orgpt = 0) const; 
# 1195 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int edgeDst(int edge, Point2f * dstpt = 0) const; 
# 1198
protected: int newEdge(); 
# 1199
void deleteEdge(int edge); 
# 1200
int newPoint(Point2f pt, bool isvirtual, int firstEdge = 0); 
# 1201
void deletePoint(int vtx); 
# 1202
void setEdgePoints(int edge, int orgPt, int dstPt); 
# 1203
void splice(int edgeA, int edgeB); 
# 1204
int connectEdges(int edgeA, int edgeB); 
# 1205
void swapEdges(int edge); 
# 1206
int isRightOf(Point2f pt, int edge) const; 
# 1207
void calcVoronoi(); 
# 1208
void clearVoronoi(); 
# 1209
void checkSubdiv() const; 
# 1211
struct Vertex { 
# 1213
Vertex(); 
# 1214
Vertex(Point2f pt, bool _isvirtual, int _firstEdge = 0); 
# 1215
bool isvirtual() const; 
# 1216
bool isfree() const; 
# 1218
int firstEdge; 
# 1219
int type; 
# 1220
Point2f pt; 
# 1221
}; 
# 1223
struct QuadEdge { 
# 1225
QuadEdge(); 
# 1226
QuadEdge(int edgeidx); 
# 1227
bool isfree() const; 
# 1229
int next[4]; 
# 1230
int pt[4]; 
# 1231
}; 
# 1234
std::vector< Vertex>  vtx; 
# 1236
std::vector< QuadEdge>  qedges; 
# 1237
int freeQEdge; 
# 1238
int freePoint; 
# 1239
bool validGeometry; 
# 1241
int recentEdge; 
# 1243
Point2f topLeft; 
# 1245
Point2f bottomRight; 
# 1246
}; 
# 1260 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
class LineSegmentDetector : public Algorithm { 
# 1284 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
public: virtual void detect(InputArray _image, OutputArray _lines, OutputArray width = noArray(), OutputArray prec = noArray(), OutputArray nfa = noArray()) = 0; 
# 1293
virtual void drawSegments(InputOutputArray _image, InputArray lines) = 0; 
# 1303 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
virtual int compareSegments(const Size & size, InputArray lines1, InputArray lines2, InputOutputArray _image = noArray()) = 0; 
# 1305
virtual ~LineSegmentDetector() { } 
# 1306
}; 
# 1325 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Ptr< LineSegmentDetector>  createLineSegmentDetector(int _refine = LSD_REFINE_STD, double _scale = (0.8), double _sigma_scale = (0.6), double _quant = (2.0), double _ang_th = (22.5), double _log_eps = 0, double _density_th = (0.7), int _n_bins = 1024); 
# 1353 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Mat getGaussianKernel(int ksize, double sigma, int ktype = 6); 
# 1373 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize = false, int ktype = 5); 
# 1390 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi = (3.141592653589793) * (0.5), int ktype = 6); 
# 1394
static inline Scalar morphologyDefaultBorderValue() { return Scalar::all((double)(1.7976931348623157081E308L)); } 
# 1409 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Mat getStructuringElement(int shape, Size ksize, Point anchor = Point(-1, -1)); 
# 1431 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void medianBlur(InputArray src, OutputArray dst, int ksize); 
# 1453 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT); 
# 1485 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType = BORDER_DEFAULT); 
# 1513 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor = Point(-1, -1), bool normalize = true, int borderType = BORDER_DEFAULT); 
# 1536 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void sqrBoxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor = Point(-1, -1), bool normalize = true, int borderType = BORDER_DEFAULT); 
# 1559 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void blur(InputArray src, OutputArray dst, Size ksize, Point anchor = Point(-1, -1), int borderType = BORDER_DEFAULT); 
# 1593 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor = Point(-1, -1), double delta = 0, int borderType = BORDER_DEFAULT); 
# 1614 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor = Point(-1, -1), double delta = 0, int borderType = BORDER_DEFAULT); 
# 1667 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize = 3, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT); 
# 1690 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void spatialGradient(InputArray src, OutputArray dx, OutputArray dy, int ksize = 3, int borderType = BORDER_DEFAULT); 
# 1716 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT); 
# 1747 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize = 1, double scale = 1, double delta = 0, int borderType = BORDER_DEFAULT); 
# 1779 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize = 3, bool L2gradient = false); 
# 1797 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void Canny(InputArray dx, InputArray dy, OutputArray edges, double threshold1, double threshold2, bool L2gradient = false); 
# 1815 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize = 3, int borderType = BORDER_DEFAULT); 
# 1838 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType = BORDER_DEFAULT); 
# 1868 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType = BORDER_DEFAULT); 
# 1895 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void preCornerDetect(InputArray src, OutputArray dst, int ksize, int borderType = BORDER_DEFAULT); 
# 1938 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria); 
# 1986 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void goodFeaturesToTrack(InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask = noArray(), int blockSize = 3, bool useHarrisDetector = false, double k = (0.04)); 
# 1991
void goodFeaturesToTrack(InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask, int blockSize, int gradientSize, bool useHarrisDetector = false, double k = (0.04)); 
# 2027 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void HoughLines(InputArray image, OutputArray lines, double rho, double theta, int threshold, double srn = 0, double stn = 0, double min_theta = 0, double max_theta = (3.141592653589793)); 
# 2060 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void HoughLinesP(InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength = 0, double maxLineGap = 0); 
# 2081 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void HoughLinesPointSet(InputArray _point, OutputArray _lines, int lines_max, int threshold, double min_rho, double max_rho, double rho_step, double min_theta, double max_theta, double theta_step); 
# 2123 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void HoughCircles(InputArray image, OutputArray circles, int method, double dp, double minDist, double param1 = 100, double param2 = 100, int minRadius = 0, int maxRadius = 0); 
# 2161 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor = Point(-1, -1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar & borderValue = morphologyDefaultBorderValue()); 
# 2193 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor = Point(-1, -1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar & borderValue = morphologyDefaultBorderValue()); 
# 2222 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor = Point(-1, -1), int iterations = 1, int borderType = BORDER_CONSTANT, const Scalar & borderValue = morphologyDefaultBorderValue()); 
# 2267 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void resize(InputArray src, OutputArray dst, Size dsize, double fx = 0, double fy = 0, int interpolation = INTER_LINEAR); 
# 2295 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, const Scalar & borderValue = Scalar()); 
# 2327 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, const Scalar & borderValue = Scalar()); 
# 2365 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode = BORDER_CONSTANT, const Scalar & borderValue = Scalar()); 
# 2400 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation = false); 
# 2423 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
inline Mat getRotationMatrix2D(Point2f center, double angle, double scale); 
# 2426
Matx23d getRotationMatrix2D_(Point2f center, double angle, double scale); 
# 2429
inline Mat getRotationMatrix2D(Point2f center, double angle, double scale) 
# 2430
{ 
# 2431
return Mat(getRotationMatrix2D_(center, angle, scale), true); 
# 2432
} 
# 2449 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Mat getAffineTransform(const Point2f  src[], const Point2f  dst[]); 
# 2462 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void invertAffineTransform(InputArray M, OutputArray iM); 
# 2480 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Mat getPerspectiveTransform(InputArray src, InputArray dst, int solveMethod = DECOMP_LU); 
# 2483
Mat getPerspectiveTransform(const Point2f  src[], const Point2f  dst[], int solveMethod = DECOMP_LU); 
# 2486
Mat getAffineTransform(InputArray src, InputArray dst); 
# 2508 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType = -1); 
# 2554 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void logPolar(InputArray src, OutputArray dst, Point2f center, double M, int flags); 
# 2595 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void linearPolar(InputArray src, OutputArray dst, Point2f center, double maxRadius, int flags); 
# 2686 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void warpPolar(InputArray src, OutputArray dst, Size dsize, Point2f center, double maxRadius, int flags); 
# 2696 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void integral(InputArray src, OutputArray sum, int sdepth = -1); 
# 2699
void integral(InputArray src, OutputArray sum, OutputArray sqsum, int sdepth = -1, int sqdepth = -1); 
# 2736 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void integral(InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth = -1, int sqdepth = -1); 
# 2762 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void accumulate(InputArray src, InputOutputArray dst, InputArray mask = noArray()); 
# 2781 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void accumulateSquare(InputArray src, InputOutputArray dst, InputArray mask = noArray()); 
# 2800 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void accumulateProduct(InputArray src1, InputArray src2, InputOutputArray dst, InputArray mask = noArray()); 
# 2821 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void accumulateWeighted(InputArray src, InputOutputArray dst, double alpha, InputArray mask = noArray()); 
# 2859 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Point2d phaseCorrelate(InputArray src1, InputArray src2, InputArray window = noArray(), double * response = 0); 
# 2877 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void createHanningWindow(OutputArray dst, Size winSize, int type); 
# 2908 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type); 
# 2937 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C); 
# 2969 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void pyrDown(InputArray src, OutputArray dst, const Size & dstsize = Size(), int borderType = BORDER_DEFAULT); 
# 2989 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void pyrUp(InputArray src, OutputArray dst, const Size & dstsize = Size(), int borderType = BORDER_DEFAULT); 
# 3003 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType = BORDER_DEFAULT); 
# 3048 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void calcHist(const Mat * images, int nimages, const int * channels, InputArray mask, OutputArray hist, int dims, const int * histSize, const float ** ranges, bool uniform = true, bool accumulate = false); 
# 3057
void calcHist(const Mat * images, int nimages, const int * channels, InputArray mask, SparseMat & hist, int dims, const int * histSize, const float ** ranges, bool uniform = true, bool accumulate = false); 
# 3064
void calcHist(InputArrayOfArrays images, const std::vector< int>  & channels, InputArray mask, OutputArray hist, const std::vector< int>  & histSize, const std::vector< float>  & ranges, bool accumulate = false); 
# 3110 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void calcBackProject(const Mat * images, int nimages, const int * channels, InputArray hist, OutputArray backProject, const float ** ranges, double scale = 1, bool uniform = true); 
# 3116
void calcBackProject(const Mat * images, int nimages, const int * channels, const SparseMat & hist, OutputArray backProject, const float ** ranges, double scale = 1, bool uniform = true); 
# 3122
void calcBackProject(InputArrayOfArrays images, const std::vector< int>  & channels, InputArray hist, OutputArray dst, const std::vector< float>  & ranges, double scale); 
# 3142 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
double compareHist(InputArray H1, InputArray H2, int method); 
# 3145
double compareHist(const SparseMat & H1, const SparseMat & H2, int method); 
# 3162 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void equalizeHist(InputArray src, OutputArray dst); 
# 3170
Ptr< CLAHE>  createCLAHE(double clipLimit = (40.0), Size tileGridSize = Size(8, 8)); 
# 3206 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
float EMD(InputArray signature1, InputArray signature2, int distType, InputArray cost = noArray(), float * lowerBound = 0, OutputArray flow = noArray()); 
# 3210
float wrapperEMD(InputArray signature1, InputArray signature2, int distType, InputArray cost = noArray(), Ptr< float>  lowerBound = Ptr< float> (), OutputArray flow = noArray()); 
# 3246 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void watershed(InputArray image, InputOutputArray markers); 
# 3287 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel = 1, TermCriteria termcrit = TermCriteria((TermCriteria::MAX_ITER) + (TermCriteria::EPS), 5, 1)); 
# 3319 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void grabCut(InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode = GC_EVAL); 
# 3380 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void distanceTransform(InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize, int labelType = DIST_LABEL_CCOMP); 
# 3395 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void distanceTransform(InputArray src, OutputArray dst, int distanceType, int maskSize, int dstType = 5); 
# 3406 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int floodFill(InputOutputArray image, Point seedPoint, Scalar newVal, Rect * rect = 0, Scalar loDiff = Scalar(), Scalar upDiff = Scalar(), int flags = 4); 
# 3482 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int floodFill(InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, Rect * rect = 0, Scalar loDiff = Scalar(), Scalar upDiff = Scalar(), int flags = 4); 
# 3494 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void blendLinear(InputArray src1, InputArray src2, InputArray weights1, InputArray weights2, OutputArray dst); 
# 3542 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void cvtColor(InputArray src, OutputArray dst, int code, int dstCn = 0); 
# 3562 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void cvtColorTwoPlane(InputArray src1, InputArray src2, OutputArray dst, int code); 
# 3594 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void demosaicing(InputArray src, OutputArray dst, int code, int dstCn = 0); 
# 3617 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Moments moments(InputArray array, bool binaryImage = false); 
# 3638 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void HuMoments(const Moments & moments, double  hu[7]); 
# 3641
void HuMoments(const Moments & m, OutputArray hu); 
# 3649
enum TemplateMatchModes { 
# 3650
TM_SQDIFF, 
# 3651
TM_SQDIFF_NORMED, 
# 3652
TM_CCORR, 
# 3653
TM_CCORR_NORMED, 
# 3654
TM_CCOEFF, 
# 3657
TM_CCOEFF_NORMED
# 3658
}; 
# 3687 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method, InputArray mask = noArray()); 
# 3716 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int connectedComponents(InputArray image, OutputArray labels, int connectivity, int ltype, int ccltype); 
# 3727 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int connectedComponents(InputArray image, OutputArray labels, int connectivity = 8, int ltype = 4); 
# 3753 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int connectedComponentsWithStats(InputArray image, OutputArray labels, OutputArray stats, OutputArray centroids, int connectivity, int ltype, int ccltype); 
# 3768 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int connectedComponentsWithStats(InputArray image, OutputArray labels, OutputArray stats, OutputArray centroids, int connectivity = 8, int ltype = 4); 
# 3798 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void findContours(InputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset = Point()); 
# 3803
void findContours(InputArray image, OutputArrayOfArrays contours, int mode, int method, Point offset = Point()); 
# 3829 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void approxPolyDP(InputArray curve, OutputArray approxCurve, double epsilon, bool closed); 
# 3840 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
double arcLength(InputArray curve, bool closed); 
# 3849 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Rect boundingRect(InputArray array); 
# 3881 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
double contourArea(InputArray contour, bool oriented = false); 
# 3891 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
RotatedRect minAreaRect(InputArray points); 
# 3902 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void boxPoints(RotatedRect box, OutputArray points); 
# 3912 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void minEnclosingCircle(InputArray points, Point2f & center, float & radius); 
# 3937 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
double minEnclosingTriangle(InputArray points, OutputArray triangle); 
# 3948 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
double matchShapes(InputArray contour1, InputArray contour2, int method, double parameter); 
# 3982 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void convexHull(InputArray points, OutputArray hull, bool clockwise = false, bool returnPoints = true); 
# 4002 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void convexityDefects(InputArray contour, InputArray convexhull, OutputArray convexityDefects); 
# 4011 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
bool isContourConvex(InputArray contour); 
# 4030 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
float intersectConvexConvex(InputArray _p1, InputArray _p2, OutputArray _p12, bool handleNested = true); 
# 4047 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
RotatedRect fitEllipse(InputArray points); 
# 4084 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
RotatedRect fitEllipseAMS(InputArray points); 
# 4129 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
RotatedRect fitEllipseDirect(InputArray points); 
# 4165 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void fitLine(InputArray points, OutputArray line, int distType, double param, double reps, double aeps); 
# 4184 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
double pointPolygonTest(InputArray contour, Point2f pt, bool measureDist); 
# 4201 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
int rotatedRectangleIntersection(const RotatedRect & rect1, const RotatedRect & rect2, OutputArray intersectingRegion); 
# 4205
Ptr< GeneralizedHoughBallard>  createGeneralizedHoughBallard(); 
# 4209
Ptr< GeneralizedHoughGuil>  createGeneralizedHoughGuil(); 
# 4217
enum ColormapTypes { 
# 4219
COLORMAP_AUTUMN, 
# 4220
COLORMAP_BONE, 
# 4221
COLORMAP_JET, 
# 4222
COLORMAP_WINTER, 
# 4223
COLORMAP_RAINBOW, 
# 4224
COLORMAP_OCEAN, 
# 4225
COLORMAP_SUMMER, 
# 4226
COLORMAP_SPRING, 
# 4227
COLORMAP_COOL, 
# 4228
COLORMAP_HSV, 
# 4229
COLORMAP_PINK, 
# 4230
COLORMAP_HOT, 
# 4231
COLORMAP_PARULA, 
# 4232
COLORMAP_MAGMA, 
# 4233
COLORMAP_INFERNO, 
# 4234
COLORMAP_PLASMA, 
# 4235
COLORMAP_VIRIDIS, 
# 4236
COLORMAP_CIVIDIS, 
# 4237
COLORMAP_TWILIGHT, 
# 4238
COLORMAP_TWILIGHT_SHIFTED, 
# 4239
COLORMAP_TURBO
# 4240
}; 
# 4252 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void applyColorMap(InputArray src, OutputArray dst, int colormap); 
# 4260
void applyColorMap(InputArray src, OutputArray dst, InputArray userColor); 
# 4286 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void line(InputOutputArray img, Point pt1, Point pt2, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4302 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void arrowedLine(InputOutputArray img, Point pt1, Point pt2, const Scalar & color, int thickness = 1, int line_type = 8, int shift = 0, double tipLength = (0.1)); 
# 4319 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void rectangle(InputOutputArray img, Point pt1, Point pt2, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4328
void rectangle(InputOutputArray img, Rect rec, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4348 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void circle(InputOutputArray img, Point center, int radius, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4377 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4391 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void ellipse(InputOutputArray img, const RotatedRect & box, const Scalar & color, int thickness = 1, int lineType = LINE_8); 
# 4411 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void drawMarker(InputOutputArray img, Point position, const Scalar & color, int markerType = MARKER_CROSS, int markerSize = 20, int thickness = 1, int line_type = 8); 
# 4420
void fillConvexPoly(InputOutputArray img, const Point * pts, int npts, const Scalar & color, int lineType = LINE_8, int shift = 0); 
# 4437 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void fillConvexPoly(InputOutputArray img, InputArray points, const Scalar & color, int lineType = LINE_8, int shift = 0); 
# 4442
void fillPoly(InputOutputArray img, const Point ** pts, const int * npts, int ncontours, const Scalar & color, int lineType = LINE_8, int shift = 0, Point offset = Point()); 
# 4465 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void fillPoly(InputOutputArray img, InputArrayOfArrays pts, const Scalar & color, int lineType = LINE_8, int shift = 0, Point offset = Point()); 
# 4470
void polylines(InputOutputArray img, const Point *const * pts, const int * npts, int ncontours, bool isClosed, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4487 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void polylines(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar & color, int thickness = 1, int lineType = LINE_8, int shift = 0); 
# 4528 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar & color, int thickness = 1, int lineType = LINE_8, InputArray hierarchy = noArray(), int maxLevel = 2147483647, Point offset = Point()); 
# 4543 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
bool clipLine(Size imgSize, Point & pt1, Point & pt2); 
# 4550
bool clipLine(Size2l imgSize, Point2l & pt1, Point2l & pt2); 
# 4557
bool clipLine(Rect imgRect, Point & pt1, Point & pt2); 
# 4573 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, std::vector< Point_< int> >  & pts); 
# 4586 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void ellipse2Poly(Point2d center, Size2d axes, int angle, int arcStart, int arcEnd, int delta, std::vector< Point_< double> >  & pts); 
# 4607 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
void putText(InputOutputArray img, const String & text, Point org, int fontFace, double fontScale, Scalar color, int thickness = 1, int lineType = LINE_8, bool bottomLeftOrigin = false); 
# 4657 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
Size getTextSize(const String & text, int fontFace, double fontScale, int thickness, int * baseLine); 
# 4671 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
double getFontScaleFromHeight(const int fontFace, const int pixelHeight, const int thickness = 1); 
# 4707 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
class LineIterator { 
# 4719 "/usr/include/opencv4/opencv2/imgproc.hpp" 3
public: LineIterator(const Mat & img, Point pt1, Point pt2, int connectivity = 8, bool leftToRight = false); 
# 4723
inline uchar *operator*(); 
# 4726
inline LineIterator &operator++(); 
# 4729
inline LineIterator operator++(int); 
# 4732
inline Point pos() const; 
# 4734
uchar *ptr; 
# 4735
const uchar *ptr0; 
# 4736
int step, elemSize; 
# 4737
int err, count; 
# 4738
int minusDelta, plusDelta; 
# 4739
int minusStep, plusStep; 
# 4740
}; 
# 4747
inline uchar *LineIterator::operator*() 
# 4748
{ 
# 4749
return ptr; 
# 4750
} 
# 4753
inline LineIterator &LineIterator::operator++() 
# 4754
{ 
# 4755
int mask = ((err) < 0) ? -1 : 0; 
# 4756
(err) += ((minusDelta) + ((plusDelta) & mask)); 
# 4757
(ptr) += ((minusStep) + ((plusStep) & mask)); 
# 4758
return *this; 
# 4759
} 
# 4762
inline LineIterator LineIterator::operator++(int) 
# 4763
{ 
# 4764
LineIterator it = *this; 
# 4765
(++(*this)); 
# 4766
return it; 
# 4767
} 
# 4770
inline Point LineIterator::pos() const 
# 4771
{ 
# 4772
Point p; 
# 4773
(p.y) = ((int)(((ptr) - (ptr0)) / (step))); 
# 4774
(p.x) = ((int)((((ptr) - (ptr0)) - ((p.y) * (step))) / (elemSize))); 
# 4775
return p; 
# 4776
} 
# 4784
}
# 71 "/usr/include/opencv4/opencv2/ml.hpp" 3
namespace cv { 
# 74
namespace ml { 
# 81
enum VariableTypes { 
# 83
VAR_NUMERICAL, 
# 84
VAR_ORDERED = 0, 
# 85
VAR_CATEGORICAL
# 86
}; 
# 89
enum ErrorTypes { 
# 91
TEST_ERROR, 
# 92
TRAIN_ERROR
# 93
}; 
# 96
enum SampleTypes { 
# 98
ROW_SAMPLE, 
# 99
COL_SAMPLE
# 100
}; 
# 107
class ParamGrid { 
# 111
public: ParamGrid(); 
# 113
ParamGrid(double _minVal, double _maxVal, double _logStep); 
# 115
double minVal; 
# 116
double maxVal; 
# 125 "/usr/include/opencv4/opencv2/ml.hpp" 3
double logStep; 
# 133
static Ptr< ParamGrid>  create(double minVal = (0.0), double maxVal = (0.0), double logstep = (1.0)); 
# 134
}; 
# 145 "/usr/include/opencv4/opencv2/ml.hpp" 3
class TrainData { 
# 148
public: static float missingValue() { return (3.4028235E38F); } 
# 149
virtual ~TrainData(); 
# 151
virtual int getLayout() const = 0; 
# 152
virtual int getNTrainSamples() const = 0; 
# 153
virtual int getNTestSamples() const = 0; 
# 154
virtual int getNSamples() const = 0; 
# 155
virtual int getNVars() const = 0; 
# 156
virtual int getNAllVars() const = 0; 
# 158
virtual void getSample(InputArray varIdx, int sidx, float * buf) const = 0; 
# 159
virtual Mat getSamples() const = 0; 
# 160
virtual Mat getMissing() const = 0; 
# 174 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual Mat getTrainSamples(int layout = ROW_SAMPLE, bool compressSamples = true, bool compressVars = true) const = 0; 
# 183
virtual Mat getTrainResponses() const = 0; 
# 191
virtual Mat getTrainNormCatResponses() const = 0; 
# 192
virtual Mat getTestResponses() const = 0; 
# 193
virtual Mat getTestNormCatResponses() const = 0; 
# 194
virtual Mat getResponses() const = 0; 
# 195
virtual Mat getNormCatResponses() const = 0; 
# 196
virtual Mat getSampleWeights() const = 0; 
# 197
virtual Mat getTrainSampleWeights() const = 0; 
# 198
virtual Mat getTestSampleWeights() const = 0; 
# 199
virtual Mat getVarIdx() const = 0; 
# 200
virtual Mat getVarType() const = 0; 
# 201
virtual Mat getVarSymbolFlags() const = 0; 
# 202
virtual int getResponseType() const = 0; 
# 203
virtual Mat getTrainSampleIdx() const = 0; 
# 204
virtual Mat getTestSampleIdx() const = 0; 
# 205
virtual void getValues(int vi, InputArray sidx, float * values) const = 0; 
# 206
virtual void getNormCatValues(int vi, InputArray sidx, int * values) const = 0; 
# 207
virtual Mat getDefaultSubstValues() const = 0; 
# 209
virtual int getCatCount(int vi) const = 0; 
# 215
virtual Mat getClassLabels() const = 0; 
# 217
virtual Mat getCatOfs() const = 0; 
# 218
virtual Mat getCatMap() const = 0; 
# 223
virtual void setTrainTestSplit(int count, bool shuffle = true) = 0; 
# 233 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual void setTrainTestSplitRatio(double ratio, bool shuffle = true) = 0; 
# 234
virtual void shuffleTrainTest() = 0; 
# 237
virtual Mat getTestSamples() const = 0; 
# 240
virtual void getNames(std::vector< std::__cxx11::basic_string< char> >  & names) const = 0; 
# 246
static Mat getSubVector(const Mat & vec, const Mat & idx); 
# 253
static Mat getSubMatrix(const Mat & matrix, const Mat & idx, int layout); 
# 284 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< TrainData>  loadFromCSV(const String & filename, int headerLineCount, int responseStartIdx = -1, int responseEndIdx = -1, const String & varTypeSpec = String(), char delimiter = ',', char missch = '\?'); 
# 311 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< TrainData>  create(InputArray samples, int layout, InputArray responses, InputArray varIdx = noArray(), InputArray sampleIdx = noArray(), InputArray sampleWeights = noArray(), InputArray varType = noArray()); 
# 314
}; 
# 318
class StatModel : public Algorithm { 
# 322
public: enum Flags { 
# 323
UPDATE_MODEL = 1, 
# 324
RAW_OUTPUT = 1, 
# 325
COMPRESSED_INPUT, 
# 326
PREPROCESSED_INPUT = 4
# 327
}; 
# 330
virtual int getVarCount() const = 0; 
# 332
virtual bool empty() const override; 
# 335
virtual bool isTrained() const = 0; 
# 337
virtual bool isClassifier() const = 0; 
# 346 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual bool train(const Ptr< TrainData>  & trainData, int flags = 0); 
# 354
virtual bool train(InputArray samples, int layout, InputArray responses); 
# 369 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual float calcError(const Ptr< TrainData>  & data, bool test, OutputArray resp) const; 
# 377
virtual float predict(InputArray samples, OutputArray results = noArray(), int flags = 0) const = 0; 
# 383
template< class _Tp> static Ptr< _Tp>  train(const Ptr< TrainData>  &data, int flags = 0) 
# 384
{ 
# 385
Ptr< _Tp>  model = _Tp::create(); 
# 386
return ((!model.empty()) && model->train(data, flags)) ? model : Ptr< _Tp> (); 
# 387
} 
# 388
}; 
# 398 "/usr/include/opencv4/opencv2/ml.hpp" 3
class NormalBayesClassifier : public StatModel { 
# 409 "/usr/include/opencv4/opencv2/ml.hpp" 3
public: virtual float predictProb(InputArray inputs, OutputArray outputs, OutputArray outputProbs, int flags = 0) const = 0; 
# 414
static Ptr< NormalBayesClassifier>  create(); 
# 425 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< NormalBayesClassifier>  load(const String & filepath, const String & nodeName = String()); 
# 426
}; 
# 436 "/usr/include/opencv4/opencv2/ml.hpp" 3
class KNearest : public StatModel { 
# 442
public: virtual int getDefaultK() const = 0; 
# 444
virtual void setDefaultK(int val) = 0; 
# 448
virtual bool getIsClassifier() const = 0; 
# 450
virtual void setIsClassifier(bool val) = 0; 
# 454
virtual int getEmax() const = 0; 
# 456
virtual void setEmax(int val) = 0; 
# 460
virtual int getAlgorithmType() const = 0; 
# 462
virtual void setAlgorithmType(int val) = 0; 
# 490 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual float findNearest(InputArray samples, int k, OutputArray results, OutputArray neighborResponses = noArray(), OutputArray dist = noArray()) const = 0; 
# 497
enum Types { 
# 499
BRUTE_FORCE = 1, 
# 500
KDTREE
# 501
}; 
# 507
static Ptr< KNearest>  create(); 
# 515
static Ptr< KNearest>  load(const String & filepath); 
# 516
}; 
# 526 "/usr/include/opencv4/opencv2/ml.hpp" 3
class SVM : public StatModel { 
# 530
public: class Kernel : public Algorithm { 
# 533
public: virtual int getType() const = 0; 
# 534
virtual void calc(int vcount, int n, const float * vecs, const float * another, float * results) = 0; 
# 535
}; 
# 540
virtual int getType() const = 0; 
# 542
virtual void setType(int val) = 0; 
# 547
virtual double getGamma() const = 0; 
# 549
virtual void setGamma(double val) = 0; 
# 554
virtual double getCoef0() const = 0; 
# 556
virtual void setCoef0(double val) = 0; 
# 561
virtual double getDegree() const = 0; 
# 563
virtual void setDegree(double val) = 0; 
# 568
virtual double getC() const = 0; 
# 570
virtual void setC(double val) = 0; 
# 575
virtual double getNu() const = 0; 
# 577
virtual void setNu(double val) = 0; 
# 582
virtual double getP() const = 0; 
# 584
virtual void setP(double val) = 0; 
# 592
virtual Mat getClassWeights() const = 0; 
# 594
virtual void setClassWeights(const Mat & val) = 0; 
# 601
virtual TermCriteria getTermCriteria() const = 0; 
# 603
virtual void setTermCriteria(const TermCriteria & val) = 0; 
# 607
virtual int getKernelType() const = 0; 
# 611
virtual void setKernel(int kernelType) = 0; 
# 615
virtual void setCustomKernel(const Ptr< Kernel>  & _kernel) = 0; 
# 618
enum Types { 
# 621
C_SVC = 100, 
# 625
NU_SVC, 
# 629
ONE_CLASS, 
# 633
EPS_SVR, 
# 636
NU_SVR
# 637
}; 
# 647 "/usr/include/opencv4/opencv2/ml.hpp" 3
enum KernelTypes { 
# 649
CUSTOM = (-1), 
# 652
LINEAR = 0, 
# 655
POLY, 
# 658
RBF, 
# 660
SIGMOID, 
# 663
CHI2, 
# 665
INTER
# 666
}; 
# 669
enum ParamTypes { 
# 670
C, 
# 671
GAMMA, 
# 672
P, 
# 673
NU, 
# 674
COEF, 
# 675
DEGREE
# 676
}; 
# 712 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual bool trainAuto(const Ptr< TrainData>  & data, int kFold = 10, ParamGrid Cgrid = getDefaultGrid(C), ParamGrid gammaGrid = getDefaultGrid(GAMMA), ParamGrid pGrid = getDefaultGrid(P), ParamGrid nuGrid = getDefaultGrid(NU), ParamGrid coeffGrid = getDefaultGrid(COEF), ParamGrid degreeGrid = getDefaultGrid(DEGREE), bool balanced = false) = 0; 
# 749 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual bool trainAuto(InputArray samples, int layout, InputArray responses, int kFold = 10, Ptr< ParamGrid>  Cgrid = SVM::getDefaultGridPtr(SVM::C), Ptr< ParamGrid>  gammaGrid = SVM::getDefaultGridPtr(SVM::GAMMA), Ptr< ParamGrid>  pGrid = SVM::getDefaultGridPtr(SVM::P), Ptr< ParamGrid>  nuGrid = SVM::getDefaultGridPtr(SVM::NU), Ptr< ParamGrid>  coeffGrid = SVM::getDefaultGridPtr(SVM::COEF), Ptr< ParamGrid>  degreeGrid = SVM::getDefaultGridPtr(SVM::DEGREE), bool balanced = false) = 0; 
# 766
virtual Mat getSupportVectors() const = 0; 
# 774
virtual Mat getUncompressedSupportVectors() const = 0; 
# 791 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual double getDecisionFunction(int i, OutputArray alpha, OutputArray svidx) const = 0; 
# 801 "/usr/include/opencv4/opencv2/ml.hpp" 3
static ParamGrid getDefaultGrid(int param_id); 
# 811 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< ParamGrid>  getDefaultGridPtr(int param_id); 
# 816
static Ptr< SVM>  create(); 
# 825 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< SVM>  load(const String & filepath); 
# 826
}; 
# 836 "/usr/include/opencv4/opencv2/ml.hpp" 3
class EM : public StatModel { 
# 840
public: enum Types { 
# 847
COV_MAT_SPHERICAL, 
# 851
COV_MAT_DIAGONAL, 
# 856
COV_MAT_GENERIC, 
# 857
COV_MAT_DEFAULT = COV_MAT_DIAGONAL
# 858
}; 
# 861
enum { DEFAULT_NCLUSTERS = 5, DEFAULT_MAX_ITERS = 100}; 
# 864
enum { START_E_STEP = 1, START_M_STEP, START_AUTO_STEP = 0}; 
# 871
virtual int getClustersNumber() const = 0; 
# 873
virtual void setClustersNumber(int val) = 0; 
# 878
virtual int getCovarianceMatrixType() const = 0; 
# 880
virtual void setCovarianceMatrixType(int val) = 0; 
# 887
virtual TermCriteria getTermCriteria() const = 0; 
# 889
virtual void setTermCriteria(const TermCriteria & val) = 0; 
# 895
virtual Mat getWeights() const = 0; 
# 901
virtual Mat getMeans() const = 0; 
# 907
virtual void getCovs(std::vector< Mat>  & covs) const = 0; 
# 916 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual float predict(InputArray samples, OutputArray results = noArray(), int flags = 0) const override = 0; 
# 930 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual Vec2d predict2(InputArray sample, OutputArray probs) const = 0; 
# 960 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual bool trainEM(InputArray samples, OutputArray logLikelihoods = noArray(), OutputArray labels = noArray(), OutputArray probs = noArray()) = 0; 
# 992 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual bool trainE(InputArray samples, InputArray means0, InputArray covs0 = noArray(), InputArray weights0 = noArray(), OutputArray logLikelihoods = noArray(), OutputArray labels = noArray(), OutputArray probs = noArray()) = 0; 
# 1017 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual bool trainM(InputArray samples, InputArray probs0, OutputArray logLikelihoods = noArray(), OutputArray labels = noArray(), OutputArray probs = noArray()) = 0; 
# 1026
static Ptr< EM>  create(); 
# 1037 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< EM>  load(const String & filepath, const String & nodeName = String()); 
# 1038
}; 
# 1053 "/usr/include/opencv4/opencv2/ml.hpp" 3
class DTrees : public StatModel { 
# 1057
public: enum Flags { PREDICT_AUTO, PREDICT_SUM = (1 << 8), PREDICT_MAX_VOTE = (2 << 8), PREDICT_MASK = (3 << 8)}; 
# 1071 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual int getMaxCategories() const = 0; 
# 1073
virtual void setMaxCategories(int val) = 0; 
# 1081
virtual int getMaxDepth() const = 0; 
# 1083
virtual void setMaxDepth(int val) = 0; 
# 1089
virtual int getMinSampleCount() const = 0; 
# 1091
virtual void setMinSampleCount(int val) = 0; 
# 1097
virtual int getCVFolds() const = 0; 
# 1099
virtual void setCVFolds(int val) = 0; 
# 1106
virtual bool getUseSurrogates() const = 0; 
# 1108
virtual void setUseSurrogates(bool val) = 0; 
# 1114
virtual bool getUse1SERule() const = 0; 
# 1116
virtual void setUse1SERule(bool val) = 0; 
# 1122
virtual bool getTruncatePrunedTree() const = 0; 
# 1124
virtual void setTruncatePrunedTree(bool val) = 0; 
# 1131
virtual float getRegressionAccuracy() const = 0; 
# 1133
virtual void setRegressionAccuracy(float val) = 0; 
# 1151 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual Mat getPriors() const = 0; 
# 1153
virtual void setPriors(const Mat & val) = 0; 
# 1157
class Node { 
# 1160
public: Node(); 
# 1161
double value; 
# 1163
int classIdx; 
# 1165
int parent; 
# 1166
int left; 
# 1167
int right; 
# 1168
int defaultDir; 
# 1170
int split; 
# 1171
}; 
# 1175
class Split { 
# 1178
public: Split(); 
# 1179
int varIdx; 
# 1180
bool inversed; 
# 1182
float quality; 
# 1183
int next; 
# 1184
float c; 
# 1191
int subsetOfs; 
# 1198
}; 
# 1202
virtual const std::vector< int>  &getRoots() const = 0; 
# 1207
virtual const std::vector< Node>  &getNodes() const = 0; 
# 1212
virtual const std::vector< Split>  &getSplits() const = 0; 
# 1217
virtual const std::vector< int>  &getSubsets() const = 0; 
# 1225
static Ptr< DTrees>  create(); 
# 1236 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< DTrees>  load(const String & filepath, const String & nodeName = String()); 
# 1237
}; 
# 1247 "/usr/include/opencv4/opencv2/ml.hpp" 3
class RTrees : public DTrees { 
# 1254
public: virtual bool getCalculateVarImportance() const = 0; 
# 1256
virtual void setCalculateVarImportance(bool val) = 0; 
# 1263
virtual int getActiveVarCount() const = 0; 
# 1265
virtual void setActiveVarCount(int val) = 0; 
# 1275 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual TermCriteria getTermCriteria() const = 0; 
# 1277
virtual void setTermCriteria(const TermCriteria & val) = 0; 
# 1284
virtual Mat getVarImportance() const = 0; 
# 1295 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual void getVotes(InputArray samples, OutputArray results, int flags) const = 0; 
# 1301
static Ptr< RTrees>  create(); 
# 1312 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< RTrees>  load(const String & filepath, const String & nodeName = String()); 
# 1313
}; 
# 1323 "/usr/include/opencv4/opencv2/ml.hpp" 3
class Boost : public DTrees { 
# 1329
public: virtual int getBoostType() const = 0; 
# 1331
virtual void setBoostType(int val) = 0; 
# 1336
virtual int getWeakCount() const = 0; 
# 1338
virtual void setWeakCount(int val) = 0; 
# 1344
virtual double getWeightTrimRate() const = 0; 
# 1346
virtual void setWeightTrimRate(double val) = 0; 
# 1350
enum Types { 
# 1351
DISCRETE, 
# 1352
REAL, 
# 1354
LOGIT, 
# 1355
GENTLE
# 1357
}; 
# 1361
static Ptr< Boost>  create(); 
# 1372 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< Boost>  load(const String & filepath, const String & nodeName = String()); 
# 1373
}; 
# 1422 "/usr/include/opencv4/opencv2/ml.hpp" 3
class ANN_MLP : public StatModel { 
# 1426
public: enum TrainingMethods { 
# 1427
BACKPROP, 
# 1428
RPROP, 
# 1429
ANNEAL
# 1430
}; 
# 1437
virtual void setTrainMethod(int method, double param1 = 0, double param2 = 0) = 0; 
# 1440
virtual int getTrainMethod() const = 0; 
# 1448
virtual void setActivationFunction(int type, double param1 = 0, double param2 = 0) = 0; 
# 1454
virtual void setLayerSizes(InputArray _layer_sizes) = 0; 
# 1460
virtual Mat getLayerSizes() const = 0; 
# 1467
virtual TermCriteria getTermCriteria() const = 0; 
# 1469
virtual void setTermCriteria(TermCriteria val) = 0; 
# 1474
virtual double getBackpropWeightScale() const = 0; 
# 1476
virtual void setBackpropWeightScale(double val) = 0; 
# 1483
virtual double getBackpropMomentumScale() const = 0; 
# 1485
virtual void setBackpropMomentumScale(double val) = 0; 
# 1490
virtual double getRpropDW0() const = 0; 
# 1492
virtual void setRpropDW0(double val) = 0; 
# 1497
virtual double getRpropDWPlus() const = 0; 
# 1499
virtual void setRpropDWPlus(double val) = 0; 
# 1504
virtual double getRpropDWMinus() const = 0; 
# 1506
virtual void setRpropDWMinus(double val) = 0; 
# 1511
virtual double getRpropDWMin() const = 0; 
# 1513
virtual void setRpropDWMin(double val) = 0; 
# 1518
virtual double getRpropDWMax() const = 0; 
# 1520
virtual void setRpropDWMax(double val) = 0; 
# 1525
virtual double getAnnealInitialT() const = 0; 
# 1527
virtual void setAnnealInitialT(double val) = 0; 
# 1532
virtual double getAnnealFinalT() const = 0; 
# 1534
virtual void setAnnealFinalT(double val) = 0; 
# 1539
virtual double getAnnealCoolingRatio() const = 0; 
# 1541
virtual void setAnnealCoolingRatio(double val) = 0; 
# 1546
virtual int getAnnealItePerStep() const = 0; 
# 1548
virtual void setAnnealItePerStep(int val) = 0; 
# 1551
virtual void setAnnealEnergyRNG(const RNG & rng) = 0; 
# 1554
enum ActivationFunctions { 
# 1556
IDENTITY, 
# 1562
SIGMOID_SYM, 
# 1564
GAUSSIAN, 
# 1566
RELU, 
# 1568
LEAKYRELU
# 1569
}; 
# 1572
enum TrainFlags { 
# 1575
UPDATE_WEIGHTS = 1, 
# 1581
NO_INPUT_SCALE, 
# 1585
NO_OUTPUT_SCALE = 4
# 1586
}; 
# 1588
virtual Mat getWeights(int layerIdx) const = 0; 
# 1595
static Ptr< ANN_MLP>  create(); 
# 1604 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< ANN_MLP>  load(const String & filepath); 
# 1606
}; 
# 1609
typedef ANN_MLP ANN_MLP_ANNEAL; 
# 1620 "/usr/include/opencv4/opencv2/ml.hpp" 3
class LogisticRegression : public StatModel { 
# 1626
public: virtual double getLearningRate() const = 0; 
# 1628
virtual void setLearningRate(double val) = 0; 
# 1632
virtual int getIterations() const = 0; 
# 1634
virtual void setIterations(int val) = 0; 
# 1638
virtual int getRegularization() const = 0; 
# 1640
virtual void setRegularization(int val) = 0; 
# 1644
virtual int getTrainMethod() const = 0; 
# 1646
virtual void setTrainMethod(int val) = 0; 
# 1652
virtual int getMiniBatchSize() const = 0; 
# 1654
virtual void setMiniBatchSize(int val) = 0; 
# 1658
virtual TermCriteria getTermCriteria() const = 0; 
# 1660
virtual void setTermCriteria(TermCriteria val) = 0; 
# 1663
enum RegKinds { 
# 1664
REG_DISABLE = (-1), 
# 1665
REG_L1 = 0, 
# 1666
REG_L2
# 1667
}; 
# 1670
enum Methods { 
# 1671
BATCH, 
# 1672
MINI_BATCH
# 1673
}; 
# 1682 "/usr/include/opencv4/opencv2/ml.hpp" 3
virtual float predict(InputArray samples, OutputArray results = noArray(), int flags = 0) const override = 0; 
# 1689
virtual Mat get_learnt_thetas() const = 0; 
# 1695
static Ptr< LogisticRegression>  create(); 
# 1706 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< LogisticRegression>  load(const String & filepath, const String & nodeName = String()); 
# 1707
}; 
# 1787 "/usr/include/opencv4/opencv2/ml.hpp" 3
class SVMSGD : public StatModel { 
# 1793
public: enum SvmsgdType { 
# 1795
SGD, 
# 1796
ASGD
# 1797
}; 
# 1800
enum MarginType { 
# 1802
SOFT_MARGIN, 
# 1803
HARD_MARGIN
# 1804
}; 
# 1809
virtual Mat getWeights() = 0; 
# 1814
virtual float getShift() = 0; 
# 1820
static Ptr< SVMSGD>  create(); 
# 1831 "/usr/include/opencv4/opencv2/ml.hpp" 3
static Ptr< SVMSGD>  load(const String & filepath, const String & nodeName = String()); 
# 1837
virtual void setOptimalParameters(int svmsgdType = SVMSGD::ASGD, int marginType = SVMSGD::SOFT_MARGIN) = 0; 
# 1841
virtual int getSvmsgdType() const = 0; 
# 1843
virtual void setSvmsgdType(int svmsgdType) = 0; 
# 1847
virtual int getMarginType() const = 0; 
# 1849
virtual void setMarginType(int marginType) = 0; 
# 1853
virtual float getMarginRegularization() const = 0; 
# 1855
virtual void setMarginRegularization(float marginRegularization) = 0; 
# 1859
virtual float getInitialStepSize() const = 0; 
# 1861
virtual void setInitialStepSize(float InitialStepSize) = 0; 
# 1865
virtual float getStepDecreasingPower() const = 0; 
# 1867
virtual void setStepDecreasingPower(float stepDecreasingPower) = 0; 
# 1873
virtual TermCriteria getTermCriteria() const = 0; 
# 1875
virtual void setTermCriteria(const TermCriteria & val) = 0; 
# 1876
}; 
# 1890 "/usr/include/opencv4/opencv2/ml.hpp" 3
void randMVNormal(InputArray mean, InputArray cov, int nsamples, OutputArray samples); 
# 1893
void createConcentricSpheresTestSet(int nsamples, int nfeatures, int nclasses, OutputArray samples, OutputArray responses); 
# 1929 "/usr/include/opencv4/opencv2/ml.hpp" 3
template< class SimulatedAnnealingSolverSystem> int simulatedAnnealingSolver(SimulatedAnnealingSolverSystem & solverSystem, double initialTemperature, double finalTemperature, double coolingRatio, size_t iterationsPerStep, double * lastTemperature = 0, RNG & rngEnergy = cv::theRNG()); 
# 1939
}
# 1940
}
# 8 "/usr/include/opencv4/opencv2/ml/ml.inl.hpp" 3
namespace cv { namespace ml { 
# 11
template< class SimulatedAnnealingSolverSystem> int 
# 12
simulatedAnnealingSolver(SimulatedAnnealingSolverSystem &solverSystem, double 
# 13
initialTemperature, double finalTemperature, double coolingRatio, size_t 
# 14
iterationsPerStep, double *
# 15
lastTemperature, RNG &
# 16
rngEnergy) 
# 18
{ 
# 19
do { if (!(!(finalTemperature > (0)))) { ; } else { cv::error(cv::Error::StsAssert, "finalTemperature > 0", __func__, "/usr/include/opencv4/opencv2/ml/ml.inl.hpp", 19); }  } while (0); 
# 20
do { if (!(!(initialTemperature > finalTemperature))) { ; } else { cv::error(cv::Error::StsAssert, "initialTemperature > finalTemperature", __func__, "/usr/include/opencv4/opencv2/ml/ml.inl.hpp", 20); }  } while (0); 
# 21
do { if (!(!(iterationsPerStep > (0)))) { ; } else { cv::error(cv::Error::StsAssert, "iterationsPerStep > 0", __func__, "/usr/include/opencv4/opencv2/ml/ml.inl.hpp", 21); }  } while (0); 
# 22
do { if (!(!(coolingRatio < ((1.0F))))) { ; } else { cv::error(cv::Error::StsAssert, "coolingRatio < 1.0f", __func__, "/usr/include/opencv4/opencv2/ml/ml.inl.hpp", 22); }  } while (0); 
# 23
double Ti = initialTemperature; 
# 24
double previousEnergy = solverSystem.energy(); 
# 25
int exchange = 0; 
# 26
while (Ti > finalTemperature) 
# 27
{ 
# 28
for (size_t i = (0); i < iterationsPerStep; i++) 
# 29
{ 
# 30
solverSystem.changeState(); 
# 31
double newEnergy = solverSystem.energy(); 
# 32
if (newEnergy < previousEnergy) 
# 33
{ 
# 34
previousEnergy = newEnergy; 
# 35
exchange++; 
# 36
} else 
# 38
{ 
# 39
double r = rngEnergy.uniform((0.0), (1.0)); 
# 40
if (r < std::exp((-(newEnergy - previousEnergy)) / Ti)) 
# 41
{ 
# 42
previousEnergy = newEnergy; 
# 43
exchange++; 
# 44
} else 
# 46
{ 
# 47
solverSystem.reverseState(); 
# 48
}  
# 49
}  
# 50
}  
# 51
Ti *= coolingRatio; 
# 52
}  
# 53
if (lastTemperature) { 
# 54
(*lastTemperature) = Ti; }  
# 55
return exchange; 
# 56
} 
# 58
}}
# 109 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
typedef struct CvHaarClassifierCascade CvHaarClassifierCascade; 
# 111
namespace cv { 
# 121 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
class SimilarRects { 
# 124
public: SimilarRects(double _eps) : eps(_eps) { } 
# 125
bool operator()(const Rect &r1, const Rect &r2) const 
# 126
{ 
# 127
double delta = ((eps) * ((std::min)(r1.width, r2.width) + (std::min)(r1.height, r2.height))) * (0.5); 
# 128
return ((std::abs((r1.x) - (r2.x))) <= delta) && ((std::abs((r1.y) - (r2.y))) <= delta) && ((std::abs((((r1.x) + (r1.width)) - (r2.x)) - (r2.width))) <= delta) && ((std::abs((((r1.y) + (r1.height)) - (r2.y)) - (r2.height))) <= delta); 
# 132
} 
# 133
double eps; 
# 134
}; 
# 151 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
void groupRectangles(std::vector< Rect_< int> >  & rectList, int groupThreshold, double eps = (0.2)); 
# 153
void groupRectangles(std::vector< Rect_< int> >  & rectList, std::vector< int>  & weights, int groupThreshold, double eps = (0.2)); 
# 156
void groupRectangles(std::vector< Rect_< int> >  & rectList, int groupThreshold, double eps, std::vector< int>  * weights, std::vector< double>  * levelWeights); 
# 159
void groupRectangles(std::vector< Rect_< int> >  & rectList, std::vector< int>  & rejectLevels, std::vector< double>  & levelWeights, int groupThreshold, double eps = (0.2)); 
# 162
void groupRectangles_meanshift(std::vector< Rect_< int> >  & rectList, std::vector< double>  & foundWeights, std::vector< double>  & foundScales, double detectThreshold = (0.0), Size winDetSize = Size(64, 128)); 
# 166
template<> struct DefaultDeleter< CvHaarClassifierCascade>  { void operator()(CvHaarClassifierCascade * obj) const; }; 
# 168
enum { CASCADE_DO_CANNY_PRUNING = 1, 
# 169
CASCADE_SCALE_IMAGE, 
# 170
CASCADE_FIND_BIGGEST_OBJECT = 4, 
# 171
CASCADE_DO_ROUGH_SEARCH = 8
# 172
}; 
# 174
class BaseCascadeClassifier : public Algorithm { 
# 177
public: virtual ~BaseCascadeClassifier(); 
# 178
virtual bool empty() const override = 0; 
# 179
virtual bool load(const String & filename) = 0; 
# 180
virtual void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize) = 0; 
# 186
virtual void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, std::vector< int>  & numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize) = 0; 
# 193
virtual void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, std::vector< int>  & rejectLevels, std::vector< double>  & levelWeights, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize, bool outputRejectLevels) = 0; 
# 202
virtual bool isOldFormatCascade() const = 0; 
# 203
virtual Size getOriginalWindowSize() const = 0; 
# 204
virtual int getFeatureType() const = 0; 
# 205
virtual void *getOldCascade() = 0; 
# 207
class MaskGenerator { 
# 210
public: virtual ~MaskGenerator() { } 
# 211
virtual Mat generateMask(const Mat & src) = 0; 
# 212
virtual void initializeMask(const Mat &) { } 
# 213
}; 
# 214
virtual void setMaskGenerator(const Ptr< MaskGenerator>  & maskGenerator) = 0; 
# 215
virtual Ptr< MaskGenerator>  getMaskGenerator() = 0; 
# 216
}; 
# 224
class CascadeClassifier { 
# 227
public: CascadeClassifier(); 
# 232
CascadeClassifier(const String & filename); 
# 233
~CascadeClassifier(); 
# 236
bool empty() const; 
# 243
bool load(const String & filename); 
# 248
bool read(const FileNode & node); 
# 270 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, double scaleFactor = (1.1), int minNeighbors = 3, int flags = 0, Size minSize = Size(), Size maxSize = Size()); 
# 292 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, std::vector< int>  & numDetections, double scaleFactor = (1.1), int minNeighbors = 3, int flags = 0, Size minSize = Size(), Size maxSize = Size()); 
# 317 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
void detectMultiScale(InputArray image, std::vector< Rect_< int> >  & objects, std::vector< int>  & rejectLevels, std::vector< double>  & levelWeights, double scaleFactor = (1.1), int minNeighbors = 3, int flags = 0, Size minSize = Size(), Size maxSize = Size(), bool outputRejectLevels = false); 
# 327
bool isOldFormatCascade() const; 
# 328
Size getOriginalWindowSize() const; 
# 329
int getFeatureType() const; 
# 330
void *getOldCascade(); 
# 332
static bool convert(const String & oldcascade, const String & newcascade); 
# 334
void setMaskGenerator(const Ptr< BaseCascadeClassifier::MaskGenerator>  & maskGenerator); 
# 335
Ptr< BaseCascadeClassifier::MaskGenerator>  getMaskGenerator(); 
# 337
Ptr< BaseCascadeClassifier>  cc; 
# 338
}; 
# 340
Ptr< BaseCascadeClassifier::MaskGenerator>  createFaceDetectionMaskGenerator(); 
# 345
struct DetectionROI { 
# 348
double scale; 
# 350
std::vector< Point_< int> >  locations; 
# 352
std::vector< double>  confidences; 
# 353
}; 
# 372 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
struct HOGDescriptor { 
# 375
enum HistogramNormType { L2Hys
# 376
}; 
# 377
enum { DEFAULT_NLEVELS = 64
# 378
}; 
# 379
enum DescriptorStorageFormat { DESCR_FORMAT_COL_BY_COL, DESCR_FORMAT_ROW_BY_ROW}; 
# 385
HOGDescriptor() : winSize(64, 128), blockSize(16, 16), blockStride(8, 8), cellSize(8, 8), nbins(9), derivAperture(1), winSigma((-1)), histogramNormType(HOGDescriptor::L2Hys), L2HysThreshold((0.2)), gammaCorrection(true), free_coef((-(1.0F))), nlevels((HOGDescriptor::DEFAULT_NLEVELS)), signedGradient(false) 
# 389
{ } 
# 405 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
HOGDescriptor(Size _winSize, Size _blockSize, Size _blockStride, Size 
# 406
_cellSize, int _nbins, int _derivAperture = 1, double _winSigma = -1, HistogramNormType 
# 407
_histogramNormType = HOGDescriptor::L2Hys, double 
# 408
_L2HysThreshold = (0.2), bool _gammaCorrection = false, int 
# 409
_nlevels = HOGDescriptor::DEFAULT_NLEVELS, bool _signedGradient = false) : winSize(_winSize), blockSize(_blockSize), blockStride(_blockStride), cellSize(_cellSize), nbins(_nbins), derivAperture(_derivAperture), winSigma(_winSigma), histogramNormType(_histogramNormType), L2HysThreshold(_L2HysThreshold), gammaCorrection(_gammaCorrection), free_coef((-(1.0F))), nlevels(_nlevels), signedGradient(_signedGradient) 
# 414
{ } 
# 419
HOGDescriptor(const String &filename) 
# 420
{ 
# 421
this->load(filename); 
# 422
} 
# 427
HOGDescriptor(const HOGDescriptor &d) 
# 428
{ 
# 429
d.copyTo(*this); 
# 430
} 
# 434
virtual ~HOGDescriptor() { } 
# 438
size_t getDescriptorSize() const; 
# 442
bool checkDetectorSize() const; 
# 446
double getWinSigma() const; 
# 453
virtual void setSVMDetector(InputArray svmdetector); 
# 458
virtual bool read(FileNode & fn); 
# 464
virtual void write(FileStorage & fs, const String & objname) const; 
# 470
virtual bool load(const String & filename, const String & objname = String()); 
# 476
virtual void save(const String & filename, const String & objname = String()) const; 
# 481
virtual void copyTo(HOGDescriptor & c) const; 
# 492 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
virtual void compute(InputArray img, std::vector< float>  & descriptors, Size winStride = Size(), Size padding = Size(), const std::vector< Point_< int> >  & locations = std::vector< Point_< int> > ()) const; 
# 508 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
virtual void detect(InputArray img, std::vector< Point_< int> >  & foundLocations, std::vector< double>  & weights, double hitThreshold = 0, Size winStride = Size(), Size padding = Size(), const std::vector< Point_< int> >  & searchLocations = std::vector< Point_< int> > ()) const; 
# 524 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
virtual void detect(InputArray img, std::vector< Point_< int> >  & foundLocations, double hitThreshold = 0, Size winStride = Size(), Size padding = Size(), const std::vector< Point_< int> >  & searchLocations = std::vector< Point_< int> > ()) const; 
# 543 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
virtual void detectMultiScale(InputArray img, std::vector< Rect_< int> >  & foundLocations, std::vector< double>  & foundWeights, double hitThreshold = 0, Size winStride = Size(), Size padding = Size(), double scale = (1.05), double finalThreshold = (2.0), bool useMeanshiftGrouping = false) const; 
# 561 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
virtual void detectMultiScale(InputArray img, std::vector< Rect_< int> >  & foundLocations, double hitThreshold = 0, Size winStride = Size(), Size padding = Size(), double scale = (1.05), double finalThreshold = (2.0), bool useMeanshiftGrouping = false) const; 
# 573 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
virtual void computeGradient(InputArray img, InputOutputArray grad, InputOutputArray angleOfs, Size paddingTL = Size(), Size paddingBR = Size()) const; 
# 578
static std::vector< float>  getDefaultPeopleDetector(); 
# 584
static std::vector< float>  getDaimlerPeopleDetector(); 
# 587
Size winSize; 
# 590
Size blockSize; 
# 593
Size blockStride; 
# 596
Size cellSize; 
# 599
int nbins; 
# 602
int derivAperture; 
# 605
double winSigma; 
# 608
HistogramNormType histogramNormType; 
# 611
double L2HysThreshold; 
# 614
bool gammaCorrection; 
# 617
std::vector< float>  svmDetector; 
# 620
UMat oclSvmDetector; 
# 623
float free_coef; 
# 626
int nlevels; 
# 629
bool signedGradient; 
# 642 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
virtual void detectROI(InputArray img, const std::vector< Point_< int> >  & locations, std::vector< Point_< int> >  & foundLocations, std::vector< double>  & confidences, double hitThreshold = 0, Size winStride = Size(), Size padding = Size()) const; 
# 655 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
virtual void detectMultiScaleROI(InputArray img, std::vector< Rect_< int> >  & foundLocations, std::vector< DetectionROI>  & locations, double hitThreshold = 0, int groupThreshold = 0) const; 
# 667
void groupRectangles(std::vector< Rect_< int> >  & rectList, std::vector< double>  & weights, int groupThreshold, double eps) const; 
# 668
}; 
# 670
class QRCodeDetector { 
# 673
public: QRCodeDetector(); 
# 674
~QRCodeDetector(); 
# 680
void setEpsX(double epsX); 
# 685
void setEpsY(double epsY); 
# 691
bool detect(InputArray img, OutputArray points) const; 
# 700 "/usr/include/opencv4/opencv2/objdetect.hpp" 3
std::string decode(InputArray img, InputArray points, OutputArray straight_qrcode = noArray()); 
# 708
std::string detectAndDecode(InputArray img, OutputArray points = noArray(), OutputArray straight_qrcode = noArray()); 
# 711
protected: struct Impl; 
# 712
Ptr< Impl>  p; 
# 713
}; 
# 716
}
# 51 "/usr/include/opencv4/opencv2/objdetect/detection_based_tracker.hpp" 3
namespace cv { 
# 57
class DetectionBasedTracker { 
# 60
public: struct Parameters { 
# 62
int maxTrackLifetime; 
# 63
int minDetectionPeriod; 
# 65
Parameters(); 
# 66
}; 
# 68
class IDetector { 
# 71
public: IDetector() : minObjSize(96, 96), maxObjSize(2147483647, 2147483647), minNeighbours(2), scaleFactor((1.1F)) 
# 76
{ } 
# 78
virtual void detect(const Mat & image, std::vector< Rect_< int> >  & objects) = 0; 
# 80
void setMinObjectSize(const Size &min) 
# 81
{ 
# 82
((minObjSize) = min); 
# 83
} 
# 84
void setMaxObjectSize(const Size &max) 
# 85
{ 
# 86
((maxObjSize) = max); 
# 87
} 
# 88
Size getMinObjectSize() const 
# 89
{ 
# 90
return minObjSize; 
# 91
} 
# 92
Size getMaxObjectSize() const 
# 93
{ 
# 94
return maxObjSize; 
# 95
} 
# 96
float getScaleFactor() 
# 97
{ 
# 98
return scaleFactor; 
# 99
} 
# 100
void setScaleFactor(float value) 
# 101
{ 
# 102
(scaleFactor) = value; 
# 103
} 
# 104
int getMinNeighbours() 
# 105
{ 
# 106
return minNeighbours; 
# 107
} 
# 108
void setMinNeighbours(int value) 
# 109
{ 
# 110
(minNeighbours) = value; 
# 111
} 
# 112
virtual ~IDetector() { } 
# 115
protected: Size minObjSize; 
# 116
Size maxObjSize; 
# 117
int minNeighbours; 
# 118
float scaleFactor; 
# 119
}; 
# 121
DetectionBasedTracker(Ptr< IDetector>  mainDetector, Ptr< IDetector>  trackingDetector, const Parameters & params); 
# 122
virtual ~DetectionBasedTracker(); 
# 124
virtual bool run(); 
# 125
virtual void stop(); 
# 126
virtual void resetTracking(); 
# 128
virtual void process(const Mat & imageGray); 
# 130
bool setParameters(const Parameters & params); 
# 131
const Parameters &getParameters() const; 
# 134
typedef std::pair< Rect_< int> , int>  Object; 
# 135
virtual void getObjects(std::vector< Rect_< int> >  & result) const; 
# 136
virtual void getObjects(std::vector< std::pair< Rect_< int> , int> >  & result) const; 
# 138
enum ObjectStatus { 
# 140
DETECTED_NOT_SHOWN_YET, 
# 141
DETECTED, 
# 142
DETECTED_TEMPORARY_LOST, 
# 143
WRONG_OBJECT
# 144
}; 
# 145
struct ExtObject { 
# 147
int id; 
# 148
Rect location; 
# 149
ObjectStatus status; 
# 150
ExtObject(int _id, Rect _location, ObjectStatus _status) : id(_id), location(_location), status(_status) 
# 152
{ 
# 153
} 
# 154
}; 
# 155
virtual void getObjects(std::vector< ExtObject>  & result) const; 
# 158
virtual int addObject(const Rect & location); 
# 161
protected: class SeparateDetectionWork; 
# 162
Ptr< SeparateDetectionWork>  separateDetectionWork; 
# 163
friend void *workcycleObjectDetectorFunction(void * p); 
# 165
struct InnerParameters { 
# 167
int numLastPositionsToTrack; 
# 168
int numStepsToWaitBeforeFirstShow; 
# 169
int numStepsToTrackWithoutDetectingIfObjectHasNotBeenShown; 
# 170
int numStepsToShowWithoutDetecting; 
# 172
float coeffTrackingWindowSize; 
# 173
float coeffObjectSizeToTrack; 
# 174
float coeffObjectSpeedUsingInPrediction; 
# 176
InnerParameters(); 
# 177
}; 
# 178
Parameters parameters; 
# 179
InnerParameters innerParameters; 
# 181
struct TrackedObject { 
# 183
typedef std::vector< Rect_< int> >  PositionsVector; 
# 185
PositionsVector lastPositions; 
# 187
int numDetectedFrames; 
# 188
int numFramesNotDetected; 
# 189
int id; 
# 191
TrackedObject(const Rect &rect) : numDetectedFrames(1), numFramesNotDetected(0) 
# 192
{ 
# 193
(lastPositions).push_back(rect); 
# 194
(id) = getNextId(); 
# 195
} 
# 197
static int getNextId() 
# 198
{ 
# 199
static int _id = 0; 
# 200
return _id++; 
# 201
} 
# 202
}; 
# 204
int numTrackedSteps; 
# 205
std::vector< TrackedObject>  trackedObjects; 
# 207
std::vector< float>  weightsPositionsSmoothing; 
# 208
std::vector< float>  weightsSizesSmoothing; 
# 210
Ptr< IDetector>  cascadeForTracking; 
# 212
void updateTrackedObjects(const std::vector< Rect_< int> >  & detectedObjects); 
# 213
Rect calcTrackedObjectPositionToShow(int i) const; 
# 214
Rect calcTrackedObjectPositionToShow(int i, ObjectStatus & status) const; 
# 215
void detectInRegion(const Mat & img, const Rect & r, std::vector< Rect_< int> >  & detectedObjectsInRegions); 
# 216
}; 
# 220
}
# 85 "/usr/include/opencv4/opencv2/photo.hpp" 3
namespace cv { 
# 95
enum { 
# 96
INPAINT_NS, 
# 97
INPAINT_TELEA
# 98
}; 
# 120 "/usr/include/opencv4/opencv2/photo.hpp" 3
void inpaint(InputArray src, InputArray inpaintMask, OutputArray dst, double inpaintRadius, int flags); 
# 148 "/usr/include/opencv4/opencv2/photo.hpp" 3
void fastNlMeansDenoising(InputArray src, OutputArray dst, float h = 3, int templateWindowSize = 7, int searchWindowSize = 21); 
# 175 "/usr/include/opencv4/opencv2/photo.hpp" 3
void fastNlMeansDenoising(InputArray src, OutputArray dst, const std::vector< float>  & h, int templateWindowSize = 7, int searchWindowSize = 21, int normType = NORM_L2); 
# 198 "/usr/include/opencv4/opencv2/photo.hpp" 3
void fastNlMeansDenoisingColored(InputArray src, OutputArray dst, float h = 3, float hColor = 3, int templateWindowSize = 7, int searchWindowSize = 21); 
# 225 "/usr/include/opencv4/opencv2/photo.hpp" 3
void fastNlMeansDenoisingMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, float h = 3, int templateWindowSize = 7, int searchWindowSize = 21); 
# 254 "/usr/include/opencv4/opencv2/photo.hpp" 3
void fastNlMeansDenoisingMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, const std::vector< float>  & h, int templateWindowSize = 7, int searchWindowSize = 21, int normType = NORM_L2); 
# 283 "/usr/include/opencv4/opencv2/photo.hpp" 3
void fastNlMeansDenoisingColoredMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, float h = 3, float hColor = 3, int templateWindowSize = 7, int searchWindowSize = 21); 
# 325 "/usr/include/opencv4/opencv2/photo.hpp" 3
void denoise_TVL1(const std::vector< Mat>  & observations, Mat & result, double lambda = (1.0), int niters = 30); 
# 332
enum { LDR_SIZE = 256}; 
# 336
class Tonemap : public Algorithm { 
# 344
public: virtual void process(InputArray src, OutputArray dst) = 0; 
# 346
virtual float getGamma() const = 0; 
# 347
virtual void setGamma(float gamma) = 0; 
# 348
}; 
# 356
Ptr< Tonemap>  createTonemap(float gamma = (1.0F)); 
# 368 "/usr/include/opencv4/opencv2/photo.hpp" 3
class TonemapDrago : public Tonemap { 
# 372
public: virtual float getSaturation() const = 0; 
# 373
virtual void setSaturation(float saturation) = 0; 
# 375
virtual float getBias() const = 0; 
# 376
virtual void setBias(float bias) = 0; 
# 377
}; 
# 387 "/usr/include/opencv4/opencv2/photo.hpp" 3
Ptr< TonemapDrago>  createTonemapDrago(float gamma = (1.0F), float saturation = (1.0F), float bias = (0.85F)); 
# 397 "/usr/include/opencv4/opencv2/photo.hpp" 3
class TonemapReinhard : public Tonemap { 
# 400
public: virtual float getIntensity() const = 0; 
# 401
virtual void setIntensity(float intensity) = 0; 
# 403
virtual float getLightAdaptation() const = 0; 
# 404
virtual void setLightAdaptation(float light_adapt) = 0; 
# 406
virtual float getColorAdaptation() const = 0; 
# 407
virtual void setColorAdaptation(float color_adapt) = 0; 
# 408
}; 
# 420 "/usr/include/opencv4/opencv2/photo.hpp" 3
Ptr< TonemapReinhard>  createTonemapReinhard(float gamma = (1.0F), float intensity = (0.0F), float light_adapt = (1.0F), float color_adapt = (0.0F)); 
# 428
class TonemapMantiuk : public Tonemap { 
# 431
public: virtual float getScale() const = 0; 
# 432
virtual void setScale(float scale) = 0; 
# 434
virtual float getSaturation() const = 0; 
# 435
virtual void setSaturation(float saturation) = 0; 
# 436
}; 
# 446 "/usr/include/opencv4/opencv2/photo.hpp" 3
Ptr< TonemapMantiuk>  createTonemapMantiuk(float gamma = (1.0F), float scale = (0.7F), float saturation = (1.0F)); 
# 450
class AlignExposures : public Algorithm { 
# 461 "/usr/include/opencv4/opencv2/photo.hpp" 3
public: virtual void process(InputArrayOfArrays src, std::vector< Mat>  & dst, InputArray times, InputArray response) = 0; 
# 463
}; 
# 474 "/usr/include/opencv4/opencv2/photo.hpp" 3
class AlignMTB : public AlignExposures { 
# 477
public: virtual void process(InputArrayOfArrays src, std::vector< Mat>  & dst, InputArray times, InputArray response) override = 0; 
# 485
virtual void process(InputArrayOfArrays src, std::vector< Mat>  & dst) = 0; 
# 493
virtual Point calculateShift(InputArray img0, InputArray img1) = 0; 
# 500
virtual void shiftMat(InputArray src, OutputArray dst, const Point shift) = 0; 
# 507
virtual void computeBitmaps(InputArray img, OutputArray tb, OutputArray eb) = 0; 
# 509
virtual int getMaxBits() const = 0; 
# 510
virtual void setMaxBits(int max_bits) = 0; 
# 512
virtual int getExcludeRange() const = 0; 
# 513
virtual void setExcludeRange(int exclude_range) = 0; 
# 515
virtual bool getCut() const = 0; 
# 516
virtual void setCut(bool value) = 0; 
# 517
}; 
# 527 "/usr/include/opencv4/opencv2/photo.hpp" 3
Ptr< AlignMTB>  createAlignMTB(int max_bits = 6, int exclude_range = 4, bool cut = true); 
# 531
class CalibrateCRF : public Algorithm { 
# 540
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times) = 0; 
# 541
}; 
# 549
class CalibrateDebevec : public CalibrateCRF { 
# 552
public: virtual float getLambda() const = 0; 
# 553
virtual void setLambda(float lambda) = 0; 
# 555
virtual int getSamples() const = 0; 
# 556
virtual void setSamples(int samples) = 0; 
# 558
virtual bool getRandom() const = 0; 
# 559
virtual void setRandom(bool random) = 0; 
# 560
}; 
# 570 "/usr/include/opencv4/opencv2/photo.hpp" 3
Ptr< CalibrateDebevec>  createCalibrateDebevec(int samples = 70, float lambda = (10.0F), bool random = false); 
# 577
class CalibrateRobertson : public CalibrateCRF { 
# 580
public: virtual int getMaxIter() const = 0; 
# 581
virtual void setMaxIter(int max_iter) = 0; 
# 583
virtual float getThreshold() const = 0; 
# 584
virtual void setThreshold(float threshold) = 0; 
# 586
virtual Mat getRadiance() const = 0; 
# 587
}; 
# 594
Ptr< CalibrateRobertson>  createCalibrateRobertson(int max_iter = 30, float threshold = (0.01F)); 
# 598
class MergeExposures : public Algorithm { 
# 609 "/usr/include/opencv4/opencv2/photo.hpp" 3
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response) = 0; 
# 611
}; 
# 618
class MergeDebevec : public MergeExposures { 
# 621
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response) override = 0; 
# 623
virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times) = 0; 
# 624
}; 
# 628
Ptr< MergeDebevec>  createMergeDebevec(); 
# 641 "/usr/include/opencv4/opencv2/photo.hpp" 3
class MergeMertens : public MergeExposures { 
# 644
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response) override = 0; 
# 651
virtual void process(InputArrayOfArrays src, OutputArray dst) = 0; 
# 653
virtual float getContrastWeight() const = 0; 
# 654
virtual void setContrastWeight(float contrast_weiht) = 0; 
# 656
virtual float getSaturationWeight() const = 0; 
# 657
virtual void setSaturationWeight(float saturation_weight) = 0; 
# 659
virtual float getExposureWeight() const = 0; 
# 660
virtual void setExposureWeight(float exposure_weight) = 0; 
# 661
}; 
# 670
Ptr< MergeMertens>  createMergeMertens(float contrast_weight = (1.0F), float saturation_weight = (1.0F), float exposure_weight = (0.0F)); 
# 677
class MergeRobertson : public MergeExposures { 
# 680
public: virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response) override = 0; 
# 682
virtual void process(InputArrayOfArrays src, OutputArray dst, InputArray times) = 0; 
# 683
}; 
# 687
Ptr< MergeRobertson>  createMergeRobertson(); 
# 704 "/usr/include/opencv4/opencv2/photo.hpp" 3
void decolor(InputArray src, OutputArray grayscale, OutputArray color_boost); 
# 714 "/usr/include/opencv4/opencv2/photo.hpp" 3
enum { 
# 716
NORMAL_CLONE = 1, 
# 719
MIXED_CLONE, 
# 721
MONOCHROME_TRANSFER}; 
# 740 "/usr/include/opencv4/opencv2/photo.hpp" 3
void seamlessClone(InputArray src, InputArray dst, InputArray mask, Point p, OutputArray blend, int flags); 
# 755 "/usr/include/opencv4/opencv2/photo.hpp" 3
void colorChange(InputArray src, InputArray mask, OutputArray dst, float red_mul = (1.0F), float green_mul = (1.0F), float blue_mul = (1.0F)); 
# 769 "/usr/include/opencv4/opencv2/photo.hpp" 3
void illuminationChange(InputArray src, InputArray mask, OutputArray dst, float alpha = (0.2F), float beta = (0.4F)); 
# 787 "/usr/include/opencv4/opencv2/photo.hpp" 3
void textureFlattening(InputArray src, InputArray mask, OutputArray dst, float low_threshold = 30, float high_threshold = 45, int kernel_size = 3); 
# 798
enum { 
# 799
RECURS_FILTER = 1, 
# 800
NORMCONV_FILTER
# 801
}; 
# 812 "/usr/include/opencv4/opencv2/photo.hpp" 3
void edgePreservingFilter(InputArray src, OutputArray dst, int flags = 1, float sigma_s = 60, float sigma_r = (0.4F)); 
# 822 "/usr/include/opencv4/opencv2/photo.hpp" 3
void detailEnhance(InputArray src, OutputArray dst, float sigma_s = 10, float sigma_r = (0.15F)); 
# 837 "/usr/include/opencv4/opencv2/photo.hpp" 3
void pencilSketch(InputArray src, OutputArray dst1, OutputArray dst2, float sigma_s = 60, float sigma_r = (0.07F), float shade_factor = (0.02F)); 
# 849 "/usr/include/opencv4/opencv2/photo.hpp" 3
void stylization(InputArray src, OutputArray dst, float sigma_s = 60, float sigma_r = (0.45F)); 
# 856
}
# 48 "/usr/include/opencv4/opencv2/shape/emdL1.hpp" 3
namespace cv { 
# 66 "/usr/include/opencv4/opencv2/shape/emdL1.hpp" 3
float EMDL1(InputArray signature1, InputArray signature2); 
# 70
}
# 50 "/usr/include/opencv4/opencv2/shape/shape_transformer.hpp" 3
namespace cv { 
# 58
class ShapeTransformer : public Algorithm { 
# 67
public: virtual void estimateTransformation(InputArray transformingShape, InputArray targetShape, std::vector< DMatch>  & matches) = 0; 
# 75
virtual float applyTransformation(InputArray input, OutputArray output = noArray()) = 0; 
# 85 "/usr/include/opencv4/opencv2/shape/shape_transformer.hpp" 3
virtual void warpImage(InputArray transformingImage, OutputArray output, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, const Scalar & borderValue = Scalar()) const = 0; 
# 88
}; 
# 98 "/usr/include/opencv4/opencv2/shape/shape_transformer.hpp" 3
class ThinPlateSplineShapeTransformer : public ShapeTransformer { 
# 106
public: virtual void setRegularizationParameter(double beta) = 0; 
# 107
virtual double getRegularizationParameter() const = 0; 
# 108
}; 
# 112
Ptr< ThinPlateSplineShapeTransformer>  createThinPlateSplineShapeTransformer(double regularizationParameter = 0); 
# 119
class AffineTransformer : public ShapeTransformer { 
# 122
public: virtual void setFullAffine(bool fullAffine) = 0; 
# 123
virtual bool getFullAffine() const = 0; 
# 124
}; 
# 127
Ptr< AffineTransformer>  createAffineTransformer(bool fullAffine); 
# 131
}
# 49 "/usr/include/opencv4/opencv2/shape/hist_cost.hpp" 3
namespace cv { 
# 57
class HistogramCostExtractor : public Algorithm { 
# 60
public: virtual void buildCostMatrix(InputArray descriptors1, InputArray descriptors2, OutputArray costMatrix) = 0; 
# 62
virtual void setNDummies(int nDummies) = 0; 
# 63
virtual int getNDummies() const = 0; 
# 65
virtual void setDefaultCost(float defaultCost) = 0; 
# 66
virtual float getDefaultCost() const = 0; 
# 67
}; 
# 71
class NormHistogramCostExtractor : public HistogramCostExtractor { 
# 74
public: virtual void setNormFlag(int flag) = 0; 
# 75
virtual int getNormFlag() const = 0; 
# 76
}; 
# 79
Ptr< HistogramCostExtractor>  createNormHistogramCostExtractor(int flag = DIST_L2, int nDummies = 25, float defaultCost = (0.2F)); 
# 83
class EMDHistogramCostExtractor : public HistogramCostExtractor { 
# 86
public: virtual void setNormFlag(int flag) = 0; 
# 87
virtual int getNormFlag() const = 0; 
# 88
}; 
# 91
Ptr< HistogramCostExtractor>  createEMDHistogramCostExtractor(int flag = DIST_L2, int nDummies = 25, float defaultCost = (0.2F)); 
# 95
class ChiHistogramCostExtractor : public HistogramCostExtractor { 
# 96
}; 
# 98
Ptr< HistogramCostExtractor>  createChiHistogramCostExtractor(int nDummies = 25, float defaultCost = (0.2F)); 
# 102
class EMDL1HistogramCostExtractor : public HistogramCostExtractor { 
# 103
}; 
# 106
Ptr< HistogramCostExtractor>  createEMDL1HistogramCostExtractor(int nDummies = 25, float defaultCost = (0.2F)); 
# 110
}
# 50 "/usr/include/opencv4/opencv2/shape/shape_distance.hpp" 3
namespace cv { 
# 61 "/usr/include/opencv4/opencv2/shape/shape_distance.hpp" 3
class ShapeDistanceExtractor : public Algorithm { 
# 69
public: virtual float computeDistance(InputArray contour1, InputArray contour2) = 0; 
# 70
}; 
# 81 "/usr/include/opencv4/opencv2/shape/shape_distance.hpp" 3
class ShapeContextDistanceExtractor : public ShapeDistanceExtractor { 
# 89
public: virtual void setAngularBins(int nAngularBins) = 0; 
# 90
virtual int getAngularBins() const = 0; 
# 97
virtual void setRadialBins(int nRadialBins) = 0; 
# 98
virtual int getRadialBins() const = 0; 
# 104
virtual void setInnerRadius(float innerRadius) = 0; 
# 105
virtual float getInnerRadius() const = 0; 
# 111
virtual void setOuterRadius(float outerRadius) = 0; 
# 112
virtual float getOuterRadius() const = 0; 
# 114
virtual void setRotationInvariant(bool rotationInvariant) = 0; 
# 115
virtual bool getRotationInvariant() const = 0; 
# 124 "/usr/include/opencv4/opencv2/shape/shape_distance.hpp" 3
virtual void setShapeContextWeight(float shapeContextWeight) = 0; 
# 125
virtual float getShapeContextWeight() const = 0; 
# 136 "/usr/include/opencv4/opencv2/shape/shape_distance.hpp" 3
virtual void setImageAppearanceWeight(float imageAppearanceWeight) = 0; 
# 137
virtual float getImageAppearanceWeight() const = 0; 
# 146 "/usr/include/opencv4/opencv2/shape/shape_distance.hpp" 3
virtual void setBendingEnergyWeight(float bendingEnergyWeight) = 0; 
# 147
virtual float getBendingEnergyWeight() const = 0; 
# 155
virtual void setImages(InputArray image1, InputArray image2) = 0; 
# 156
virtual void getImages(OutputArray image1, OutputArray image2) const = 0; 
# 158
virtual void setIterations(int iterations) = 0; 
# 159
virtual int getIterations() const = 0; 
# 166
virtual void setCostExtractor(Ptr< HistogramCostExtractor>  comparer) = 0; 
# 167
virtual Ptr< HistogramCostExtractor>  getCostExtractor() const = 0; 
# 173
virtual void setStdDev(float sigma) = 0; 
# 174
virtual float getStdDev() const = 0; 
# 181
virtual void setTransformAlgorithm(Ptr< ShapeTransformer>  transformer) = 0; 
# 182
virtual Ptr< ShapeTransformer>  getTransformAlgorithm() const = 0; 
# 183
}; 
# 187
Ptr< ShapeContextDistanceExtractor>  createShapeContextDistanceExtractor(int nAngularBins = 12, int nRadialBins = 4, float innerRadius = (0.2F), float outerRadius = 2, int iterations = 3, const Ptr< HistogramCostExtractor>  & comparer = createChiHistogramCostExtractor(), const Ptr< ShapeTransformer>  & transformer = createThinPlateSplineShapeTransformer()); 
# 200 "/usr/include/opencv4/opencv2/shape/shape_distance.hpp" 3
class HausdorffDistanceExtractor : public ShapeDistanceExtractor { 
# 208
public: virtual void setDistanceFlag(int distanceFlag) = 0; 
# 209
virtual int getDistanceFlag() const = 0; 
# 217
virtual void setRankProportion(float rankProportion) = 0; 
# 218
virtual float getRankProportion() const = 0; 
# 219
}; 
# 222
Ptr< HausdorffDistanceExtractor>  createHausdorffDistanceExtractor(int distanceFlag = cv::NORM_L2, float rankProp = (0.6F)); 
# 226
}
# 69 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
namespace cv { 
# 71
namespace cuda { 
# 77
template< class T> struct DevPtr { 
# 79
typedef T elem_type; 
# 80
typedef int index_type; 
# 82
enum { elem_size = sizeof(elem_type)}; 
# 84
T *data; 
# 86 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 86 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
DevPtr() : data((0)) { } 
# 87 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 87 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
DevPtr(T *data_) : data(data_) { } 
# 89 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) size_t 
# 89 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
elemSize() const { return elem_size; } 
# 90 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 90 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
operator T *() { return data; } 
# 91 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 91 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
operator const T *() const { return data; } 
# 92
}; 
# 94
template< class T> struct PtrSz : public DevPtr< T>  { 
# 96 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 96 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
PtrSz() : size((0)) { } 
# 97 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 97 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
PtrSz(T *data_, ::size_t size_) : DevPtr< T> (data_), size(size_) { } 
# 99
::size_t size; 
# 100
}; 
# 102
template< class T> struct PtrStep : public DevPtr< T>  { 
# 104 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 104 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
PtrStep() : step((0)) { } 
# 105 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 105 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
PtrStep(T *data_, ::size_t step_) : DevPtr< T> (data_), step(step_) { } 
# 107
::size_t step; 
# 109 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) T *
# 109 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
ptr(int y = 0) { return (T *)(((char *)DevPtr< T> ::data) + (y * (step))); } 
# 110 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) const T *
# 110 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
ptr(int y = 0) const { return (const T *)(((const char *)DevPtr< T> ::data) + (y * (step))); } 
# 112 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) T &
# 112 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
operator()(int y, int x) { return ptr(y)[x]; } 
# 113 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) const T &
# 113 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
operator()(int y, int x) const { return ptr(y)[x]; } 
# 114
}; 
# 116
template< class T> struct PtrStepSz : public PtrStep< T>  { 
# 118 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 118 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
PtrStepSz() : cols(0), rows(0) { } 
# 119 "/usr/include/opencv4/opencv2/core/cuda_types.hpp"
__attribute((always_inline)) 
# 119 "/usr/include/opencv4/opencv2/core/cuda_types.hpp" 3
PtrStepSz(int rows_, int cols_, T *data_, ::size_t step_) : PtrStep< T> (data_, step_), cols(cols_), rows(rows_) 
# 120
{ } 
# 122
template< class U> explicit 
# 123
PtrStepSz(const PtrStepSz< U>  &d) : PtrStep< T> ((T *)(d.data), (d.step)), cols(((d.cols))), rows(((d.rows))) { } 
# 125
int cols; 
# 126
int rows; 
# 127
}; 
# 129
typedef PtrStepSz< unsigned char>  PtrStepSzb; 
# 130
typedef PtrStepSz< unsigned short>  PtrStepSzus; 
# 131
typedef PtrStepSz< float>  PtrStepSzf; 
# 132
typedef PtrStepSz< int>  PtrStepSzi; 
# 134
typedef PtrStep< unsigned char>  PtrStepb; 
# 135
typedef PtrStep< unsigned short>  PtrStepus; 
# 136
typedef PtrStep< float>  PtrStepf; 
# 137
typedef PtrStep< int>  PtrStepi; 
# 139
}
# 140
}
# 65 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
namespace cv { namespace cuda { 
# 105 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
class GpuMat { 
# 108
public: class Allocator { 
# 111
public: virtual ~Allocator() { } 
# 114
virtual bool allocate(GpuMat * mat, int rows, int cols, size_t elemSize) = 0; 
# 115
virtual void free(GpuMat * mat) = 0; 
# 116
}; 
# 119
static Allocator *defaultAllocator(); 
# 120
static void setDefaultAllocator(Allocator * allocator); 
# 123
inline explicit GpuMat(Allocator * allocator = GpuMat::defaultAllocator()); 
# 126
inline GpuMat(int rows, int cols, int type, Allocator * allocator = GpuMat::defaultAllocator()); 
# 127
inline GpuMat(Size size, int type, Allocator * allocator = GpuMat::defaultAllocator()); 
# 130
inline GpuMat(int rows, int cols, int type, Scalar s, Allocator * allocator = GpuMat::defaultAllocator()); 
# 131
inline GpuMat(Size size, int type, Scalar s, Allocator * allocator = GpuMat::defaultAllocator()); 
# 134
inline GpuMat(const GpuMat & m); 
# 137
GpuMat(int rows, int cols, int type, void * data, size_t step = Mat::AUTO_STEP); 
# 138
GpuMat(Size size, int type, void * data, size_t step = Mat::AUTO_STEP); 
# 141
GpuMat(const GpuMat & m, Range rowRange, Range colRange); 
# 142
GpuMat(const GpuMat & m, Rect roi); 
# 145
inline explicit GpuMat(InputArray arr, Allocator * allocator = GpuMat::defaultAllocator()); 
# 148
inline ~GpuMat(); 
# 151
inline GpuMat &operator=(const GpuMat & m); 
# 154
void create(int rows, int cols, int type); 
# 155
inline void create(Size size, int type); 
# 158
void release(); 
# 161
inline void swap(GpuMat & mat); 
# 168
void upload(InputArray arr); 
# 178 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
void upload(InputArray arr, Stream & stream); 
# 185
void download(OutputArray dst) const; 
# 195 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
void download(OutputArray dst, Stream & stream) const; 
# 198
inline GpuMat clone() const; 
# 201
void copyTo(OutputArray dst) const; 
# 204
void copyTo(OutputArray dst, Stream & stream) const; 
# 207
inline void copyTo(OutputArray dst, InputArray mask) const; 
# 210
void copyTo(OutputArray dst, InputArray mask, Stream & stream) const; 
# 213
inline GpuMat &setTo(Scalar s); 
# 216
GpuMat &setTo(Scalar s, Stream & stream); 
# 219
inline GpuMat &setTo(Scalar s, InputArray mask); 
# 222
GpuMat &setTo(Scalar s, InputArray mask, Stream & stream); 
# 225
inline void convertTo(OutputArray dst, int rtype) const; 
# 228
void convertTo(OutputArray dst, int rtype, Stream & stream) const; 
# 231
inline void convertTo(OutputArray dst, int rtype, double alpha, double beta = (0.0)) const; 
# 234
inline void convertTo(OutputArray dst, int rtype, double alpha, Stream & stream) const; 
# 237
void convertTo(OutputArray dst, int rtype, double alpha, double beta, Stream & stream) const; 
# 239
inline void assignTo(GpuMat & m, int type = -1) const; 
# 242
inline uchar *ptr(int y = 0); 
# 243
inline const uchar *ptr(int y = 0) const; 
# 246
template< class _Tp> inline _Tp *ptr(int y = 0); 
# 247
template< class _Tp> inline const _Tp *ptr(int y = 0) const; 
# 249
template< class _Tp> inline operator PtrStepSz< _Tp> () const; 
# 250
template< class _Tp> inline operator PtrStep< _Tp> () const; 
# 253
inline GpuMat row(int y) const; 
# 256
inline GpuMat col(int x) const; 
# 259
inline GpuMat rowRange(int startrow, int endrow) const; 
# 260
inline GpuMat rowRange(Range r) const; 
# 263
inline GpuMat colRange(int startcol, int endcol) const; 
# 264
inline GpuMat colRange(Range r) const; 
# 267
inline GpuMat operator()(Range rowRange, Range colRange) const; 
# 268
inline GpuMat operator()(Rect roi) const; 
# 272
GpuMat reshape(int cn, int rows = 0) const; 
# 275
void locateROI(Size & wholeSize, Point & ofs) const; 
# 278
GpuMat &adjustROI(int dtop, int dbottom, int dleft, int dright); 
# 282
inline bool isContinuous() const; 
# 285
inline size_t elemSize() const; 
# 288
inline size_t elemSize1() const; 
# 291
inline int type() const; 
# 294
inline int depth() const; 
# 297
inline int channels() const; 
# 300
inline size_t step1() const; 
# 303
inline Size size() const; 
# 306
inline bool empty() const; 
# 309
void updateContinuityFlag(); 
# 317
int flags; 
# 320
int rows, cols; 
# 323
size_t step; 
# 326
uchar *data; 
# 330
int *refcount; 
# 333
uchar *datastart; 
# 334
const uchar *dataend; 
# 337
Allocator *allocator; 
# 338
}; 
# 351 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
void createContinuous(int rows, int cols, int type, OutputArray arr); 
# 362 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
void ensureSizeIsEnough(int rows, int cols, int type, OutputArray arr); 
# 481 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
class BufferPool { 
# 486
public: explicit BufferPool(Stream & stream); 
# 489
GpuMat getBuffer(int rows, int cols, int type); 
# 492
GpuMat getBuffer(Size size, int type) { return this->getBuffer(size.height, size.width, type); } 
# 495
Ptr< GpuMat::Allocator>  getAllocator() const { return allocator_; } 
# 498
private: Ptr< GpuMat::Allocator>  allocator_; 
# 499
}; 
# 502
void setBufferPoolUsage(bool on); 
# 503
void setBufferPoolConfig(int deviceId, size_t stackSize, int stackCount); 
# 524 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
class HostMem { 
# 527
public: enum AllocType { PAGE_LOCKED = 1, SHARED, WRITE_COMBINED = 4}; 
# 529
static MatAllocator *getAllocator(AllocType alloc_type = HostMem::AllocType::PAGE_LOCKED); 
# 531
inline explicit HostMem(AllocType alloc_type = HostMem::AllocType::PAGE_LOCKED); 
# 533
inline HostMem(const HostMem & m); 
# 535
inline HostMem(int rows, int cols, int type, AllocType alloc_type = HostMem::AllocType::PAGE_LOCKED); 
# 536
inline HostMem(Size size, int type, AllocType alloc_type = HostMem::AllocType::PAGE_LOCKED); 
# 539
inline explicit HostMem(InputArray arr, AllocType alloc_type = HostMem::AllocType::PAGE_LOCKED); 
# 541
inline ~HostMem(); 
# 543
inline HostMem &operator=(const HostMem & m); 
# 546
inline void swap(HostMem & b); 
# 549
inline HostMem clone() const; 
# 552
void create(int rows, int cols, int type); 
# 553
inline void create(Size size, int type); 
# 557
HostMem reshape(int cn, int rows = 0) const; 
# 560
void release(); 
# 563
inline Mat createMatHeader() const; 
# 572 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
GpuMat createGpuMatHeader() const; 
# 575
inline bool isContinuous() const; 
# 576
inline size_t elemSize() const; 
# 577
inline size_t elemSize1() const; 
# 578
inline int type() const; 
# 579
inline int depth() const; 
# 580
inline int channels() const; 
# 581
inline size_t step1() const; 
# 582
inline Size size() const; 
# 583
inline bool empty() const; 
# 586
int flags; 
# 587
int rows, cols; 
# 588
size_t step; 
# 590
uchar *data; 
# 591
int *refcount; 
# 593
uchar *datastart; 
# 594
const uchar *dataend; 
# 596
AllocType alloc_type; 
# 597
}; 
# 603
void registerPageLocked(Mat & m); 
# 609
void unregisterPageLocked(Mat & m); 
# 642 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
class Stream { 
# 644
typedef void (Stream::*bool_type)(void) const; 
# 645
void this_type_does_not_support_comparisons() const { } 
# 648
public: typedef void (*StreamCallback)(int status, void * userData); 
# 651
Stream(); 
# 654
Stream(const Ptr< GpuMat::Allocator>  & allocator); 
# 658
bool queryIfComplete() const; 
# 662
void waitForCompletion(); 
# 666
void waitEvent(const Event & event); 
# 676 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
void enqueueHostCallback(StreamCallback callback, void * userData); 
# 679
static Stream &Null(); 
# 682
operator bool_type() const; 
# 684
class Impl; 
# 687
private: Ptr< Impl>  impl_; 
# 688
inline Stream(const Ptr< Impl>  & impl); 
# 690
friend struct StreamAccessor; 
# 691
friend class BufferPool; 
# 692
friend class DefaultDeviceInitializer; 
# 693
}; 
# 695
class Event { 
# 698
public: enum CreateFlags { 
# 700
DEFAULT, 
# 701
BLOCKING_SYNC, 
# 702
DISABLE_TIMING, 
# 703
INTERPROCESS = 4
# 704
}; 
# 706
explicit Event(CreateFlags flags = Event::CreateFlags::DEFAULT); 
# 709
void record(Stream & stream = Stream::Null()); 
# 712
bool queryIfComplete() const; 
# 715
void waitForCompletion(); 
# 718
static float elapsedTime(const Event & start, const Event & end); 
# 720
class Impl; 
# 723
private: Ptr< Impl>  impl_; 
# 724
inline Event(const Ptr< Impl>  & impl); 
# 726
friend struct EventAccessor; 
# 727
}; 
# 744 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
int getCudaEnabledDeviceCount(); 
# 752
void setDevice(int device); 
# 756
int getDevice(); 
# 763
void resetDevice(); 
# 767
enum FeatureSet { 
# 769
FEATURE_SET_COMPUTE_10 = 10, 
# 770
FEATURE_SET_COMPUTE_11, 
# 771
FEATURE_SET_COMPUTE_12, 
# 772
FEATURE_SET_COMPUTE_13, 
# 773
FEATURE_SET_COMPUTE_20 = 20, 
# 774
FEATURE_SET_COMPUTE_21, 
# 775
FEATURE_SET_COMPUTE_30 = 30, 
# 776
FEATURE_SET_COMPUTE_32 = 32, 
# 777
FEATURE_SET_COMPUTE_35 = 35, 
# 778
FEATURE_SET_COMPUTE_50 = 50, 
# 780
GLOBAL_ATOMICS = FEATURE_SET_COMPUTE_11, 
# 781
SHARED_ATOMICS, 
# 782
NATIVE_DOUBLE, 
# 783
WARP_SHUFFLE_FUNCTIONS = FEATURE_SET_COMPUTE_30, 
# 784
DYNAMIC_PARALLELISM = FEATURE_SET_COMPUTE_35
# 785
}; 
# 788
bool deviceSupports(FeatureSet feature_set); 
# 796
class TargetArchs { 
# 803
public: static bool builtWith(FeatureSet feature_set); 
# 811
static inline bool has(int major, int minor); 
# 812
static bool hasPtx(int major, int minor); 
# 813
static bool hasBin(int major, int minor); 
# 815
static bool hasEqualOrLessPtx(int major, int minor); 
# 816
static inline bool hasEqualOrGreater(int major, int minor); 
# 817
static bool hasEqualOrGreaterPtx(int major, int minor); 
# 818
static bool hasEqualOrGreaterBin(int major, int minor); 
# 819
}; 
# 823
class DeviceInfo { 
# 827
public: inline DeviceInfo(); 
# 836 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
inline DeviceInfo(int device_id); 
# 840
inline int deviceID() const; 
# 843
const char *name() const; 
# 846
size_t totalGlobalMem() const; 
# 849
size_t sharedMemPerBlock() const; 
# 852
int regsPerBlock() const; 
# 855
int warpSize() const; 
# 858
size_t memPitch() const; 
# 861
int maxThreadsPerBlock() const; 
# 864
Vec3i maxThreadsDim() const; 
# 867
Vec3i maxGridSize() const; 
# 870
int clockRate() const; 
# 873
size_t totalConstMem() const; 
# 876
int majorVersion() const; 
# 879
int minorVersion() const; 
# 882
size_t textureAlignment() const; 
# 885
size_t texturePitchAlignment() const; 
# 888
int multiProcessorCount() const; 
# 891
bool kernelExecTimeoutEnabled() const; 
# 894
bool integrated() const; 
# 897
bool canMapHostMemory() const; 
# 899
enum ComputeMode { 
# 901
ComputeModeDefault, 
# 902
ComputeModeExclusive, 
# 903
ComputeModeProhibited, 
# 904
ComputeModeExclusiveProcess
# 905
}; 
# 908
ComputeMode computeMode() const; 
# 911
int maxTexture1D() const; 
# 914
int maxTexture1DMipmap() const; 
# 917
int maxTexture1DLinear() const; 
# 920
Vec2i maxTexture2D() const; 
# 923
Vec2i maxTexture2DMipmap() const; 
# 926
Vec3i maxTexture2DLinear() const; 
# 929
Vec2i maxTexture2DGather() const; 
# 932
Vec3i maxTexture3D() const; 
# 935
int maxTextureCubemap() const; 
# 938
Vec2i maxTexture1DLayered() const; 
# 941
Vec3i maxTexture2DLayered() const; 
# 944
Vec2i maxTextureCubemapLayered() const; 
# 947
int maxSurface1D() const; 
# 950
Vec2i maxSurface2D() const; 
# 953
Vec3i maxSurface3D() const; 
# 956
Vec2i maxSurface1DLayered() const; 
# 959
Vec3i maxSurface2DLayered() const; 
# 962
int maxSurfaceCubemap() const; 
# 965
Vec2i maxSurfaceCubemapLayered() const; 
# 968
size_t surfaceAlignment() const; 
# 971
bool concurrentKernels() const; 
# 974
bool ECCEnabled() const; 
# 977
int pciBusID() const; 
# 980
int pciDeviceID() const; 
# 983
int pciDomainID() const; 
# 986
bool tccDriver() const; 
# 989
int asyncEngineCount() const; 
# 992
bool unifiedAddressing() const; 
# 995
int memoryClockRate() const; 
# 998
int memoryBusWidth() const; 
# 1001
int l2CacheSize() const; 
# 1004
int maxThreadsPerMultiProcessor() const; 
# 1007
void queryMemory(size_t & totalMemory, size_t & freeMemory) const; 
# 1008
inline size_t freeMemory() const; 
# 1009
inline size_t totalMemory() const; 
# 1017
inline bool supports(FeatureSet feature_set) const; 
# 1024
bool isCompatible() const; 
# 1027
private: int device_id_; 
# 1028
}; 
# 1030
void printCudaDeviceInfo(int device); 
# 1031
void printShortCudaDeviceInfo(int device); 
# 1040 "/usr/include/opencv4/opencv2/core/cuda.hpp" 3
void convertFp16(InputArray _src, OutputArray _dst, Stream & stream = Stream::Null()); 
# 1044
}}
# 51 "/usr/include/opencv4/opencv2/core/cuda.inl.hpp" 3
namespace cv { namespace cuda { 
# 58
inline GpuMat::GpuMat(Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 60
{ } 
# 63
inline GpuMat::GpuMat(int rows_, int cols_, int type_, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 65
{ 
# 66
if ((rows_ > 0) && (cols_ > 0)) { 
# 67
this->create(rows_, cols_, type_); }  
# 68
} 
# 71
inline GpuMat::GpuMat(Size size_, int type_, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 73
{ 
# 74
if (((size_.height) > 0) && ((size_.width) > 0)) { 
# 75
this->create(size_.height, size_.width, type_); }  
# 76
} 
# 79
inline GpuMat::GpuMat(int rows_, int cols_, int type_, Scalar s_, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 81
{ 
# 82
if ((rows_ > 0) && (cols_ > 0)) 
# 83
{ 
# 84
this->create(rows_, cols_, type_); 
# 85
this->setTo(s_); 
# 86
}  
# 87
} 
# 90
inline GpuMat::GpuMat(Size size_, int type_, Scalar s_, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 92
{ 
# 93
if (((size_.height) > 0) && ((size_.width) > 0)) 
# 94
{ 
# 95
this->create(size_.height, size_.width, type_); 
# 96
this->setTo(s_); 
# 97
}  
# 98
} 
# 101
inline GpuMat::GpuMat(const GpuMat &m) : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend), allocator(m.allocator) 
# 103
{ 
# 104
if (refcount) { 
# 105
(int)__atomic_fetch_add((unsigned *)(refcount), (unsigned)1, 4); }  
# 106
} 
# 109
inline GpuMat::GpuMat(InputArray arr, Allocator *allocator_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), allocator(allocator_) 
# 111
{ 
# 112
this->upload(arr); 
# 113
} 
# 116
inline GpuMat::~GpuMat() 
# 117
{ 
# 118
this->release(); 
# 119
} 
# 122
inline GpuMat &GpuMat::operator=(const GpuMat &m) 
# 123
{ 
# 124
if (this != (&m)) 
# 125
{ 
# 126
GpuMat temp(m); 
# 127
this->swap(temp); 
# 128
}  
# 130
return *this; 
# 131
} 
# 134
inline void GpuMat::create(Size size_, int type_) 
# 135
{ 
# 136
this->create(size_.height, size_.width, type_); 
# 137
} 
# 140
inline void GpuMat::swap(GpuMat &b) 
# 141
{ 
# 142
std::swap(flags, b.flags); 
# 143
std::swap(rows, b.rows); 
# 144
std::swap(cols, b.cols); 
# 145
std::swap(step, b.step); 
# 146
std::swap(data, b.data); 
# 147
std::swap(datastart, b.datastart); 
# 148
std::swap(dataend, b.dataend); 
# 149
std::swap(refcount, b.refcount); 
# 150
std::swap(allocator, b.allocator); 
# 151
} 
# 154
inline GpuMat GpuMat::clone() const 
# 155
{ 
# 156
GpuMat m; 
# 157
this->copyTo(m); 
# 158
return m; 
# 159
} 
# 162
inline void GpuMat::copyTo(OutputArray dst, InputArray mask) const 
# 163
{ 
# 164
this->copyTo(dst, mask, Stream::Null()); 
# 165
} 
# 168
inline GpuMat &GpuMat::setTo(Scalar s) 
# 169
{ 
# 170
return this->setTo(s, Stream::Null()); 
# 171
} 
# 174
inline GpuMat &GpuMat::setTo(Scalar s, InputArray mask) 
# 175
{ 
# 176
return this->setTo(s, mask, Stream::Null()); 
# 177
} 
# 180
inline void GpuMat::convertTo(OutputArray dst, int rtype) const 
# 181
{ 
# 182
this->convertTo(dst, rtype, Stream::Null()); 
# 183
} 
# 186
inline void GpuMat::convertTo(OutputArray dst, int rtype, double alpha, double beta) const 
# 187
{ 
# 188
this->convertTo(dst, rtype, alpha, beta, Stream::Null()); 
# 189
} 
# 192
inline void GpuMat::convertTo(OutputArray dst, int rtype, double alpha, Stream &stream) const 
# 193
{ 
# 194
this->convertTo(dst, rtype, alpha, (0.0), stream); 
# 195
} 
# 198
inline void GpuMat::assignTo(GpuMat &m, int _type) const 
# 199
{ 
# 200
if (_type < 0) { 
# 201
(m = (*this)); } else { 
# 203
this->convertTo(m, _type); }  
# 204
} 
# 207
inline uchar *GpuMat::ptr(int y) 
# 208
{ 
# 209
; 
# 210
return (data) + ((step) * y); 
# 211
} 
# 214
inline const uchar *GpuMat::ptr(int y) const 
# 215
{ 
# 216
; 
# 217
return (data) + ((step) * y); 
# 218
} 
# 220
template< class _Tp> inline _Tp *
# 221
GpuMat::ptr(int y) 
# 222
{ 
# 223
return (_Tp *)this->ptr(y); 
# 224
} 
# 226
template< class _Tp> inline const _Tp *
# 227
GpuMat::ptr(int y) const 
# 228
{ 
# 229
return (const _Tp *)this->ptr(y); 
# 230
} 
# 232
template< class T> inline 
# 233
GpuMat::operator PtrStepSz< T> () const 
# 234
{ 
# 235
return PtrStepSz< T> (rows, cols, (T *)(data), step); 
# 236
} 
# 238
template< class T> inline 
# 239
GpuMat::operator PtrStep< T> () const 
# 240
{ 
# 241
return PtrStep< T> ((T *)(data), step); 
# 242
} 
# 245
inline GpuMat GpuMat::row(int y) const 
# 246
{ 
# 247
return GpuMat(*this, Range(y, y + 1), Range::all()); 
# 248
} 
# 251
inline GpuMat GpuMat::col(int x) const 
# 252
{ 
# 253
return GpuMat(*this, Range::all(), Range(x, x + 1)); 
# 254
} 
# 257
inline GpuMat GpuMat::rowRange(int startrow, int endrow) const 
# 258
{ 
# 259
return GpuMat(*this, Range(startrow, endrow), Range::all()); 
# 260
} 
# 263
inline GpuMat GpuMat::rowRange(Range r) const 
# 264
{ 
# 265
return GpuMat(*this, r, Range::all()); 
# 266
} 
# 269
inline GpuMat GpuMat::colRange(int startcol, int endcol) const 
# 270
{ 
# 271
return GpuMat(*this, Range::all(), Range(startcol, endcol)); 
# 272
} 
# 275
inline GpuMat GpuMat::colRange(Range r) const 
# 276
{ 
# 277
return GpuMat(*this, Range::all(), r); 
# 278
} 
# 281
inline GpuMat GpuMat::operator()(Range rowRange_, Range colRange_) const 
# 282
{ 
# 283
return GpuMat(*this, rowRange_, colRange_); 
# 284
} 
# 287
inline GpuMat GpuMat::operator()(Rect roi) const 
# 288
{ 
# 289
return GpuMat(*this, roi); 
# 290
} 
# 293
inline bool GpuMat::isContinuous() const 
# 294
{ 
# 295
return ((flags) & (Mat::CONTINUOUS_FLAG)) != 0; 
# 296
} 
# 299
inline size_t GpuMat::elemSize() const 
# 300
{ 
# 301
return (((((flags) & ((512 - 1) << 3)) >> 3) + 1) * ((675553809 >> (((flags) & ((1 << 3) - 1)) * 4)) & 15)); 
# 302
} 
# 305
inline size_t GpuMat::elemSize1() const 
# 306
{ 
# 307
return ((675553809 >> (((flags) & ((1 << 3) - 1)) * 4)) & 15); 
# 308
} 
# 311
inline int GpuMat::type() const 
# 312
{ 
# 313
return ((flags) & (((1 << 3) * 512) - 1)); 
# 314
} 
# 317
inline int GpuMat::depth() const 
# 318
{ 
# 319
return ((flags) & ((1 << 3) - 1)); 
# 320
} 
# 323
inline int GpuMat::channels() const 
# 324
{ 
# 325
return ((((flags) & ((512 - 1) << 3)) >> 3) + 1); 
# 326
} 
# 329
inline size_t GpuMat::step1() const 
# 330
{ 
# 331
return (step) / this->elemSize1(); 
# 332
} 
# 335
inline Size GpuMat::size() const 
# 336
{ 
# 337
return Size(cols, rows); 
# 338
} 
# 341
inline bool GpuMat::empty() const 
# 342
{ 
# 343
return (data) == (0); 
# 344
} 
# 347
static inline GpuMat createContinuous(int rows, int cols, int type) 
# 348
{ 
# 349
GpuMat m; 
# 350
createContinuous(rows, cols, type, m); 
# 351
return m; 
# 352
} 
# 355
static inline void createContinuous(Size size, int type, OutputArray arr) 
# 356
{ 
# 357
createContinuous(size.height, size.width, type, arr); 
# 358
} 
# 361
static inline GpuMat createContinuous(Size size, int type) 
# 362
{ 
# 363
GpuMat m; 
# 364
createContinuous(size, type, m); 
# 365
return m; 
# 366
} 
# 369
static inline void ensureSizeIsEnough(Size size, int type, OutputArray arr) 
# 370
{ 
# 371
ensureSizeIsEnough(size.height, size.width, type, arr); 
# 372
} 
# 375
static inline void swap(GpuMat &a, GpuMat &b) 
# 376
{ 
# 377
a.swap(b); 
# 378
} 
# 385
inline HostMem::HostMem(AllocType alloc_type_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), alloc_type(alloc_type_) 
# 387
{ 
# 388
} 
# 391
inline HostMem::HostMem(const HostMem &m) : flags(m.flags), rows(m.rows), cols(m.cols), step(m.step), data(m.data), refcount(m.refcount), datastart(m.datastart), dataend(m.dataend), alloc_type(m.alloc_type) 
# 393
{ 
# 394
if (refcount) { 
# 395
(int)__atomic_fetch_add((unsigned *)(refcount), (unsigned)1, 4); }  
# 396
} 
# 399
inline HostMem::HostMem(int rows_, int cols_, int type_, AllocType alloc_type_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), alloc_type(alloc_type_) 
# 401
{ 
# 402
if ((rows_ > 0) && (cols_ > 0)) { 
# 403
this->create(rows_, cols_, type_); }  
# 404
} 
# 407
inline HostMem::HostMem(Size size_, int type_, AllocType alloc_type_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), alloc_type(alloc_type_) 
# 409
{ 
# 410
if (((size_.height) > 0) && ((size_.width) > 0)) { 
# 411
this->create(size_.height, size_.width, type_); }  
# 412
} 
# 415
inline HostMem::HostMem(InputArray arr, AllocType alloc_type_) : flags(0), rows(0), cols(0), step((0)), data((0)), refcount((0)), datastart((0)), dataend((0)), alloc_type(alloc_type_) 
# 417
{ 
# 418
(arr.getMat()).copyTo(*this); 
# 419
} 
# 422
inline HostMem::~HostMem() 
# 423
{ 
# 424
this->release(); 
# 425
} 
# 428
inline HostMem &HostMem::operator=(const HostMem &m) 
# 429
{ 
# 430
if (this != (&m)) 
# 431
{ 
# 432
HostMem temp(m); 
# 433
this->swap(temp); 
# 434
}  
# 436
return *this; 
# 437
} 
# 440
inline void HostMem::swap(HostMem &b) 
# 441
{ 
# 442
std::swap(flags, b.flags); 
# 443
std::swap(rows, b.rows); 
# 444
std::swap(cols, b.cols); 
# 445
std::swap(step, b.step); 
# 446
std::swap(data, b.data); 
# 447
std::swap(datastart, b.datastart); 
# 448
std::swap(dataend, b.dataend); 
# 449
std::swap(refcount, b.refcount); 
# 450
std::swap(alloc_type, b.alloc_type); 
# 451
} 
# 454
inline HostMem HostMem::clone() const 
# 455
{ 
# 456
HostMem m(this->size(), this->type(), alloc_type); 
# 457
(this->createMatHeader()).copyTo(m); 
# 458
return m; 
# 459
} 
# 462
inline void HostMem::create(Size size_, int type_) 
# 463
{ 
# 464
this->create(size_.height, size_.width, type_); 
# 465
} 
# 468
inline Mat HostMem::createMatHeader() const 
# 469
{ 
# 470
return Mat(this->size(), this->type(), data, step); 
# 471
} 
# 474
inline bool HostMem::isContinuous() const 
# 475
{ 
# 476
return ((flags) & (Mat::CONTINUOUS_FLAG)) != 0; 
# 477
} 
# 480
inline size_t HostMem::elemSize() const 
# 481
{ 
# 482
return (((((flags) & ((512 - 1) << 3)) >> 3) + 1) * ((675553809 >> (((flags) & ((1 << 3) - 1)) * 4)) & 15)); 
# 483
} 
# 486
inline size_t HostMem::elemSize1() const 
# 487
{ 
# 488
return ((675553809 >> (((flags) & ((1 << 3) - 1)) * 4)) & 15); 
# 489
} 
# 492
inline int HostMem::type() const 
# 493
{ 
# 494
return ((flags) & (((1 << 3) * 512) - 1)); 
# 495
} 
# 498
inline int HostMem::depth() const 
# 499
{ 
# 500
return ((flags) & ((1 << 3) - 1)); 
# 501
} 
# 504
inline int HostMem::channels() const 
# 505
{ 
# 506
return ((((flags) & ((512 - 1) << 3)) >> 3) + 1); 
# 507
} 
# 510
inline size_t HostMem::step1() const 
# 511
{ 
# 512
return (step) / this->elemSize1(); 
# 513
} 
# 516
inline Size HostMem::size() const 
# 517
{ 
# 518
return Size(cols, rows); 
# 519
} 
# 522
inline bool HostMem::empty() const 
# 523
{ 
# 524
return (data) == (0); 
# 525
} 
# 528
static inline void swap(HostMem &a, HostMem &b) 
# 529
{ 
# 530
a.swap(b); 
# 531
} 
# 538
inline Stream::Stream(const Ptr< Impl>  &impl) : impl_(impl) 
# 540
{ 
# 541
} 
# 548
inline Event::Event(const Ptr< Impl>  &impl) : impl_(impl) 
# 550
{ 
# 551
} 
# 558
inline bool TargetArchs::has(int major, int minor) 
# 559
{ 
# 560
return hasPtx(major, minor) || hasBin(major, minor); 
# 561
} 
# 564
inline bool TargetArchs::hasEqualOrGreater(int major, int minor) 
# 565
{ 
# 566
return hasEqualOrGreaterPtx(major, minor) || hasEqualOrGreaterBin(major, minor); 
# 567
} 
# 570
inline DeviceInfo::DeviceInfo() 
# 571
{ 
# 572
(device_id_) = getDevice(); 
# 573
} 
# 576
inline DeviceInfo::DeviceInfo(int device_id) 
# 577
{ 
# 578
do { if (!(!((device_id >= 0) && (device_id < getCudaEnabledDeviceCount())))) { ; } else { cv::error(cv::Error::StsAssert, "device_id >= 0 && device_id < getCudaEnabledDeviceCount()", __func__, "/usr/include/opencv4/opencv2/core/cuda.inl.hpp", 578); }  } while (0); 
# 579
(device_id_) = device_id; 
# 580
} 
# 583
inline int DeviceInfo::deviceID() const 
# 584
{ 
# 585
return device_id_; 
# 586
} 
# 589
inline size_t DeviceInfo::freeMemory() const 
# 590
{ 
# 591
size_t _totalMemory = (0), _freeMemory = (0); 
# 592
this->queryMemory(_totalMemory, _freeMemory); 
# 593
return _freeMemory; 
# 594
} 
# 597
inline size_t DeviceInfo::totalMemory() const 
# 598
{ 
# 599
size_t _totalMemory = (0), _freeMemory = (0); 
# 600
this->queryMemory(_totalMemory, _freeMemory); 
# 601
return _totalMemory; 
# 602
} 
# 605
inline bool DeviceInfo::supports(FeatureSet feature_set) const 
# 606
{ 
# 607
int version = (this->majorVersion() * 10) + this->minorVersion(); 
# 608
return version >= feature_set; 
# 609
} 
# 612
}}
# 618
namespace cv { 
# 621
inline Mat::Mat(const cuda::GpuMat &m) : flags(0), dims(0), rows(0), cols(0), data((0)), datastart((0)), dataend((0)), datalimit((0)), allocator((0)), u((0)), size(&(rows)) 
# 623
{ 
# 624
m.download(*this); 
# 625
} 
# 627
}
# 51 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
namespace cv { 
# 52
namespace detail { 
# 59
class RotationWarper { 
# 62
public: virtual ~RotationWarper() { } 
# 71 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
virtual Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R) = 0; 
# 82 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) = 0; 
# 94 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst) = 0; 
# 107 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
virtual void warpBackward(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, Size dst_size, OutputArray dst) = 0; 
# 116
virtual Rect warpRoi(Size src_size, InputArray K, InputArray R) = 0; 
# 118
virtual float getScale() const { return (1.0F); } 
# 119
virtual void setScale(float) { } 
# 120
}; 
# 124
struct ProjectorBase { 
# 126
void setCameraParams(InputArray K = Mat::eye(3, 3, 5), InputArray R = Mat::eye(3, 3, 5), InputArray T = Mat::zeros(3, 1, 5)); 
# 130
float scale; 
# 131
float k[9]; 
# 132
float rinv[9]; 
# 133
float r_kinv[9]; 
# 134
float k_rinv[9]; 
# 135
float t[3]; 
# 136
}; 
# 140
template< class P> 
# 141
class RotationWarperBase : public RotationWarper { 
# 144
public: virtual Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R) override; 
# 146
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) override; 
# 148
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst) override; 
# 151
virtual void warpBackward(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, Size dst_size, OutputArray dst) override; 
# 154
virtual Rect warpRoi(Size src_size, InputArray K, InputArray R) override; 
# 156
virtual float getScale() const override { return (projector_).scale; } 
# 157
virtual void setScale(float val) override { ((projector_).scale) = val; } 
# 162
protected: virtual void detectResultRoi(Size src_size, Point & dst_tl, Point & dst_br); 
# 166
void detectResultRoiByBorder(Size src_size, Point & dst_tl, Point & dst_br); 
# 168
P projector_; 
# 169
}; 
# 172
struct PlaneProjector : public ProjectorBase { 
# 174
inline void mapForward(float x, float y, float & u, float & v); 
# 175
inline void mapBackward(float u, float v, float & x, float & y); 
# 176
}; 
# 180
class PlaneWarper : public RotationWarperBase< PlaneProjector>  { 
# 187
public: PlaneWarper(float scale = (1.0F)) { ((projector_).scale) = scale; } 
# 189
virtual Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R) override; 
# 190
Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R, InputArray T); 
# 192
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, InputArray T, OutputArray xmap, OutputArray ymap); 
# 193
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) override; 
# 195
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst) override; 
# 197
virtual Point warp(InputArray src, InputArray K, InputArray R, InputArray T, int interp_mode, int border_mode, OutputArray dst); 
# 200
virtual Rect warpRoi(Size src_size, InputArray K, InputArray R) override; 
# 201
Rect warpRoi(Size src_size, InputArray K, InputArray R, InputArray T); 
# 204
protected: virtual void detectResultRoi(Size src_size, Point & dst_tl, Point & dst_br) override; 
# 205
}; 
# 213
class AffineWarper : public PlaneWarper { 
# 220
public: AffineWarper(float scale = (1.0F)) : PlaneWarper(scale) { } 
# 229 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
virtual Point2f warpPoint(const Point2f & pt, InputArray K, InputArray H) override; 
# 240 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
virtual Rect buildMaps(Size src_size, InputArray K, InputArray H, OutputArray xmap, OutputArray ymap) override; 
# 252 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
virtual Point warp(InputArray src, InputArray K, InputArray H, int interp_mode, int border_mode, OutputArray dst) override; 
# 261
virtual Rect warpRoi(Size src_size, InputArray K, InputArray H) override; 
# 267
protected: void getRTfromHomogeneous(InputArray H, Mat & R, Mat & T); 
# 268
}; 
# 271
struct SphericalProjector : public ProjectorBase { 
# 273
inline void mapForward(float x, float y, float & u, float & v); 
# 274
inline void mapBackward(float u, float v, float & x, float & y); 
# 275
}; 
# 284 "/usr/include/opencv4/opencv2/stitching/detail/warpers.hpp" 3
class SphericalWarper : public RotationWarperBase< SphericalProjector>  { 
# 292
public: SphericalWarper(float scale) { ((projector_).scale) = scale; } 
# 294
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) override; 
# 295
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst) override; 
# 297
protected: virtual void detectResultRoi(Size src_size, Point & dst_tl, Point & dst_br) override; 
# 298
}; 
# 301
struct CylindricalProjector : public ProjectorBase { 
# 303
inline void mapForward(float x, float y, float & u, float & v); 
# 304
inline void mapBackward(float u, float v, float & x, float & y); 
# 305
}; 
# 310
class CylindricalWarper : public RotationWarperBase< CylindricalProjector>  { 
# 317
public: CylindricalWarper(float scale) { ((projector_).scale) = scale; } 
# 319
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) override; 
# 320
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst) override; 
# 322
protected: virtual void detectResultRoi(Size src_size, Point &dst_tl, Point &dst_br) override 
# 323
{ 
# 324
this->RotationWarperBase< CylindricalProjector> ::detectResultRoiByBorder(src_size, dst_tl, dst_br); 
# 325
} 
# 326
}; 
# 329
struct FisheyeProjector : public ProjectorBase { 
# 331
inline void mapForward(float x, float y, float & u, float & v); 
# 332
inline void mapBackward(float u, float v, float & x, float & y); 
# 333
}; 
# 336
class FisheyeWarper : public RotationWarperBase< FisheyeProjector>  { 
# 339
public: FisheyeWarper(float scale) { ((projector_).scale) = scale; } 
# 340
}; 
# 343
struct StereographicProjector : public ProjectorBase { 
# 345
inline void mapForward(float x, float y, float & u, float & v); 
# 346
inline void mapBackward(float u, float v, float & x, float & y); 
# 347
}; 
# 350
class StereographicWarper : public RotationWarperBase< StereographicProjector>  { 
# 353
public: StereographicWarper(float scale) { ((projector_).scale) = scale; } 
# 354
}; 
# 357
struct CompressedRectilinearProjector : public ProjectorBase { 
# 359
float a, b; 
# 361
inline void mapForward(float x, float y, float & u, float & v); 
# 362
inline void mapBackward(float u, float v, float & x, float & y); 
# 363
}; 
# 366
class CompressedRectilinearWarper : public RotationWarperBase< CompressedRectilinearProjector>  { 
# 369
public: CompressedRectilinearWarper(float scale, float A = 1, float B = 1) 
# 370
{ 
# 371
((projector_).a) = A; 
# 372
((projector_).b) = B; 
# 373
((projector_).scale) = scale; 
# 374
} 
# 375
}; 
# 378
struct CompressedRectilinearPortraitProjector : public ProjectorBase { 
# 380
float a, b; 
# 382
inline void mapForward(float x, float y, float & u, float & v); 
# 383
inline void mapBackward(float u, float v, float & x, float & y); 
# 384
}; 
# 387
class CompressedRectilinearPortraitWarper : public RotationWarperBase< CompressedRectilinearPortraitProjector>  { 
# 390
public: CompressedRectilinearPortraitWarper(float scale, float A = 1, float B = 1) 
# 391
{ 
# 392
((projector_).a) = A; 
# 393
((projector_).b) = B; 
# 394
((projector_).scale) = scale; 
# 395
} 
# 396
}; 
# 399
struct PaniniProjector : public ProjectorBase { 
# 401
float a, b; 
# 403
inline void mapForward(float x, float y, float & u, float & v); 
# 404
inline void mapBackward(float u, float v, float & x, float & y); 
# 405
}; 
# 408
class PaniniWarper : public RotationWarperBase< PaniniProjector>  { 
# 411
public: PaniniWarper(float scale, float A = 1, float B = 1) 
# 412
{ 
# 413
((projector_).a) = A; 
# 414
((projector_).b) = B; 
# 415
((projector_).scale) = scale; 
# 416
} 
# 417
}; 
# 420
struct PaniniPortraitProjector : public ProjectorBase { 
# 422
float a, b; 
# 424
inline void mapForward(float x, float y, float & u, float & v); 
# 425
inline void mapBackward(float u, float v, float & x, float & y); 
# 426
}; 
# 429
class PaniniPortraitWarper : public RotationWarperBase< PaniniPortraitProjector>  { 
# 432
public: PaniniPortraitWarper(float scale, float A = 1, float B = 1) 
# 433
{ 
# 434
((projector_).a) = A; 
# 435
((projector_).b) = B; 
# 436
((projector_).scale) = scale; 
# 437
} 
# 439
}; 
# 442
struct MercatorProjector : public ProjectorBase { 
# 444
inline void mapForward(float x, float y, float & u, float & v); 
# 445
inline void mapBackward(float u, float v, float & x, float & y); 
# 446
}; 
# 449
class MercatorWarper : public RotationWarperBase< MercatorProjector>  { 
# 452
public: MercatorWarper(float scale) { ((projector_).scale) = scale; } 
# 453
}; 
# 456
struct TransverseMercatorProjector : public ProjectorBase { 
# 458
inline void mapForward(float x, float y, float & u, float & v); 
# 459
inline void mapBackward(float u, float v, float & x, float & y); 
# 460
}; 
# 463
class TransverseMercatorWarper : public RotationWarperBase< TransverseMercatorProjector>  { 
# 466
public: TransverseMercatorWarper(float scale) { ((projector_).scale) = scale; } 
# 467
}; 
# 470
class PlaneWarperGpu : public PlaneWarper { 
# 473
public: PlaneWarperGpu(float scale = (1.0F)) : PlaneWarper(scale) { } 
# 475
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) override 
# 476
{ 
# 477
Rect result = this->buildMaps(src_size, K, R, d_xmap_, d_ymap_); 
# 478
(d_xmap_).download(xmap); 
# 479
(d_ymap_).download(ymap); 
# 480
return result; 
# 481
} 
# 483
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, InputArray T, OutputArray xmap, OutputArray ymap) override 
# 484
{ 
# 485
Rect result = this->buildMaps(src_size, K, R, T, d_xmap_, d_ymap_); 
# 486
(d_xmap_).download(xmap); 
# 487
(d_ymap_).download(ymap); 
# 488
return result; 
# 489
} 
# 491
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray 
# 492
dst) override 
# 493
{ 
# 494
(d_src_).upload(src); 
# 495
Point result = this->warp(d_src_, K, R, interp_mode, border_mode, d_dst_); 
# 496
(d_dst_).download(dst); 
# 497
return result; 
# 498
} 
# 500
virtual Point warp(InputArray src, InputArray K, InputArray R, InputArray T, int interp_mode, int border_mode, OutputArray 
# 501
dst) override 
# 502
{ 
# 503
(d_src_).upload(src); 
# 504
Point result = this->warp(d_src_, K, R, T, interp_mode, border_mode, d_dst_); 
# 505
(d_dst_).download(dst); 
# 506
return result; 
# 507
} 
# 509
Rect buildMaps(Size src_size, InputArray K, InputArray R, cuda::GpuMat & xmap, cuda::GpuMat & ymap); 
# 511
Rect buildMaps(Size src_size, InputArray K, InputArray R, InputArray T, cuda::GpuMat & xmap, cuda::GpuMat & ymap); 
# 513
Point warp(const cuda::GpuMat & src, InputArray K, InputArray R, int interp_mode, int border_mode, cuda::GpuMat & dst); 
# 516
Point warp(const cuda::GpuMat & src, InputArray K, InputArray R, InputArray T, int interp_mode, int border_mode, cuda::GpuMat & dst); 
# 520
private: cuda::GpuMat d_xmap_, d_ymap_, d_src_, d_dst_; 
# 521
}; 
# 524
class SphericalWarperGpu : public SphericalWarper { 
# 527
public: SphericalWarperGpu(float scale) : SphericalWarper(scale) { } 
# 529
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) override 
# 530
{ 
# 531
Rect result = this->buildMaps(src_size, K, R, d_xmap_, d_ymap_); 
# 532
(d_xmap_).download(xmap); 
# 533
(d_ymap_).download(ymap); 
# 534
return result; 
# 535
} 
# 537
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray 
# 538
dst) override 
# 539
{ 
# 540
(d_src_).upload(src); 
# 541
Point result = this->warp(d_src_, K, R, interp_mode, border_mode, d_dst_); 
# 542
(d_dst_).download(dst); 
# 543
return result; 
# 544
} 
# 546
Rect buildMaps(Size src_size, InputArray K, InputArray R, cuda::GpuMat & xmap, cuda::GpuMat & ymap); 
# 548
Point warp(const cuda::GpuMat & src, InputArray K, InputArray R, int interp_mode, int border_mode, cuda::GpuMat & dst); 
# 552
private: cuda::GpuMat d_xmap_, d_ymap_, d_src_, d_dst_; 
# 553
}; 
# 556
class CylindricalWarperGpu : public CylindricalWarper { 
# 559
public: CylindricalWarperGpu(float scale) : CylindricalWarper(scale) { } 
# 561
virtual Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap) override 
# 562
{ 
# 563
Rect result = this->buildMaps(src_size, K, R, d_xmap_, d_ymap_); 
# 564
(d_xmap_).download(xmap); 
# 565
(d_ymap_).download(ymap); 
# 566
return result; 
# 567
} 
# 569
virtual Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray 
# 570
dst) override 
# 571
{ 
# 572
(d_src_).upload(src); 
# 573
Point result = this->warp(d_src_, K, R, interp_mode, border_mode, d_dst_); 
# 574
(d_dst_).download(dst); 
# 575
return result; 
# 576
} 
# 578
Rect buildMaps(Size src_size, InputArray K, InputArray R, cuda::GpuMat & xmap, cuda::GpuMat & ymap); 
# 580
Point warp(const cuda::GpuMat & src, InputArray K, InputArray R, int interp_mode, int border_mode, cuda::GpuMat & dst); 
# 584
private: cuda::GpuMat d_xmap_, d_ymap_, d_src_, d_dst_; 
# 585
}; 
# 588
struct SphericalPortraitProjector : public ProjectorBase { 
# 590
inline void mapForward(float x, float y, float & u, float & v); 
# 591
inline void mapBackward(float u, float v, float & x, float & y); 
# 592
}; 
# 597
class SphericalPortraitWarper : public RotationWarperBase< SphericalPortraitProjector>  { 
# 600
public: SphericalPortraitWarper(float scale) { ((projector_).scale) = scale; } 
# 603
protected: virtual void detectResultRoi(Size src_size, Point & dst_tl, Point & dst_br) override; 
# 604
}; 
# 606
struct CylindricalPortraitProjector : public ProjectorBase { 
# 608
inline void mapForward(float x, float y, float & u, float & v); 
# 609
inline void mapBackward(float u, float v, float & x, float & y); 
# 610
}; 
# 613
class CylindricalPortraitWarper : public RotationWarperBase< CylindricalPortraitProjector>  { 
# 616
public: CylindricalPortraitWarper(float scale) { ((projector_).scale) = scale; } 
# 619
protected: virtual void detectResultRoi(Size src_size, Point &dst_tl, Point &dst_br) override 
# 620
{ 
# 621
this->RotationWarperBase< CylindricalPortraitProjector> ::detectResultRoiByBorder(src_size, dst_tl, dst_br); 
# 622
} 
# 623
}; 
# 625
struct PlanePortraitProjector : public ProjectorBase { 
# 627
inline void mapForward(float x, float y, float & u, float & v); 
# 628
inline void mapBackward(float u, float v, float & x, float & y); 
# 629
}; 
# 632
class PlanePortraitWarper : public RotationWarperBase< PlanePortraitProjector>  { 
# 635
public: PlanePortraitWarper(float scale) { ((projector_).scale) = scale; } 
# 638
protected: virtual void detectResultRoi(Size src_size, Point &dst_tl, Point &dst_br) override 
# 639
{ 
# 640
this->RotationWarperBase< PlanePortraitProjector> ::detectResultRoiByBorder(src_size, dst_tl, dst_br); 
# 641
} 
# 642
}; 
# 646
}
# 647
}
# 52 "/usr/include/opencv4/opencv2/stitching/detail/warpers_inl.hpp" 3
namespace cv { 
# 53
namespace detail { 
# 55
template< class P> Point2f 
# 56
RotationWarperBase< P> ::warpPoint(const Point2f &pt, InputArray K, InputArray R) 
# 57
{ 
# 58
(projector_).setCameraParams(K, R); 
# 59
Point2f uv; 
# 60
(projector_).mapForward(pt.x, pt.y, uv.x, uv.y); 
# 61
return uv; 
# 62
} 
# 65
template< class P> Rect 
# 66
RotationWarperBase< P> ::buildMaps(Size src_size, InputArray K, InputArray R, OutputArray _xmap, OutputArray _ymap) 
# 67
{ 
# 68
(projector_).setCameraParams(K, R); 
# 70
Point dst_tl, dst_br; 
# 71
detectResultRoi(src_size, dst_tl, dst_br); 
# 73
_xmap.create(((dst_br.y) - (dst_tl.y)) + 1, ((dst_br.x) - (dst_tl.x)) + 1, 5); 
# 74
_ymap.create(((dst_br.y) - (dst_tl.y)) + 1, ((dst_br.x) - (dst_tl.x)) + 1, 5); 
# 76
Mat xmap = _xmap.getMat(), ymap = _ymap.getMat(); 
# 78
float x, y; 
# 79
for (int v = dst_tl.y; v <= (dst_br.y); ++v) 
# 80
{ 
# 81
for (int u = dst_tl.x; u <= (dst_br.x); ++u) 
# 82
{ 
# 83
(projector_).mapBackward(static_cast< float>(u), static_cast< float>(v), x, y); 
# 84
xmap.template at< float> (v - (dst_tl.y), u - (dst_tl.x)) = x; 
# 85
ymap.template at< float> (v - (dst_tl.y), u - (dst_tl.x)) = y; 
# 86
}  
# 87
}  
# 89
return Rect(dst_tl, dst_br); 
# 90
} 
# 93
template< class P> Point 
# 94
RotationWarperBase< P> ::warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray 
# 95
dst) 
# 96
{ 
# 97
UMat xmap, ymap; 
# 98
Rect dst_roi = buildMaps(src.size(), K, R, xmap, ymap); 
# 100
dst.create((dst_roi.height) + 1, (dst_roi.width) + 1, src.type()); 
# 101
remap(src, dst, xmap, ymap, interp_mode, border_mode); 
# 103
return dst_roi.tl(); 
# 104
} 
# 107
template< class P> void 
# 108
RotationWarperBase< P> ::warpBackward(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, Size 
# 109
dst_size, OutputArray dst) 
# 110
{ 
# 111
(projector_).setCameraParams(K, R); 
# 113
Point src_tl, src_br; 
# 114
detectResultRoi(dst_size, src_tl, src_br); 
# 116
Size size = src.size(); 
# 117
do { if (!(!(((((src_br.x) - (src_tl.x)) + 1) == (size.width)) && ((((src_br.y) - (src_tl.y)) + 1) == (size.height))))) { ; } else { cv::error(cv::Error::StsAssert, "src_br.x - src_tl.x + 1 == size.width && src_br.y - src_tl.y + 1 == size.height", __func__, "/usr/include/opencv4/opencv2/stitching/detail/warpers_inl.hpp", 117); }  } while (0); 
# 119
Mat xmap(dst_size, 5); 
# 120
Mat ymap(dst_size, 5); 
# 122
float u, v; 
# 123
for (int y = 0; y < (dst_size.height); ++y) 
# 124
{ 
# 125
for (int x = 0; x < (dst_size.width); ++x) 
# 126
{ 
# 127
(projector_).mapForward(static_cast< float>(x), static_cast< float>(y), u, v); 
# 128
xmap.template at< float> (y, x) = (u - (src_tl.x)); 
# 129
ymap.template at< float> (y, x) = (v - (src_tl.y)); 
# 130
}  
# 131
}  
# 133
dst.create(dst_size, src.type()); 
# 134
remap(src, dst, xmap, ymap, interp_mode, border_mode); 
# 135
} 
# 138
template< class P> Rect 
# 139
RotationWarperBase< P> ::warpRoi(Size src_size, InputArray K, InputArray R) 
# 140
{ 
# 141
(projector_).setCameraParams(K, R); 
# 143
Point dst_tl, dst_br; 
# 144
detectResultRoi(src_size, dst_tl, dst_br); 
# 146
return Rect(dst_tl, Point((dst_br.x) + 1, (dst_br.y) + 1)); 
# 147
} 
# 150
template< class P> void 
# 151
RotationWarperBase< P> ::detectResultRoi(Size src_size, Point &dst_tl, Point &dst_br) 
# 152
{ 
# 153
float tl_uf = std::numeric_limits< float> ::max(); 
# 154
float tl_vf = std::numeric_limits< float> ::max(); 
# 155
float br_uf = -std::numeric_limits< float> ::max(); 
# 156
float br_vf = -std::numeric_limits< float> ::max(); 
# 158
float u, v; 
# 159
for (int y = 0; y < (src_size.height); ++y) 
# 160
{ 
# 161
for (int x = 0; x < (src_size.width); ++x) 
# 162
{ 
# 163
(projector_).mapForward(static_cast< float>(x), static_cast< float>(y), u, v); 
# 164
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 165
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 166
}  
# 167
}  
# 169
(dst_tl.x) = (static_cast< int>(tl_uf)); 
# 170
(dst_tl.y) = (static_cast< int>(tl_vf)); 
# 171
(dst_br.x) = (static_cast< int>(br_uf)); 
# 172
(dst_br.y) = (static_cast< int>(br_vf)); 
# 173
} 
# 176
template< class P> void 
# 177
RotationWarperBase< P> ::detectResultRoiByBorder(Size src_size, Point &dst_tl, Point &dst_br) 
# 178
{ 
# 179
float tl_uf = std::numeric_limits< float> ::max(); 
# 180
float tl_vf = std::numeric_limits< float> ::max(); 
# 181
float br_uf = -std::numeric_limits< float> ::max(); 
# 182
float br_vf = -std::numeric_limits< float> ::max(); 
# 184
float u, v; 
# 185
for (float x = (0); x < (src_size.width); ++x) 
# 186
{ 
# 187
(projector_).mapForward(static_cast< float>(x), 0, u, v); 
# 188
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 189
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 191
(projector_).mapForward(static_cast< float>(x), static_cast< float>((src_size.height) - 1), u, v); 
# 192
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 193
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 194
}  
# 195
for (int y = 0; y < (src_size.height); ++y) 
# 196
{ 
# 197
(projector_).mapForward(0, static_cast< float>(y), u, v); 
# 198
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 199
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 201
(projector_).mapForward(static_cast< float>((src_size.width) - 1), static_cast< float>(y), u, v); 
# 202
tl_uf = (std::min)(tl_uf, u); tl_vf = (std::min)(tl_vf, v); 
# 203
br_uf = (std::max)(br_uf, u); br_vf = (std::max)(br_vf, v); 
# 204
}  
# 206
(dst_tl.x) = (static_cast< int>(tl_uf)); 
# 207
(dst_tl.y) = (static_cast< int>(tl_vf)); 
# 208
(dst_br.x) = (static_cast< int>(br_uf)); 
# 209
(dst_br.y) = (static_cast< int>(br_vf)); 
# 210
} 
# 214
inline void PlaneProjector::mapForward(float x, float y, float &u, float &v) 
# 215
{ 
# 216
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 217
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 218
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 220
x_ = (((t)[0]) + ((x_ / z_) * ((1) - ((t)[2])))); 
# 221
y_ = (((t)[1]) + ((y_ / z_) * ((1) - ((t)[2])))); 
# 223
u = ((scale) * x_); 
# 224
v = ((scale) * y_); 
# 225
} 
# 229
inline void PlaneProjector::mapBackward(float u, float v, float &x, float &y) 
# 230
{ 
# 231
u = ((u / (scale)) - ((t)[0])); 
# 232
v = ((v / (scale)) - ((t)[1])); 
# 234
float z; 
# 235
x = (((((k_rinv)[0]) * u) + (((k_rinv)[1]) * v)) + (((k_rinv)[2]) * ((1) - ((t)[2])))); 
# 236
y = (((((k_rinv)[3]) * u) + (((k_rinv)[4]) * v)) + (((k_rinv)[5]) * ((1) - ((t)[2])))); 
# 237
z = (((((k_rinv)[6]) * u) + (((k_rinv)[7]) * v)) + (((k_rinv)[8]) * ((1) - ((t)[2])))); 
# 239
x /= z; 
# 240
y /= z; 
# 241
} 
# 245
inline void SphericalProjector::mapForward(float x, float y, float &u, float &v) 
# 246
{ 
# 247
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 248
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 249
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 251
u = ((scale) * atan2f(x_, z_)); 
# 252
float w = y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_)); 
# 253
v = ((scale) * ((static_cast< float>((3.141592653589793))) - acosf((w == w) ? w : (0)))); 
# 254
} 
# 258
inline void SphericalProjector::mapBackward(float u, float v, float &x, float &y) 
# 259
{ 
# 260
u /= (scale); 
# 261
v /= (scale); 
# 263
float sinv = sinf((static_cast< float>((3.141592653589793))) - v); 
# 264
float x_ = sinv * sinf(u); 
# 265
float y_ = cosf((static_cast< float>((3.141592653589793))) - v); 
# 266
float z_ = sinv * cosf(u); 
# 268
float z; 
# 269
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 270
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 271
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 273
if (z > (0)) { x /= z; y /= z; } else { 
# 274
x = (y = (-1)); }  
# 275
} 
# 279
inline void CylindricalProjector::mapForward(float x, float y, float &u, float &v) 
# 280
{ 
# 281
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 282
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 283
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 285
u = ((scale) * atan2f(x_, z_)); 
# 286
v = (((scale) * y_) / sqrtf((x_ * x_) + (z_ * z_))); 
# 287
} 
# 291
inline void CylindricalProjector::mapBackward(float u, float v, float &x, float &y) 
# 292
{ 
# 293
u /= (scale); 
# 294
v /= (scale); 
# 296
float x_ = sinf(u); 
# 297
float y_ = v; 
# 298
float z_ = cosf(u); 
# 300
float z; 
# 301
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 302
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 303
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 305
if (z > (0)) { x /= z; y /= z; } else { 
# 306
x = (y = (-1)); }  
# 307
} 
# 310
inline void FisheyeProjector::mapForward(float x, float y, float &u, float &v) 
# 311
{ 
# 312
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 313
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 314
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 316
float u_ = atan2f(x_, z_); 
# 317
float v_ = ((float)(3.141592653589793)) - acosf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 319
u = (((scale) * v_) * cosf(u_)); 
# 320
v = (((scale) * v_) * sinf(u_)); 
# 321
} 
# 324
inline void FisheyeProjector::mapBackward(float u, float v, float &x, float &y) 
# 325
{ 
# 326
u /= (scale); 
# 327
v /= (scale); 
# 329
float u_ = atan2f(v, u); 
# 330
float v_ = sqrtf((u * u) + (v * v)); 
# 332
float sinv = sinf(((float)(3.141592653589793)) - v_); 
# 333
float x_ = sinv * sinf(u_); 
# 334
float y_ = cosf(((float)(3.141592653589793)) - v_); 
# 335
float z_ = sinv * cosf(u_); 
# 337
float z; 
# 338
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 339
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 340
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 342
if (z > (0)) { x /= z; y /= z; } else { 
# 343
x = (y = (-1)); }  
# 344
} 
# 347
inline void StereographicProjector::mapForward(float x, float y, float &u, float &v) 
# 348
{ 
# 349
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 350
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 351
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 353
float u_ = atan2f(x_, z_); 
# 354
float v_ = ((float)(3.141592653589793)) - acosf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 356
float r = sinf(v_) / ((1) - cosf(v_)); 
# 358
u = (((scale) * r) * cos(u_)); 
# 359
v = (((scale) * r) * sin(u_)); 
# 360
} 
# 363
inline void StereographicProjector::mapBackward(float u, float v, float &x, float &y) 
# 364
{ 
# 365
u /= (scale); 
# 366
v /= (scale); 
# 368
float u_ = atan2f(v, u); 
# 369
float r = sqrtf((u * u) + (v * v)); 
# 370
float v_ = (2) * atanf((1.0F) / r); 
# 372
float sinv = sinf(((float)(3.141592653589793)) - v_); 
# 373
float x_ = sinv * sinf(u_); 
# 374
float y_ = cosf(((float)(3.141592653589793)) - v_); 
# 375
float z_ = sinv * cosf(u_); 
# 377
float z; 
# 378
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 379
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 380
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 382
if (z > (0)) { x /= z; y /= z; } else { 
# 383
x = (y = (-1)); }  
# 384
} 
# 387
inline void CompressedRectilinearProjector::mapForward(float x, float y, float &u, float &v) 
# 388
{ 
# 389
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 390
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 391
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 393
float u_ = atan2f(x_, z_); 
# 394
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 396
u = (((scale) * (a)) * tanf(u_ / (a))); 
# 397
v = ((((scale) * (b)) * tanf(v_)) / cosf(u_)); 
# 398
} 
# 401
inline void CompressedRectilinearProjector::mapBackward(float u, float v, float &x, float &y) 
# 402
{ 
# 403
u /= (scale); 
# 404
v /= (scale); 
# 406
float aatg = (a) * atanf(u / (a)); 
# 407
float u_ = aatg; 
# 408
float v_ = atanf((v * cosf(aatg)) / (b)); 
# 410
float cosv = cosf(v_); 
# 411
float x_ = cosv * sinf(u_); 
# 412
float y_ = sinf(v_); 
# 413
float z_ = cosv * cosf(u_); 
# 415
float z; 
# 416
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 417
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 418
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 420
if (z > (0)) { x /= z; y /= z; } else { 
# 421
x = (y = (-1)); }  
# 422
} 
# 425
inline void CompressedRectilinearPortraitProjector::mapForward(float x, float y, float &u, float &v) 
# 426
{ 
# 427
float y_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 428
float x_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 429
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 431
float u_ = atan2f(x_, z_); 
# 432
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 434
u = (((-(scale)) * (a)) * tanf(u_ / (a))); 
# 435
v = ((((scale) * (b)) * tanf(v_)) / cosf(u_)); 
# 436
} 
# 439
inline void CompressedRectilinearPortraitProjector::mapBackward(float u, float v, float &x, float &y) 
# 440
{ 
# 441
u /= (-(scale)); 
# 442
v /= (scale); 
# 444
float aatg = (a) * atanf(u / (a)); 
# 445
float u_ = aatg; 
# 446
float v_ = atanf((v * cosf(aatg)) / (b)); 
# 448
float cosv = cosf(v_); 
# 449
float y_ = cosv * sinf(u_); 
# 450
float x_ = sinf(v_); 
# 451
float z_ = cosv * cosf(u_); 
# 453
float z; 
# 454
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 455
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 456
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 458
if (z > (0)) { x /= z; y /= z; } else { 
# 459
x = (y = (-1)); }  
# 460
} 
# 463
inline void PaniniProjector::mapForward(float x, float y, float &u, float &v) 
# 464
{ 
# 465
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 466
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 467
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 469
float u_ = atan2f(x_, z_); 
# 470
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 472
float tg = (a) * tanf(u_ / (a)); 
# 473
u = ((scale) * tg); 
# 475
float sinu = sinf(u_); 
# 476
if ((fabs(sinu)) < (1.0E-7)) { 
# 477
v = (((scale) * (b)) * tanf(v_)); } else { 
# 479
v = (((((scale) * (b)) * tg) * tanf(v_)) / sinu); }  
# 480
} 
# 483
inline void PaniniProjector::mapBackward(float u, float v, float &x, float &y) 
# 484
{ 
# 485
u /= (scale); 
# 486
v /= (scale); 
# 488
float lamda = (a) * atanf(u / (a)); 
# 489
float u_ = lamda; 
# 491
float v_; 
# 492
if ((fabs(lamda)) > (1.0E-7)) { 
# 493
v_ = atanf((v * sinf(lamda)) / (((b) * (a)) * tanf(lamda / (a)))); } else { 
# 495
v_ = atanf(v / (b)); }  
# 497
float cosv = cosf(v_); 
# 498
float x_ = cosv * sinf(u_); 
# 499
float y_ = sinf(v_); 
# 500
float z_ = cosv * cosf(u_); 
# 502
float z; 
# 503
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 504
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 505
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 507
if (z > (0)) { x /= z; y /= z; } else { 
# 508
x = (y = (-1)); }  
# 509
} 
# 512
inline void PaniniPortraitProjector::mapForward(float x, float y, float &u, float &v) 
# 513
{ 
# 514
float y_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 515
float x_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 516
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 518
float u_ = atan2f(x_, z_); 
# 519
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 521
float tg = (a) * tanf(u_ / (a)); 
# 522
u = ((-(scale)) * tg); 
# 524
float sinu = sinf(u_); 
# 525
if ((fabs(sinu)) < (1.0E-7)) { 
# 526
v = (((scale) * (b)) * tanf(v_)); } else { 
# 528
v = (((((scale) * (b)) * tg) * tanf(v_)) / sinu); }  
# 529
} 
# 532
inline void PaniniPortraitProjector::mapBackward(float u, float v, float &x, float &y) 
# 533
{ 
# 534
u /= (-(scale)); 
# 535
v /= (scale); 
# 537
float lamda = (a) * atanf(u / (a)); 
# 538
float u_ = lamda; 
# 540
float v_; 
# 541
if ((fabs(lamda)) > (1.0E-7)) { 
# 542
v_ = atanf((v * sinf(lamda)) / (((b) * (a)) * tanf(lamda / (a)))); } else { 
# 544
v_ = atanf(v / (b)); }  
# 546
float cosv = cosf(v_); 
# 547
float y_ = cosv * sinf(u_); 
# 548
float x_ = sinf(v_); 
# 549
float z_ = cosv * cosf(u_); 
# 551
float z; 
# 552
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 553
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 554
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 556
if (z > (0)) { x /= z; y /= z; } else { 
# 557
x = (y = (-1)); }  
# 558
} 
# 561
inline void MercatorProjector::mapForward(float x, float y, float &u, float &v) 
# 562
{ 
# 563
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 564
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 565
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 567
float u_ = atan2f(x_, z_); 
# 568
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 570
u = ((scale) * u_); 
# 571
v = ((scale) * logf(tanf(((float)((3.141592653589793) / (4))) + (v_ / (2))))); 
# 572
} 
# 575
inline void MercatorProjector::mapBackward(float u, float v, float &x, float &y) 
# 576
{ 
# 577
u /= (scale); 
# 578
v /= (scale); 
# 580
float v_ = atanf(sinhf(v)); 
# 581
float u_ = u; 
# 583
float cosv = cosf(v_); 
# 584
float x_ = cosv * sinf(u_); 
# 585
float y_ = sinf(v_); 
# 586
float z_ = cosv * cosf(u_); 
# 588
float z; 
# 589
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 590
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 591
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 593
if (z > (0)) { x /= z; y /= z; } else { 
# 594
x = (y = (-1)); }  
# 595
} 
# 598
inline void TransverseMercatorProjector::mapForward(float x, float y, float &u, float &v) 
# 599
{ 
# 600
float x_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 601
float y_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 602
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 604
float u_ = atan2f(x_, z_); 
# 605
float v_ = asinf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))); 
# 607
float B = cosf(v_) * sinf(u_); 
# 609
u = (((scale) / (2)) * logf(((1) + B) / ((1) - B))); 
# 610
v = ((scale) * atan2f(tanf(v_), cosf(u_))); 
# 611
} 
# 614
inline void TransverseMercatorProjector::mapBackward(float u, float v, float &x, float &y) 
# 615
{ 
# 616
u /= (scale); 
# 617
v /= (scale); 
# 619
float v_ = asinf(sinf(v) / coshf(u)); 
# 620
float u_ = atan2f(sinhf(u), cos(v)); 
# 622
float cosv = cosf(v_); 
# 623
float x_ = cosv * sinf(u_); 
# 624
float y_ = sinf(v_); 
# 625
float z_ = cosv * cosf(u_); 
# 627
float z; 
# 628
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 629
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 630
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 632
if (z > (0)) { x /= z; y /= z; } else { 
# 633
x = (y = (-1)); }  
# 634
} 
# 637
inline void SphericalPortraitProjector::mapForward(float x, float y, float &u0, float &v0) 
# 638
{ 
# 639
float x0_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 640
float y0_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 641
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 643
float x_ = y0_; 
# 644
float y_ = x0_; 
# 645
float u, v; 
# 647
u = ((scale) * atan2f(x_, z_)); 
# 648
v = ((scale) * ((static_cast< float>((3.141592653589793))) - acosf(y_ / sqrtf(((x_ * x_) + (y_ * y_)) + (z_ * z_))))); 
# 650
u0 = (-u); 
# 651
v0 = v; 
# 652
} 
# 656
inline void SphericalPortraitProjector::mapBackward(float u0, float v0, float &x, float &y) 
# 657
{ 
# 658
float u, v; 
# 659
u = (-u0); 
# 660
v = v0; 
# 662
u /= (scale); 
# 663
v /= (scale); 
# 665
float sinv = sinf((static_cast< float>((3.141592653589793))) - v); 
# 666
float x0_ = sinv * sinf(u); 
# 667
float y0_ = cosf((static_cast< float>((3.141592653589793))) - v); 
# 668
float z_ = sinv * cosf(u); 
# 670
float x_ = y0_; 
# 671
float y_ = x0_; 
# 673
float z; 
# 674
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 675
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 676
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 678
if (z > (0)) { x /= z; y /= z; } else { 
# 679
x = (y = (-1)); }  
# 680
} 
# 683
inline void CylindricalPortraitProjector::mapForward(float x, float y, float &u0, float &v0) 
# 684
{ 
# 685
float x0_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 686
float y0_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 687
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 689
float x_ = y0_; 
# 690
float y_ = x0_; 
# 691
float u, v; 
# 693
u = ((scale) * atan2f(x_, z_)); 
# 694
v = (((scale) * y_) / sqrtf((x_ * x_) + (z_ * z_))); 
# 696
u0 = (-u); 
# 697
v0 = v; 
# 698
} 
# 702
inline void CylindricalPortraitProjector::mapBackward(float u0, float v0, float &x, float &y) 
# 703
{ 
# 704
float u, v; 
# 705
u = (-u0); 
# 706
v = v0; 
# 708
u /= (scale); 
# 709
v /= (scale); 
# 711
float x0_ = sinf(u); 
# 712
float y0_ = v; 
# 713
float z_ = cosf(u); 
# 715
float x_ = y0_; 
# 716
float y_ = x0_; 
# 718
float z; 
# 719
x = (((((k_rinv)[0]) * x_) + (((k_rinv)[1]) * y_)) + (((k_rinv)[2]) * z_)); 
# 720
y = (((((k_rinv)[3]) * x_) + (((k_rinv)[4]) * y_)) + (((k_rinv)[5]) * z_)); 
# 721
z = (((((k_rinv)[6]) * x_) + (((k_rinv)[7]) * y_)) + (((k_rinv)[8]) * z_)); 
# 723
if (z > (0)) { x /= z; y /= z; } else { 
# 724
x = (y = (-1)); }  
# 725
} 
# 728
inline void PlanePortraitProjector::mapForward(float x, float y, float &u0, float &v0) 
# 729
{ 
# 730
float x0_ = ((((r_kinv)[0]) * x) + (((r_kinv)[1]) * y)) + ((r_kinv)[2]); 
# 731
float y0_ = ((((r_kinv)[3]) * x) + (((r_kinv)[4]) * y)) + ((r_kinv)[5]); 
# 732
float z_ = ((((r_kinv)[6]) * x) + (((r_kinv)[7]) * y)) + ((r_kinv)[8]); 
# 734
float x_ = y0_; 
# 735
float y_ = x0_; 
# 737
x_ = (((t)[0]) + ((x_ / z_) * ((1) - ((t)[2])))); 
# 738
y_ = (((t)[1]) + ((y_ / z_) * ((1) - ((t)[2])))); 
# 740
float u, v; 
# 741
u = ((scale) * x_); 
# 742
v = ((scale) * y_); 
# 744
u0 = (-u); 
# 745
v0 = v; 
# 746
} 
# 750
inline void PlanePortraitProjector::mapBackward(float u0, float v0, float &x, float &y) 
# 751
{ 
# 752
float u, v; 
# 753
u = (-u0); 
# 754
v = v0; 
# 756
u = ((u / (scale)) - ((t)[0])); 
# 757
v = ((v / (scale)) - ((t)[1])); 
# 759
float z; 
# 760
x = (((((k_rinv)[0]) * v) + (((k_rinv)[1]) * u)) + (((k_rinv)[2]) * ((1) - ((t)[2])))); 
# 761
y = (((((k_rinv)[3]) * v) + (((k_rinv)[4]) * u)) + (((k_rinv)[5]) * ((1) - ((t)[2])))); 
# 762
z = (((((k_rinv)[6]) * v) + (((k_rinv)[7]) * u)) + (((k_rinv)[8]) * ((1) - ((t)[2])))); 
# 764
x /= z; 
# 765
y /= z; 
# 766
} 
# 769
}
# 770
}
# 49 "/usr/include/opencv4/opencv2/stitching/warpers.hpp" 3
namespace cv { 
# 50
class PyRotationWarper { 
# 52
Ptr< detail::RotationWarper>  rw; 
# 55
public: PyRotationWarper(String type, float scale); 
# 56
PyRotationWarper() { } 
# 57
~PyRotationWarper() { } 
# 66 "/usr/include/opencv4/opencv2/stitching/warpers.hpp" 3
Point2f warpPoint(const Point2f & pt, InputArray K, InputArray R); 
# 77 "/usr/include/opencv4/opencv2/stitching/warpers.hpp" 3
Rect buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap); 
# 89 "/usr/include/opencv4/opencv2/stitching/warpers.hpp" 3
Point warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst); 
# 102 "/usr/include/opencv4/opencv2/stitching/warpers.hpp" 3
void warpBackward(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, Size dst_size, OutputArray dst); 
# 111
Rect warpRoi(Size src_size, InputArray K, InputArray R); 
# 113
float getScale() const { return (1.0F); } 
# 114
void setScale(float) { } 
# 115
}; 
# 123
class WarperCreator { 
# 126
public: virtual ~WarperCreator() { } 
# 127
virtual Ptr< detail::RotationWarper>  create(float scale) const = 0; 
# 128
}; 
# 134
class PlaneWarper : public WarperCreator { 
# 137
public: virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::PlaneWarper> (scale); } 
# 138
}; 
# 143
class AffineWarper : public WarperCreator { 
# 146
public: virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::AffineWarper> (scale); } 
# 147
}; 
# 152
class CylindricalWarper : public WarperCreator { 
# 155
public: virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::CylindricalWarper> (scale); } 
# 156
}; 
# 159
class SphericalWarper : public WarperCreator { 
# 162
public: virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::SphericalWarper> (scale); } 
# 163
}; 
# 165
class FisheyeWarper : public WarperCreator { 
# 168
public: virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::FisheyeWarper> (scale); } 
# 169
}; 
# 171
class StereographicWarper : public WarperCreator { 
# 174
public: virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::StereographicWarper> (scale); } 
# 175
}; 
# 177
class CompressedRectilinearWarper : public WarperCreator { 
# 179
float a, b; 
# 181
public: CompressedRectilinearWarper(float A = 1, float B = 1) 
# 182
{ 
# 183
(a) = A; (b) = B; 
# 184
} 
# 185
virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::CompressedRectilinearWarper> (scale, a, b); } 
# 186
}; 
# 188
class CompressedRectilinearPortraitWarper : public WarperCreator { 
# 190
float a, b; 
# 192
public: CompressedRectilinearPortraitWarper(float A = 1, float B = 1) 
# 193
{ 
# 194
(a) = A; (b) = B; 
# 195
} 
# 196
virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::CompressedRectilinearPortraitWarper> (scale, a, b); } 
# 197
}; 
# 199
class PaniniWarper : public WarperCreator { 
# 201
float a, b; 
# 203
public: PaniniWarper(float A = 1, float B = 1) 
# 204
{ 
# 205
(a) = A; (b) = B; 
# 206
} 
# 207
virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::PaniniWarper> (scale, a, b); } 
# 208
}; 
# 210
class PaniniPortraitWarper : public WarperCreator { 
# 212
float a, b; 
# 214
public: PaniniPortraitWarper(float A = 1, float B = 1) 
# 215
{ 
# 216
(a) = A; (b) = B; 
# 217
} 
# 218
virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::PaniniPortraitWarper> (scale, a, b); } 
# 219
}; 
# 221
class MercatorWarper : public WarperCreator { 
# 224
public: virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::MercatorWarper> (scale); } 
# 225
}; 
# 227
class TransverseMercatorWarper : public WarperCreator { 
# 230
public: virtual Ptr< detail::RotationWarper>  create(float scale) const override { return makePtr< detail::TransverseMercatorWarper> (scale); } 
# 231
}; 
# 259 "/usr/include/opencv4/opencv2/stitching/warpers.hpp" 3
}
# 51 "/usr/include/opencv4/opencv2/stitching/detail/matchers.hpp" 3
namespace cv { 
# 52
namespace detail { 
# 58
struct ImageFeatures { 
# 60
int img_idx; 
# 61
Size img_size; 
# 62
std::vector< KeyPoint>  keypoints; 
# 63
UMat descriptors; 
# 64
std::vector< KeyPoint>  getKeypoints() { return keypoints; } 
# 65
}; 
# 73
void computeImageFeatures(const Ptr< Feature2D>  & featuresFinder, InputArrayOfArrays images, std::vector< ImageFeatures>  & features, InputArrayOfArrays masks = noArray()); 
# 86 "/usr/include/opencv4/opencv2/stitching/detail/matchers.hpp" 3
void computeImageFeatures(const Ptr< Feature2D>  & featuresFinder, InputArray image, ImageFeatures & features, InputArray mask = noArray()); 
# 99 "/usr/include/opencv4/opencv2/stitching/detail/matchers.hpp" 3
struct MatchesInfo { 
# 101
MatchesInfo(); 
# 102
MatchesInfo(const MatchesInfo & other); 
# 103
MatchesInfo &operator=(const MatchesInfo & other); 
# 105
int src_img_idx; 
# 106
int dst_img_idx; 
# 107
std::vector< DMatch>  matches; 
# 108
std::vector< unsigned char>  inliers_mask; 
# 109
int num_inliers; 
# 110
Mat H; 
# 111
double confidence; 
# 112
std::vector< DMatch>  getMatches() { return matches; } 
# 113
std::vector< unsigned char>  getInliers() { return inliers_mask; } 
# 114
}; 
# 117
class FeaturesMatcher { 
# 120
public: virtual ~FeaturesMatcher() { } 
# 127
void operator()(const ImageFeatures &features1, const ImageFeatures &features2, MatchesInfo &
# 128
matches_info) { this->match(features1, features2, matches_info); } 
# 140 "/usr/include/opencv4/opencv2/stitching/detail/matchers.hpp" 3
void operator()(const std::vector< ImageFeatures>  & features, std::vector< MatchesInfo>  & pairwise_matches, const UMat & mask = UMat()); 
# 145
bool isThreadSafe() const { return is_thread_safe_; } 
# 149
virtual void collectGarbage() { } 
# 152
protected: FeaturesMatcher(bool is_thread_safe = false) : is_thread_safe_(is_thread_safe) { } 
# 161 "/usr/include/opencv4/opencv2/stitching/detail/matchers.hpp" 3
virtual void match(const ImageFeatures & features1, const ImageFeatures & features2, MatchesInfo & matches_info) = 0; 
# 164
bool is_thread_safe_; 
# 165
}; 
# 172
class BestOf2NearestMatcher : public FeaturesMatcher { 
# 184 "/usr/include/opencv4/opencv2/stitching/detail/matchers.hpp" 3
public: BestOf2NearestMatcher(bool try_use_gpu = false, float match_conf = (0.3F), int num_matches_thresh1 = 6, int num_matches_thresh2 = 6); 
# 187
virtual void collectGarbage() override; 
# 188
static Ptr< BestOf2NearestMatcher>  create(bool try_use_gpu = false, float match_conf = (0.3F), int num_matches_thresh1 = 6, int num_matches_thresh2 = 6); 
# 193
protected: virtual void match(const ImageFeatures & features1, const ImageFeatures & features2, MatchesInfo & matches_info) override; 
# 194
int num_matches_thresh1_; 
# 195
int num_matches_thresh2_; 
# 196
Ptr< FeaturesMatcher>  impl_; 
# 197
}; 
# 199
class BestOf2NearestRangeMatcher : public BestOf2NearestMatcher { 
# 202
public: BestOf2NearestRangeMatcher(int range_width = 5, bool try_use_gpu = false, float match_conf = (0.3F), int num_matches_thresh1 = 6, int num_matches_thresh2 = 6); 
# 205
void operator()(const std::vector< ImageFeatures>  & features, std::vector< MatchesInfo>  & pairwise_matches, const UMat & mask = UMat()); 
# 210
protected: int range_width_; 
# 211
}; 
# 222 "/usr/include/opencv4/opencv2/stitching/detail/matchers.hpp" 3
class AffineBestOf2NearestMatcher : public BestOf2NearestMatcher { 
# 237 "/usr/include/opencv4/opencv2/stitching/detail/matchers.hpp" 3
public: AffineBestOf2NearestMatcher(bool full_affine = false, bool try_use_gpu = false, float 
# 238
match_conf = (0.3F), int num_matches_thresh1 = 6) : BestOf2NearestMatcher(try_use_gpu, match_conf, num_matches_thresh1, num_matches_thresh1), full_affine_(full_affine) 
# 240
{ } 
# 243
protected: virtual void match(const ImageFeatures & features1, const ImageFeatures & features2, MatchesInfo & matches_info) override; 
# 245
bool full_affine_; 
# 246
}; 
# 250
}
# 251
}
# 67 "/usr/include/c++/9/bits/stl_list.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 71
namespace __detail { 
# 80
struct _List_node_base { 
# 82
_List_node_base *_M_next; 
# 83
_List_node_base *_M_prev; 
# 86
static void swap(_List_node_base & __x, _List_node_base & __y) noexcept; 
# 89
void _M_transfer(_List_node_base *const __first, _List_node_base *const __last) noexcept; 
# 93
void _M_reverse() noexcept; 
# 96
void _M_hook(_List_node_base *const __position) noexcept; 
# 99
void _M_unhook() noexcept; 
# 100
}; 
# 103
struct _List_node_header : public _List_node_base { 
# 106
size_t _M_size; 
# 109
_List_node_header() noexcept 
# 110
{ this->_M_init(); } 
# 113
_List_node_header(_List_node_header &&__x) noexcept : _List_node_base{__x._M_next, __x._M_prev}, _M_size(__x._M_size) 
# 118
{ 
# 119
if ((__x._M_base()->_M_next) == __x._M_base()) { 
# 120
(this->_M_next) = ((this->_M_prev) = this); } else 
# 122
{ 
# 123
((this->_M_next)->_M_prev) = (((this->_M_prev)->_M_next) = this->_M_base()); 
# 124
__x._M_init(); 
# 125
}  
# 126
} 
# 129
void _M_move_nodes(_List_node_header &&__x) 
# 130
{ 
# 131
_List_node_base *const __xnode = __x._M_base(); 
# 132
if ((__xnode->_M_next) == __xnode) { 
# 133
this->_M_init(); } else 
# 135
{ 
# 136
_List_node_base *const __node = this->_M_base(); 
# 137
(__node->_M_next) = (__xnode->_M_next); 
# 138
(__node->_M_prev) = (__xnode->_M_prev); 
# 139
((__node->_M_next)->_M_prev) = (((__node->_M_prev)->_M_next) = __node); 
# 141
(_M_size) = (__x._M_size); 
# 143
__x._M_init(); 
# 144
}  
# 145
} 
# 149
void _M_init() noexcept 
# 150
{ 
# 151
(this->_M_next) = ((this->_M_prev) = this); 
# 153
(this->_M_size) = (0); 
# 155
} 
# 158
private: _List_node_base *_M_base() { return this; } 
# 159
}; 
# 160
}
# 165
template< class _Tp> 
# 166
struct _List_node : public __detail::_List_node_base { 
# 169
__gnu_cxx::__aligned_membuf< _Tp>  _M_storage; 
# 170
_Tp *_M_valptr() { return (_M_storage)._M_ptr(); } 
# 171
const _Tp *_M_valptr() const { return (_M_storage)._M_ptr(); } 
# 177
}; 
# 184
template< class _Tp> 
# 185
struct _List_iterator { 
# 187
typedef _List_iterator _Self; 
# 188
typedef _List_node< _Tp>  _Node; 
# 190
typedef ptrdiff_t difference_type; 
# 191
typedef bidirectional_iterator_tag iterator_category; 
# 192
typedef _Tp value_type; 
# 193
typedef _Tp *pointer; 
# 194
typedef _Tp &reference; 
# 196
_List_iterator() noexcept : _M_node() 
# 197
{ } 
# 200
explicit _List_iterator(__detail::_List_node_base *__x) noexcept : _M_node(__x) 
# 201
{ } 
# 204
_Self _M_const_cast() const noexcept 
# 205
{ return *this; } 
# 209
reference operator*() const noexcept 
# 210
{ return *(static_cast< _Node *>(_M_node))->_M_valptr(); } 
# 213
pointer operator->() const noexcept 
# 214
{ return (static_cast< _Node *>(_M_node))->_M_valptr(); } 
# 217
_Self &operator++() noexcept 
# 218
{ 
# 219
(_M_node) = ((_M_node)->_M_next); 
# 220
return *this; 
# 221
} 
# 224
_Self operator++(int) noexcept 
# 225
{ 
# 226
_Self __tmp = *this; 
# 227
(_M_node) = ((_M_node)->_M_next); 
# 228
return __tmp; 
# 229
} 
# 232
_Self &operator--() noexcept 
# 233
{ 
# 234
(_M_node) = ((_M_node)->_M_prev); 
# 235
return *this; 
# 236
} 
# 239
_Self operator--(int) noexcept 
# 240
{ 
# 241
_Self __tmp = *this; 
# 242
(_M_node) = ((_M_node)->_M_prev); 
# 243
return __tmp; 
# 244
} 
# 247
friend inline bool operator==(const typename _List_iterator< _Tp> ::_Self &__x, const typename _List_iterator< _Tp> ::_Self &__y) noexcept 
# 248
{ return (__x._M_node) == (__y._M_node); } 
# 251
friend inline bool operator!=(const typename _List_iterator< _Tp> ::_Self &__x, const typename _List_iterator< _Tp> ::_Self &__y) noexcept 
# 252
{ return (__x._M_node) != (__y._M_node); } 
# 255
__detail::_List_node_base *_M_node; 
# 256
}; 
# 263
template< class _Tp> 
# 264
struct _List_const_iterator { 
# 266
typedef _List_const_iterator _Self; 
# 267
typedef const _List_node< _Tp>  _Node; 
# 268
typedef _List_iterator< _Tp>  iterator; 
# 270
typedef ptrdiff_t difference_type; 
# 271
typedef bidirectional_iterator_tag iterator_category; 
# 272
typedef _Tp value_type; 
# 273
typedef const _Tp *pointer; 
# 274
typedef const _Tp &reference; 
# 276
_List_const_iterator() noexcept : _M_node() 
# 277
{ } 
# 280
explicit _List_const_iterator(const __detail::_List_node_base *__x) noexcept : _M_node(__x) 
# 282
{ } 
# 284
_List_const_iterator(const iterator &__x) noexcept : _M_node(((__x._M_node))) 
# 285
{ } 
# 288
iterator _M_const_cast() const noexcept 
# 289
{ return ((_List_iterator< _Tp> )(const_cast< __detail::_List_node_base *>(_M_node))); } 
# 293
reference operator*() const noexcept 
# 294
{ return *(static_cast< _Node *>(_M_node))->_M_valptr(); } 
# 297
pointer operator->() const noexcept 
# 298
{ return (static_cast< _Node *>(_M_node))->_M_valptr(); } 
# 301
_Self &operator++() noexcept 
# 302
{ 
# 303
(_M_node) = ((_M_node)->_M_next); 
# 304
return *this; 
# 305
} 
# 308
_Self operator++(int) noexcept 
# 309
{ 
# 310
_Self __tmp = *this; 
# 311
(_M_node) = ((_M_node)->_M_next); 
# 312
return __tmp; 
# 313
} 
# 316
_Self &operator--() noexcept 
# 317
{ 
# 318
(_M_node) = ((_M_node)->_M_prev); 
# 319
return *this; 
# 320
} 
# 323
_Self operator--(int) noexcept 
# 324
{ 
# 325
_Self __tmp = *this; 
# 326
(_M_node) = ((_M_node)->_M_prev); 
# 327
return __tmp; 
# 328
} 
# 331
friend inline bool operator==(const typename _List_const_iterator< _Tp> ::_Self &__x, const typename _List_const_iterator< _Tp> ::_Self &__y) noexcept 
# 332
{ return (__x._M_node) == (__y._M_node); } 
# 335
friend inline bool operator!=(const typename _List_const_iterator< _Tp> ::_Self &__x, const typename _List_const_iterator< _Tp> ::_Self &__y) noexcept 
# 336
{ return (__x._M_node) != (__y._M_node); } 
# 339
const __detail::_List_node_base *_M_node; 
# 340
}; 
# 342
inline namespace __cxx11 { 
# 344
template< class _Tp, class _Alloc> 
# 345
class _List_base { 
# 349
protected: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other _Tp_alloc_type; 
# 350
typedef __gnu_cxx::__alloc_traits< _Tp_alloc_type>  _Tp_alloc_traits; 
# 352
typedef typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::template rebind< _List_node< _Tp> > ::other _Node_alloc_type; 
# 353
typedef __gnu_cxx::__alloc_traits< _Node_alloc_type>  _Node_alloc_traits; 
# 357
static size_t _S_distance(const __detail::_List_node_base *__first, const __detail::_List_node_base *
# 358
__last) 
# 359
{ 
# 360
size_t __n = (0); 
# 361
while (__first != __last) 
# 362
{ 
# 363
__first = (__first->_M_next); 
# 364
++__n; 
# 365
}  
# 366
return __n; 
# 367
} 
# 370
struct _List_impl : public _Node_alloc_type { 
# 373
__detail::_List_node_header _M_node; 
# 375
_List_impl() noexcept(is_nothrow_default_constructible< typename _List_base< _Tp, _Alloc> ::_Node_alloc_type> ::value) : _List_base< _Tp, _Alloc> ::_Node_alloc_type() 
# 378
{ } 
# 380
_List_impl(const typename _List_base< _Tp, _Alloc> ::_Node_alloc_type &__a) noexcept : _List_base< _Tp, _Alloc> ::_Node_alloc_type(__a) 
# 382
{ } 
# 385
_List_impl(_List_impl &&) = default;
# 387
_List_impl(typename _List_base< _Tp, _Alloc> ::_Node_alloc_type &&__a, _List_impl &&__x) : _List_base< _Tp, _Alloc> ::_Node_alloc_type(std::move(__a)), _M_node(std::move(__x._M_node)) 
# 389
{ } 
# 391
_List_impl(typename _List_base< _Tp, _Alloc> ::_Node_alloc_type &&__a) noexcept : _List_base< _Tp, _Alloc> ::_Node_alloc_type(std::move(__a)) 
# 393
{ } 
# 395
}; 
# 397
_List_impl _M_impl; 
# 400
size_t _M_get_size() const { return ((_M_impl)._M_node)._M_size; } 
# 402
void _M_set_size(size_t __n) { (((_M_impl)._M_node)._M_size) = __n; } 
# 404
void _M_inc_size(size_t __n) { (((_M_impl)._M_node)._M_size) += __n; } 
# 406
void _M_dec_size(size_t __n) { (((_M_impl)._M_node)._M_size) -= __n; } 
# 410
size_t _M_distance(const __detail::_List_node_base *__first, const __detail::_List_node_base *
# 411
__last) const 
# 412
{ return (_S_distance)(__first, __last); } 
# 415
size_t _M_node_count() const { return _M_get_size(); } 
# 437 "/usr/include/c++/9/bits/stl_list.h" 3
typename __gnu_cxx::__alloc_traits< _Node_alloc_type> ::pointer _M_get_node() 
# 438
{ return _Node_alloc_traits::allocate(_M_impl, 1); } 
# 441
void _M_put_node(typename __gnu_cxx::__alloc_traits< _Node_alloc_type> ::pointer __p) noexcept 
# 442
{ _Node_alloc_traits::deallocate(_M_impl, __p, 1); } 
# 445
public: typedef _Alloc allocator_type; 
# 448
_Node_alloc_type &_M_get_Node_allocator() noexcept 
# 449
{ return _M_impl; } 
# 452
const _Node_alloc_type &_M_get_Node_allocator() const noexcept 
# 453
{ return _M_impl; } 
# 456
_List_base() = default;
# 461
_List_base(const _Node_alloc_type &__a) noexcept : _M_impl(__a) 
# 463
{ } 
# 466
_List_base(_List_base &&) = default;
# 469
_List_base(_List_base &&__x, _Node_alloc_type &&__a) : _M_impl(std::move(__a)) 
# 471
{ 
# 472
if (__x._M_get_Node_allocator() == _M_get_Node_allocator()) { 
# 473
_M_move_nodes(std::move(__x)); }  
# 475
} 
# 479
_List_base(_Node_alloc_type &&__a, _List_base &&__x) : _M_impl(std::move(__a), std::move(__x._M_impl)) 
# 481
{ } 
# 484
_List_base(_Node_alloc_type &&__a) : _M_impl(std::move(__a)) 
# 486
{ } 
# 489
void _M_move_nodes(_List_base &&__x) 
# 490
{ ((_M_impl)._M_node)._M_move_nodes(std::move(((__x._M_impl)._M_node))); } 
# 494
~_List_base() noexcept 
# 495
{ _M_clear(); } 
# 498
void _M_clear() noexcept; 
# 501
void _M_init() noexcept 
# 502
{ ((this->_M_impl)._M_node)._M_init(); } 
# 503
}; 
# 551 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _Tp, class _Alloc = allocator< _Tp> > 
# 552
class list : protected _List_base< _Tp, _Alloc>  { 
# 564 "/usr/include/c++/9/bits/stl_list.h" 3
static_assert((is_same< typename remove_cv< _Tp> ::type, _Tp> ::value), "std::list must have a non-const, non-volatile value_type");
# 572
typedef _List_base< _Tp, _Alloc>  _Base; 
# 573
typedef typename _List_base< _Tp, _Alloc> ::_Tp_alloc_type _Tp_alloc_type; 
# 574
typedef typename _List_base< _Tp, _Alloc> ::_Tp_alloc_traits _Tp_alloc_traits; 
# 575
typedef typename _List_base< _Tp, _Alloc> ::_Node_alloc_type _Node_alloc_type; 
# 576
typedef typename _List_base< _Tp, _Alloc> ::_Node_alloc_traits _Node_alloc_traits; 
# 579
public: typedef _Tp value_type; 
# 580
typedef typename _List_base< _Tp, _Alloc> ::_Tp_alloc_traits::pointer pointer; 
# 581
typedef typename _List_base< _Tp, _Alloc> ::_Tp_alloc_traits::const_pointer const_pointer; 
# 582
typedef typename _List_base< _Tp, _Alloc> ::_Tp_alloc_traits::reference reference; 
# 583
typedef typename _List_base< _Tp, _Alloc> ::_Tp_alloc_traits::const_reference const_reference; 
# 584
typedef _List_iterator< _Tp>  iterator; 
# 585
typedef _List_const_iterator< _Tp>  const_iterator; 
# 586
typedef std::reverse_iterator< const_iterator>  const_reverse_iterator; 
# 587
typedef std::reverse_iterator< iterator>  reverse_iterator; 
# 588
typedef std::size_t size_type; 
# 589
typedef std::ptrdiff_t difference_type; 
# 590
typedef _Alloc allocator_type; 
# 595
protected: typedef _List_node< _Tp>  _Node; 
# 597
using _List_base< _Tp, _Alloc> ::_M_impl;
# 598
using _List_base< _Tp, _Alloc> ::_M_put_node;
# 599
using _List_base< _Tp, _Alloc> ::_M_get_node;
# 600
using _List_base< _Tp, _Alloc> ::_M_get_Node_allocator;
# 626 "/usr/include/c++/9/bits/stl_list.h" 3
template< class ..._Args> _Node *
# 628
_M_create_node(_Args &&...__args) 
# 629
{ 
# 630
auto __p = this->_M_get_node(); 
# 631
auto &__alloc = _M_get_Node_allocator(); 
# 632
__allocated_ptr< _Node_alloc_type>  __guard{__alloc, __p}; 
# 633
_Node_alloc_traits::construct(__alloc, (__p->_M_valptr)(), std::forward< _Args> (__args)...); 
# 635
__guard = nullptr; 
# 636
return __p; 
# 637
} 
# 642
static std::size_t _S_distance(const_iterator __first, const_iterator __last) 
# 643
{ return std::distance(__first, __last); } 
# 647
std::size_t _M_node_count() const 
# 648
{ return this->_M_get_size(); } 
# 669 "/usr/include/c++/9/bits/stl_list.h" 3
public: list() = default;
# 679 "/usr/include/c++/9/bits/stl_list.h" 3
explicit list(const allocator_type &__a) noexcept : _Base((_Node_alloc_type)__a) 
# 680
{ } 
# 692 "/usr/include/c++/9/bits/stl_list.h" 3
explicit list(size_type __n, const allocator_type &__a = allocator_type()) : _Base((_Node_alloc_type)__a) 
# 694
{ _M_default_initialize(__n); } 
# 704 "/usr/include/c++/9/bits/stl_list.h" 3
list(size_type __n, const value_type &__value, const allocator_type &
# 705
__a = allocator_type()) : _Base((_Node_alloc_type)__a) 
# 707
{ _M_fill_initialize(__n, __value); } 
# 731 "/usr/include/c++/9/bits/stl_list.h" 3
list(const list &__x) : _Base(_Node_alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator())) 
# 734
{ _M_initialize_dispatch(__x.begin(), __x.end(), std::__false_type()); } 
# 744 "/usr/include/c++/9/bits/stl_list.h" 3
list(list &&) = default;
# 754 "/usr/include/c++/9/bits/stl_list.h" 3
list(initializer_list< value_type>  __l, const allocator_type &
# 755
__a = allocator_type()) : _Base((_Node_alloc_type)__a) 
# 757
{ _M_initialize_dispatch(__l.begin(), __l.end(), std::__false_type()); } 
# 759
list(const list &__x, const allocator_type &__a) : _Base((_Node_alloc_type)__a) 
# 761
{ _M_initialize_dispatch(__x.begin(), __x.end(), std::__false_type()); } 
# 764
private: list(list &&__x, const allocator_type &__a, std::true_type) noexcept : _Base((_Node_alloc_type)__a, std::move(__x)) 
# 766
{ } 
# 768
list(list &&__x, const allocator_type &__a, std::false_type) : _Base((_Node_alloc_type)__a) 
# 770
{ 
# 771
if (__x._M_get_Node_allocator() == this->_M_get_Node_allocator()) { 
# 772
this->_M_move_nodes(std::move(__x)); } else { 
# 774
insert(begin(), std::__make_move_if_noexcept_iterator(__x.begin()), std::__make_move_if_noexcept_iterator(__x.end())); }  
# 776
} 
# 779
public: list(list &&__x, const allocator_type &__a) noexcept(_Node_alloc_traits::_S_always_equal()) : list(std::move(__x), __a, typename _List_base< _Tp, _Alloc> ::_Node_alloc_traits::is_always_equal{}) 
# 783
{ } 
# 797 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _InputIterator, class 
# 798
 = std::_RequireInputIter< _InputIterator> > 
# 799
list(_InputIterator __first, _InputIterator __last, const allocator_type &
# 800
__a = allocator_type()) : _Base((_Node_alloc_type)__a) 
# 802
{ _M_initialize_dispatch(__first, __last, std::__false_type()); } 
# 823 "/usr/include/c++/9/bits/stl_list.h" 3
~list() = default;
# 835 "/usr/include/c++/9/bits/stl_list.h" 3
list &operator=(const list & __x); 
# 849 "/usr/include/c++/9/bits/stl_list.h" 3
list &operator=(list &&__x) noexcept(_Node_alloc_traits::_S_nothrow_move()) 
# 851
{ 
# 852
constexpr bool __move_storage = (_Node_alloc_traits::_S_propagate_on_move_assign() || _Node_alloc_traits::_S_always_equal()); 
# 855
_M_move_assign(std::move(__x), std::__bool_constant< __move_storage> ()); 
# 856
return *this; 
# 857
} 
# 867 "/usr/include/c++/9/bits/stl_list.h" 3
list &operator=(initializer_list< value_type>  __l) 
# 868
{ 
# 869
this->assign(__l.begin(), __l.end()); 
# 870
return *this; 
# 871
} 
# 885 "/usr/include/c++/9/bits/stl_list.h" 3
void assign(size_type __n, const value_type &__val) 
# 886
{ _M_fill_assign(__n, __val); } 
# 901 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _InputIterator, class 
# 902
 = std::_RequireInputIter< _InputIterator> > void 
# 904
assign(_InputIterator __first, _InputIterator __last) 
# 905
{ _M_assign_dispatch(__first, __last, std::__false_type()); } 
# 926 "/usr/include/c++/9/bits/stl_list.h" 3
void assign(initializer_list< value_type>  __l) 
# 927
{ this->_M_assign_dispatch(__l.begin(), __l.end(), std::__false_type()); } 
# 932
allocator_type get_allocator() const noexcept 
# 933
{ return (allocator_type)_Base::_M_get_Node_allocator(); } 
# 941
iterator begin() noexcept 
# 942
{ return ((_List_iterator< _Tp> )((((this->_M_impl)._M_node)._M_next))); } 
# 950
const_iterator begin() const noexcept 
# 951
{ return ((_List_const_iterator< _Tp> )((((this->_M_impl)._M_node)._M_next))); } 
# 959
iterator end() noexcept 
# 960
{ return ((_List_iterator< _Tp> )(&((this->_M_impl)._M_node))); } 
# 968
const_iterator end() const noexcept 
# 969
{ return ((_List_const_iterator< _Tp> )(&((this->_M_impl)._M_node))); } 
# 977
reverse_iterator rbegin() noexcept 
# 978
{ return ((std::reverse_iterator< iterator> )(end())); } 
# 986
const_reverse_iterator rbegin() const noexcept 
# 987
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 995
reverse_iterator rend() noexcept 
# 996
{ return ((std::reverse_iterator< iterator> )(begin())); } 
# 1004
const_reverse_iterator rend() const noexcept 
# 1005
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 1014
const_iterator cbegin() const noexcept 
# 1015
{ return ((_List_const_iterator< _Tp> )((((this->_M_impl)._M_node)._M_next))); } 
# 1023
const_iterator cend() const noexcept 
# 1024
{ return ((_List_const_iterator< _Tp> )(&((this->_M_impl)._M_node))); } 
# 1032
const_reverse_iterator crbegin() const noexcept 
# 1033
{ return ((std::reverse_iterator< const_iterator> )(end())); } 
# 1041
const_reverse_iterator crend() const noexcept 
# 1042
{ return ((std::reverse_iterator< const_iterator> )(begin())); } 
# 1051
bool empty() const noexcept 
# 1052
{ return (((this->_M_impl)._M_node)._M_next) == (&((this->_M_impl)._M_node)); } 
# 1056
size_type size() const noexcept 
# 1057
{ return _M_node_count(); } 
# 1061
size_type max_size() const noexcept 
# 1062
{ return _Node_alloc_traits::max_size(_M_get_Node_allocator()); } 
# 1075 "/usr/include/c++/9/bits/stl_list.h" 3
void resize(size_type __new_size); 
# 1088 "/usr/include/c++/9/bits/stl_list.h" 3
void resize(size_type __new_size, const value_type & __x); 
# 1110 "/usr/include/c++/9/bits/stl_list.h" 3
reference front() noexcept 
# 1111
{ return *begin(); } 
# 1118
const_reference front() const noexcept 
# 1119
{ return *begin(); } 
# 1126
reference back() noexcept 
# 1127
{ 
# 1128
iterator __tmp = end(); 
# 1129
--__tmp; 
# 1130
return *__tmp; 
# 1131
} 
# 1138
const_reference back() const noexcept 
# 1139
{ 
# 1140
const_iterator __tmp = end(); 
# 1141
--__tmp; 
# 1142
return *__tmp; 
# 1143
} 
# 1157 "/usr/include/c++/9/bits/stl_list.h" 3
void push_front(const value_type &__x) 
# 1158
{ this->_M_insert(begin(), __x); } 
# 1162
void push_front(value_type &&__x) 
# 1163
{ this->_M_insert(begin(), std::move(__x)); } 
# 1165
template< class ..._Args> void 
# 1171
emplace_front(_Args &&...__args) 
# 1172
{ 
# 1173
this->_M_insert(begin(), std::forward< _Args> (__args)...); 
# 1177
} 
# 1193 "/usr/include/c++/9/bits/stl_list.h" 3
void pop_front() noexcept 
# 1194
{ _M_erase(begin()); } 
# 1207 "/usr/include/c++/9/bits/stl_list.h" 3
void push_back(const value_type &__x) 
# 1208
{ this->_M_insert(end(), __x); } 
# 1212
void push_back(value_type &&__x) 
# 1213
{ this->_M_insert(end(), std::move(__x)); } 
# 1215
template< class ..._Args> void 
# 1221
emplace_back(_Args &&...__args) 
# 1222
{ 
# 1223
this->_M_insert(end(), std::forward< _Args> (__args)...); 
# 1227
} 
# 1242 "/usr/include/c++/9/bits/stl_list.h" 3
void pop_back() noexcept 
# 1243
{ _M_erase(((((_List_iterator< _Tp> )((((this->_M_impl)._M_node)._M_prev)))))); } 
# 1258 "/usr/include/c++/9/bits/stl_list.h" 3
template< class ..._Args> iterator emplace(const_iterator __position, _Args && ...__args); 
# 1274 "/usr/include/c++/9/bits/stl_list.h" 3
iterator insert(const_iterator __position, const value_type & __x); 
# 1304 "/usr/include/c++/9/bits/stl_list.h" 3
iterator insert(const_iterator __position, value_type &&__x) 
# 1305
{ return emplace(__position, std::move(__x)); } 
# 1323 "/usr/include/c++/9/bits/stl_list.h" 3
iterator insert(const_iterator __p, initializer_list< value_type>  __l) 
# 1324
{ return this->insert(__p, __l.begin(), __l.end()); } 
# 1343 "/usr/include/c++/9/bits/stl_list.h" 3
iterator insert(const_iterator __position, size_type __n, const value_type & __x); 
# 1381 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _InputIterator, class 
# 1382
 = std::_RequireInputIter< _InputIterator> > iterator 
# 1381
insert(const_iterator __position, _InputIterator __first, _InputIterator __last); 
# 1427 "/usr/include/c++/9/bits/stl_list.h" 3
iterator erase(const_iterator __position) noexcept; 
# 1452 "/usr/include/c++/9/bits/stl_list.h" 3
iterator erase(const_iterator __first, const_iterator __last) noexcept 
# 1456
{ 
# 1457
while (__first != __last) { 
# 1458
__first = erase(__first); }  
# 1459
return __last._M_const_cast(); 
# 1460
} 
# 1474 "/usr/include/c++/9/bits/stl_list.h" 3
void swap(list &__x) noexcept 
# 1475
{ 
# 1476
__detail::_List_node_base::swap(((this->_M_impl)._M_node), ((__x._M_impl)._M_node)); 
# 1479
std::size_t __xsize = __x._M_get_size(); 
# 1480
__x._M_set_size(this->_M_get_size()); 
# 1481
this->_M_set_size(__xsize); 
# 1483
_Node_alloc_traits::_S_on_swap(this->_M_get_Node_allocator(), __x._M_get_Node_allocator()); 
# 1485
} 
# 1494
void clear() noexcept 
# 1495
{ 
# 1496
_Base::_M_clear(); 
# 1497
_Base::_M_init(); 
# 1498
} 
# 1514 "/usr/include/c++/9/bits/stl_list.h" 3
void splice(const_iterator __position, list &&__x) noexcept 
# 1518
{ 
# 1519
if (!__x.empty()) 
# 1520
{ 
# 1521
_M_check_equal_allocators(__x); 
# 1523
_M_transfer(__position._M_const_cast(), __x.begin(), __x.end()); 
# 1526
this->_M_inc_size(__x._M_get_size()); 
# 1527
__x._M_set_size(0); 
# 1528
}  
# 1529
} 
# 1533
void splice(const_iterator __position, list &__x) noexcept 
# 1534
{ splice(__position, std::move(__x)); } 
# 1549 "/usr/include/c++/9/bits/stl_list.h" 3
void splice(const_iterator __position, list &&__x, const_iterator __i) noexcept 
# 1563 "/usr/include/c++/9/bits/stl_list.h" 3
{ 
# 1564
iterator __j = __i._M_const_cast(); 
# 1565
++__j; 
# 1566
if ((__position == __i) || (__position == __j)) { 
# 1567
return; }  
# 1569
if (this != std::__addressof(__x)) { 
# 1570
_M_check_equal_allocators(__x); }  
# 1572
_M_transfer(__position._M_const_cast(), __i._M_const_cast(), __j); 
# 1575
this->_M_inc_size(1); 
# 1576
__x._M_dec_size(1); 
# 1577
} 
# 1591 "/usr/include/c++/9/bits/stl_list.h" 3
void splice(const_iterator __position, list &__x, const_iterator __i) noexcept 
# 1592
{ splice(__position, std::move(__x), __i); } 
# 1610 "/usr/include/c++/9/bits/stl_list.h" 3
void splice(const_iterator __position, list &&__x, const_iterator __first, const_iterator 
# 1611
__last) noexcept 
# 1629 "/usr/include/c++/9/bits/stl_list.h" 3
{ 
# 1630
if (__first != __last) 
# 1631
{ 
# 1632
if (this != std::__addressof(__x)) { 
# 1633
_M_check_equal_allocators(__x); }  
# 1635
std::size_t __n = (_S_distance)(__first, __last); 
# 1636
this->_M_inc_size(__n); 
# 1637
__x._M_dec_size(__n); 
# 1639
_M_transfer(__position._M_const_cast(), __first._M_const_cast(), __last._M_const_cast()); 
# 1642
}  
# 1643
} 
# 1660 "/usr/include/c++/9/bits/stl_list.h" 3
void splice(const_iterator __position, list &__x, const_iterator __first, const_iterator 
# 1661
__last) noexcept 
# 1662
{ splice(__position, std::move(__x), __first, __last); } 
# 1672
private: typedef void __remove_return_type; 
# 1690 "/usr/include/c++/9/bits/stl_list.h" 3
public: __remove_return_type remove(const _Tp & __value); 
# 1703 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _Predicate> __remove_return_type remove_if(_Predicate); 
# 1719 "/usr/include/c++/9/bits/stl_list.h" 3
__remove_return_type unique(); 
# 1733 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _BinaryPredicate> __remove_return_type unique(_BinaryPredicate); 
# 1750 "/usr/include/c++/9/bits/stl_list.h" 3
void merge(list && __x); 
# 1753
void merge(list &__x) 
# 1754
{ merge(std::move(__x)); } 
# 1774 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _StrictWeakOrdering> void merge(list && __x, _StrictWeakOrdering __comp); 
# 1778
template< class _StrictWeakOrdering> void 
# 1780
merge(list &__x, _StrictWeakOrdering __comp) 
# 1781
{ merge(std::move(__x), __comp); } 
# 1794 "/usr/include/c++/9/bits/stl_list.h" 3
void reverse() noexcept 
# 1795
{ ((this->_M_impl)._M_node)._M_reverse(); } 
# 1804
void sort(); 
# 1812
template< class _StrictWeakOrdering> void sort(_StrictWeakOrdering); 
# 1825
protected: 
# 1823
template< class _Integer> void 
# 1825
_M_initialize_dispatch(_Integer __n, _Integer __x, std::__true_type) 
# 1826
{ _M_fill_initialize(static_cast< size_type>(__n), __x); } 
# 1829
template< class _InputIterator> void 
# 1831
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type) 
# 1833
{ 
# 1834
for (; __first != __last; ++__first) { 
# 1836
emplace_back(*__first); }  
# 1840
} 
# 1845
void _M_fill_initialize(size_type __n, const value_type &__x) 
# 1846
{ 
# 1847
for (; __n; --__n) { 
# 1848
push_back(__x); }  
# 1849
} 
# 1854
void _M_default_initialize(size_type __n) 
# 1855
{ 
# 1856
for (; __n; --__n) { 
# 1857
emplace_back(); }  
# 1858
} 
# 1862
void _M_default_append(size_type __n); 
# 1871 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _Integer> void 
# 1873
_M_assign_dispatch(_Integer __n, _Integer __val, std::__true_type) 
# 1874
{ _M_fill_assign(__n, __val); } 
# 1877
template< class _InputIterator> void _M_assign_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type); 
# 1885
void _M_fill_assign(size_type __n, const value_type & __val); 
# 1890
void _M_transfer(iterator __position, iterator __first, iterator __last) 
# 1891
{ (__position._M_node)->_M_transfer((__first._M_node), (__last._M_node)); } 
# 1903 "/usr/include/c++/9/bits/stl_list.h" 3
template< class ..._Args> void 
# 1905
_M_insert(iterator __position, _Args &&...__args) 
# 1906
{ 
# 1907
_Node *__tmp = _M_create_node(std::forward< _Args> (__args)...); 
# 1908
__tmp->_M_hook((__position._M_node)); 
# 1909
this->_M_inc_size(1); 
# 1910
} 
# 1915
void _M_erase(iterator __position) noexcept 
# 1916
{ 
# 1917
this->_M_dec_size(1); 
# 1918
(__position._M_node)->_M_unhook(); 
# 1919
_Node *__n = static_cast< _Node *>(__position._M_node); 
# 1921
_Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr()); 
# 1926
_M_put_node(__n); 
# 1927
} 
# 1931
void _M_check_equal_allocators(list &__x) noexcept 
# 1932
{ 
# 1933
if (std::template __alloc_neq< typename _List_base< _Tp, _Alloc> ::_Node_alloc_type> ::_S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator())) { 
# 1935
__builtin_abort(); }  
# 1936
} 
# 1940
const_iterator _M_resize_pos(size_type & __new_size) const; 
# 1944
void _M_move_assign(list &&__x, std::true_type) noexcept 
# 1945
{ 
# 1946
this->_M_clear(); 
# 1947
this->_M_move_nodes(std::move(__x)); 
# 1948
std::__alloc_on_move(this->_M_get_Node_allocator(), __x._M_get_Node_allocator()); 
# 1950
} 
# 1953
void _M_move_assign(list &&__x, std::false_type) 
# 1954
{ 
# 1955
if (__x._M_get_Node_allocator() == this->_M_get_Node_allocator()) { 
# 1956
_M_move_assign(std::move(__x), std::true_type{}); } else { 
# 1960
_M_assign_dispatch(std::__make_move_if_noexcept_iterator(__x.begin()), std::__make_move_if_noexcept_iterator(__x.end()), std::__false_type{}); }  
# 1963
} 
# 1965
}; 
# 1977 "/usr/include/c++/9/bits/stl_list.h" 3
}
# 1989 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _Tp, class _Alloc> inline bool 
# 1991
operator==(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 1992
{ 
# 1994
if (__x.size() != __y.size()) { 
# 1995
return false; }  
# 1998
typedef typename __cxx11::list< _Tp, _Alloc> ::const_iterator const_iterator; 
# 1999
const_iterator __end1 = __x.end(); 
# 2000
const_iterator __end2 = __y.end(); 
# 2002
const_iterator __i1 = __x.begin(); 
# 2003
const_iterator __i2 = __y.begin(); 
# 2004
while ((__i1 != __end1) && (__i2 != __end2) && ((*__i1) == (*__i2))) 
# 2005
{ 
# 2006
++__i1; 
# 2007
++__i2; 
# 2008
}  
# 2009
return (__i1 == __end1) && (__i2 == __end2); 
# 2010
} 
# 2023 "/usr/include/c++/9/bits/stl_list.h" 3
template< class _Tp, class _Alloc> inline bool 
# 2025
operator<(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 2026
{ return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end()); 
# 2027
} 
# 2030
template< class _Tp, class _Alloc> inline bool 
# 2032
operator!=(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 2033
{ return !(__x == __y); } 
# 2036
template< class _Tp, class _Alloc> inline bool 
# 2038
operator>(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 2039
{ return __y < __x; } 
# 2042
template< class _Tp, class _Alloc> inline bool 
# 2044
operator<=(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 2045
{ return !(__y < __x); } 
# 2048
template< class _Tp, class _Alloc> inline bool 
# 2050
operator>=(const __cxx11::list< _Tp, _Alloc>  &__x, const __cxx11::list< _Tp, _Alloc>  &__y) 
# 2051
{ return !(__x < __y); } 
# 2054
template< class _Tp, class _Alloc> inline void 
# 2056
swap(__cxx11::list< _Tp, _Alloc>  &__x, __cxx11::list< _Tp, _Alloc>  &__y) noexcept(noexcept(__x.swap(__y))) 
# 2058
{ __x.swap(__y); } 
# 2065
template< class _Tp> inline ptrdiff_t 
# 2067
__distance(_List_iterator< _Tp>  __first, _List_iterator< _Tp>  
# 2068
__last, input_iterator_tag 
# 2069
__tag) 
# 2070
{ 
# 2071
typedef _List_const_iterator< _Tp>  _CIter; 
# 2072
return std::__distance(((_List_const_iterator< _Tp> )(__first)), ((_List_const_iterator< _Tp> )(__last)), __tag); 
# 2073
} 
# 2075
template< class _Tp> inline ptrdiff_t 
# 2077
__distance(_List_const_iterator< _Tp>  __first, _List_const_iterator< _Tp>  
# 2078
__last, input_iterator_tag) 
# 2080
{ 
# 2081
typedef __detail::_List_node_header _Sentinel; 
# 2082
_List_const_iterator< _Tp>  __beyond = __last; 
# 2083
++__beyond; 
# 2084
const bool __whole = __first == __beyond; 
# 2085
if ((0) && __whole) { 
# 2086
return (static_cast< const _Sentinel *>(__last._M_node))->_M_size; }  
# 2088
ptrdiff_t __n = (0); 
# 2089
while (__first != __last) 
# 2090
{ 
# 2091
++__first; 
# 2092
++__n; 
# 2093
}  
# 2094
return __n; 
# 2095
} 
# 2099
}
# 59 "/usr/include/c++/9/bits/list.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 64
template< class _Tp, class _Alloc> void 
# 67
__cxx11::_List_base< _Tp, _Alloc> ::_M_clear() noexcept 
# 68
{ 
# 69
typedef _List_node< _Tp>  _Node; 
# 70
__detail::_List_node_base *__cur = ((((_M_impl)._M_node)._M_next)); 
# 71
while (__cur != (&((_M_impl)._M_node))) 
# 72
{ 
# 73
_Node *__tmp = static_cast< _Node *>(__cur); 
# 74
__cur = (__tmp->_M_next); 
# 75
_Tp *__val = __tmp->_M_valptr(); 
# 77
_Node_alloc_traits::destroy(_M_get_Node_allocator(), __val); 
# 81
_M_put_node(__tmp); 
# 82
}  
# 83
} 
# 86
template< class _Tp, class _Alloc> 
# 87
template< class ..._Args> typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 90
__cxx11::list< _Tp, _Alloc> ::emplace(const_iterator __position, _Args &&...__args) 
# 91
{ 
# 92
_Node *__tmp = _M_create_node(std::forward< _Args> (__args)...); 
# 93
__tmp->_M_hook((__position._M_const_cast()._M_node)); 
# 94
this->_M_inc_size(1); 
# 95
return ((_List_iterator< _Tp> )(__tmp)); 
# 96
} 
# 99
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 103
__cxx11::list< _Tp, _Alloc> ::insert(const_iterator __position, const value_type &__x) 
# 107
{ 
# 108
_Node *__tmp = _M_create_node(__x); 
# 109
__tmp->_M_hook((__position._M_const_cast()._M_node)); 
# 110
this->_M_inc_size(1); 
# 111
return ((_List_iterator< _Tp> )(__tmp)); 
# 112
} 
# 115
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 118
__cxx11::list< _Tp, _Alloc> ::insert(const_iterator __position, size_type __n, const value_type &__x) 
# 119
{ 
# 120
if (__n) 
# 121
{ 
# 122
list __tmp(__n, __x, get_allocator()); 
# 123
iterator __it = __tmp.begin(); 
# 124
splice(__position, __tmp); 
# 125
return __it; 
# 126
}  
# 127
return __position._M_const_cast(); 
# 128
} 
# 130
template< class _Tp, class _Alloc> 
# 131
template< class _InputIterator, class > typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 134
__cxx11::list< _Tp, _Alloc> ::insert(const_iterator __position, _InputIterator __first, _InputIterator 
# 135
__last) 
# 136
{ 
# 137
list __tmp(__first, __last, get_allocator()); 
# 138
if (!__tmp.empty()) 
# 139
{ 
# 140
iterator __it = __tmp.begin(); 
# 141
splice(__position, __tmp); 
# 142
return __it; 
# 143
}  
# 144
return __position._M_const_cast(); 
# 145
} 
# 148
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::iterator 
# 152
__cxx11::list< _Tp, _Alloc> ::erase(const_iterator __position) noexcept 
# 156
{ 
# 157
iterator __ret = ((((_List_iterator< _Tp> )(((__position._M_node)->_M_next))))); 
# 158
_M_erase(__position._M_const_cast()); 
# 159
return __ret; 
# 160
} 
# 173 "/usr/include/c++/9/bits/list.tcc" 3
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::const_iterator 
# 176
__cxx11::list< _Tp, _Alloc> ::_M_resize_pos(size_type &__new_size) const 
# 177
{ 
# 178
const_iterator __i; 
# 180
const size_type __len = size(); 
# 181
if (__new_size < __len) 
# 182
{ 
# 183
if (__new_size <= (__len / (2))) 
# 184
{ 
# 185
__i = begin(); 
# 186
std::advance(__i, __new_size); 
# 187
} else 
# 189
{ 
# 190
__i = end(); 
# 191
std::ptrdiff_t __num_erase = __len - __new_size; 
# 192
std::advance(__i, -__num_erase); 
# 193
}  
# 194
__new_size = (0); 
# 195
return __i; 
# 196
} else { 
# 198
__i = end(); }  
# 204
__new_size -= __len; 
# 205
return __i; 
# 206
} 
# 209
template< class _Tp, class _Alloc> void 
# 212
__cxx11::list< _Tp, _Alloc> ::_M_default_append(size_type __n) 
# 213
{ 
# 214
size_type __i = (0); 
# 215
try 
# 216
{ 
# 217
for (; __i < __n; ++__i) { 
# 218
emplace_back(); }  
# 219
} 
# 220
catch (...) 
# 221
{ 
# 222
for (; __i; --__i) { 
# 223
pop_back(); }  
# 224
throw; 
# 225
}  
# 226
} 
# 228
template< class _Tp, class _Alloc> void 
# 231
__cxx11::list< _Tp, _Alloc> ::resize(size_type __new_size) 
# 232
{ 
# 233
const_iterator __i = _M_resize_pos(__new_size); 
# 234
if (__new_size) { 
# 235
_M_default_append(__new_size); } else { 
# 237
erase(__i, end()); }  
# 238
} 
# 240
template< class _Tp, class _Alloc> void 
# 243
__cxx11::list< _Tp, _Alloc> ::resize(size_type __new_size, const value_type &__x) 
# 244
{ 
# 245
const_iterator __i = _M_resize_pos(__new_size); 
# 246
if (__new_size) { 
# 247
insert(end(), __new_size, __x); } else { 
# 249
erase(__i, end()); }  
# 250
} 
# 265 "/usr/include/c++/9/bits/list.tcc" 3
template< class _Tp, class _Alloc> __cxx11::list< _Tp, _Alloc>  &
# 268
__cxx11::list< _Tp, _Alloc> ::operator=(const list &__x) 
# 269
{ 
# 270
if (this != std::__addressof(__x)) 
# 271
{ 
# 273
if (_Node_alloc_traits::_S_propagate_on_copy_assign()) 
# 274
{ 
# 275
auto &__this_alloc = this->_M_get_Node_allocator(); 
# 276
auto &__that_alloc = __x._M_get_Node_allocator(); 
# 277
if ((!_Node_alloc_traits::_S_always_equal()) && (__this_alloc != __that_alloc)) 
# 279
{ 
# 281
clear(); 
# 282
}  
# 283
std::__alloc_on_copy(__this_alloc, __that_alloc); 
# 284
}  
# 286
_M_assign_dispatch(__x.begin(), __x.end(), std::__false_type()); 
# 287
}  
# 288
return *this; 
# 289
} 
# 291
template< class _Tp, class _Alloc> void 
# 294
__cxx11::list< _Tp, _Alloc> ::_M_fill_assign(size_type __n, const value_type &__val) 
# 295
{ 
# 296
iterator __i = begin(); 
# 297
for (; (__i != end()) && (__n > (0)); (++__i), (--__n)) { 
# 298
(*__i) = __val; }  
# 299
if (__n > (0)) { 
# 300
insert(end(), __n, __val); } else { 
# 302
erase(__i, end()); }  
# 303
} 
# 305
template< class _Tp, class _Alloc> 
# 306
template< class _InputIterator> void 
# 309
__cxx11::list< _Tp, _Alloc> ::_M_assign_dispatch(_InputIterator __first2, _InputIterator __last2, std::__false_type) 
# 311
{ 
# 312
iterator __first1 = begin(); 
# 313
iterator __last1 = end(); 
# 314
for (; (__first1 != __last1) && (__first2 != __last2); (++__first1), ((void)(++__first2))) { 
# 316
(*__first1) = (*__first2); }  
# 317
if (__first2 == __last2) { 
# 318
erase(__first1, __last1); } else { 
# 320
insert(__last1, __first2, __last2); }  
# 321
} 
# 329
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::__remove_return_type 
# 332
__cxx11::list< _Tp, _Alloc> ::remove(const value_type &__value) 
# 333
{ 
# 334
size_type __removed __attribute((__unused__)) = (0); 
# 335
iterator __first = begin(); 
# 336
iterator __last = end(); 
# 337
iterator __extra = __last; 
# 338
while (__first != __last) 
# 339
{ 
# 340
iterator __next = __first; 
# 341
++__next; 
# 342
if ((*__first) == __value) 
# 343
{ 
# 347
if (std::__addressof(*__first) != std::__addressof(__value)) 
# 348
{ 
# 349
_M_erase(__first); 
# 350
; 
# 351
} else { 
# 353
__extra = __first; }  
# 354
}  
# 355
__first = __next; 
# 356
}  
# 357
if (__extra != __last) 
# 358
{ 
# 359
_M_erase(__extra); 
# 360
; 
# 361
}  
# 363
} 
# 365
template< class _Tp, class _Alloc> typename __cxx11::list< _Tp, _Alloc> ::__remove_return_type 
# 368
__cxx11::list< _Tp, _Alloc> ::unique() 
# 369
{ 
# 370
iterator __first = begin(); 
# 371
iterator __last = end(); 
# 372
if (__first == __last) { 
# 373
return; }  
# 374
size_type __removed __attribute((__unused__)) = (0); 
# 375
iterator __next = __first; 
# 376
while ((++__next) != __last) 
# 377
{ 
# 378
if ((*__first) == (*__next)) 
# 379
{ 
# 380
_M_erase(__next); 
# 381
; 
# 382
} else { 
# 384
__first = __next; }  
# 385
__next = __first; 
# 386
}  
# 388
} 
# 390
template< class _Tp, class _Alloc> void 
# 394
__cxx11::list< _Tp, _Alloc> ::merge(list &&__x) 
# 398
{ 
# 401
if (this != std::__addressof(__x)) 
# 402
{ 
# 403
_M_check_equal_allocators(__x); 
# 405
iterator __first1 = begin(); 
# 406
iterator __last1 = end(); 
# 407
iterator __first2 = __x.begin(); 
# 408
iterator __last2 = __x.end(); 
# 409
const std::size_t __orig_size = __x.size(); 
# 410
try { 
# 411
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 412
if ((*__first2) < (*__first1)) 
# 413
{ 
# 414
iterator __next = __first2; 
# 415
_M_transfer(__first1, __first2, ++__next); 
# 416
__first2 = __next; 
# 417
} else { 
# 419
++__first1; }  }  
# 420
if (__first2 != __last2) { 
# 421
_M_transfer(__last1, __first2, __last2); }  
# 423
this->_M_inc_size(__x._M_get_size()); 
# 424
__x._M_set_size(0); 
# 425
} 
# 426
catch (...) 
# 427
{ 
# 428
const std::size_t __dist = std::distance(__first2, __last2); 
# 429
this->_M_inc_size(__orig_size - __dist); 
# 430
__x._M_set_size(__dist); 
# 431
throw; 
# 432
}  
# 433
}  
# 434
} 
# 436
template< class _Tp, class _Alloc> 
# 437
template< class _StrictWeakOrdering> void 
# 441
__cxx11::list< _Tp, _Alloc> ::merge(list &&__x, _StrictWeakOrdering __comp) 
# 445
{ 
# 448
if (this != std::__addressof(__x)) 
# 449
{ 
# 450
_M_check_equal_allocators(__x); 
# 452
iterator __first1 = begin(); 
# 453
iterator __last1 = end(); 
# 454
iterator __first2 = __x.begin(); 
# 455
iterator __last2 = __x.end(); 
# 456
const std::size_t __orig_size = __x.size(); 
# 457
try 
# 458
{ 
# 459
while ((__first1 != __last1) && (__first2 != __last2)) { 
# 460
if (__comp(*__first2, *__first1)) 
# 461
{ 
# 462
iterator __next = __first2; 
# 463
_M_transfer(__first1, __first2, ++__next); 
# 464
__first2 = __next; 
# 465
} else { 
# 467
++__first1; }  }  
# 468
if (__first2 != __last2) { 
# 469
_M_transfer(__last1, __first2, __last2); }  
# 471
this->_M_inc_size(__x._M_get_size()); 
# 472
__x._M_set_size(0); 
# 473
} 
# 474
catch (...) 
# 475
{ 
# 476
const std::size_t __dist = std::distance(__first2, __last2); 
# 477
this->_M_inc_size(__orig_size - __dist); 
# 478
__x._M_set_size(__dist); 
# 479
throw; 
# 480
}  
# 481
}  
# 482
} 
# 484
template< class _Tp, class _Alloc> void 
# 487
__cxx11::list< _Tp, _Alloc> ::sort() 
# 488
{ 
# 490
if (((((this->_M_impl)._M_node)._M_next) != (&((this->_M_impl)._M_node))) && (((((this->_M_impl)._M_node)._M_next)->_M_next) != (&((this->_M_impl)._M_node)))) 
# 492
{ 
# 493
list __carry; 
# 494
list __tmp[64]; 
# 495
list *__fill = __tmp; 
# 496
list *__counter; 
# 497
try 
# 498
{ 
# 499
do 
# 500
{ 
# 501
__carry.splice(__carry.begin(), *this, begin()); 
# 503
for (__counter = __tmp; (__counter != __fill) && (!__counter->empty()); ++__counter) 
# 506
{ 
# 507
__counter->merge(__carry); 
# 508
__carry.swap(*__counter); 
# 509
}  
# 510
__carry.swap(*__counter); 
# 511
if (__counter == __fill) { 
# 512
++__fill; }  
# 513
} 
# 514
while (!empty()); 
# 516
for (__counter = (__tmp + 1); __counter != __fill; ++__counter) { 
# 517
__counter->merge(*(__counter - 1)); }  
# 518
swap(*(__fill - 1)); 
# 519
} 
# 520
catch (...) 
# 521
{ 
# 522
this->splice(end(), __carry); 
# 523
for (int __i = 0; __i < (sizeof(__tmp) / sizeof((__tmp[0]))); ++__i) { 
# 524
this->splice(end(), __tmp[__i]); }  
# 525
throw; 
# 526
}  
# 527
}  
# 528
} 
# 530
template< class _Tp, class _Alloc> 
# 531
template< class _Predicate> typename __cxx11::list< _Tp, _Alloc> ::__remove_return_type 
# 534
__cxx11::list< _Tp, _Alloc> ::remove_if(_Predicate __pred) 
# 535
{ 
# 536
size_type __removed __attribute((__unused__)) = (0); 
# 537
iterator __first = begin(); 
# 538
iterator __last = end(); 
# 539
while (__first != __last) 
# 540
{ 
# 541
iterator __next = __first; 
# 542
++__next; 
# 543
if (__pred(*__first)) 
# 544
{ 
# 545
_M_erase(__first); 
# 546
; 
# 547
}  
# 548
__first = __next; 
# 549
}  
# 551
} 
# 553
template< class _Tp, class _Alloc> 
# 554
template< class _BinaryPredicate> typename __cxx11::list< _Tp, _Alloc> ::__remove_return_type 
# 557
__cxx11::list< _Tp, _Alloc> ::unique(_BinaryPredicate __binary_pred) 
# 558
{ 
# 559
iterator __first = begin(); 
# 560
iterator __last = end(); 
# 561
if (__first == __last) { 
# 562
return; }  
# 563
size_type __removed __attribute((__unused__)) = (0); 
# 564
iterator __next = __first; 
# 565
while ((++__next) != __last) 
# 566
{ 
# 567
if (__binary_pred(*__first, *__next)) 
# 568
{ 
# 569
_M_erase(__next); 
# 570
; 
# 571
} else { 
# 573
__first = __next; }  
# 574
__next = __first; 
# 575
}  
# 577
} 
# 581
template< class _Tp, class _Alloc> 
# 582
template< class _StrictWeakOrdering> void 
# 585
__cxx11::list< _Tp, _Alloc> ::sort(_StrictWeakOrdering __comp) 
# 586
{ 
# 588
if (((((this->_M_impl)._M_node)._M_next) != (&((this->_M_impl)._M_node))) && (((((this->_M_impl)._M_node)._M_next)->_M_next) != (&((this->_M_impl)._M_node)))) 
# 590
{ 
# 591
list __carry; 
# 592
list __tmp[64]; 
# 593
list *__fill = __tmp; 
# 594
list *__counter; 
# 595
try 
# 596
{ 
# 597
do 
# 598
{ 
# 599
__carry.splice(__carry.begin(), *this, begin()); 
# 601
for (__counter = __tmp; (__counter != __fill) && (!__counter->empty()); ++__counter) 
# 604
{ 
# 605
__counter->merge(__carry, __comp); 
# 606
__carry.swap(*__counter); 
# 607
}  
# 608
__carry.swap(*__counter); 
# 609
if (__counter == __fill) { 
# 610
++__fill; }  
# 611
} 
# 612
while (!empty()); 
# 614
for (__counter = (__tmp + 1); __counter != __fill; ++__counter) { 
# 615
__counter->merge(*(__counter - 1), __comp); }  
# 616
swap(*(__fill - 1)); 
# 617
} 
# 618
catch (...) 
# 619
{ 
# 620
this->splice(end(), __carry); 
# 621
for (int __i = 0; __i < (sizeof(__tmp) / sizeof((__tmp[0]))); ++__i) { 
# 622
this->splice(end(), __tmp[__i]); }  
# 623
throw; 
# 624
}  
# 625
}  
# 626
} 
# 630
}
# 49 "/usr/include/opencv4/opencv2/stitching/detail/util.hpp" 3
namespace cv { 
# 50
namespace detail { 
# 55
class DisjointSets { 
# 58
public: DisjointSets(int elem_count = 0) { this->createOneElemSets(elem_count); } 
# 60
void createOneElemSets(int elem_count); 
# 61
int findSetByElem(int elem); 
# 62
int mergeSets(int set1, int set2); 
# 64
std::vector< int>  parent; 
# 65
std::vector< int>  size; 
# 68
private: std::vector< int>  rank_; 
# 69
}; 
# 72
struct GraphEdge { 
# 74
inline GraphEdge(int from, int to, float weight); 
# 75
bool operator<(const GraphEdge &other) const { return (weight) < (other.weight); } 
# 76
bool operator>(const GraphEdge &other) const { return (weight) > (other.weight); } 
# 78
int from, to; 
# 79
float weight; 
# 80
}; 
# 82
inline GraphEdge::GraphEdge(int _from, int _to, float _weight) : from(_from), to(_to), weight(_weight) { } 
# 85
class Graph { 
# 88
public: Graph(int num_vertices = 0) { this->create(num_vertices); } 
# 89
void create(int num_vertices) { (edges_).assign(num_vertices, std::__cxx11::list< GraphEdge> ()); } 
# 90
int numVertices() const { return static_cast< int>((edges_).size()); } 
# 91
void addEdge(int from, int to, float weight); 
# 92
template< class B> B forEach(B body) const; 
# 93
template< class B> B walkBreadthFirst(int from, B body) const; 
# 96
private: std::vector< std::__cxx11::list< GraphEdge> >  edges_; 
# 97
}; 
# 103
bool overlapRoi(Point tl1, Point tl2, Size sz1, Size sz2, Rect & roi); 
# 104
Rect resultRoi(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images); 
# 105
Rect resultRoi(const std::vector< Point_< int> >  & corners, const std::vector< Size_< int> >  & sizes); 
# 106
Rect resultRoiIntersection(const std::vector< Point_< int> >  & corners, const std::vector< Size_< int> >  & sizes); 
# 107
Point resultTl(const std::vector< Point_< int> >  & corners); 
# 110
void selectRandomSubset(int count, int size, std::vector< int>  & subset); 
# 112
int &stitchingLogLevel(); 
# 116
}
# 117
}
# 69 "/usr/include/c++/9/bits/stl_deque.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 93 "/usr/include/c++/9/bits/stl_deque.h" 3
constexpr size_t __deque_buf_size(size_t __size) 
# 94
{ return ((__size < (512)) ? (size_t)((512) / __size) : ((size_t)1)); 
# 95
} 
# 109 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Tp, class _Ref, class _Ptr> 
# 110
struct _Deque_iterator { 
# 120
private: 
# 119
template< class _Up> using __ptr_to = typename pointer_traits< _Ptr> ::template rebind< _Up> ; 
# 121
template< class _CvTp> using __iter = _Deque_iterator< _Tp, _CvTp &, __ptr_to< _CvTp> > ; 
# 124
public: typedef __iter< _Tp>  iterator; 
# 125
typedef __iter< const _Tp>  const_iterator; 
# 126
typedef __ptr_to< _Tp>  _Elt_pointer; 
# 127
typedef __ptr_to< _Elt_pointer>  _Map_pointer; 
# 130
static size_t _S_buffer_size() noexcept 
# 131
{ return __deque_buf_size(sizeof(_Tp)); } 
# 133
typedef random_access_iterator_tag iterator_category; 
# 134
typedef _Tp value_type; 
# 135
typedef _Ptr pointer; 
# 136
typedef _Ref reference; 
# 137
typedef size_t size_type; 
# 138
typedef ptrdiff_t difference_type; 
# 139
typedef _Deque_iterator _Self; 
# 141
_Elt_pointer _M_cur; 
# 142
_Elt_pointer _M_first; 
# 143
_Elt_pointer _M_last; 
# 144
_Map_pointer _M_node; 
# 146
_Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept : _M_cur(__x), _M_first(*__y), _M_last((*__y) + (_S_buffer_size)()), _M_node(__y) 
# 148
{ } 
# 150
_Deque_iterator() noexcept : _M_cur(), _M_first(), _M_last(), _M_node() 
# 151
{ } 
# 160 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Iter, class 
# 161
 = _Require< is_same< _Self, const_iterator> , is_same< _Iter, iterator> > > 
# 163
_Deque_iterator(const _Iter &__x) noexcept : _M_cur((__x._M_cur)), _M_first((__x._M_first)), _M_last((__x._M_last)), _M_node((__x._M_node)) 
# 165
{ } 
# 167
_Deque_iterator(const _Deque_iterator &__x) noexcept : _M_cur(__x._M_cur), _M_first(__x._M_first), _M_last(__x._M_last), _M_node(__x._M_node) 
# 169
{ } 
# 171
_Deque_iterator &operator=(const _Deque_iterator &) = default;
# 175
iterator _M_const_cast() const noexcept 
# 176
{ return iterator(_M_cur, _M_node); } 
# 179
reference operator*() const noexcept 
# 180
{ return *(_M_cur); } 
# 183
pointer operator->() const noexcept 
# 184
{ return _M_cur; } 
# 187
_Self &operator++() noexcept 
# 188
{ 
# 189
++(_M_cur); 
# 190
if ((_M_cur) == (_M_last)) 
# 191
{ 
# 192
_M_set_node((_M_node) + 1); 
# 193
(_M_cur) = (_M_first); 
# 194
}  
# 195
return *this; 
# 196
} 
# 199
_Self operator++(int) noexcept 
# 200
{ 
# 201
_Self __tmp = *this; 
# 202
++(*this); 
# 203
return __tmp; 
# 204
} 
# 207
_Self &operator--() noexcept 
# 208
{ 
# 209
if ((_M_cur) == (_M_first)) 
# 210
{ 
# 211
_M_set_node((_M_node) - 1); 
# 212
(_M_cur) = (_M_last); 
# 213
}  
# 214
--(_M_cur); 
# 215
return *this; 
# 216
} 
# 219
_Self operator--(int) noexcept 
# 220
{ 
# 221
_Self __tmp = *this; 
# 222
--(*this); 
# 223
return __tmp; 
# 224
} 
# 227
_Self &operator+=(difference_type __n) noexcept 
# 228
{ 
# 229
const difference_type __offset = __n + ((_M_cur) - (_M_first)); 
# 230
if ((__offset >= (0)) && (__offset < ((difference_type)(_S_buffer_size)()))) { 
# 231
(_M_cur) += __n; } else 
# 233
{ 
# 234
const difference_type __node_offset = ((__offset > (0)) ? __offset / ((difference_type)(_S_buffer_size)()) : ((-((difference_type)(((-__offset) - (1)) / (_S_buffer_size)()))) - (1))); 
# 238
_M_set_node((_M_node) + __node_offset); 
# 239
(_M_cur) = ((_M_first) + (__offset - (__node_offset * ((difference_type)(_S_buffer_size)())))); 
# 241
}  
# 242
return *this; 
# 243
} 
# 246
_Self operator+(difference_type __n) const noexcept 
# 247
{ 
# 248
_Self __tmp = *this; 
# 249
return __tmp += __n; 
# 250
} 
# 253
_Self &operator-=(difference_type __n) noexcept 
# 254
{ return (*this) += (-__n); } 
# 257
_Self operator-(difference_type __n) const noexcept 
# 258
{ 
# 259
_Self __tmp = *this; 
# 260
return __tmp -= __n; 
# 261
} 
# 264
reference operator[](difference_type __n) const noexcept 
# 265
{ return *((*this) + __n); } 
# 273
void _M_set_node(_Map_pointer __new_node) noexcept 
# 274
{ 
# 275
(_M_node) = __new_node; 
# 276
(_M_first) = (*__new_node); 
# 277
(_M_last) = ((_M_first) + ((difference_type)(_S_buffer_size)())); 
# 278
} 
# 279
}; 
# 284
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 286
operator==(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 287
__y) noexcept 
# 288
{ return (__x._M_cur) == (__y._M_cur); } 
# 290
template< class _Tp, class _RefL, class _PtrL, class 
# 291
_RefR, class _PtrR> inline bool 
# 293
operator==(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 294
__y) noexcept 
# 295
{ return (__x._M_cur) == (__y._M_cur); } 
# 297
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 299
operator!=(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 300
__y) noexcept 
# 301
{ return !(__x == __y); } 
# 303
template< class _Tp, class _RefL, class _PtrL, class 
# 304
_RefR, class _PtrR> inline bool 
# 306
operator!=(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 307
__y) noexcept 
# 308
{ return !(__x == __y); } 
# 310
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 312
operator<(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 313
__y) noexcept 
# 314
{ return ((__x._M_node) == (__y._M_node)) ? (__x._M_cur) < (__y._M_cur) : ((__x._M_node) < (__y._M_node)); 
# 315
} 
# 317
template< class _Tp, class _RefL, class _PtrL, class 
# 318
_RefR, class _PtrR> inline bool 
# 320
operator<(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 321
__y) noexcept 
# 322
{ return ((__x._M_node) == (__y._M_node)) ? (__x._M_cur) < (__y._M_cur) : ((__x._M_node) < (__y._M_node)); 
# 323
} 
# 325
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 327
operator>(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 328
__y) noexcept 
# 329
{ return __y < __x; } 
# 331
template< class _Tp, class _RefL, class _PtrL, class 
# 332
_RefR, class _PtrR> inline bool 
# 334
operator>(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 335
__y) noexcept 
# 336
{ return __y < __x; } 
# 338
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 340
operator<=(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 341
__y) noexcept 
# 342
{ return !(__y < __x); } 
# 344
template< class _Tp, class _RefL, class _PtrL, class 
# 345
_RefR, class _PtrR> inline bool 
# 347
operator<=(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 348
__y) noexcept 
# 349
{ return !(__y < __x); } 
# 351
template< class _Tp, class _Ref, class _Ptr> inline bool 
# 353
operator>=(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 354
__y) noexcept 
# 355
{ return !(__x < __y); } 
# 357
template< class _Tp, class _RefL, class _PtrL, class 
# 358
_RefR, class _PtrR> inline bool 
# 360
operator>=(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 361
__y) noexcept 
# 362
{ return !(__x < __y); } 
# 368
template< class _Tp, class _Ref, class _Ptr> inline typename _Deque_iterator< _Tp, _Ref, _Ptr> ::difference_type 
# 370
operator-(const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x, const _Deque_iterator< _Tp, _Ref, _Ptr>  &
# 371
__y) noexcept 
# 372
{ 
# 373
return ((((typename _Deque_iterator< _Tp, _Ref, _Ptr> ::difference_type)_Deque_iterator< _Tp, _Ref, _Ptr> ::_S_buffer_size()) * (((__x._M_node) - (__y._M_node)) - 1)) + ((__x._M_cur) - (__x._M_first))) + ((__y._M_last) - (__y._M_cur)); 
# 377
} 
# 379
template< class _Tp, class _RefL, class _PtrL, class 
# 380
_RefR, class _PtrR> inline typename _Deque_iterator< _Tp, _RefL, _PtrL> ::difference_type 
# 382
operator-(const _Deque_iterator< _Tp, _RefL, _PtrL>  &__x, const _Deque_iterator< _Tp, _RefR, _PtrR>  &
# 383
__y) noexcept 
# 384
{ 
# 385
return ((((typename _Deque_iterator< _Tp, _RefL, _PtrL> ::difference_type)_Deque_iterator< _Tp, _RefL, _PtrL> ::_S_buffer_size()) * (((__x._M_node) - (__y._M_node)) - 1)) + ((__x._M_cur) - (__x._M_first))) + ((__y._M_last) - (__y._M_cur)); 
# 389
} 
# 391
template< class _Tp, class _Ref, class _Ptr> inline _Deque_iterator< _Tp, _Ref, _Ptr>  
# 393
operator+(ptrdiff_t __n, const _Deque_iterator< _Tp, _Ref, _Ptr>  &__x) noexcept 
# 395
{ return __x + __n; } 
# 397
template< class _Tp> void fill(const _Deque_iterator< _Tp, _Tp &, _Tp *>  &, const _Deque_iterator< _Tp, _Tp &, _Tp *>  &, const _Tp &); 
# 402
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  copy(_Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, _Tp &, _Tp *> ); 
# 408
template< class _Tp> inline _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 410
copy(_Deque_iterator< _Tp, _Tp &, _Tp *>  __first, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 411
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 412
__result) 
# 413
{ return std::copy(((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__first)), ((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__last)), __result); 
# 415
} 
# 417
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  copy_backward(_Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, _Tp &, _Tp *> ); 
# 423
template< class _Tp> inline _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 425
copy_backward(_Deque_iterator< _Tp, _Tp &, _Tp *>  __first, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 426
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 427
__result) 
# 428
{ return std::copy_backward(((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__first)), ((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__last)), __result); 
# 432
} 
# 435
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  move(_Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, _Tp &, _Tp *> ); 
# 441
template< class _Tp> inline _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 443
move(_Deque_iterator< _Tp, _Tp &, _Tp *>  __first, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 444
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 445
__result) 
# 446
{ return std::move(((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__first)), ((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__last)), __result); 
# 448
} 
# 450
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  move_backward(_Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, const _Tp &, const _Tp *> , _Deque_iterator< _Tp, _Tp &, _Tp *> ); 
# 456
template< class _Tp> inline _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 458
move_backward(_Deque_iterator< _Tp, _Tp &, _Tp *>  __first, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 459
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 460
__result) 
# 461
{ return std::move_backward(((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__first)), ((_Deque_iterator< _Tp, const _Tp &, const _Tp *> )(__last)), __result); 
# 465
} 
# 478 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Tp, class _Alloc> 
# 479
class _Deque_base { 
# 483
protected: typedef typename __gnu_cxx::__alloc_traits< _Alloc> ::template rebind< _Tp> ::other _Tp_alloc_type; 
# 484
typedef __gnu_cxx::__alloc_traits< _Tp_alloc_type>  _Alloc_traits; 
# 490
typedef typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::pointer _Ptr; 
# 491
typedef typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::const_pointer _Ptr_const; 
# 495
typedef typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::template rebind< _Ptr> ::other _Map_alloc_type; 
# 496
typedef __gnu_cxx::__alloc_traits< _Map_alloc_type>  _Map_alloc_traits; 
# 499
public: typedef _Alloc allocator_type; 
# 502
allocator_type get_allocator() const noexcept 
# 503
{ return (allocator_type)_M_get_Tp_allocator(); } 
# 505
typedef _Deque_iterator< _Tp, _Tp &, _Ptr>  iterator; 
# 506
typedef _Deque_iterator< _Tp, const _Tp &, _Ptr_const>  const_iterator; 
# 508
_Deque_base() : _M_impl() 
# 510
{ _M_initialize_map(0); } 
# 512
_Deque_base(size_t __num_elements) : _M_impl() 
# 514
{ _M_initialize_map(__num_elements); } 
# 516
_Deque_base(const allocator_type &__a, size_t __num_elements) : _M_impl(__a) 
# 518
{ _M_initialize_map(__num_elements); } 
# 520
_Deque_base(const allocator_type &__a) : _M_impl(__a) 
# 522
{ } 
# 525
_Deque_base(_Deque_base &&__x, false_type) : _M_impl(__x._M_move_impl()) 
# 527
{ } 
# 529
_Deque_base(_Deque_base &&__x, true_type) : _M_impl(std::move(__x._M_get_Tp_allocator())) 
# 531
{ 
# 532
_M_initialize_map(0); 
# 533
if ((__x._M_impl)._M_map) { 
# 534
(this->_M_impl)._M_swap_data(__x._M_impl); }  
# 535
} 
# 537
_Deque_base(_Deque_base &&__x) : _Deque_base(std::move(__x), typename __gnu_cxx::__alloc_traits< _Tp_alloc_type> ::is_always_equal{}) 
# 539
{ } 
# 541
_Deque_base(_Deque_base &&__x, const allocator_type &__a, size_t __n) : _M_impl(__a) 
# 543
{ 
# 544
if (__x.get_allocator() == __a) 
# 545
{ 
# 546
if ((__x._M_impl)._M_map) 
# 547
{ 
# 548
_M_initialize_map(0); 
# 549
(this->_M_impl)._M_swap_data(__x._M_impl); 
# 550
}  
# 551
} else 
# 553
{ 
# 554
_M_initialize_map(__n); 
# 555
}  
# 556
} 
# 559
~_Deque_base() noexcept; 
# 562
protected: typedef typename _Deque_iterator< _Tp, _Tp &, _Ptr> ::_Map_pointer _Map_pointer; 
# 567
struct _Deque_impl : public _Tp_alloc_type { 
# 570
typename _Deque_base< _Tp, _Alloc> ::_Map_pointer _M_map; 
# 571
std::size_t _M_map_size; 
# 572
typename _Deque_base< _Tp, _Alloc> ::iterator _M_start; 
# 573
typename _Deque_base< _Tp, _Alloc> ::iterator _M_finish; 
# 575
_Deque_impl() : _Deque_base< _Tp, _Alloc> ::_Tp_alloc_type(), _M_map(), _M_map_size((0)), _M_start(), _M_finish() 
# 578
{ } 
# 580
_Deque_impl(const typename _Deque_base< _Tp, _Alloc> ::_Tp_alloc_type &__a) noexcept : _Deque_base< _Tp, _Alloc> ::_Tp_alloc_type(__a), _M_map(), _M_map_size((0)), _M_start(), _M_finish() 
# 583
{ } 
# 586
_Deque_impl(_Deque_impl &&) = default;
# 588
_Deque_impl(typename _Deque_base< _Tp, _Alloc> ::_Tp_alloc_type &&__a) noexcept : _Deque_base< _Tp, _Alloc> ::_Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size((0)), _M_start(), _M_finish() 
# 591
{ } 
# 594
void _M_swap_data(_Deque_impl &__x) noexcept 
# 595
{ 
# 596
using std::swap;
# 597
swap(this->_M_start, __x._M_start); 
# 598
swap(this->_M_finish, __x._M_finish); 
# 599
swap(this->_M_map, __x._M_map); 
# 600
swap(this->_M_map_size, __x._M_map_size); 
# 601
} 
# 602
}; 
# 605
_Tp_alloc_type &_M_get_Tp_allocator() noexcept 
# 606
{ return *(static_cast< _Tp_alloc_type *>(&(this->_M_impl))); } 
# 609
const _Tp_alloc_type &_M_get_Tp_allocator() const noexcept 
# 610
{ return *(static_cast< const _Tp_alloc_type *>(&(this->_M_impl))); } 
# 613
_Map_alloc_type _M_get_map_allocator() const noexcept 
# 614
{ return (_Map_alloc_type)_M_get_Tp_allocator(); } 
# 617
_Ptr _M_allocate_node() 
# 618
{ 
# 619
typedef __gnu_cxx::__alloc_traits< _Tp_alloc_type>  _Traits; 
# 620
return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp))); 
# 621
} 
# 624
void _M_deallocate_node(_Ptr __p) noexcept 
# 625
{ 
# 626
typedef __gnu_cxx::__alloc_traits< _Tp_alloc_type>  _Traits; 
# 627
_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp))); 
# 628
} 
# 631
_Map_pointer _M_allocate_map(size_t __n) 
# 632
{ 
# 633
_Map_alloc_type __map_alloc = _M_get_map_allocator(); 
# 634
return _Map_alloc_traits::allocate(__map_alloc, __n); 
# 635
} 
# 638
void _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept 
# 639
{ 
# 640
_Map_alloc_type __map_alloc = _M_get_map_allocator(); 
# 641
_Map_alloc_traits::deallocate(__map_alloc, __p, __n); 
# 642
} 
# 645
void _M_initialize_map(size_t); 
# 646
void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish); 
# 647
void _M_destroy_nodes(_Map_pointer __nstart, _Map_pointer __nfinish) noexcept; 
# 649
enum { _S_initial_map_size = 8}; 
# 651
_Deque_impl _M_impl; 
# 656
private: _Deque_impl _M_move_impl() 
# 657
{ 
# 658
if (!((_M_impl)._M_map)) { 
# 659
return std::move(_M_impl); }  
# 662
_Tp_alloc_type __alloc{_M_get_Tp_allocator()}; 
# 664
_Tp_alloc_type __sink __attribute((__unused__)){std::move(__alloc)}; 
# 666
_Deque_base __empty{__alloc}; 
# 667
__empty._M_initialize_map(0); 
# 669
_Deque_impl __ret{std::move(_M_get_Tp_allocator())}; 
# 670
(_M_impl)._M_swap_data(__ret); 
# 671
(_M_impl)._M_swap_data(__empty._M_impl); 
# 672
return __ret; 
# 673
} 
# 675
}; 
# 677
template< class _Tp, class _Alloc> 
# 679
_Deque_base< _Tp, _Alloc> ::~_Deque_base() noexcept 
# 680
{ 
# 681
if ((this->_M_impl)._M_map) 
# 682
{ 
# 683
_M_destroy_nodes((((this->_M_impl)._M_start)._M_node), (((this->_M_impl)._M_finish)._M_node) + 1); 
# 685
_M_deallocate_map(((this->_M_impl)._M_map), ((this->_M_impl)._M_map_size)); 
# 686
}  
# 687
} 
# 697 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Tp, class _Alloc> void 
# 700
_Deque_base< _Tp, _Alloc> ::_M_initialize_map(size_t __num_elements) 
# 701
{ 
# 702
const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))) + (1); 
# 705
((this->_M_impl)._M_map_size) = std::max((size_t)_S_initial_map_size, (size_t)(__num_nodes + (2))); 
# 707
((this->_M_impl)._M_map) = _M_allocate_map(((this->_M_impl)._M_map_size)); 
# 714
_Map_pointer __nstart = ((this->_M_impl)._M_map) + ((((this->_M_impl)._M_map_size) - __num_nodes) / 2); 
# 716
_Map_pointer __nfinish = __nstart + __num_nodes; 
# 718
try 
# 719
{ _M_create_nodes(__nstart, __nfinish); } 
# 720
catch (...) 
# 721
{ 
# 722
_M_deallocate_map(((this->_M_impl)._M_map), ((this->_M_impl)._M_map_size)); 
# 723
((this->_M_impl)._M_map) = _Map_pointer(); 
# 724
((this->_M_impl)._M_map_size) = 0; 
# 725
throw; 
# 726
}  
# 728
((this->_M_impl)._M_start)._M_set_node(__nstart); 
# 729
((this->_M_impl)._M_finish)._M_set_node(__nfinish - 1); 
# 730
(((this->_M_impl)._M_start)._M_cur) = (((_M_impl)._M_start)._M_first); 
# 731
(((this->_M_impl)._M_finish)._M_cur) = ((((this->_M_impl)._M_finish)._M_first) + (__num_elements % __deque_buf_size(sizeof(_Tp)))); 
# 734
} 
# 736
template< class _Tp, class _Alloc> void 
# 739
_Deque_base< _Tp, _Alloc> ::_M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish) 
# 740
{ 
# 741
_Map_pointer __cur; 
# 742
try 
# 743
{ 
# 744
for (__cur = __nstart; __cur < __nfinish; ++__cur) { 
# 745
(*__cur) = _M_allocate_node(); }  
# 746
} 
# 747
catch (...) 
# 748
{ 
# 749
_M_destroy_nodes(__nstart, __cur); 
# 750
throw; 
# 751
}  
# 752
} 
# 754
template< class _Tp, class _Alloc> void 
# 757
_Deque_base< _Tp, _Alloc> ::_M_destroy_nodes(_Map_pointer __nstart, _Map_pointer 
# 758
__nfinish) noexcept 
# 759
{ 
# 760
for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n) { 
# 761
_M_deallocate_node(*__n); }  
# 762
} 
# 848 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Tp, class _Alloc = allocator< _Tp> > 
# 849
class deque : protected _Deque_base< _Tp, _Alloc>  { 
# 861 "/usr/include/c++/9/bits/stl_deque.h" 3
static_assert((is_same< typename remove_cv< _Tp> ::type, _Tp> ::value), "std::deque must have a non-const, non-volatile value_type");
# 869
typedef _Deque_base< _Tp, _Alloc>  _Base; 
# 870
typedef typename _Deque_base< _Tp, _Alloc> ::_Tp_alloc_type _Tp_alloc_type; 
# 871
typedef typename _Deque_base< _Tp, _Alloc> ::_Alloc_traits _Alloc_traits; 
# 872
typedef typename _Deque_base< _Tp, _Alloc> ::_Map_pointer _Map_pointer; 
# 875
public: typedef _Tp value_type; 
# 876
typedef typename _Deque_base< _Tp, _Alloc> ::_Alloc_traits::pointer pointer; 
# 877
typedef typename _Deque_base< _Tp, _Alloc> ::_Alloc_traits::const_pointer const_pointer; 
# 878
typedef typename _Deque_base< _Tp, _Alloc> ::_Alloc_traits::reference reference; 
# 879
typedef typename _Deque_base< _Tp, _Alloc> ::_Alloc_traits::const_reference const_reference; 
# 880
typedef typename _Deque_base< _Tp, _Alloc> ::iterator iterator; 
# 881
typedef typename _Deque_base< _Tp, _Alloc> ::const_iterator const_iterator; 
# 882
typedef std::reverse_iterator< const_iterator>  const_reverse_iterator; 
# 883
typedef std::reverse_iterator< iterator>  reverse_iterator; 
# 884
typedef std::size_t size_type; 
# 885
typedef std::ptrdiff_t difference_type; 
# 886
typedef _Alloc allocator_type; 
# 889
protected: static std::size_t _S_buffer_size() noexcept 
# 890
{ return __deque_buf_size(sizeof(_Tp)); } 
# 893
using _Deque_base< _Tp, _Alloc> ::_M_initialize_map;
# 894
using _Deque_base< _Tp, _Alloc> ::_M_create_nodes;
# 895
using _Deque_base< _Tp, _Alloc> ::_M_destroy_nodes;
# 896
using _Deque_base< _Tp, _Alloc> ::_M_allocate_node;
# 897
using _Deque_base< _Tp, _Alloc> ::_M_deallocate_node;
# 898
using _Deque_base< _Tp, _Alloc> ::_M_allocate_map;
# 899
using _Deque_base< _Tp, _Alloc> ::_M_deallocate_map;
# 900
using _Deque_base< _Tp, _Alloc> ::_M_get_Tp_allocator;
# 906
using _Deque_base< _Tp, _Alloc> ::_M_impl;
# 915
public: deque() : _Base() { } 
# 922
explicit deque(const allocator_type &__a) : _Base(__a, 0) 
# 923
{ } 
# 935 "/usr/include/c++/9/bits/stl_deque.h" 3
explicit deque(size_type __n, const allocator_type &__a = allocator_type()) : _Base(__a, (_S_check_init_len)(__n, __a)) 
# 937
{ _M_default_initialize(); } 
# 947 "/usr/include/c++/9/bits/stl_deque.h" 3
deque(size_type __n, const value_type &__value, const allocator_type &
# 948
__a = allocator_type()) : _Base(__a, (_S_check_init_len)(__n, __a)) 
# 950
{ _M_fill_initialize(__value); } 
# 974 "/usr/include/c++/9/bits/stl_deque.h" 3
deque(const deque &__x) : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()), __x.size()) 
# 977
{ std::__uninitialized_copy_a(__x.begin(), __x.end(), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 979
} 
# 989 "/usr/include/c++/9/bits/stl_deque.h" 3
deque(deque &&__x) : _Base(std::move(__x)) 
# 990
{ } 
# 993
deque(const deque &__x, const allocator_type &__a) : _Base(__a, __x.size()) 
# 995
{ std::__uninitialized_copy_a(__x.begin(), __x.end(), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 997
} 
# 1000
deque(deque &&__x, const allocator_type &__a) : _Base(std::move(__x), __a, __x.size()) 
# 1002
{ 
# 1003
if (__x.get_allocator() != __a) 
# 1004
{ 
# 1005
std::__uninitialized_move_a(__x.begin(), __x.end(), ((this->_M_impl)._M_start), _M_get_Tp_allocator()); 
# 1008
__x.clear(); 
# 1009
}  
# 1010
} 
# 1023 "/usr/include/c++/9/bits/stl_deque.h" 3
deque(initializer_list< value_type>  __l, const allocator_type &
# 1024
__a = allocator_type()) : _Base(__a) 
# 1026
{ 
# 1027
_M_range_initialize(__l.begin(), __l.end(), std::random_access_iterator_tag()); 
# 1029
} 
# 1048 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _InputIterator, class 
# 1049
 = std::_RequireInputIter< _InputIterator> > 
# 1050
deque(_InputIterator __first, _InputIterator __last, const allocator_type &
# 1051
__a = allocator_type()) : _Base(__a) 
# 1053
{ _M_initialize_dispatch(__first, __last, std::__false_type()); } 
# 1071 "/usr/include/c++/9/bits/stl_deque.h" 3
~deque() 
# 1072
{ _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); } 
# 1084 "/usr/include/c++/9/bits/stl_deque.h" 3
deque &operator=(const deque & __x); 
# 1096 "/usr/include/c++/9/bits/stl_deque.h" 3
deque &operator=(deque &&__x) noexcept(_Alloc_traits::_S_always_equal()) 
# 1097
{ 
# 1098
using __always_equal = typename _Deque_base< _Tp, _Alloc> ::_Alloc_traits::is_always_equal; 
# 1099
_M_move_assign1(std::move(__x), __always_equal{}); 
# 1100
return *this; 
# 1101
} 
# 1115 "/usr/include/c++/9/bits/stl_deque.h" 3
deque &operator=(initializer_list< value_type>  __l) 
# 1116
{ 
# 1117
_M_assign_aux(__l.begin(), __l.end(), std::random_access_iterator_tag()); 
# 1119
return *this; 
# 1120
} 
# 1134 "/usr/include/c++/9/bits/stl_deque.h" 3
void assign(size_type __n, const value_type &__val) 
# 1135
{ _M_fill_assign(__n, __val); } 
# 1150 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _InputIterator, class 
# 1151
 = std::_RequireInputIter< _InputIterator> > void 
# 1153
assign(_InputIterator __first, _InputIterator __last) 
# 1154
{ _M_assign_dispatch(__first, __last, std::__false_type()); } 
# 1178 "/usr/include/c++/9/bits/stl_deque.h" 3
void assign(initializer_list< value_type>  __l) 
# 1179
{ _M_assign_aux(__l.begin(), __l.end(), std::random_access_iterator_tag()); } 
# 1184
allocator_type get_allocator() const noexcept 
# 1185
{ return _Base::get_allocator(); } 
# 1193
iterator begin() noexcept 
# 1194
{ return (this->_M_impl)._M_start; } 
# 1201
const_iterator begin() const noexcept 
# 1202
{ return (this->_M_impl)._M_start; } 
# 1210
iterator end() noexcept 
# 1211
{ return (this->_M_impl)._M_finish; } 
# 1219
const_iterator end() const noexcept 
# 1220
{ return (this->_M_impl)._M_finish; } 
# 1228
reverse_iterator rbegin() noexcept 
# 1229
{ return ((std::reverse_iterator< iterator> )(((this->_M_impl)._M_finish))); } 
# 1237
const_reverse_iterator rbegin() const noexcept 
# 1238
{ return ((std::reverse_iterator< const_iterator> )(((this->_M_impl)._M_finish))); } 
# 1246
reverse_iterator rend() noexcept 
# 1247
{ return ((std::reverse_iterator< iterator> )(((this->_M_impl)._M_start))); } 
# 1255
const_reverse_iterator rend() const noexcept 
# 1256
{ return ((std::reverse_iterator< const_iterator> )(((this->_M_impl)._M_start))); } 
# 1264
const_iterator cbegin() const noexcept 
# 1265
{ return (this->_M_impl)._M_start; } 
# 1273
const_iterator cend() const noexcept 
# 1274
{ return (this->_M_impl)._M_finish; } 
# 1282
const_reverse_iterator crbegin() const noexcept 
# 1283
{ return ((std::reverse_iterator< const_iterator> )(((this->_M_impl)._M_finish))); } 
# 1291
const_reverse_iterator crend() const noexcept 
# 1292
{ return ((std::reverse_iterator< const_iterator> )(((this->_M_impl)._M_start))); } 
# 1298
size_type size() const noexcept 
# 1299
{ return ((this->_M_impl)._M_finish) - ((this->_M_impl)._M_start); } 
# 1303
size_type max_size() const noexcept 
# 1304
{ return (_S_max_size)(_M_get_Tp_allocator()); } 
# 1317 "/usr/include/c++/9/bits/stl_deque.h" 3
void resize(size_type __new_size) 
# 1318
{ 
# 1319
const size_type __len = size(); 
# 1320
if (__new_size > __len) { 
# 1321
_M_default_append(__new_size - __len); } else { 
# 1322
if (__new_size < __len) { 
# 1323
_M_erase_at_end(((this->_M_impl)._M_start) + ((difference_type)__new_size)); }  }  
# 1325
} 
# 1339 "/usr/include/c++/9/bits/stl_deque.h" 3
void resize(size_type __new_size, const value_type &__x) 
# 1340
{ 
# 1341
const size_type __len = size(); 
# 1342
if (__new_size > __len) { 
# 1343
_M_fill_insert(((this->_M_impl)._M_finish), __new_size - __len, __x); } else { 
# 1344
if (__new_size < __len) { 
# 1345
_M_erase_at_end(((this->_M_impl)._M_start) + ((difference_type)__new_size)); }  }  
# 1347
} 
# 1375 "/usr/include/c++/9/bits/stl_deque.h" 3
void shrink_to_fit() noexcept 
# 1376
{ _M_shrink_to_fit(); } 
# 1384
bool empty() const noexcept 
# 1385
{ return ((this->_M_impl)._M_finish) == ((this->_M_impl)._M_start); } 
# 1400 "/usr/include/c++/9/bits/stl_deque.h" 3
reference operator[](size_type __n) noexcept 
# 1401
{ 
# 1402
; 
# 1403
return ((this->_M_impl)._M_start)[(difference_type)__n]; 
# 1404
} 
# 1418 "/usr/include/c++/9/bits/stl_deque.h" 3
const_reference operator[](size_type __n) const noexcept 
# 1419
{ 
# 1420
; 
# 1421
return ((this->_M_impl)._M_start)[(difference_type)__n]; 
# 1422
} 
# 1427
protected: void _M_range_check(size_type __n) const 
# 1428
{ 
# 1429
if (__n >= size()) { 
# 1430
__throw_out_of_range_fmt("deque::_M_range_check: __n (which is %zu)>= this->size() (which is %zu)", __n, size()); }  
# 1434
} 
# 1449 "/usr/include/c++/9/bits/stl_deque.h" 3
public: reference at(size_type __n) 
# 1450
{ 
# 1451
_M_range_check(__n); 
# 1452
return (*this)[__n]; 
# 1453
} 
# 1467 "/usr/include/c++/9/bits/stl_deque.h" 3
const_reference at(size_type __n) const 
# 1468
{ 
# 1469
_M_range_check(__n); 
# 1470
return (*this)[__n]; 
# 1471
} 
# 1478
reference front() noexcept 
# 1479
{ 
# 1480
; 
# 1481
return *begin(); 
# 1482
} 
# 1489
const_reference front() const noexcept 
# 1490
{ 
# 1491
; 
# 1492
return *begin(); 
# 1493
} 
# 1500
reference back() noexcept 
# 1501
{ 
# 1502
; 
# 1503
iterator __tmp = end(); 
# 1504
--__tmp; 
# 1505
return *__tmp; 
# 1506
} 
# 1513
const_reference back() const noexcept 
# 1514
{ 
# 1515
; 
# 1516
const_iterator __tmp = end(); 
# 1517
--__tmp; 
# 1518
return *__tmp; 
# 1519
} 
# 1532 "/usr/include/c++/9/bits/stl_deque.h" 3
void push_front(const value_type &__x) 
# 1533
{ 
# 1534
if ((((this->_M_impl)._M_start)._M_cur) != (((this->_M_impl)._M_start)._M_first)) 
# 1535
{ 
# 1536
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_start)._M_cur) - 1, __x); 
# 1539
--(((this->_M_impl)._M_start)._M_cur); 
# 1540
} else { 
# 1542
_M_push_front_aux(__x); }  
# 1543
} 
# 1547
void push_front(value_type &&__x) 
# 1548
{ emplace_front(std::move(__x)); } 
# 1550
template< class ..._Args> void emplace_front(_Args && ...__args); 
# 1569 "/usr/include/c++/9/bits/stl_deque.h" 3
void push_back(const value_type &__x) 
# 1570
{ 
# 1571
if ((((this->_M_impl)._M_finish)._M_cur) != ((((this->_M_impl)._M_finish)._M_last) - 1)) 
# 1573
{ 
# 1574
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_finish)._M_cur), __x); 
# 1576
++(((this->_M_impl)._M_finish)._M_cur); 
# 1577
} else { 
# 1579
_M_push_back_aux(__x); }  
# 1580
} 
# 1584
void push_back(value_type &&__x) 
# 1585
{ emplace_back(std::move(__x)); } 
# 1587
template< class ..._Args> void emplace_back(_Args && ...__args); 
# 1605 "/usr/include/c++/9/bits/stl_deque.h" 3
void pop_front() noexcept 
# 1606
{ 
# 1607
; 
# 1608
if ((((this->_M_impl)._M_start)._M_cur) != ((((this->_M_impl)._M_start)._M_last) - 1)) 
# 1610
{ 
# 1611
_Alloc_traits::destroy((this->_M_impl), (((this->_M_impl)._M_start)._M_cur)); 
# 1613
++(((this->_M_impl)._M_start)._M_cur); 
# 1614
} else { 
# 1616
_M_pop_front_aux(); }  
# 1617
} 
# 1628 "/usr/include/c++/9/bits/stl_deque.h" 3
void pop_back() noexcept 
# 1629
{ 
# 1630
; 
# 1631
if ((((this->_M_impl)._M_finish)._M_cur) != (((this->_M_impl)._M_finish)._M_first)) 
# 1633
{ 
# 1634
--(((this->_M_impl)._M_finish)._M_cur); 
# 1635
_Alloc_traits::destroy((this->_M_impl), (((this->_M_impl)._M_finish)._M_cur)); 
# 1637
} else { 
# 1639
_M_pop_back_aux(); }  
# 1640
} 
# 1652 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class ..._Args> iterator emplace(const_iterator __position, _Args && ...__args); 
# 1666 "/usr/include/c++/9/bits/stl_deque.h" 3
iterator insert(const_iterator __position, const value_type & __x); 
# 1692 "/usr/include/c++/9/bits/stl_deque.h" 3
iterator insert(const_iterator __position, value_type &&__x) 
# 1693
{ return emplace(__position, std::move(__x)); } 
# 1705 "/usr/include/c++/9/bits/stl_deque.h" 3
iterator insert(const_iterator __p, initializer_list< value_type>  __l) 
# 1706
{ 
# 1707
auto __offset = __p - cbegin(); 
# 1708
_M_range_insert_aux(__p._M_const_cast(), __l.begin(), __l.end(), std::random_access_iterator_tag()); 
# 1710
return begin() + __offset; 
# 1711
} 
# 1726 "/usr/include/c++/9/bits/stl_deque.h" 3
iterator insert(const_iterator __position, size_type __n, const value_type &__x) 
# 1727
{ 
# 1728
difference_type __offset = __position - cbegin(); 
# 1729
_M_fill_insert(__position._M_const_cast(), __n, __x); 
# 1730
return begin() + __offset; 
# 1731
} 
# 1759 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _InputIterator, class 
# 1760
 = std::_RequireInputIter< _InputIterator> > iterator 
# 1762
insert(const_iterator __position, _InputIterator __first, _InputIterator 
# 1763
__last) 
# 1764
{ 
# 1765
difference_type __offset = __position - cbegin(); 
# 1766
_M_insert_dispatch(__position._M_const_cast(), __first, __last, std::__false_type()); 
# 1768
return begin() + __offset; 
# 1769
} 
# 1807 "/usr/include/c++/9/bits/stl_deque.h" 3
iterator erase(const_iterator __position) 
# 1811
{ return _M_erase(__position._M_const_cast()); } 
# 1831 "/usr/include/c++/9/bits/stl_deque.h" 3
iterator erase(const_iterator __first, const_iterator __last) 
# 1835
{ return _M_erase(__first._M_const_cast(), __last._M_const_cast()); } 
# 1849 "/usr/include/c++/9/bits/stl_deque.h" 3
void swap(deque &__x) noexcept 
# 1850
{ 
# 1853
; 
# 1855
(_M_impl._M_swap_data)((__x._M_impl)); 
# 1856
_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()); 
# 1858
} 
# 1867
void clear() noexcept 
# 1868
{ _M_erase_at_end(begin()); } 
# 1879
protected: 
# 1877
template< class _Integer> void 
# 1879
_M_initialize_dispatch(_Integer __n, _Integer __x, std::__true_type) 
# 1880
{ 
# 1881
_M_initialize_map((_S_check_init_len)(static_cast< size_type>(__n), _M_get_Tp_allocator())); 
# 1883
_M_fill_initialize(__x); 
# 1884
} 
# 1887
static std::size_t _S_check_init_len(std::size_t __n, const allocator_type &__a) 
# 1888
{ 
# 1889
if (__n > (_S_max_size)(__a)) { 
# 1890
__throw_length_error("cannot create std::deque larger than max_size()"); }  
# 1892
return __n; 
# 1893
} 
# 1896
static size_type _S_max_size(const _Tp_alloc_type &__a) noexcept 
# 1897
{ 
# 1898
const std::size_t __diffmax = (__gnu_cxx::__numeric_traits_integer< std::streamsize> ::__max); 
# 1899
const std::size_t __allocmax = _Alloc_traits::max_size(__a); 
# 1900
return (std::min)(__diffmax, __allocmax); 
# 1901
} 
# 1904
template< class _InputIterator> void 
# 1906
_M_initialize_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type) 
# 1908
{ 
# 1909
_M_range_initialize(__first, __last, std::__iterator_category(__first)); 
# 1911
} 
# 1925 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _InputIterator> void _M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag); 
# 1931
template< class _ForwardIterator> void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag); 
# 1948 "/usr/include/c++/9/bits/stl_deque.h" 3
void _M_fill_initialize(const value_type & __value); 
# 1953
void _M_default_initialize(); 
# 1963 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Integer> void 
# 1965
_M_assign_dispatch(_Integer __n, _Integer __val, std::__true_type) 
# 1966
{ _M_fill_assign(__n, __val); } 
# 1969
template< class _InputIterator> void 
# 1971
_M_assign_dispatch(_InputIterator __first, _InputIterator __last, std::__false_type) 
# 1973
{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); } 
# 1976
template< class _InputIterator> void _M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag); 
# 1982
template< class _ForwardIterator> void 
# 1984
_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) 
# 1986
{ 
# 1987
const size_type __len = std::distance(__first, __last); 
# 1988
if (__len > size()) 
# 1989
{ 
# 1990
_ForwardIterator __mid = __first; 
# 1991
std::advance(__mid, size()); 
# 1992
std::copy(__first, __mid, begin()); 
# 1993
_M_range_insert_aux(end(), __mid, __last, std::__iterator_category(__first)); 
# 1995
} else { 
# 1997
_M_erase_at_end(std::copy(__first, __last, begin())); }  
# 1998
} 
# 2003
void _M_fill_assign(size_type __n, const value_type &__val) 
# 2004
{ 
# 2005
if (__n > size()) 
# 2006
{ 
# 2007
std::fill(begin(), end(), __val); 
# 2008
_M_fill_insert(end(), __n - size(), __val); 
# 2009
} else 
# 2011
{ 
# 2012
_M_erase_at_end(begin() + ((difference_type)__n)); 
# 2013
std::fill(begin(), end(), __val); 
# 2014
}  
# 2015
} 
# 2024 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class ..._Args> void _M_push_back_aux(_Args && ...__args); 
# 2027
template< class ..._Args> void _M_push_front_aux(_Args && ...__args); 
# 2031
void _M_pop_back_aux(); 
# 2033
void _M_pop_front_aux(); 
# 2043 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Integer> void 
# 2045
_M_insert_dispatch(iterator __pos, _Integer 
# 2046
__n, _Integer __x, std::__true_type) 
# 2047
{ _M_fill_insert(__pos, __n, __x); } 
# 2050
template< class _InputIterator> void 
# 2052
_M_insert_dispatch(iterator __pos, _InputIterator 
# 2053
__first, _InputIterator __last, std::__false_type) 
# 2055
{ 
# 2056
_M_range_insert_aux(__pos, __first, __last, std::__iterator_category(__first)); 
# 2058
} 
# 2061
template< class _InputIterator> void _M_range_insert_aux(iterator __pos, _InputIterator __first, _InputIterator __last, std::input_iterator_tag); 
# 2067
template< class _ForwardIterator> void _M_range_insert_aux(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag); 
# 2076
void _M_fill_insert(iterator __pos, size_type __n, const value_type & __x); 
# 2083
template< class ..._Args> iterator _M_insert_aux(iterator __pos, _Args && ...__args); 
# 2090
void _M_insert_aux(iterator __pos, size_type __n, const value_type & __x); 
# 2093
template< class _ForwardIterator> void _M_insert_aux(iterator __pos, _ForwardIterator __first, _ForwardIterator __last, size_type __n); 
# 2103
void _M_destroy_data_aux(iterator __first, iterator __last); 
# 2107
template< class _Alloc1> void 
# 2109
_M_destroy_data(iterator __first, iterator __last, const _Alloc1 &) 
# 2110
{ _M_destroy_data_aux(__first, __last); } 
# 2113
void _M_destroy_data(iterator __first, iterator __last, const allocator< _Tp>  &) 
# 2115
{ 
# 2116
if (!__has_trivial_destructor(value_type)) { 
# 2117
_M_destroy_data_aux(__first, __last); }  
# 2118
} 
# 2122
void _M_erase_at_begin(iterator __pos) 
# 2123
{ 
# 2124
_M_destroy_data(begin(), __pos, _M_get_Tp_allocator()); 
# 2125
_M_destroy_nodes((((this->_M_impl)._M_start)._M_node), (__pos._M_node)); 
# 2126
((this->_M_impl)._M_start) = __pos; 
# 2127
} 
# 2132
void _M_erase_at_end(iterator __pos) 
# 2133
{ 
# 2134
_M_destroy_data(__pos, end(), _M_get_Tp_allocator()); 
# 2135
_M_destroy_nodes((__pos._M_node) + 1, (((this->_M_impl)._M_finish)._M_node) + 1); 
# 2137
((this->_M_impl)._M_finish) = __pos; 
# 2138
} 
# 2141
iterator _M_erase(iterator __pos); 
# 2144
iterator _M_erase(iterator __first, iterator __last); 
# 2149
void _M_default_append(size_type __n); 
# 2152
bool _M_shrink_to_fit(); 
# 2158
iterator _M_reserve_elements_at_front(size_type __n) 
# 2159
{ 
# 2160
const size_type __vacancies = (((this->_M_impl)._M_start)._M_cur) - (((this->_M_impl)._M_start)._M_first); 
# 2162
if (__n > __vacancies) { 
# 2163
_M_new_elements_at_front(__n - __vacancies); }  
# 2164
return ((this->_M_impl)._M_start) - ((difference_type)__n); 
# 2165
} 
# 2168
iterator _M_reserve_elements_at_back(size_type __n) 
# 2169
{ 
# 2170
const size_type __vacancies = ((((this->_M_impl)._M_finish)._M_last) - (((this->_M_impl)._M_finish)._M_cur)) - 1; 
# 2172
if (__n > __vacancies) { 
# 2173
_M_new_elements_at_back(__n - __vacancies); }  
# 2174
return ((this->_M_impl)._M_finish) + ((difference_type)__n); 
# 2175
} 
# 2178
void _M_new_elements_at_front(size_type __new_elements); 
# 2181
void _M_new_elements_at_back(size_type __new_elements); 
# 2194 "/usr/include/c++/9/bits/stl_deque.h" 3
void _M_reserve_map_at_back(size_type __nodes_to_add = 1) 
# 2195
{ 
# 2196
if ((__nodes_to_add + (1)) > (((this->_M_impl)._M_map_size) - ((((this->_M_impl)._M_finish)._M_node) - ((this->_M_impl)._M_map)))) { 
# 2198
_M_reallocate_map(__nodes_to_add, false); }  
# 2199
} 
# 2202
void _M_reserve_map_at_front(size_type __nodes_to_add = 1) 
# 2203
{ 
# 2204
if (__nodes_to_add > ((size_type)((((this->_M_impl)._M_start)._M_node) - ((this->_M_impl)._M_map)))) { 
# 2206
_M_reallocate_map(__nodes_to_add, true); }  
# 2207
} 
# 2210
void _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front); 
# 2217
void _M_move_assign1(deque &&__x, std::true_type) noexcept 
# 2218
{ 
# 2219
(this->_M_impl)._M_swap_data((__x._M_impl)); 
# 2220
__x.clear(); 
# 2221
std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()); 
# 2222
} 
# 2228
void _M_move_assign1(deque &&__x, std::false_type) 
# 2229
{ 
# 2230
constexpr bool __move_storage = _Alloc_traits::_S_propagate_on_move_assign(); 
# 2232
_M_move_assign2(std::move(__x), std::__bool_constant< __move_storage> ()); 
# 2233
} 
# 2237
template< class ..._Args> void 
# 2239
_M_replace_map(_Args &&...__args) 
# 2240
{ 
# 2242
deque __newobj(std::forward< _Args> (__args)...); 
# 2244
clear(); 
# 2245
_M_deallocate_node(*(begin()._M_node)); 
# 2246
_M_deallocate_map(((this->_M_impl)._M_map), ((this->_M_impl)._M_map_size)); 
# 2247
((this->_M_impl)._M_map) = nullptr; 
# 2248
((this->_M_impl)._M_map_size) = 0; 
# 2250
(this->_M_impl)._M_swap_data((__newobj._M_impl)); 
# 2251
} 
# 2255
void _M_move_assign2(deque &&__x, std::true_type) 
# 2256
{ 
# 2258
auto __alloc = __x._M_get_Tp_allocator(); 
# 2261
_M_replace_map(std::move(__x)); 
# 2263
_M_get_Tp_allocator() = std::move(__alloc); 
# 2264
} 
# 2269
void _M_move_assign2(deque &&__x, std::false_type) 
# 2270
{ 
# 2271
if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator()) 
# 2272
{ 
# 2275
_M_replace_map(std::move(__x), __x.get_allocator()); 
# 2276
} else 
# 2278
{ 
# 2281
_M_assign_aux(std::__make_move_if_noexcept_iterator(__x.begin()), std::__make_move_if_noexcept_iterator(__x.end()), std::random_access_iterator_tag()); 
# 2284
__x.clear(); 
# 2285
}  
# 2286
} 
# 2288
}; 
# 2310 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Tp, class _Alloc> inline bool 
# 2312
operator==(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2313
__y) 
# 2314
{ return (__x.size() == __y.size()) && std::equal(__x.begin(), __x.end(), __y.begin()); 
# 2315
} 
# 2328 "/usr/include/c++/9/bits/stl_deque.h" 3
template< class _Tp, class _Alloc> inline bool 
# 2330
operator<(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2331
__y) 
# 2332
{ return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end()); 
# 2333
} 
# 2336
template< class _Tp, class _Alloc> inline bool 
# 2338
operator!=(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2339
__y) 
# 2340
{ return !(__x == __y); } 
# 2343
template< class _Tp, class _Alloc> inline bool 
# 2345
operator>(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2346
__y) 
# 2347
{ return __y < __x; } 
# 2350
template< class _Tp, class _Alloc> inline bool 
# 2352
operator<=(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2353
__y) 
# 2354
{ return !(__y < __x); } 
# 2357
template< class _Tp, class _Alloc> inline bool 
# 2359
operator>=(const deque< _Tp, _Alloc>  &__x, const deque< _Tp, _Alloc>  &
# 2360
__y) 
# 2361
{ return !(__x < __y); } 
# 2364
template< class _Tp, class _Alloc> inline void 
# 2366
swap(deque< _Tp, _Alloc>  &__x, deque< _Tp, _Alloc>  &__y) noexcept(noexcept(__x.swap(__y))) 
# 2368
{ __x.swap(__y); } 
# 2377
template< class _Tp> 
# 2378
struct __is_bitwise_relocatable< deque< _Tp> , void>  : public true_type { 
# 2379
}; 
# 2383
}
# 59 "/usr/include/c++/9/bits/deque.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 65
template< class _Tp, class _Alloc> void 
# 68
deque< _Tp, _Alloc> ::_M_default_initialize() 
# 69
{ 
# 70
_Map_pointer __cur; 
# 71
try 
# 72
{ 
# 73
for (__cur = (((this->_M_impl)._M_start)._M_node); __cur < (((this->_M_impl)._M_finish)._M_node); ++__cur) { 
# 76
std::__uninitialized_default_a(*__cur, (*__cur) + (_S_buffer_size)(), _M_get_Tp_allocator()); }  
# 78
std::__uninitialized_default_a((((this->_M_impl)._M_finish)._M_first), (((this->_M_impl)._M_finish)._M_cur), _M_get_Tp_allocator()); 
# 81
} 
# 82
catch (...) 
# 83
{ 
# 84
std::_Destroy(((this->_M_impl)._M_start), iterator(*__cur, __cur), _M_get_Tp_allocator()); 
# 86
throw; 
# 87
}  
# 88
} 
# 91
template< class _Tp, class _Alloc> deque< _Tp, _Alloc>  &
# 94
deque< _Tp, _Alloc> ::operator=(const deque &__x) 
# 95
{ 
# 96
if ((&__x) != this) 
# 97
{ 
# 99
if (_Alloc_traits::_S_propagate_on_copy_assign()) 
# 100
{ 
# 101
if ((!_Alloc_traits::_S_always_equal()) && (_M_get_Tp_allocator() != __x._M_get_Tp_allocator())) 
# 103
{ 
# 106
_M_replace_map(__x, __x.get_allocator()); 
# 107
std::__alloc_on_copy(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()); 
# 109
return *this; 
# 110
}  
# 111
std::__alloc_on_copy(_M_get_Tp_allocator(), __x._M_get_Tp_allocator()); 
# 113
}  
# 115
const size_type __len = size(); 
# 116
if (__len >= __x.size()) { 
# 117
_M_erase_at_end(std::copy(__x.begin(), __x.end(), ((this->_M_impl)._M_start))); } else 
# 120
{ 
# 121
const_iterator __mid = __x.begin() + ((difference_type)__len); 
# 122
std::copy(__x.begin(), __mid, ((this->_M_impl)._M_start)); 
# 123
_M_range_insert_aux(((this->_M_impl)._M_finish), __mid, __x.end(), std::random_access_iterator_tag()); 
# 125
}  
# 126
}  
# 127
return *this; 
# 128
} 
# 131
template< class _Tp, class _Alloc> 
# 132
template< class ..._Args> void 
# 139
deque< _Tp, _Alloc> ::emplace_front(_Args &&...__args) 
# 140
{ 
# 141
if ((((this->_M_impl)._M_start)._M_cur) != (((this->_M_impl)._M_start)._M_first)) 
# 142
{ 
# 143
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_start)._M_cur) - 1, std::forward< _Args> (__args)...); 
# 146
--(((this->_M_impl)._M_start)._M_cur); 
# 147
} else { 
# 149
_M_push_front_aux(std::forward< _Args> (__args)...); }  
# 153
} 
# 155
template< class _Tp, class _Alloc> 
# 156
template< class ..._Args> void 
# 163
deque< _Tp, _Alloc> ::emplace_back(_Args &&...__args) 
# 164
{ 
# 165
if ((((this->_M_impl)._M_finish)._M_cur) != ((((this->_M_impl)._M_finish)._M_last) - 1)) 
# 167
{ 
# 168
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_finish)._M_cur), std::forward< _Args> (__args)...); 
# 171
++(((this->_M_impl)._M_finish)._M_cur); 
# 172
} else { 
# 174
_M_push_back_aux(std::forward< _Args> (__args)...); }  
# 178
} 
# 182
template< class _Tp, class _Alloc> 
# 183
template< class ..._Args> typename deque< _Tp, _Alloc> ::iterator 
# 186
deque< _Tp, _Alloc> ::emplace(const_iterator __position, _Args &&...__args) 
# 187
{ 
# 188
if ((__position._M_cur) == (((this->_M_impl)._M_start)._M_cur)) 
# 189
{ 
# 190
emplace_front(std::forward< _Args> (__args)...); 
# 191
return (this->_M_impl)._M_start; 
# 192
} else { 
# 193
if ((__position._M_cur) == (((this->_M_impl)._M_finish)._M_cur)) 
# 194
{ 
# 195
emplace_back(std::forward< _Args> (__args)...); 
# 196
iterator __tmp = (((this->_M_impl)._M_finish)); 
# 197
--__tmp; 
# 198
return __tmp; 
# 199
} else { 
# 201
return _M_insert_aux(__position._M_const_cast(), std::forward< _Args> (__args)...); }  }  
# 203
} 
# 206
template< class _Tp, class _Alloc> typename deque< _Tp, _Alloc> ::iterator 
# 210
deque< _Tp, _Alloc> ::insert(const_iterator __position, const value_type &__x) 
# 214
{ 
# 215
if ((__position._M_cur) == (((this->_M_impl)._M_start)._M_cur)) 
# 216
{ 
# 217
push_front(__x); 
# 218
return (this->_M_impl)._M_start; 
# 219
} else { 
# 220
if ((__position._M_cur) == (((this->_M_impl)._M_finish)._M_cur)) 
# 221
{ 
# 222
push_back(__x); 
# 223
iterator __tmp = (((this->_M_impl)._M_finish)); 
# 224
--__tmp; 
# 225
return __tmp; 
# 226
} else { 
# 228
return _M_insert_aux(__position._M_const_cast(), __x); }  }  
# 229
} 
# 231
template< class _Tp, class _Alloc> typename deque< _Tp, _Alloc> ::iterator 
# 234
deque< _Tp, _Alloc> ::_M_erase(iterator __position) 
# 235
{ 
# 236
iterator __next = __position; 
# 237
++__next; 
# 238
const difference_type __index = __position - begin(); 
# 239
if ((static_cast< size_type>(__index)) < (size() >> 1)) 
# 240
{ 
# 241
if (__position != begin()) { 
# 242
std::move_backward(begin(), __position, __next); }  
# 243
pop_front(); 
# 244
} else 
# 246
{ 
# 247
if (__next != end()) { 
# 248
std::move(__next, end(), __position); }  
# 249
pop_back(); 
# 250
}  
# 251
return begin() + __index; 
# 252
} 
# 254
template< class _Tp, class _Alloc> typename deque< _Tp, _Alloc> ::iterator 
# 257
deque< _Tp, _Alloc> ::_M_erase(iterator __first, iterator __last) 
# 258
{ 
# 259
if (__first == __last) { 
# 260
return __first; } else { 
# 261
if ((__first == begin()) && (__last == end())) 
# 262
{ 
# 263
clear(); 
# 264
return end(); 
# 265
} else 
# 267
{ 
# 268
const difference_type __n = __last - __first; 
# 269
const difference_type __elems_before = __first - begin(); 
# 270
if ((static_cast< size_type>(__elems_before)) <= ((size() - __n) / 2)) 
# 271
{ 
# 272
if (__first != begin()) { 
# 273
std::move_backward(begin(), __first, __last); }  
# 274
_M_erase_at_begin(begin() + __n); 
# 275
} else 
# 277
{ 
# 278
if (__last != end()) { 
# 279
std::move(__last, end(), __first); }  
# 280
_M_erase_at_end(end() - __n); 
# 281
}  
# 282
return begin() + __elems_before; 
# 283
}  }  
# 284
} 
# 286
template< class _Tp, class _Alloc> 
# 287
template< class _InputIterator> void 
# 290
deque< _Tp, _Alloc> ::_M_assign_aux(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) 
# 292
{ 
# 293
iterator __cur = begin(); 
# 294
for (; (__first != __last) && (__cur != end()); (++__cur), ((void)(++__first))) { 
# 295
(*__cur) = (*__first); }  
# 296
if (__first == __last) { 
# 297
_M_erase_at_end(__cur); } else { 
# 299
_M_range_insert_aux(end(), __first, __last, std::__iterator_category(__first)); }  
# 301
} 
# 303
template< class _Tp, class _Alloc> void 
# 306
deque< _Tp, _Alloc> ::_M_fill_insert(iterator __pos, size_type __n, const value_type &__x) 
# 307
{ 
# 308
if ((__pos._M_cur) == (((this->_M_impl)._M_start)._M_cur)) 
# 309
{ 
# 310
iterator __new_start = _M_reserve_elements_at_front(__n); 
# 311
try 
# 312
{ 
# 313
std::__uninitialized_fill_a(__new_start, ((this->_M_impl)._M_start), __x, _M_get_Tp_allocator()); 
# 315
((this->_M_impl)._M_start) = __new_start; 
# 316
} 
# 317
catch (...) 
# 318
{ 
# 319
_M_destroy_nodes((__new_start._M_node), (((this->_M_impl)._M_start)._M_node)); 
# 321
throw; 
# 322
}  
# 323
} else { 
# 324
if ((__pos._M_cur) == (((this->_M_impl)._M_finish)._M_cur)) 
# 325
{ 
# 326
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 327
try 
# 328
{ 
# 329
std::__uninitialized_fill_a(((this->_M_impl)._M_finish), __new_finish, __x, _M_get_Tp_allocator()); 
# 332
((this->_M_impl)._M_finish) = __new_finish; 
# 333
} 
# 334
catch (...) 
# 335
{ 
# 336
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 338
throw; 
# 339
}  
# 340
} else { 
# 342
_M_insert_aux(__pos, __n, __x); }  }  
# 343
} 
# 346
template< class _Tp, class _Alloc> void 
# 349
deque< _Tp, _Alloc> ::_M_default_append(size_type __n) 
# 350
{ 
# 351
if (__n) 
# 352
{ 
# 353
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 354
try 
# 355
{ 
# 356
std::__uninitialized_default_a(((this->_M_impl)._M_finish), __new_finish, _M_get_Tp_allocator()); 
# 359
((this->_M_impl)._M_finish) = __new_finish; 
# 360
} 
# 361
catch (...) 
# 362
{ 
# 363
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 365
throw; 
# 366
}  
# 367
}  
# 368
} 
# 370
template< class _Tp, class _Alloc> bool 
# 373
deque< _Tp, _Alloc> ::_M_shrink_to_fit() 
# 374
{ 
# 375
const difference_type __front_capacity = (((this->_M_impl)._M_start)._M_cur) - (((this->_M_impl)._M_start)._M_first); 
# 377
if (__front_capacity == (0)) { 
# 378
return false; }  
# 380
const difference_type __back_capacity = (((this->_M_impl)._M_finish)._M_last) - (((this->_M_impl)._M_finish)._M_cur); 
# 382
if ((__front_capacity + __back_capacity) < (_S_buffer_size)()) { 
# 383
return false; }  
# 385
return std::template __shrink_to_fit_aux< deque> ::_S_do_it(*this); 
# 386
} 
# 389
template< class _Tp, class _Alloc> void 
# 392
deque< _Tp, _Alloc> ::_M_fill_initialize(const value_type &__value) 
# 393
{ 
# 394
_Map_pointer __cur; 
# 395
try 
# 396
{ 
# 397
for (__cur = (((this->_M_impl)._M_start)._M_node); __cur < (((this->_M_impl)._M_finish)._M_node); ++__cur) { 
# 400
std::__uninitialized_fill_a(*__cur, (*__cur) + (_S_buffer_size)(), __value, _M_get_Tp_allocator()); }  
# 402
std::__uninitialized_fill_a((((this->_M_impl)._M_finish)._M_first), (((this->_M_impl)._M_finish)._M_cur), __value, _M_get_Tp_allocator()); 
# 405
} 
# 406
catch (...) 
# 407
{ 
# 408
std::_Destroy(((this->_M_impl)._M_start), iterator(*__cur, __cur), _M_get_Tp_allocator()); 
# 410
throw; 
# 411
}  
# 412
} 
# 414
template< class _Tp, class _Alloc> 
# 415
template< class _InputIterator> void 
# 418
deque< _Tp, _Alloc> ::_M_range_initialize(_InputIterator __first, _InputIterator __last, std::input_iterator_tag) 
# 420
{ 
# 421
this->_M_initialize_map(0); 
# 422
try 
# 423
{ 
# 424
for (; __first != __last; ++__first) { 
# 426
emplace_back(*__first); }  
# 430
} 
# 431
catch (...) 
# 432
{ 
# 433
clear(); 
# 434
throw; 
# 435
}  
# 436
} 
# 438
template< class _Tp, class _Alloc> 
# 439
template< class _ForwardIterator> void 
# 442
deque< _Tp, _Alloc> ::_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last, std::forward_iterator_tag) 
# 444
{ 
# 445
const size_type __n = std::distance(__first, __last); 
# 446
this->_M_initialize_map((_S_check_init_len)(__n, _M_get_Tp_allocator())); 
# 448
_Map_pointer __cur_node; 
# 449
try 
# 450
{ 
# 451
for (__cur_node = (((this->_M_impl)._M_start)._M_node); __cur_node < (((this->_M_impl)._M_finish)._M_node); ++__cur_node) 
# 454
{ 
# 455
_ForwardIterator __mid = __first; 
# 456
std::advance(__mid, (_S_buffer_size)()); 
# 457
std::__uninitialized_copy_a(__first, __mid, *__cur_node, _M_get_Tp_allocator()); 
# 459
__first = __mid; 
# 460
}  
# 461
std::__uninitialized_copy_a(__first, __last, (((this->_M_impl)._M_finish)._M_first), _M_get_Tp_allocator()); 
# 464
} 
# 465
catch (...) 
# 466
{ 
# 467
std::_Destroy(((this->_M_impl)._M_start), iterator(*__cur_node, __cur_node), _M_get_Tp_allocator()); 
# 470
throw; 
# 471
}  
# 472
} 
# 475
template< class _Tp, class _Alloc> 
# 477
template< class ..._Args> void 
# 480
deque< _Tp, _Alloc> ::_M_push_back_aux(_Args &&...__args) 
# 486
{ 
# 487
if (size() == max_size()) { 
# 488
__throw_length_error("cannot create std::deque larger than max_size()"); }  
# 491
_M_reserve_map_at_back(); 
# 492
(*((((this->_M_impl)._M_finish)._M_node) + 1)) = this->_M_allocate_node(); 
# 493
try 
# 494
{ 
# 496
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_finish)._M_cur), std::forward< _Args> (__args)...); 
# 502
((this->_M_impl)._M_finish)._M_set_node((((this->_M_impl)._M_finish)._M_node) + 1); 
# 504
(((this->_M_impl)._M_finish)._M_cur) = (((this->_M_impl)._M_finish)._M_first); 
# 505
} 
# 506
catch (...) 
# 507
{ 
# 508
_M_deallocate_node(*((((this->_M_impl)._M_finish)._M_node) + 1)); 
# 509
throw; 
# 510
}  
# 511
} 
# 514
template< class _Tp, class _Alloc> 
# 516
template< class ..._Args> void 
# 519
deque< _Tp, _Alloc> ::_M_push_front_aux(_Args &&...__args) 
# 525
{ 
# 526
if (size() == max_size()) { 
# 527
__throw_length_error("cannot create std::deque larger than max_size()"); }  
# 530
_M_reserve_map_at_front(); 
# 531
(*((((this->_M_impl)._M_start)._M_node) - 1)) = this->_M_allocate_node(); 
# 532
try 
# 533
{ 
# 534
((this->_M_impl)._M_start)._M_set_node((((this->_M_impl)._M_start)._M_node) - 1); 
# 536
(((this->_M_impl)._M_start)._M_cur) = ((((this->_M_impl)._M_start)._M_last) - 1); 
# 538
_Alloc_traits::construct((this->_M_impl), (((this->_M_impl)._M_start)._M_cur), std::forward< _Args> (__args)...); 
# 544
} 
# 545
catch (...) 
# 546
{ 
# 547
++((this->_M_impl)._M_start); 
# 548
_M_deallocate_node(*((((this->_M_impl)._M_start)._M_node) - 1)); 
# 549
throw; 
# 550
}  
# 551
} 
# 554
template< class _Tp, class _Alloc> void 
# 556
deque< _Tp, _Alloc> ::_M_pop_back_aux() 
# 557
{ 
# 558
_M_deallocate_node((((this->_M_impl)._M_finish)._M_first)); 
# 559
((this->_M_impl)._M_finish)._M_set_node((((this->_M_impl)._M_finish)._M_node) - 1); 
# 560
(((this->_M_impl)._M_finish)._M_cur) = ((((this->_M_impl)._M_finish)._M_last) - 1); 
# 561
_Alloc_traits::destroy(_M_get_Tp_allocator(), (((this->_M_impl)._M_finish)._M_cur)); 
# 563
} 
# 570
template< class _Tp, class _Alloc> void 
# 572
deque< _Tp, _Alloc> ::_M_pop_front_aux() 
# 573
{ 
# 574
_Alloc_traits::destroy(_M_get_Tp_allocator(), (((this->_M_impl)._M_start)._M_cur)); 
# 576
_M_deallocate_node((((this->_M_impl)._M_start)._M_first)); 
# 577
((this->_M_impl)._M_start)._M_set_node((((this->_M_impl)._M_start)._M_node) + 1); 
# 578
(((this->_M_impl)._M_start)._M_cur) = (((this->_M_impl)._M_start)._M_first); 
# 579
} 
# 581
template< class _Tp, class _Alloc> 
# 582
template< class _InputIterator> void 
# 585
deque< _Tp, _Alloc> ::_M_range_insert_aux(iterator __pos, _InputIterator 
# 586
__first, _InputIterator __last, std::input_iterator_tag) 
# 588
{ std::copy(__first, __last, std::inserter(*this, __pos)); } 
# 590
template< class _Tp, class _Alloc> 
# 591
template< class _ForwardIterator> void 
# 594
deque< _Tp, _Alloc> ::_M_range_insert_aux(iterator __pos, _ForwardIterator 
# 595
__first, _ForwardIterator __last, std::forward_iterator_tag) 
# 597
{ 
# 598
const size_type __n = std::distance(__first, __last); 
# 599
if ((__pos._M_cur) == (((this->_M_impl)._M_start)._M_cur)) 
# 600
{ 
# 601
iterator __new_start = _M_reserve_elements_at_front(__n); 
# 602
try 
# 603
{ 
# 604
std::__uninitialized_copy_a(__first, __last, __new_start, _M_get_Tp_allocator()); 
# 606
((this->_M_impl)._M_start) = __new_start; 
# 607
} 
# 608
catch (...) 
# 609
{ 
# 610
_M_destroy_nodes((__new_start._M_node), (((this->_M_impl)._M_start)._M_node)); 
# 612
throw; 
# 613
}  
# 614
} else { 
# 615
if ((__pos._M_cur) == (((this->_M_impl)._M_finish)._M_cur)) 
# 616
{ 
# 617
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 618
try 
# 619
{ 
# 620
std::__uninitialized_copy_a(__first, __last, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 623
((this->_M_impl)._M_finish) = __new_finish; 
# 624
} 
# 625
catch (...) 
# 626
{ 
# 627
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 629
throw; 
# 630
}  
# 631
} else { 
# 633
_M_insert_aux(__pos, __first, __last, __n); }  }  
# 634
} 
# 636
template< class _Tp, class _Alloc> 
# 638
template< class ..._Args> typename deque< _Tp, _Alloc> ::iterator 
# 641
deque< _Tp, _Alloc> ::_M_insert_aux(iterator __pos, _Args &&...__args) 
# 642
{ 
# 643
value_type __x_copy(std::forward< _Args> (__args)...); 
# 651
difference_type __index = __pos - ((this->_M_impl)._M_start); 
# 652
if ((static_cast< size_type>(__index)) < (size() / 2)) 
# 653
{ 
# 654
push_front(std::move(front())); 
# 655
iterator __front1 = (((this->_M_impl)._M_start)); 
# 656
++__front1; 
# 657
iterator __front2 = __front1; 
# 658
++__front2; 
# 659
__pos = (((this->_M_impl)._M_start) + __index); 
# 660
iterator __pos1 = __pos; 
# 661
++__pos1; 
# 662
std::move(__front2, __pos1, __front1); 
# 663
} else 
# 665
{ 
# 666
push_back(std::move(back())); 
# 667
iterator __back1 = (((this->_M_impl)._M_finish)); 
# 668
--__back1; 
# 669
iterator __back2 = __back1; 
# 670
--__back2; 
# 671
__pos = (((this->_M_impl)._M_start) + __index); 
# 672
std::move_backward(__pos, __back2, __back1); 
# 673
}  
# 674
(*__pos) = std::move(__x_copy); 
# 675
return __pos; 
# 676
} 
# 678
template< class _Tp, class _Alloc> void 
# 681
deque< _Tp, _Alloc> ::_M_insert_aux(iterator __pos, size_type __n, const value_type &__x) 
# 682
{ 
# 683
const difference_type __elems_before = __pos - ((this->_M_impl)._M_start); 
# 684
const size_type __length = size(); 
# 685
value_type __x_copy = __x; 
# 686
if (__elems_before < ((difference_type)(__length / (2)))) 
# 687
{ 
# 688
iterator __new_start = _M_reserve_elements_at_front(__n); 
# 689
iterator __old_start = (((this->_M_impl)._M_start)); 
# 690
__pos = (((this->_M_impl)._M_start) + __elems_before); 
# 691
try 
# 692
{ 
# 693
if (__elems_before >= ((difference_type)__n)) 
# 694
{ 
# 695
iterator __start_n = ((this->_M_impl)._M_start) + ((difference_type)__n); 
# 697
std::__uninitialized_move_a(((this->_M_impl)._M_start), __start_n, __new_start, _M_get_Tp_allocator()); 
# 700
((this->_M_impl)._M_start) = __new_start; 
# 701
std::move(__start_n, __pos, __old_start); 
# 702
std::fill(__pos - ((difference_type)__n), __pos, __x_copy); 
# 703
} else 
# 705
{ 
# 706
std::__uninitialized_move_fill(((this->_M_impl)._M_start), __pos, __new_start, ((this->_M_impl)._M_start), __x_copy, _M_get_Tp_allocator()); 
# 711
((this->_M_impl)._M_start) = __new_start; 
# 712
std::fill(__old_start, __pos, __x_copy); 
# 713
}  
# 714
} 
# 715
catch (...) 
# 716
{ 
# 717
_M_destroy_nodes((__new_start._M_node), (((this->_M_impl)._M_start)._M_node)); 
# 719
throw; 
# 720
}  
# 721
} else 
# 723
{ 
# 724
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 725
iterator __old_finish = (((this->_M_impl)._M_finish)); 
# 726
const difference_type __elems_after = (((difference_type)__length) - __elems_before); 
# 728
__pos = (((this->_M_impl)._M_finish) - __elems_after); 
# 729
try 
# 730
{ 
# 731
if (__elems_after > ((difference_type)__n)) 
# 732
{ 
# 733
iterator __finish_n = ((this->_M_impl)._M_finish) - ((difference_type)__n); 
# 735
std::__uninitialized_move_a(__finish_n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 739
((this->_M_impl)._M_finish) = __new_finish; 
# 740
std::move_backward(__pos, __finish_n, __old_finish); 
# 741
std::fill(__pos, __pos + ((difference_type)__n), __x_copy); 
# 742
} else 
# 744
{ 
# 745
std::__uninitialized_fill_move(((this->_M_impl)._M_finish), __pos + ((difference_type)__n), __x_copy, __pos, ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 750
((this->_M_impl)._M_finish) = __new_finish; 
# 751
std::fill(__pos, __old_finish, __x_copy); 
# 752
}  
# 753
} 
# 754
catch (...) 
# 755
{ 
# 756
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 758
throw; 
# 759
}  
# 760
}  
# 761
} 
# 763
template< class _Tp, class _Alloc> 
# 764
template< class _ForwardIterator> void 
# 767
deque< _Tp, _Alloc> ::_M_insert_aux(iterator __pos, _ForwardIterator 
# 768
__first, _ForwardIterator __last, size_type 
# 769
__n) 
# 770
{ 
# 771
const difference_type __elemsbefore = __pos - ((this->_M_impl)._M_start); 
# 772
const size_type __length = size(); 
# 773
if ((static_cast< size_type>(__elemsbefore)) < (__length / (2))) 
# 774
{ 
# 775
iterator __new_start = _M_reserve_elements_at_front(__n); 
# 776
iterator __old_start = (((this->_M_impl)._M_start)); 
# 777
__pos = (((this->_M_impl)._M_start) + __elemsbefore); 
# 778
try 
# 779
{ 
# 780
if (__elemsbefore >= ((difference_type)__n)) 
# 781
{ 
# 782
iterator __start_n = ((this->_M_impl)._M_start) + ((difference_type)__n); 
# 784
std::__uninitialized_move_a(((this->_M_impl)._M_start), __start_n, __new_start, _M_get_Tp_allocator()); 
# 787
((this->_M_impl)._M_start) = __new_start; 
# 788
std::move(__start_n, __pos, __old_start); 
# 789
std::copy(__first, __last, __pos - ((difference_type)__n)); 
# 790
} else 
# 792
{ 
# 793
_ForwardIterator __mid = __first; 
# 794
std::advance(__mid, ((difference_type)__n) - __elemsbefore); 
# 795
std::__uninitialized_move_copy(((this->_M_impl)._M_start), __pos, __first, __mid, __new_start, _M_get_Tp_allocator()); 
# 799
((this->_M_impl)._M_start) = __new_start; 
# 800
std::copy(__mid, __last, __old_start); 
# 801
}  
# 802
} 
# 803
catch (...) 
# 804
{ 
# 805
_M_destroy_nodes((__new_start._M_node), (((this->_M_impl)._M_start)._M_node)); 
# 807
throw; 
# 808
}  
# 809
} else 
# 811
{ 
# 812
iterator __new_finish = _M_reserve_elements_at_back(__n); 
# 813
iterator __old_finish = (((this->_M_impl)._M_finish)); 
# 814
const difference_type __elemsafter = (((difference_type)__length) - __elemsbefore); 
# 816
__pos = (((this->_M_impl)._M_finish) - __elemsafter); 
# 817
try 
# 818
{ 
# 819
if (__elemsafter > ((difference_type)__n)) 
# 820
{ 
# 821
iterator __finish_n = ((this->_M_impl)._M_finish) - ((difference_type)__n); 
# 823
std::__uninitialized_move_a(__finish_n, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 827
((this->_M_impl)._M_finish) = __new_finish; 
# 828
std::move_backward(__pos, __finish_n, __old_finish); 
# 829
std::copy(__first, __last, __pos); 
# 830
} else 
# 832
{ 
# 833
_ForwardIterator __mid = __first; 
# 834
std::advance(__mid, __elemsafter); 
# 835
std::__uninitialized_copy_move(__mid, __last, __pos, ((this->_M_impl)._M_finish), ((this->_M_impl)._M_finish), _M_get_Tp_allocator()); 
# 839
((this->_M_impl)._M_finish) = __new_finish; 
# 840
std::copy(__first, __mid, __pos); 
# 841
}  
# 842
} 
# 843
catch (...) 
# 844
{ 
# 845
_M_destroy_nodes((((this->_M_impl)._M_finish)._M_node) + 1, (__new_finish._M_node) + 1); 
# 847
throw; 
# 848
}  
# 849
}  
# 850
} 
# 852
template< class _Tp, class _Alloc> void 
# 855
deque< _Tp, _Alloc> ::_M_destroy_data_aux(iterator __first, iterator __last) 
# 856
{ 
# 857
for (_Map_pointer __node = (__first._M_node) + 1; __node < (__last._M_node); ++__node) { 
# 859
std::_Destroy(*__node, (*__node) + (_S_buffer_size)(), _M_get_Tp_allocator()); }  
# 862
if ((__first._M_node) != (__last._M_node)) 
# 863
{ 
# 864
std::_Destroy((__first._M_cur), (__first._M_last), _M_get_Tp_allocator()); 
# 866
std::_Destroy((__last._M_first), (__last._M_cur), _M_get_Tp_allocator()); 
# 868
} else { 
# 870
std::_Destroy((__first._M_cur), (__last._M_cur), _M_get_Tp_allocator()); }  
# 872
} 
# 874
template< class _Tp, class _Alloc> void 
# 877
deque< _Tp, _Alloc> ::_M_new_elements_at_front(size_type __new_elems) 
# 878
{ 
# 879
if ((max_size() - size()) < __new_elems) { 
# 880
__throw_length_error("deque::_M_new_elements_at_front"); }  
# 882
const size_type __new_nodes = ((__new_elems + (_S_buffer_size)()) - (1)) / (_S_buffer_size)(); 
# 884
_M_reserve_map_at_front(__new_nodes); 
# 885
size_type __i; 
# 886
try 
# 887
{ 
# 888
for (__i = (1); __i <= __new_nodes; ++__i) { 
# 889
(*((((this->_M_impl)._M_start)._M_node) - __i)) = this->_M_allocate_node(); }  
# 890
} 
# 891
catch (...) 
# 892
{ 
# 893
for (size_type __j = (1); __j < __i; ++__j) { 
# 894
_M_deallocate_node(*((((this->_M_impl)._M_start)._M_node) - __j)); }  
# 895
throw; 
# 896
}  
# 897
} 
# 899
template< class _Tp, class _Alloc> void 
# 902
deque< _Tp, _Alloc> ::_M_new_elements_at_back(size_type __new_elems) 
# 903
{ 
# 904
if ((max_size() - size()) < __new_elems) { 
# 905
__throw_length_error("deque::_M_new_elements_at_back"); }  
# 907
const size_type __new_nodes = ((__new_elems + (_S_buffer_size)()) - (1)) / (_S_buffer_size)(); 
# 909
_M_reserve_map_at_back(__new_nodes); 
# 910
size_type __i; 
# 911
try 
# 912
{ 
# 913
for (__i = (1); __i <= __new_nodes; ++__i) { 
# 914
(*((((this->_M_impl)._M_finish)._M_node) + __i)) = this->_M_allocate_node(); }  
# 915
} 
# 916
catch (...) 
# 917
{ 
# 918
for (size_type __j = (1); __j < __i; ++__j) { 
# 919
_M_deallocate_node(*((((this->_M_impl)._M_finish)._M_node) + __j)); }  
# 920
throw; 
# 921
}  
# 922
} 
# 924
template< class _Tp, class _Alloc> void 
# 927
deque< _Tp, _Alloc> ::_M_reallocate_map(size_type __nodes_to_add, bool __add_at_front) 
# 928
{ 
# 929
const size_type __old_num_nodes = ((((this->_M_impl)._M_finish)._M_node) - (((this->_M_impl)._M_start)._M_node)) + 1; 
# 931
const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add; 
# 933
_Map_pointer __new_nstart; 
# 934
if (((this->_M_impl)._M_map_size) > ((2) * __new_num_nodes)) 
# 935
{ 
# 936
__new_nstart = ((((this->_M_impl)._M_map) + ((((this->_M_impl)._M_map_size) - __new_num_nodes) / 2)) + (__add_at_front ? __nodes_to_add : (0))); 
# 939
if (__new_nstart < (((this->_M_impl)._M_start)._M_node)) { 
# 940
std::copy((((this->_M_impl)._M_start)._M_node), (((this->_M_impl)._M_finish)._M_node) + 1, __new_nstart); } else { 
# 944
std::copy_backward((((this->_M_impl)._M_start)._M_node), (((this->_M_impl)._M_finish)._M_node) + 1, __new_nstart + __old_num_nodes); }  
# 947
} else 
# 949
{ 
# 950
size_type __new_map_size = (((this->_M_impl)._M_map_size) + std::max(((this->_M_impl)._M_map_size), __nodes_to_add)) + 2; 
# 954
_Map_pointer __new_map = this->_M_allocate_map(__new_map_size); 
# 955
__new_nstart = ((__new_map + ((__new_map_size - __new_num_nodes) / (2))) + (__add_at_front ? __nodes_to_add : (0))); 
# 957
std::copy((((this->_M_impl)._M_start)._M_node), (((this->_M_impl)._M_finish)._M_node) + 1, __new_nstart); 
# 960
_M_deallocate_map(((this->_M_impl)._M_map), ((this->_M_impl)._M_map_size)); 
# 962
((this->_M_impl)._M_map) = __new_map; 
# 963
((this->_M_impl)._M_map_size) = __new_map_size; 
# 964
}  
# 966
((this->_M_impl)._M_start)._M_set_node(__new_nstart); 
# 967
((this->_M_impl)._M_finish)._M_set_node((__new_nstart + __old_num_nodes) - 1); 
# 968
} 
# 972
template< class _Tp> void 
# 974
fill(const _Deque_iterator< _Tp, _Tp &, _Tp *>  &__first, const _Deque_iterator< _Tp, _Tp &, _Tp *>  &
# 975
__last, const _Tp &__value) 
# 976
{ 
# 977
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 979
for (typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::_Map_pointer __node = (__first._M_node) + 1; __node < (__last._M_node); ++__node) { 
# 981
std::fill(*__node, (*__node) + _Self::_S_buffer_size(), __value); }  
# 983
if ((__first._M_node) != (__last._M_node)) 
# 984
{ 
# 985
std::fill((__first._M_cur), (__first._M_last), __value); 
# 986
std::fill((__last._M_first), (__last._M_cur), __value); 
# 987
} else { 
# 989
std::fill((__first._M_cur), (__last._M_cur), __value); }  
# 990
} 
# 992
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 994
copy(_Deque_iterator< _Tp, const _Tp &, const _Tp *>  __first, _Deque_iterator< _Tp, const _Tp &, const _Tp *>  
# 995
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 996
__result) 
# 997
{ 
# 998
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 999
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::difference_type difference_type; 
# 1001
difference_type __len = __last - __first; 
# 1002
while (__len > 0) 
# 1003
{ 
# 1004
const difference_type __clen = std::min(__len, std::min((__first._M_last) - (__first._M_cur), (__result._M_last) - (__result._M_cur))); 
# 1007
std::copy((__first._M_cur), (__first._M_cur) + __clen, (__result._M_cur)); 
# 1008
__first += __clen; 
# 1009
__result += __clen; 
# 1010
__len -= __clen; 
# 1011
}  
# 1012
return __result; 
# 1013
} 
# 1015
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1017
copy_backward(_Deque_iterator< _Tp, const _Tp &, const _Tp *>  __first, _Deque_iterator< _Tp, const _Tp &, const _Tp *>  
# 1018
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1019
__result) 
# 1020
{ 
# 1021
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 1022
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::difference_type difference_type; 
# 1024
difference_type __len = __last - __first; 
# 1025
while (__len > 0) 
# 1026
{ 
# 1027
difference_type __llen = (__last._M_cur) - (__last._M_first); 
# 1028
_Tp *__lend = ((__last._M_cur)); 
# 1030
difference_type __rlen = (__result._M_cur) - (__result._M_first); 
# 1031
_Tp *__rend = ((__result._M_cur)); 
# 1033
if (!__llen) 
# 1034
{ 
# 1035
__llen = _Self::_S_buffer_size(); 
# 1036
__lend = ((*((__last._M_node) - 1)) + __llen); 
# 1037
}  
# 1038
if (!__rlen) 
# 1039
{ 
# 1040
__rlen = _Self::_S_buffer_size(); 
# 1041
__rend = ((*((__result._M_node) - 1)) + __rlen); 
# 1042
}  
# 1044
const difference_type __clen = std::min(__len, std::min(__llen, __rlen)); 
# 1046
std::copy_backward(__lend - __clen, __lend, __rend); 
# 1047
__last -= __clen; 
# 1048
__result -= __clen; 
# 1049
__len -= __clen; 
# 1050
}  
# 1051
return __result; 
# 1052
} 
# 1055
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1057
move(_Deque_iterator< _Tp, const _Tp &, const _Tp *>  __first, _Deque_iterator< _Tp, const _Tp &, const _Tp *>  
# 1058
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1059
__result) 
# 1060
{ 
# 1061
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 1062
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::difference_type difference_type; 
# 1064
difference_type __len = __last - __first; 
# 1065
while (__len > 0) 
# 1066
{ 
# 1067
const difference_type __clen = std::min(__len, std::min((__first._M_last) - (__first._M_cur), (__result._M_last) - (__result._M_cur))); 
# 1070
std::move((__first._M_cur), (__first._M_cur) + __clen, (__result._M_cur)); 
# 1071
__first += __clen; 
# 1072
__result += __clen; 
# 1073
__len -= __clen; 
# 1074
}  
# 1075
return __result; 
# 1076
} 
# 1078
template< class _Tp> _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1080
move_backward(_Deque_iterator< _Tp, const _Tp &, const _Tp *>  __first, _Deque_iterator< _Tp, const _Tp &, const _Tp *>  
# 1081
__last, _Deque_iterator< _Tp, _Tp &, _Tp *>  
# 1082
__result) 
# 1083
{ 
# 1084
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self _Self; 
# 1085
typedef typename _Deque_iterator< _Tp, _Tp &, _Tp *> ::_Self::difference_type difference_type; 
# 1087
difference_type __len = __last - __first; 
# 1088
while (__len > 0) 
# 1089
{ 
# 1090
difference_type __llen = (__last._M_cur) - (__last._M_first); 
# 1091
_Tp *__lend = ((__last._M_cur)); 
# 1093
difference_type __rlen = (__result._M_cur) - (__result._M_first); 
# 1094
_Tp *__rend = ((__result._M_cur)); 
# 1096
if (!__llen) 
# 1097
{ 
# 1098
__llen = _Self::_S_buffer_size(); 
# 1099
__lend = ((*((__last._M_node) - 1)) + __llen); 
# 1100
}  
# 1101
if (!__rlen) 
# 1102
{ 
# 1103
__rlen = _Self::_S_buffer_size(); 
# 1104
__rend = ((*((__result._M_node) - 1)) + __rlen); 
# 1105
}  
# 1107
const difference_type __clen = std::min(__len, std::min(__llen, __rlen)); 
# 1109
std::move_backward(__lend - __clen, __lend, __rend); 
# 1110
__last -= __clen; 
# 1111
__result -= __clen; 
# 1112
__len -= __clen; 
# 1113
}  
# 1114
return __result; 
# 1115
} 
# 1120
}
# 65 "/usr/include/c++/9/bits/stl_queue.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 95 "/usr/include/c++/9/bits/stl_queue.h" 3
template< class _Tp, class _Sequence = deque< _Tp> > 
# 96
class queue { 
# 109 "/usr/include/c++/9/bits/stl_queue.h" 3
template< class _Tp1, class _Seq1> friend bool operator==(const std::queue< _Tp1, _Seq1>  &, const std::queue< _Tp1, _Seq1>  &); 
# 113
template< class _Tp1, class _Seq1> friend bool operator<(const std::queue< _Tp1, _Seq1>  &, const std::queue< _Tp1, _Seq1>  &); 
# 118
template< class _Alloc> using _Uses = typename enable_if< uses_allocator< _Sequence, _Alloc> ::value> ::type; 
# 132 "/usr/include/c++/9/bits/stl_queue.h" 3
public: typedef typename _Sequence::value_type value_type; 
# 133
typedef typename _Sequence::reference reference; 
# 134
typedef typename _Sequence::const_reference const_reference; 
# 135
typedef typename _Sequence::size_type size_type; 
# 136
typedef _Sequence container_type; 
# 147 "/usr/include/c++/9/bits/stl_queue.h" 3
protected: _Sequence c; 
# 160 "/usr/include/c++/9/bits/stl_queue.h" 3
public: 
# 158
template< class _Seq = _Sequence, class _Requires = typename enable_if< is_default_constructible< _Seq> ::value> ::type> 
# 160
queue() : c() 
# 161
{ } 
# 164
explicit queue(const _Sequence &__c) : c(__c) 
# 165
{ } 
# 168
explicit queue(_Sequence &&__c) : c(std::move(__c)) 
# 169
{ } 
# 171
template< class _Alloc, class _Requires = _Uses< _Alloc> > explicit 
# 173
queue(const _Alloc &__a) : c(__a) 
# 174
{ } 
# 176
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 177
queue(const _Sequence &__c, const _Alloc &__a) : c(__c, __a) 
# 178
{ } 
# 180
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 181
queue(_Sequence &&__c, const _Alloc &__a) : c(std::move(__c), __a) 
# 182
{ } 
# 184
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 185
queue(const queue &__q, const _Alloc &__a) : c(__q.c, __a) 
# 186
{ } 
# 188
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 189
queue(queue &&__q, const _Alloc &__a) : c(std::move(__q.c), __a) 
# 190
{ } 
# 197
bool empty() const 
# 198
{ return (c).empty(); } 
# 202
size_type size() const 
# 203
{ return (c).size(); } 
# 210
reference front() 
# 211
{ 
# 212
; 
# 213
return (c).front(); 
# 214
} 
# 221
const_reference front() const 
# 222
{ 
# 223
; 
# 224
return (c).front(); 
# 225
} 
# 232
reference back() 
# 233
{ 
# 234
; 
# 235
return (c).back(); 
# 236
} 
# 243
const_reference back() const 
# 244
{ 
# 245
; 
# 246
return (c).back(); 
# 247
} 
# 259 "/usr/include/c++/9/bits/stl_queue.h" 3
void push(const value_type &__x) 
# 260
{ (c).push_back(__x); } 
# 264
void push(value_type &&__x) 
# 265
{ (c).push_back(std::move(__x)); } 
# 273
template< class ..._Args> void 
# 275
emplace(_Args &&...__args) 
# 276
{ (c).emplace_back(std::forward< _Args> (__args)...); } 
# 292 "/usr/include/c++/9/bits/stl_queue.h" 3
void pop() 
# 293
{ 
# 294
; 
# 295
(c).pop_front(); 
# 296
} 
# 300
void swap(queue &__q) noexcept(__is_nothrow_swappable< _Sequence> ::value) 
# 306
{ 
# 307
using std::swap;
# 308
swap(c, __q.c); 
# 309
} 
# 311
}; 
# 336 "/usr/include/c++/9/bits/stl_queue.h" 3
template< class _Tp, class _Seq> inline bool 
# 338
operator==(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 339
{ return (__x.c) == (__y.c); } 
# 354 "/usr/include/c++/9/bits/stl_queue.h" 3
template< class _Tp, class _Seq> inline bool 
# 356
operator<(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 357
{ return (__x.c) < (__y.c); } 
# 360
template< class _Tp, class _Seq> inline bool 
# 362
operator!=(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 363
{ return !(__x == __y); } 
# 366
template< class _Tp, class _Seq> inline bool 
# 368
operator>(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 369
{ return __y < __x; } 
# 372
template< class _Tp, class _Seq> inline bool 
# 374
operator<=(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 375
{ return !(__y < __x); } 
# 378
template< class _Tp, class _Seq> inline bool 
# 380
operator>=(const queue< _Tp, _Seq>  &__x, const queue< _Tp, _Seq>  &__y) 
# 381
{ return !(__x < __y); } 
# 384
template< class _Tp, class _Seq> inline typename enable_if< __is_swappable< _Seq> ::value> ::type 
# 392
swap(queue< _Tp, _Seq>  &__x, queue< _Tp, _Seq>  &__y) noexcept(noexcept(__x.swap(__y))) 
# 394
{ __x.swap(__y); } 
# 396
template< class _Tp, class _Seq, class _Alloc> 
# 397
struct uses_allocator< queue< _Tp, _Seq> , _Alloc>  : public std::uses_allocator< _Seq, _Alloc> ::type { 
# 398
}; 
# 441 "/usr/include/c++/9/bits/stl_queue.h" 3
template< class _Tp, class _Sequence = vector< _Tp> , class 
# 442
_Compare = less< typename _Sequence::value_type> > 
# 443
class priority_queue { 
# 459 "/usr/include/c++/9/bits/stl_queue.h" 3
template< class _Alloc> using _Uses = typename enable_if< uses_allocator< _Sequence, _Alloc> ::value> ::type; 
# 473 "/usr/include/c++/9/bits/stl_queue.h" 3
public: typedef typename _Sequence::value_type value_type; 
# 474
typedef typename _Sequence::reference reference; 
# 475
typedef typename _Sequence::const_reference const_reference; 
# 476
typedef typename _Sequence::size_type size_type; 
# 477
typedef _Sequence container_type; 
# 480
typedef _Compare value_compare; 
# 484
protected: _Sequence c; 
# 485
_Compare comp; 
# 501 "/usr/include/c++/9/bits/stl_queue.h" 3
public: 
# 498
template< class _Seq = _Sequence, class _Requires = typename enable_if< __and_< is_default_constructible< _Compare> , is_default_constructible< _Seq> > ::value> ::type> 
# 501
priority_queue() : c(), comp() 
# 502
{ } 
# 505
explicit priority_queue(const _Compare &__x, const _Sequence &__s) : c(__s), comp(__x) 
# 507
{ std::make_heap((c).begin(), (c).end(), comp); } 
# 510
explicit priority_queue(const _Compare &__x, _Sequence &&__s = _Sequence()) : c(std::move(__s)), comp(__x) 
# 512
{ std::make_heap((c).begin(), (c).end(), comp); } 
# 514
template< class _Alloc, class _Requires = _Uses< _Alloc> > explicit 
# 516
priority_queue(const _Alloc &__a) : c(__a), comp() 
# 517
{ } 
# 519
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 520
priority_queue(const _Compare &__x, const _Alloc &__a) : c(__a), comp(__x) 
# 521
{ } 
# 525
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 526
priority_queue(const _Compare &__x, const _Sequence &__c, const _Alloc &
# 527
__a) : c(__c, __a), comp(__x) 
# 529
{ std::make_heap((c).begin(), (c).end(), comp); } 
# 531
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 532
priority_queue(const _Compare &__x, _Sequence &&__c, const _Alloc &__a) : c(std::move(__c), __a), comp(__x) 
# 534
{ std::make_heap((c).begin(), (c).end(), comp); } 
# 536
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 537
priority_queue(const priority_queue &__q, const _Alloc &__a) : c(__q.c, __a), comp(__q.comp) 
# 538
{ } 
# 540
template< class _Alloc, class _Requires = _Uses< _Alloc> > 
# 541
priority_queue(priority_queue &&__q, const _Alloc &__a) : c(std::move(__q.c), __a), comp(std::move(__q.comp)) 
# 542
{ } 
# 572 "/usr/include/c++/9/bits/stl_queue.h" 3
template< class _InputIterator> 
# 573
priority_queue(_InputIterator __first, _InputIterator __last, const _Compare &
# 574
__x, const _Sequence &
# 575
__s) : c(__s), comp(__x) 
# 577
{ 
# 578
; 
# 579
(c).insert((c).end(), __first, __last); 
# 580
std::make_heap((c).begin(), (c).end(), comp); 
# 581
} 
# 583
template< class _InputIterator> 
# 584
priority_queue(_InputIterator __first, _InputIterator __last, const _Compare &
# 585
__x = _Compare(), _Sequence &&
# 586
__s = _Sequence()) : c(std::move(__s)), comp(__x) 
# 588
{ 
# 589
; 
# 590
(c).insert((c).end(), __first, __last); 
# 591
std::make_heap((c).begin(), (c).end(), comp); 
# 592
} 
# 599
bool empty() const 
# 600
{ return (c).empty(); } 
# 604
size_type size() const 
# 605
{ return (c).size(); } 
# 612
const_reference top() const 
# 613
{ 
# 614
; 
# 615
return (c).front(); 
# 616
} 
# 627 "/usr/include/c++/9/bits/stl_queue.h" 3
void push(const value_type &__x) 
# 628
{ 
# 629
(c).push_back(__x); 
# 630
std::push_heap((c).begin(), (c).end(), comp); 
# 631
} 
# 635
void push(value_type &&__x) 
# 636
{ 
# 637
(c).push_back(std::move(__x)); 
# 638
std::push_heap((c).begin(), (c).end(), comp); 
# 639
} 
# 641
template< class ..._Args> void 
# 643
emplace(_Args &&...__args) 
# 644
{ 
# 645
(c).emplace_back(std::forward< _Args> (__args)...); 
# 646
std::push_heap((c).begin(), (c).end(), comp); 
# 647
} 
# 662 "/usr/include/c++/9/bits/stl_queue.h" 3
void pop() 
# 663
{ 
# 664
; 
# 665
std::pop_heap((c).begin(), (c).end(), comp); 
# 666
(c).pop_back(); 
# 667
} 
# 671
void swap(priority_queue &__pq) noexcept(__and_< __is_nothrow_swappable< _Sequence> , __is_nothrow_swappable< _Compare> > ::value) 
# 680
{ 
# 681
using std::swap;
# 682
swap(c, __pq.c); 
# 683
swap(comp, __pq.comp); 
# 684
} 
# 686
}; 
# 717 "/usr/include/c++/9/bits/stl_queue.h" 3
template< class _Tp, class _Sequence, class _Compare> inline typename enable_if< __and_< __is_swappable< _Sequence> , __is_swappable< _Compare> > ::value> ::type 
# 726
swap(priority_queue< _Tp, _Sequence, _Compare>  &__x, priority_queue< _Tp, _Sequence, _Compare>  &
# 727
__y) noexcept(noexcept(__x.swap(__y))) 
# 729
{ __x.swap(__y); } 
# 731
template< class _Tp, class _Sequence, class _Compare, class 
# 732
_Alloc> 
# 733
struct uses_allocator< priority_queue< _Tp, _Sequence, _Compare> , _Alloc>  : public std::uses_allocator< _Sequence, _Alloc> ::type { 
# 734
}; 
# 738
}
# 52 "/usr/include/opencv4/opencv2/stitching/detail/util_inl.hpp" 3
namespace cv { 
# 53
namespace detail { 
# 55
template< class B> B 
# 56
Graph::forEach(B body) const 
# 57
{ 
# 58
for (int i = 0; i < this->numVertices(); ++i) 
# 59
{ 
# 60
std::__cxx11::list< GraphEdge> ::const_iterator edge = (edges_)[i].begin(); 
# 61
for (; (edge != ((edges_)[i].end())); (++edge)) { 
# 62
body((*edge)); }  
# 63
}  
# 64
return body; 
# 65
} 
# 68
template< class B> B 
# 69
Graph::walkBreadthFirst(int from, B body) const 
# 70
{ 
# 71
std::vector< bool>  was(this->numVertices(), false); 
# 72
std::queue< int>  vertices; 
# 74
((was[from]) = (true)); 
# 75
vertices.push(from); 
# 77
while (!vertices.empty()) 
# 78
{ 
# 79
int vertex = vertices.front(); 
# 80
vertices.pop(); 
# 82
std::__cxx11::list< GraphEdge> ::const_iterator edge = (edges_)[vertex].begin(); 
# 83
for (; (edge != ((edges_)[vertex].end())); (++edge)) 
# 84
{ 
# 85
if (!was[edge->to]) 
# 86
{ 
# 87
body((*edge)); 
# 88
((was[edge->to]) = (true)); 
# 89
vertices.push(edge->to); 
# 90
}  
# 91
}  
# 92
}  
# 94
return body; 
# 95
} 
# 102
static inline float normL2(const Point3f &a) 
# 103
{ 
# 104
return (((a.x) * (a.x)) + ((a.y) * (a.y))) + ((a.z) * (a.z)); 
# 105
} 
# 109
static inline float normL2(const Point3f &a, const Point3f &b) 
# 110
{ 
# 111
return normL2((a - b)); 
# 112
} 
# 116
static inline double normL2sq(const Mat &r) 
# 117
{ 
# 118
return r.dot(r); 
# 119
} 
# 122
static inline int sqr(int x) { return x * x; } 
# 123
static inline float sqr(float x) { return x * x; } 
# 124
static inline double sqr(double x) { return x * x; } 
# 126
}
# 127
}
# 48 "/usr/include/opencv4/opencv2/stitching/detail/camera.hpp" 3
namespace cv { 
# 49
namespace detail { 
# 58 "/usr/include/opencv4/opencv2/stitching/detail/camera.hpp" 3
struct CameraParams { 
# 60
CameraParams(); 
# 61
CameraParams(const CameraParams & other); 
# 62
CameraParams &operator=(const CameraParams & other); 
# 63
Mat K() const; 
# 65
double focal; 
# 66
double aspect; 
# 67
double ppx; 
# 68
double ppy; 
# 69
Mat R; 
# 70
Mat t; 
# 71
}; 
# 75
}
# 76
}
# 51 "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp" 3
namespace cv { 
# 52
namespace detail { 
# 65 "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp" 3
class Estimator { 
# 68
public: virtual ~Estimator() { } 
# 77 "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp" 3
bool operator()(const std::vector< ImageFeatures>  &features, const std::vector< MatchesInfo>  &
# 78
pairwise_matches, std::vector< CameraParams>  &
# 79
cameras) 
# 80
{ 
# 81
return this->estimate(features, pairwise_matches, cameras); 
# 82
} 
# 93 "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp" 3
protected: virtual bool estimate(const std::vector< ImageFeatures>  & features, const std::vector< MatchesInfo>  & pairwise_matches, std::vector< CameraParams>  & cameras) = 0; 
# 96
}; 
# 100
class HomographyBasedEstimator : public Estimator { 
# 103
public: HomographyBasedEstimator(bool is_focals_estimated = false) : is_focals_estimated_(is_focals_estimated) 
# 104
{ } 
# 107
private: virtual bool estimate(const std::vector< ImageFeatures>  & features, const std::vector< MatchesInfo>  & pairwise_matches, std::vector< CameraParams>  & cameras) override; 
# 111
bool is_focals_estimated_; 
# 112
}; 
# 121 "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp" 3
class AffineBasedEstimator : public Estimator { 
# 124
public: AffineBasedEstimator() { } 
# 126
private: virtual bool estimate(const std::vector< ImageFeatures>  & features, const std::vector< MatchesInfo>  & pairwise_matches, std::vector< CameraParams>  & cameras) override; 
# 129
}; 
# 133
class BundleAdjusterBase : public Estimator { 
# 136
public: const Mat refinementMask() const { return (refinement_mask_).clone(); } 
# 137
void setRefinementMask(const Mat &mask) 
# 138
{ 
# 139
do { if (!(!((mask.type() == 0) && (((mask.size)()) == Size(3, 3))))) { ; } else { cv::error(cv::Error::StsAssert, "mask.type() == CV_8U && mask.size() == Size(3, 3)", __func__, "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp", 139); }  } while (0); 
# 140
((refinement_mask_) = (mask.clone())); 
# 141
} 
# 143
double confThresh() const { return conf_thresh_; } 
# 144
void setConfThresh(double conf_thresh) { (conf_thresh_) = conf_thresh; } 
# 146
TermCriteria termCriteria() { return term_criteria_; } 
# 147
void setTermCriteria(const TermCriteria &term_criteria) { (term_criteria_) = term_criteria; } 
# 155
protected: BundleAdjusterBase(int num_params_per_cam, int num_errs_per_measurement) : num_images_(0), total_num_matches_(0), num_params_per_cam_(num_params_per_cam), num_errs_per_measurement_(num_errs_per_measurement), features_((0)), pairwise_matches_((0)), conf_thresh_((0)) 
# 160
{ 
# 161
this->setRefinementMask((Mat::ones(3, 3, 0))); 
# 162
this->setConfThresh((1.0)); 
# 163
this->setTermCriteria(TermCriteria((TermCriteria::EPS) + (TermCriteria::COUNT), 1000, (double)(2.2204460492503130808E-16L))); 
# 164
} 
# 167
virtual bool estimate(const std::vector< ImageFeatures>  & features, const std::vector< MatchesInfo>  & pairwise_matches, std::vector< CameraParams>  & cameras) override; 
# 175
virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras) = 0; 
# 180
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const = 0; 
# 185
virtual void calcError(Mat & err) = 0; 
# 191
virtual void calcJacobian(Mat & jac) = 0; 
# 194
Mat refinement_mask_; 
# 196
int num_images_; 
# 197
int total_num_matches_; 
# 199
int num_params_per_cam_; 
# 200
int num_errs_per_measurement_; 
# 202
const ImageFeatures *features_; 
# 203
const MatchesInfo *pairwise_matches_; 
# 206
double conf_thresh_; 
# 209
TermCriteria term_criteria_; 
# 212
Mat cam_params_; 
# 215
std::vector< std::pair< int, int> >  edges_; 
# 216
}; 
# 221
class NoBundleAdjuster : public BundleAdjusterBase { 
# 224
public: NoBundleAdjuster() : BundleAdjusterBase(0, 0) { } 
# 227
private: virtual bool estimate(const std::vector< ImageFeatures>  &, const std::vector< MatchesInfo>  &, std::vector< CameraParams>  &) override 
# 229
{ 
# 230
return true; 
# 231
} 
# 232
virtual void setUpInitialCameraParams(const std::vector< CameraParams>  &) override { } 
# 233
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  &) const override { } 
# 234
virtual void calcError(Mat &) override { } 
# 235
virtual void calcJacobian(Mat &) override { } 
# 236
}; 
# 245 "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp" 3
class BundleAdjusterReproj : public BundleAdjusterBase { 
# 248
public: BundleAdjusterReproj() : BundleAdjusterBase(7, 2) { } 
# 251
private: virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras) override; 
# 252
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const override; 
# 253
virtual void calcError(Mat & err) override; 
# 254
virtual void calcJacobian(Mat & jac) override; 
# 256
Mat err1_, err2_; 
# 257
}; 
# 265
class BundleAdjusterRay : public BundleAdjusterBase { 
# 268
public: BundleAdjusterRay() : BundleAdjusterBase(4, 3) { } 
# 271
private: virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras) override; 
# 272
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const override; 
# 273
virtual void calcError(Mat & err) override; 
# 274
virtual void calcJacobian(Mat & jac) override; 
# 276
Mat err1_, err2_; 
# 277
}; 
# 289 "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp" 3
class BundleAdjusterAffine : public BundleAdjusterBase { 
# 292
public: BundleAdjusterAffine() : BundleAdjusterBase(6, 2) { } 
# 295
private: virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras) override; 
# 296
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const override; 
# 297
virtual void calcError(Mat & err) override; 
# 298
virtual void calcJacobian(Mat & jac) override; 
# 300
Mat err1_, err2_; 
# 301
}; 
# 313 "/usr/include/opencv4/opencv2/stitching/detail/motion_estimators.hpp" 3
class BundleAdjusterAffinePartial : public BundleAdjusterBase { 
# 316
public: BundleAdjusterAffinePartial() : BundleAdjusterBase(4, 2) { } 
# 319
private: virtual void setUpInitialCameraParams(const std::vector< CameraParams>  & cameras) override; 
# 320
virtual void obtainRefinedCameraParams(std::vector< CameraParams>  & cameras) const override; 
# 321
virtual void calcError(Mat & err) override; 
# 322
virtual void calcJacobian(Mat & jac) override; 
# 324
Mat err1_, err2_; 
# 325
}; 
# 328
enum WaveCorrectKind { 
# 330
WAVE_CORRECT_HORIZ, 
# 331
WAVE_CORRECT_VERT
# 332
}; 
# 339
void waveCorrect(std::vector< Mat>  & rmats, WaveCorrectKind kind); 
# 346
String matchesGraphAsString(std::vector< std::__cxx11::basic_string< char> >  & pathes, std::vector< MatchesInfo>  & pairwise_matches, float conf_threshold); 
# 349
std::vector< int>  leaveBiggestComponent(std::vector< ImageFeatures>  & features, std::vector< MatchesInfo>  & pairwise_matches, float conf_threshold); 
# 354
void findMaxSpanningTree(int num_images, const std::vector< MatchesInfo>  & pairwise_matches, Graph & span_tree, std::vector< int>  & centers); 
# 360
}
# 361
}
# 52 "/usr/include/opencv4/opencv2/stitching/detail/exposure_compensate.hpp" 3
namespace cv { 
# 53
namespace detail { 
# 60
class ExposureCompensator { 
# 63
public: ExposureCompensator() : updateGain(true) { } 
# 64
virtual ~ExposureCompensator() { } 
# 66
enum { NO, GAIN, GAIN_BLOCKS, CHANNELS, CHANNELS_BLOCKS}; 
# 67
static Ptr< ExposureCompensator>  createDefault(int type); 
# 75
void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< UMat>  & masks); 
# 78
virtual void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks) = 0; 
# 87
virtual void apply(int index, Point corner, InputOutputArray image, InputArray mask) = 0; 
# 88
virtual void getMatGains(std::vector< Mat>  &) { cv::error(Error::StsInternal, "", __func__, "/usr/include/opencv4/opencv2/stitching/detail/exposure_compensate.hpp", 88); } 
# 89
virtual void setMatGains(std::vector< Mat>  &) { cv::error(Error::StsInternal, "", __func__, "/usr/include/opencv4/opencv2/stitching/detail/exposure_compensate.hpp", 89); } 
# 90
void setUpdateGain(bool b) { (updateGain) = b; } 
# 91
bool getUpdateGain() { return updateGain; } 
# 93
protected: bool updateGain; 
# 94
}; 
# 98
class NoExposureCompensator : public ExposureCompensator { 
# 101
public: virtual void feed(const std::vector< Point_< int> >  &, const std::vector< UMat>  &, const std::vector< std::pair< UMat, unsigned char> >  &) override 
# 102
{ } 
# 103
virtual void apply(int, Point, InputOutputArray, InputArray) override { } 
# 104
virtual void getMatGains(std::vector< Mat>  &umv) override { umv.clear(); } 
# 105
virtual void setMatGains(std::vector< Mat>  &umv) override { umv.clear(); } 
# 106
}; 
# 111
class GainCompensator : public ExposureCompensator { 
# 115
public: GainCompensator() : GainCompensator(1) 
# 116
{ } 
# 117
GainCompensator(int nr_feeds) : nr_feeds_(nr_feeds) 
# 118
{ } 
# 119
virtual void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks) override; 
# 121
void singleFeed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks); 
# 123
virtual void apply(int index, Point corner, InputOutputArray image, InputArray mask) override; 
# 124
virtual void getMatGains(std::vector< Mat>  & umv) override; 
# 125
virtual void setMatGains(std::vector< Mat>  & umv) override; 
# 126
void setNrFeeds(int nr_feeds) { (nr_feeds_) = nr_feeds; } 
# 127
int getNrFeeds() { return nr_feeds_; } 
# 128
std::vector< double>  gains() const; 
# 131
private: Mat_< double>  gains_; 
# 132
int nr_feeds_; 
# 133
}; 
# 138
class ChannelsCompensator : public ExposureCompensator { 
# 141
public: ChannelsCompensator(int nr_feeds = 1) : nr_feeds_(nr_feeds) { } 
# 142
virtual void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks) override; 
# 144
virtual void apply(int index, Point corner, InputOutputArray image, InputArray mask) override; 
# 145
virtual void getMatGains(std::vector< Mat>  & umv) override; 
# 146
virtual void setMatGains(std::vector< Mat>  & umv) override; 
# 147
void setNrFeeds(int nr_feeds) { (nr_feeds_) = nr_feeds; } 
# 148
int getNrFeeds() { return nr_feeds_; } 
# 149
std::vector< Scalar_< double> >  gains() const { return gains_; } 
# 152
private: std::vector< Scalar_< double> >  gains_; 
# 153
int nr_feeds_; 
# 154
}; 
# 158
class BlocksCompensator : public ExposureCompensator { 
# 161
public: BlocksCompensator(int bl_width = 32, int bl_height = 32, int nr_feeds = 1) : bl_width_(bl_width), bl_height_(bl_height), nr_feeds_(nr_feeds), nr_gain_filtering_iterations_(2) 
# 162
{ } 
# 163
virtual void apply(int index, Point corner, InputOutputArray image, InputArray mask) override; 
# 164
virtual void getMatGains(std::vector< Mat>  & umv) override; 
# 165
virtual void setMatGains(std::vector< Mat>  & umv) override; 
# 166
void setNrFeeds(int nr_feeds) { (nr_feeds_) = nr_feeds; } 
# 167
int getNrFeeds() { return nr_feeds_; } 
# 168
void setBlockSize(int width, int height) { (bl_width_) = width; (bl_height_) = height; } 
# 169
void setBlockSize(Size size) { this->setBlockSize(size.width, size.height); } 
# 170
Size getBlockSize() const { return Size(bl_width_, bl_height_); } 
# 171
void setNrGainsFilteringIterations(int nr_iterations) { (nr_gain_filtering_iterations_) = nr_iterations; } 
# 172
int getNrGainsFilteringIterations() const { return nr_gain_filtering_iterations_; } 
# 175
protected: template< class Compensator> void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks); 
# 180
private: UMat getGainMap(const GainCompensator & compensator, int bl_idx, Size bl_per_img); 
# 181
UMat getGainMap(const ChannelsCompensator & compensator, int bl_idx, Size bl_per_img); 
# 183
int bl_width_, bl_height_; 
# 184
std::vector< UMat>  gain_maps_; 
# 185
int nr_feeds_; 
# 186
int nr_gain_filtering_iterations_; 
# 187
}; 
# 192
class BlocksGainCompensator : public BlocksCompensator { 
# 196
public: BlocksGainCompensator(int bl_width = 32, int bl_height = 32) : BlocksGainCompensator(bl_width, bl_height, 1) 
# 197
{ } 
# 198
BlocksGainCompensator(int bl_width, int bl_height, int nr_feeds) : BlocksCompensator(bl_width, bl_height, nr_feeds) 
# 199
{ } 
# 201
virtual void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks) override; 
# 205
virtual void apply(int index, Point corner, InputOutputArray image, InputArray mask) override { 
# 206
this->BlocksCompensator::apply(index, corner, image, mask); } 
# 208
virtual void getMatGains(std::vector< Mat>  &umv) override { this->BlocksCompensator::getMatGains(umv); } 
# 210
virtual void setMatGains(std::vector< Mat>  &umv) override { this->BlocksCompensator::setMatGains(umv); } 
# 211
}; 
# 216
class BlocksChannelsCompensator : public BlocksCompensator { 
# 219
public: BlocksChannelsCompensator(int bl_width = 32, int bl_height = 32, int nr_feeds = 1) : BlocksCompensator(bl_width, bl_height, nr_feeds) 
# 220
{ } 
# 222
virtual void feed(const std::vector< Point_< int> >  & corners, const std::vector< UMat>  & images, const std::vector< std::pair< UMat, unsigned char> >  & masks) override; 
# 224
}; 
# 227
}
# 228
}
# 50 "/usr/include/opencv4/opencv2/stitching/detail/seam_finders.hpp" 3
namespace cv { 
# 51
namespace detail { 
# 58
class SeamFinder { 
# 61
public: virtual ~SeamFinder() { } 
# 62
enum { NO, VORONOI_SEAM, DP_SEAM}; 
# 69
virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks) = 0; 
# 71
static Ptr< SeamFinder>  createDefault(int type); 
# 72
}; 
# 76
class NoSeamFinder : public SeamFinder { 
# 79
public: virtual void find(const std::vector< UMat>  &, const std::vector< Point_< int> >  &, std::vector< UMat>  &) override { } 
# 80
}; 
# 84
class PairwiseSeamFinder : public SeamFinder { 
# 87
public: virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks) override; 
# 91
protected: void run(); 
# 98
virtual void findInPair(size_t first, size_t second, Rect roi) = 0; 
# 100
std::vector< UMat>  images_; 
# 101
std::vector< Size_< int> >  sizes_; 
# 102
std::vector< Point_< int> >  corners_; 
# 103
std::vector< UMat>  masks_; 
# 104
}; 
# 108
class VoronoiSeamFinder : public PairwiseSeamFinder { 
# 111
public: virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks) override; 
# 113
virtual void find(const std::vector< Size_< int> >  & size, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks); 
# 116
private: virtual void findInPair(size_t first, size_t second, Rect roi) override; 
# 117
}; 
# 120
class DpSeamFinder : public SeamFinder { 
# 123
public: enum CostFunction { COLOR, COLOR_GRAD}; 
# 125
DpSeamFinder(CostFunction costFunc = COLOR); 
# 126
DpSeamFinder(String costFunc); 
# 128
CostFunction costFunction() const { return costFunc_; } 
# 129
void setCostFunction(CostFunction val) { (costFunc_) = val; } 
# 130
void setCostFunction(String val); 
# 132
virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks) override; 
# 136
private: enum ComponentState { 
# 138
FIRST = 1, SECOND, INTERS = 4, 
# 139
INTERS_FIRST, 
# 140
INTERS_SECOND
# 141
}; 
# 143
class ImagePairLess { 
# 146
public: ImagePairLess(const std::vector< Mat>  &images, const std::vector< Point_< int> >  &corners) : src_(&images[0]), corners_(&corners[0]) 
# 147
{ } 
# 149
bool operator()(const std::pair< unsigned long, unsigned long>  &l, const std::pair< unsigned long, unsigned long>  &r) const 
# 150
{ 
# 151
Point c1 = (((corners_)[l.first]) + Point((((src_)[l.first]).cols) / 2, (((src_)[l.first]).rows) / 2)); 
# 152
Point c2 = (((corners_)[l.second]) + Point((((src_)[l.second]).cols) / 2, (((src_)[l.second]).rows) / 2)); 
# 153
int d1 = ((c1 - c2)).dot((c1 - c2)); 
# 155
(c1 = ((((corners_)[r.first]) + Point((((src_)[r.first]).cols) / 2, (((src_)[r.first]).rows) / 2)))); 
# 156
(c2 = ((((corners_)[r.second]) + Point((((src_)[r.second]).cols) / 2, (((src_)[r.second]).rows) / 2)))); 
# 157
int d2 = ((c1 - c2)).dot((c1 - c2)); 
# 159
return d1 < d2; 
# 160
} 
# 163
private: const Mat *src_; 
# 164
const Point *corners_; 
# 165
}; 
# 167
class ClosePoints { 
# 170
public: ClosePoints(int minDist) : minDist_(minDist) { } 
# 172
bool operator()(const Point &p1, const Point &p2) const 
# 173
{ 
# 174
int dist2 = (((p1.x) - (p2.x)) * ((p1.x) - (p2.x))) + (((p1.y) - (p2.y)) * ((p1.y) - (p2.y))); 
# 175
return dist2 < ((minDist_) * (minDist_)); 
# 176
} 
# 179
private: int minDist_; 
# 180
}; 
# 182
void process(const Mat & image1, const Mat & image2, Point tl1, Point tl2, Mat & mask1, Mat & mask2); 
# 185
void findComponents(); 
# 187
void findEdges(); 
# 189
void resolveConflicts(const Mat & image1, const Mat & image2, Point tl1, Point tl2, Mat & mask1, Mat & mask2); 
# 192
void computeGradients(const Mat & image1, const Mat & image2); 
# 194
bool hasOnlyOneNeighbor(int comp); 
# 196
bool closeToContour(int y, int x, const Mat_< unsigned char>  & contourMask); 
# 198
bool getSeamTips(int comp1, int comp2, Point & p1, Point & p2); 
# 200
void computeCosts(const Mat & image1, const Mat & image2, Point tl1, Point tl2, int comp, Mat_< float>  & costV, Mat_< float>  & costH); 
# 204
bool estimateSeam(const Mat & image1, const Mat & image2, Point tl1, Point tl2, int comp, Point p1, Point p2, std::vector< Point_< int> >  & seam, bool & isHorizontal); 
# 208
void updateLabelsUsingSeam(int comp1, int comp2, const std::vector< Point_< int> >  & seam, bool isHorizontalSeam); 
# 211
CostFunction costFunc_; 
# 214
Point unionTl_, unionBr_; 
# 215
Size unionSize_; 
# 216
Mat_< unsigned char>  mask1_, mask2_; 
# 217
Mat_< unsigned char>  contour1mask_, contour2mask_; 
# 218
Mat_< float>  gradx1_, grady1_; 
# 219
Mat_< float>  gradx2_, grady2_; 
# 222
int ncomps_; 
# 223
Mat_< int>  labels_; 
# 224
std::vector< ComponentState>  states_; 
# 225
std::vector< Point_< int> >  tls_, brs_; 
# 226
std::vector< std::vector< Point_< int> > >  contours_; 
# 227
std::set< std::pair< int, int> >  edges_; 
# 228
}; 
# 232
class GraphCutSeamFinderBase { 
# 235
public: enum CostType { COST_COLOR, COST_COLOR_GRAD}; 
# 236
}; 
# 240
class GraphCutSeamFinder : public GraphCutSeamFinderBase, public SeamFinder { 
# 243
public: GraphCutSeamFinder(int cost_type = COST_COLOR_GRAD, float terminal_cost = (10000.0F), float bad_region_penalty = (1000.0F)); 
# 245
GraphCutSeamFinder(String cost_type, float terminal_cost = (10000.0F), float bad_region_penalty = (1000.0F)); 
# 248
virtual ~GraphCutSeamFinder(); 
# 250
virtual void find(const std::vector< UMat>  & src, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & masks) override; 
# 255
private: class Impl; 
# 256
Ptr< PairwiseSeamFinder>  impl_; 
# 257
}; 
# 288 "/usr/include/opencv4/opencv2/stitching/detail/seam_finders.hpp" 3
}
# 289
}
# 53 "/usr/include/opencv4/opencv2/stitching/detail/blenders.hpp" 3
namespace cv { 
# 54
namespace detail { 
# 63 "/usr/include/opencv4/opencv2/stitching/detail/blenders.hpp" 3
class Blender { 
# 66
public: virtual ~Blender() { } 
# 68
enum { NO, FEATHER, MULTI_BAND}; 
# 69
static Ptr< Blender>  createDefault(int type, bool try_gpu = false); 
# 76
virtual void prepare(const std::vector< Point_< int> >  & corners, const std::vector< Size_< int> >  & sizes); 
# 78
virtual void prepare(Rect dst_roi); 
# 85
virtual void feed(InputArray img, InputArray mask, Point tl); 
# 91
virtual void blend(InputOutputArray dst, InputOutputArray dst_mask); 
# 94
protected: UMat dst_, dst_mask_; 
# 95
Rect dst_roi_; 
# 96
}; 
# 100
class FeatherBlender : public Blender { 
# 103
public: inline FeatherBlender(float sharpness = (0.02F)); 
# 105
float sharpness() const { return sharpness_; } 
# 106
void setSharpness(float val) { (sharpness_) = val; } 
# 108
virtual void prepare(Rect dst_roi) override; 
# 109
virtual void feed(InputArray img, InputArray mask, Point tl) override; 
# 110
virtual void blend(InputOutputArray dst, InputOutputArray dst_mask) override; 
# 114
Rect createWeightMaps(const std::vector< UMat>  & masks, const std::vector< Point_< int> >  & corners, std::vector< UMat>  & weight_maps); 
# 118
private: float sharpness_; 
# 119
UMat weight_map_; 
# 120
UMat dst_weight_map_; 
# 121
}; 
# 123
inline FeatherBlender::FeatherBlender(float _sharpness) { this->setSharpness(_sharpness); } 
# 127
class MultiBandBlender : public Blender { 
# 130
public: MultiBandBlender(int try_gpu = false, int num_bands = 5, int weight_type = 5); 
# 132
int numBands() const { return actual_num_bands_; } 
# 133
void setNumBands(int val) { (actual_num_bands_) = val; } 
# 135
virtual void prepare(Rect dst_roi) override; 
# 136
virtual void feed(InputArray img, InputArray mask, Point tl) override; 
# 137
virtual void blend(InputOutputArray dst, InputOutputArray dst_mask) override; 
# 140
private: int actual_num_bands_, num_bands_; 
# 141
std::vector< UMat>  dst_pyr_laplace_; 
# 142
std::vector< UMat>  dst_band_weights_; 
# 143
Rect dst_roi_final_; 
# 144
bool can_use_gpu_; 
# 145
int weight_type_; 
# 162 "/usr/include/opencv4/opencv2/stitching/detail/blenders.hpp" 3
}; 
# 168
void normalizeUsingWeightMap(InputArray weight, InputOutputArray src); 
# 170
void createWeightMap(InputArray mask, float sharpness, InputOutputArray weight); 
# 172
void createLaplacePyr(InputArray img, int num_levels, std::vector< UMat>  & pyr); 
# 173
void createLaplacePyrGpu(InputArray img, int num_levels, std::vector< UMat>  & pyr); 
# 176
void restoreImageFromLaplacePyr(std::vector< UMat>  & pyr); 
# 177
void restoreImageFromLaplacePyrGpu(std::vector< UMat>  & pyr); 
# 181
}
# 182
}
# 107 "/usr/include/opencv4/opencv2/stitching.hpp" 3
namespace cv { 
# 138 "/usr/include/opencv4/opencv2/stitching.hpp" 3
class Stitcher { 
# 146
public: static constexpr double ORIG_RESOL = (-(1.0)); 
# 152
enum Status { 
# 154
OK, 
# 155
ERR_NEED_MORE_IMGS, 
# 156
ERR_HOMOGRAPHY_EST_FAIL, 
# 157
ERR_CAMERA_PARAMS_ADJUST_FAIL
# 158
}; 
# 160
enum Mode { 
# 167
PANORAMA, 
# 173
SCANS
# 175
}; 
# 184 "/usr/include/opencv4/opencv2/stitching.hpp" 3
static Ptr< Stitcher>  create(Mode mode = Stitcher::PANORAMA); 
# 186
double registrationResol() const { return registr_resol_; } 
# 187
void setRegistrationResol(double resol_mpx) { (registr_resol_) = resol_mpx; } 
# 189
double seamEstimationResol() const { return seam_est_resol_; } 
# 190
void setSeamEstimationResol(double resol_mpx) { (seam_est_resol_) = resol_mpx; } 
# 192
double compositingResol() const { return compose_resol_; } 
# 193
void setCompositingResol(double resol_mpx) { (compose_resol_) = resol_mpx; } 
# 195
double panoConfidenceThresh() const { return conf_thresh_; } 
# 196
void setPanoConfidenceThresh(double conf_thresh) { (conf_thresh_) = conf_thresh; } 
# 198
bool waveCorrection() const { return do_wave_correct_; } 
# 199
void setWaveCorrection(bool flag) { (do_wave_correct_) = flag; } 
# 201
InterpolationFlags interpolationFlags() const { return interp_flags_; } 
# 202
void setInterpolationFlags(InterpolationFlags interp_flags) { (interp_flags_) = interp_flags; } 
# 204
detail::WaveCorrectKind waveCorrectKind() const { return wave_correct_kind_; } 
# 205
void setWaveCorrectKind(detail::WaveCorrectKind kind) { (wave_correct_kind_) = kind; } 
# 207
Ptr< Feature2D>  featuresFinder() { return features_finder_; } 
# 208
const Ptr< Feature2D>  featuresFinder() const { return features_finder_; } 
# 209
void setFeaturesFinder(Ptr< Feature2D>  features_finder) 
# 210
{ ((features_finder_) = features_finder); } 
# 212
Ptr< detail::FeaturesMatcher>  featuresMatcher() { return features_matcher_; } 
# 213
const Ptr< detail::FeaturesMatcher>  featuresMatcher() const { return features_matcher_; } 
# 214
void setFeaturesMatcher(Ptr< detail::FeaturesMatcher>  features_matcher) 
# 215
{ ((features_matcher_) = features_matcher); } 
# 217
const UMat &matchingMask() const { return matching_mask_; } 
# 218
void setMatchingMask(const UMat &mask) 
# 219
{ 
# 220
do { if (!(!((mask.type() == 0) && ((mask.cols) == (mask.rows))))) { ; } else { cv::error(cv::Error::StsAssert, "mask.type() == CV_8U && mask.cols == mask.rows", __func__, "/usr/include/opencv4/opencv2/stitching.hpp", 220); }  } while (0); 
# 221
((matching_mask_) = (mask.clone())); 
# 222
} 
# 224
Ptr< detail::BundleAdjusterBase>  bundleAdjuster() { return bundle_adjuster_; } 
# 225
const Ptr< detail::BundleAdjusterBase>  bundleAdjuster() const { return bundle_adjuster_; } 
# 226
void setBundleAdjuster(Ptr< detail::BundleAdjusterBase>  bundle_adjuster) 
# 227
{ ((bundle_adjuster_) = bundle_adjuster); } 
# 229
Ptr< detail::Estimator>  estimator() { return estimator_; } 
# 230
const Ptr< detail::Estimator>  estimator() const { return estimator_; } 
# 231
void setEstimator(Ptr< detail::Estimator>  estimator) 
# 232
{ ((estimator_) = estimator); } 
# 234
Ptr< WarperCreator>  warper() { return warper_; } 
# 235
const Ptr< WarperCreator>  warper() const { return warper_; } 
# 236
void setWarper(Ptr< WarperCreator>  creator) { ((warper_) = creator); } 
# 238
Ptr< detail::ExposureCompensator>  exposureCompensator() { return exposure_comp_; } 
# 239
const Ptr< detail::ExposureCompensator>  exposureCompensator() const { return exposure_comp_; } 
# 240
void setExposureCompensator(Ptr< detail::ExposureCompensator>  exposure_comp) 
# 241
{ ((exposure_comp_) = exposure_comp); } 
# 243
Ptr< detail::SeamFinder>  seamFinder() { return seam_finder_; } 
# 244
const Ptr< detail::SeamFinder>  seamFinder() const { return seam_finder_; } 
# 245
void setSeamFinder(Ptr< detail::SeamFinder>  seam_finder) { ((seam_finder_) = seam_finder); } 
# 247
Ptr< detail::Blender>  blender() { return blender_; } 
# 248
const Ptr< detail::Blender>  blender() const { return blender_; } 
# 249
void setBlender(Ptr< detail::Blender>  b) { ((blender_) = b); } 
# 260 "/usr/include/opencv4/opencv2/stitching.hpp" 3
Status estimateTransform(InputArrayOfArrays images, InputArrayOfArrays masks = noArray()); 
# 263
Status composePanorama(OutputArray pano); 
# 275 "/usr/include/opencv4/opencv2/stitching.hpp" 3
Status composePanorama(InputArrayOfArrays images, OutputArray pano); 
# 278
Status stitch(InputArrayOfArrays images, OutputArray pano); 
# 286
Status stitch(InputArrayOfArrays images, InputArrayOfArrays masks, OutputArray pano); 
# 288
std::vector< int>  component() const { return indices_; } 
# 289
std::vector< detail::CameraParams>  cameras() const { return cameras_; } 
# 290
double workScale() const { return work_scale_; } 
# 291
UMat resultMask() const { return result_mask_; } 
# 294
private: Status matchImages(); 
# 295
Status estimateCameraParams(); 
# 297
double registr_resol_; 
# 298
double seam_est_resol_; 
# 299
double compose_resol_; 
# 300
double conf_thresh_; 
# 301
InterpolationFlags interp_flags_; 
# 302
Ptr< Feature2D>  features_finder_; 
# 303
Ptr< detail::FeaturesMatcher>  features_matcher_; 
# 304
UMat matching_mask_; 
# 305
Ptr< detail::BundleAdjusterBase>  bundle_adjuster_; 
# 306
Ptr< detail::Estimator>  estimator_; 
# 307
bool do_wave_correct_; 
# 308
detail::WaveCorrectKind wave_correct_kind_; 
# 309
Ptr< WarperCreator>  warper_; 
# 310
Ptr< detail::ExposureCompensator>  exposure_comp_; 
# 311
Ptr< detail::SeamFinder>  seam_finder_; 
# 312
Ptr< detail::Blender>  blender_; 
# 314
std::vector< UMat>  imgs_; 
# 315
std::vector< UMat>  masks_; 
# 316
std::vector< Size_< int> >  full_img_sizes_; 
# 317
std::vector< detail::ImageFeatures>  features_; 
# 318
std::vector< detail::MatchesInfo>  pairwise_matches_; 
# 319
std::vector< UMat>  seam_est_imgs_; 
# 320
std::vector< int>  indices_; 
# 321
std::vector< detail::CameraParams>  cameras_; 
# 322
UMat result_mask_; 
# 323
double work_scale_; 
# 324
double seam_scale_; 
# 325
double seam_work_aspect_; 
# 326
double warped_image_scale_; 
# 327
}; 
# 332
__attribute((deprecated)) Ptr< Stitcher>  createStitcher(bool try_use_gpu = false); 
# 337
__attribute((deprecated)) Ptr< Stitcher>  createStitcherScans(bool try_use_gpu = false); 
# 341
}
# 48 "/usr/include/opencv4/opencv2/superres/optical_flow.hpp" 3
namespace cv { 
# 50
namespace superres { 
# 56
class DenseOpticalFlowExt : public Algorithm { 
# 59
public: virtual void calc(InputArray frame0, InputArray frame1, OutputArray flow1, OutputArray flow2 = noArray()) = 0; 
# 60
virtual void collectGarbage() = 0; 
# 61
}; 
# 64
class FarnebackOpticalFlow : virtual public DenseOpticalFlowExt { 
# 68
public: virtual double getPyrScale() const = 0; 
# 70
virtual void setPyrScale(double val) = 0; 
# 72
virtual int getLevelsNumber() const = 0; 
# 74
virtual void setLevelsNumber(int val) = 0; 
# 76
virtual int getWindowSize() const = 0; 
# 78
virtual void setWindowSize(int val) = 0; 
# 80
virtual int getIterations() const = 0; 
# 82
virtual void setIterations(int val) = 0; 
# 84
virtual int getPolyN() const = 0; 
# 86
virtual void setPolyN(int val) = 0; 
# 88
virtual double getPolySigma() const = 0; 
# 90
virtual void setPolySigma(double val) = 0; 
# 92
virtual int getFlags() const = 0; 
# 94
virtual void setFlags(int val) = 0; 
# 95
}; 
# 96
Ptr< FarnebackOpticalFlow>  createOptFlow_Farneback(); 
# 97
Ptr< FarnebackOpticalFlow>  createOptFlow_Farneback_CUDA(); 
# 103
class DualTVL1OpticalFlow : virtual public DenseOpticalFlowExt { 
# 107
public: virtual double getTau() const = 0; 
# 109
virtual void setTau(double val) = 0; 
# 111
virtual double getLambda() const = 0; 
# 113
virtual void setLambda(double val) = 0; 
# 115
virtual double getTheta() const = 0; 
# 117
virtual void setTheta(double val) = 0; 
# 119
virtual int getScalesNumber() const = 0; 
# 121
virtual void setScalesNumber(int val) = 0; 
# 123
virtual int getWarpingsNumber() const = 0; 
# 125
virtual void setWarpingsNumber(int val) = 0; 
# 127
virtual double getEpsilon() const = 0; 
# 129
virtual void setEpsilon(double val) = 0; 
# 131
virtual int getIterations() const = 0; 
# 133
virtual void setIterations(int val) = 0; 
# 135
virtual bool getUseInitialFlow() const = 0; 
# 137
virtual void setUseInitialFlow(bool val) = 0; 
# 138
}; 
# 139
Ptr< DualTVL1OpticalFlow>  createOptFlow_DualTVL1(); 
# 140
Ptr< DualTVL1OpticalFlow>  createOptFlow_DualTVL1_CUDA(); 
# 143
class BroxOpticalFlow : virtual public DenseOpticalFlowExt { 
# 148
public: virtual double getAlpha() const = 0; 
# 150
virtual void setAlpha(double val) = 0; 
# 153
virtual double getGamma() const = 0; 
# 155
virtual void setGamma(double val) = 0; 
# 158
virtual double getScaleFactor() const = 0; 
# 160
virtual void setScaleFactor(double val) = 0; 
# 163
virtual int getInnerIterations() const = 0; 
# 165
virtual void setInnerIterations(int val) = 0; 
# 168
virtual int getOuterIterations() const = 0; 
# 170
virtual void setOuterIterations(int val) = 0; 
# 173
virtual int getSolverIterations() const = 0; 
# 175
virtual void setSolverIterations(int val) = 0; 
# 176
}; 
# 177
Ptr< BroxOpticalFlow>  createOptFlow_Brox_CUDA(); 
# 180
class PyrLKOpticalFlow : virtual public DenseOpticalFlowExt { 
# 184
public: virtual int getWindowSize() const = 0; 
# 186
virtual void setWindowSize(int val) = 0; 
# 188
virtual int getMaxLevel() const = 0; 
# 190
virtual void setMaxLevel(int val) = 0; 
# 192
virtual int getIterations() const = 0; 
# 194
virtual void setIterations(int val) = 0; 
# 195
}; 
# 196
Ptr< PyrLKOpticalFlow>  createOptFlow_PyrLK_CUDA(); 
# 200
}
# 201
}
# 58 "/usr/include/opencv4/opencv2/superres.hpp" 3
namespace cv { 
# 60
namespace superres { 
# 66
class FrameSource { 
# 69
public: virtual ~FrameSource(); 
# 71
virtual void nextFrame(OutputArray frame) = 0; 
# 72
virtual void reset() = 0; 
# 73
}; 
# 75
Ptr< FrameSource>  createFrameSource_Empty(); 
# 77
Ptr< FrameSource>  createFrameSource_Video(const String & fileName); 
# 78
Ptr< FrameSource>  createFrameSource_Video_CUDA(const String & fileName); 
# 80
Ptr< FrameSource>  createFrameSource_Camera(int deviceId = 0); 
# 87
class SuperResolution : public Algorithm, public FrameSource { 
# 94
public: void setInput(const Ptr< FrameSource>  & frameSource); 
# 100
virtual void nextFrame(OutputArray frame) override; 
# 101
virtual void reset() override; 
# 105
virtual void collectGarbage(); 
# 109
virtual int getScale() const = 0; 
# 111
virtual void setScale(int val) = 0; 
# 115
virtual int getIterations() const = 0; 
# 117
virtual void setIterations(int val) = 0; 
# 121
virtual double getTau() const = 0; 
# 123
virtual void setTau(double val) = 0; 
# 127
virtual double getLambda() const = 0; 
# 129
virtual void setLambda(double val) = 0; 
# 133
virtual double getAlpha() const = 0; 
# 135
virtual void setAlpha(double val) = 0; 
# 139
virtual int getKernelSize() const = 0; 
# 141
virtual void setKernelSize(int val) = 0; 
# 145
virtual int getBlurKernelSize() const = 0; 
# 147
virtual void setBlurKernelSize(int val) = 0; 
# 151
virtual double getBlurSigma() const = 0; 
# 153
virtual void setBlurSigma(double val) = 0; 
# 157
virtual int getTemporalAreaRadius() const = 0; 
# 159
virtual void setTemporalAreaRadius(int val) = 0; 
# 163
virtual Ptr< DenseOpticalFlowExt>  getOpticalFlow() const = 0; 
# 165
virtual void setOpticalFlow(const Ptr< DenseOpticalFlowExt>  & val) = 0; 
# 168
protected: SuperResolution(); 
# 170
virtual void initImpl(Ptr< FrameSource>  & frameSource) = 0; 
# 171
virtual void processImpl(Ptr< FrameSource>  & frameSource, OutputArray output) = 0; 
# 173
bool isUmat_; 
# 176
private: Ptr< FrameSource>  frameSource_; 
# 177
bool firstCall_; 
# 178
}; 
# 199 "/usr/include/opencv4/opencv2/superres.hpp" 3
Ptr< SuperResolution>  createSuperResolution_BTVL1(); 
# 200
Ptr< SuperResolution>  createSuperResolution_BTVL1_CUDA(); 
# 204
}
# 205
}
# 50 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
namespace cv { 
# 56
enum { OPTFLOW_USE_INITIAL_FLOW = 4, 
# 57
OPTFLOW_LK_GET_MIN_EIGENVALS = 8, 
# 58
OPTFLOW_FARNEBACK_GAUSSIAN = 256
# 59
}; 
# 79 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
RotatedRect CamShift(InputArray probImage, Rect & window, TermCriteria criteria); 
# 104 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
int meanShift(InputArray probImage, Rect & window, TermCriteria criteria); 
# 121 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives = true, int pyrBorder = BORDER_REFLECT_101, int derivBorder = BORDER_CONSTANT, bool tryReuseInputImage = true); 
# 178 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize = Size(21, 21), int maxLevel = 3, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (0.01)), int flags = 0, double minEigThreshold = (1.0E-4)); 
# 223 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
void calcOpticalFlowFarneback(InputArray prev, InputArray next, InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags); 
# 258 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
__attribute((deprecated)) Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine); 
# 261
enum { 
# 262
MOTION_TRANSLATION, 
# 263
MOTION_EUCLIDEAN, 
# 264
MOTION_AFFINE, 
# 265
MOTION_HOMOGRAPHY
# 266
}; 
# 279 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
double computeECC(InputArray templateImage, InputArray inputImage, InputArray inputMask = noArray()); 
# 336 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
double findTransformECC(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType, TermCriteria criteria, InputArray inputMask, int gaussFiltSize); 
# 343
double findTransformECC(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType = MOTION_AFFINE, TermCriteria criteria = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 50, (0.001)), InputArray inputMask = noArray()); 
# 360 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
class KalmanFilter { 
# 363
public: KalmanFilter(); 
# 370
KalmanFilter(int dynamParams, int measureParams, int controlParams = 0, int type = 5); 
# 379 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
void init(int dynamParams, int measureParams, int controlParams = 0, int type = 5); 
# 385
const Mat &predict(const Mat & control = Mat()); 
# 391
const Mat &correct(const Mat & measurement); 
# 393
Mat statePre; 
# 394
Mat statePost; 
# 395
Mat transitionMatrix; 
# 396
Mat controlMatrix; 
# 397
Mat measurementMatrix; 
# 398
Mat processNoiseCov; 
# 399
Mat measurementNoiseCov; 
# 400
Mat errorCovPre; 
# 401
Mat gain; 
# 402
Mat errorCovPost; 
# 405
Mat temp1; 
# 406
Mat temp2; 
# 407
Mat temp3; 
# 408
Mat temp4; 
# 409
Mat temp5; 
# 410
}; 
# 421 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
Mat readOpticalFlow(const String & path); 
# 431 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
bool writeOpticalFlow(const String & path, InputArray flow); 
# 436
class DenseOpticalFlow : public Algorithm { 
# 445
public: virtual void calc(InputArray I0, InputArray I1, InputOutputArray flow) = 0; 
# 448
virtual void collectGarbage() = 0; 
# 449
}; 
# 453
class SparseOpticalFlow : public Algorithm { 
# 466 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
public: virtual void calc(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err = cv::noArray()) = 0; 
# 470
}; 
# 475
class FarnebackOpticalFlow : public DenseOpticalFlow { 
# 478
public: virtual int getNumLevels() const = 0; 
# 479
virtual void setNumLevels(int numLevels) = 0; 
# 481
virtual double getPyrScale() const = 0; 
# 482
virtual void setPyrScale(double pyrScale) = 0; 
# 484
virtual bool getFastPyramids() const = 0; 
# 485
virtual void setFastPyramids(bool fastPyramids) = 0; 
# 487
virtual int getWinSize() const = 0; 
# 488
virtual void setWinSize(int winSize) = 0; 
# 490
virtual int getNumIters() const = 0; 
# 491
virtual void setNumIters(int numIters) = 0; 
# 493
virtual int getPolyN() const = 0; 
# 494
virtual void setPolyN(int polyN) = 0; 
# 496
virtual double getPolySigma() const = 0; 
# 497
virtual void setPolySigma(double polySigma) = 0; 
# 499
virtual int getFlags() const = 0; 
# 500
virtual void setFlags(int flags) = 0; 
# 502
static Ptr< FarnebackOpticalFlow>  create(int numLevels = 5, double pyrScale = (0.5), bool fastPyramids = false, int winSize = 13, int numIters = 10, int polyN = 5, double polySigma = (1.1), int flags = 0); 
# 511
}; 
# 523 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
class VariationalRefinement : public DenseOpticalFlow { 
# 528
public: virtual void calcUV(InputArray I0, InputArray I1, InputOutputArray flow_u, InputOutputArray flow_v) = 0; 
# 532
virtual int getFixedPointIterations() const = 0; 
# 534
virtual void setFixedPointIterations(int val) = 0; 
# 539
virtual int getSorIterations() const = 0; 
# 541
virtual void setSorIterations(int val) = 0; 
# 545
virtual float getOmega() const = 0; 
# 547
virtual void setOmega(float val) = 0; 
# 551
virtual float getAlpha() const = 0; 
# 553
virtual void setAlpha(float val) = 0; 
# 557
virtual float getDelta() const = 0; 
# 559
virtual void setDelta(float val) = 0; 
# 563
virtual float getGamma() const = 0; 
# 565
virtual void setGamma(float val) = 0; 
# 569
static Ptr< VariationalRefinement>  create(); 
# 570
}; 
# 584 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
class DISOpticalFlow : public DenseOpticalFlow { 
# 588
public: enum { 
# 589
PRESET_ULTRAFAST, 
# 590
PRESET_FAST, 
# 591
PRESET_MEDIUM
# 592
}; 
# 597
virtual int getFinestScale() const = 0; 
# 599
virtual void setFinestScale(int val) = 0; 
# 604
virtual int getPatchSize() const = 0; 
# 606
virtual void setPatchSize(int val) = 0; 
# 611
virtual int getPatchStride() const = 0; 
# 613
virtual void setPatchStride(int val) = 0; 
# 618
virtual int getGradientDescentIterations() const = 0; 
# 620
virtual void setGradientDescentIterations(int val) = 0; 
# 626
virtual int getVariationalRefinementIterations() const = 0; 
# 628
virtual void setVariationalRefinementIterations(int val) = 0; 
# 632
virtual float getVariationalRefinementAlpha() const = 0; 
# 634
virtual void setVariationalRefinementAlpha(float val) = 0; 
# 638
virtual float getVariationalRefinementDelta() const = 0; 
# 640
virtual void setVariationalRefinementDelta(float val) = 0; 
# 644
virtual float getVariationalRefinementGamma() const = 0; 
# 646
virtual void setVariationalRefinementGamma(float val) = 0; 
# 654
virtual bool getUseMeanNormalization() const = 0; 
# 656
virtual void setUseMeanNormalization(bool val) = 0; 
# 663
virtual bool getUseSpatialPropagation() const = 0; 
# 665
virtual void setUseSpatialPropagation(bool val) = 0; 
# 671
static Ptr< DISOpticalFlow>  create(int preset = DISOpticalFlow::PRESET_FAST); 
# 672
}; 
# 682 "/usr/include/opencv4/opencv2/video/tracking.hpp" 3
class SparsePyrLKOpticalFlow : public SparseOpticalFlow { 
# 685
public: virtual Size getWinSize() const = 0; 
# 686
virtual void setWinSize(Size winSize) = 0; 
# 688
virtual int getMaxLevel() const = 0; 
# 689
virtual void setMaxLevel(int maxLevel) = 0; 
# 691
virtual TermCriteria getTermCriteria() const = 0; 
# 692
virtual void setTermCriteria(TermCriteria & crit) = 0; 
# 694
virtual int getFlags() const = 0; 
# 695
virtual void setFlags(int flags) = 0; 
# 697
virtual double getMinEigThreshold() const = 0; 
# 698
virtual void setMinEigThreshold(double minEigThreshold) = 0; 
# 700
static Ptr< SparsePyrLKOpticalFlow>  create(Size winSize = Size(21, 21), int maxLevel = 3, TermCriteria crit = TermCriteria((TermCriteria::COUNT) + (TermCriteria::EPS), 30, (0.01)), int flags = 0, double minEigThreshold = (1.0E-4)); 
# 706
}; 
# 710
}
# 49 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
namespace cv { 
# 60 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
class BackgroundSubtractor : public Algorithm { 
# 72 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
public: virtual void apply(InputArray image, OutputArray fgmask, double learningRate = -1) = 0; 
# 81 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
virtual void getBackgroundImage(OutputArray backgroundImage) const = 0; 
# 82
}; 
# 90
class BackgroundSubtractorMOG2 : public BackgroundSubtractor { 
# 95
public: virtual int getHistory() const = 0; 
# 98
virtual void setHistory(int history) = 0; 
# 102
virtual int getNMixtures() const = 0; 
# 107
virtual void setNMixtures(int nmixtures) = 0; 
# 115
virtual double getBackgroundRatio() const = 0; 
# 118
virtual void setBackgroundRatio(double ratio) = 0; 
# 125
virtual double getVarThreshold() const = 0; 
# 128
virtual void setVarThreshold(double varThreshold) = 0; 
# 138 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
virtual double getVarThresholdGen() const = 0; 
# 141
virtual void setVarThresholdGen(double varThresholdGen) = 0; 
# 145
virtual double getVarInit() const = 0; 
# 148
virtual void setVarInit(double varInit) = 0; 
# 150
virtual double getVarMin() const = 0; 
# 151
virtual void setVarMin(double varMin) = 0; 
# 153
virtual double getVarMax() const = 0; 
# 154
virtual void setVarMax(double varMax) = 0; 
# 162
virtual double getComplexityReductionThreshold() const = 0; 
# 165
virtual void setComplexityReductionThreshold(double ct) = 0; 
# 172
virtual bool getDetectShadows() const = 0; 
# 175
virtual void setDetectShadows(bool detectShadows) = 0; 
# 182
virtual int getShadowValue() const = 0; 
# 185
virtual void setShadowValue(int value) = 0; 
# 194 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
virtual double getShadowThreshold() const = 0; 
# 197
virtual void setShadowThreshold(double threshold) = 0; 
# 208 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
virtual void apply(InputArray image, OutputArray fgmask, double learningRate = -1) override = 0; 
# 209
}; 
# 221 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
Ptr< BackgroundSubtractorMOG2>  createBackgroundSubtractorMOG2(int history = 500, double varThreshold = 16, bool detectShadows = true); 
# 229
class BackgroundSubtractorKNN : public BackgroundSubtractor { 
# 234
public: virtual int getHistory() const = 0; 
# 237
virtual void setHistory(int history) = 0; 
# 241
virtual int getNSamples() const = 0; 
# 246
virtual void setNSamples(int _nN) = 0; 
# 253
virtual double getDist2Threshold() const = 0; 
# 256
virtual void setDist2Threshold(double _dist2Threshold) = 0; 
# 263
virtual int getkNNSamples() const = 0; 
# 266
virtual void setkNNSamples(int _nkNN) = 0; 
# 273
virtual bool getDetectShadows() const = 0; 
# 276
virtual void setDetectShadows(bool detectShadows) = 0; 
# 283
virtual int getShadowValue() const = 0; 
# 286
virtual void setShadowValue(int value) = 0; 
# 295 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
virtual double getShadowThreshold() const = 0; 
# 298
virtual void setShadowThreshold(double threshold) = 0; 
# 299
}; 
# 310 "/usr/include/opencv4/opencv2/video/background_segm.hpp" 3
Ptr< BackgroundSubtractorKNN>  createBackgroundSubtractorKNN(int history = 500, double dist2Threshold = (400.0), bool detectShadows = true); 
# 315
}
# 38 "/usr/include/x86_64-linux-gnu/c++/9/bits/c++io.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 42
typedef __gthread_mutex_t __c_lock; 
# 45
typedef FILE __c_file; 
# 48
}
# 44 "/usr/include/x86_64-linux-gnu/c++/9/bits/basic_file.h" 3
namespace std __attribute((__visibility__("default"))) { 
# 49
template< class _CharT> class __basic_file; 
# 54
template<> class __basic_file< char>  { 
# 57
__c_file *_M_cfile; 
# 60
bool _M_cfile_created; 
# 63
public: __basic_file(__c_lock * __lock = 0) throw(); 
# 66
__basic_file(std::__basic_file< char>  &&__rv, __c_lock * = 0) noexcept : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created) 
# 68
{ 
# 69
(__rv._M_cfile) = (nullptr); 
# 70
(__rv._M_cfile_created) = false; 
# 71
} 
# 73
std::__basic_file< char>  &operator=(const std::__basic_file< char>  &) = delete;
# 74
std::__basic_file< char>  &operator=(std::__basic_file< char>  &&) = delete;
# 77
void swap(std::__basic_file< char>  &__f) noexcept 
# 78
{ 
# 79
std::swap(_M_cfile, __f._M_cfile); 
# 80
std::swap(_M_cfile_created, __f._M_cfile_created); 
# 81
} 
# 85
std::__basic_file< char>  *open(const char * __name, ios_base::openmode __mode, int __prot = 436); 
# 93
std::__basic_file< char>  *sys_open(__c_file * __file, ios_base::openmode); 
# 96
std::__basic_file< char>  *sys_open(int __fd, ios_base::openmode __mode) throw(); 
# 99
std::__basic_file< char>  *close(); 
# 101
__attribute((__pure__)) bool 
# 102
is_open() const throw(); 
# 104
__attribute((__pure__)) int 
# 105
fd() throw(); 
# 107
__attribute((__pure__)) __c_file *
# 108
file() throw(); 
# 110
~__basic_file(); 
# 113
streamsize xsputn(const char * __s, streamsize __n); 
# 116
streamsize xsputn_2(const char * __s1, streamsize __n1, const char * __s2, streamsize __n2); 
# 120
streamsize xsgetn(char * __s, streamsize __n); 
# 123
streamoff seekoff(streamoff __off, ios_base::seekdir __way) throw(); 
# 126
int sync(); 
# 129
streamsize showmanyc(); 
# 130
}; 
# 133
}
# 47 "/usr/include/c++/9/fstream" 3
namespace std __attribute((__visibility__("default"))) { 
# 79 "/usr/include/c++/9/fstream" 3
template< class _CharT, class _Traits> 
# 80
class basic_filebuf : public basic_streambuf< _CharT, _Traits>  { 
# 83
template< class _Tp> using __chk_state = __and_< is_copy_assignable< _Tp> , is_copy_constructible< _Tp> , is_default_constructible< _Tp> > ; 
# 88
static_assert((__chk_state< typename _Traits::state_type> ::value), "state_type must be CopyAssignable, CopyConstructible and DefaultConstructible");
# 92
static_assert((is_same< typename _Traits::pos_type, fpos< typename _Traits::state_type> > ::value), "pos_type must be fpos<state_type>");
# 98
public: typedef _CharT char_type; 
# 99
typedef _Traits traits_type; 
# 100
typedef typename _Traits::int_type int_type; 
# 101
typedef typename _Traits::pos_type pos_type; 
# 102
typedef typename _Traits::off_type off_type; 
# 104
typedef basic_streambuf< _CharT, _Traits>  __streambuf_type; 
# 105
typedef basic_filebuf __filebuf_type; 
# 106
typedef std::__basic_file< char>  __file_type; 
# 107
typedef typename _Traits::state_type __state_type; 
# 108
typedef codecvt< char_type, char, __state_type>  __codecvt_type; 
# 110
friend class ios_base; 
# 115
protected: std::__c_lock _M_lock; 
# 118
__file_type _M_file; 
# 121
std::ios_base::openmode _M_mode; 
# 124
__state_type _M_state_beg; 
# 129
__state_type _M_state_cur; 
# 133
__state_type _M_state_last; 
# 136
char_type *_M_buf; 
# 143
std::size_t _M_buf_size; 
# 146
bool _M_buf_allocated; 
# 155 "/usr/include/c++/9/fstream" 3
bool _M_reading; 
# 156
bool _M_writing; 
# 164
char_type _M_pback; 
# 165
char_type *_M_pback_cur_save; 
# 166
char_type *_M_pback_end_save; 
# 167
bool _M_pback_init; 
# 171
const __codecvt_type *_M_codecvt; 
# 178
char *_M_ext_buf; 
# 183
std::streamsize _M_ext_buf_size; 
# 190
const char *_M_ext_next; 
# 191
char *_M_ext_end; 
# 199
void _M_create_pback() 
# 200
{ 
# 201
if (!(_M_pback_init)) 
# 202
{ 
# 203
(_M_pback_cur_save) = this->gptr(); 
# 204
(_M_pback_end_save) = this->egptr(); 
# 205
this->setg(&(_M_pback), &(_M_pback), (&(_M_pback)) + 1); 
# 206
(_M_pback_init) = true; 
# 207
}  
# 208
} 
# 216
void _M_destroy_pback() throw() 
# 217
{ 
# 218
if (_M_pback_init) 
# 219
{ 
# 221
(_M_pback_cur_save) += (this->gptr() != this->eback()); 
# 222
this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save); 
# 223
(_M_pback_init) = false; 
# 224
}  
# 225
} 
# 235
public: basic_filebuf(); 
# 238
basic_filebuf(const basic_filebuf &) = delete;
# 239
basic_filebuf(basic_filebuf &&); 
# 246
virtual ~basic_filebuf() 
# 247
{ 
# 248
try 
# 249
{ close(); } 
# 250
catch (...) 
# 251
{ }  
# 252
} 
# 255
basic_filebuf &operator=(const basic_filebuf &) = delete;
# 256
basic_filebuf &operator=(basic_filebuf &&); 
# 257
void swap(basic_filebuf &); 
# 265
bool is_open() const throw() 
# 266
{ return (_M_file).is_open(); } 
# 310 "/usr/include/c++/9/fstream" 3
__filebuf_type *open(const char * __s, std::ios_base::openmode __mode); 
# 331 "/usr/include/c++/9/fstream" 3
__filebuf_type *open(const std::string &__s, std::ios_base::openmode __mode) 
# 332
{ return open(__s.c_str(), __mode); } 
# 361 "/usr/include/c++/9/fstream" 3
__filebuf_type *close(); 
# 365
protected: void _M_allocate_internal_buffer(); 
# 368
void _M_destroy_internal_buffer() throw(); 
# 372
virtual std::streamsize showmanyc(); 
# 380
virtual int_type underflow(); 
# 383
virtual int_type pbackfail(int_type __c = _Traits::eof()); 
# 393 "/usr/include/c++/9/fstream" 3
virtual int_type overflow(int_type __c = _Traits::eof()); 
# 398
bool _M_convert_to_external(char_type *, std::streamsize); 
# 413 "/usr/include/c++/9/fstream" 3
virtual __streambuf_type *setbuf(char_type * __s, std::streamsize __n); 
# 416
virtual pos_type seekoff(off_type __off, std::ios_base::seekdir __way, std::ios_base::openmode __mode = (std::ios_base::in | std::ios_base::out)); 
# 420
virtual pos_type seekpos(pos_type __pos, std::ios_base::openmode __mode = (std::ios_base::in | std::ios_base::out)); 
# 425
pos_type _M_seek(off_type __off, std::ios_base::seekdir __way, __state_type __state); 
# 428
int _M_get_ext_pos(__state_type & __state); 
# 431
virtual int sync(); 
# 434
virtual void imbue(const std::locale & __loc); 
# 437
virtual std::streamsize xsgetn(char_type * __s, std::streamsize __n); 
# 440
virtual std::streamsize xsputn(const char_type * __s, std::streamsize __n); 
# 444
bool _M_terminate_output(); 
# 459 "/usr/include/c++/9/fstream" 3
void _M_set_buffer(std::streamsize __off) 
# 460
{ 
# 461
const bool __testin = ((_M_mode) & std::ios_base::in); 
# 462
const bool __testout = (((_M_mode) & std::ios_base::out)) || (((_M_mode) & std::ios_base::app)); 
# 465
if (__testin && (__off > (0))) { 
# 466
this->setg(_M_buf, _M_buf, (_M_buf) + __off); } else { 
# 468
this->setg(_M_buf, _M_buf, _M_buf); }  
# 470
if (__testout && (__off == (0)) && ((_M_buf_size) > (1))) { 
# 471
this->setp(_M_buf, ((_M_buf) + (_M_buf_size)) - 1); } else { 
# 473
this->setp(0, 0); }  
# 474
} 
# 475
}; 
# 491 "/usr/include/c++/9/fstream" 3
template< class _CharT, class _Traits> 
# 492
class basic_ifstream : public basic_istream< _CharT, _Traits>  { 
# 496
public: typedef _CharT char_type; 
# 497
typedef _Traits traits_type; 
# 498
typedef typename _Traits::int_type int_type; 
# 499
typedef typename _Traits::pos_type pos_type; 
# 500
typedef typename _Traits::off_type off_type; 
# 503
typedef basic_filebuf< char_type, traits_type>  __filebuf_type; 
# 504
typedef basic_istream< _CharT, _Traits>  __istream_type; 
# 507
private: __filebuf_type _M_filebuf; 
# 518 "/usr/include/c++/9/fstream" 3
public: basic_ifstream() : __istream_type(), _M_filebuf() 
# 519
{ this->init(&(_M_filebuf)); } 
# 529 "/usr/include/c++/9/fstream" 3
explicit basic_ifstream(const char *__s, std::ios_base::openmode __mode = ios_base::in) : __istream_type(), _M_filebuf() 
# 531
{ 
# 532
this->init(&(_M_filebuf)); 
# 533
this->open(__s, __mode); 
# 534
} 
# 562 "/usr/include/c++/9/fstream" 3
explicit basic_ifstream(const std::string &__s, std::ios_base::openmode 
# 563
__mode = ios_base::in) : __istream_type(), _M_filebuf() 
# 565
{ 
# 566
this->init(&(_M_filebuf)); 
# 567
this->open(__s, __mode); 
# 568
} 
# 585 "/usr/include/c++/9/fstream" 3
basic_ifstream(const basic_ifstream &) = delete;
# 587
basic_ifstream(basic_ifstream &&__rhs) : __istream_type(std::move(__rhs)), _M_filebuf(std::move(__rhs._M_filebuf)) 
# 590
{ __istream_type::set_rdbuf(&(_M_filebuf)); } 
# 599 "/usr/include/c++/9/fstream" 3
~basic_ifstream() 
# 600
{ } 
# 606
basic_ifstream &operator=(const basic_ifstream &) = delete;
# 609
basic_ifstream &operator=(basic_ifstream &&__rhs) 
# 610
{ 
# 611
basic_istream< _CharT, _Traits> ::operator=(std::move(__rhs)); 
# 612
(_M_filebuf) = std::move(__rhs._M_filebuf); 
# 613
return *this; 
# 614
} 
# 617
void swap(basic_ifstream &__rhs) 
# 618
{ 
# 619
__istream_type::swap(__rhs); 
# 620
(_M_filebuf).swap(__rhs._M_filebuf); 
# 621
} 
# 632 "/usr/include/c++/9/fstream" 3
__filebuf_type *rdbuf() const 
# 633
{ return const_cast< __filebuf_type *>(&(_M_filebuf)); } 
# 640
bool is_open() 
# 641
{ return (_M_filebuf).is_open(); } 
# 646
bool is_open() const 
# 647
{ return (_M_filebuf).is_open(); } 
# 658 "/usr/include/c++/9/fstream" 3
void open(const char *__s, std::ios_base::openmode __mode = ios_base::in) 
# 659
{ 
# 660
if (!(_M_filebuf).open(__s, (__mode | std::ios_base::in))) { 
# 661
this->setstate(ios_base::failbit); } else { 
# 665
this->clear(); }  
# 666
} 
# 697 "/usr/include/c++/9/fstream" 3
void open(const std::string &__s, std::ios_base::openmode __mode = ios_base::in) 
# 698
{ 
# 699
if (!(_M_filebuf).open(__s, (__mode | std::ios_base::in))) { 
# 700
this->setstate(ios_base::failbit); } else { 
# 704
this->clear(); }  
# 705
} 
# 730 "/usr/include/c++/9/fstream" 3
void close() 
# 731
{ 
# 732
if (!(_M_filebuf).close()) { 
# 733
this->setstate(ios_base::failbit); }  
# 734
} 
# 735
}; 
# 752 "/usr/include/c++/9/fstream" 3
template< class _CharT, class _Traits> 
# 753
class basic_ofstream : public basic_ostream< _CharT, _Traits>  { 
# 757
public: typedef _CharT char_type; 
# 758
typedef _Traits traits_type; 
# 759
typedef typename _Traits::int_type int_type; 
# 760
typedef typename _Traits::pos_type pos_type; 
# 761
typedef typename _Traits::off_type off_type; 
# 764
typedef basic_filebuf< char_type, traits_type>  __filebuf_type; 
# 765
typedef basic_ostream< _CharT, _Traits>  __ostream_type; 
# 768
private: __filebuf_type _M_filebuf; 
# 779 "/usr/include/c++/9/fstream" 3
public: basic_ofstream() : __ostream_type(), _M_filebuf() 
# 780
{ this->init(&(_M_filebuf)); } 
# 790 "/usr/include/c++/9/fstream" 3
explicit basic_ofstream(const char *__s, std::ios_base::openmode 
# 791
__mode = ios_base::out) : __ostream_type(), _M_filebuf() 
# 793
{ 
# 794
this->init(&(_M_filebuf)); 
# 795
this->open(__s, __mode); 
# 796
} 
# 825 "/usr/include/c++/9/fstream" 3
explicit basic_ofstream(const std::string &__s, std::ios_base::openmode 
# 826
__mode = ios_base::out) : __ostream_type(), _M_filebuf() 
# 828
{ 
# 829
this->init(&(_M_filebuf)); 
# 830
this->open(__s, __mode); 
# 831
} 
# 848 "/usr/include/c++/9/fstream" 3
basic_ofstream(const basic_ofstream &) = delete;
# 850
basic_ofstream(basic_ofstream &&__rhs) : __ostream_type(std::move(__rhs)), _M_filebuf(std::move(__rhs._M_filebuf)) 
# 853
{ __ostream_type::set_rdbuf(&(_M_filebuf)); } 
# 862 "/usr/include/c++/9/fstream" 3
~basic_ofstream() 
# 863
{ } 
# 869
basic_ofstream &operator=(const basic_ofstream &) = delete;
# 872
basic_ofstream &operator=(basic_ofstream &&__rhs) 
# 873
{ 
# 874
basic_ostream< _CharT, _Traits> ::operator=(std::move(__rhs)); 
# 875
(_M_filebuf) = std::move(__rhs._M_filebuf); 
# 876
return *this; 
# 877
} 
# 880
void swap(basic_ofstream &__rhs) 
# 881
{ 
# 882
__ostream_type::swap(__rhs); 
# 883
(_M_filebuf).swap(__rhs._M_filebuf); 
# 884
} 
# 895 "/usr/include/c++/9/fstream" 3
__filebuf_type *rdbuf() const 
# 896
{ return const_cast< __filebuf_type *>(&(_M_filebuf)); } 
# 903
bool is_open() 
# 904
{ return (_M_filebuf).is_open(); } 
# 909
bool is_open() const 
# 910
{ return (_M_filebuf).is_open(); } 
# 921 "/usr/include/c++/9/fstream" 3
void open(const char *__s, std::ios_base::openmode __mode = ios_base::out) 
# 922
{ 
# 923
if (!(_M_filebuf).open(__s, (__mode | std::ios_base::out))) { 
# 924
this->setstate(ios_base::failbit); } else { 
# 928
this->clear(); }  
# 929
} 
# 960 "/usr/include/c++/9/fstream" 3
void open(const std::string &__s, std::ios_base::openmode __mode = ios_base::out) 
# 961
{ 
# 962
if (!(_M_filebuf).open(__s, (__mode | std::ios_base::out))) { 
# 963
this->setstate(ios_base::failbit); } else { 
# 967
this->clear(); }  
# 968
} 
# 993 "/usr/include/c++/9/fstream" 3
void close() 
# 994
{ 
# 995
if (!(_M_filebuf).close()) { 
# 996
this->setstate(ios_base::failbit); }  
# 997
} 
# 998
}; 
# 1015 "/usr/include/c++/9/fstream" 3
template< class _CharT, class _Traits> 
# 1016
class basic_fstream : public basic_iostream< _CharT, _Traits>  { 
# 1020
public: typedef _CharT char_type; 
# 1021
typedef _Traits traits_type; 
# 1022
typedef typename _Traits::int_type int_type; 
# 1023
typedef typename _Traits::pos_type pos_type; 
# 1024
typedef typename _Traits::off_type off_type; 
# 1027
typedef basic_filebuf< char_type, traits_type>  __filebuf_type; 
# 1028
typedef basic_ios< char_type, traits_type>  __ios_type; 
# 1029
typedef basic_iostream< _CharT, _Traits>  __iostream_type; 
# 1032
private: __filebuf_type _M_filebuf; 
# 1043 "/usr/include/c++/9/fstream" 3
public: basic_fstream() : __iostream_type(), _M_filebuf() 
# 1045
{ this->init(&(_M_filebuf)); } 
# 1053
explicit basic_fstream(const char *__s, std::ios_base::openmode 
# 1054
__mode = (std::ios_base::in | std::ios_base::out)) : __iostream_type(0), _M_filebuf() 
# 1056
{ 
# 1057
this->init(&(_M_filebuf)); 
# 1058
this->open(__s, __mode); 
# 1059
} 
# 1083 "/usr/include/c++/9/fstream" 3
explicit basic_fstream(const std::string &__s, std::ios_base::openmode 
# 1084
__mode = (std::ios_base::in | std::ios_base::out)) : __iostream_type(0), _M_filebuf() 
# 1086
{ 
# 1087
this->init(&(_M_filebuf)); 
# 1088
this->open(__s, __mode); 
# 1089
} 
# 1104 "/usr/include/c++/9/fstream" 3
basic_fstream(const basic_fstream &) = delete;
# 1106
basic_fstream(basic_fstream &&__rhs) : __iostream_type(std::move(__rhs)), _M_filebuf(std::move(__rhs._M_filebuf)) 
# 1109
{ __iostream_type::set_rdbuf(&(_M_filebuf)); } 
# 1118 "/usr/include/c++/9/fstream" 3
~basic_fstream() 
# 1119
{ } 
# 1125
basic_fstream &operator=(const basic_fstream &) = delete;
# 1128
basic_fstream &operator=(basic_fstream &&__rhs) 
# 1129
{ 
# 1130
basic_iostream< _CharT, _Traits> ::operator=(std::move(__rhs)); 
# 1131
(_M_filebuf) = std::move(__rhs._M_filebuf); 
# 1132
return *this; 
# 1133
} 
# 1136
void swap(basic_fstream &__rhs) 
# 1137
{ 
# 1138
__iostream_type::swap(__rhs); 
# 1139
(_M_filebuf).swap(__rhs._M_filebuf); 
# 1140
} 
# 1151 "/usr/include/c++/9/fstream" 3
__filebuf_type *rdbuf() const 
# 1152
{ return const_cast< __filebuf_type *>(&(_M_filebuf)); } 
# 1159
bool is_open() 
# 1160
{ return (_M_filebuf).is_open(); } 
# 1165
bool is_open() const 
# 1166
{ return (_M_filebuf).is_open(); } 
# 1177 "/usr/include/c++/9/fstream" 3
void open(const char *__s, std::ios_base::openmode 
# 1178
__mode = (std::ios_base::in | std::ios_base::out)) 
# 1179
{ 
# 1180
if (!(_M_filebuf).open(__s, __mode)) { 
# 1181
this->setstate(ios_base::failbit); } else { 
# 1185
this->clear(); }  
# 1186
} 
# 1218 "/usr/include/c++/9/fstream" 3
void open(const std::string &__s, std::ios_base::openmode 
# 1219
__mode = (std::ios_base::in | std::ios_base::out)) 
# 1220
{ 
# 1221
if (!(_M_filebuf).open(__s, __mode)) { 
# 1222
this->setstate(ios_base::failbit); } else { 
# 1226
this->clear(); }  
# 1227
} 
# 1253 "/usr/include/c++/9/fstream" 3
void close() 
# 1254
{ 
# 1255
if (!(_M_filebuf).close()) { 
# 1256
this->setstate(ios_base::failbit); }  
# 1257
} 
# 1258
}; 
# 1262
template< class _CharT, class _Traits> inline void 
# 1264
swap(basic_filebuf< _CharT, _Traits>  &__x, basic_filebuf< _CharT, _Traits>  &
# 1265
__y) 
# 1266
{ __x.swap(__y); } 
# 1269
template< class _CharT, class _Traits> inline void 
# 1271
swap(basic_ifstream< _CharT, _Traits>  &__x, basic_ifstream< _CharT, _Traits>  &
# 1272
__y) 
# 1273
{ __x.swap(__y); } 
# 1276
template< class _CharT, class _Traits> inline void 
# 1278
swap(basic_ofstream< _CharT, _Traits>  &__x, basic_ofstream< _CharT, _Traits>  &
# 1279
__y) 
# 1280
{ __x.swap(__y); } 
# 1283
template< class _CharT, class _Traits> inline void 
# 1285
swap(basic_fstream< _CharT, _Traits>  &__x, basic_fstream< _CharT, _Traits>  &
# 1286
__y) 
# 1287
{ __x.swap(__y); } 
# 1291
}
# 43 "/usr/include/c++/9/bits/fstream.tcc" 3
namespace std __attribute((__visibility__("default"))) { 
# 47
template< class _CharT, class _Traits> void 
# 50
basic_filebuf< _CharT, _Traits> ::_M_allocate_internal_buffer() 
# 51
{ 
# 54
if ((!(_M_buf_allocated)) && (!(_M_buf))) 
# 55
{ 
# 56
(_M_buf) = (new char_type [_M_buf_size]); 
# 57
(_M_buf_allocated) = true; 
# 58
}  
# 59
} 
# 61
template< class _CharT, class _Traits> void 
# 64
basic_filebuf< _CharT, _Traits> ::_M_destroy_internal_buffer() throw() 
# 65
{ 
# 66
if (_M_buf_allocated) 
# 67
{ 
# 68
delete [] (_M_buf); 
# 69
(_M_buf) = 0; 
# 70
(_M_buf_allocated) = false; 
# 71
}  
# 72
delete [] (_M_ext_buf); 
# 73
(_M_ext_buf) = (0); 
# 74
(_M_ext_buf_size) = (0); 
# 75
(_M_ext_next) = (0); 
# 76
(_M_ext_end) = (0); 
# 77
} 
# 79
template< class _CharT, class _Traits> 
# 81
basic_filebuf< _CharT, _Traits> ::basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&(_M_lock)), _M_mode(((std::ios_base::openmode)0)), _M_state_beg(), _M_state_cur(), _M_state_last(), _M_buf((0)), _M_buf_size((8192)), _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(), _M_pback_cur_save((0)), _M_pback_end_save((0)), _M_pback_init(false), _M_codecvt((0)), _M_ext_buf((0)), _M_ext_buf_size((0)), _M_ext_next((0)), _M_ext_end((0)) 
# 88
{ 
# 89
if (has_facet< __codecvt_type> ((this->_M_buf_locale))) { 
# 90
(_M_codecvt) = (&use_facet< __codecvt_type> ((this->_M_buf_locale))); }  
# 91
} 
# 94
template< class _CharT, class _Traits> 
# 96
basic_filebuf< _CharT, _Traits> ::basic_filebuf(basic_filebuf &&__rhs) : __streambuf_type(__rhs), _M_lock(), _M_file(std::move(__rhs._M_file), &(_M_lock)), _M_mode(std::__exchange(__rhs._M_mode, (std::ios_base::openmode)0)), _M_state_beg(std::move(__rhs._M_state_beg)), _M_state_cur(std::move(__rhs._M_state_cur)), _M_state_last(std::move(__rhs._M_state_last)), _M_buf(std::__exchange(__rhs._M_buf, nullptr)), _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)), _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)), _M_reading(std::__exchange(__rhs._M_reading, false)), _M_writing(std::__exchange(__rhs._M_writing, false)), _M_pback(__rhs._M_pback), _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)), _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)), _M_pback_init(std::__exchange(__rhs._M_pback_init, false)), _M_codecvt(__rhs._M_codecvt), _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)), _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)), _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)), _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr)) 
# 117
{ 
# 118
__rhs._M_set_buffer(-1); 
# 119
(__rhs._M_state_last) = ((__rhs._M_state_cur) = (__rhs._M_state_beg)); 
# 120
} 
# 122
template< class _CharT, class _Traits> basic_filebuf< _CharT, _Traits>  &
# 125
basic_filebuf< _CharT, _Traits> ::operator=(basic_filebuf &&__rhs) 
# 126
{ 
# 127
close(); 
# 128
basic_streambuf< _CharT, _Traits> ::operator=(__rhs); 
# 129
(_M_file).swap(__rhs._M_file); 
# 130
(_M_mode) = std::__exchange(__rhs._M_mode, (std::ios_base::openmode)0); 
# 131
(_M_state_beg) = std::move(__rhs._M_state_beg); 
# 132
(_M_state_cur) = std::move(__rhs._M_state_cur); 
# 133
(_M_state_last) = std::move(__rhs._M_state_last); 
# 134
(_M_buf) = std::__exchange(__rhs._M_buf, nullptr); 
# 135
(_M_buf_size) = std::__exchange(__rhs._M_buf_size, 1); 
# 136
(_M_buf_allocated) = std::__exchange(__rhs._M_buf_allocated, false); 
# 137
(_M_ext_buf) = std::__exchange(__rhs._M_ext_buf, nullptr); 
# 138
(_M_ext_buf_size) = std::__exchange(__rhs._M_ext_buf_size, 0); 
# 139
(_M_ext_next) = std::__exchange(__rhs._M_ext_next, nullptr); 
# 140
(_M_ext_end) = std::__exchange(__rhs._M_ext_end, nullptr); 
# 141
(_M_reading) = std::__exchange(__rhs._M_reading, false); 
# 142
(_M_writing) = std::__exchange(__rhs._M_writing, false); 
# 143
(_M_pback_cur_save) = std::__exchange(__rhs._M_pback_cur_save, nullptr); 
# 144
(_M_pback_end_save) = std::__exchange(__rhs._M_pback_end_save, nullptr); 
# 145
(_M_pback_init) = std::__exchange(__rhs._M_pback_init, false); 
# 146
__rhs._M_set_buffer(-1); 
# 147
(__rhs._M_state_last) = ((__rhs._M_state_cur) = (__rhs._M_state_beg)); 
# 148
return *this; 
# 149
} 
# 151
template< class _CharT, class _Traits> void 
# 154
basic_filebuf< _CharT, _Traits> ::swap(basic_filebuf &__rhs) 
# 155
{ 
# 156
__streambuf_type::swap(__rhs); 
# 157
(_M_file).swap(__rhs._M_file); 
# 158
std::swap(_M_mode, __rhs._M_mode); 
# 159
std::swap(_M_state_beg, __rhs._M_state_beg); 
# 160
std::swap(_M_state_cur, __rhs._M_state_cur); 
# 161
std::swap(_M_state_last, __rhs._M_state_last); 
# 162
std::swap(_M_buf, __rhs._M_buf); 
# 163
std::swap(_M_buf_size, __rhs._M_buf_size); 
# 164
std::swap(_M_buf_allocated, __rhs._M_buf_allocated); 
# 165
std::swap(_M_ext_buf, __rhs._M_ext_buf); 
# 166
std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size); 
# 167
std::swap(_M_ext_next, __rhs._M_ext_next); 
# 168
std::swap(_M_ext_end, __rhs._M_ext_end); 
# 169
std::swap(_M_reading, __rhs._M_reading); 
# 170
std::swap(_M_writing, __rhs._M_writing); 
# 171
std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save); 
# 172
std::swap(_M_pback_end_save, __rhs._M_pback_end_save); 
# 173
std::swap(_M_pback_init, __rhs._M_pback_init); 
# 174
} 
# 177
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::__filebuf_type *
# 180
basic_filebuf< _CharT, _Traits> ::open(const char *__s, std::ios_base::openmode __mode) 
# 181
{ 
# 182
__filebuf_type *__ret = (0); 
# 183
if (!is_open()) 
# 184
{ 
# 185
(_M_file).open(__s, __mode); 
# 186
if (is_open()) 
# 187
{ 
# 188
_M_allocate_internal_buffer(); 
# 189
(_M_mode) = __mode; 
# 192
(_M_reading) = false; 
# 193
(_M_writing) = false; 
# 194
_M_set_buffer(-1); 
# 197
(_M_state_last) = ((_M_state_cur) = (_M_state_beg)); 
# 200
if ((__mode & std::ios_base::ate) && (seekoff(0, std::ios_base::end, __mode) == ((pos_type)((off_type)(-1))))) { 
# 203
close(); } else { 
# 205
__ret = this; }  
# 206
}  
# 207
}  
# 208
return __ret; 
# 209
} 
# 247 "/usr/include/c++/9/bits/fstream.tcc" 3
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::__filebuf_type *
# 250
basic_filebuf< _CharT, _Traits> ::close() 
# 251
{ 
# 252
if (!is_open()) { 
# 253
return 0; }  
# 255
bool __testfail = false; 
# 256
{ 
# 258
struct __close_sentry { 
# 260
basic_filebuf *__fb; 
# 261
__close_sentry(basic_filebuf *__fbi) : __fb(__fbi) { } 
# 262
~__close_sentry() 
# 263
{ 
# 264
((__fb)->_M_mode) = ((std::ios_base::openmode)0); 
# 265
((__fb)->_M_pback_init) = false; 
# 266
(__fb)->_M_destroy_internal_buffer(); 
# 267
((__fb)->_M_reading) = false; 
# 268
((__fb)->_M_writing) = false; 
# 269
(__fb)->_M_set_buffer(-1); 
# 270
((__fb)->_M_state_last) = (((__fb)->_M_state_cur) = ((__fb)->_M_state_beg)); 
# 271
} 
# 272
} __cs(this); 
# 274
try 
# 275
{ 
# 276
if (!_M_terminate_output()) { 
# 277
__testfail = true; }  
# 278
} 
# 279
catch (...) 
# 280
{ 
# 281
(_M_file).close(); 
# 282
throw; 
# 283
}  
# 284
} 
# 286
if (!((_M_file).close())) { 
# 287
__testfail = true; }  
# 289
if (__testfail) { 
# 290
return 0; } else { 
# 292
return this; }  
# 293
} 
# 295
template< class _CharT, class _Traits> streamsize 
# 298
basic_filebuf< _CharT, _Traits> ::showmanyc() 
# 299
{ 
# 300
std::streamsize __ret = (-1); 
# 301
const bool __testin = ((_M_mode) & std::ios_base::in); 
# 302
if (__testin && is_open()) 
# 303
{ 
# 306
__ret = (this->egptr() - this->gptr()); 
# 314
if (__check_facet(_M_codecvt).encoding() >= 0) { 
# 316
__ret += ((_M_file).showmanyc() / (_M_codecvt)->max_length()); }  
# 317
}  
# 318
return __ret; 
# 319
} 
# 321
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::int_type 
# 324
basic_filebuf< _CharT, _Traits> ::underflow() 
# 325
{ 
# 326
int_type __ret = traits_type::eof(); 
# 327
const bool __testin = ((_M_mode) & std::ios_base::in); 
# 328
if (__testin) 
# 329
{ 
# 330
if (_M_writing) 
# 331
{ 
# 332
if (overflow() == traits_type::eof()) { 
# 333
return __ret; }  
# 334
_M_set_buffer(-1); 
# 335
(_M_writing) = false; 
# 336
}  
# 340
_M_destroy_pback(); 
# 342
if (this->gptr() < this->egptr()) { 
# 343
return traits_type::to_int_type(*this->gptr()); }  
# 346
const std::size_t __buflen = ((_M_buf_size) > (1)) ? (_M_buf_size) - (1) : (1); 
# 349
bool __got_eof = false; 
# 351
std::streamsize __ilen = (0); 
# 352
std::codecvt_base::result __r = codecvt_base::ok; 
# 353
if (__check_facet(_M_codecvt).always_noconv()) 
# 354
{ 
# 355
__ilen = (_M_file).xsgetn(reinterpret_cast< char *>(this->eback()), __buflen); 
# 357
if (__ilen == (0)) { 
# 358
__got_eof = true; }  
# 359
} else 
# 361
{ 
# 364
const int __enc = (_M_codecvt)->encoding(); 
# 365
std::streamsize __blen; 
# 366
std::streamsize __rlen; 
# 367
if (__enc > 0) { 
# 368
__blen = (__rlen = (__buflen * __enc)); } else 
# 370
{ 
# 371
__blen = ((__buflen + (_M_codecvt)->max_length()) - 1); 
# 372
__rlen = __buflen; 
# 373
}  
# 374
const std::streamsize __remainder = (_M_ext_end) - (_M_ext_next); 
# 375
__rlen = ((__rlen > __remainder) ? __rlen - __remainder : (0)); 
# 379
if ((_M_reading) && (this->egptr() == this->eback()) && __remainder) { 
# 380
__rlen = (0); }  
# 384
if ((_M_ext_buf_size) < __blen) 
# 385
{ 
# 386
char *__buf = new char [__blen]; 
# 387
if (__remainder) { 
# 388
__builtin_memcpy(__buf, _M_ext_next, __remainder); }  
# 390
delete [] (_M_ext_buf); 
# 391
(_M_ext_buf) = __buf; 
# 392
(_M_ext_buf_size) = __blen; 
# 393
} else { 
# 394
if (__remainder) { 
# 395
__builtin_memmove(_M_ext_buf, _M_ext_next, __remainder); }  }  
# 397
(_M_ext_next) = (_M_ext_buf); 
# 398
(_M_ext_end) = ((_M_ext_buf) + __remainder); 
# 399
(_M_state_last) = (_M_state_cur); 
# 401
do 
# 402
{ 
# 403
if (__rlen > (0)) 
# 404
{ 
# 408
if ((((_M_ext_end) - (_M_ext_buf)) + __rlen) > (_M_ext_buf_size)) 
# 409
{ 
# 410
__throw_ios_failure("basic_filebuf::underflow codecvt::max_length() is not valid"); 
# 413
}  
# 414
std::streamsize __elen = (_M_file).xsgetn(_M_ext_end, __rlen); 
# 415
if (__elen == (0)) { 
# 416
__got_eof = true; } else { 
# 417
if (__elen == (-1)) { 
# 418
break; }  }  
# 419
(_M_ext_end) += __elen; 
# 420
}  
# 422
char_type *__iend = this->eback(); 
# 423
if ((_M_ext_next) < (_M_ext_end)) { 
# 424
__r = (_M_codecvt)->in(_M_state_cur, _M_ext_next, _M_ext_end, _M_ext_next, this->eback(), this->eback() + __buflen, __iend); }  
# 428
if (__r == (codecvt_base::noconv)) 
# 429
{ 
# 430
std::size_t __avail = (_M_ext_end) - (_M_ext_buf); 
# 431
__ilen = (std::min(__avail, __buflen)); 
# 432
traits_type::copy(this->eback(), reinterpret_cast< char_type *>(_M_ext_buf), __ilen); 
# 435
(_M_ext_next) = ((_M_ext_buf) + __ilen); 
# 436
} else { 
# 438
__ilen = (__iend - this->eback()); }  
# 443
if (__r == (codecvt_base::error)) { 
# 444
break; }  
# 446
__rlen = (1); 
# 447
} 
# 448
while ((__ilen == (0)) && (!__got_eof)); 
# 449
}  
# 451
if (__ilen > (0)) 
# 452
{ 
# 453
_M_set_buffer(__ilen); 
# 454
(_M_reading) = true; 
# 455
__ret = traits_type::to_int_type(*this->gptr()); 
# 456
} else { 
# 457
if (__got_eof) 
# 458
{ 
# 462
_M_set_buffer(-1); 
# 463
(_M_reading) = false; 
# 466
if (__r == (codecvt_base::partial)) { 
# 467
__throw_ios_failure("basic_filebuf::underflow incomplete character in file"); }  
# 469
} else { 
# 470
if (__r == (codecvt_base::error)) { 
# 471
__throw_ios_failure("basic_filebuf::underflow invalid byte sequence in file"); } else { 
# 474
__throw_ios_failure("basic_filebuf::underflow error reading the file", *__errno_location()); }  }  }  
# 476
}  
# 477
return __ret; 
# 478
} 
# 480
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::int_type 
# 483
basic_filebuf< _CharT, _Traits> ::pbackfail(int_type __i) 
# 484
{ 
# 485
int_type __ret = traits_type::eof(); 
# 486
const bool __testin = ((_M_mode) & std::ios_base::in); 
# 487
if (__testin) 
# 488
{ 
# 489
if (_M_writing) 
# 490
{ 
# 491
if (overflow() == traits_type::eof()) { 
# 492
return __ret; }  
# 493
_M_set_buffer(-1); 
# 494
(_M_writing) = false; 
# 495
}  
# 498
const bool __testpb = _M_pback_init; 
# 499
const bool __testeof = traits_type::eq_int_type(__i, __ret); 
# 500
int_type __tmp; 
# 501
if (this->eback() < this->gptr()) 
# 502
{ 
# 503
this->gbump(-1); 
# 504
__tmp = traits_type::to_int_type(*this->gptr()); 
# 505
} else { 
# 506
if (seekoff(-1, std::ios_base::cur) != ((pos_type)((off_type)(-1)))) 
# 507
{ 
# 508
__tmp = underflow(); 
# 509
if (traits_type::eq_int_type(__tmp, __ret)) { 
# 510
return __ret; }  
# 511
} else 
# 513
{ 
# 519
return __ret; 
# 520
}  }  
# 524
if ((!__testeof) && traits_type::eq_int_type(__i, __tmp)) { 
# 525
__ret = __i; } else { 
# 526
if (__testeof) { 
# 527
__ret = traits_type::not_eof(__i); } else { 
# 528
if (!__testpb) 
# 529
{ 
# 530
_M_create_pback(); 
# 531
(_M_reading) = true; 
# 532
(*this->gptr()) = traits_type::to_char_type(__i); 
# 533
__ret = __i; 
# 534
}  }  }  
# 535
}  
# 536
return __ret; 
# 537
} 
# 539
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::int_type 
# 542
basic_filebuf< _CharT, _Traits> ::overflow(int_type __c) 
# 543
{ 
# 544
int_type __ret = traits_type::eof(); 
# 545
const bool __testeof = traits_type::eq_int_type(__c, __ret); 
# 546
const bool __testout = (((_M_mode) & std::ios_base::out)) || (((_M_mode) & std::ios_base::app)); 
# 548
if (__testout) 
# 549
{ 
# 550
if (_M_reading) 
# 551
{ 
# 552
_M_destroy_pback(); 
# 553
const int __gptr_off = _M_get_ext_pos(_M_state_last); 
# 554
if (_M_seek(__gptr_off, ios_base::cur, _M_state_last) == ((pos_type)((off_type)(-1)))) { 
# 556
return __ret; }  
# 557
}  
# 558
if (this->pbase() < this->pptr()) 
# 559
{ 
# 561
if (!__testeof) 
# 562
{ 
# 563
(*this->pptr()) = traits_type::to_char_type(__c); 
# 564
this->pbump(1); 
# 565
}  
# 569
if (_M_convert_to_external(this->pbase(), this->pptr() - this->pbase())) 
# 571
{ 
# 572
_M_set_buffer(0); 
# 573
__ret = traits_type::not_eof(__c); 
# 574
}  
# 575
} else { 
# 576
if ((_M_buf_size) > (1)) 
# 577
{ 
# 581
_M_set_buffer(0); 
# 582
(_M_writing) = true; 
# 583
if (!__testeof) 
# 584
{ 
# 585
(*this->pptr()) = traits_type::to_char_type(__c); 
# 586
this->pbump(1); 
# 587
}  
# 588
__ret = traits_type::not_eof(__c); 
# 589
} else 
# 591
{ 
# 593
char_type __conv = traits_type::to_char_type(__c); 
# 594
if (__testeof || _M_convert_to_external(&__conv, 1)) 
# 595
{ 
# 596
(_M_writing) = true; 
# 597
__ret = traits_type::not_eof(__c); 
# 598
}  
# 599
}  }  
# 600
}  
# 601
return __ret; 
# 602
} 
# 604
template< class _CharT, class _Traits> bool 
# 607
basic_filebuf< _CharT, _Traits> ::_M_convert_to_external(_CharT *__ibuf, std::streamsize __ilen) 
# 608
{ 
# 610
std::streamsize __elen; 
# 611
std::streamsize __plen; 
# 612
if (__check_facet(_M_codecvt).always_noconv()) 
# 613
{ 
# 614
__elen = (_M_file).xsputn(reinterpret_cast< char *>(__ibuf), __ilen); 
# 615
__plen = __ilen; 
# 616
} else 
# 618
{ 
# 621
std::streamsize __blen = __ilen * (_M_codecvt)->max_length(); 
# 622
char *__buf = static_cast< char *>(__builtin_alloca(__blen)); 
# 624
char *__bend; 
# 625
const char_type *__iend; 
# 626
std::codecvt_base::result __r; 
# 627
__r = (_M_codecvt)->out(_M_state_cur, __ibuf, __ibuf + __ilen, __iend, __buf, __buf + __blen, __bend); 
# 630
if ((__r == (codecvt_base::ok)) || (__r == (codecvt_base::partial))) { 
# 631
__blen = (__bend - __buf); } else { 
# 632
if (__r == (codecvt_base::noconv)) 
# 633
{ 
# 635
__buf = (reinterpret_cast< char *>(__ibuf)); 
# 636
__blen = __ilen; 
# 637
} else { 
# 639
__throw_ios_failure("basic_filebuf::_M_convert_to_external conversion error"); }  }  
# 642
__elen = (_M_file).xsputn(__buf, __blen); 
# 643
__plen = __blen; 
# 646
if ((__r == (codecvt_base::partial)) && (__elen == __plen)) 
# 647
{ 
# 648
const char_type *__iresume = __iend; 
# 649
std::streamsize __rlen = this->pptr() - __iend; 
# 650
__r = (_M_codecvt)->out(_M_state_cur, __iresume, __iresume + __rlen, __iend, __buf, __buf + __blen, __bend); 
# 653
if (__r != (codecvt_base::error)) 
# 654
{ 
# 655
__rlen = (__bend - __buf); 
# 656
__elen = (_M_file).xsputn(__buf, __rlen); 
# 657
__plen = __rlen; 
# 658
} else { 
# 660
__throw_ios_failure("basic_filebuf::_M_convert_to_external conversion error"); }  
# 662
}  
# 663
}  
# 664
return __elen == __plen; 
# 665
} 
# 667
template< class _CharT, class _Traits> streamsize 
# 670
basic_filebuf< _CharT, _Traits> ::xsgetn(_CharT *__s, std::streamsize __n) 
# 671
{ 
# 673
std::streamsize __ret = (0); 
# 674
if (_M_pback_init) 
# 675
{ 
# 676
if ((__n > (0)) && (this->gptr() == this->eback())) 
# 677
{ 
# 678
(*(__s++)) = (*this->gptr()); 
# 679
this->gbump(1); 
# 680
__ret = (1); 
# 681
--__n; 
# 682
}  
# 683
_M_destroy_pback(); 
# 684
} else { 
# 685
if (_M_writing) 
# 686
{ 
# 687
if (overflow() == traits_type::eof()) { 
# 688
return __ret; }  
# 689
_M_set_buffer(-1); 
# 690
(_M_writing) = false; 
# 691
}  }  
# 696
const bool __testin = ((_M_mode) & std::ios_base::in); 
# 697
const std::streamsize __buflen = ((_M_buf_size) > (1)) ? (_M_buf_size) - (1) : (1); 
# 699
if ((__n > __buflen) && __check_facet(_M_codecvt).always_noconv() && __testin) 
# 701
{ 
# 703
const std::streamsize __avail = this->egptr() - this->gptr(); 
# 704
if (__avail != (0)) 
# 705
{ 
# 706
traits_type::copy(__s, this->gptr(), __avail); 
# 707
__s += __avail; 
# 708
this->setg(this->eback(), this->gptr() + __avail, this->egptr()); 
# 709
__ret += __avail; 
# 710
__n -= __avail; 
# 711
}  
# 715
std::streamsize __len; 
# 716
for (; ;) 
# 717
{ 
# 718
__len = (_M_file).xsgetn(reinterpret_cast< char *>(__s), __n); 
# 719
if (__len == (-1)) { 
# 720
__throw_ios_failure("basic_filebuf::xsgetn error reading the file", *__errno_location()); }  
# 722
if (__len == (0)) { 
# 723
break; }  
# 725
__n -= __len; 
# 726
__ret += __len; 
# 727
if (__n == (0)) { 
# 728
break; }  
# 730
__s += __len; 
# 731
}  
# 733
if (__n == (0)) 
# 734
{ 
# 736
(_M_reading) = true; 
# 737
} else { 
# 738
if (__len == (0)) 
# 739
{ 
# 743
_M_set_buffer(-1); 
# 744
(_M_reading) = false; 
# 745
}  }  
# 746
} else { 
# 748
__ret += __streambuf_type::xsgetn(__s, __n); }  
# 750
return __ret; 
# 751
} 
# 753
template< class _CharT, class _Traits> streamsize 
# 756
basic_filebuf< _CharT, _Traits> ::xsputn(const _CharT *__s, std::streamsize __n) 
# 757
{ 
# 758
std::streamsize __ret = (0); 
# 762
const bool __testout = (((_M_mode) & std::ios_base::out)) || (((_M_mode) & std::ios_base::app)); 
# 764
if (__check_facet(_M_codecvt).always_noconv() && __testout && (!(_M_reading))) 
# 766
{ 
# 768
const std::streamsize __chunk = (1UL << 10); 
# 769
std::streamsize __bufavail = this->epptr() - this->pptr(); 
# 772
if ((!(_M_writing)) && ((_M_buf_size) > (1))) { 
# 773
__bufavail = ((_M_buf_size) - (1)); }  
# 775
const std::streamsize __limit = std::min(__chunk, __bufavail); 
# 776
if (__n >= __limit) 
# 777
{ 
# 778
const std::streamsize __buffill = this->pptr() - this->pbase(); 
# 779
const char *__buf = reinterpret_cast< const char *>(this->pbase()); 
# 780
__ret = (_M_file).xsputn_2(__buf, __buffill, reinterpret_cast< const char *>(__s), __n); 
# 783
if (__ret == (__buffill + __n)) 
# 784
{ 
# 785
_M_set_buffer(0); 
# 786
(_M_writing) = true; 
# 787
}  
# 788
if (__ret > __buffill) { 
# 789
__ret -= __buffill; } else { 
# 791
__ret = (0); }  
# 792
} else { 
# 794
__ret = __streambuf_type::xsputn(__s, __n); }  
# 795
} else { 
# 797
__ret = __streambuf_type::xsputn(__s, __n); }  
# 798
return __ret; 
# 799
} 
# 801
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::__streambuf_type *
# 804
basic_filebuf< _CharT, _Traits> ::setbuf(char_type *__s, std::streamsize __n) 
# 805
{ 
# 806
if (!is_open()) 
# 807
{ 
# 808
if ((__s == 0) && (__n == (0))) { 
# 809
(_M_buf_size) = (1); } else { 
# 810
if (__s && (__n > (0))) 
# 811
{ 
# 820 "/usr/include/c++/9/bits/fstream.tcc" 3
(_M_buf) = __s; 
# 821
(_M_buf_size) = __n; 
# 822
}  }  
# 823
}  
# 824
return this; 
# 825
} 
# 830
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::pos_type 
# 833
basic_filebuf< _CharT, _Traits> ::seekoff(off_type __off, std::ios_base::seekdir __way, std::ios_base::openmode) 
# 834
{ 
# 835
int __width = 0; 
# 836
if (_M_codecvt) { 
# 837
__width = (_M_codecvt)->encoding(); }  
# 838
if (__width < 0) { 
# 839
__width = 0; }  
# 841
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 842
const bool __testfail = (__off != 0) && (__width <= 0); 
# 843
if (is_open() && (!__testfail)) 
# 844
{ 
# 849
bool __no_movement = (__way == std::ios_base::cur) && (__off == 0) && ((!(_M_writing)) || (_M_codecvt)->always_noconv()); 
# 853
if (!__no_movement) { 
# 854
_M_destroy_pback(); }  
# 861
__state_type __state = _M_state_beg; 
# 862
off_type __computed_off = __off * __width; 
# 863
if ((_M_reading) && (__way == std::ios_base::cur)) 
# 864
{ 
# 865
__state = (_M_state_last); 
# 866
__computed_off += _M_get_ext_pos(__state); 
# 867
}  
# 868
if (!__no_movement) { 
# 869
__ret = _M_seek(__computed_off, __way, __state); } else 
# 871
{ 
# 872
if (_M_writing) { 
# 873
__computed_off = (this->pptr() - this->pbase()); }  
# 875
off_type __file_off = (_M_file).seekoff(0, std::ios_base::cur); 
# 876
if (__file_off != ((off_type)(-1))) 
# 877
{ 
# 878
__ret = (__file_off + __computed_off); 
# 879
__ret.state(__state); 
# 880
}  
# 881
}  
# 882
}  
# 883
return __ret; 
# 884
} 
# 890
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::pos_type 
# 893
basic_filebuf< _CharT, _Traits> ::seekpos(pos_type __pos, std::ios_base::openmode) 
# 894
{ 
# 895
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 896
if (is_open()) 
# 897
{ 
# 899
_M_destroy_pback(); 
# 900
__ret = _M_seek((off_type)__pos, ios_base::beg, __pos.state()); 
# 901
}  
# 902
return __ret; 
# 903
} 
# 905
template< class _CharT, class _Traits> typename basic_filebuf< _CharT, _Traits> ::pos_type 
# 908
basic_filebuf< _CharT, _Traits> ::_M_seek(off_type __off, std::ios_base::seekdir __way, __state_type __state) 
# 909
{ 
# 910
pos_type __ret = ((pos_type)((off_type)(-1))); 
# 911
if (_M_terminate_output()) 
# 912
{ 
# 913
off_type __file_off = (_M_file).seekoff(__off, __way); 
# 914
if (__file_off != ((off_type)(-1))) 
# 915
{ 
# 916
(_M_reading) = false; 
# 917
(_M_writing) = false; 
# 918
(_M_ext_next) = ((_M_ext_end) = (_M_ext_buf)); 
# 919
_M_set_buffer(-1); 
# 920
(_M_state_cur) = __state; 
# 921
__ret = __file_off; 
# 922
__ret.state(_M_state_cur); 
# 923
}  
# 924
}  
# 925
return __ret; 
# 926
} 
# 931
template< class _CharT, class _Traits> int 
# 933
basic_filebuf< _CharT, _Traits> ::_M_get_ext_pos(__state_type &__state) 
# 934
{ 
# 935
if ((_M_codecvt)->always_noconv()) { 
# 936
return this->gptr() - this->egptr(); } else 
# 938
{ 
# 942
const int __gptr_off = (_M_codecvt)->length(__state, _M_ext_buf, _M_ext_next, this->gptr() - this->eback()); 
# 945
return ((_M_ext_buf) + __gptr_off) - (_M_ext_end); 
# 946
}  
# 947
} 
# 949
template< class _CharT, class _Traits> bool 
# 952
basic_filebuf< _CharT, _Traits> ::_M_terminate_output() 
# 953
{ 
# 955
bool __testvalid = true; 
# 956
if (this->pbase() < this->pptr()) 
# 957
{ 
# 958
const int_type __tmp = overflow(); 
# 959
if (traits_type::eq_int_type(__tmp, traits_type::eof())) { 
# 960
__testvalid = false; }  
# 961
}  
# 964
if ((_M_writing) && (!__check_facet(_M_codecvt).always_noconv()) && __testvalid) 
# 966
{ 
# 970
const std::size_t __blen = (128); 
# 971
char __buf[__blen]; 
# 972
std::codecvt_base::result __r; 
# 973
std::streamsize __ilen = (0); 
# 975
do 
# 976
{ 
# 977
char *__next; 
# 978
__r = (_M_codecvt)->unshift(_M_state_cur, __buf, __buf + __blen, __next); 
# 980
if (__r == (codecvt_base::error)) { 
# 981
__testvalid = false; } else { 
# 982
if ((__r == (codecvt_base::ok)) || (__r == (codecvt_base::partial))) 
# 984
{ 
# 985
__ilen = (__next - __buf); 
# 986
if (__ilen > (0)) 
# 987
{ 
# 988
const std::streamsize __elen = (_M_file).xsputn(__buf, __ilen); 
# 989
if (__elen != __ilen) { 
# 990
__testvalid = false; }  
# 991
}  
# 992
}  }  
# 993
} 
# 994
while ((__r == (codecvt_base::partial)) && (__ilen > (0)) && __testvalid); 
# 996
if (__testvalid) 
# 997
{ 
# 1002
const int_type __tmp = overflow(); 
# 1003
if (traits_type::eq_int_type(__tmp, traits_type::eof())) { 
# 1004
__testvalid = false; }  
# 1005
}  
# 1006
}  
# 1007
return __testvalid; 
# 1008
} 
# 1010
template< class _CharT, class _Traits> int 
# 1013
basic_filebuf< _CharT, _Traits> ::sync() 
# 1014
{ 
# 1017
int __ret = 0; 
# 1018
if (this->pbase() < this->pptr()) 
# 1019
{ 
# 1020
const int_type __tmp = overflow(); 
# 1021
if (traits_type::eq_int_type(__tmp, traits_type::eof())) { 
# 1022
__ret = (-1); }  
# 1023
}  
# 1024
return __ret; 
# 1025
} 
# 1027
template< class _CharT, class _Traits> void 
# 1030
basic_filebuf< _CharT, _Traits> ::imbue(const std::locale &__loc) 
# 1031
{ 
# 1032
bool __testvalid = true; 
# 1034
const __codecvt_type *_M_codecvt_tmp = (0); 
# 1035
if (__builtin_expect(has_facet< __codecvt_type> (__loc), true)) { 
# 1036
_M_codecvt_tmp = (&use_facet< __codecvt_type> (__loc)); }  
# 1038
if (is_open()) 
# 1039
{ 
# 1041
if (((_M_reading) || (_M_writing)) && (__check_facet(_M_codecvt).encoding() == (-1))) { 
# 1043
__testvalid = false; } else 
# 1045
{ 
# 1046
if (_M_reading) 
# 1047
{ 
# 1048
if (__check_facet(_M_codecvt).always_noconv()) 
# 1049
{ 
# 1050
if (_M_codecvt_tmp && (!__check_facet(_M_codecvt_tmp).always_noconv())) { 
# 1052
__testvalid = (seekoff(0, std::ios_base::cur, _M_mode) != ((pos_type)((off_type)(-1)))); }  
# 1054
} else 
# 1056
{ 
# 1058
(_M_ext_next) = ((_M_ext_buf) + (_M_codecvt)->length(_M_state_last, _M_ext_buf, _M_ext_next, this->gptr() - this->eback())); 
# 1062
const std::streamsize __remainder = (_M_ext_end) - (_M_ext_next); 
# 1063
if (__remainder) { 
# 1064
__builtin_memmove(_M_ext_buf, _M_ext_next, __remainder); }  
# 1066
(_M_ext_next) = (_M_ext_buf); 
# 1067
(_M_ext_end) = ((_M_ext_buf) + __remainder); 
# 1068
_M_set_buffer(-1); 
# 1069
(_M_state_last) = ((_M_state_cur) = (_M_state_beg)); 
# 1070
}  
# 1071
} else { 
# 1072
if ((_M_writing) && (__testvalid = _M_terminate_output())) { 
# 1073
_M_set_buffer(-1); }  }  
# 1074
}  
# 1075
}  
# 1077
if (__testvalid) { 
# 1078
(_M_codecvt) = _M_codecvt_tmp; } else { 
# 1080
(_M_codecvt) = 0; }  
# 1081
} 
# 1086
extern template class basic_filebuf< char> ;
# 1087
extern template class basic_ifstream< char> ;
# 1088
extern template class basic_ofstream< char> ;
# 1089
extern template class basic_fstream< char> ;
# 1092
extern template class basic_filebuf< wchar_t> ;
# 1093
extern template class basic_ifstream< wchar_t> ;
# 1094
extern template class basic_ofstream< wchar_t> ;
# 1095
extern template class basic_fstream< wchar_t> ;
# 1100
}
# 53 "/usr/include/opencv4/opencv2/videostab/optical_flow.hpp" 3
namespace cv { 
# 55
namespace videostab { 
# 61
class ISparseOptFlowEstimator { 
# 64
public: virtual ~ISparseOptFlowEstimator() { } 
# 65
virtual void run(InputArray frame0, InputArray frame1, InputArray points0, InputOutputArray points1, OutputArray status, OutputArray errors) = 0; 
# 68
}; 
# 70
class IDenseOptFlowEstimator { 
# 73
public: virtual ~IDenseOptFlowEstimator() { } 
# 74
virtual void run(InputArray frame0, InputArray frame1, InputOutputArray flowX, InputOutputArray flowY, OutputArray errors) = 0; 
# 77
}; 
# 79
class PyrLkOptFlowEstimatorBase { 
# 82
public: PyrLkOptFlowEstimatorBase() { this->setWinSize(Size(21, 21)); this->setMaxLevel(3); } 
# 84
virtual void setWinSize(Size val) { ((winSize_) = val); } 
# 85
virtual Size winSize() const { return winSize_; } 
# 87
virtual void setMaxLevel(int val) { (maxLevel_) = val; } 
# 88
virtual int maxLevel() const { return maxLevel_; } 
# 89
virtual ~PyrLkOptFlowEstimatorBase() { } 
# 92
protected: Size winSize_; 
# 93
int maxLevel_; 
# 94
}; 
# 96
class SparsePyrLkOptFlowEstimator : public PyrLkOptFlowEstimatorBase, public ISparseOptFlowEstimator { 
# 100
public: virtual void run(InputArray frame0, InputArray frame1, InputArray points0, InputOutputArray points1, OutputArray status, OutputArray errors) override; 
# 103
}; 
# 147 "/usr/include/opencv4/opencv2/videostab/optical_flow.hpp" 3
}
# 148
}
# 49 "/usr/include/opencv4/opencv2/videostab/motion_core.hpp" 3
namespace cv { 
# 51
namespace videostab { 
# 59
enum MotionModel { 
# 61
MM_TRANSLATION, 
# 62
MM_TRANSLATION_AND_SCALE, 
# 63
MM_ROTATION, 
# 64
MM_RIGID, 
# 65
MM_SIMILARITY, 
# 66
MM_AFFINE, 
# 67
MM_HOMOGRAPHY, 
# 68
MM_UNKNOWN
# 69
}; 
# 73
struct RansacParams { 
# 75
int size; 
# 76
float thresh; 
# 77
float eps; 
# 78
float prob; 
# 80
RansacParams() : size(0), thresh((0)), eps((0)), prob((0)) { } 
# 87
inline RansacParams(int size, float thresh, float eps, float prob); 
# 92
int niters() const 
# 93
{ 
# 94
return static_cast< int>(std::ceil((std::log((1) - (prob))) / std::log((1) - std::pow((1) - (eps), size)))); 
# 96
} 
# 102
static RansacParams default2dMotion(MotionModel model) 
# 103
{ 
# 104
do { if (!(!(model < (MM_UNKNOWN)))) { ; } else { cv::error(cv::Error::StsAssert, "model < MM_UNKNOWN", __func__, "/usr/include/opencv4/opencv2/videostab/motion_core.hpp", 104); }  } while (0); 
# 105
if (model == (MM_TRANSLATION)) { 
# 106
return RansacParams(1, (0.5F), (0.5F), (0.99F)); }  
# 107
if (model == (MM_TRANSLATION_AND_SCALE)) { 
# 108
return RansacParams(2, (0.5F), (0.5F), (0.99F)); }  
# 109
if (model == (MM_ROTATION)) { 
# 110
return RansacParams(1, (0.5F), (0.5F), (0.99F)); }  
# 111
if (model == (MM_RIGID)) { 
# 112
return RansacParams(2, (0.5F), (0.5F), (0.99F)); }  
# 113
if (model == (MM_SIMILARITY)) { 
# 114
return RansacParams(2, (0.5F), (0.5F), (0.99F)); }  
# 115
if (model == (MM_AFFINE)) { 
# 116
return RansacParams(3, (0.5F), (0.5F), (0.99F)); }  
# 117
return RansacParams(4, (0.5F), (0.5F), (0.99F)); 
# 118
} 
# 119
}; 
# 121
inline RansacParams::RansacParams(int _size, float _thresh, float _eps, float _prob) : size(_size), thresh(_thresh), eps(_eps), prob(_prob) 
# 122
{ } 
# 126
}
# 127
}
# 50 "/usr/include/opencv4/opencv2/videostab/outlier_rejection.hpp" 3
namespace cv { 
# 52
namespace videostab { 
# 58
class IOutlierRejector { 
# 61
public: virtual ~IOutlierRejector() { } 
# 63
virtual void process(Size frameSize, InputArray points0, InputArray points1, OutputArray mask) = 0; 
# 65
}; 
# 67
class NullOutlierRejector : public IOutlierRejector { 
# 70
public: virtual void process(Size frameSize, InputArray points0, InputArray points1, OutputArray mask) override; 
# 72
}; 
# 74
class TranslationBasedLocalOutlierRejector : public IOutlierRejector { 
# 77
public: TranslationBasedLocalOutlierRejector(); 
# 79
void setCellSize(Size val) { ((cellSize_) = val); } 
# 80
Size cellSize() const { return cellSize_; } 
# 82
void setRansacParams(RansacParams val) { (ransacParams_) = val; } 
# 83
RansacParams ransacParams() const { return ransacParams_; } 
# 85
virtual void process(Size frameSize, InputArray points0, InputArray points1, OutputArray mask) override; 
# 89
private: Size cellSize_; 
# 90
RansacParams ransacParams_; 
# 92
typedef std::vector< int>  Cell; 
# 93
std::vector< std::vector< int> >  grid_; 
# 94
}; 
# 98
}
# 99
}
# 59 "/usr/include/opencv4/opencv2/videostab/global_motion.hpp" 3
namespace cv { 
# 61
namespace videostab { 
# 77 "/usr/include/opencv4/opencv2/videostab/global_motion.hpp" 3
Mat estimateGlobalMotionLeastSquares(InputOutputArray points0, InputOutputArray points1, int model = MM_AFFINE, float * rmse = 0); 
# 90 "/usr/include/opencv4/opencv2/videostab/global_motion.hpp" 3
Mat estimateGlobalMotionRansac(InputArray points0, InputArray points1, int model = MM_AFFINE, const RansacParams & params = RansacParams::default2dMotion(MM_AFFINE), float * rmse = 0, int * ninliers = 0); 
# 97
class MotionEstimatorBase { 
# 100
public: virtual ~MotionEstimatorBase() { } 
# 106
virtual void setMotionModel(MotionModel val) { (motionModel_) = val; } 
# 111
virtual MotionModel motionModel() const { return motionModel_; } 
# 120 "/usr/include/opencv4/opencv2/videostab/global_motion.hpp" 3
virtual Mat estimate(InputArray points0, InputArray points1, bool * ok = 0) = 0; 
# 123
protected: MotionEstimatorBase(MotionModel model) { this->setMotionModel(model); } 
# 126
private: MotionModel motionModel_; 
# 127
}; 
# 131
class MotionEstimatorRansacL2 : public MotionEstimatorBase { 
# 134
public: MotionEstimatorRansacL2(MotionModel model = MM_AFFINE); 
# 136
void setRansacParams(const RansacParams &val) { (ransacParams_) = val; } 
# 137
RansacParams ransacParams() const { return ransacParams_; } 
# 139
void setMinInlierRatio(float val) { (minInlierRatio_) = val; } 
# 140
float minInlierRatio() const { return minInlierRatio_; } 
# 142
virtual Mat estimate(InputArray points0, InputArray points1, bool * ok = 0) override; 
# 145
private: RansacParams ransacParams_; 
# 146
float minInlierRatio_; 
# 147
}; 
# 153
class MotionEstimatorL1 : public MotionEstimatorBase { 
# 156
public: MotionEstimatorL1(MotionModel model = MM_AFFINE); 
# 158
virtual Mat estimate(InputArray points0, InputArray points1, bool * ok = 0) override; 
# 161
private: std::vector< double>  obj_, collb_, colub_; 
# 162
std::vector< double>  elems_, rowlb_, rowub_; 
# 163
std::vector< int>  rows_, cols_; 
# 165
void set(int row, int col, double coef) 
# 166
{ 
# 167
(rows_).push_back(row); 
# 168
(cols_).push_back(col); 
# 169
(elems_).push_back(coef); 
# 170
} 
# 171
}; 
# 175
class ImageMotionEstimatorBase { 
# 178
public: virtual ~ImageMotionEstimatorBase() { } 
# 180
virtual void setMotionModel(MotionModel val) { (motionModel_) = val; } 
# 181
virtual MotionModel motionModel() const { return motionModel_; } 
# 183
virtual void setFrameMask(InputArray mask) 
# 184
{ 
# 185
if (!mask.empty()) { 
# 186
cv::error(Error::StsNotImplemented, "Mask support is not implemented.", __func__, "/usr/include/opencv4/opencv2/videostab/global_motion.hpp", 186); }  
# 187
} 
# 189
virtual Mat estimate(const Mat & frame0, const Mat & frame1, bool * ok = 0) = 0; 
# 192
protected: ImageMotionEstimatorBase(MotionModel model) { this->setMotionModel(model); } 
# 195
private: MotionModel motionModel_; 
# 196
}; 
# 198
class FromFileMotionReader : public ImageMotionEstimatorBase { 
# 201
public: FromFileMotionReader(const String & path); 
# 203
virtual Mat estimate(const Mat & frame0, const Mat & frame1, bool * ok = 0) override; 
# 206
private: std::ifstream file_; 
# 207
}; 
# 209
class ToFileMotionWriter : public ImageMotionEstimatorBase { 
# 212
public: ToFileMotionWriter(const String & path, Ptr< ImageMotionEstimatorBase>  estimator); 
# 214
virtual void setMotionModel(MotionModel val) override { (motionEstimator_)->setMotionModel(val); } 
# 215
virtual MotionModel motionModel() const override { return (motionEstimator_)->motionModel(); } 
# 217
virtual void setFrameMask(InputArray mask) override { (motionEstimator_)->setFrameMask(mask); } 
# 219
virtual Mat estimate(const Mat & frame0, const Mat & frame1, bool * ok = 0) override; 
# 222
private: std::ofstream file_; 
# 223
Ptr< ImageMotionEstimatorBase>  motionEstimator_; 
# 224
}; 
# 229
class KeypointBasedMotionEstimator : public ImageMotionEstimatorBase { 
# 232
public: KeypointBasedMotionEstimator(Ptr< MotionEstimatorBase>  estimator); 
# 234
virtual void setMotionModel(MotionModel val) override { (motionEstimator_)->setMotionModel(val); } 
# 235
virtual MotionModel motionModel() const override { return (motionEstimator_)->motionModel(); } 
# 237
void setDetector(Ptr< Feature2D>  val) { ((detector_) = val); } 
# 238
Ptr< Feature2D>  detector() const { return detector_; } 
# 240
void setOpticalFlowEstimator(Ptr< ISparseOptFlowEstimator>  val) { ((optFlowEstimator_) = val); } 
# 241
Ptr< ISparseOptFlowEstimator>  opticalFlowEstimator() const { return optFlowEstimator_; } 
# 243
void setOutlierRejector(Ptr< IOutlierRejector>  val) { ((outlierRejector_) = val); } 
# 244
Ptr< IOutlierRejector>  outlierRejector() const { return outlierRejector_; } 
# 246
virtual void setFrameMask(InputArray mask) override { ((mask_) = (mask.getMat())); } 
# 248
virtual Mat estimate(const Mat & frame0, const Mat & frame1, bool * ok = 0) override; 
# 249
Mat estimate(InputArray frame0, InputArray frame1, bool * ok = 0); 
# 252
private: Ptr< MotionEstimatorBase>  motionEstimator_; 
# 253
Ptr< Feature2D>  detector_; 
# 254
Ptr< ISparseOptFlowEstimator>  optFlowEstimator_; 
# 255
Ptr< IOutlierRejector>  outlierRejector_; 
# 256
Mat mask_; 
# 258
std::vector< unsigned char>  status_; 
# 259
std::vector< KeyPoint>  keypointsPrev_; 
# 260
std::vector< Point_< float> >  pointsPrev_, points_; 
# 261
std::vector< Point_< float> >  pointsPrevGood_, pointsGood_; 
# 262
}; 
# 304 "/usr/include/opencv4/opencv2/videostab/global_motion.hpp" 3
Mat getMotion(int from, int to, const std::vector< Mat>  & motions); 
# 308
}
# 309
}
# 51 "/usr/include/opencv4/opencv2/videostab/motion_stabilizing.hpp" 3
namespace cv { 
# 53
namespace videostab { 
# 59
class IMotionStabilizer { 
# 62
public: virtual ~IMotionStabilizer() { } 
# 65
virtual void stabilize(int size, const std::vector< Mat>  & motions, std::pair< int, int>  range, Mat * stabilizationMotions) = 0; 
# 68
}; 
# 70
class MotionStabilizationPipeline : public IMotionStabilizer { 
# 73
public: void pushBack(Ptr< IMotionStabilizer>  stabilizer) { (stabilizers_).push_back(stabilizer); } 
# 74
bool empty() const { return (stabilizers_).empty(); } 
# 76
virtual void stabilize(int size, const std::vector< Mat>  & motions, std::pair< int, int>  range, Mat * stabilizationMotions) override; 
# 81
private: std::vector< Ptr< IMotionStabilizer> >  stabilizers_; 
# 82
}; 
# 84
class MotionFilterBase : public IMotionStabilizer { 
# 87
public: virtual ~MotionFilterBase() { } 
# 89
virtual Mat stabilize(int idx, const std::vector< Mat>  & motions, std::pair< int, int>  range) = 0; 
# 92
virtual void stabilize(int size, const std::vector< Mat>  & motions, std::pair< int, int>  range, Mat * stabilizationMotions) override; 
# 95
}; 
# 97
class GaussianMotionFilter : public MotionFilterBase { 
# 100
public: inline GaussianMotionFilter(int radius = 15, float stdev = -(1.0F)); 
# 102
void setParams(int radius, float stdev = -(1.0F)); 
# 103
int radius() const { return radius_; } 
# 104
float stdev() const { return stdev_; } 
# 106
virtual Mat stabilize(int idx, const std::vector< Mat>  & motions, std::pair< int, int>  range) override; 
# 110
private: int radius_; 
# 111
float stdev_; 
# 112
std::vector< float>  weight_; 
# 113
}; 
# 115
inline GaussianMotionFilter::GaussianMotionFilter(int _radius, float _stdev) { this->setParams(_radius, _stdev); } 
# 117
class LpMotionStabilizer : public IMotionStabilizer { 
# 120
public: LpMotionStabilizer(MotionModel model = MM_SIMILARITY); 
# 122
void setMotionModel(MotionModel val) { (model_) = val; } 
# 123
MotionModel motionModel() const { return model_; } 
# 125
void setFrameSize(Size val) { ((frameSize_) = val); } 
# 126
Size frameSize() const { return frameSize_; } 
# 128
void setTrimRatio(float val) { (trimRatio_) = val; } 
# 129
float trimRatio() const { return trimRatio_; } 
# 131
void setWeight1(float val) { (w1_) = val; } 
# 132
float weight1() const { return w1_; } 
# 134
void setWeight2(float val) { (w2_) = val; } 
# 135
float weight2() const { return w2_; } 
# 137
void setWeight3(float val) { (w3_) = val; } 
# 138
float weight3() const { return w3_; } 
# 140
void setWeight4(float val) { (w4_) = val; } 
# 141
float weight4() const { return w4_; } 
# 143
virtual void stabilize(int size, const std::vector< Mat>  & motions, std::pair< int, int>  range, Mat * stabilizationMotions) override; 
# 148
private: MotionModel model_; 
# 149
Size frameSize_; 
# 150
float trimRatio_; 
# 151
float w1_, w2_, w3_, w4_; 
# 153
std::vector< double>  obj_, collb_, colub_; 
# 154
std::vector< int>  rows_, cols_; 
# 155
std::vector< double>  elems_, rowlb_, rowub_; 
# 157
void set(int row, int col, double coef) 
# 158
{ 
# 159
(rows_).push_back(row); 
# 160
(cols_).push_back(col); 
# 161
(elems_).push_back(coef); 
# 162
} 
# 163
}; 
# 165
Mat ensureInclusionConstraint(const Mat & M, Size size, float trimRatio); 
# 167
float estimateOptimalTrimRatio(const Mat & M, Size size); 
# 171
}
# 172
}
# 49 "/usr/include/opencv4/opencv2/videostab/frame_source.hpp" 3
namespace cv { 
# 51
namespace videostab { 
# 57
class IFrameSource { 
# 60
public: virtual ~IFrameSource() { } 
# 61
virtual void reset() = 0; 
# 62
virtual Mat nextFrame() = 0; 
# 63
}; 
# 65
class NullFrameSource : public IFrameSource { 
# 68
public: virtual void reset() override { } 
# 69
virtual Mat nextFrame() override { return Mat(); } 
# 70
}; 
# 72
class VideoFileSource : public IFrameSource { 
# 75
public: VideoFileSource(const String & path, bool volatileFrame = false); 
# 77
virtual void reset() override; 
# 78
virtual Mat nextFrame() override; 
# 80
int width(); 
# 81
int height(); 
# 82
int count(); 
# 83
double fps(); 
# 86
private: Ptr< IFrameSource>  impl; 
# 87
}; 
# 89
class MaskFrameSource : public IFrameSource { 
# 92
public: MaskFrameSource(const Ptr< IFrameSource>  &source) : impl(source) { } 
# 94
virtual void reset() override { (impl)->reset(); } 
# 95
virtual Mat nextFrame() override { 
# 96
Mat nextFrame = (impl)->nextFrame(); 
# 97
(maskCallback_)(nextFrame); 
# 98
return nextFrame; 
# 99
} 
# 101
void setMaskCallback(std::function< void (Mat &)>  MaskCallback) 
# 102
{ 
# 103
((maskCallback_) = (std::bind(MaskCallback, std::placeholders::_1))); 
# 104
} 
# 107
private: Ptr< IFrameSource>  impl; 
# 108
std::function< void (Mat &)>  maskCallback_; 
# 109
}; 
# 113
}
# 114
}
# 48 "/usr/include/opencv4/opencv2/videostab/log.hpp" 3
namespace cv { 
# 50
namespace videostab { 
# 56
class ILog { 
# 59
public: virtual ~ILog() { } 
# 60
virtual void print(const char * format, ...) = 0; 
# 61
}; 
# 63
class NullLog : public ILog { 
# 66
public: virtual void print(const char *, ...) override { } 
# 67
}; 
# 69
class LogToStdout : public ILog { 
# 72
public: virtual void print(const char * format, ...) override; 
# 73
}; 
# 77
}
# 78
}
# 51 "/usr/include/opencv4/opencv2/videostab/fast_marching.hpp" 3
namespace cv { 
# 53
namespace videostab { 
# 63 "/usr/include/opencv4/opencv2/videostab/fast_marching.hpp" 3
class FastMarchingMethod { 
# 66
public: FastMarchingMethod() : inf_((1000000.0F)), size_(0) { } 
# 75 "/usr/include/opencv4/opencv2/videostab/fast_marching.hpp" 3
template< class Inpaint> Inpaint run(const Mat & mask, Inpaint inpaint); 
# 81
Mat distanceMap() const { return dist_; } 
# 84
private: enum { INSIDE, BAND, KNOWN = 255}; 
# 86
struct DXY { 
# 88
float dist; 
# 89
int x, y; 
# 91
DXY() : dist((0)), x(0), y(0) { } 
# 92
DXY(float _dist, int _x, int _y) : dist(_dist), x(_x), y(_y) { } 
# 93
bool operator<(const DXY &dxy) const { return (dist) < (dxy.dist); } 
# 94
}; 
# 96
float solve(int x1, int y1, int x2, int y2) const; 
# 97
int &indexOf(const DXY &dxy) { return (index_)(dxy.y, dxy.x); } 
# 99
void heapUp(int idx); 
# 100
void heapDown(int idx); 
# 101
void heapAdd(const DXY & dxy); 
# 102
void heapRemoveMin(); 
# 104
float inf_; 
# 106
Mat_< unsigned char>  flag_; 
# 107
Mat_< float>  dist_; 
# 109
Mat_< int>  index_; 
# 110
std::vector< DXY>  narrowBand_; 
# 111
int size_; 
# 112
}; 
# 116
}
# 117
}
# 48 "/usr/include/opencv4/opencv2/videostab/fast_marching_inl.hpp" 3
namespace cv { 
# 50
namespace videostab { 
# 53
template< class Inpaint> Inpaint 
# 54
FastMarchingMethod::run(const Mat &mask, Inpaint inpaint) 
# 55
{ 
# 56
using namespace cv;
# 58
do { if (!(!(mask.type() == 0))) { ; } else { cv::error(cv::Error::StsAssert, "mask.type() == CV_8U", __func__, "/usr/include/opencv4/opencv2/videostab/fast_marching_inl.hpp", 58); }  } while (0); 
# 60
static const int lut[4][2] = {{(-1), 0}, {0, (-1)}, {1, 0}, {0, 1}}; 
# 62
mask.copyTo(flag_); 
# 63
(flag_).create((mask.size)()); 
# 64
(dist_).create((mask.size)()); 
# 65
(index_).create((mask.size)()); 
# 66
(narrowBand_).clear(); 
# 67
(size_) = 0; 
# 70
for (int y = 0; y < ((flag_).rows); ++y) 
# 71
{ 
# 72
for (int x = 0; x < ((flag_).cols); ++x) 
# 73
{ 
# 74
if (((flag_)(y, x)) == (KNOWN)) { 
# 75
(dist_)(y, x) = (0.0F); } else 
# 77
{ 
# 78
int n = 0; 
# 79
int nunknown = 0; 
# 81
for (int i = 0; i < 4; ++i) 
# 82
{ 
# 83
int xn = x + ((lut[i])[0]); 
# 84
int yn = y + ((lut[i])[1]); 
# 86
if ((xn >= 0) && (xn < ((flag_).cols)) && (yn >= 0) && (yn < ((flag_).rows))) 
# 87
{ 
# 88
n++; 
# 89
if (((flag_)(yn, xn)) != (KNOWN)) { 
# 90
nunknown++; }  
# 91
}  
# 92
}  
# 94
if ((n > 0) && (nunknown == n)) 
# 95
{ 
# 96
(dist_)(y, x) = (inf_); 
# 97
(flag_)(y, x) = (INSIDE); 
# 98
} else 
# 100
{ 
# 101
(dist_)(y, x) = (0.0F); 
# 102
(flag_)(y, x) = (BAND); 
# 103
inpaint(x, y); 
# 105
(narrowBand_).push_back(DXY((0.0F), x, y)); 
# 106
(index_)(y, x) = ((size_)++); 
# 107
}  
# 108
}  
# 109
}  
# 110
}  
# 113
for (int i = ((size_) / 2) - 1; i >= 0; --i) { 
# 114
this->heapDown(i); }  
# 117
while ((size_) > 0) 
# 118
{ 
# 119
int x = (narrowBand_)[0].x; 
# 120
int y = (narrowBand_)[0].y; 
# 121
this->heapRemoveMin(); 
# 123
(flag_)(y, x) = (KNOWN); 
# 124
for (int n = 0; n < 4; ++n) 
# 125
{ 
# 126
int xn = x + ((lut[n])[0]); 
# 127
int yn = y + ((lut[n])[1]); 
# 129
if ((xn >= 0) && (xn < ((flag_).cols)) && (yn >= 0) && (yn < ((flag_).rows)) && (((flag_)(yn, xn)) != (KNOWN))) 
# 130
{ 
# 131
(dist_)(yn, xn) = std::min(std::min(this->solve(xn - 1, yn, xn, yn - 1), this->solve(xn + 1, yn, xn, yn - 1)), std::min(this->solve(xn - 1, yn, xn, yn + 1), this->solve(xn + 1, yn, xn, yn + 1))); 
# 134
if (((flag_)(yn, xn)) == (INSIDE)) 
# 135
{ 
# 136
(flag_)(yn, xn) = (BAND); 
# 137
inpaint(xn, yn); 
# 138
this->heapAdd(DXY((dist_)(yn, xn), xn, yn)); 
# 139
} else 
# 141
{ 
# 142
int i = (index_)(yn, xn); 
# 143
if ((dist_)(yn, xn) < ((narrowBand_)[i].dist)) 
# 144
{ 
# 145
((narrowBand_)[i].dist) = (dist_)(yn, xn); 
# 146
this->heapUp(i); 
# 147
}  
# 154
}  
# 155
}  
# 156
}  
# 157
}  
# 159
return inpaint; 
# 160
} 
# 162
}
# 163
}
# 53 "/usr/include/opencv4/opencv2/videostab/inpainting.hpp" 3
namespace cv { 
# 55
namespace videostab { 
# 61
class InpainterBase { 
# 64
public: InpainterBase() : radius_(0), motionModel_(MM_UNKNOWN), frames_((0)), motions_((0)), stabilizedFrames_((0)), stabilizationMotions_((0)) 
# 66
{ } 
# 68
virtual ~InpainterBase() { } 
# 70
virtual void setRadius(int val) { (radius_) = val; } 
# 71
virtual int radius() const { return radius_; } 
# 73
virtual void setMotionModel(MotionModel val) { (motionModel_) = val; } 
# 74
virtual MotionModel motionModel() const { return motionModel_; } 
# 76
virtual void inpaint(int idx, Mat & frame, Mat & mask) = 0; 
# 81
virtual void setFrames(const std::vector< Mat>  &val) { (frames_) = (&val); } 
# 82
virtual const std::vector< Mat>  &frames() const { return *(frames_); } 
# 84
virtual void setMotions(const std::vector< Mat>  &val) { (motions_) = (&val); } 
# 85
virtual const std::vector< Mat>  &motions() const { return *(motions_); } 
# 87
virtual void setStabilizedFrames(const std::vector< Mat>  &val) { (stabilizedFrames_) = (&val); } 
# 88
virtual const std::vector< Mat>  &stabilizedFrames() const { return *(stabilizedFrames_); } 
# 90
virtual void setStabilizationMotions(const std::vector< Mat>  &val) { (stabilizationMotions_) = (&val); } 
# 91
virtual const std::vector< Mat>  &stabilizationMotions() const { return *(stabilizationMotions_); } 
# 94
protected: int radius_; 
# 95
MotionModel motionModel_; 
# 96
const std::vector< Mat>  *frames_; 
# 97
const std::vector< Mat>  *motions_; 
# 98
const std::vector< Mat>  *stabilizedFrames_; 
# 99
const std::vector< Mat>  *stabilizationMotions_; 
# 100
}; 
# 102
class NullInpainter : public InpainterBase { 
# 105
public: virtual void inpaint(int, Mat &, Mat &) override { } 
# 106
}; 
# 108
class InpaintingPipeline : public InpainterBase { 
# 111
public: void pushBack(Ptr< InpainterBase>  inpainter) { (inpainters_).push_back(inpainter); } 
# 112
bool empty() const { return (inpainters_).empty(); } 
# 114
virtual void setRadius(int val) override; 
# 115
virtual void setMotionModel(MotionModel val) override; 
# 116
virtual void setFrames(const std::vector< Mat>  & val) override; 
# 117
virtual void setMotions(const std::vector< Mat>  & val) override; 
# 118
virtual void setStabilizedFrames(const std::vector< Mat>  & val) override; 
# 119
virtual void setStabilizationMotions(const std::vector< Mat>  & val) override; 
# 121
virtual void inpaint(int idx, Mat & frame, Mat & mask) override; 
# 124
private: std::vector< Ptr< InpainterBase> >  inpainters_; 
# 125
}; 
# 127
class ConsistentMosaicInpainter : public InpainterBase { 
# 130
public: ConsistentMosaicInpainter(); 
# 132
void setStdevThresh(float val) { (stdevThresh_) = val; } 
# 133
float stdevThresh() const { return stdevThresh_; } 
# 135
virtual void inpaint(int idx, Mat & frame, Mat & mask) override; 
# 138
private: float stdevThresh_; 
# 139
}; 
# 141
class MotionInpainter : public InpainterBase { 
# 144
public: MotionInpainter(); 
# 146
void setOptFlowEstimator(Ptr< IDenseOptFlowEstimator>  val) { ((optFlowEstimator_) = val); } 
# 147
Ptr< IDenseOptFlowEstimator>  optFlowEstimator() const { return optFlowEstimator_; } 
# 149
void setFlowErrorThreshold(float val) { (flowErrorThreshold_) = val; } 
# 150
float flowErrorThreshold() const { return flowErrorThreshold_; } 
# 152
void setDistThreshold(float val) { (distThresh_) = val; } 
# 153
float distThresh() const { return distThresh_; } 
# 155
void setBorderMode(int val) { (borderMode_) = val; } 
# 156
int borderMode() const { return borderMode_; } 
# 158
virtual void inpaint(int idx, Mat & frame, Mat & mask) override; 
# 161
private: FastMarchingMethod fmm_; 
# 162
Ptr< IDenseOptFlowEstimator>  optFlowEstimator_; 
# 163
float flowErrorThreshold_; 
# 164
float distThresh_; 
# 165
int borderMode_; 
# 167
Mat frame1_, transformedFrame1_; 
# 168
Mat_< unsigned char>  grayFrame_, transformedGrayFrame1_; 
# 169
Mat_< unsigned char>  mask1_, transformedMask1_; 
# 170
Mat_< float>  flowX_, flowY_, flowErrors_; 
# 171
Mat_< unsigned char>  flowMask_; 
# 172
}; 
# 174
class ColorAverageInpainter : public InpainterBase { 
# 177
public: virtual void inpaint(int idx, Mat & frame, Mat & mask) override; 
# 180
private: FastMarchingMethod fmm_; 
# 181
}; 
# 183
class ColorInpainter : public InpainterBase { 
# 186
public: inline ColorInpainter(int method = INPAINT_TELEA, double radius = (2.0)); 
# 188
virtual void inpaint(int idx, Mat & frame, Mat & mask) override; 
# 191
private: int method_; 
# 192
double radius_; 
# 193
Mat invMask_; 
# 194
}; 
# 196
inline ColorInpainter::ColorInpainter(int _method, double _radius) : method_(_method), radius_(_radius) 
# 197
{ } 
# 199
void calcFlowMask(const Mat & flowX, const Mat & flowY, const Mat & errors, float maxError, const Mat & mask0, const Mat & mask1, Mat & flowMask); 
# 203
void completeFrameAccordingToFlow(const Mat & flowMask, const Mat & flowX, const Mat & flowY, const Mat & frame1, const Mat & mask1, float distThresh, Mat & frame0, Mat & mask0); 
# 209
}
# 210
}
# 49 "/usr/include/opencv4/opencv2/videostab/deblurring.hpp" 3
namespace cv { 
# 51
namespace videostab { 
# 57
float calcBlurriness(const Mat & frame); 
# 59
class DeblurerBase { 
# 62
public: DeblurerBase() : radius_(0), frames_((0)), motions_((0)), blurrinessRates_((0)) { } 
# 64
virtual ~DeblurerBase() { } 
# 66
virtual void setRadius(int val) { (radius_) = val; } 
# 67
virtual int radius() const { return radius_; } 
# 69
virtual void deblur(int idx, Mat & frame) = 0; 
# 74
virtual void setFrames(const std::vector< Mat>  &val) { (frames_) = (&val); } 
# 75
virtual const std::vector< Mat>  &frames() const { return *(frames_); } 
# 77
virtual void setMotions(const std::vector< Mat>  &val) { (motions_) = (&val); } 
# 78
virtual const std::vector< Mat>  &motions() const { return *(motions_); } 
# 80
virtual void setBlurrinessRates(const std::vector< float>  &val) { (blurrinessRates_) = (&val); } 
# 81
virtual const std::vector< float>  &blurrinessRates() const { return *(blurrinessRates_); } 
# 84
protected: int radius_; 
# 85
const std::vector< Mat>  *frames_; 
# 86
const std::vector< Mat>  *motions_; 
# 87
const std::vector< float>  *blurrinessRates_; 
# 88
}; 
# 90
class NullDeblurer : public DeblurerBase { 
# 93
public: virtual void deblur(int, Mat &) override { } 
# 94
}; 
# 96
class WeightingDeblurer : public DeblurerBase { 
# 99
public: WeightingDeblurer(); 
# 101
void setSensitivity(float val) { (sensitivity_) = val; } 
# 102
float sensitivity() const { return sensitivity_; } 
# 104
virtual void deblur(int idx, Mat & frame) override; 
# 107
private: float sensitivity_; 
# 108
Mat_< float>  bSum_, gSum_, rSum_, wSum_; 
# 109
}; 
# 113
}
# 114
}
# 52 "/usr/include/opencv4/opencv2/videostab/wobble_suppression.hpp" 3
namespace cv { 
# 54
namespace videostab { 
# 60
class WobbleSuppressorBase { 
# 63
public: WobbleSuppressorBase(); 
# 65
virtual ~WobbleSuppressorBase() { } 
# 67
void setMotionEstimator(Ptr< ImageMotionEstimatorBase>  val) { ((motionEstimator_) = val); } 
# 68
Ptr< ImageMotionEstimatorBase>  motionEstimator() const { return motionEstimator_; } 
# 70
virtual void suppress(int idx, const Mat & frame, Mat & result) = 0; 
# 75
virtual void setFrameCount(int val) { (frameCount_) = val; } 
# 76
virtual int frameCount() const { return frameCount_; } 
# 78
virtual void setMotions(const std::vector< Mat>  &val) { (motions_) = (&val); } 
# 79
virtual const std::vector< Mat>  &motions() const { return *(motions_); } 
# 81
virtual void setMotions2(const std::vector< Mat>  &val) { (motions2_) = (&val); } 
# 82
virtual const std::vector< Mat>  &motions2() const { return *(motions2_); } 
# 84
virtual void setStabilizationMotions(const std::vector< Mat>  &val) { (stabilizationMotions_) = (&val); } 
# 85
virtual const std::vector< Mat>  &stabilizationMotions() const { return *(stabilizationMotions_); } 
# 88
protected: Ptr< ImageMotionEstimatorBase>  motionEstimator_; 
# 89
int frameCount_; 
# 90
const std::vector< Mat>  *motions_; 
# 91
const std::vector< Mat>  *motions2_; 
# 92
const std::vector< Mat>  *stabilizationMotions_; 
# 93
}; 
# 95
class NullWobbleSuppressor : public WobbleSuppressorBase { 
# 98
public: virtual void suppress(int idx, const Mat & frame, Mat & result) override; 
# 99
}; 
# 101
class MoreAccurateMotionWobbleSuppressorBase : public WobbleSuppressorBase { 
# 104
public: virtual void setPeriod(int val) { (period_) = val; } 
# 105
virtual int period() const { return period_; } 
# 108
protected: MoreAccurateMotionWobbleSuppressorBase() { this->setPeriod(30); } 
# 110
int period_; 
# 111
}; 
# 113
class MoreAccurateMotionWobbleSuppressor : public MoreAccurateMotionWobbleSuppressorBase { 
# 116
public: virtual void suppress(int idx, const Mat & frame, Mat & result) override; 
# 119
private: Mat_< float>  mapx_, mapy_; 
# 120
}; 
# 137 "/usr/include/opencv4/opencv2/videostab/wobble_suppression.hpp" 3
}
# 138
}
# 58 "/usr/include/opencv4/opencv2/videostab/stabilizer.hpp" 3
namespace cv { 
# 60
namespace videostab { 
# 66
class StabilizerBase { 
# 69
public: virtual ~StabilizerBase() { } 
# 71
void setLog(Ptr< ILog>  ilog) { ((log_) = ilog); } 
# 72
Ptr< ILog>  log() const { return log_; } 
# 74
void setRadius(int val) { (radius_) = val; } 
# 75
int radius() const { return radius_; } 
# 77
void setFrameSource(Ptr< IFrameSource>  val) { ((frameSource_) = val); } 
# 78
Ptr< IFrameSource>  frameSource() const { return frameSource_; } 
# 80
void setMaskSource(const Ptr< IFrameSource>  &val) { ((maskSource_) = val); } 
# 81
Ptr< IFrameSource>  maskSource() const { return maskSource_; } 
# 83
void setMotionEstimator(Ptr< ImageMotionEstimatorBase>  val) { ((motionEstimator_) = val); } 
# 84
Ptr< ImageMotionEstimatorBase>  motionEstimator() const { return motionEstimator_; } 
# 86
void setDeblurer(Ptr< DeblurerBase>  val) { ((deblurer_) = val); } 
# 87
Ptr< DeblurerBase>  deblurrer() const { return deblurer_; } 
# 89
void setTrimRatio(float val) { (trimRatio_) = val; } 
# 90
float trimRatio() const { return trimRatio_; } 
# 92
void setCorrectionForInclusion(bool val) { (doCorrectionForInclusion_) = val; } 
# 93
bool doCorrectionForInclusion() const { return doCorrectionForInclusion_; } 
# 95
void setBorderMode(int val) { (borderMode_) = val; } 
# 96
int borderMode() const { return borderMode_; } 
# 98
void setInpainter(Ptr< InpainterBase>  val) { ((inpainter_) = val); } 
# 99
Ptr< InpainterBase>  inpainter() const { return inpainter_; } 
# 102
protected: StabilizerBase(); 
# 104
void reset(); 
# 105
Mat nextStabilizedFrame(); 
# 106
bool doOneIteration(); 
# 107
virtual void setUp(const Mat & firstFrame); 
# 108
virtual Mat estimateMotion() = 0; 
# 109
virtual Mat estimateStabilizationMotion() = 0; 
# 110
void stabilizeFrame(); 
# 111
virtual Mat postProcessFrame(const Mat & frame); 
# 112
void logProcessingTime(); 
# 114
Ptr< ILog>  log_; 
# 115
Ptr< IFrameSource>  frameSource_; 
# 116
Ptr< IFrameSource>  maskSource_; 
# 117
Ptr< ImageMotionEstimatorBase>  motionEstimator_; 
# 118
Ptr< DeblurerBase>  deblurer_; 
# 119
Ptr< InpainterBase>  inpainter_; 
# 120
int radius_; 
# 121
float trimRatio_; 
# 122
bool doCorrectionForInclusion_; 
# 123
int borderMode_; 
# 125
Size frameSize_; 
# 126
Mat frameMask_; 
# 127
int curPos_; 
# 128
int curStabilizedPos_; 
# 129
bool doDeblurring_; 
# 130
Mat preProcessedFrame_; 
# 131
bool doInpainting_; 
# 132
Mat inpaintingMask_; 
# 133
Mat finalFrame_; 
# 134
std::vector< Mat>  frames_; 
# 135
std::vector< Mat>  motions_; 
# 136
std::vector< float>  blurrinessRates_; 
# 137
std::vector< Mat>  stabilizedFrames_; 
# 138
std::vector< Mat>  stabilizedMasks_; 
# 139
std::vector< Mat>  stabilizationMotions_; 
# 140
clock_t processingStartTime_; 
# 141
}; 
# 143
class OnePassStabilizer : public StabilizerBase, public IFrameSource { 
# 146
public: OnePassStabilizer(); 
# 148
void setMotionFilter(Ptr< MotionFilterBase>  val) { ((motionFilter_) = val); } 
# 149
Ptr< MotionFilterBase>  motionFilter() const { return motionFilter_; } 
# 151
virtual void reset() override; 
# 152
virtual Mat nextFrame() override { return this->nextStabilizedFrame(); } 
# 155
protected: virtual void setUp(const Mat & firstFrame) override; 
# 156
virtual Mat estimateMotion() override; 
# 157
virtual Mat estimateStabilizationMotion() override; 
# 158
virtual Mat postProcessFrame(const Mat & frame) override; 
# 160
Ptr< MotionFilterBase>  motionFilter_; 
# 161
}; 
# 163
class TwoPassStabilizer : public StabilizerBase, public IFrameSource { 
# 166
public: TwoPassStabilizer(); 
# 168
void setMotionStabilizer(Ptr< IMotionStabilizer>  val) { ((motionStabilizer_) = val); } 
# 169
Ptr< IMotionStabilizer>  motionStabilizer() const { return motionStabilizer_; } 
# 171
void setWobbleSuppressor(Ptr< WobbleSuppressorBase>  val) { ((wobbleSuppressor_) = val); } 
# 172
Ptr< WobbleSuppressorBase>  wobbleSuppressor() const { return wobbleSuppressor_; } 
# 174
void setEstimateTrimRatio(bool val) { (mustEstTrimRatio_) = val; } 
# 175
bool mustEstimateTrimaRatio() const { return mustEstTrimRatio_; } 
# 177
virtual void reset() override; 
# 178
virtual Mat nextFrame() override; 
# 181
protected: void runPrePassIfNecessary(); 
# 183
virtual void setUp(const Mat & firstFrame) override; 
# 184
virtual Mat estimateMotion() override; 
# 185
virtual Mat estimateStabilizationMotion() override; 
# 186
virtual Mat postProcessFrame(const Mat & frame) override; 
# 188
Ptr< IMotionStabilizer>  motionStabilizer_; 
# 189
Ptr< WobbleSuppressorBase>  wobbleSuppressor_; 
# 190
bool mustEstTrimRatio_; 
# 192
int frameCount_; 
# 193
bool isPrePassDone_; 
# 194
bool doWobbleSuppression_; 
# 195
std::vector< Mat>  motions2_; 
# 196
Mat suppressedFrame_; 
# 197
}; 
# 201
}
# 202
}
# 49 "/usr/include/opencv4/opencv2/videostab/ring_buffer.hpp" 3
namespace cv { 
# 51
namespace videostab { 
# 57
template< class T> inline T &at(int idx, std::vector< T>  &items) 
# 58
{ 
# 59
return items[cv::borderInterpolate(idx, static_cast< int>(items.size()), cv::BORDER_WRAP)]; 
# 60
} 
# 62
template< class T> inline const T &at(int idx, const std::vector< T>  &items) 
# 63
{ 
# 64
return items[cv::borderInterpolate(idx, static_cast< int>(items.size()), cv::BORDER_WRAP)]; 
# 65
} 
# 69
}
# 70
}
# 53 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
namespace cv { 
# 55
namespace viz { 
# 63
class Color : public Scalar { 
# 66
public: inline Color(); 
# 68
inline Color(double gray); 
# 69
inline Color(double blue, double green, double red); 
# 71
inline Color(const Scalar & color); 
# 73
inline operator Vec3b() const; 
# 75
static inline Color black(); 
# 76
static inline Color blue(); 
# 77
static inline Color green(); 
# 78
static inline Color red(); 
# 79
static inline Color cyan(); 
# 80
static inline Color yellow(); 
# 81
static inline Color magenta(); 
# 82
static inline Color white(); 
# 84
static inline Color gray(); 
# 85
static inline Color silver(); 
# 87
static inline Color mlab(); 
# 89
static inline Color navy(); 
# 90
static inline Color maroon(); 
# 91
static inline Color teal(); 
# 92
static inline Color olive(); 
# 93
static inline Color purple(); 
# 94
static inline Color azure(); 
# 95
static inline Color chartreuse(); 
# 96
static inline Color rose(); 
# 98
static inline Color lime(); 
# 99
static inline Color gold(); 
# 100
static inline Color orange(); 
# 101
static inline Color orange_red(); 
# 102
static inline Color indigo(); 
# 104
static inline Color brown(); 
# 105
static inline Color apricot(); 
# 106
static inline Color pink(); 
# 107
static inline Color raspberry(); 
# 108
static inline Color cherry(); 
# 109
static inline Color violet(); 
# 110
static inline Color amethyst(); 
# 111
static inline Color bluberry(); 
# 112
static inline Color celestial_blue(); 
# 113
static inline Color turquoise(); 
# 115
static inline Color not_set(); 
# 116
}; 
# 120
class Mesh { 
# 123
public: enum { 
# 124
LOAD_AUTO, 
# 125
LOAD_PLY, 
# 126
LOAD_OBJ
# 127
}; 
# 129
Mat cloud; 
# 130
Mat colors; 
# 131
Mat normals; 
# 135
Mat polygons; 
# 137
Mat texture; 
# 138
Mat tcoords; 
# 149 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
static Mesh load(const String & file, int type = LOAD_PLY); 
# 151
}; 
# 158
class Camera { 
# 171 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
public: Camera(double fx, double fy, double cx, double cy, const Size & window_size); 
# 178
Camera(const Vec2d & fov, const Size & window_size); 
# 192 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
Camera(const Matx33d & K, const Size & window_size); 
# 208 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
explicit Camera(const Matx44d & proj, const Size & window_size); 
# 210
const Vec2d &getClip() const { return clip_; } 
# 211
void setClip(const Vec2d &clip) { (clip_) = clip; } 
# 213
const Size &getWindowSize() const { return window_size_; } 
# 214
void setWindowSize(const Size & window_size); 
# 216
const Vec2d &getFov() const { return fov_; } 
# 217
void setFov(const Vec2d &fov) { (fov_) = fov; } 
# 219
const Vec2d &getPrincipalPoint() const { return principal_point_; } 
# 220
const Vec2d &getFocalLength() const { return focal_; } 
# 235 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
void computeProjectionMatrix(Matx44d & proj) const; 
# 245 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
static Camera KinectCamera(const Size & window_size); 
# 248
private: void init(double fx, double fy, double cx, double cy, const Size & window_size); 
# 254
Vec2d clip_; 
# 261
Vec2d fov_; 
# 264
Size window_size_; 
# 271
Vec2d principal_point_; 
# 277
Vec2d focal_; 
# 278
}; 
# 282
class KeyboardEvent { 
# 285
public: enum { NONE, ALT, CTRL, SHIFT = 4}; 
# 286
enum Action { KEY_UP, KEY_DOWN}; 
# 295 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
KeyboardEvent(Action action, const String & symbol, unsigned char code, int modifiers); 
# 297
Action action; 
# 298
String symbol; 
# 299
unsigned char code; 
# 300
int modifiers; 
# 301
}; 
# 305
class MouseEvent { 
# 308
public: enum Type { MouseMove = 1, MouseButtonPress, MouseButtonRelease, MouseScrollDown, MouseScrollUp, MouseDblClick}; 
# 309
enum MouseButton { NoButton, LeftButton, MiddleButton, RightButton, VScroll}; 
# 320 "/usr/include/opencv4/opencv2/viz/types.hpp" 3
MouseEvent(const Type & type, const MouseButton & button, const Point & pointer, int modifiers); 
# 322
Type type; 
# 323
MouseButton button; 
# 324
Point pointer; 
# 325
int modifiers; 
# 326
}; 
# 330
}
# 331
}
# 338
inline cv::viz::Color::Color() : Scalar(0, 0, 0) { } 
# 339
inline cv::viz::Color::Color(double _gray) : Scalar(_gray, _gray, _gray) { } 
# 340
inline cv::viz::Color::Color(double _blue, double _green, double _red) : Scalar(_blue, _green, _red) { } 
# 341
inline cv::viz::Color::Color(const Scalar &color) : Scalar(color) { } 
# 343
inline cv::viz::Color::operator cv::Vec3b() const { return ((cv::Vec< double, 3> )(val)); } 
# 345
inline cv::viz::Color cv::viz::Color::black() { return Color(0, 0, 0); } 
# 346
inline cv::viz::Color cv::viz::Color::blue() { return Color(255, 0, 0); } 
# 347
inline cv::viz::Color cv::viz::Color::green() { return Color(0, 255, 0); } 
# 348
inline cv::viz::Color cv::viz::Color::red() { return Color(0, 0, 255); } 
# 349
inline cv::viz::Color cv::viz::Color::cyan() { return Color(255, 255, 0); } 
# 350
inline cv::viz::Color cv::viz::Color::yellow() { return Color(0, 255, 255); } 
# 351
inline cv::viz::Color cv::viz::Color::magenta() { return Color(255, 0, 255); } 
# 352
inline cv::viz::Color cv::viz::Color::white() { return Color(255, 255, 255); } 
# 354
inline cv::viz::Color cv::viz::Color::gray() { return Color(128, 128, 128); } 
# 355
inline cv::viz::Color cv::viz::Color::silver() { return Color(192, 192, 192); } 
# 357
inline cv::viz::Color cv::viz::Color::mlab() { return Color(255, 128, 128); } 
# 359
inline cv::viz::Color cv::viz::Color::navy() { return Color(128, 0, 0); } 
# 360
inline cv::viz::Color cv::viz::Color::maroon() { return Color(0, 0, 128); } 
# 361
inline cv::viz::Color cv::viz::Color::teal() { return Color(128, 128, 0); } 
# 362
inline cv::viz::Color cv::viz::Color::olive() { return Color(0, 128, 128); } 
# 363
inline cv::viz::Color cv::viz::Color::purple() { return Color(128, 0, 128); } 
# 364
inline cv::viz::Color cv::viz::Color::azure() { return Color(255, 128, 0); } 
# 365
inline cv::viz::Color cv::viz::Color::chartreuse() { return Color(0, 255, 128); } 
# 366
inline cv::viz::Color cv::viz::Color::rose() { return Color(128, 0, 255); } 
# 368
inline cv::viz::Color cv::viz::Color::lime() { return Color(0, 255, 191); } 
# 369
inline cv::viz::Color cv::viz::Color::gold() { return Color(0, 215, 255); } 
# 370
inline cv::viz::Color cv::viz::Color::orange() { return Color(0, 165, 255); } 
# 371
inline cv::viz::Color cv::viz::Color::orange_red() { return Color(0, 69, 255); } 
# 372
inline cv::viz::Color cv::viz::Color::indigo() { return Color(130, 0, 75); } 
# 374
inline cv::viz::Color cv::viz::Color::brown() { return Color(42, 42, 165); } 
# 375
inline cv::viz::Color cv::viz::Color::apricot() { return Color(177, 206, 251); } 
# 376
inline cv::viz::Color cv::viz::Color::pink() { return Color(203, 192, 255); } 
# 377
inline cv::viz::Color cv::viz::Color::raspberry() { return Color(92, 11, 227); } 
# 378
inline cv::viz::Color cv::viz::Color::cherry() { return Color(99, 29, 222); } 
# 379
inline cv::viz::Color cv::viz::Color::violet() { return Color(226, 43, 138); } 
# 380
inline cv::viz::Color cv::viz::Color::amethyst() { return Color(204, 102, 153); } 
# 381
inline cv::viz::Color cv::viz::Color::bluberry() { return Color(247, 134, 79); } 
# 382
inline cv::viz::Color cv::viz::Color::celestial_blue() { return Color(208, 151, 73); } 
# 383
inline cv::viz::Color cv::viz::Color::turquoise() { return Color(208, 224, 64); } 
# 385
inline cv::viz::Color cv::viz::Color::not_set() { return Color(-1, -1, -1); } 
# 51 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
namespace cv { 
# 53
namespace viz { 
# 61
enum RenderingProperties { 
# 63
POINT_SIZE, 
# 64
OPACITY, 
# 65
LINE_WIDTH, 
# 66
FONT_SIZE, 
# 67
REPRESENTATION, 
# 68
IMMEDIATE_RENDERING, 
# 69
SHADING, 
# 70
AMBIENT, 
# 71
LIGHTING
# 72
}; 
# 74
enum RepresentationValues { 
# 76
REPRESENTATION_POINTS, 
# 77
REPRESENTATION_WIREFRAME, 
# 78
REPRESENTATION_SURFACE
# 79
}; 
# 81
enum ShadingValues { 
# 83
SHADING_FLAT, 
# 84
SHADING_GOURAUD, 
# 85
SHADING_PHONG
# 86
}; 
# 92
class Widget { 
# 95
public: Widget(); 
# 96
Widget(const Widget & other); 
# 97
Widget &operator=(const Widget & other); 
# 98
virtual ~Widget(); 
# 104
static Widget fromPlyFile(const String & file_name); 
# 131 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
void setRenderingProperty(int property, double value); 
# 157 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
double getRenderingProperty(int property) const; 
# 170 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
template< class _W> _W cast() const; 
# 172
private: class Impl; 
# 173
Impl *impl_; 
# 174
friend struct WidgetAccessor; 
# 175
}; 
# 181
class Widget3D : public Widget { 
# 184
public: Widget3D() { } 
# 190
void setPose(const Affine3d & pose); 
# 195
void updatePose(const Affine3d & pose); 
# 198
Affine3d getPose() const; 
# 204
void applyTransform(const Affine3d & transform); 
# 210
void setColor(const Color & color); 
# 212
}; 
# 218
class Widget2D : public Widget { 
# 221
public: Widget2D() { } 
# 227
void setColor(const Color & color); 
# 228
}; 
# 235
class WLine : public Widget3D { 
# 244
public: WLine(const Point3d & pt1, const Point3d & pt2, const Color & color = Color::white()); 
# 245
}; 
# 249
class WPlane : public Widget3D { 
# 257
public: WPlane(const Size2d & size = Size2d((1.0), (1.0)), const Color & color = Color::white()); 
# 267 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WPlane(const Point3d & center, const Vec3d & normal, const Vec3d & new_yaxis, const Size2d & size = Size2d((1.0), (1.0)), const Color & color = Color::white()); 
# 269
}; 
# 273
class WSphere : public Widget3D { 
# 283
public: WSphere(const Point3d & center, double radius, int sphere_resolution = 10, const Color & color = Color::white()); 
# 284
}; 
# 288
class WArrow : public Widget3D { 
# 301 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
public: WArrow(const Point3d & pt1, const Point3d & pt2, double thickness = (0.03), const Color & color = Color::white()); 
# 302
}; 
# 306
class WCircle : public Widget3D { 
# 315
public: WCircle(double radius, double thickness = (0.01), const Color & color = Color::white()); 
# 325 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WCircle(double radius, const Point3d & center, const Vec3d & normal, double thickness = (0.01), const Color & color = Color::white()); 
# 326
}; 
# 330
class WCone : public Widget3D { 
# 340
public: WCone(double length, double radius, int resolution = (6.0), const Color & color = Color::white()); 
# 351 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WCone(double radius, const Point3d & center, const Point3d & tip, int resolution = (6.0), const Color & color = Color::white()); 
# 352
}; 
# 356
class WCylinder : public Widget3D { 
# 367 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
public: WCylinder(const Point3d & axis_point1, const Point3d & axis_point2, double radius, int numsides = 30, const Color & color = Color::white()); 
# 368
}; 
# 372
class WCube : public Widget3D { 
# 384 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
public: WCube(const Point3d & min_point = Vec3d::all(-(0.5)), const Point3d & max_point = Vec3d::all((0.5)), bool wire_frame = true, const Color & color = Color::white()); 
# 386
}; 
# 390
class WPolyLine : public Widget3D { 
# 393
public: WPolyLine(InputArray points, InputArray colors); 
# 399
WPolyLine(InputArray points, const Color & color = Color::white()); 
# 400
}; 
# 407
class WText : public Widget2D { 
# 417
public: WText(const String & text, const Point & pos, int font_size = 20, const Color & color = Color::white()); 
# 423
void setText(const String & text); 
# 426
String getText() const; 
# 427
}; 
# 431
class WText3D : public Widget3D { 
# 442 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
public: WText3D(const String & text, const Point3d & position, double text_scale = (1.0), bool face_camera = true, const Color & color = Color::white()); 
# 449
void setText(const String & text); 
# 452
String getText() const; 
# 453
}; 
# 457
class WImageOverlay : public Widget2D { 
# 465
public: WImageOverlay(InputArray image, const Rect & rect); 
# 470
void setImage(InputArray image); 
# 471
}; 
# 475
class WImage3D : public Widget3D { 
# 483
public: WImage3D(InputArray image, const Size2d & size); 
# 493 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WImage3D(InputArray image, const Size2d & size, const Vec3d & center, const Vec3d & normal, const Vec3d & up_vector); 
# 499
void setImage(InputArray image); 
# 505
void setSize(const Size & size); 
# 506
}; 
# 513
class WCoordinateSystem : public Widget3D { 
# 520
public: WCoordinateSystem(double scale = (1.0)); 
# 521
}; 
# 525
class WGrid : public Widget3D { 
# 534
public: WGrid(const Vec2i & cells = Vec2i::all(10), const Vec2d & cells_spacing = Vec2d::all((1.0)), const Color & color = Color::white()); 
# 537
WGrid(const Point3d & center, const Vec3d & normal, const Vec3d & new_yaxis, const Vec2i & cells = Vec2i::all(10), const Vec2d & cells_spacing = Vec2d::all((1.0)), const Color & color = Color::white()); 
# 539
}; 
# 543
class WCameraPosition : public Widget3D { 
# 550
public: WCameraPosition(double scale = (1.0)); 
# 560 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WCameraPosition(const Matx33d & K, double scale = (1.0), const Color & color = Color::white()); 
# 570 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WCameraPosition(const Vec2d & fov, double scale = (1.0), const Color & color = Color::white()); 
# 583 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WCameraPosition(const Matx33d & K, InputArray image, double scale = (1.0), const Color & color = Color::white()); 
# 596 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WCameraPosition(const Vec2d & fov, InputArray image, double scale = (1.0), const Color & color = Color::white()); 
# 597
}; 
# 604
class WTrajectory : public Widget3D { 
# 607
public: enum { FRAMES = 1, PATH, BOTH}; 
# 622 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WTrajectory(InputArray path, int display_mode = WTrajectory::PATH, double scale = (1.0), const Color & color = Color::white()); 
# 623
}; 
# 627
class WTrajectoryFrustums : public Widget3D { 
# 639 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
public: WTrajectoryFrustums(InputArray path, const Matx33d & K, double scale = (1.0), const Color & color = Color::white()); 
# 650 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WTrajectoryFrustums(InputArray path, const Vec2d & fov, double scale = (1.0), const Color & color = Color::white()); 
# 651
}; 
# 658
class WTrajectorySpheres : public Widget3D { 
# 669 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
public: WTrajectorySpheres(InputArray path, double line_length = (0.05), double radius = (0.007), const Color & from = Color::red(), const Color & to = Color::white()); 
# 671
}; 
# 680 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
class WCloud : public Widget3D { 
# 690
public: WCloud(InputArray cloud, InputArray colors); 
# 698
WCloud(InputArray cloud, const Color & color = Color::white()); 
# 707 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WCloud(InputArray cloud, InputArray colors, InputArray normals); 
# 717 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
WCloud(InputArray cloud, const Color & color, InputArray normals); 
# 718
}; 
# 720
class WPaintedCloud : public Widget3D { 
# 724
public: WPaintedCloud(InputArray cloud); 
# 727
WPaintedCloud(InputArray cloud, const Point3d & p1, const Point3d & p2); 
# 730
WPaintedCloud(InputArray cloud, const Point3d & p1, const Point3d & p2, const Color & c1, const Color c2); 
# 731
}; 
# 736
class WCloudCollection : public Widget3D { 
# 739
public: WCloudCollection(); 
# 747
void addCloud(InputArray cloud, InputArray colors, const Affine3d & pose = Affine3d::Identity()); 
# 754
void addCloud(InputArray cloud, const Color & color = Color::white(), const Affine3d & pose = Affine3d::Identity()); 
# 759
void finalize(); 
# 760
}; 
# 764
class WCloudNormals : public Widget3D { 
# 777 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
public: WCloudNormals(InputArray cloud, InputArray normals, int level = 64, double scale = (0.1), const Color & color = Color::white()); 
# 778
}; 
# 788 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
class WMesh : public Widget3D { 
# 791
public: WMesh(const Mesh & mesh); 
# 792
WMesh(InputArray cloud, InputArray polygons, InputArray colors = noArray(), InputArray normals = noArray()); 
# 793
}; 
# 802 "/usr/include/opencv4/opencv2/viz/widgets.hpp" 3
class WWidgetMerger : public Widget3D { 
# 805
public: WWidgetMerger(); 
# 808
void addWidget(const Widget3D & widget, const Affine3d & pose = Affine3d::Identity()); 
# 811
void finalize(); 
# 812
}; 
# 817
template<> Widget2D Widget::cast< Widget2D> () const; 
# 818
template<> Widget3D Widget::cast< Widget3D> () const; 
# 819
template<> WLine Widget::cast< WLine> () const; 
# 820
template<> WPlane Widget::cast< WPlane> () const; 
# 821
template<> WSphere Widget::cast< WSphere> () const; 
# 822
template<> WCylinder Widget::cast< WCylinder> () const; 
# 823
template<> WArrow Widget::cast< WArrow> () const; 
# 824
template<> WCircle Widget::cast< WCircle> () const; 
# 825
template<> WCone Widget::cast< WCone> () const; 
# 826
template<> WCube Widget::cast< WCube> () const; 
# 827
template<> WCoordinateSystem Widget::cast< WCoordinateSystem> () const; 
# 828
template<> WPolyLine Widget::cast< WPolyLine> () const; 
# 829
template<> WGrid Widget::cast< WGrid> () const; 
# 830
template<> WText3D Widget::cast< WText3D> () const; 
# 831
template<> WText Widget::cast< WText> () const; 
# 832
template<> WImageOverlay Widget::cast< WImageOverlay> () const; 
# 833
template<> WImage3D Widget::cast< WImage3D> () const; 
# 834
template<> WCameraPosition Widget::cast< WCameraPosition> () const; 
# 835
template<> WTrajectory Widget::cast< WTrajectory> () const; 
# 836
template<> WTrajectoryFrustums Widget::cast< WTrajectoryFrustums> () const; 
# 837
template<> WTrajectorySpheres Widget::cast< WTrajectorySpheres> () const; 
# 838
template<> WCloud Widget::cast< WCloud> () const; 
# 839
template<> WPaintedCloud Widget::cast< WPaintedCloud> () const; 
# 840
template<> WCloudCollection Widget::cast< WCloudCollection> () const; 
# 841
template<> WCloudNormals Widget::cast< WCloudNormals> () const; 
# 842
template<> WMesh Widget::cast< WMesh> () const; 
# 843
template<> WWidgetMerger Widget::cast< WWidgetMerger> () const; 
# 847
}
# 848
}
# 57 "/usr/include/opencv4/opencv2/viz/viz3d.hpp" 3
namespace cv { 
# 59
namespace viz { 
# 67
class Viz3d { 
# 70
public: typedef viz::Color Color; 
# 71
typedef void (*KeyboardCallback)(const KeyboardEvent &, void *); 
# 72
typedef void (*MouseCallback)(const MouseEvent &, void *); 
# 78
Viz3d(const String & window_name = String()); 
# 79
Viz3d(const Viz3d &); 
# 80
Viz3d &operator=(const Viz3d &); 
# 81
~Viz3d(); 
# 88
void showWidget(const String & id, const Widget & widget, const Affine3d & pose = Affine3d::Identity()); 
# 94
void removeWidget(const String & id); 
# 103 "/usr/include/opencv4/opencv2/viz/viz3d.hpp" 3
Widget getWidget(const String & id) const; 
# 107
void removeAllWidgets(); 
# 114
void showImage(InputArray image, const Size & window_size = Size(-1, -1)); 
# 120
void setWidgetPose(const String & id, const Affine3d & pose); 
# 127
void updateWidgetPose(const String & id, const Affine3d & pose); 
# 133
Affine3d getWidgetPose(const String & id) const; 
# 139
void setCamera(const Camera & camera); 
# 143
Camera getCamera() const; 
# 147
Affine3d getViewerPose() const; 
# 153
void setViewerPose(const Affine3d & pose); 
# 159
void resetCameraViewpoint(const String & id); 
# 163
void resetCamera(); 
# 170
void convertToWindowCoordinates(const Point3d & pt, Point3d & window_coord); 
# 177
void converTo3DRay(const Point3d & window_coord, Point3d & origin, Vec3d & direction); 
# 181
Size getWindowSize() const; 
# 186
void setWindowSize(const Size & window_size); 
# 191
String getWindowName() const; 
# 195
Mat getScreenshot() const; 
# 201
void saveScreenshot(const String & file); 
# 207
void setWindowPosition(const Point & window_position); 
# 213
void setFullScreen(bool mode = true); 
# 217
void setBackgroundColor(const Color & color = Color::black(), const Color & color2 = Color::not_set()); 
# 218
void setBackgroundTexture(InputArray image = noArray()); 
# 219
void setBackgroundMeshLab(); 
# 223
void spin(); 
# 230
void spinOnce(int time = 1, bool force_redraw = false); 
# 234
void setOffScreenRendering(); 
# 238
void removeAllLights(); 
# 249 "/usr/include/opencv4/opencv2/viz/viz3d.hpp" 3
void addLight(const Vec3d & position, const Vec3d & focalPoint = Vec3d(0, 0, 0), const Color & color = Color::white(), const Color & diffuseColor = Color::white(), const Color & ambientColor = Color::black(), const Color & specularColor = Color::white()); 
# 255
bool wasStopped() const; 
# 256
void close(); 
# 264
void registerKeyboardCallback(KeyboardCallback callback, void * cookie = 0); 
# 271
void registerMouseCallback(MouseCallback callback, void * cookie = 0); 
# 299 "/usr/include/opencv4/opencv2/viz/viz3d.hpp" 3
void setRenderingProperty(const String & id, int property, double value); 
# 325 "/usr/include/opencv4/opencv2/viz/viz3d.hpp" 3
double getRenderingProperty(const String & id, int property); 
# 334 "/usr/include/opencv4/opencv2/viz/viz3d.hpp" 3
void setRepresentation(int representation); 
# 336
void setGlobalWarnings(bool enabled = false); 
# 339
private: struct VizImpl; 
# 340
VizImpl *impl_; 
# 342
void create(const String & window_name); 
# 343
void release(); 
# 345
friend class VizStorage; 
# 346
}; 
# 350
}
# 351
}
# 53 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
namespace cv { 
# 55
namespace viz { 
# 73 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
Affine3d makeTransformToGlobal(const Vec3d & axis_x, const Vec3d & axis_y, const Vec3d & axis_z, const Vec3d & origin = Vec3d::all(0)); 
# 84 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
Affine3d makeCameraPose(const Vec3d & position, const Vec3d & focal_point, const Vec3d & y_dir); 
# 102 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
Viz3d getWindowByName(const String & window_name); 
# 105
void unregisterAllWindows(); 
# 108
Viz3d imshow(const String & window_name, InputArray image, const Size & window_size = Size(-1, -1)); 
# 114
inline bool isNan(float x) 
# 115
{ 
# 116
unsigned *u = reinterpret_cast< unsigned *>(&x); 
# 117
return (((u[0]) & (2139095040)) == (2139095040)) && ((u[0]) & (8388607)); 
# 118
} 
# 124
inline bool isNan(double x) 
# 125
{ 
# 126
unsigned *u = reinterpret_cast< unsigned *>(&x); 
# 127
return (((u[1]) & (2146435072)) == (2146435072)) && (((u[0]) != (0)) || (((u[1]) & (1048575)) != (0))); 
# 128
} 
# 134
template< class _Tp, int cn> inline bool isNan(const Vec< _Tp, cn>  &v) 
# 135
{ return (isNan((v.val)[0]) || isNan((v.val)[1])) || isNan((v.val)[2]); } 
# 141
template< class _Tp> inline bool isNan(const Point3_< _Tp>  &p) 
# 142
{ return (isNan((p.x)) || isNan((p.y))) || isNan((p.z)); } 
# 156 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
void writeCloud(const String & file, InputArray cloud, InputArray colors = noArray(), InputArray normals = noArray(), bool binary = false); 
# 165 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
Mat readCloud(const String & file, OutputArray colors = noArray(), OutputArray normals = noArray()); 
# 170
Mesh readMesh(const String & file); 
# 180 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
bool readPose(const String & file, Affine3d & pose, const String & tag = "pose"); 
# 186
void writePose(const String & file, const Affine3d & pose, const String & tag = "pose"); 
# 198 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
void writeTrajectory(InputArray traj, const String & files_format = "pose%05d.xml", int start = 0, const String & tag = "pose"); 
# 211 "/usr/include/opencv4/opencv2/viz/vizcore.hpp" 3
void readTrajectory(OutputArray traj, const String & files_format = "pose%05d.xml", int start = 0, int end = 2147483647, const String & tag = "pose"); 
# 219
void computeNormals(const Mesh & mesh, OutputArray normals); 
# 223
}
# 224
}
# 56 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuComplex.h"
#pragma GCC diagnostic ignored "-Wunused-function"
# 72 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuComplex.h"
extern "C" {
# 77
typedef float2 cuFloatComplex; 
# 79
static inline float cuCrealf(cuFloatComplex x) 
# 80
{ 
# 81
return x.x; 
# 82
} 
# 84
static inline float cuCimagf(cuFloatComplex x) 
# 85
{ 
# 86
return x.y; 
# 87
} 
# 89
static inline cuFloatComplex make_cuFloatComplex(float 
# 90
r, float i) 
# 91
{ 
# 92
cuFloatComplex res; 
# 93
(res.x) = r; 
# 94
(res.y) = i; 
# 95
return res; 
# 96
} 
# 98
static inline cuFloatComplex cuConjf(cuFloatComplex x) 
# 99
{ 
# 100
return make_cuFloatComplex(cuCrealf(x), -cuCimagf(x)); 
# 101
} 
# 102
static inline cuFloatComplex cuCaddf(cuFloatComplex x, cuFloatComplex 
# 103
y) 
# 104
{ 
# 105
return make_cuFloatComplex(cuCrealf(x) + cuCrealf(y), cuCimagf(x) + cuCimagf(y)); 
# 107
} 
# 109
static inline cuFloatComplex cuCsubf(cuFloatComplex x, cuFloatComplex 
# 110
y) 
# 111
{ 
# 112
return make_cuFloatComplex(cuCrealf(x) - cuCrealf(y), cuCimagf(x) - cuCimagf(y)); 
# 114
} 
# 121
static inline cuFloatComplex cuCmulf(cuFloatComplex x, cuFloatComplex 
# 122
y) 
# 123
{ 
# 124
cuFloatComplex prod; 
# 125
prod = make_cuFloatComplex((cuCrealf(x) * cuCrealf(y)) - (cuCimagf(x) * cuCimagf(y)), (cuCrealf(x) * cuCimagf(y)) + (cuCimagf(x) * cuCrealf(y))); 
# 129
return prod; 
# 130
} 
# 137
static inline cuFloatComplex cuCdivf(cuFloatComplex x, cuFloatComplex 
# 138
y) 
# 139
{ 
# 140
cuFloatComplex quot; 
# 141
float s = fabsf(cuCrealf(y)) + fabsf(cuCimagf(y)); 
# 142
float oos = (1.0F) / s; 
# 143
float ars = cuCrealf(x) * oos; 
# 144
float ais = cuCimagf(x) * oos; 
# 145
float brs = cuCrealf(y) * oos; 
# 146
float bis = cuCimagf(y) * oos; 
# 147
s = ((brs * brs) + (bis * bis)); 
# 148
oos = ((1.0F) / s); 
# 149
quot = make_cuFloatComplex(((ars * brs) + (ais * bis)) * oos, ((ais * brs) - (ars * bis)) * oos); 
# 151
return quot; 
# 152
} 
# 162 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuComplex.h"
static inline float cuCabsf(cuFloatComplex x) 
# 163
{ 
# 164
float a = cuCrealf(x); 
# 165
float b = cuCimagf(x); 
# 166
float v, w, t; 
# 167
a = fabsf(a); 
# 168
b = fabsf(b); 
# 169
if (a > b) { 
# 170
v = a; 
# 171
w = b; 
# 172
} else { 
# 173
v = b; 
# 174
w = a; 
# 175
}  
# 176
t = (w / v); 
# 177
t = ((1.0F) + (t * t)); 
# 178
t = (v * sqrtf(t)); 
# 179
if (((v == (0.0F)) || (v > (3.4028235E38F))) || (w > (3.4028235E38F))) { 
# 180
t = (v + w); 
# 181
}  
# 182
return t; 
# 183
} 
# 186
typedef double2 cuDoubleComplex; 
# 188
static inline double cuCreal(cuDoubleComplex x) 
# 189
{ 
# 190
return x.x; 
# 191
} 
# 193
static inline double cuCimag(cuDoubleComplex x) 
# 194
{ 
# 195
return x.y; 
# 196
} 
# 198
static inline cuDoubleComplex make_cuDoubleComplex(double 
# 199
r, double i) 
# 200
{ 
# 201
cuDoubleComplex res; 
# 202
(res.x) = r; 
# 203
(res.y) = i; 
# 204
return res; 
# 205
} 
# 207
static inline cuDoubleComplex cuConj(cuDoubleComplex x) 
# 208
{ 
# 209
return make_cuDoubleComplex(cuCreal(x), -cuCimag(x)); 
# 210
} 
# 212
static inline cuDoubleComplex cuCadd(cuDoubleComplex x, cuDoubleComplex 
# 213
y) 
# 214
{ 
# 215
return make_cuDoubleComplex(cuCreal(x) + cuCreal(y), cuCimag(x) + cuCimag(y)); 
# 217
} 
# 219
static inline cuDoubleComplex cuCsub(cuDoubleComplex x, cuDoubleComplex 
# 220
y) 
# 221
{ 
# 222
return make_cuDoubleComplex(cuCreal(x) - cuCreal(y), cuCimag(x) - cuCimag(y)); 
# 224
} 
# 231
static inline cuDoubleComplex cuCmul(cuDoubleComplex x, cuDoubleComplex 
# 232
y) 
# 233
{ 
# 234
cuDoubleComplex prod; 
# 235
prod = make_cuDoubleComplex((cuCreal(x) * cuCreal(y)) - (cuCimag(x) * cuCimag(y)), (cuCreal(x) * cuCimag(y)) + (cuCimag(x) * cuCreal(y))); 
# 239
return prod; 
# 240
} 
# 247
static inline cuDoubleComplex cuCdiv(cuDoubleComplex x, cuDoubleComplex 
# 248
y) 
# 249
{ 
# 250
cuDoubleComplex quot; 
# 251
double s = fabs(cuCreal(y)) + fabs(cuCimag(y)); 
# 252
double oos = (1.0) / s; 
# 253
double ars = cuCreal(x) * oos; 
# 254
double ais = cuCimag(x) * oos; 
# 255
double brs = cuCreal(y) * oos; 
# 256
double bis = cuCimag(y) * oos; 
# 257
s = ((brs * brs) + (bis * bis)); 
# 258
oos = ((1.0) / s); 
# 259
quot = make_cuDoubleComplex(((ars * brs) + (ais * bis)) * oos, ((ais * brs) - (ars * bis)) * oos); 
# 261
return quot; 
# 262
} 
# 270
static inline double cuCabs(cuDoubleComplex x) 
# 271
{ 
# 272
double a = cuCreal(x); 
# 273
double b = cuCimag(x); 
# 274
double v, w, t; 
# 275
a = fabs(a); 
# 276
b = fabs(b); 
# 277
if (a > b) { 
# 278
v = a; 
# 279
w = b; 
# 280
} else { 
# 281
v = b; 
# 282
w = a; 
# 283
}  
# 284
t = (w / v); 
# 285
t = ((1.0) + (t * t)); 
# 286
t = (v * sqrt(t)); 
# 287
if (((v == (0.0)) || (v > (1.7976931348623157E308))) || (w > (1.7976931348623157E308))) 
# 288
{ 
# 289
t = (v + w); 
# 290
}  
# 291
return t; 
# 292
} 
# 295
}
# 299
typedef cuFloatComplex cuComplex; 
# 300
static inline cuComplex make_cuComplex(float x, float 
# 301
y) 
# 302
{ 
# 303
return make_cuFloatComplex(x, y); 
# 304
} 
# 307
static inline cuDoubleComplex cuComplexFloatToDouble(cuFloatComplex 
# 308
c) 
# 309
{ 
# 310
return make_cuDoubleComplex((double)cuCrealf(c), (double)cuCimagf(c)); 
# 311
} 
# 313
static inline cuFloatComplex cuComplexDoubleToFloat(cuDoubleComplex 
# 314
c) 
# 315
{ 
# 316
return make_cuFloatComplex((float)cuCreal(c), (float)cuCimag(c)); 
# 317
} 
# 320
static inline cuComplex cuCfmaf(cuComplex x, cuComplex y, cuComplex d) 
# 321
{ 
# 322
float real_res; 
# 323
float imag_res; 
# 325
real_res = ((cuCrealf(x) * cuCrealf(y)) + cuCrealf(d)); 
# 326
imag_res = ((cuCrealf(x) * cuCimagf(y)) + cuCimagf(d)); 
# 328
real_res = ((-(cuCimagf(x) * cuCimagf(y))) + real_res); 
# 329
imag_res = ((cuCimagf(x) * cuCrealf(y)) + imag_res); 
# 331
return make_cuComplex(real_res, imag_res); 
# 332
} 
# 334
static inline cuDoubleComplex cuCfma(cuDoubleComplex x, cuDoubleComplex y, cuDoubleComplex d) 
# 335
{ 
# 336
double real_res; 
# 337
double imag_res; 
# 339
real_res = ((cuCreal(x) * cuCreal(y)) + cuCreal(d)); 
# 340
imag_res = ((cuCreal(x) * cuCimag(y)) + cuCimag(d)); 
# 342
real_res = ((-(cuCimag(x) * cuCimag(y))) + real_res); 
# 343
imag_res = ((cuCimag(x) * cuCreal(y)) + imag_res); 
# 345
return make_cuDoubleComplex(real_res, imag_res); 
# 346
} 
# 134 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
struct __half; 
# 147 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
struct __half2; 
# 163 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __double2half(const double a); 
# 178 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __float2half(const float a); 
# 193 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __float2half_rn(const float a); 
# 208 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __float2half_rz(const float a); 
# 224 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __float2half_rd(const float a); 
# 240 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __float2half_ru(const float a); 
# 255 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline float __half2float(const __half a); 
# 273 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half2 __float2half2_rn(const float a); 
# 294 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half2 __floats2half2_rn(const float a, const float b); 
# 310 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline float __low2float(const __half2 a); 
# 326 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline float __high2float(const __half2 a); 
# 348 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half2 __float22half2_rn(const float2 a); 
# 364 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline float2 __half22float2(const __half2 a); 
# 380 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline int __half2int_rn(const __half h); 
# 396 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline int __half2int_rz(const __half h); 
# 412 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline int __half2int_rd(const __half h); 
# 428 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline int __half2int_ru(const __half h); 
# 445 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __int2half_rn(const int i); 
# 461 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __int2half_rz(const int i); 
# 477 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __int2half_rd(const int i); 
# 493 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __int2half_ru(const int i); 
# 511 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half2short_rn(const __half h); 
# 527 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline short __half2short_rz(const __half h); 
# 543 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half2short_rd(const __half h); 
# 559 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half2short_ru(const __half h); 
# 577 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __short2half_rn(const short i); 
# 593 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short2half_rz(const short i); 
# 609 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short2half_rd(const short i); 
# 625 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short2half_ru(const short i); 
# 642 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned __half2uint_rn(const __half h); 
# 658 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline unsigned __half2uint_rz(const __half h); 
# 674 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned __half2uint_rd(const __half h); 
# 690 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned __half2uint_ru(const __half h); 
# 707 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __uint2half_rn(const unsigned i); 
# 723 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __uint2half_rz(const unsigned i); 
# 739 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __uint2half_rd(const unsigned i); 
# 755 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __uint2half_ru(const unsigned i); 
# 773 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half2ushort_rn(const __half h); 
# 790 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline unsigned short __half2ushort_rz(const __half h); 
# 802 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half2ushort_rd(const __half h); 
# 814 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half2ushort_ru(const __half h); 
# 832 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __ushort2half_rn(const unsigned short i); 
# 849 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort2half_rz(const unsigned short i); 
# 865 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort2half_rd(const unsigned short i); 
# 881 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort2half_ru(const unsigned short i); 
# 899 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned long long __half2ull_rn(const __half h); 
# 916 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline unsigned long long __half2ull_rz(const __half h); 
# 932 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned long long __half2ull_rd(const __half h); 
# 948 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned long long __half2ull_ru(const __half h); 
# 966 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __ull2half_rn(const unsigned long long i); 
# 983 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ull2half_rz(const unsigned long long i); 
# 999 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ull2half_rd(const unsigned long long i); 
# 1015 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ull2half_ru(const unsigned long long i); 
# 1033 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline long long __half2ll_rn(const __half h); 
# 1049 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline long long __half2ll_rz(const __half h); 
# 1065 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline long long __half2ll_rd(const __half h); 
# 1081 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline long long __half2ll_ru(const __half h); 
# 1099 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
static inline __half __ll2half_rn(const long long i); 
# 1111 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ll2half_rz(const long long i); 
# 1127 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ll2half_rd(const long long i); 
# 1143 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ll2half_ru(const long long i); 
# 1160 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half htrunc(const __half h); 
# 1175 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hceil(const __half h); 
# 1190 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hfloor(const __half h); 
# 1207 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hrint(const __half h); 
# 1224 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2trunc(const __half2 h); 
# 1240 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2ceil(const __half2 h); 
# 1256 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2floor(const __half2 h); 
# 1274 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2rint(const __half2 h); 
# 1291 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __half2half2(const __half a); 
# 1307 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __lowhigh2highlow(const __half2 a); 
# 1327 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __lows2half2(const __half2 a, const __half2 b); 
# 1347 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __highs2half2(const __half2 a, const __half2 b); 
# 1362 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __high2half(const __half2 a); 
# 1377 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __low2half(const __half2 a); 
# 1394 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline int __hisinf(const __half a); 
# 1412 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __halves2half2(const __half a, const __half b); 
# 1428 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __low2half2(const __half2 a); 
# 1444 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __high2half2(const __half2 a); 
# 1461 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline short __half_as_short(const __half h); 
# 1477 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline unsigned short __half_as_ushort(const __half h); 
# 1493 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __short_as_half(const short i); 
# 1509 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __ushort_as_half(const unsigned short i); 
# 1528 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline __half2 __shfl(const __half2 var, const int delta, const int width = 32); 
# 1529
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline __half2 __shfl_up(const __half2 var, const unsigned delta, const int width = 32); 
# 1530
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline __half2 __shfl_down(const __half2 var, const unsigned delta, const int width = 32); 
# 1531
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline __half2 __shfl_xor(const __half2 var, const int delta, const int width = 32); 
# 1532
__attribute((deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning)."))) __attribute__((unused)) static inline __half __shfl(const __half var, const int delta, const int width = 32); 
# 1533
__attribute((deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning)."))) __attribute__((unused)) static inline __half __shfl_up(const __half var, const unsigned delta, const int width = 32); 
# 1534
__attribute((deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning)."))) __attribute__((unused)) static inline __half __shfl_down(const __half var, const unsigned delta, const int width = 32); 
# 1535
__attribute((deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning)."))) __attribute__((unused)) static inline __half __shfl_xor(const __half var, const int delta, const int width = 32); 
# 1561 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __shfl_sync(const unsigned mask, const __half2 var, const int delta, const int width = 32); 
# 1586 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __shfl_up_sync(const unsigned mask, const __half2 var, const unsigned delta, const int width = 32); 
# 1611 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __shfl_down_sync(const unsigned mask, const __half2 var, const unsigned delta, const int width = 32); 
# 1635 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __shfl_xor_sync(const unsigned mask, const __half2 var, const int delta, const int width = 32); 
# 1660 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __shfl_sync(const unsigned mask, const __half var, const int delta, const int width = 32); 
# 1684 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __shfl_up_sync(const unsigned mask, const __half var, const unsigned delta, const int width = 32); 
# 1709 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __shfl_down_sync(const unsigned mask, const __half var, const unsigned delta, const int width = 32); 
# 1733 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __shfl_xor_sync(const unsigned mask, const __half var, const int delta, const int width = 32); 
# 1748 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __ldg(const __half2 *const ptr); 
# 1755
__attribute__((unused)) static inline __half __ldg(const __half *const ptr); 
# 1762
__attribute__((unused)) static inline __half2 __ldcg(const __half2 *const ptr); 
# 1769
__attribute__((unused)) static inline __half __ldcg(const __half *const ptr); 
# 1776
__attribute__((unused)) static inline __half2 __ldca(const __half2 *const ptr); 
# 1783
__attribute__((unused)) static inline __half __ldca(const __half *const ptr); 
# 1790
__attribute__((unused)) static inline __half2 __ldcs(const __half2 *const ptr); 
# 1797
__attribute__((unused)) static inline __half __ldcs(const __half *const ptr); 
# 1804
__attribute__((unused)) static inline __half2 __ldlu(const __half2 *const ptr); 
# 1811
__attribute__((unused)) static inline __half __ldlu(const __half *const ptr); 
# 1818
__attribute__((unused)) static inline __half2 __ldcv(const __half2 *const ptr); 
# 1825
__attribute__((unused)) static inline __half __ldcv(const __half *const ptr); 
# 1832
__attribute__((unused)) static inline void __stwb(__half2 *const ptr, const __half2 value); 
# 1839
__attribute__((unused)) static inline void __stwb(__half *const ptr, const __half value); 
# 1846
__attribute__((unused)) static inline void __stcg(__half2 *const ptr, const __half2 value); 
# 1853
__attribute__((unused)) static inline void __stcg(__half *const ptr, const __half value); 
# 1860
__attribute__((unused)) static inline void __stcs(__half2 *const ptr, const __half2 value); 
# 1867
__attribute__((unused)) static inline void __stcs(__half *const ptr, const __half value); 
# 1874
__attribute__((unused)) static inline void __stwt(__half2 *const ptr, const __half2 value); 
# 1881
__attribute__((unused)) static inline void __stwt(__half *const ptr, const __half value); 
# 1902 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __heq2(const __half2 a, const __half2 b); 
# 1920 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hne2(const __half2 a, const __half2 b); 
# 1938 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hle2(const __half2 a, const __half2 b); 
# 1956 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hge2(const __half2 a, const __half2 b); 
# 1974 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hlt2(const __half2 a, const __half2 b); 
# 1992 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hgt2(const __half2 a, const __half2 b); 
# 2010 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hequ2(const __half2 a, const __half2 b); 
# 2028 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hneu2(const __half2 a, const __half2 b); 
# 2046 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hleu2(const __half2 a, const __half2 b); 
# 2064 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hgeu2(const __half2 a, const __half2 b); 
# 2082 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hltu2(const __half2 a, const __half2 b); 
# 2100 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hgtu2(const __half2 a, const __half2 b); 
# 2116 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hisnan2(const __half2 a); 
# 2136 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hadd2(const __half2 a, const __half2 b); 
# 2156 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hsub2(const __half2 a, const __half2 b); 
# 2176 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmul2(const __half2 a, const __half2 b); 
# 2196 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hadd2_rn(const __half2 a, const __half2 b); 
# 2217 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hsub2_rn(const __half2 a, const __half2 b); 
# 2238 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmul2_rn(const __half2 a, const __half2 b); 
# 2258 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __h2div(const __half2 a, const __half2 b); 
# 2275 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __habs2(const __half2 a); 
# 2294 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hadd2_sat(const __half2 a, const __half2 b); 
# 2313 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hsub2_sat(const __half2 a, const __half2 b); 
# 2333 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmul2_sat(const __half2 a, const __half2 b); 
# 2356 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hfma2(const __half2 a, const __half2 b, const __half2 c); 
# 2378 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hfma2_sat(const __half2 a, const __half2 b, const __half2 c); 
# 2397 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hneg2(const __half2 a); 
# 2412 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __habs(const __half a); 
# 2432 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hadd(const __half a, const __half b); 
# 2452 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hsub(const __half a, const __half b); 
# 2468 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmul(const __half a, const __half b); 
# 2488 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hadd_rn(const __half a, const __half b); 
# 2508 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hsub_rn(const __half a, const __half b); 
# 2524 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmul_rn(const __half a, const __half b); 
# 2544 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hdiv(const __half a, const __half b); 
# 2562 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hadd_sat(const __half a, const __half b); 
# 2581 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hsub_sat(const __half a, const __half b); 
# 2600 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmul_sat(const __half a, const __half b); 
# 2623 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hfma(const __half a, const __half b, const __half c); 
# 2645 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hfma_sat(const __half a, const __half b, const __half c); 
# 2663 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hneg(const __half a); 
# 2685 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbeq2(const __half2 a, const __half2 b); 
# 2707 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbne2(const __half2 a, const __half2 b); 
# 2729 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hble2(const __half2 a, const __half2 b); 
# 2751 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbge2(const __half2 a, const __half2 b); 
# 2773 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hblt2(const __half2 a, const __half2 b); 
# 2795 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbgt2(const __half2 a, const __half2 b); 
# 2817 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbequ2(const __half2 a, const __half2 b); 
# 2839 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbneu2(const __half2 a, const __half2 b); 
# 2861 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbleu2(const __half2 a, const __half2 b); 
# 2884 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbgeu2(const __half2 a, const __half2 b); 
# 2906 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbltu2(const __half2 a, const __half2 b); 
# 2929 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hbgtu2(const __half2 a, const __half2 b); 
# 2946 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __heq(const __half a, const __half b); 
# 2963 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hne(const __half a, const __half b); 
# 2980 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hle(const __half a, const __half b); 
# 2997 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hge(const __half a, const __half b); 
# 3014 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hlt(const __half a, const __half b); 
# 3031 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hgt(const __half a, const __half b); 
# 3049 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hequ(const __half a, const __half b); 
# 3067 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hneu(const __half a, const __half b); 
# 3085 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hleu(const __half a, const __half b); 
# 3103 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hgeu(const __half a, const __half b); 
# 3121 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hltu(const __half a, const __half b); 
# 3139 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hgtu(const __half a, const __half b); 
# 3154 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline bool __hisnan(const __half a); 
# 3174 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmax(const __half a, const __half b); 
# 3193 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmin(const __half a, const __half b); 
# 3211 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmax_nan(const __half a, const __half b); 
# 3229 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hmin_nan(const __half a, const __half b); 
# 3251 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half __hfma_relu(const __half a, const __half b, const __half c); 
# 3272 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmax2(const __half2 a, const __half2 b); 
# 3293 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmin2(const __half2 a, const __half2 b); 
# 3313 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmax2_nan(const __half2 a, const __half2 b); 
# 3333 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hmin2_nan(const __half2 a, const __half2 b); 
# 3355 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hfma2_relu(const __half2 a, const __half2 b, const __half2 c); 
# 3375 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 __hcmadd(const __half2 a, const __half2 b, const __half2 c); 
# 3390 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hsqrt(const __half a); 
# 3407 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hrsqrt(const __half a); 
# 3422 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hrcp(const __half a); 
# 3438 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hlog(const __half a); 
# 3454 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hlog2(const __half a); 
# 3470 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hlog10(const __half a); 
# 3487 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hexp(const __half a); 
# 3504 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hexp2(const __half a); 
# 3521 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hexp10(const __half a); 
# 3536 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hcos(const __half a); 
# 3551 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half hsin(const __half a); 
# 3567 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2sqrt(const __half2 a); 
# 3584 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2rsqrt(const __half2 a); 
# 3600 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2rcp(const __half2 a); 
# 3617 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2log(const __half2 a); 
# 3634 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2log2(const __half2 a); 
# 3651 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2log10(const __half2 a); 
# 3668 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2exp(const __half2 a); 
# 3685 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2exp2(const __half2 a); 
# 3702 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2exp10(const __half2 a); 
# 3718 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2cos(const __half2 a); 
# 3733 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 h2sin(const __half2 a); 
# 3757 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half2 atomicAdd(__half2 *const address, const __half2 val); 
# 3779 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.h"
__attribute__((unused)) static inline __half atomicAdd(__half *const address, const __half val); 
# 153 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
typedef 
# 151
struct __attribute((aligned(2))) { 
# 152
unsigned short x; 
# 153
} __half_raw; 
# 158
typedef 
# 155
struct __attribute((aligned(4))) { 
# 156
unsigned short x; 
# 157
unsigned short y; 
# 158
} __half2_raw; 
# 166
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#pragma GCC diagnostic ignored "-Weffc++"
# 179 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
struct __attribute((aligned(2))) __half { 
# 181
protected: unsigned short __x; 
# 185
public: __half() = default;
# 191
__half(const __half_raw &hr) : __x(hr.x) { } 
# 192
__half &operator=(const __half_raw &hr) { (__x) = (hr.x); return *this; } 
# 193
volatile __half &operator=(const __half_raw &hr) volatile { (__x) = (hr.x); return *this; } 
# 194
volatile __half &operator=(const volatile __half_raw &hr) volatile { (__x) = (hr.x); return *this; } 
# 195
operator __half_raw() const { __half_raw ret; (ret.x) = (__x); return ret; } 
# 196
operator __half_raw() const volatile { __half_raw ret; (ret.x) = (__x); return ret; } 
# 201
__half(const float f) { (__x) = (__float2half(f).__x); } 
# 202
__half(const double f) { (__x) = (__double2half(f).__x); } 
# 204
operator float() const { return __half2float(*this); } 
# 205
__half &operator=(const float f) { (__x) = (__float2half(f).__x); return *this; } 
# 208
__half &operator=(const double f) { (__x) = (__double2half(f).__x); return *this; } 
# 214
__half(const short val) { (__x) = (__short2half_rn(val).__x); } 
# 215
__half(const unsigned short val) { (__x) = (__ushort2half_rn(val).__x); } 
# 216
__half(const int val) { (__x) = (__int2half_rn(val).__x); } 
# 217
__half(const unsigned val) { (__x) = (__uint2half_rn(val).__x); } 
# 218
__half(const long long val) { (__x) = (__ll2half_rn(val).__x); } 
# 219
__half(const unsigned long long val) { (__x) = (__ull2half_rn(val).__x); } 
# 222
operator short() const { return __half2short_rz(*this); } 
# 223
__half &operator=(const short val) { (__x) = (__short2half_rn(val).__x); return *this; } 
# 225
operator unsigned short() const { return __half2ushort_rz(*this); } 
# 226
__half &operator=(const unsigned short val) { (__x) = (__ushort2half_rn(val).__x); return *this; } 
# 228
operator int() const { return __half2int_rz(*this); } 
# 229
__half &operator=(const int val) { (__x) = (__int2half_rn(val).__x); return *this; } 
# 231
operator unsigned() const { return __half2uint_rz(*this); } 
# 232
__half &operator=(const unsigned val) { (__x) = (__uint2half_rn(val).__x); return *this; } 
# 234
operator long long() const { return __half2ll_rz(*this); } 
# 235
__half &operator=(const long long val) { (__x) = (__ll2half_rn(val).__x); return *this; } 
# 237
operator unsigned long long() const { return __half2ull_rz(*this); } 
# 238
__half &operator=(const unsigned long long val) { (__x) = (__ull2half_rn(val).__x); return *this; } 
# 241
operator bool() const { return ((__x) & 32767U) != 0U; } 
# 244
}; 
# 253 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half operator+(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 253
{ return __hadd(lh, rh); } 
#endif
# 254 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half operator-(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 254
{ return __hsub(lh, rh); } 
#endif
# 255 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half operator*(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 255
{ return __hmul(lh, rh); } 
#endif
# 256 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half operator/(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 256
{ return __hdiv(lh, rh); } 
#endif
# 258 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half &operator+=(__half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 258
{ lh = __hadd(lh, rh); return lh; } 
#endif
# 259 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half &operator-=(__half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 259
{ lh = __hsub(lh, rh); return lh; } 
#endif
# 260 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half &operator*=(__half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 260
{ lh = __hmul(lh, rh); return lh; } 
#endif
# 261 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half &operator/=(__half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 261
{ lh = __hdiv(lh, rh); return lh; } 
#endif
# 264 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half &operator++(__half &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 264
{ __half_raw one; (one.x) = (15360U); (h += one); return h; } 
#endif
# 265 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half &operator--(__half &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 265
{ __half_raw one; (one.x) = (15360U); (h -= one); return h; } 
#endif
# 266 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half operator++(__half &h, const int ignored) 
# 267
{int volatile ___ = 1;(void)h;(void)ignored;
# 276
::exit(___);}
#if 0
# 267
{ 
# 269
static_cast< void>(ignored); 
# 271
const __half ret = h; 
# 272
__half_raw one; 
# 273
(one.x) = (15360U); 
# 274
(h += one); 
# 275
return ret; 
# 276
} 
#endif
# 277 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half operator--(__half &h, const int ignored) 
# 278
{int volatile ___ = 1;(void)h;(void)ignored;
# 287
::exit(___);}
#if 0
# 278
{ 
# 280
static_cast< void>(ignored); 
# 282
const __half ret = h; 
# 283
__half_raw one; 
# 284
(one.x) = (15360U); 
# 285
(h -= one); 
# 286
return ret; 
# 287
} 
#endif
# 290 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half operator+(const __half &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 290
{ return h; } 
#endif
# 291 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half operator-(const __half &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 291
{ return __hneg(h); } 
#endif
# 294 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator==(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 294
{ return __heq(lh, rh); } 
#endif
# 295 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator!=(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 295
{ return __hneu(lh, rh); } 
#endif
# 296 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator>(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 296
{ return __hgt(lh, rh); } 
#endif
# 297 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator<(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 297
{ return __hlt(lh, rh); } 
#endif
# 298 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator>=(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 298
{ return __hge(lh, rh); } 
#endif
# 299 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator<=(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 299
{ return __hle(lh, rh); } 
#endif
# 305 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
struct __attribute((aligned(4))) __half2 { 
# 306
__half x; 
# 307
__half y; 
# 312
__half2() = default;
# 313
__half2(const __half2 &&src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = std::move(*(reinterpret_cast< const unsigned *>(&src))); } 
# 314
__half2 &operator=(const __half2 &&src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = std::move(*(reinterpret_cast< const unsigned *>(&src))); return *this; } 
# 318
__half2(const __half &a, const __half &b) : x(a), y(b) { } 
# 319
__half2(const __half2 &src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&src))); } 
# 320
__half2 &operator=(const __half2 &src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&src))); return *this; } 
# 323
__half2(const __half2_raw &h2r) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&h2r))); } 
# 324
__half2 &operator=(const __half2_raw &h2r) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&h2r))); return *this; } 
# 325
operator __half2_raw() const { __half2_raw ret; (ret.x) = (0U); (ret.y) = (0U); (*(reinterpret_cast< unsigned *>(&ret))) = (*(reinterpret_cast< const unsigned *>(&(*this)))); return ret; } 
# 326
}; 
# 334
__attribute((always_inline)) __attribute__((unused)) inline __half2 operator+(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 334
{ return __hadd2(lh, rh); } 
#endif
# 335 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 operator-(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 335
{ return __hsub2(lh, rh); } 
#endif
# 336 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 operator*(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 336
{ return __hmul2(lh, rh); } 
#endif
# 337 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 operator/(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 337
{ return __h2div(lh, rh); } 
#endif
# 339 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 &operator+=(__half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 339
{ (lh = (__hadd2(lh, rh))); return lh; } 
#endif
# 340 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 &operator-=(__half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 340
{ (lh = (__hsub2(lh, rh))); return lh; } 
#endif
# 341 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 &operator*=(__half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 341
{ (lh = (__hmul2(lh, rh))); return lh; } 
#endif
# 342 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 &operator/=(__half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 342
{ (lh = (__h2div(lh, rh))); return lh; } 
#endif
# 344 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 &operator++(__half2 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 344
{ __half2_raw one; (one.x) = (15360U); (one.y) = (15360U); (h = (__hadd2(h, one))); return h; } 
#endif
# 345 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 &operator--(__half2 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 345
{ __half2_raw one; (one.x) = (15360U); (one.y) = (15360U); (h = (__hsub2(h, one))); return h; } 
#endif
# 346 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 operator++(__half2 &h, const int ignored) 
# 347
{int volatile ___ = 1;(void)h;(void)ignored;
# 357
::exit(___);}
#if 0
# 347
{ 
# 349
static_cast< void>(ignored); 
# 351
const __half2 ret = h; 
# 352
__half2_raw one; 
# 353
(one.x) = (15360U); 
# 354
(one.y) = (15360U); 
# 355
(h = (__hadd2(h, one))); 
# 356
return ret; 
# 357
} 
#endif
# 358 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 operator--(__half2 &h, const int ignored) 
# 359
{int volatile ___ = 1;(void)h;(void)ignored;
# 369
::exit(___);}
#if 0
# 359
{ 
# 361
static_cast< void>(ignored); 
# 363
const __half2 ret = h; 
# 364
__half2_raw one; 
# 365
(one.x) = (15360U); 
# 366
(one.y) = (15360U); 
# 367
(h = (__hsub2(h, one))); 
# 368
return ret; 
# 369
} 
#endif
# 371 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 operator+(const __half2 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 371
{ return h; } 
#endif
# 372 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __half2 operator-(const __half2 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 372
{ return __hneg2(h); } 
#endif
# 374 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator==(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 374
{ return __hbeq2(lh, rh); } 
#endif
# 375 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator!=(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 375
{ return __hbneu2(lh, rh); } 
#endif
# 376 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator>(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 376
{ return __hbgt2(lh, rh); } 
#endif
# 377 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator<(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 377
{ return __hblt2(lh, rh); } 
#endif
# 378 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator>=(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 378
{ return __hbge2(lh, rh); } 
#endif
# 379 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator<=(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 379
{ return __hble2(lh, rh); } 
#endif
# 392 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
#pragma GCC diagnostic pop
# 400
static inline unsigned short __internal_float2half(const float f, unsigned &sign, unsigned &remainder) 
# 401
{ 
# 402
unsigned x; 
# 403
unsigned u; 
# 404
unsigned result; 
# 406
(void)memcpy(&x, &f, sizeof f); 
# 410
u = (x & 2147483647U); 
# 411
sign = ((x >> 16U) & 32768U); 
# 413
if (u >= 2139095040U) { 
# 414
remainder = 0U; 
# 415
result = ((u == 2139095040U) ? sign | 31744U : 32767U); 
# 416
} else { if (u > 1199566847U) { 
# 417
remainder = 2147483648U; 
# 418
result = (sign | 31743U); 
# 419
} else { if (u >= 947912704U) { 
# 420
remainder = (u << 19U); 
# 421
u -= 939524096U; 
# 422
result = (sign | (u >> 13U)); 
# 423
} else { if (u < 855638017U) { 
# 424
remainder = u; 
# 425
result = sign; 
# 426
} else { 
# 427
const unsigned exponent = u >> 23U; 
# 428
const unsigned shift = 126U - exponent; 
# 429
unsigned mantissa = u & 8388607U; 
# 430
mantissa |= 8388608U; 
# 431
remainder = (mantissa << (32U - shift)); 
# 432
result = (sign | (mantissa >> shift)); 
# 433
result &= 65535U; 
# 434
}  }  }  }  
# 435
return static_cast< unsigned short>(result); 
# 436
} 
# 439
static inline __half __double2half(const double a) 
# 440
{ 
# 446
__half result; 
# 451
unsigned long long absa; 
# 452
unsigned long long ua; 
# 454
(void)memcpy(&ua, &a, sizeof a); 
# 458
absa = (ua & 9223372036854775807ULL); 
# 459
if ((absa >= 4679240012837945344ULL) || (absa <= 4494592428115755008ULL)) 
# 460
{ 
# 463
result = __float2half(static_cast< float>(a)); 
# 464
} else 
# 466
{ 
# 477 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
unsigned long long shifterBits; 
# 478
if (absa >= 4544132024016830464ULL) 
# 479
{ 
# 481
shifterBits = ((ua & 9218868437227405312ULL) + 189151184349560832ULL); 
# 482
} else 
# 484
{ 
# 486
shifterBits = 4733283208366391296ULL; 
# 487
}  
# 489
shifterBits |= 2251799813685248ULL; 
# 490
double shifter; 
# 492
(void)memcpy(&shifter, &shifterBits, sizeof shifterBits); 
# 496
double aShiftRound = a + shifter; 
# 500
unsigned long long aShiftRoundBits; 
# 502
(void)memcpy(&aShiftRoundBits, &aShiftRound, sizeof aShiftRound); 
# 508
aShiftRoundBits &= 9223372036854775807ULL; 
# 511
(void)memcpy(&aShiftRound, &aShiftRoundBits, sizeof aShiftRound); 
# 516
result = __float2half(static_cast< float>(aShiftRound - shifter)); 
# 517
}  
# 519
return result; 
# 521
} 
# 523
static inline __half __float2half(const float a) 
# 524
{ 
# 525
__half val; 
# 529
__half_raw r; 
# 530
unsigned sign = 0U; 
# 531
unsigned remainder = 0U; 
# 532
(r.x) = __internal_float2half(a, sign, remainder); 
# 533
if ((remainder > 2147483648U) || ((remainder == 2147483648U) && (((r.x) & 1U) != 0U))) { 
# 534
(r.x)++; 
# 535
}  
# 536
(val = r); 
# 538
return val; 
# 539
} 
# 540
static inline __half __float2half_rn(const float a) 
# 541
{ 
# 542
__half val; 
# 546
__half_raw r; 
# 547
unsigned sign = 0U; 
# 548
unsigned remainder = 0U; 
# 549
(r.x) = __internal_float2half(a, sign, remainder); 
# 550
if ((remainder > 2147483648U) || ((remainder == 2147483648U) && (((r.x) & 1U) != 0U))) { 
# 551
(r.x)++; 
# 552
}  
# 553
(val = r); 
# 555
return val; 
# 556
} 
# 557
static inline __half __float2half_rz(const float a) 
# 558
{ 
# 559
__half val; 
# 563
__half_raw r; 
# 564
unsigned sign = 0U; 
# 565
unsigned remainder = 0U; 
# 566
(r.x) = __internal_float2half(a, sign, remainder); 
# 567
(val = r); 
# 569
return val; 
# 570
} 
# 571
static inline __half __float2half_rd(const float a) 
# 572
{ 
# 573
__half val; 
# 577
__half_raw r; 
# 578
unsigned sign = 0U; 
# 579
unsigned remainder = 0U; 
# 580
(r.x) = __internal_float2half(a, sign, remainder); 
# 581
if ((remainder != 0U) && (sign != 0U)) { 
# 582
(r.x)++; 
# 583
}  
# 584
(val = r); 
# 586
return val; 
# 587
} 
# 588
static inline __half __float2half_ru(const float a) 
# 589
{ 
# 590
__half val; 
# 594
__half_raw r; 
# 595
unsigned sign = 0U; 
# 596
unsigned remainder = 0U; 
# 597
(r.x) = __internal_float2half(a, sign, remainder); 
# 598
if ((remainder != 0U) && (sign == 0U)) { 
# 599
(r.x)++; 
# 600
}  
# 601
(val = r); 
# 603
return val; 
# 604
} 
# 605
static inline __half2 __float2half2_rn(const float a) 
# 606
{ 
# 607
__half2 val; 
# 613
(val = __half2(__float2half_rn(a), __float2half_rn(a))); 
# 615
return val; 
# 616
} 
# 617
static inline __half2 __floats2half2_rn(const float a, const float b) 
# 618
{ 
# 619
__half2 val; 
# 631 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
(val = __half2(__float2half_rn(a), __float2half_rn(b))); 
# 633
return val; 
# 634
} 
# 637
static inline float __internal_half2float(const unsigned short h) 
# 638
{ 
# 639
unsigned sign = ((static_cast< unsigned>(h)) >> 15U) & 1U; 
# 640
unsigned exponent = ((static_cast< unsigned>(h)) >> 10U) & 31U; 
# 641
unsigned mantissa = ((static_cast< unsigned>(h)) & 1023U) << 13U; 
# 642
float f; 
# 643
if (exponent == 31U) { 
# 645
sign = ((mantissa != 0U) ? sign >> 1U : sign); 
# 646
mantissa = ((mantissa != 0U) ? 8388607U : 0U); 
# 647
exponent = 255U; 
# 648
} else { if (exponent == 0U) { 
# 649
if (mantissa != 0U) { 
# 650
unsigned msb; 
# 651
exponent = 113U; 
# 652
do { 
# 653
msb = (mantissa & 4194304U); 
# 654
mantissa <<= 1U; 
# 655
--exponent; 
# 656
} while (msb == 0U); 
# 657
mantissa &= 8388607U; 
# 658
}  
# 659
} else { 
# 660
exponent += 112U; 
# 661
}  }  
# 662
const unsigned u = ((sign << 31U) | (exponent << 23U)) | mantissa; 
# 664
(void)memcpy(&f, &u, sizeof u); 
# 668
return f; 
# 669
} 
# 672
static inline float __half2float(const __half a) 
# 673
{ 
# 674
float val; 
# 678
val = __internal_half2float(((__half_raw)a).x); 
# 680
return val; 
# 681
} 
# 682
static inline float __low2float(const __half2 a) 
# 683
{ 
# 684
float val; 
# 690
val = __internal_half2float(((__half2_raw)a).x); 
# 692
return val; 
# 693
} 
# 694
static inline float __high2float(const __half2 a) 
# 695
{ 
# 696
float val; 
# 702
val = __internal_half2float(((__half2_raw)a).y); 
# 704
return val; 
# 705
} 
# 711
static inline __half2 make_half2(const __half x, const __half y) 
# 712
{ 
# 713
__half2 t; (t.x) = x; (t.y) = y; return t; 
# 714
} 
# 719
static inline __half2 __float22half2_rn(const float2 a) 
# 720
{ 
# 721
const __half2 val = __floats2half2_rn(a.x, a.y); 
# 722
return val; 
# 723
} 
# 724
static inline float2 __half22float2(const __half2 a) 
# 725
{ 
# 726
float hi_float; 
# 727
float lo_float; 
# 737 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
lo_float = __internal_half2float(((__half2_raw)a).x); 
# 738
hi_float = __internal_half2float(((__half2_raw)a).y); 
# 740
return make_float2(lo_float, hi_float); 
# 741
} 
# 742
__attribute__((unused)) static inline int __half2int_rn(const __half h) 
# 743
{int volatile ___ = 1;(void)h;
# 747
::exit(___);}
#if 0
# 743
{ 
# 744
int i; 
# 745
__asm__("cvt.rni.s32.f16 %0, %1;" : "=r" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 746
return i; 
# 747
} 
#endif
# 748 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline int __half2int_rz(const __half h) 
# 749
{ 
# 750
int i; 
# 754
const float f = __half2float(h); 
# 755
i = (static_cast< int>(f)); 
# 756
const int max_val = ((int)2147483647U); 
# 757
const int min_val = ((int)2147483648U); 
# 758
const unsigned short bits = static_cast< unsigned short>((((__half_raw)h).x) << 1U); 
# 760
if (bits > ((unsigned short)63488U)) { 
# 762
i = 0; 
# 763
} else { if (f > (static_cast< float>(max_val))) { 
# 765
i = max_val; 
# 766
} else { if (f < (static_cast< float>(min_val))) { 
# 768
i = min_val; 
# 769
} else { 
# 771
}  }  }  
# 773
return i; 
# 774
} 
# 775
__attribute__((unused)) static inline int __half2int_rd(const __half h) 
# 776
{int volatile ___ = 1;(void)h;
# 780
::exit(___);}
#if 0
# 776
{ 
# 777
int i; 
# 778
__asm__("cvt.rmi.s32.f16 %0, %1;" : "=r" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 779
return i; 
# 780
} 
#endif
# 781 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline int __half2int_ru(const __half h) 
# 782
{int volatile ___ = 1;(void)h;
# 786
::exit(___);}
#if 0
# 782
{ 
# 783
int i; 
# 784
__asm__("cvt.rpi.s32.f16 %0, %1;" : "=r" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 785
return i; 
# 786
} 
#endif
# 787 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline __half __int2half_rn(const int i) 
# 788
{ 
# 789
__half h; 
# 797
const float f = static_cast< float>(i); 
# 798
h = __float2half_rn(f); 
# 800
return h; 
# 801
} 
# 802
__attribute__((unused)) static inline __half __int2half_rz(const int i) 
# 803
{int volatile ___ = 1;(void)i;
# 807
::exit(___);}
#if 0
# 803
{ 
# 804
__half h; 
# 805
__asm__("cvt.rz.f16.s32 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "r" (i)); 
# 806
return h; 
# 807
} 
#endif
# 808 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __int2half_rd(const int i) 
# 809
{int volatile ___ = 1;(void)i;
# 813
::exit(___);}
#if 0
# 809
{ 
# 810
__half h; 
# 811
__asm__("cvt.rm.f16.s32 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "r" (i)); 
# 812
return h; 
# 813
} 
#endif
# 814 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __int2half_ru(const int i) 
# 815
{int volatile ___ = 1;(void)i;
# 819
::exit(___);}
#if 0
# 815
{ 
# 816
__half h; 
# 817
__asm__("cvt.rp.f16.s32 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "r" (i)); 
# 818
return h; 
# 819
} 
#endif
# 821 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline short __half2short_rn(const __half h) 
# 822
{int volatile ___ = 1;(void)h;
# 826
::exit(___);}
#if 0
# 822
{ 
# 823
short i; 
# 824
__asm__("cvt.rni.s16.f16 %0, %1;" : "=h" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 825
return i; 
# 826
} 
#endif
# 827 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline short __half2short_rz(const __half h) 
# 828
{ 
# 829
short i; 
# 833
const float f = __half2float(h); 
# 834
i = (static_cast< short>(f)); 
# 835
const short max_val = ((short)32767U); 
# 836
const short min_val = ((short)32768U); 
# 837
const unsigned short bits = static_cast< unsigned short>((((__half_raw)h).x) << 1U); 
# 839
if (bits > ((unsigned short)63488U)) { 
# 841
i = (0); 
# 842
} else { if (f > (static_cast< float>(max_val))) { 
# 844
i = max_val; 
# 845
} else { if (f < (static_cast< float>(min_val))) { 
# 847
i = min_val; 
# 848
} else { 
# 850
}  }  }  
# 852
return i; 
# 853
} 
# 854
__attribute__((unused)) static inline short __half2short_rd(const __half h) 
# 855
{int volatile ___ = 1;(void)h;
# 859
::exit(___);}
#if 0
# 855
{ 
# 856
short i; 
# 857
__asm__("cvt.rmi.s16.f16 %0, %1;" : "=h" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 858
return i; 
# 859
} 
#endif
# 860 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline short __half2short_ru(const __half h) 
# 861
{int volatile ___ = 1;(void)h;
# 865
::exit(___);}
#if 0
# 861
{ 
# 862
short i; 
# 863
__asm__("cvt.rpi.s16.f16 %0, %1;" : "=h" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 864
return i; 
# 865
} 
#endif
# 866 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline __half __short2half_rn(const short i) 
# 867
{ 
# 868
__half h; 
# 872
const float f = static_cast< float>(i); 
# 873
h = __float2half_rn(f); 
# 875
return h; 
# 876
} 
# 877
__attribute__((unused)) static inline __half __short2half_rz(const short i) 
# 878
{int volatile ___ = 1;(void)i;
# 882
::exit(___);}
#if 0
# 878
{ 
# 879
__half h; 
# 880
__asm__("cvt.rz.f16.s16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "h" (i)); 
# 881
return h; 
# 882
} 
#endif
# 883 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __short2half_rd(const short i) 
# 884
{int volatile ___ = 1;(void)i;
# 888
::exit(___);}
#if 0
# 884
{ 
# 885
__half h; 
# 886
__asm__("cvt.rm.f16.s16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "h" (i)); 
# 887
return h; 
# 888
} 
#endif
# 889 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __short2half_ru(const short i) 
# 890
{int volatile ___ = 1;(void)i;
# 894
::exit(___);}
#if 0
# 890
{ 
# 891
__half h; 
# 892
__asm__("cvt.rp.f16.s16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "h" (i)); 
# 893
return h; 
# 894
} 
#endif
# 896 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline unsigned __half2uint_rn(const __half h) 
# 897
{int volatile ___ = 1;(void)h;
# 901
::exit(___);}
#if 0
# 897
{ 
# 898
unsigned i; 
# 899
__asm__("cvt.rni.u32.f16 %0, %1;" : "=r" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 900
return i; 
# 901
} 
#endif
# 902 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline unsigned __half2uint_rz(const __half h) 
# 903
{ 
# 904
unsigned i; 
# 908
const float f = __half2float(h); 
# 909
i = (static_cast< unsigned>(f)); 
# 910
const unsigned max_val = 4294967295U; 
# 911
const unsigned min_val = 0U; 
# 912
const unsigned short bits = static_cast< unsigned short>((((__half_raw)h).x) << 1U); 
# 914
if (bits > ((unsigned short)63488U)) { 
# 916
i = 0U; 
# 917
} else { if (f > (static_cast< float>(max_val))) { 
# 919
i = max_val; 
# 920
} else { if (f < (static_cast< float>(min_val))) { 
# 922
i = min_val; 
# 923
} else { 
# 925
}  }  }  
# 927
return i; 
# 928
} 
# 929
__attribute__((unused)) static inline unsigned __half2uint_rd(const __half h) 
# 930
{int volatile ___ = 1;(void)h;
# 934
::exit(___);}
#if 0
# 930
{ 
# 931
unsigned i; 
# 932
__asm__("cvt.rmi.u32.f16 %0, %1;" : "=r" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 933
return i; 
# 934
} 
#endif
# 935 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline unsigned __half2uint_ru(const __half h) 
# 936
{int volatile ___ = 1;(void)h;
# 940
::exit(___);}
#if 0
# 936
{ 
# 937
unsigned i; 
# 938
__asm__("cvt.rpi.u32.f16 %0, %1;" : "=r" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 939
return i; 
# 940
} 
#endif
# 941 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline __half __uint2half_rn(const unsigned i) 
# 942
{ 
# 943
__half h; 
# 951
const float f = static_cast< float>(i); 
# 952
h = __float2half_rn(f); 
# 954
return h; 
# 955
} 
# 956
__attribute__((unused)) static inline __half __uint2half_rz(const unsigned i) 
# 957
{int volatile ___ = 1;(void)i;
# 961
::exit(___);}
#if 0
# 957
{ 
# 958
__half h; 
# 959
__asm__("cvt.rz.f16.u32 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "r" (i)); 
# 960
return h; 
# 961
} 
#endif
# 962 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __uint2half_rd(const unsigned i) 
# 963
{int volatile ___ = 1;(void)i;
# 967
::exit(___);}
#if 0
# 963
{ 
# 964
__half h; 
# 965
__asm__("cvt.rm.f16.u32 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "r" (i)); 
# 966
return h; 
# 967
} 
#endif
# 968 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __uint2half_ru(const unsigned i) 
# 969
{int volatile ___ = 1;(void)i;
# 973
::exit(___);}
#if 0
# 969
{ 
# 970
__half h; 
# 971
__asm__("cvt.rp.f16.u32 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "r" (i)); 
# 972
return h; 
# 973
} 
#endif
# 975 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline unsigned short __half2ushort_rn(const __half h) 
# 976
{int volatile ___ = 1;(void)h;
# 980
::exit(___);}
#if 0
# 976
{ 
# 977
unsigned short i; 
# 978
__asm__("cvt.rni.u16.f16 %0, %1;" : "=h" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 979
return i; 
# 980
} 
#endif
# 981 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline unsigned short __half2ushort_rz(const __half h) 
# 982
{ 
# 983
unsigned short i; 
# 987
const float f = __half2float(h); 
# 988
i = (static_cast< unsigned short>(f)); 
# 989
const unsigned short max_val = (65535U); 
# 990
const unsigned short min_val = (0U); 
# 991
const unsigned short bits = static_cast< unsigned short>((((__half_raw)h).x) << 1U); 
# 993
if (bits > ((unsigned short)63488U)) { 
# 995
i = (0U); 
# 996
} else { if (f > (static_cast< float>(max_val))) { 
# 998
i = max_val; 
# 999
} else { if (f < (static_cast< float>(min_val))) { 
# 1001
i = min_val; 
# 1002
} else { 
# 1004
}  }  }  
# 1006
return i; 
# 1007
} 
# 1008
__attribute__((unused)) static inline unsigned short __half2ushort_rd(const __half h) 
# 1009
{int volatile ___ = 1;(void)h;
# 1013
::exit(___);}
#if 0
# 1009
{ 
# 1010
unsigned short i; 
# 1011
__asm__("cvt.rmi.u16.f16 %0, %1;" : "=h" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1012
return i; 
# 1013
} 
#endif
# 1014 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline unsigned short __half2ushort_ru(const __half h) 
# 1015
{int volatile ___ = 1;(void)h;
# 1019
::exit(___);}
#if 0
# 1015
{ 
# 1016
unsigned short i; 
# 1017
__asm__("cvt.rpi.u16.f16 %0, %1;" : "=h" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1018
return i; 
# 1019
} 
#endif
# 1020 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline __half __ushort2half_rn(const unsigned short i) 
# 1021
{ 
# 1022
__half h; 
# 1026
const float f = static_cast< float>(i); 
# 1027
h = __float2half_rn(f); 
# 1029
return h; 
# 1030
} 
# 1031
__attribute__((unused)) static inline __half __ushort2half_rz(const unsigned short i) 
# 1032
{int volatile ___ = 1;(void)i;
# 1036
::exit(___);}
#if 0
# 1032
{ 
# 1033
__half h; 
# 1034
__asm__("cvt.rz.f16.u16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "h" (i)); 
# 1035
return h; 
# 1036
} 
#endif
# 1037 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ushort2half_rd(const unsigned short i) 
# 1038
{int volatile ___ = 1;(void)i;
# 1042
::exit(___);}
#if 0
# 1038
{ 
# 1039
__half h; 
# 1040
__asm__("cvt.rm.f16.u16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "h" (i)); 
# 1041
return h; 
# 1042
} 
#endif
# 1043 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ushort2half_ru(const unsigned short i) 
# 1044
{int volatile ___ = 1;(void)i;
# 1048
::exit(___);}
#if 0
# 1044
{ 
# 1045
__half h; 
# 1046
__asm__("cvt.rp.f16.u16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "h" (i)); 
# 1047
return h; 
# 1048
} 
#endif
# 1050 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline unsigned long long __half2ull_rn(const __half h) 
# 1051
{int volatile ___ = 1;(void)h;
# 1055
::exit(___);}
#if 0
# 1051
{ 
# 1052
unsigned long long i; 
# 1053
__asm__("cvt.rni.u64.f16 %0, %1;" : "=l" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1054
return i; 
# 1055
} 
#endif
# 1056 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline unsigned long long __half2ull_rz(const __half h) 
# 1057
{ 
# 1058
unsigned long long i; 
# 1062
const float f = __half2float(h); 
# 1063
i = (static_cast< unsigned long long>(f)); 
# 1064
const unsigned long long max_val = 18446744073709551615ULL; 
# 1065
const unsigned long long min_val = 0ULL; 
# 1066
const unsigned short bits = static_cast< unsigned short>((((__half_raw)h).x) << 1U); 
# 1068
if (bits > ((unsigned short)63488U)) { 
# 1070
i = 9223372036854775808ULL; 
# 1071
} else { if (f > (static_cast< float>(max_val))) { 
# 1073
i = max_val; 
# 1074
} else { if (f < (static_cast< float>(min_val))) { 
# 1076
i = min_val; 
# 1077
} else { 
# 1079
}  }  }  
# 1081
return i; 
# 1082
} 
# 1083
__attribute__((unused)) static inline unsigned long long __half2ull_rd(const __half h) 
# 1084
{int volatile ___ = 1;(void)h;
# 1088
::exit(___);}
#if 0
# 1084
{ 
# 1085
unsigned long long i; 
# 1086
__asm__("cvt.rmi.u64.f16 %0, %1;" : "=l" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1087
return i; 
# 1088
} 
#endif
# 1089 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline unsigned long long __half2ull_ru(const __half h) 
# 1090
{int volatile ___ = 1;(void)h;
# 1094
::exit(___);}
#if 0
# 1090
{ 
# 1091
unsigned long long i; 
# 1092
__asm__("cvt.rpi.u64.f16 %0, %1;" : "=l" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1093
return i; 
# 1094
} 
#endif
# 1095 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline __half __ull2half_rn(const unsigned long long i) 
# 1096
{ 
# 1097
__half h; 
# 1105
const float f = static_cast< float>(i); 
# 1106
h = __float2half_rn(f); 
# 1108
return h; 
# 1109
} 
# 1110
__attribute__((unused)) static inline __half __ull2half_rz(const unsigned long long i) 
# 1111
{int volatile ___ = 1;(void)i;
# 1115
::exit(___);}
#if 0
# 1111
{ 
# 1112
__half h; 
# 1113
__asm__("cvt.rz.f16.u64 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "l" (i)); 
# 1114
return h; 
# 1115
} 
#endif
# 1116 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ull2half_rd(const unsigned long long i) 
# 1117
{int volatile ___ = 1;(void)i;
# 1121
::exit(___);}
#if 0
# 1117
{ 
# 1118
__half h; 
# 1119
__asm__("cvt.rm.f16.u64 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "l" (i)); 
# 1120
return h; 
# 1121
} 
#endif
# 1122 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ull2half_ru(const unsigned long long i) 
# 1123
{int volatile ___ = 1;(void)i;
# 1127
::exit(___);}
#if 0
# 1123
{ 
# 1124
__half h; 
# 1125
__asm__("cvt.rp.f16.u64 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "l" (i)); 
# 1126
return h; 
# 1127
} 
#endif
# 1129 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline long long __half2ll_rn(const __half h) 
# 1130
{int volatile ___ = 1;(void)h;
# 1134
::exit(___);}
#if 0
# 1130
{ 
# 1131
long long i; 
# 1132
__asm__("cvt.rni.s64.f16 %0, %1;" : "=l" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1133
return i; 
# 1134
} 
#endif
# 1135 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline long long __half2ll_rz(const __half h) 
# 1136
{ 
# 1137
long long i; 
# 1141
const float f = __half2float(h); 
# 1142
i = (static_cast< long long>(f)); 
# 1143
const long long max_val = ((long long)9223372036854775807ULL); 
# 1144
const long long min_val = ((long long)9223372036854775808ULL); 
# 1145
const unsigned short bits = static_cast< unsigned short>((((__half_raw)h).x) << 1U); 
# 1147
if (bits > ((unsigned short)63488U)) { 
# 1149
i = min_val; 
# 1150
} else { if (f > (static_cast< float>(max_val))) { 
# 1152
i = max_val; 
# 1153
} else { if (f < (static_cast< float>(min_val))) { 
# 1155
i = min_val; 
# 1156
} else { 
# 1158
}  }  }  
# 1160
return i; 
# 1161
} 
# 1162
__attribute__((unused)) static inline long long __half2ll_rd(const __half h) 
# 1163
{int volatile ___ = 1;(void)h;
# 1167
::exit(___);}
#if 0
# 1163
{ 
# 1164
long long i; 
# 1165
__asm__("cvt.rmi.s64.f16 %0, %1;" : "=l" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1166
return i; 
# 1167
} 
#endif
# 1168 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline long long __half2ll_ru(const __half h) 
# 1169
{int volatile ___ = 1;(void)h;
# 1173
::exit(___);}
#if 0
# 1169
{ 
# 1170
long long i; 
# 1171
__asm__("cvt.rpi.s64.f16 %0, %1;" : "=l" (i) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1172
return i; 
# 1173
} 
#endif
# 1174 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
static inline __half __ll2half_rn(const long long i) 
# 1175
{ 
# 1176
__half h; 
# 1184
const float f = static_cast< float>(i); 
# 1185
h = __float2half_rn(f); 
# 1187
return h; 
# 1188
} 
# 1189
__attribute__((unused)) static inline __half __ll2half_rz(const long long i) 
# 1190
{int volatile ___ = 1;(void)i;
# 1194
::exit(___);}
#if 0
# 1190
{ 
# 1191
__half h; 
# 1192
__asm__("cvt.rz.f16.s64 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "l" (i)); 
# 1193
return h; 
# 1194
} 
#endif
# 1195 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ll2half_rd(const long long i) 
# 1196
{int volatile ___ = 1;(void)i;
# 1200
::exit(___);}
#if 0
# 1196
{ 
# 1197
__half h; 
# 1198
__asm__("cvt.rm.f16.s64 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "l" (i)); 
# 1199
return h; 
# 1200
} 
#endif
# 1201 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ll2half_ru(const long long i) 
# 1202
{int volatile ___ = 1;(void)i;
# 1206
::exit(___);}
#if 0
# 1202
{ 
# 1203
__half h; 
# 1204
__asm__("cvt.rp.f16.s64 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&h))) : "l" (i)); 
# 1205
return h; 
# 1206
} 
#endif
# 1208 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half htrunc(const __half h) 
# 1209
{int volatile ___ = 1;(void)h;
# 1213
::exit(___);}
#if 0
# 1209
{ 
# 1210
__half r; 
# 1211
__asm__("cvt.rzi.f16.f16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1212
return r; 
# 1213
} 
#endif
# 1214 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hceil(const __half h) 
# 1215
{int volatile ___ = 1;(void)h;
# 1219
::exit(___);}
#if 0
# 1215
{ 
# 1216
__half r; 
# 1217
__asm__("cvt.rpi.f16.f16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1218
return r; 
# 1219
} 
#endif
# 1220 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hfloor(const __half h) 
# 1221
{int volatile ___ = 1;(void)h;
# 1225
::exit(___);}
#if 0
# 1221
{ 
# 1222
__half r; 
# 1223
__asm__("cvt.rmi.f16.f16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1224
return r; 
# 1225
} 
#endif
# 1226 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hrint(const __half h) 
# 1227
{int volatile ___ = 1;(void)h;
# 1231
::exit(___);}
#if 0
# 1227
{ 
# 1228
__half r; 
# 1229
__asm__("cvt.rni.f16.f16 %0, %1;" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 1230
return r; 
# 1231
} 
#endif
# 1233 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2trunc(const __half2 h) 
# 1234
{int volatile ___ = 1;(void)h;
# 1242
::exit(___);}
#if 0
# 1234
{ 
# 1235
__half2 val; 
# 1236
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  cvt.rzi.f16.f16 low, low;\n  cvt.rzi.f16.f16 high, high;\n  mov.b32 %0, {low," "high};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&h)))); 
# 1241
return val; 
# 1242
} 
#endif
# 1243 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2ceil(const __half2 h) 
# 1244
{int volatile ___ = 1;(void)h;
# 1252
::exit(___);}
#if 0
# 1244
{ 
# 1245
__half2 val; 
# 1246
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  cvt.rpi.f16.f16 low, low;\n  cvt.rpi.f16.f16 high, high;\n  mov.b32 %0, {low," "high};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&h)))); 
# 1251
return val; 
# 1252
} 
#endif
# 1253 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2floor(const __half2 h) 
# 1254
{int volatile ___ = 1;(void)h;
# 1262
::exit(___);}
#if 0
# 1254
{ 
# 1255
__half2 val; 
# 1256
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  cvt.rmi.f16.f16 low, low;\n  cvt.rmi.f16.f16 high, high;\n  mov.b32 %0, {low," "high};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&h)))); 
# 1261
return val; 
# 1262
} 
#endif
# 1263 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2rint(const __half2 h) 
# 1264
{int volatile ___ = 1;(void)h;
# 1272
::exit(___);}
#if 0
# 1264
{ 
# 1265
__half2 val; 
# 1266
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  cvt.rni.f16.f16 low, low;\n  cvt.rni.f16.f16 high, high;\n  mov.b32 %0, {low," "high};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&h)))); 
# 1271
return val; 
# 1272
} 
#endif
# 1273 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __lows2half2(const __half2 a, const __half2 b) 
# 1274
{int volatile ___ = 1;(void)a;(void)b;
# 1281
::exit(___);}
#if 0
# 1274
{ 
# 1275
__half2 val; 
# 1276
__asm__("{.reg .f16 alow,ahigh,blow,bhigh;\n  mov.b32 {alow,ahigh}, %1;\n  mov.b32 {blow,bhigh}, %2;\n  mov.b32 %0, {alow,blow};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1280
return val; 
# 1281
} 
#endif
# 1282 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __highs2half2(const __half2 a, const __half2 b) 
# 1283
{int volatile ___ = 1;(void)a;(void)b;
# 1290
::exit(___);}
#if 0
# 1283
{ 
# 1284
__half2 val; 
# 1285
__asm__("{.reg .f16 alow,ahigh,blow,bhigh;\n  mov.b32 {alow,ahigh}, %1;\n  mov.b32 {blow,bhigh}, %2;\n  mov.b32 %0, {ahigh,bhigh};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1289
return val; 
# 1290
} 
#endif
# 1291 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __low2half(const __half2 a) 
# 1292
{int volatile ___ = 1;(void)a;
# 1298
::exit(___);}
#if 0
# 1292
{ 
# 1293
__half ret; 
# 1294
__asm__("{.reg .f16 low,high;\n mov.b32 {low,high}, %1;\n mov.b16 %0, low;}" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1297
return ret; 
# 1298
} 
#endif
# 1299 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline int __hisinf(const __half a) 
# 1300
{int volatile ___ = 1;(void)a;
# 1310
::exit(___);}
#if 0
# 1300
{ 
# 1301
int retval; 
# 1302
if ((*(reinterpret_cast< const unsigned short *>(&a))) == 64512U) { 
# 1303
retval = (-1); 
# 1304
} else { if ((*(reinterpret_cast< const unsigned short *>(&a))) == 31744U) { 
# 1305
retval = 1; 
# 1306
} else { 
# 1307
retval = 0; 
# 1308
}  }  
# 1309
return retval; 
# 1310
} 
#endif
# 1311 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __low2half2(const __half2 a) 
# 1312
{int volatile ___ = 1;(void)a;
# 1318
::exit(___);}
#if 0
# 1312
{ 
# 1313
__half2 val; 
# 1314
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {low,low};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1317
return val; 
# 1318
} 
#endif
# 1319 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __high2half2(const __half2 a) 
# 1320
{int volatile ___ = 1;(void)a;
# 1326
::exit(___);}
#if 0
# 1320
{ 
# 1321
__half2 val; 
# 1322
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {high,high};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1325
return val; 
# 1326
} 
#endif
# 1327 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __high2half(const __half2 a) 
# 1328
{int volatile ___ = 1;(void)a;
# 1334
::exit(___);}
#if 0
# 1328
{ 
# 1329
__half ret; 
# 1330
__asm__("{.reg .f16 low,high;\n mov.b32 {low,high}, %1;\n mov.b16 %0, high;}" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1333
return ret; 
# 1334
} 
#endif
# 1335 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __halves2half2(const __half a, const __half b) 
# 1336
{int volatile ___ = 1;(void)a;(void)b;
# 1341
::exit(___);}
#if 0
# 1336
{ 
# 1337
__half2 val; 
# 1338
__asm__("{  mov.b32 %0, {%1,%2};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1340
return val; 
# 1341
} 
#endif
# 1342 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __half2half2(const __half a) 
# 1343
{int volatile ___ = 1;(void)a;
# 1348
::exit(___);}
#if 0
# 1343
{ 
# 1344
__half2 val; 
# 1345
__asm__("{  mov.b32 %0, {%1,%1};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 1347
return val; 
# 1348
} 
#endif
# 1349 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __lowhigh2highlow(const __half2 a) 
# 1350
{int volatile ___ = 1;(void)a;
# 1356
::exit(___);}
#if 0
# 1350
{ 
# 1351
__half2 val; 
# 1352
__asm__("{.reg .f16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {high,low};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1355
return val; 
# 1356
} 
#endif
# 1357 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline short __half_as_short(const __half h) 
# 1358
{int volatile ___ = 1;(void)h;
# 1360
::exit(___);}
#if 0
# 1358
{ 
# 1359
return static_cast< short>(*(reinterpret_cast< const unsigned short *>(&h))); 
# 1360
} 
#endif
# 1361 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline unsigned short __half_as_ushort(const __half h) 
# 1362
{int volatile ___ = 1;(void)h;
# 1364
::exit(___);}
#if 0
# 1362
{ 
# 1363
return *(reinterpret_cast< const unsigned short *>(&h)); 
# 1364
} 
#endif
# 1365 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __short_as_half(const short i) 
# 1366
{int volatile ___ = 1;(void)i;
# 1370
::exit(___);}
#if 0
# 1366
{ 
# 1367
__half h; 
# 1368
(*(reinterpret_cast< unsigned short *>(&h))) = (static_cast< unsigned short>(i)); 
# 1369
return h; 
# 1370
} 
#endif
# 1371 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ushort_as_half(const unsigned short i) 
# 1372
{int volatile ___ = 1;(void)i;
# 1376
::exit(___);}
#if 0
# 1372
{ 
# 1373
__half h; 
# 1374
(*(reinterpret_cast< unsigned short *>(&h))) = i; 
# 1375
return h; 
# 1376
} 
#endif
# 1398 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __shfl(const __half2 var, const int delta, const int width) 
# 1399
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 1404
::exit(___);}
#if 0
# 1399
{ 
# 1400
unsigned warp_size; 
# 1401
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1402
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1403
{ __half2 r; __asm__ volatile("{shfl.idx.b32 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c)); return r; } 
# 1404
} 
#endif
# 1405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __shfl_up(const __half2 var, const unsigned delta, const int width) 
# 1406
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 1411
::exit(___);}
#if 0
# 1406
{ 
# 1407
unsigned warp_size; 
# 1408
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1409
const unsigned c = (warp_size - (static_cast< unsigned>(width))) << 8U; 
# 1410
{ __half2 r; __asm__ volatile("{shfl.up.b32 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c)); return r; } 
# 1411
} 
#endif
# 1412 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __shfl_down(const __half2 var, const unsigned delta, const int width) 
# 1413
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 1418
::exit(___);}
#if 0
# 1413
{ 
# 1414
unsigned warp_size; 
# 1415
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1416
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1417
{ __half2 r; __asm__ volatile("{shfl.down.b32 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c)); return r; } 
# 1418
} 
#endif
# 1419 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __shfl_xor(const __half2 var, const int delta, const int width) 
# 1420
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 1425
::exit(___);}
#if 0
# 1420
{ 
# 1421
unsigned warp_size; 
# 1422
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1423
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1424
{ __half2 r; __asm__ volatile("{shfl.bfly.b32 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c)); return r; } 
# 1425
} 
#endif
# 1429 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __shfl_sync(const unsigned mask, const __half2 var, const int delta, const int width) 
# 1430
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1435
::exit(___);}
#if 0
# 1430
{ 
# 1431
unsigned warp_size; 
# 1432
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1433
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1434
{ __half2 r; __asm__ volatile("{shfl.sync.idx.b32 %0,%1,%2,%3,%4;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c), "r" (mask)); return r; } 
# 1435
} 
#endif
# 1436 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __shfl_up_sync(const unsigned mask, const __half2 var, const unsigned delta, const int width) 
# 1437
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1442
::exit(___);}
#if 0
# 1437
{ 
# 1438
unsigned warp_size; 
# 1439
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1440
const unsigned c = (warp_size - (static_cast< unsigned>(width))) << 8U; 
# 1441
{ __half2 r; __asm__ volatile("{shfl.sync.up.b32 %0,%1,%2,%3,%4;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c), "r" (mask)); return r; } 
# 1442
} 
#endif
# 1443 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __shfl_down_sync(const unsigned mask, const __half2 var, const unsigned delta, const int width) 
# 1444
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1449
::exit(___);}
#if 0
# 1444
{ 
# 1445
unsigned warp_size; 
# 1446
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1447
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1448
{ __half2 r; __asm__ volatile("{shfl.sync.down.b32 %0,%1,%2,%3,%4;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c), "r" (mask)); return r; } 
# 1449
} 
#endif
# 1450 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __shfl_xor_sync(const unsigned mask, const __half2 var, const int delta, const int width) 
# 1451
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1456
::exit(___);}
#if 0
# 1451
{ 
# 1452
unsigned warp_size; 
# 1453
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1454
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1455
{ __half2 r; __asm__ volatile("{shfl.sync.bfly.b32 %0,%1,%2,%3,%4;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c), "r" (mask)); return r; } 
# 1456
} 
#endif
# 1463 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __shfl(const __half var, const int delta, const int width) 
# 1464
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 1468
::exit(___);}
#if 0
# 1464
{ 
# 1465
const __half2 temp1 = __halves2half2(var, var); 
# 1466
const __half2 temp2 = __shfl(temp1, delta, width); 
# 1467
return __low2half(temp2); 
# 1468
} 
#endif
# 1469 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __shfl_up(const __half var, const unsigned delta, const int width) 
# 1470
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 1474
::exit(___);}
#if 0
# 1470
{ 
# 1471
const __half2 temp1 = __halves2half2(var, var); 
# 1472
const __half2 temp2 = __shfl_up(temp1, delta, width); 
# 1473
return __low2half(temp2); 
# 1474
} 
#endif
# 1475 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __shfl_down(const __half var, const unsigned delta, const int width) 
# 1476
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 1480
::exit(___);}
#if 0
# 1476
{ 
# 1477
const __half2 temp1 = __halves2half2(var, var); 
# 1478
const __half2 temp2 = __shfl_down(temp1, delta, width); 
# 1479
return __low2half(temp2); 
# 1480
} 
#endif
# 1481 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __shfl_xor(const __half var, const int delta, const int width) 
# 1482
{int volatile ___ = 1;(void)var;(void)delta;(void)width;
# 1486
::exit(___);}
#if 0
# 1482
{ 
# 1483
const __half2 temp1 = __halves2half2(var, var); 
# 1484
const __half2 temp2 = __shfl_xor(temp1, delta, width); 
# 1485
return __low2half(temp2); 
# 1486
} 
#endif
# 1490 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __shfl_sync(const unsigned mask, const __half var, const int delta, const int width) 
# 1491
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1495
::exit(___);}
#if 0
# 1491
{ 
# 1492
const __half2 temp1 = __halves2half2(var, var); 
# 1493
const __half2 temp2 = __shfl_sync(mask, temp1, delta, width); 
# 1494
return __low2half(temp2); 
# 1495
} 
#endif
# 1496 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __shfl_up_sync(const unsigned mask, const __half var, const unsigned delta, const int width) 
# 1497
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1501
::exit(___);}
#if 0
# 1497
{ 
# 1498
const __half2 temp1 = __halves2half2(var, var); 
# 1499
const __half2 temp2 = __shfl_up_sync(mask, temp1, delta, width); 
# 1500
return __low2half(temp2); 
# 1501
} 
#endif
# 1502 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __shfl_down_sync(const unsigned mask, const __half var, const unsigned delta, const int width) 
# 1503
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1507
::exit(___);}
#if 0
# 1503
{ 
# 1504
const __half2 temp1 = __halves2half2(var, var); 
# 1505
const __half2 temp2 = __shfl_down_sync(mask, temp1, delta, width); 
# 1506
return __low2half(temp2); 
# 1507
} 
#endif
# 1508 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __shfl_xor_sync(const unsigned mask, const __half var, const int delta, const int width) 
# 1509
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1513
::exit(___);}
#if 0
# 1509
{ 
# 1510
const __half2 temp1 = __halves2half2(var, var); 
# 1511
const __half2 temp2 = __shfl_xor_sync(mask, temp1, delta, width); 
# 1512
return __low2half(temp2); 
# 1513
} 
#endif
# 1526 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __ldg(const __half2 *const ptr) 
# 1527
{int volatile ___ = 1;(void)ptr;
# 1531
::exit(___);}
#if 0
# 1527
{ 
# 1528
__half2 ret; 
# 1529
__asm__("ld.global.nc.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr)); 
# 1530
return ret; 
# 1531
} 
#endif
# 1532 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ldg(const __half *const ptr) 
# 1533
{int volatile ___ = 1;(void)ptr;
# 1537
::exit(___);}
#if 0
# 1533
{ 
# 1534
__half ret; 
# 1535
__asm__("ld.global.nc.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr)); 
# 1536
return ret; 
# 1537
} 
#endif
# 1538 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __ldcg(const __half2 *const ptr) 
# 1539
{int volatile ___ = 1;(void)ptr;
# 1543
::exit(___);}
#if 0
# 1539
{ 
# 1540
__half2 ret; 
# 1541
__asm__("ld.global.cg.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr)); 
# 1542
return ret; 
# 1543
} 
#endif
# 1544 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ldcg(const __half *const ptr) 
# 1545
{int volatile ___ = 1;(void)ptr;
# 1549
::exit(___);}
#if 0
# 1545
{ 
# 1546
__half ret; 
# 1547
__asm__("ld.global.cg.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr)); 
# 1548
return ret; 
# 1549
} 
#endif
# 1550 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __ldca(const __half2 *const ptr) 
# 1551
{int volatile ___ = 1;(void)ptr;
# 1555
::exit(___);}
#if 0
# 1551
{ 
# 1552
__half2 ret; 
# 1553
__asm__("ld.global.ca.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr)); 
# 1554
return ret; 
# 1555
} 
#endif
# 1556 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ldca(const __half *const ptr) 
# 1557
{int volatile ___ = 1;(void)ptr;
# 1561
::exit(___);}
#if 0
# 1557
{ 
# 1558
__half ret; 
# 1559
__asm__("ld.global.ca.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr)); 
# 1560
return ret; 
# 1561
} 
#endif
# 1562 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __ldcs(const __half2 *const ptr) 
# 1563
{int volatile ___ = 1;(void)ptr;
# 1567
::exit(___);}
#if 0
# 1563
{ 
# 1564
__half2 ret; 
# 1565
__asm__("ld.global.cs.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr)); 
# 1566
return ret; 
# 1567
} 
#endif
# 1568 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ldcs(const __half *const ptr) 
# 1569
{int volatile ___ = 1;(void)ptr;
# 1573
::exit(___);}
#if 0
# 1569
{ 
# 1570
__half ret; 
# 1571
__asm__("ld.global.cs.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr)); 
# 1572
return ret; 
# 1573
} 
#endif
# 1574 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __ldlu(const __half2 *const ptr) 
# 1575
{int volatile ___ = 1;(void)ptr;
# 1579
::exit(___);}
#if 0
# 1575
{ 
# 1576
__half2 ret; 
# 1577
__asm__("ld.global.lu.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr) : "memory"); 
# 1578
return ret; 
# 1579
} 
#endif
# 1580 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ldlu(const __half *const ptr) 
# 1581
{int volatile ___ = 1;(void)ptr;
# 1585
::exit(___);}
#if 0
# 1581
{ 
# 1582
__half ret; 
# 1583
__asm__("ld.global.lu.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr) : "memory"); 
# 1584
return ret; 
# 1585
} 
#endif
# 1586 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __ldcv(const __half2 *const ptr) 
# 1587
{int volatile ___ = 1;(void)ptr;
# 1591
::exit(___);}
#if 0
# 1587
{ 
# 1588
__half2 ret; 
# 1589
__asm__("ld.global.cv.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr) : "memory"); 
# 1590
return ret; 
# 1591
} 
#endif
# 1592 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __ldcv(const __half *const ptr) 
# 1593
{int volatile ___ = 1;(void)ptr;
# 1597
::exit(___);}
#if 0
# 1593
{ 
# 1594
__half ret; 
# 1595
__asm__("ld.global.cv.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr) : "memory"); 
# 1596
return ret; 
# 1597
} 
#endif
# 1598 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline void __stwb(__half2 *const ptr, const __half2 value) 
# 1599
{int volatile ___ = 1;(void)ptr;(void)value;
# 1601
::exit(___);}
#if 0
# 1599
{ 
# 1600
__asm__("st.global.wb.b32 [%0], %1;" : : "l" (ptr), "r" (*(reinterpret_cast< const unsigned *>(&value))) : "memory"); 
# 1601
} 
#endif
# 1602 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline void __stwb(__half *const ptr, const __half value) 
# 1603
{int volatile ___ = 1;(void)ptr;(void)value;
# 1605
::exit(___);}
#if 0
# 1603
{ 
# 1604
__asm__("st.global.wb.b16 [%0], %1;" : : "l" (ptr), "h" (*(reinterpret_cast< const unsigned short *>(&value))) : "memory"); 
# 1605
} 
#endif
# 1606 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline void __stcg(__half2 *const ptr, const __half2 value) 
# 1607
{int volatile ___ = 1;(void)ptr;(void)value;
# 1609
::exit(___);}
#if 0
# 1607
{ 
# 1608
__asm__("st.global.cg.b32 [%0], %1;" : : "l" (ptr), "r" (*(reinterpret_cast< const unsigned *>(&value))) : "memory"); 
# 1609
} 
#endif
# 1610 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline void __stcg(__half *const ptr, const __half value) 
# 1611
{int volatile ___ = 1;(void)ptr;(void)value;
# 1613
::exit(___);}
#if 0
# 1611
{ 
# 1612
__asm__("st.global.cg.b16 [%0], %1;" : : "l" (ptr), "h" (*(reinterpret_cast< const unsigned short *>(&value))) : "memory"); 
# 1613
} 
#endif
# 1614 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline void __stcs(__half2 *const ptr, const __half2 value) 
# 1615
{int volatile ___ = 1;(void)ptr;(void)value;
# 1617
::exit(___);}
#if 0
# 1615
{ 
# 1616
__asm__("st.global.cs.b32 [%0], %1;" : : "l" (ptr), "r" (*(reinterpret_cast< const unsigned *>(&value))) : "memory"); 
# 1617
} 
#endif
# 1618 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline void __stcs(__half *const ptr, const __half value) 
# 1619
{int volatile ___ = 1;(void)ptr;(void)value;
# 1621
::exit(___);}
#if 0
# 1619
{ 
# 1620
__asm__("st.global.cs.b16 [%0], %1;" : : "l" (ptr), "h" (*(reinterpret_cast< const unsigned short *>(&value))) : "memory"); 
# 1621
} 
#endif
# 1622 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline void __stwt(__half2 *const ptr, const __half2 value) 
# 1623
{int volatile ___ = 1;(void)ptr;(void)value;
# 1625
::exit(___);}
#if 0
# 1623
{ 
# 1624
__asm__("st.global.wt.b32 [%0], %1;" : : "l" (ptr), "r" (*(reinterpret_cast< const unsigned *>(&value))) : "memory"); 
# 1625
} 
#endif
# 1626 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline void __stwt(__half *const ptr, const __half value) 
# 1627
{int volatile ___ = 1;(void)ptr;(void)value;
# 1629
::exit(___);}
#if 0
# 1627
{ 
# 1628
__asm__("st.global.wt.b16 [%0], %1;" : : "l" (ptr), "h" (*(reinterpret_cast< const unsigned short *>(&value))) : "memory"); 
# 1629
} 
#endif
# 1642 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __heq2(const __half2 a, const __half2 b) 
# 1643
{int volatile ___ = 1;(void)a;(void)b;
# 1645
::exit(___);}
#if 0
# 1643
{ 
# 1644
{ __half2 val; __asm__("{ set.eq.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1645
} 
#endif
# 1646 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hne2(const __half2 a, const __half2 b) 
# 1647
{int volatile ___ = 1;(void)a;(void)b;
# 1649
::exit(___);}
#if 0
# 1647
{ 
# 1648
{ __half2 val; __asm__("{ set.ne.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1649
} 
#endif
# 1650 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hle2(const __half2 a, const __half2 b) 
# 1651
{int volatile ___ = 1;(void)a;(void)b;
# 1653
::exit(___);}
#if 0
# 1651
{ 
# 1652
{ __half2 val; __asm__("{ set.le.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1653
} 
#endif
# 1654 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hge2(const __half2 a, const __half2 b) 
# 1655
{int volatile ___ = 1;(void)a;(void)b;
# 1657
::exit(___);}
#if 0
# 1655
{ 
# 1656
{ __half2 val; __asm__("{ set.ge.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1657
} 
#endif
# 1658 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hlt2(const __half2 a, const __half2 b) 
# 1659
{int volatile ___ = 1;(void)a;(void)b;
# 1661
::exit(___);}
#if 0
# 1659
{ 
# 1660
{ __half2 val; __asm__("{ set.lt.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1661
} 
#endif
# 1662 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hgt2(const __half2 a, const __half2 b) 
# 1663
{int volatile ___ = 1;(void)a;(void)b;
# 1665
::exit(___);}
#if 0
# 1663
{ 
# 1664
{ __half2 val; __asm__("{ set.gt.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1665
} 
#endif
# 1666 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hequ2(const __half2 a, const __half2 b) 
# 1667
{int volatile ___ = 1;(void)a;(void)b;
# 1669
::exit(___);}
#if 0
# 1667
{ 
# 1668
{ __half2 val; __asm__("{ set.equ.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1669
} 
#endif
# 1670 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hneu2(const __half2 a, const __half2 b) 
# 1671
{int volatile ___ = 1;(void)a;(void)b;
# 1673
::exit(___);}
#if 0
# 1671
{ 
# 1672
{ __half2 val; __asm__("{ set.neu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1673
} 
#endif
# 1674 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hleu2(const __half2 a, const __half2 b) 
# 1675
{int volatile ___ = 1;(void)a;(void)b;
# 1677
::exit(___);}
#if 0
# 1675
{ 
# 1676
{ __half2 val; __asm__("{ set.leu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1677
} 
#endif
# 1678 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hgeu2(const __half2 a, const __half2 b) 
# 1679
{int volatile ___ = 1;(void)a;(void)b;
# 1681
::exit(___);}
#if 0
# 1679
{ 
# 1680
{ __half2 val; __asm__("{ set.geu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1681
} 
#endif
# 1682 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hltu2(const __half2 a, const __half2 b) 
# 1683
{int volatile ___ = 1;(void)a;(void)b;
# 1685
::exit(___);}
#if 0
# 1683
{ 
# 1684
{ __half2 val; __asm__("{ set.ltu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1685
} 
#endif
# 1686 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hgtu2(const __half2 a, const __half2 b) 
# 1687
{int volatile ___ = 1;(void)a;(void)b;
# 1689
::exit(___);}
#if 0
# 1687
{ 
# 1688
{ __half2 val; __asm__("{ set.gtu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1689
} 
#endif
# 1703 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbeq2(const __half2 a, const __half2 b) 
# 1704
{int volatile ___ = 1;(void)a;(void)b;
# 1706
::exit(___);}
#if 0
# 1704
{ 
# 1705
{ __half2 val; bool retval; __asm__("{ set.eq.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1706
} 
#endif
# 1707 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbne2(const __half2 a, const __half2 b) 
# 1708
{int volatile ___ = 1;(void)a;(void)b;
# 1710
::exit(___);}
#if 0
# 1708
{ 
# 1709
{ __half2 val; bool retval; __asm__("{ set.ne.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1710
} 
#endif
# 1711 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hble2(const __half2 a, const __half2 b) 
# 1712
{int volatile ___ = 1;(void)a;(void)b;
# 1714
::exit(___);}
#if 0
# 1712
{ 
# 1713
{ __half2 val; bool retval; __asm__("{ set.le.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1714
} 
#endif
# 1715 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbge2(const __half2 a, const __half2 b) 
# 1716
{int volatile ___ = 1;(void)a;(void)b;
# 1718
::exit(___);}
#if 0
# 1716
{ 
# 1717
{ __half2 val; bool retval; __asm__("{ set.ge.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1718
} 
#endif
# 1719 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hblt2(const __half2 a, const __half2 b) 
# 1720
{int volatile ___ = 1;(void)a;(void)b;
# 1722
::exit(___);}
#if 0
# 1720
{ 
# 1721
{ __half2 val; bool retval; __asm__("{ set.lt.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1722
} 
#endif
# 1723 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbgt2(const __half2 a, const __half2 b) 
# 1724
{int volatile ___ = 1;(void)a;(void)b;
# 1726
::exit(___);}
#if 0
# 1724
{ 
# 1725
{ __half2 val; bool retval; __asm__("{ set.gt.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1726
} 
#endif
# 1727 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbequ2(const __half2 a, const __half2 b) 
# 1728
{int volatile ___ = 1;(void)a;(void)b;
# 1730
::exit(___);}
#if 0
# 1728
{ 
# 1729
{ __half2 val; bool retval; __asm__("{ set.equ.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1730
} 
#endif
# 1731 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbneu2(const __half2 a, const __half2 b) 
# 1732
{int volatile ___ = 1;(void)a;(void)b;
# 1734
::exit(___);}
#if 0
# 1732
{ 
# 1733
{ __half2 val; bool retval; __asm__("{ set.neu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1734
} 
#endif
# 1735 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbleu2(const __half2 a, const __half2 b) 
# 1736
{int volatile ___ = 1;(void)a;(void)b;
# 1738
::exit(___);}
#if 0
# 1736
{ 
# 1737
{ __half2 val; bool retval; __asm__("{ set.leu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1738
} 
#endif
# 1739 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbgeu2(const __half2 a, const __half2 b) 
# 1740
{int volatile ___ = 1;(void)a;(void)b;
# 1742
::exit(___);}
#if 0
# 1740
{ 
# 1741
{ __half2 val; bool retval; __asm__("{ set.geu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1742
} 
#endif
# 1743 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbltu2(const __half2 a, const __half2 b) 
# 1744
{int volatile ___ = 1;(void)a;(void)b;
# 1746
::exit(___);}
#if 0
# 1744
{ 
# 1745
{ __half2 val; bool retval; __asm__("{ set.ltu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1746
} 
#endif
# 1747 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hbgtu2(const __half2 a, const __half2 b) 
# 1748
{int volatile ___ = 1;(void)a;(void)b;
# 1750
::exit(___);}
#if 0
# 1748
{ 
# 1749
{ __half2 val; bool retval; __asm__("{ set.gtu.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); if ((*(reinterpret_cast< const unsigned *>(&val))) == 1006648320U) { retval = true; } else { retval = false; }  return retval; } 
# 1750
} 
#endif
# 1763 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __heq(const __half a, const __half b) 
# 1764
{int volatile ___ = 1;(void)a;(void)b;
# 1766
::exit(___);}
#if 0
# 1764
{ 
# 1765
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.eq.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1766
} 
#endif
# 1767 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hne(const __half a, const __half b) 
# 1768
{int volatile ___ = 1;(void)a;(void)b;
# 1770
::exit(___);}
#if 0
# 1768
{ 
# 1769
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.ne.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1770
} 
#endif
# 1771 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hle(const __half a, const __half b) 
# 1772
{int volatile ___ = 1;(void)a;(void)b;
# 1774
::exit(___);}
#if 0
# 1772
{ 
# 1773
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.le.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1774
} 
#endif
# 1775 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hge(const __half a, const __half b) 
# 1776
{int volatile ___ = 1;(void)a;(void)b;
# 1778
::exit(___);}
#if 0
# 1776
{ 
# 1777
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.ge.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1778
} 
#endif
# 1779 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hlt(const __half a, const __half b) 
# 1780
{int volatile ___ = 1;(void)a;(void)b;
# 1782
::exit(___);}
#if 0
# 1780
{ 
# 1781
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.lt.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1782
} 
#endif
# 1783 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hgt(const __half a, const __half b) 
# 1784
{int volatile ___ = 1;(void)a;(void)b;
# 1786
::exit(___);}
#if 0
# 1784
{ 
# 1785
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.gt.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1786
} 
#endif
# 1787 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hequ(const __half a, const __half b) 
# 1788
{int volatile ___ = 1;(void)a;(void)b;
# 1790
::exit(___);}
#if 0
# 1788
{ 
# 1789
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.equ.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1790
} 
#endif
# 1791 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hneu(const __half a, const __half b) 
# 1792
{int volatile ___ = 1;(void)a;(void)b;
# 1794
::exit(___);}
#if 0
# 1792
{ 
# 1793
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.neu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1794
} 
#endif
# 1795 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hleu(const __half a, const __half b) 
# 1796
{int volatile ___ = 1;(void)a;(void)b;
# 1798
::exit(___);}
#if 0
# 1796
{ 
# 1797
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.leu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1798
} 
#endif
# 1799 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hgeu(const __half a, const __half b) 
# 1800
{int volatile ___ = 1;(void)a;(void)b;
# 1802
::exit(___);}
#if 0
# 1800
{ 
# 1801
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.geu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1802
} 
#endif
# 1803 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hltu(const __half a, const __half b) 
# 1804
{int volatile ___ = 1;(void)a;(void)b;
# 1806
::exit(___);}
#if 0
# 1804
{ 
# 1805
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.ltu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1806
} 
#endif
# 1807 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hgtu(const __half a, const __half b) 
# 1808
{int volatile ___ = 1;(void)a;(void)b;
# 1810
::exit(___);}
#if 0
# 1808
{ 
# 1809
{ unsigned short val; __asm__("{ .reg .pred __$temp3;\n  setp.gtu.f16  __$temp3, %1, %2;\n  selp.u16 %0, 1, 0, __$temp3;}" : "=h" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1810
} 
#endif
# 1815 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hadd2(const __half2 a, const __half2 b) 
# 1816
{int volatile ___ = 1;(void)a;(void)b;
# 1818
::exit(___);}
#if 0
# 1816
{ 
# 1817
{ __half2 val; __asm__("{add.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1818
} 
#endif
# 1819 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hsub2(const __half2 a, const __half2 b) 
# 1820
{int volatile ___ = 1;(void)a;(void)b;
# 1822
::exit(___);}
#if 0
# 1820
{ 
# 1821
{ __half2 val; __asm__("{sub.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1822
} 
#endif
# 1823 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hmul2(const __half2 a, const __half2 b) 
# 1824
{int volatile ___ = 1;(void)a;(void)b;
# 1826
::exit(___);}
#if 0
# 1824
{ 
# 1825
{ __half2 val; __asm__("{mul.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1826
} 
#endif
# 1827 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hadd2_sat(const __half2 a, const __half2 b) 
# 1828
{int volatile ___ = 1;(void)a;(void)b;
# 1830
::exit(___);}
#if 0
# 1828
{ 
# 1829
{ __half2 val; __asm__("{add.sat.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1830
} 
#endif
# 1831 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hsub2_sat(const __half2 a, const __half2 b) 
# 1832
{int volatile ___ = 1;(void)a;(void)b;
# 1834
::exit(___);}
#if 0
# 1832
{ 
# 1833
{ __half2 val; __asm__("{sub.sat.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1834
} 
#endif
# 1835 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hmul2_sat(const __half2 a, const __half2 b) 
# 1836
{int volatile ___ = 1;(void)a;(void)b;
# 1838
::exit(___);}
#if 0
# 1836
{ 
# 1837
{ __half2 val; __asm__("{mul.sat.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1838
} 
#endif
# 1839 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hadd2_rn(const __half2 a, const __half2 b) 
# 1840
{int volatile ___ = 1;(void)a;(void)b;
# 1842
::exit(___);}
#if 0
# 1840
{ 
# 1841
{ __half2 val; __asm__("{add.rn.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1842
} 
#endif
# 1843 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hsub2_rn(const __half2 a, const __half2 b) 
# 1844
{int volatile ___ = 1;(void)a;(void)b;
# 1846
::exit(___);}
#if 0
# 1844
{ 
# 1845
{ __half2 val; __asm__("{sub.rn.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1846
} 
#endif
# 1847 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hmul2_rn(const __half2 a, const __half2 b) 
# 1848
{int volatile ___ = 1;(void)a;(void)b;
# 1850
::exit(___);}
#if 0
# 1848
{ 
# 1849
{ __half2 val; __asm__("{mul.rn.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1850
} 
#endif
# 1851 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hfma2(const __half2 a, const __half2 b, const __half2 c) 
# 1852
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 1854
::exit(___);}
#if 0
# 1852
{ 
# 1853
{ __half2 val; __asm__("{fma.rn.f16x2 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b))), "r" (*(reinterpret_cast< const unsigned *>(&c)))); return val; } 
# 1854
} 
#endif
# 1855 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hfma2_sat(const __half2 a, const __half2 b, const __half2 c) 
# 1856
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 1858
::exit(___);}
#if 0
# 1856
{ 
# 1857
{ __half2 val; __asm__("{fma.rn.sat.f16x2 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b))), "r" (*(reinterpret_cast< const unsigned *>(&c)))); return val; } 
# 1858
} 
#endif
# 1859 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __h2div(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;
# 1871
::exit(___);}
#if 0
# 1859
{ 
# 1860
__half ha = __low2half(a); 
# 1861
__half hb = __low2half(b); 
# 1863
const __half v1 = __hdiv(ha, hb); 
# 1865
ha = __high2half(a); 
# 1866
hb = __high2half(b); 
# 1868
const __half v2 = __hdiv(ha, hb); 
# 1870
return __halves2half2(v1, v2); 
# 1871
} 
#endif
# 1875 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hadd(const __half a, const __half b) 
# 1876
{int volatile ___ = 1;(void)a;(void)b;
# 1878
::exit(___);}
#if 0
# 1876
{ 
# 1877
{ __half val; __asm__("{add.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1878
} 
#endif
# 1879 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hsub(const __half a, const __half b) 
# 1880
{int volatile ___ = 1;(void)a;(void)b;
# 1882
::exit(___);}
#if 0
# 1880
{ 
# 1881
{ __half val; __asm__("{sub.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1882
} 
#endif
# 1883 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hmul(const __half a, const __half b) 
# 1884
{int volatile ___ = 1;(void)a;(void)b;
# 1886
::exit(___);}
#if 0
# 1884
{ 
# 1885
{ __half val; __asm__("{mul.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1886
} 
#endif
# 1887 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hadd_sat(const __half a, const __half b) 
# 1888
{int volatile ___ = 1;(void)a;(void)b;
# 1890
::exit(___);}
#if 0
# 1888
{ 
# 1889
{ __half val; __asm__("{add.sat.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1890
} 
#endif
# 1891 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hsub_sat(const __half a, const __half b) 
# 1892
{int volatile ___ = 1;(void)a;(void)b;
# 1894
::exit(___);}
#if 0
# 1892
{ 
# 1893
{ __half val; __asm__("{sub.sat.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1894
} 
#endif
# 1895 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hmul_sat(const __half a, const __half b) 
# 1896
{int volatile ___ = 1;(void)a;(void)b;
# 1898
::exit(___);}
#if 0
# 1896
{ 
# 1897
{ __half val; __asm__("{mul.sat.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1898
} 
#endif
# 1899 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hadd_rn(const __half a, const __half b) 
# 1900
{int volatile ___ = 1;(void)a;(void)b;
# 1902
::exit(___);}
#if 0
# 1900
{ 
# 1901
{ __half val; __asm__("{add.rn.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1902
} 
#endif
# 1903 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hsub_rn(const __half a, const __half b) 
# 1904
{int volatile ___ = 1;(void)a;(void)b;
# 1906
::exit(___);}
#if 0
# 1904
{ 
# 1905
{ __half val; __asm__("{sub.rn.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1906
} 
#endif
# 1907 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hmul_rn(const __half a, const __half b) 
# 1908
{int volatile ___ = 1;(void)a;(void)b;
# 1910
::exit(___);}
#if 0
# 1908
{ 
# 1909
{ __half val; __asm__("{mul.rn.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1910
} 
#endif
# 1911 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hfma(const __half a, const __half b, const __half c) 
# 1912
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 1914
::exit(___);}
#if 0
# 1912
{ 
# 1913
{ __half val; __asm__("{fma.rn.f16 %0,%1,%2,%3;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b))), "h" (*(reinterpret_cast< const unsigned short *>(&c)))); return val; } 
# 1914
} 
#endif
# 1915 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hfma_sat(const __half a, const __half b, const __half c) 
# 1916
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 1918
::exit(___);}
#if 0
# 1916
{ 
# 1917
{ __half val; __asm__("{fma.rn.sat.f16 %0,%1,%2,%3;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b))), "h" (*(reinterpret_cast< const unsigned short *>(&c)))); return val; } 
# 1918
} 
#endif
# 1919 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hdiv(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;
# 1941
::exit(___);}
#if 0
# 1919
{ 
# 1920
__half v; 
# 1921
__half abs; 
# 1922
__half den; 
# 1923
(*(reinterpret_cast< unsigned short *>(&den))) = (143U); 
# 1925
float rcp; 
# 1926
const float fa = __half2float(a); 
# 1927
const float fb = __half2float(b); 
# 1929
__asm__("{rcp.approx.ftz.f32 %0, %1;\n}" : "=f" (rcp) : "f" (fb)); 
# 1931
float fv = rcp * fa; 
# 1933
v = __float2half(fv); 
# 1934
(*(reinterpret_cast< unsigned short *>(&abs))) = (static_cast< unsigned short>((static_cast< unsigned>(*(reinterpret_cast< const unsigned short *>(&v)))) & 32767U)); 
# 1935
if (__hlt(abs, den) && (!((*(reinterpret_cast< const unsigned short *>(&abs))) == 0U))) { 
# 1936
const float err = __fmaf_rn(-fb, fv, fa); 
# 1937
fv = __fmaf_rn(rcp, err, fv); 
# 1938
v = __float2half(fv); 
# 1939
}  
# 1940
return v; 
# 1941
} 
#endif
# 1985 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) static inline float __float_simpl_sinf(float a); 
# 1986
__attribute((always_inline)) __attribute__((unused)) static inline float __float_simpl_cosf(float a); 
# 1987
__attribute__((unused)) static inline __half hsin(const __half a) {int volatile ___ = 1;(void)a;
# 2003
::exit(___);}
#if 0
# 1987
{ 
# 1988
const float sl = __float_simpl_sinf(__half2float(a)); 
# 1989
__half r = __float2half_rn(sl); 
# 1990
__asm__("{\n\t  .reg.b16 i,r,t;     \n\t  mov.b16 r, %0;      \n\t  mov.b16 i, %1;      \n\t  and.b16 t, r, 0x8000U; \n\t  abs.f16 r, r; " "  \n\t  abs.f16 i, i;   \n\t{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X32B3U;\n  mov.b16 ulp,0x0800U;\n  set.eq.f16.f16 p,i, spc;\n" "  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X5CB0U;\n  mov.b16 ulp,0x9000U;\n  set.eq.f16.f16 p,i, spc;\n" "  fma.rn.f16 r,p,ulp,r;\n}\n  or.b16  r,r,t;      \n\t  mov.b16 %0, r;      \n}\n" : "+h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2002
return r; 
# 2003
} 
#endif
# 2004 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2sin(const __half2 a) {int volatile ___ = 1;(void)a;
# 2021
::exit(___);}
#if 0
# 2004
{ 
# 2005
const float sl = __float_simpl_sinf(__half2float(a.x)); 
# 2006
const float sh = __float_simpl_sinf(__half2float(a.y)); 
# 2007
__half2 r = __floats2half2_rn(sl, sh); 
# 2008
__asm__("{\n\t  .reg.b32 i,r,t;             \n\t  mov.b32 r, %0;              \n\t  mov.b32 i, %1;              \n\t  and.b32 t, r, 0x800" "08000U;   \n\t  abs.f16x2 r, r;   \n\t  abs.f16x2 i, i;   \n\t{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X32B332B3U;\n  mov.b32 ulp," "0x08000800U;\n  set.eq.f16x2.f16x2 p,i, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X5CB05CB0U;\n" "  mov.b32 ulp,0x90009000U;\n  set.eq.f16x2.f16x2 p,i, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  or.b32  r, r, t;            \n\t  mo" "v.b32 %0, r;              \n}\n" : "+r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2020
return r; 
# 2021
} 
#endif
# 2022 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hcos(const __half a) {int volatile ___ = 1;(void)a;
# 2034
::exit(___);}
#if 0
# 2022
{ 
# 2023
const float cl = __float_simpl_cosf(__half2float(a)); 
# 2024
__half r = __float2half_rn(cl); 
# 2025
__asm__("{\n\t  .reg.b16 i,r;        \n\t  mov.b16 r, %0;       \n\t  mov.b16 i, %1;       \n\t  abs.f16 i, i;        \n\t{.reg.b16 spc, " "ulp, p;\n  mov.b16 spc,0X2B7CU;\n  mov.b16 ulp,0x1000U;\n  set.eq.f16.f16 p,i, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n  mov.b16 %0, r" ";       \n}\n" : "+h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2033
return r; 
# 2034
} 
#endif
# 2035 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2cos(const __half2 a) {int volatile ___ = 1;(void)a;
# 2048
::exit(___);}
#if 0
# 2035
{ 
# 2036
const float cl = __float_simpl_cosf(__half2float(a.x)); 
# 2037
const float ch = __float_simpl_cosf(__half2float(a.y)); 
# 2038
__half2 r = __floats2half2_rn(cl, ch); 
# 2039
__asm__("{\n\t  .reg.b32 i,r;   \n\t  mov.b32 r, %0;  \n\t  mov.b32 i, %1;  \n\t  abs.f16x2 i, i; \n\t{.reg.b32 spc, ulp, p;\n  mov.b32 s" "pc,0X2B7C2B7CU;\n  mov.b32 ulp,0x10001000U;\n  set.eq.f16x2.f16x2 p,i, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32 %0, r;  \n}" "\n" : "+r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2047
return r; 
# 2048
} 
#endif
# 2049 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) static inline float __internal_trig_reduction_kernel(const float a, unsigned *const quadrant) 
# 2050
{int volatile ___ = 1;(void)a;(void)quadrant;
# 2058
::exit(___);}
#if 0
# 2050
{ 
# 2051
const float ar = __fmaf_rn(a, (0.63661975F), (1.2582912E7F)); 
# 2052
const unsigned q = __float_as_uint(ar); 
# 2053
const float j = __fsub_rn(ar, (1.2582912E7F)); 
# 2054
float t = __fmaf_rn(j, -(1.5707963F), a); 
# 2055
t = __fmaf_rn(j, -(7.5497894E-8F), t); 
# 2056
(*quadrant) = q; 
# 2057
return t; 
# 2058
} 
#endif
# 2059 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) static inline float __internal_sin_cos_kernel(const float x, const unsigned i) 
# 2060
{int volatile ___ = 1;(void)x;(void)i;
# 2098
::exit(___);}
#if 0
# 2060
{ 
# 2061
float z; 
# 2062
const float x2 = x * x; 
# 2063
float a8; 
# 2064
float a6; 
# 2065
float a4; 
# 2066
float a2; 
# 2067
float a1; 
# 2068
float a0; 
# 2070
if ((i & 1U) != 0U) { 
# 2072
a8 = (2.4433157E-5F); 
# 2073
a6 = (-(0.0013887316F)); 
# 2074
a4 = (0.041666646F); 
# 2075
a2 = (-(0.5F)); 
# 2076
a1 = x2; 
# 2077
a0 = (1.0F); 
# 2078
} else 
# 2079
{ 
# 2081
a8 = (-(1.9515296E-4F)); 
# 2082
a6 = (0.008332161F); 
# 2083
a4 = (-(0.16666655F)); 
# 2084
a2 = (0.0F); 
# 2085
a1 = x; 
# 2086
a0 = x; 
# 2087
}  
# 2089
z = __fmaf_rn(a8, x2, a6); 
# 2090
z = __fmaf_rn(z, x2, a4); 
# 2091
z = __fmaf_rn(z, x2, a2); 
# 2092
z = __fmaf_rn(z, a1, a0); 
# 2094
if ((i & 2U) != 0U) { 
# 2095
z = (-z); 
# 2096
}  
# 2097
return z; 
# 2098
} 
#endif
# 2099 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) static inline float __float_simpl_sinf(float a) 
# 2100
{int volatile ___ = 1;(void)a;
# 2106
::exit(___);}
#if 0
# 2100
{ 
# 2101
float z; 
# 2102
unsigned i; 
# 2103
a = __internal_trig_reduction_kernel(a, &i); 
# 2104
z = __internal_sin_cos_kernel(a, i); 
# 2105
return z; 
# 2106
} 
#endif
# 2107 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute((always_inline)) __attribute__((unused)) static inline float __float_simpl_cosf(float a) 
# 2108
{int volatile ___ = 1;(void)a;
# 2114
::exit(___);}
#if 0
# 2108
{ 
# 2109
float z; 
# 2110
unsigned i; 
# 2111
a = __internal_trig_reduction_kernel(a, &i); 
# 2112
z = __internal_sin_cos_kernel(a, (i & 3U) + 1U); 
# 2113
return z; 
# 2114
} 
#endif
# 2116 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hexp(const __half a) {int volatile ___ = 1;(void)a;
# 2134
::exit(___);}
#if 0
# 2116
{ 
# 2117
__half val; 
# 2118
__asm__("{.reg.b32         f, C, nZ;       \n .reg.b16         h,r;            \n  mov.b16         h,%1;           \n  cvt.f32.f16     f," "h;            \n  mov.b32         C, 0x3fb8aa3bU; \n  mov.b32         nZ, 0x80000000U;\n  fma.rn.f32      f,f,C,nZ;       \n  ex" "2.approx.ftz.f32  f,f;        \n  cvt.rn.f16.f32      r,f;        \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X1F79U;\n  mov.b16 ul" "p,0x9400U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X25CFU;\n  mov.b16 ul" "p,0x9400U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0XC13BU;\n  mov.b16 ul" "p,0x0400U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0XC1EFU;\n  mov.b16 ul" "p,0x0200U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0,r;           \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2133
return val; 
# 2134
} 
#endif
# 2135 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2exp(const __half2 a) {int volatile ___ = 1;(void)a;
# 2159
::exit(___);}
#if 0
# 2135
{ 
# 2136
__half2 val; 
# 2137
__asm__("{.reg.b16         hl, hu;         \n .reg.b32         h,r,fl,fu,C,nZ; \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         h," " %1;          \n  cvt.f32.f16     fl, hl;         \n  cvt.f32.f16     fu, hu;         \n  mov.b32         C, 0x3fb8aa3bU; \n  mo" "v.b32         nZ, 0x80000000U;\n  fma.rn.f32      fl,fl,C,nZ;     \n  fma.rn.f32      fu,fu,C,nZ;     \n  ex2.approx.ftz.f32  fl" ", fl;     \n  ex2.approx.ftz.f32  fu, fu;     \n  cvt.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b3" "2         r, {hl, hu};    \n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X1F791F79U;\n  mov.b32 ulp,0x94009400U;\n  set.eq.f16x2.f16x2" " p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X25CF25CFU;\n  mov.b32 ulp,0x94009400U;\n  set." "eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0XC13BC13BU;\n  mov.b32 ulp,0x0400" "0400U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0XC1EFC1EFU;\n  mov." "b32 ulp,0x02000200U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;  \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2158
return val; 
# 2159
} 
#endif
# 2160 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hexp2(const __half a) {int volatile ___ = 1;(void)a;
# 2173
::exit(___);}
#if 0
# 2160
{ 
# 2161
__half val; 
# 2162
__asm__("{.reg.b32         f, ULP;         \n .reg.b16         r;              \n  mov.b16         r,%1;           \n  cvt.f32.f16     f," "r;            \n  ex2.approx.ftz.f32      f,f;    \n  mov.b32         ULP, 0x33800000U;\n  fma.rn.f32      f,f,ULP,f;      \n  c" "vt.rn.f16.f32      r,f;        \n  mov.b16         %0,r;           \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2172
return val; 
# 2173
} 
#endif
# 2174 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2exp2(const __half2 a) {int volatile ___ = 1;(void)a;
# 2191
::exit(___);}
#if 0
# 2174
{ 
# 2175
__half2 val; 
# 2176
__asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu, ULP;    \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  ex2.approx.ftz.f32  fl, fl;     \n  ex2.approx.ftz.f32  fu, fu;     \n  mo" "v.b32         ULP, 0x33800000U;\n  fma.rn.f32      fl,fl,ULP,fl;   \n  fma.rn.f32      fu,fu,ULP,fu;   \n  cvt.rn.f16.f32      h" "l, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2190
return val; 
# 2191
} 
#endif
# 2192 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hexp10(const __half a) {int volatile ___ = 1;(void)a;
# 2211
::exit(___);}
#if 0
# 2192
{ 
# 2193
__half val; 
# 2194
__asm__("{.reg.b16         h,r;            \n .reg.b32         f, C, nZ;       \n  mov.b16         h, %1;          \n  cvt.f32.f16     f," " h;           \n  mov.b32         C, 0x40549A78U; \n  mov.b32         nZ, 0x80000000U;\n  fma.rn.f32      f,f,C,nZ;       \n  ex" "2.approx.ftz.f32  f, f;       \n  cvt.rn.f16.f32      r, f;       \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x34DEU;\n  mov.b16 ul" "p,0x9800U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x9766U;\n  mov.b16 ul" "p,0x9000U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x9972U;\n  mov.b16 ul" "p,0x1000U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0xA5C4U;\n  mov.b16 ul" "p,0x1000U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0xBF0AU;\n  mov.b16 ul" "p,0x8100U;\n  set.eq.f16.f16 p,h, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0, r;          \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2210
return val; 
# 2211
} 
#endif
# 2212 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2exp10(const __half2 a) {int volatile ___ = 1;(void)a;
# 2237
::exit(___);}
#if 0
# 2212
{ 
# 2213
__half2 val; 
# 2214
__asm__("{.reg.b16         hl, hu;         \n .reg.b32         h,r,fl,fu,C,nZ; \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         h," " %1;          \n  cvt.f32.f16     fl, hl;         \n  cvt.f32.f16     fu, hu;         \n  mov.b32         C, 0x40549A78U; \n  mo" "v.b32         nZ, 0x80000000U;\n  fma.rn.f32      fl,fl,C,nZ;     \n  fma.rn.f32      fu,fu,C,nZ;     \n  ex2.approx.ftz.f32  fl" ", fl;     \n  ex2.approx.ftz.f32  fu, fu;     \n  cvt.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b3" "2         r, {hl, hu};    \n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x34DE34DEU;\n  mov.b32 ulp,0x98009800U;\n  set.eq.f16x2.f16x2" " p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x97669766U;\n  mov.b32 ulp,0x90009000U;\n  set." "eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x99729972U;\n  mov.b32 ulp,0x1000" "1000U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0xA5C4A5C4U;\n  mov." "b32 ulp,0x10001000U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0xBF0A" "BF0AU;\n  mov.b32 ulp,0x81008100U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;  \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2236
return val; 
# 2237
} 
#endif
# 2238 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hlog2(const __half a) {int volatile ___ = 1;(void)a;
# 2251
::exit(___);}
#if 0
# 2238
{ 
# 2239
__half val; 
# 2240
__asm__("{.reg.b16         h, r;           \n .reg.b32         f;              \n  mov.b16         h, %1;          \n  cvt.f32.f16     f," " h;           \n  lg2.approx.ftz.f32  f, f;       \n  cvt.rn.f16.f32      r, f;       \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x" "A2E2U;\n  mov.b16 ulp,0x8080U;\n  set.eq.f16.f16 p,r, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x" "BF46U;\n  mov.b16 ulp,0x9400U;\n  set.eq.f16.f16 p,r, spc;\n  fma.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0, r;          \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2250
return val; 
# 2251
} 
#endif
# 2252 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2log2(const __half2 a) {int volatile ___ = 1;(void)a;
# 2269
::exit(___);}
#if 0
# 2252
{ 
# 2253
__half2 val; 
# 2254
__asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu, r, p;   \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  lg2.approx.ftz.f32  fl, fl;     \n  lg2.approx.ftz.f32  fu, fu;     \n  cv" "t.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         r, {hl, hu};    \n{.reg.b32 spc, ulp, p;\n" "  mov.b32 spc,0xA2E2A2E2U;\n  mov.b32 ulp,0x80808080U;\n  set.eq.f16x2.f16x2 p,r, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 " "spc, ulp, p;\n  mov.b32 spc,0xBF46BF46U;\n  mov.b32 ulp,0x94009400U;\n  set.eq.f16x2.f16x2 p,r, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n" "}\n  mov.b32         %0, r;          \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2268
return val; 
# 2269
} 
#endif
# 2270 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hlog(const __half a) {int volatile ___ = 1;(void)a;
# 2287
::exit(___);}
#if 0
# 2270
{ 
# 2271
__half val; 
# 2272
__asm__("{.reg.b32         f, C;           \n .reg.b16         r,h;            \n  mov.b16         h,%1;           \n  cvt.f32.f16     f," "h;            \n  lg2.approx.ftz.f32  f,f;        \n  mov.b32         C, 0x3f317218U;  \n  mul.f32         f,f,C;          \n  c" "vt.rn.f16.f32      r,f;        \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X160DU;\n  mov.b16 ulp,0x9C00U;\n  set.eq.f16.f16 p,h, s" "pc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X3BFEU;\n  mov.b16 ulp,0x8010U;\n  set.eq.f16.f16 p,h, s" "pc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X3C0BU;\n  mov.b16 ulp,0x8080U;\n  set.eq.f16.f16 p,h, s" "pc;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0X6051U;\n  mov.b16 ulp,0x1C00U;\n  set.eq.f16.f16 p,h, s" "pc;\n  fma.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0,r;           \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2286
return val; 
# 2287
} 
#endif
# 2288 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2log(const __half2 a) {int volatile ___ = 1;(void)a;
# 2311
::exit(___);}
#if 0
# 2288
{ 
# 2289
__half2 val; 
# 2290
__asm__("{.reg.b16         hl, hu;             \n .reg.b32         r, fl, fu, C, h;    \n  mov.b32         {hl, hu}, %1;       \n  mov.b3" "2         h, %1;              \n  cvt.f32.f16     fl, hl;             \n  cvt.f32.f16     fu, hu;             \n  lg2.approx.ftz" ".f32  fl, fl;         \n  lg2.approx.ftz.f32  fu, fu;         \n  mov.b32         C, 0x3f317218U;     \n  mul.f32         fl,fl," "C;            \n  mul.f32         fu,fu,C;            \n  cvt.rn.f16.f32      hl, fl;         \n  cvt.rn.f16.f32      hu, fu;   " "      \n  mov.b32         r, {hl, hu};        \n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X160D160DU;\n  mov.b32 ulp,0x9C009C00U;\n" "  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X3BFE3BFEU;\n  mov.b32 ulp," "0x80108010U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0X3C0B3C0BU;\n" "  mov.b32 ulp,0x80808080U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc," "0X60516051U;\n  mov.b32 ulp,0x1C001C00U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;" "              \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2310
return val; 
# 2311
} 
#endif
# 2312 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hlog10(const __half a) {int volatile ___ = 1;(void)a;
# 2329
::exit(___);}
#if 0
# 2312
{ 
# 2313
__half val; 
# 2314
__asm__("{.reg.b16         h, r;           \n .reg.b32         f, C;           \n  mov.b16         h, %1;          \n  cvt.f32.f16     f," " h;           \n  lg2.approx.ftz.f32  f, f;       \n  mov.b32         C, 0x3E9A209BU; \n  mul.f32         f,f,C;          \n  cv" "t.rn.f16.f32      r, f;       \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x338FU;\n  mov.b16 ulp,0x1000U;\n  set.eq.f16.f16 p,h, sp" "c;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x33F8U;\n  mov.b16 ulp,0x9000U;\n  set.eq.f16.f16 p,h, sp" "c;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x57E1U;\n  mov.b16 ulp,0x9800U;\n  set.eq.f16.f16 p,h, sp" "c;\n  fma.rn.f16 r,p,ulp,r;\n}\n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0x719DU;\n  mov.b16 ulp,0x9C00U;\n  set.eq.f16.f16 p,h, sp" "c;\n  fma.rn.f16 r,p,ulp,r;\n}\n  mov.b16         %0, r;          \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2328
return val; 
# 2329
} 
#endif
# 2330 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2log10(const __half2 a) {int volatile ___ = 1;(void)a;
# 2353
::exit(___);}
#if 0
# 2330
{ 
# 2331
__half2 val; 
# 2332
__asm__("{.reg.b16         hl, hu;             \n .reg.b32         r, fl, fu, C, h;    \n  mov.b32         {hl, hu}, %1;       \n  mov.b3" "2         h, %1;              \n  cvt.f32.f16     fl, hl;             \n  cvt.f32.f16     fu, hu;             \n  lg2.approx.ftz" ".f32  fl, fl;         \n  lg2.approx.ftz.f32  fu, fu;         \n  mov.b32         C, 0x3E9A209BU;     \n  mul.f32         fl,fl," "C;            \n  mul.f32         fu,fu,C;            \n  cvt.rn.f16.f32      hl, fl;         \n  cvt.rn.f16.f32      hu, fu;   " "      \n  mov.b32         r, {hl, hu};        \n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x338F338FU;\n  mov.b32 ulp,0x10001000U;\n" "  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x33F833F8U;\n  mov.b32 ulp," "0x90009000U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0x57E157E1U;\n" "  mov.b32 ulp,0x98009800U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n{.reg.b32 spc, ulp, p;\n  mov.b32 spc," "0x719D719DU;\n  mov.b32 ulp,0x9C009C00U;\n  set.eq.f16x2.f16x2 p,h, spc;\n  fma.rn.f16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;" "              \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2352
return val; 
# 2353
} 
#endif
# 2356 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2rcp(const __half2 a) {int volatile ___ = 1;(void)a;
# 2358
::exit(___);}
#if 0
# 2356
{ 
# 2357
{ __half2 val; __asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  rcp.approx.ftz.f32   fl, fl;     \n  rcp.approx.ftz.f32   fu, fu;     \n  " "cvt.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); return val; } 
# 2358
} 
#endif
# 2359 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hrcp(const __half a) {int volatile ___ = 1;(void)a;
# 2361
::exit(___);}
#if 0
# 2359
{ 
# 2360
{ __half val; __asm__("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  cvt.f32.f16     f,r;      \n  rcp.ap" "prox.ftz.f32   f,f;  \n  cvt.rn.f16.f32      r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); return val; } 
# 2361
} 
#endif
# 2362 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2rsqrt(const __half2 a) {int volatile ___ = 1;(void)a;
# 2364
::exit(___);}
#if 0
# 2362
{ 
# 2363
{ __half2 val; __asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  rsqrt.approx.ftz.f32   fl, fl;     \n  rsqrt.approx.ftz.f32   fu, fu;     " "\n  cvt.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); return val; } 
# 2364
} 
#endif
# 2365 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hrsqrt(const __half a) {int volatile ___ = 1;(void)a;
# 2367
::exit(___);}
#if 0
# 2365
{ 
# 2366
{ __half val; __asm__("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  cvt.f32.f16     f,r;      \n  rsqrt." "approx.ftz.f32   f,f;  \n  cvt.rn.f16.f32      r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); return val; } 
# 2367
} 
#endif
# 2368 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 h2sqrt(const __half2 a) {int volatile ___ = 1;(void)a;
# 2370
::exit(___);}
#if 0
# 2368
{ 
# 2369
{ __half2 val; __asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  cvt.f32.f16     fl" ", hl;         \n  cvt.f32.f16     fu, hu;         \n  sqrt.approx.ftz.f32   fl, fl;     \n  sqrt.approx.ftz.f32   fu, fu;     \n" "  cvt.rn.f16.f32      hl, fl;     \n  cvt.rn.f16.f32      hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); return val; } 
# 2370
} 
#endif
# 2371 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half hsqrt(const __half a) {int volatile ___ = 1;(void)a;
# 2373
::exit(___);}
#if 0
# 2371
{ 
# 2372
{ __half val; __asm__("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  cvt.f32.f16     f,r;      \n  sqrt.a" "pprox.ftz.f32   f,f;  \n  cvt.rn.f16.f32      r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); return val; } 
# 2373
} 
#endif
# 2376 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hisnan2(const __half2 a) 
# 2377
{int volatile ___ = 1;(void)a;
# 2382
::exit(___);}
#if 0
# 2377
{ 
# 2378
__half2 r; 
# 2379
__asm__("{set.nan.f16x2.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2381
return r; 
# 2382
} 
#endif
# 2383 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline bool __hisnan(const __half a) 
# 2384
{int volatile ___ = 1;(void)a;
# 2389
::exit(___);}
#if 0
# 2384
{ 
# 2385
__half r; 
# 2386
__asm__("{set.nan.f16.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2388
return (*(reinterpret_cast< const unsigned short *>(&r))) != 0U; 
# 2389
} 
#endif
# 2390 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hneg2(const __half2 a) 
# 2391
{int volatile ___ = 1;(void)a;
# 2396
::exit(___);}
#if 0
# 2391
{ 
# 2392
__half2 r; 
# 2393
__asm__("{neg.f16x2 %0,%1;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2395
return r; 
# 2396
} 
#endif
# 2397 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hneg(const __half a) 
# 2398
{int volatile ___ = 1;(void)a;
# 2403
::exit(___);}
#if 0
# 2398
{ 
# 2399
__half r; 
# 2400
__asm__("{neg.f16 %0,%1;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2402
return r; 
# 2403
} 
#endif
# 2404 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __habs2(const __half2 a) 
# 2405
{int volatile ___ = 1;(void)a;
# 2410
::exit(___);}
#if 0
# 2405
{ 
# 2406
__half2 r; 
# 2407
__asm__("{abs.f16x2 %0,%1;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2409
return r; 
# 2410
} 
#endif
# 2411 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __habs(const __half a) 
# 2412
{int volatile ___ = 1;(void)a;
# 2417
::exit(___);}
#if 0
# 2412
{ 
# 2413
__half r; 
# 2414
__asm__("{abs.f16 %0,%1;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2416
return r; 
# 2417
} 
#endif
# 2419 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hcmadd(const __half2 a, const __half2 b, const __half2 c) 
# 2420
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2430
::exit(___);}
#if 0
# 2420
{ 
# 2425
__half real_tmp = __hfma(a.x, b.x, c.x); 
# 2426
__half img_tmp = __hfma(a.x, b.y, c.y); 
# 2427
real_tmp = __hfma(__hneg(a.y), b.y, real_tmp); 
# 2428
img_tmp = __hfma(a.y, b.x, img_tmp); 
# 2429
return make_half2(real_tmp, img_tmp); 
# 2430
} 
#endif
# 2437 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hmax(const __half a, const __half b) 
# 2438
{int volatile ___ = 1;(void)a;(void)b;
# 2440
::exit(___);}
#if 0
# 2438
{ 
# 2439
{ __half val; __asm__("{max.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 2440
} 
#endif
# 2441 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hmin(const __half a, const __half b) 
# 2442
{int volatile ___ = 1;(void)a;(void)b;
# 2444
::exit(___);}
#if 0
# 2442
{ 
# 2443
{ __half val; __asm__("{min.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 2444
} 
#endif
# 2445 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hmax_nan(const __half a, const __half b) 
# 2446
{int volatile ___ = 1;(void)a;(void)b;
# 2448
::exit(___);}
#if 0
# 2446
{ 
# 2447
{ __half val; __asm__("{max.NaN.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 2448
} 
#endif
# 2449 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hmin_nan(const __half a, const __half b) 
# 2450
{int volatile ___ = 1;(void)a;(void)b;
# 2452
::exit(___);}
#if 0
# 2450
{ 
# 2451
{ __half val; __asm__("{min.NaN.f16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 2452
} 
#endif
# 2453 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half __hfma_relu(const __half a, const __half b, const __half c) 
# 2454
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2456
::exit(___);}
#if 0
# 2454
{ 
# 2455
{ __half val; __asm__("{fma.rn.relu.f16 %0,%1,%2,%3;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b))), "h" (*(reinterpret_cast< const unsigned short *>(&c)))); return val; } 
# 2456
} 
#endif
# 2460 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hmax2(const __half2 a, const __half2 b) 
# 2461
{int volatile ___ = 1;(void)a;(void)b;
# 2463
::exit(___);}
#if 0
# 2461
{ 
# 2462
{ __half2 val; __asm__("{max.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 2463
} 
#endif
# 2464 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hmin2(const __half2 a, const __half2 b) 
# 2465
{int volatile ___ = 1;(void)a;(void)b;
# 2467
::exit(___);}
#if 0
# 2465
{ 
# 2466
{ __half2 val; __asm__("{min.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 2467
} 
#endif
# 2468 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hmax2_nan(const __half2 a, const __half2 b) 
# 2469
{int volatile ___ = 1;(void)a;(void)b;
# 2471
::exit(___);}
#if 0
# 2469
{ 
# 2470
{ __half2 val; __asm__("{max.NaN.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 2471
} 
#endif
# 2472 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hmin2_nan(const __half2 a, const __half2 b) 
# 2473
{int volatile ___ = 1;(void)a;(void)b;
# 2475
::exit(___);}
#if 0
# 2473
{ 
# 2474
{ __half2 val; __asm__("{min.NaN.f16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 2475
} 
#endif
# 2476 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 __hfma2_relu(const __half2 a, const __half2 b, const __half2 c) 
# 2477
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2479
::exit(___);}
#if 0
# 2477
{ 
# 2478
{ __half2 val; __asm__("{fma.rn.relu.f16x2 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b))), "r" (*(reinterpret_cast< const unsigned *>(&c)))); return val; } 
# 2479
} 
#endif
# 2491 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half2 atomicAdd(__half2 *const address, const __half2 val) {int volatile ___ = 1;(void)address;(void)val;
# 2497
::exit(___);}
#if 0
# 2491
{ 
# 2492
__half2 r; 
# 2493
__asm__ volatile("{ atom.add.noftz.f16x2 %0,[%1],%2; }\n" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "l" (address), "r" (*(reinterpret_cast< const unsigned *>(&val))) : "memory"); 
# 2496
return r; 
# 2497
} 
#endif
# 2503 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
__attribute__((unused)) static inline __half atomicAdd(__half *const address, const __half val) {int volatile ___ = 1;(void)address;(void)val;
# 2510
::exit(___);}
#if 0
# 2503
{ 
# 2504
__half r; 
# 2505
__asm__ volatile("{ atom.add.noftz.f16 %0,[%1],%2; }\n" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "l" (address), "h" (*(reinterpret_cast< const unsigned short *>(&val))) : "memory"); 
# 2509
return r; 
# 2510
} 
#endif
# 2536 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_fp16.hpp"
typedef __half half; 
# 2537
typedef __half2 half2; 
# 2539
typedef __half __nv_half; 
# 2540
typedef __half2 __nv_half2; 
# 2541
typedef __half_raw __nv_half_raw; 
# 2542
typedef __half2_raw __nv_half2_raw; 
# 2543
typedef __half nv_half; 
# 2544
typedef __half2 nv_half2; 
# 128 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
struct __nv_bfloat16; 
# 138 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
struct __nv_bfloat162; 
# 154 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __double2bfloat16(const double a); 
# 169 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __float2bfloat16(const float a); 
# 184 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __float2bfloat16_rn(const float a); 
# 199 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __float2bfloat16_rz(const float a); 
# 215 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __float2bfloat16_rd(const float a); 
# 231 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __float2bfloat16_ru(const float a); 
# 246 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline float __bfloat162float(const __nv_bfloat16 a); 
# 264 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat162 __float2bfloat162_rn(const float a); 
# 285 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat162 __floats2bfloat162_rn(const float a, const float b); 
# 301 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline float __low2float(const __nv_bfloat162 a); 
# 317 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline float __high2float(const __nv_bfloat162 a); 
# 339 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat162 __float22bfloat162_rn(const float2 a); 
# 355 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline float2 __bfloat1622float2(const __nv_bfloat162 a); 
# 371 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline int __bfloat162int_rn(const __nv_bfloat16 h); 
# 387 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline int __bfloat162int_rz(const __nv_bfloat16 h); 
# 403 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline int __bfloat162int_rd(const __nv_bfloat16 h); 
# 419 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline int __bfloat162int_ru(const __nv_bfloat16 h); 
# 436 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __int2bfloat16_rn(const int i); 
# 452 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __int2bfloat16_rz(const int i); 
# 468 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __int2bfloat16_rd(const int i); 
# 484 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __int2bfloat16_ru(const int i); 
# 502 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline short __bfloat162short_rn(const __nv_bfloat16 h); 
# 518 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline short __bfloat162short_rz(const __nv_bfloat16 h); 
# 534 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline short __bfloat162short_rd(const __nv_bfloat16 h); 
# 550 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline short __bfloat162short_ru(const __nv_bfloat16 h); 
# 568 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __short2bfloat16_rn(const short i); 
# 584 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __short2bfloat16_rz(const short i); 
# 600 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __short2bfloat16_rd(const short i); 
# 616 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __short2bfloat16_ru(const short i); 
# 633 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned __bfloat162uint_rn(const __nv_bfloat16 h); 
# 649 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline unsigned __bfloat162uint_rz(const __nv_bfloat16 h); 
# 665 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned __bfloat162uint_rd(const __nv_bfloat16 h); 
# 681 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned __bfloat162uint_ru(const __nv_bfloat16 h); 
# 698 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __uint2bfloat16_rn(const unsigned i); 
# 714 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __uint2bfloat16_rz(const unsigned i); 
# 730 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __uint2bfloat16_rd(const unsigned i); 
# 746 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __uint2bfloat16_ru(const unsigned i); 
# 764 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned short __bfloat162ushort_rn(const __nv_bfloat16 h); 
# 781 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline unsigned short __bfloat162ushort_rz(const __nv_bfloat16 h); 
# 793 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned short __bfloat162ushort_rd(const __nv_bfloat16 h); 
# 805 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned short __bfloat162ushort_ru(const __nv_bfloat16 h); 
# 823 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __ushort2bfloat16_rn(const unsigned short i); 
# 840 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ushort2bfloat16_rz(const unsigned short i); 
# 856 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ushort2bfloat16_rd(const unsigned short i); 
# 872 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ushort2bfloat16_ru(const unsigned short i); 
# 890 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned long long __bfloat162ull_rn(const __nv_bfloat16 h); 
# 907 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline unsigned long long __bfloat162ull_rz(const __nv_bfloat16 h); 
# 923 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned long long __bfloat162ull_rd(const __nv_bfloat16 h); 
# 939 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned long long __bfloat162ull_ru(const __nv_bfloat16 h); 
# 957 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __ull2bfloat16_rn(const unsigned long long i); 
# 974 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ull2bfloat16_rz(const unsigned long long i); 
# 990 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ull2bfloat16_rd(const unsigned long long i); 
# 1006 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ull2bfloat16_ru(const unsigned long long i); 
# 1024 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline long long __bfloat162ll_rn(const __nv_bfloat16 h); 
# 1040 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline long long __bfloat162ll_rz(const __nv_bfloat16 h); 
# 1056 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline long long __bfloat162ll_rd(const __nv_bfloat16 h); 
# 1072 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline long long __bfloat162ll_ru(const __nv_bfloat16 h); 
# 1090 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
static inline __nv_bfloat16 __ll2bfloat16_rn(const long long i); 
# 1102 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ll2bfloat16_rz(const long long i); 
# 1118 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ll2bfloat16_rd(const long long i); 
# 1134 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ll2bfloat16_ru(const long long i); 
# 1151 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 htrunc(const __nv_bfloat16 h); 
# 1166 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hceil(const __nv_bfloat16 h); 
# 1181 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hfloor(const __nv_bfloat16 h); 
# 1198 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hrint(const __nv_bfloat16 h); 
# 1215 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2trunc(const __nv_bfloat162 h); 
# 1231 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2ceil(const __nv_bfloat162 h); 
# 1247 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2floor(const __nv_bfloat162 h); 
# 1265 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2rint(const __nv_bfloat162 h); 
# 1282 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __bfloat162bfloat162(const __nv_bfloat16 a); 
# 1298 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __lowhigh2highlow(const __nv_bfloat162 a); 
# 1318 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __lows2bfloat162(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1338 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __highs2bfloat162(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1353 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __high2bfloat16(const __nv_bfloat162 a); 
# 1368 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __low2bfloat16(const __nv_bfloat162 a); 
# 1385 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline int __hisinf(const __nv_bfloat16 a); 
# 1403 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __halves2bfloat162(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 1419 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __low2bfloat162(const __nv_bfloat162 a); 
# 1435 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __high2bfloat162(const __nv_bfloat162 a); 
# 1452 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline short __bfloat16_as_short(const __nv_bfloat16 h); 
# 1468 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline unsigned short __bfloat16_as_ushort(const __nv_bfloat16 h); 
# 1484 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __short_as_bfloat16(const short i); 
# 1500 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __ushort_as_bfloat16(const unsigned short i); 
# 1531 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __shfl_sync(const unsigned mask, const __nv_bfloat162 var, const int delta, const int width = 32); 
# 1556 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __shfl_up_sync(const unsigned mask, const __nv_bfloat162 var, const unsigned delta, const int width = 32); 
# 1581 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __shfl_down_sync(const unsigned mask, const __nv_bfloat162 var, const unsigned delta, const int width = 32); 
# 1605 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __shfl_xor_sync(const unsigned mask, const __nv_bfloat162 var, const int delta, const int width = 32); 
# 1630 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __shfl_sync(const unsigned mask, const __nv_bfloat16 var, const int delta, const int width = 32); 
# 1654 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __shfl_up_sync(const unsigned mask, const __nv_bfloat16 var, const unsigned delta, const int width = 32); 
# 1679 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __shfl_down_sync(const unsigned mask, const __nv_bfloat16 var, const unsigned delta, const int width = 32); 
# 1703 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __shfl_xor_sync(const unsigned mask, const __nv_bfloat16 var, const int delta, const int width = 32); 
# 1716 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __ldg(const __nv_bfloat162 *const ptr); 
# 1723
__attribute__((unused)) static inline __nv_bfloat16 __ldg(const __nv_bfloat16 *const ptr); 
# 1730
__attribute__((unused)) static inline __nv_bfloat162 __ldcg(const __nv_bfloat162 *const ptr); 
# 1737
__attribute__((unused)) static inline __nv_bfloat16 __ldcg(const __nv_bfloat16 *const ptr); 
# 1744
__attribute__((unused)) static inline __nv_bfloat162 __ldca(const __nv_bfloat162 *const ptr); 
# 1751
__attribute__((unused)) static inline __nv_bfloat16 __ldca(const __nv_bfloat16 *const ptr); 
# 1758
__attribute__((unused)) static inline __nv_bfloat162 __ldcs(const __nv_bfloat162 *const ptr); 
# 1765
__attribute__((unused)) static inline __nv_bfloat16 __ldcs(const __nv_bfloat16 *const ptr); 
# 1772
__attribute__((unused)) static inline __nv_bfloat162 __ldlu(const __nv_bfloat162 *const ptr); 
# 1779
__attribute__((unused)) static inline __nv_bfloat16 __ldlu(const __nv_bfloat16 *const ptr); 
# 1786
__attribute__((unused)) static inline __nv_bfloat162 __ldcv(const __nv_bfloat162 *const ptr); 
# 1793
__attribute__((unused)) static inline __nv_bfloat16 __ldcv(const __nv_bfloat16 *const ptr); 
# 1801
__attribute__((unused)) static inline void __stwb(__nv_bfloat162 *const ptr, const __nv_bfloat162 value); 
# 1808
__attribute__((unused)) static inline void __stwb(__nv_bfloat16 *const ptr, const __nv_bfloat16 value); 
# 1815
__attribute__((unused)) static inline void __stcg(__nv_bfloat162 *const ptr, const __nv_bfloat162 value); 
# 1822
__attribute__((unused)) static inline void __stcg(__nv_bfloat16 *const ptr, const __nv_bfloat16 value); 
# 1829
__attribute__((unused)) static inline void __stcs(__nv_bfloat162 *const ptr, const __nv_bfloat162 value); 
# 1836
__attribute__((unused)) static inline void __stcs(__nv_bfloat16 *const ptr, const __nv_bfloat16 value); 
# 1843
__attribute__((unused)) static inline void __stwt(__nv_bfloat162 *const ptr, const __nv_bfloat162 value); 
# 1850
__attribute__((unused)) static inline void __stwt(__nv_bfloat16 *const ptr, const __nv_bfloat16 value); 
# 1869 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __heq2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1887 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hne2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1905 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hle2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1923 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hge2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1941 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hlt2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1959 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hgt2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1977 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hequ2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 1995 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hneu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2013 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hleu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2031 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hgeu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2049 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hltu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2067 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hgtu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2083 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hisnan2(const __nv_bfloat162 a); 
# 2103 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hadd2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2123 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hsub2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2143 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hmul2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2163 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hadd2_rn(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2183 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hsub2_rn(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2204 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hmul2_rn(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2224 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __h2div(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2241 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __habs2(const __nv_bfloat162 a); 
# 2260 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hadd2_sat(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2279 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hsub2_sat(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2299 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hmul2_sat(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2322 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hfma2(const __nv_bfloat162 a, const __nv_bfloat162 b, const __nv_bfloat162 c); 
# 2344 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hfma2_sat(const __nv_bfloat162 a, const __nv_bfloat162 b, const __nv_bfloat162 c); 
# 2363 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hneg2(const __nv_bfloat162 a); 
# 2378 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __habs(const __nv_bfloat16 a); 
# 2398 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hadd(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2418 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hsub(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2434 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hmul(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2454 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hadd_rn(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2474 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hsub_rn(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2490 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hmul_rn(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2510 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hdiv(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2528 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hadd_sat(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2547 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hsub_sat(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2566 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hmul_sat(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2589 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hfma(const __nv_bfloat16 a, const __nv_bfloat16 b, const __nv_bfloat16 c); 
# 2611 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hfma_sat(const __nv_bfloat16 a, const __nv_bfloat16 b, const __nv_bfloat16 c); 
# 2629 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hneg(const __nv_bfloat16 a); 
# 2651 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbeq2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2673 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbne2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2695 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hble2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2717 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbge2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2739 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hblt2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2761 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbgt2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2783 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbequ2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2805 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbneu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2827 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbleu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2850 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbgeu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2872 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbltu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2895 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hbgtu2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 2912 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __heq(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2929 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hne(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2946 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hle(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2963 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hge(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2980 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hlt(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 2997 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hgt(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3015 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hequ(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3033 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hneu(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3051 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hleu(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3069 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hgeu(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3087 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hltu(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3105 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hgtu(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3120 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline bool __hisnan(const __nv_bfloat16 a); 
# 3139 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hmax(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3158 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hmin(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3176 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hmax_nan(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3194 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hmin_nan(const __nv_bfloat16 a, const __nv_bfloat16 b); 
# 3216 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 __hfma_relu(const __nv_bfloat16 a, const __nv_bfloat16 b, const __nv_bfloat16 c); 
# 3237 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hmax2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 3258 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hmin2(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 3278 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hmax2_nan(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 3298 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hmin2_nan(const __nv_bfloat162 a, const __nv_bfloat162 b); 
# 3320 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hfma2_relu(const __nv_bfloat162 a, const __nv_bfloat162 b, const __nv_bfloat162 c); 
# 3339 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 __hcmadd(const __nv_bfloat162 a, const __nv_bfloat162 b, const __nv_bfloat162 c); 
# 3355 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hsqrt(const __nv_bfloat16 a); 
# 3372 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hrsqrt(const __nv_bfloat16 a); 
# 3387 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hrcp(const __nv_bfloat16 a); 
# 3403 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hlog(const __nv_bfloat16 a); 
# 3419 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hlog2(const __nv_bfloat16 a); 
# 3435 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hlog10(const __nv_bfloat16 a); 
# 3452 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hexp(const __nv_bfloat16 a); 
# 3469 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hexp2(const __nv_bfloat16 a); 
# 3486 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hexp10(const __nv_bfloat16 a); 
# 3501 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hcos(const __nv_bfloat16 a); 
# 3516 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 hsin(const __nv_bfloat16 a); 
# 3532 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2sqrt(const __nv_bfloat162 a); 
# 3549 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2rsqrt(const __nv_bfloat162 a); 
# 3565 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2rcp(const __nv_bfloat162 a); 
# 3582 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2log(const __nv_bfloat162 a); 
# 3599 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2log2(const __nv_bfloat162 a); 
# 3616 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2log10(const __nv_bfloat162 a); 
# 3633 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2exp(const __nv_bfloat162 a); 
# 3650 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2exp2(const __nv_bfloat162 a); 
# 3667 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2exp10(const __nv_bfloat162 a); 
# 3683 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2cos(const __nv_bfloat162 a); 
# 3698 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 h2sin(const __nv_bfloat162 a); 
# 3717 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat162 atomicAdd(__nv_bfloat162 *const address, const __nv_bfloat162 val); 
# 3735 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.h"
__attribute__((unused)) static inline __nv_bfloat16 atomicAdd(__nv_bfloat16 *const address, const __nv_bfloat16 val); 
# 127 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
typedef 
# 125
struct __attribute((aligned(2))) { 
# 126
unsigned short x; 
# 127
} __nv_bfloat16_raw; 
# 132
typedef 
# 129
struct __attribute((aligned(4))) { 
# 130
unsigned short x; 
# 131
unsigned short y; 
# 132
} __nv_bfloat162_raw; 
# 140
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#pragma GCC diagnostic ignored "-Weffc++"
# 153 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
struct __attribute((aligned(2))) __nv_bfloat16 { 
# 155
protected: unsigned short __x; 
# 159
public: __nv_bfloat16() = default;
# 165
__nv_bfloat16(const __nv_bfloat16_raw &hr) : __x(hr.x) { } 
# 166
__nv_bfloat16 &operator=(const __nv_bfloat16_raw &hr) { (__x) = (hr.x); return *this; } 
# 167
volatile __nv_bfloat16 &operator=(const __nv_bfloat16_raw &hr) volatile { (__x) = (hr.x); return *this; } 
# 168
volatile __nv_bfloat16 &operator=(const volatile __nv_bfloat16_raw &hr) volatile { (__x) = (hr.x); return *this; } 
# 169
operator __nv_bfloat16_raw() const { __nv_bfloat16_raw ret; (ret.x) = (__x); return ret; } 
# 170
operator __nv_bfloat16_raw() const volatile { __nv_bfloat16_raw ret; (ret.x) = (__x); return ret; } 
# 174
__nv_bfloat16(const float f) { (__x) = (__float2bfloat16(f).__x); } 
# 175
__nv_bfloat16(const double f) { (__x) = (__double2bfloat16(f).__x); } 
# 177
operator float() const { return __bfloat162float(*this); } 
# 178
__nv_bfloat16 &operator=(const float f) { (__x) = (__float2bfloat16(f).__x); return *this; } 
# 181
__nv_bfloat16 &operator=(const double f) { (__x) = (__double2bfloat16(f).__x); return *this; } 
# 187
__nv_bfloat16(short val) { (__x) = (__short2bfloat16_rn(val).__x); } 
# 188
__nv_bfloat16(unsigned short val) { (__x) = (__ushort2bfloat16_rn(val).__x); } 
# 189
__nv_bfloat16(int val) { (__x) = (__int2bfloat16_rn(val).__x); } 
# 190
__nv_bfloat16(unsigned val) { (__x) = (__uint2bfloat16_rn(val).__x); } 
# 191
__nv_bfloat16(long long val) { (__x) = (__ll2bfloat16_rn(val).__x); } 
# 192
__nv_bfloat16(unsigned long long val) { (__x) = (__ull2bfloat16_rn(val).__x); } 
# 195
operator short() const { return __bfloat162short_rz(*this); } 
# 196
__nv_bfloat16 &operator=(short val) { (__x) = (__short2bfloat16_rn(val).__x); return *this; } 
# 198
operator unsigned short() const { return __bfloat162ushort_rz(*this); } 
# 199
__nv_bfloat16 &operator=(unsigned short val) { (__x) = (__ushort2bfloat16_rn(val).__x); return *this; } 
# 201
operator int() const { return __bfloat162int_rz(*this); } 
# 202
__nv_bfloat16 &operator=(int val) { (__x) = (__int2bfloat16_rn(val).__x); return *this; } 
# 204
operator unsigned() const { return __bfloat162uint_rz(*this); } 
# 205
__nv_bfloat16 &operator=(unsigned val) { (__x) = (__uint2bfloat16_rn(val).__x); return *this; } 
# 207
operator long long() const { return __bfloat162ll_rz(*this); } 
# 208
__nv_bfloat16 &operator=(long long val) { (__x) = (__ll2bfloat16_rn(val).__x); return *this; } 
# 210
operator unsigned long long() const { return __bfloat162ull_rz(*this); } 
# 211
__nv_bfloat16 &operator=(unsigned long long val) { (__x) = (__ull2bfloat16_rn(val).__x); return *this; } 
# 214
operator bool() const { return ((__x) & 32767) != 0; } 
# 217
}; 
# 225
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 operator+(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 225
{ return __hadd(lh, rh); } 
#endif
# 226 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 operator-(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 226
{ return __hsub(lh, rh); } 
#endif
# 227 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 operator*(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 227
{ return __hmul(lh, rh); } 
#endif
# 228 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 operator/(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 228
{ return __hdiv(lh, rh); } 
#endif
# 230 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 &operator+=(__nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 230
{ lh = __hadd(lh, rh); return lh; } 
#endif
# 231 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 &operator-=(__nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 231
{ lh = __hsub(lh, rh); return lh; } 
#endif
# 232 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 &operator*=(__nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 232
{ lh = __hmul(lh, rh); return lh; } 
#endif
# 233 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 &operator/=(__nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 233
{ lh = __hdiv(lh, rh); return lh; } 
#endif
# 236 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 &operator++(__nv_bfloat16 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 236
{ __nv_bfloat16_raw one; (one.x) = (16256); (h += one); return h; } 
#endif
# 237 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 &operator--(__nv_bfloat16 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 237
{ __nv_bfloat16_raw one; (one.x) = (16256); (h -= one); return h; } 
#endif
# 238 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 operator++(__nv_bfloat16 &h, const int ignored) 
# 239
{int volatile ___ = 1;(void)h;(void)ignored;
# 248
::exit(___);}
#if 0
# 239
{ 
# 241
static_cast< void>(ignored); 
# 243
const __nv_bfloat16 ret = h; 
# 244
__nv_bfloat16_raw one; 
# 245
(one.x) = (16256); 
# 246
(h += one); 
# 247
return ret; 
# 248
} 
#endif
# 249 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 operator--(__nv_bfloat16 &h, const int ignored) 
# 250
{int volatile ___ = 1;(void)h;(void)ignored;
# 259
::exit(___);}
#if 0
# 250
{ 
# 252
static_cast< void>(ignored); 
# 254
const __nv_bfloat16 ret = h; 
# 255
__nv_bfloat16_raw one; 
# 256
(one.x) = (16256); 
# 257
(h -= one); 
# 258
return ret; 
# 259
} 
#endif
# 261 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 operator+(const __nv_bfloat16 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 261
{ return h; } 
#endif
# 262 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat16 operator-(const __nv_bfloat16 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 262
{ return __hneg(h); } 
#endif
# 265 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator==(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 265
{ return __heq(lh, rh); } 
#endif
# 266 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator!=(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 266
{ return __hneu(lh, rh); } 
#endif
# 267 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator>(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 267
{ return __hgt(lh, rh); } 
#endif
# 268 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator<(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 268
{ return __hlt(lh, rh); } 
#endif
# 269 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator>=(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 269
{ return __hge(lh, rh); } 
#endif
# 270 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator<=(const __nv_bfloat16 &lh, const __nv_bfloat16 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 270
{ return __hle(lh, rh); } 
#endif
# 276 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
struct __attribute((aligned(4))) __nv_bfloat162 { 
# 277
__nv_bfloat16 x; 
# 278
__nv_bfloat16 y; 
# 283
__nv_bfloat162() = default;
# 284
__nv_bfloat162(__nv_bfloat162 &&src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = std::move(*(reinterpret_cast< const unsigned *>(&src))); } 
# 285
__nv_bfloat162 &operator=(__nv_bfloat162 &&src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = std::move(*(reinterpret_cast< const unsigned *>(&src))); return *this; } 
# 289
__nv_bfloat162(const __nv_bfloat16 &a, const __nv_bfloat16 &b) : x(a), y(b) { } 
# 290
__nv_bfloat162(const __nv_bfloat162 &src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&src))); } 
# 291
__nv_bfloat162 &operator=(const __nv_bfloat162 &src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&src))); return *this; } 
# 294
__nv_bfloat162(const __nv_bfloat162_raw &h2r) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&h2r))); } 
# 295
__nv_bfloat162 &operator=(const __nv_bfloat162_raw &h2r) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&h2r))); return *this; } 
# 296
operator __nv_bfloat162_raw() const { __nv_bfloat162_raw ret; (ret.x) = (0U); (ret.y) = (0U); (*(reinterpret_cast< unsigned *>(&ret))) = (*(reinterpret_cast< const unsigned *>(&(*this)))); return ret; } 
# 297
}; 
# 304
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 operator+(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 304
{ return __hadd2(lh, rh); } 
#endif
# 305 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 operator-(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 305
{ return __hsub2(lh, rh); } 
#endif
# 306 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 operator*(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 306
{ return __hmul2(lh, rh); } 
#endif
# 307 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 operator/(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 307
{ return __h2div(lh, rh); } 
#endif
# 309 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 &operator+=(__nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 309
{ (lh = (__hadd2(lh, rh))); return lh; } 
#endif
# 310 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 &operator-=(__nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 310
{ (lh = (__hsub2(lh, rh))); return lh; } 
#endif
# 311 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 &operator*=(__nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 311
{ (lh = (__hmul2(lh, rh))); return lh; } 
#endif
# 312 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 &operator/=(__nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 312
{ (lh = (__h2div(lh, rh))); return lh; } 
#endif
# 314 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 &operator++(__nv_bfloat162 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 314
{ __nv_bfloat162_raw one; (one.x) = (16256); (one.y) = (16256); (h = (__hadd2(h, one))); return h; } 
#endif
# 315 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 &operator--(__nv_bfloat162 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 315
{ __nv_bfloat162_raw one; (one.x) = (16256); (one.y) = (16256); (h = (__hsub2(h, one))); return h; } 
#endif
# 316 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 operator++(__nv_bfloat162 &h, const int ignored) 
# 317
{int volatile ___ = 1;(void)h;(void)ignored;
# 327
::exit(___);}
#if 0
# 317
{ 
# 319
static_cast< void>(ignored); 
# 321
const __nv_bfloat162 ret = h; 
# 322
__nv_bfloat162_raw one; 
# 323
(one.x) = (16256); 
# 324
(one.y) = (16256); 
# 325
(h = (__hadd2(h, one))); 
# 326
return ret; 
# 327
} 
#endif
# 328 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 operator--(__nv_bfloat162 &h, const int ignored) 
# 329
{int volatile ___ = 1;(void)h;(void)ignored;
# 339
::exit(___);}
#if 0
# 329
{ 
# 331
static_cast< void>(ignored); 
# 333
const __nv_bfloat162 ret = h; 
# 334
__nv_bfloat162_raw one; 
# 335
(one.x) = (16256); 
# 336
(one.y) = (16256); 
# 337
(h = (__hsub2(h, one))); 
# 338
return ret; 
# 339
} 
#endif
# 340 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 operator+(const __nv_bfloat162 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 340
{ return h; } 
#endif
# 341 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline __nv_bfloat162 operator-(const __nv_bfloat162 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
# 341
{ return __hneg2(h); } 
#endif
# 343 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator==(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 343
{ return __hbeq2(lh, rh); } 
#endif
# 344 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator!=(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 344
{ return __hbneu2(lh, rh); } 
#endif
# 345 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator>(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 345
{ return __hbgt2(lh, rh); } 
#endif
# 346 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator<(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 346
{ return __hblt2(lh, rh); } 
#endif
# 347 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator>=(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 347
{ return __hbge2(lh, rh); } 
#endif
# 348 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute((always_inline)) __attribute__((unused)) inline bool operator<=(const __nv_bfloat162 &lh, const __nv_bfloat162 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
# 348
{ return __hble2(lh, rh); } 
#endif
# 361 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
#pragma GCC diagnostic pop
# 368
static inline unsigned short __internal_float2bfloat16(const float f, unsigned &sign, unsigned &remainder) 
# 369
{ 
# 370
unsigned x; 
# 375
(void)memcpy(&x, &f, sizeof f); 
# 380
if ((x & 2147483647U) > 2139095040U) { 
# 381
sign = 0U; 
# 382
remainder = 0U; 
# 383
return static_cast< unsigned short>(32767U); 
# 384
}  
# 385
sign = (x >> 31U); 
# 386
remainder = (x << 16U); 
# 387
return static_cast< unsigned short>(x >> 16U); 
# 388
} 
# 390
static inline __nv_bfloat16 __double2bfloat16(const double x) 
# 391
{ 
# 392
float f = static_cast< float>(x); 
# 393
const double d = static_cast< double>(f); 
# 394
unsigned u; 
# 399
(void)memcpy(&u, &f, sizeof f); 
# 403
bool x_is_not_nan = (u << ((unsigned)1U)) <= ((unsigned)4278190080U); 
# 406
if ((x > (0.0)) && (d > x)) { 
# 407
u--; 
# 408
}  
# 409
if ((x < (0.0)) && (d < x)) { 
# 410
u--; 
# 411
}  
# 412
if ((d != x) && x_is_not_nan) { 
# 413
u |= 1U; 
# 414
}  
# 419
(void)memcpy(&f, &u, sizeof f); 
# 424
return __float2bfloat16(f); 
# 425
} 
# 427
static inline __nv_bfloat16 __float2bfloat16(const float a) 
# 428
{ 
# 429
__nv_bfloat16 val; 
# 433
__nv_bfloat16_raw r; 
# 434
unsigned sign = 0U; 
# 435
unsigned remainder = 0U; 
# 436
(r.x) = __internal_float2bfloat16(a, sign, remainder); 
# 437
if ((remainder > 2147483648U) || ((remainder == 2147483648U) && (((r.x) & 1U) != 0U))) { 
# 438
(r.x)++; 
# 439
}  
# 440
(val = r); 
# 442
return val; 
# 443
} 
# 444
static inline __nv_bfloat16 __float2bfloat16_rn(const float a) 
# 445
{ 
# 446
__nv_bfloat16 val; 
# 450
__nv_bfloat16_raw r; 
# 451
unsigned sign = 0U; 
# 452
unsigned remainder = 0U; 
# 453
(r.x) = __internal_float2bfloat16(a, sign, remainder); 
# 454
if ((remainder > 2147483648U) || ((remainder == 2147483648U) && (((r.x) & 1U) != 0U))) { 
# 455
(r.x)++; 
# 456
}  
# 457
(val = r); 
# 459
return val; 
# 460
} 
# 461
static inline __nv_bfloat16 __float2bfloat16_rz(const float a) 
# 462
{ 
# 463
__nv_bfloat16 val; 
# 467
__nv_bfloat16_raw r; 
# 468
unsigned sign = 0U; 
# 469
unsigned remainder = 0U; 
# 470
(r.x) = __internal_float2bfloat16(a, sign, remainder); 
# 471
(val = r); 
# 473
return val; 
# 474
} 
# 475
static inline __nv_bfloat16 __float2bfloat16_rd(const float a) 
# 476
{ 
# 477
__nv_bfloat16 val; 
# 478
__nv_bfloat16_raw r; 
# 479
unsigned sign = 0U; 
# 480
unsigned remainder = 0U; 
# 481
(r.x) = __internal_float2bfloat16(a, sign, remainder); 
# 482
if ((remainder != 0U) && (sign != 0U)) { 
# 483
(r.x)++; 
# 484
}  
# 485
(val = r); 
# 486
return val; 
# 487
} 
# 488
static inline __nv_bfloat16 __float2bfloat16_ru(const float a) 
# 489
{ 
# 490
__nv_bfloat16 val; 
# 491
__nv_bfloat16_raw r; 
# 492
unsigned sign = 0U; 
# 493
unsigned remainder = 0U; 
# 494
(r.x) = __internal_float2bfloat16(a, sign, remainder); 
# 495
if ((remainder != 0U) && (sign == 0U)) { 
# 496
(r.x)++; 
# 497
}  
# 498
(val = r); 
# 499
return val; 
# 500
} 
# 501
static inline __nv_bfloat162 __float2bfloat162_rn(const float a) 
# 502
{ 
# 503
__nv_bfloat162 val; 
# 509
(val = __nv_bfloat162(__float2bfloat16_rn(a), __float2bfloat16_rn(a))); 
# 511
return val; 
# 512
} 
# 513
static inline __nv_bfloat162 __floats2bfloat162_rn(const float a, const float b) 
# 514
{ 
# 515
__nv_bfloat162 val; 
# 522
(val = __nv_bfloat162(__float2bfloat16_rn(a), __float2bfloat16_rn(b))); 
# 524
return val; 
# 525
} 
# 527
static inline float __internal_bfloat162float(const unsigned short h) 
# 528
{ 
# 529
float f; 
# 533
unsigned u = (static_cast< unsigned>(h)) << 16; 
# 535
(void)memcpy(&f, &u, sizeof f); 
# 540
return f; 
# 541
} 
# 543
static inline float __bfloat162float(const __nv_bfloat16 a) 
# 544
{ 
# 545
return __internal_bfloat162float(((__nv_bfloat16_raw)a).x); 
# 546
} 
# 547
static inline float __low2float(const __nv_bfloat162 a) 
# 548
{ 
# 549
return __internal_bfloat162float(((__nv_bfloat162_raw)a).x); 
# 550
} 
# 552
static inline float __high2float(const __nv_bfloat162 a) 
# 553
{ 
# 554
return __internal_bfloat162float(((__nv_bfloat162_raw)a).y); 
# 555
} 
# 560
static inline __nv_bfloat162 make_bfloat162(const __nv_bfloat16 x, const __nv_bfloat16 y) 
# 561
{ 
# 562
__nv_bfloat162 t; (t.x) = x; (t.y) = y; return t; 
# 563
} 
# 568
static inline __nv_bfloat162 __float22bfloat162_rn(const float2 a) 
# 569
{ 
# 570
__nv_bfloat162 val = __floats2bfloat162_rn(a.x, a.y); 
# 571
return val; 
# 572
} 
# 573
static inline float2 __bfloat1622float2(const __nv_bfloat162 a) 
# 574
{ 
# 575
float hi_float; 
# 576
float lo_float; 
# 577
lo_float = __internal_bfloat162float(((__nv_bfloat162_raw)a).x); 
# 578
hi_float = __internal_bfloat162float(((__nv_bfloat162_raw)a).y); 
# 579
return make_float2(lo_float, hi_float); 
# 580
} 
# 581
__attribute__((unused)) static inline int __bfloat162int_rn(const __nv_bfloat16 h) 
# 582
{int volatile ___ = 1;(void)h;
# 584
::exit(___);}
#if 0
# 582
{ 
# 583
return __float2int_rn(__bfloat162float(h)); 
# 584
} 
#endif
# 585 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline int __bfloat162int_rz(const __nv_bfloat16 h) 
# 586
{ 
# 587
const float f = __bfloat162float(h); 
# 588
int i; 
# 589
i = (static_cast< int>(f)); 
# 591
const int max_val = ((int)2147483647U); 
# 592
const int min_val = ((int)2147483648U); 
# 593
const unsigned short bits = static_cast< unsigned short>((((__nv_bfloat16_raw)h).x) << 1U); 
# 595
if (bits > ((unsigned short)65280U)) { 
# 597
i = 0; 
# 598
} else { if (f >= (static_cast< float>(max_val))) { 
# 600
i = max_val; 
# 601
} else { if (f < (static_cast< float>(min_val))) { 
# 603
i = min_val; 
# 604
}  }  }  
# 606
return i; 
# 607
} 
# 608
__attribute__((unused)) static inline int __bfloat162int_rd(const __nv_bfloat16 h) 
# 609
{int volatile ___ = 1;(void)h;
# 611
::exit(___);}
#if 0
# 609
{ 
# 610
return __float2int_rd(__bfloat162float(h)); 
# 611
} 
#endif
# 612 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline int __bfloat162int_ru(const __nv_bfloat16 h) 
# 613
{int volatile ___ = 1;(void)h;
# 615
::exit(___);}
#if 0
# 613
{ 
# 614
return __float2int_ru(__bfloat162float(h)); 
# 615
} 
#endif
# 616 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline __nv_bfloat16 __int2bfloat16_rn(const int i) 
# 617
{ 
# 627 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
const double d = static_cast< double>(i); 
# 628
return __double2bfloat16(d); 
# 630
} 
# 631
__attribute__((unused)) static inline __nv_bfloat16 __int2bfloat16_rz(const int i) 
# 632
{int volatile ___ = 1;(void)i;
# 634
::exit(___);}
#if 0
# 632
{ 
# 633
return __float2bfloat16_rz(__int2float_rz(i)); 
# 634
} 
#endif
# 635 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __int2bfloat16_rd(const int i) 
# 636
{int volatile ___ = 1;(void)i;
# 638
::exit(___);}
#if 0
# 636
{ 
# 637
return __float2bfloat16_rd(__int2float_rd(i)); 
# 638
} 
#endif
# 639 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __int2bfloat16_ru(const int i) 
# 640
{int volatile ___ = 1;(void)i;
# 642
::exit(___);}
#if 0
# 640
{ 
# 641
return __float2bfloat16_ru(__int2float_ru(i)); 
# 642
} 
#endif
# 644 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline short __bfloat162short_rn(const __nv_bfloat16 h) 
# 645
{int volatile ___ = 1;(void)h;
# 652
::exit(___);}
#if 0
# 645
{ 
# 646
short val; 
# 647
__asm__("{ .reg.f32 f;\n  mov.b32 f, {0,%1};\n  cvt.rni.s16.f32 %0,f;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 651
return val; 
# 652
} 
#endif
# 653 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline short __bfloat162short_rz(const __nv_bfloat16 h) 
# 654
{ 
# 655
short val; 
# 662
const float f = __bfloat162float(h); 
# 663
val = (static_cast< short>(f)); 
# 664
const short max_val = ((short)32767U); 
# 665
const short min_val = ((short)32768U); 
# 666
const unsigned short bits = static_cast< unsigned short>((((__nv_bfloat16_raw)h).x) << 1U); 
# 668
if (bits > ((unsigned short)65280U)) { 
# 670
val = (0); 
# 671
} else { if (f > (static_cast< float>(max_val))) { 
# 673
val = max_val; 
# 674
} else { if (f < (static_cast< float>(min_val))) { 
# 676
val = min_val; 
# 677
}  }  }  
# 679
return val; 
# 680
} 
# 681
__attribute__((unused)) static inline short __bfloat162short_rd(const __nv_bfloat16 h) 
# 682
{int volatile ___ = 1;(void)h;
# 689
::exit(___);}
#if 0
# 682
{ 
# 683
short val; 
# 684
__asm__("{ .reg.f32 f;\n  mov.b32 f, {0,%1};\n  cvt.rmi.s16.f32 %0,f;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 688
return val; 
# 689
} 
#endif
# 690 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline short __bfloat162short_ru(const __nv_bfloat16 h) 
# 691
{int volatile ___ = 1;(void)h;
# 698
::exit(___);}
#if 0
# 691
{ 
# 692
short val; 
# 693
__asm__("{ .reg.f32 f;\n  mov.b32 f, {0,%1};\n  cvt.rpi.s16.f32 %0,f;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 697
return val; 
# 698
} 
#endif
# 699 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline __nv_bfloat16 __short2bfloat16_rn(const short i) 
# 700
{ 
# 701
const float f = static_cast< float>(i); 
# 702
return __float2bfloat16_rn(f); 
# 703
} 
# 704
__attribute__((unused)) static inline __nv_bfloat16 __short2bfloat16_rz(const short i) 
# 705
{int volatile ___ = 1;(void)i;
# 707
::exit(___);}
#if 0
# 705
{ 
# 706
return __float2bfloat16_rz(__int2float_rz(static_cast< int>(i))); 
# 707
} 
#endif
# 708 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __short2bfloat16_rd(const short i) 
# 709
{int volatile ___ = 1;(void)i;
# 711
::exit(___);}
#if 0
# 709
{ 
# 710
return __float2bfloat16_rd(__int2float_rd(static_cast< int>(i))); 
# 711
} 
#endif
# 712 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __short2bfloat16_ru(const short i) 
# 713
{int volatile ___ = 1;(void)i;
# 715
::exit(___);}
#if 0
# 713
{ 
# 714
return __float2bfloat16_ru(__int2float_ru(static_cast< int>(i))); 
# 715
} 
#endif
# 717 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline unsigned __bfloat162uint_rn(const __nv_bfloat16 h) 
# 718
{int volatile ___ = 1;(void)h;
# 720
::exit(___);}
#if 0
# 718
{ 
# 719
return __float2uint_rn(__bfloat162float(h)); 
# 720
} 
#endif
# 721 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline unsigned __bfloat162uint_rz(const __nv_bfloat16 h) 
# 722
{ 
# 723
const float f = __bfloat162float(h); 
# 724
unsigned i; 
# 725
i = (static_cast< unsigned>(f)); 
# 727
const unsigned max_val = 4294967295U; 
# 728
const unsigned min_val = 0U; 
# 729
const unsigned short bits = static_cast< unsigned short>((((__nv_bfloat16_raw)h).x) << 1U); 
# 731
if (bits > ((unsigned short)65280U)) { 
# 733
i = 0U; 
# 734
} else { if (f >= (static_cast< float>(max_val))) { 
# 736
i = max_val; 
# 737
} else { if (f < (static_cast< float>(min_val))) { 
# 739
i = min_val; 
# 740
}  }  }  
# 742
return i; 
# 743
} 
# 744
__attribute__((unused)) static inline unsigned __bfloat162uint_rd(const __nv_bfloat16 h) 
# 745
{int volatile ___ = 1;(void)h;
# 747
::exit(___);}
#if 0
# 745
{ 
# 746
return __float2uint_rd(__bfloat162float(h)); 
# 747
} 
#endif
# 748 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline unsigned __bfloat162uint_ru(const __nv_bfloat16 h) 
# 749
{int volatile ___ = 1;(void)h;
# 751
::exit(___);}
#if 0
# 749
{ 
# 750
return __float2uint_ru(__bfloat162float(h)); 
# 751
} 
#endif
# 752 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline __nv_bfloat16 __uint2bfloat16_rn(const unsigned i) 
# 753
{ 
# 763 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
const double d = static_cast< double>(i); 
# 764
return __double2bfloat16(d); 
# 766
} 
# 767
__attribute__((unused)) static inline __nv_bfloat16 __uint2bfloat16_rz(const unsigned i) 
# 768
{int volatile ___ = 1;(void)i;
# 770
::exit(___);}
#if 0
# 768
{ 
# 769
return __float2bfloat16_rz(__uint2float_rz(i)); 
# 770
} 
#endif
# 771 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __uint2bfloat16_rd(const unsigned i) 
# 772
{int volatile ___ = 1;(void)i;
# 774
::exit(___);}
#if 0
# 772
{ 
# 773
return __float2bfloat16_rd(__uint2float_rd(i)); 
# 774
} 
#endif
# 775 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __uint2bfloat16_ru(const unsigned i) 
# 776
{int volatile ___ = 1;(void)i;
# 778
::exit(___);}
#if 0
# 776
{ 
# 777
return __float2bfloat16_ru(__uint2float_ru(i)); 
# 778
} 
#endif
# 780 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline unsigned short __bfloat162ushort_rn(const __nv_bfloat16 h) 
# 781
{int volatile ___ = 1;(void)h;
# 788
::exit(___);}
#if 0
# 781
{ 
# 782
unsigned short val; 
# 783
__asm__("{ .reg.f32 f;\n  mov.b32 f, {0,%1};\n  cvt.rni.u16.f32 %0,f;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 787
return val; 
# 788
} 
#endif
# 789 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline unsigned short __bfloat162ushort_rz(const __nv_bfloat16 h) 
# 790
{ 
# 791
unsigned short val; 
# 798
const float f = __bfloat162float(h); 
# 799
val = (static_cast< unsigned short>(f)); 
# 800
const unsigned short max_val = (65535U); 
# 801
const unsigned short min_val = (0U); 
# 802
const unsigned short bits = static_cast< unsigned short>((((__nv_bfloat16_raw)h).x) << 1U); 
# 804
if (bits > ((unsigned short)65280U)) { 
# 806
val = (0U); 
# 807
} else { if (f > (static_cast< float>(max_val))) { 
# 809
val = max_val; 
# 810
} else { if (f < (static_cast< float>(min_val))) { 
# 812
val = min_val; 
# 813
}  }  }  
# 815
return val; 
# 816
} 
# 817
__attribute__((unused)) static inline unsigned short __bfloat162ushort_rd(const __nv_bfloat16 h) 
# 818
{int volatile ___ = 1;(void)h;
# 825
::exit(___);}
#if 0
# 818
{ 
# 819
unsigned short val; 
# 820
__asm__("{ .reg.f32 f;\n  mov.b32 f, {0,%1};\n  cvt.rmi.u16.f32 %0,f;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 824
return val; 
# 825
} 
#endif
# 826 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline unsigned short __bfloat162ushort_ru(const __nv_bfloat16 h) 
# 827
{int volatile ___ = 1;(void)h;
# 834
::exit(___);}
#if 0
# 827
{ 
# 828
unsigned short val; 
# 829
__asm__("{ .reg.f32 f;\n  mov.b32 f, {0,%1};\n  cvt.rpi.u16.f32 %0,f;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&h)))); 
# 833
return val; 
# 834
} 
#endif
# 835 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline __nv_bfloat16 __ushort2bfloat16_rn(const unsigned short i) 
# 836
{ 
# 837
const float f = static_cast< float>(i); 
# 838
return __float2bfloat16_rn(f); 
# 839
} 
# 840
__attribute__((unused)) static inline __nv_bfloat16 __ushort2bfloat16_rz(const unsigned short i) 
# 841
{int volatile ___ = 1;(void)i;
# 843
::exit(___);}
#if 0
# 841
{ 
# 842
return __float2bfloat16_rz(__uint2float_rz(static_cast< unsigned>(i))); 
# 843
} 
#endif
# 844 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ushort2bfloat16_rd(const unsigned short i) 
# 845
{int volatile ___ = 1;(void)i;
# 847
::exit(___);}
#if 0
# 845
{ 
# 846
return __float2bfloat16_rd(__uint2float_rd(static_cast< unsigned>(i))); 
# 847
} 
#endif
# 848 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ushort2bfloat16_ru(const unsigned short i) 
# 849
{int volatile ___ = 1;(void)i;
# 851
::exit(___);}
#if 0
# 849
{ 
# 850
return __float2bfloat16_ru(__uint2float_ru(static_cast< unsigned>(i))); 
# 851
} 
#endif
# 853 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline unsigned long long __bfloat162ull_rn(const __nv_bfloat16 h) 
# 854
{int volatile ___ = 1;(void)h;
# 856
::exit(___);}
#if 0
# 854
{ 
# 855
return __float2ull_rn(__bfloat162float(h)); 
# 856
} 
#endif
# 857 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline unsigned long long __bfloat162ull_rz(const __nv_bfloat16 h) 
# 858
{ 
# 859
const float f = __bfloat162float(h); 
# 860
unsigned long long i; 
# 861
i = (static_cast< unsigned long long>(f)); 
# 863
const unsigned long long max_val = 18446744073709551615ULL; 
# 864
const unsigned long long min_val = 0ULL; 
# 865
const unsigned short bits = static_cast< unsigned short>((((__nv_bfloat16_raw)h).x) << 1U); 
# 867
if (bits > ((unsigned short)65280U)) { 
# 869
i = 9223372036854775808ULL; 
# 870
} else { if (f >= (static_cast< float>(max_val))) { 
# 872
i = max_val; 
# 873
} else { if (f < (static_cast< float>(min_val))) { 
# 875
i = min_val; 
# 876
}  }  }  
# 878
return i; 
# 879
} 
# 880
__attribute__((unused)) static inline unsigned long long __bfloat162ull_rd(const __nv_bfloat16 h) 
# 881
{int volatile ___ = 1;(void)h;
# 883
::exit(___);}
#if 0
# 881
{ 
# 882
return __float2ull_rd(__bfloat162float(h)); 
# 883
} 
#endif
# 884 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline unsigned long long __bfloat162ull_ru(const __nv_bfloat16 h) 
# 885
{int volatile ___ = 1;(void)h;
# 887
::exit(___);}
#if 0
# 885
{ 
# 886
return __float2ull_ru(__bfloat162float(h)); 
# 887
} 
#endif
# 888 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline __nv_bfloat16 __ull2bfloat16_rn(const unsigned long long i) 
# 889
{ 
# 899 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
float f = static_cast< float>(i); 
# 900
const unsigned long long uf = static_cast< unsigned long long>(f); 
# 901
unsigned u; 
# 906
(void)memcpy(&u, &f, sizeof f); 
# 913
if (uf > i) { 
# 914
u--; 
# 915
}  
# 916
if (uf != i) { 
# 917
u |= 1U; 
# 918
}  
# 923
(void)memcpy(&f, &u, sizeof f); 
# 928
return __float2bfloat16_rn(f); 
# 930
} 
# 931
__attribute__((unused)) static inline __nv_bfloat16 __ull2bfloat16_rz(const unsigned long long i) 
# 932
{int volatile ___ = 1;(void)i;
# 934
::exit(___);}
#if 0
# 932
{ 
# 933
return __float2bfloat16_rz(__ull2float_rz(i)); 
# 934
} 
#endif
# 935 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ull2bfloat16_rd(const unsigned long long i) 
# 936
{int volatile ___ = 1;(void)i;
# 938
::exit(___);}
#if 0
# 936
{ 
# 937
return __float2bfloat16_rd(__ull2float_rd(i)); 
# 938
} 
#endif
# 939 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ull2bfloat16_ru(const unsigned long long i) 
# 940
{int volatile ___ = 1;(void)i;
# 942
::exit(___);}
#if 0
# 940
{ 
# 941
return __float2bfloat16_ru(__ull2float_ru(i)); 
# 942
} 
#endif
# 943 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline long long __bfloat162ll_rn(const __nv_bfloat16 h) 
# 944
{int volatile ___ = 1;(void)h;
# 946
::exit(___);}
#if 0
# 944
{ 
# 945
return __float2ll_rn(__bfloat162float(h)); 
# 946
} 
#endif
# 947 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline long long __bfloat162ll_rz(const __nv_bfloat16 h) 
# 948
{ 
# 949
const float f = __bfloat162float(h); 
# 950
long long i; 
# 951
i = (static_cast< long long>(f)); 
# 953
const long long max_val = ((long long)9223372036854775807ULL); 
# 954
const long long min_val = ((long long)9223372036854775808ULL); 
# 955
const unsigned short bits = static_cast< unsigned short>((((__nv_bfloat16_raw)h).x) << 1U); 
# 957
if (bits > ((unsigned short)65280U)) { 
# 959
i = min_val; 
# 960
} else { if (f >= (static_cast< float>(max_val))) { 
# 962
i = max_val; 
# 963
} else { if (f < (static_cast< float>(min_val))) { 
# 965
i = min_val; 
# 966
}  }  }  
# 968
return i; 
# 969
} 
# 970
__attribute__((unused)) static inline long long __bfloat162ll_rd(const __nv_bfloat16 h) 
# 971
{int volatile ___ = 1;(void)h;
# 973
::exit(___);}
#if 0
# 971
{ 
# 972
return __float2ll_rd(__bfloat162float(h)); 
# 973
} 
#endif
# 974 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline long long __bfloat162ll_ru(const __nv_bfloat16 h) 
# 975
{int volatile ___ = 1;(void)h;
# 977
::exit(___);}
#if 0
# 975
{ 
# 976
return __float2ll_ru(__bfloat162float(h)); 
# 977
} 
#endif
# 978 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
static inline __nv_bfloat16 __ll2bfloat16_rn(const long long i) 
# 979
{ 
# 989 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
float f = static_cast< float>(i); 
# 990
const long long lf = static_cast< long long>(f); 
# 991
unsigned u; 
# 996
(void)memcpy(&u, &f, sizeof f); 
# 1001
if ((f > (0.0F)) && (lf > i)) { 
# 1002
u--; 
# 1003
}  
# 1004
if ((f < (0.0F)) && (lf < i)) { 
# 1005
u--; 
# 1006
}  
# 1007
if (lf != i) { 
# 1008
u |= 1U; 
# 1009
}  
# 1014
(void)memcpy(&f, &u, sizeof f); 
# 1019
return __float2bfloat16_rn(f); 
# 1021
} 
# 1022
__attribute__((unused)) static inline __nv_bfloat16 __ll2bfloat16_rz(const long long i) 
# 1023
{int volatile ___ = 1;(void)i;
# 1025
::exit(___);}
#if 0
# 1023
{ 
# 1024
return __float2bfloat16_rz(__ll2float_rz(i)); 
# 1025
} 
#endif
# 1026 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ll2bfloat16_rd(const long long i) 
# 1027
{int volatile ___ = 1;(void)i;
# 1029
::exit(___);}
#if 0
# 1027
{ 
# 1028
return __float2bfloat16_rd(__ll2float_rd(i)); 
# 1029
} 
#endif
# 1030 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ll2bfloat16_ru(const long long i) 
# 1031
{int volatile ___ = 1;(void)i;
# 1033
::exit(___);}
#if 0
# 1031
{ 
# 1032
return __float2bfloat16_ru(__ll2float_ru(i)); 
# 1033
} 
#endif
# 1035 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 htrunc(const __nv_bfloat16 h) 
# 1036
{int volatile ___ = 1;(void)h;
# 1038
::exit(___);}
#if 0
# 1036
{ 
# 1037
return __float2bfloat16_rz(truncf(__bfloat162float(h))); 
# 1038
} 
#endif
# 1039 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hceil(const __nv_bfloat16 h) 
# 1040
{int volatile ___ = 1;(void)h;
# 1042
::exit(___);}
#if 0
# 1040
{ 
# 1041
return __float2bfloat16_ru(ceilf(__bfloat162float(h))); 
# 1042
} 
#endif
# 1043 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hfloor(const __nv_bfloat16 h) 
# 1044
{int volatile ___ = 1;(void)h;
# 1046
::exit(___);}
#if 0
# 1044
{ 
# 1045
return __float2bfloat16_rd(floorf(__bfloat162float(h))); 
# 1046
} 
#endif
# 1047 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hrint(const __nv_bfloat16 h) 
# 1048
{int volatile ___ = 1;(void)h;
# 1050
::exit(___);}
#if 0
# 1048
{ 
# 1049
return __float2bfloat16_rn(rintf(__bfloat162float(h))); 
# 1050
} 
#endif
# 1052 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2trunc(const __nv_bfloat162 h) 
# 1053
{int volatile ___ = 1;(void)h;
# 1057
::exit(___);}
#if 0
# 1053
{ 
# 1054
const __nv_bfloat16 low = __float2bfloat16_rz(truncf(__low2float(h))); 
# 1055
const __nv_bfloat16 high = __float2bfloat16_rz(truncf(__high2float(h))); 
# 1056
return __nv_bfloat162(low, high); 
# 1057
} 
#endif
# 1058 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2ceil(const __nv_bfloat162 h) 
# 1059
{int volatile ___ = 1;(void)h;
# 1063
::exit(___);}
#if 0
# 1059
{ 
# 1060
const __nv_bfloat16 low = __float2bfloat16_ru(ceilf(__low2float(h))); 
# 1061
const __nv_bfloat16 high = __float2bfloat16_ru(ceilf(__high2float(h))); 
# 1062
return __nv_bfloat162(low, high); 
# 1063
} 
#endif
# 1064 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2floor(const __nv_bfloat162 h) 
# 1065
{int volatile ___ = 1;(void)h;
# 1069
::exit(___);}
#if 0
# 1065
{ 
# 1066
const __nv_bfloat16 low = __float2bfloat16_rd(floorf(__low2float(h))); 
# 1067
const __nv_bfloat16 high = __float2bfloat16_rd(floorf(__high2float(h))); 
# 1068
return __nv_bfloat162(low, high); 
# 1069
} 
#endif
# 1071 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2rint(const __nv_bfloat162 h) 
# 1072
{int volatile ___ = 1;(void)h;
# 1074
::exit(___);}
#if 0
# 1072
{ 
# 1073
return __halves2bfloat162(hrint(__low2bfloat16(h)), hrint(__high2bfloat16(h))); 
# 1074
} 
#endif
# 1075 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __lows2bfloat162(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1076
{int volatile ___ = 1;(void)a;(void)b;
# 1083
::exit(___);}
#if 0
# 1076
{ 
# 1077
__nv_bfloat162 val; 
# 1078
__asm__("{.reg .b16 alow,ahigh,blow,bhigh;\n  mov.b32 {alow,ahigh}, %1;\n  mov.b32 {blow,bhigh}, %2;\n  mov.b32 %0, {alow,blow};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1082
return val; 
# 1083
} 
#endif
# 1084 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __highs2bfloat162(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1085
{int volatile ___ = 1;(void)a;(void)b;
# 1092
::exit(___);}
#if 0
# 1085
{ 
# 1086
__nv_bfloat162 val; 
# 1087
__asm__("{.reg .b16 alow,ahigh,blow,bhigh;\n  mov.b32 {alow,ahigh}, %1;\n  mov.b32 {blow,bhigh}, %2;\n  mov.b32 %0, {ahigh,bhigh};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1091
return val; 
# 1092
} 
#endif
# 1093 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __low2bfloat16(const __nv_bfloat162 a) 
# 1094
{int volatile ___ = 1;(void)a;
# 1100
::exit(___);}
#if 0
# 1094
{ 
# 1095
__nv_bfloat16 ret; 
# 1096
__asm__("{.reg .b16 low,high;\n mov.b32 {low,high}, %1;\n mov.b16 %0, low;}" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1099
return ret; 
# 1100
} 
#endif
# 1101 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline int __hisinf(const __nv_bfloat16 a) 
# 1102
{int volatile ___ = 1;(void)a;
# 1112
::exit(___);}
#if 0
# 1102
{ 
# 1103
int retval; 
# 1104
if ((*(reinterpret_cast< const unsigned short *>(&a))) == 65408U) { 
# 1105
retval = (-1); 
# 1106
} else { if ((*(reinterpret_cast< const unsigned short *>(&a))) == 32640U) { 
# 1107
retval = 1; 
# 1108
} else { 
# 1109
retval = 0; 
# 1110
}  }  
# 1111
return retval; 
# 1112
} 
#endif
# 1113 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __low2bfloat162(const __nv_bfloat162 a) 
# 1114
{int volatile ___ = 1;(void)a;
# 1120
::exit(___);}
#if 0
# 1114
{ 
# 1115
__nv_bfloat162 val; 
# 1116
__asm__("{.reg .b16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {low,low};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1119
return val; 
# 1120
} 
#endif
# 1121 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __high2bfloat162(const __nv_bfloat162 a) 
# 1122
{int volatile ___ = 1;(void)a;
# 1128
::exit(___);}
#if 0
# 1122
{ 
# 1123
__nv_bfloat162 val; 
# 1124
__asm__("{.reg .b16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {high,high};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1127
return val; 
# 1128
} 
#endif
# 1129 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __high2bfloat16(const __nv_bfloat162 a) 
# 1130
{int volatile ___ = 1;(void)a;
# 1136
::exit(___);}
#if 0
# 1130
{ 
# 1131
__nv_bfloat16 ret; 
# 1132
__asm__("{.reg .b16 low,high;\n mov.b32 {low,high}, %1;\n mov.b16 %0, high;}" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1135
return ret; 
# 1136
} 
#endif
# 1137 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __halves2bfloat162(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1138
{int volatile ___ = 1;(void)a;(void)b;
# 1143
::exit(___);}
#if 0
# 1138
{ 
# 1139
__nv_bfloat162 val; 
# 1140
__asm__("{  mov.b32 %0, {%1,%2};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1142
return val; 
# 1143
} 
#endif
# 1144 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __bfloat162bfloat162(const __nv_bfloat16 a) 
# 1145
{int volatile ___ = 1;(void)a;
# 1150
::exit(___);}
#if 0
# 1145
{ 
# 1146
__nv_bfloat162 val; 
# 1147
__asm__("{  mov.b32 %0, {%1,%1};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 1149
return val; 
# 1150
} 
#endif
# 1151 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __lowhigh2highlow(const __nv_bfloat162 a) 
# 1152
{int volatile ___ = 1;(void)a;
# 1158
::exit(___);}
#if 0
# 1152
{ 
# 1153
__nv_bfloat162 val; 
# 1154
__asm__("{.reg .b16 low,high;\n  mov.b32 {low,high}, %1;\n  mov.b32 %0, {high,low};}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1157
return val; 
# 1158
} 
#endif
# 1159 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline short __bfloat16_as_short(const __nv_bfloat16 h) 
# 1160
{int volatile ___ = 1;(void)h;
# 1162
::exit(___);}
#if 0
# 1160
{ 
# 1161
return static_cast< short>(*(reinterpret_cast< const unsigned short *>(&h))); 
# 1162
} 
#endif
# 1163 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline unsigned short __bfloat16_as_ushort(const __nv_bfloat16 h) 
# 1164
{int volatile ___ = 1;(void)h;
# 1166
::exit(___);}
#if 0
# 1164
{ 
# 1165
return *(reinterpret_cast< const unsigned short *>(&h)); 
# 1166
} 
#endif
# 1167 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __short_as_bfloat16(const short i) 
# 1168
{int volatile ___ = 1;(void)i;
# 1172
::exit(___);}
#if 0
# 1168
{ 
# 1169
__nv_bfloat16 h; 
# 1170
(*(reinterpret_cast< unsigned short *>(&h))) = (static_cast< unsigned short>(i)); 
# 1171
return h; 
# 1172
} 
#endif
# 1173 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ushort_as_bfloat16(const unsigned short i) 
# 1174
{int volatile ___ = 1;(void)i;
# 1178
::exit(___);}
#if 0
# 1174
{ 
# 1175
__nv_bfloat16 h; 
# 1176
(*(reinterpret_cast< unsigned short *>(&h))) = i; 
# 1177
return h; 
# 1178
} 
#endif
# 1190 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __shfl_sync(const unsigned mask, const __nv_bfloat162 var, const int delta, const int width) 
# 1191
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1196
::exit(___);}
#if 0
# 1191
{ 
# 1192
unsigned warp_size; 
# 1193
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1194
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1195
{ __nv_bfloat162 r; __asm__ volatile("{shfl.sync.idx.b32 %0,%1,%2,%3,%4;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c), "r" (mask)); return r; } 
# 1196
} 
#endif
# 1197 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __shfl_up_sync(const unsigned mask, const __nv_bfloat162 var, const unsigned delta, const int width) 
# 1198
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1203
::exit(___);}
#if 0
# 1198
{ 
# 1199
unsigned warp_size; 
# 1200
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1201
const unsigned c = (warp_size - (static_cast< unsigned>(width))) << 8U; 
# 1202
{ __nv_bfloat162 r; __asm__ volatile("{shfl.sync.up.b32 %0,%1,%2,%3,%4;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c), "r" (mask)); return r; } 
# 1203
} 
#endif
# 1204 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __shfl_down_sync(const unsigned mask, const __nv_bfloat162 var, const unsigned delta, const int width) 
# 1205
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1210
::exit(___);}
#if 0
# 1205
{ 
# 1206
unsigned warp_size; 
# 1207
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1208
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1209
{ __nv_bfloat162 r; __asm__ volatile("{shfl.sync.down.b32 %0,%1,%2,%3,%4;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c), "r" (mask)); return r; } 
# 1210
} 
#endif
# 1211 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __shfl_xor_sync(const unsigned mask, const __nv_bfloat162 var, const int delta, const int width) 
# 1212
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1217
::exit(___);}
#if 0
# 1212
{ 
# 1213
unsigned warp_size; 
# 1214
__asm__("{mov.u32 %0, WARP_SZ;\n}" : "=r" (warp_size) :); 
# 1215
const unsigned c = ((warp_size - (static_cast< unsigned>(width))) << 8U) | 31U; 
# 1216
{ __nv_bfloat162 r; __asm__ volatile("{shfl.sync.bfly.b32 %0,%1,%2,%3,%4;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&var))), "r" (delta), "r" (c), "r" (mask)); return r; } 
# 1217
} 
#endif
# 1221 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __shfl_sync(const unsigned mask, const __nv_bfloat16 var, const int delta, const int width) 
# 1222
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1226
::exit(___);}
#if 0
# 1222
{ 
# 1223
const __nv_bfloat162 temp1 = __halves2bfloat162(var, var); 
# 1224
const __nv_bfloat162 temp2 = __shfl_sync(mask, temp1, delta, width); 
# 1225
return __low2bfloat16(temp2); 
# 1226
} 
#endif
# 1227 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __shfl_up_sync(const unsigned mask, const __nv_bfloat16 var, const unsigned delta, const int width) 
# 1228
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1232
::exit(___);}
#if 0
# 1228
{ 
# 1229
const __nv_bfloat162 temp1 = __halves2bfloat162(var, var); 
# 1230
const __nv_bfloat162 temp2 = __shfl_up_sync(mask, temp1, delta, width); 
# 1231
return __low2bfloat16(temp2); 
# 1232
} 
#endif
# 1233 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __shfl_down_sync(const unsigned mask, const __nv_bfloat16 var, const unsigned delta, const int width) 
# 1234
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1238
::exit(___);}
#if 0
# 1234
{ 
# 1235
const __nv_bfloat162 temp1 = __halves2bfloat162(var, var); 
# 1236
const __nv_bfloat162 temp2 = __shfl_down_sync(mask, temp1, delta, width); 
# 1237
return __low2bfloat16(temp2); 
# 1238
} 
#endif
# 1239 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __shfl_xor_sync(const unsigned mask, const __nv_bfloat16 var, const int delta, const int width) 
# 1240
{int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;
# 1244
::exit(___);}
#if 0
# 1240
{ 
# 1241
const __nv_bfloat162 temp1 = __halves2bfloat162(var, var); 
# 1242
const __nv_bfloat162 temp2 = __shfl_xor_sync(mask, temp1, delta, width); 
# 1243
return __low2bfloat16(temp2); 
# 1244
} 
#endif
# 1256 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __ldg(const __nv_bfloat162 *const ptr) 
# 1257
{int volatile ___ = 1;(void)ptr;
# 1261
::exit(___);}
#if 0
# 1257
{ 
# 1258
__nv_bfloat162 ret; 
# 1259
__asm__("ld.global.nc.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr)); 
# 1260
return ret; 
# 1261
} 
#endif
# 1262 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ldg(const __nv_bfloat16 *const ptr) 
# 1263
{int volatile ___ = 1;(void)ptr;
# 1267
::exit(___);}
#if 0
# 1263
{ 
# 1264
__nv_bfloat16 ret; 
# 1265
__asm__("ld.global.nc.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr)); 
# 1266
return ret; 
# 1267
} 
#endif
# 1268 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __ldcg(const __nv_bfloat162 *const ptr) 
# 1269
{int volatile ___ = 1;(void)ptr;
# 1273
::exit(___);}
#if 0
# 1269
{ 
# 1270
__nv_bfloat162 ret; 
# 1271
__asm__("ld.global.cg.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr)); 
# 1272
return ret; 
# 1273
} 
#endif
# 1274 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ldcg(const __nv_bfloat16 *const ptr) 
# 1275
{int volatile ___ = 1;(void)ptr;
# 1279
::exit(___);}
#if 0
# 1275
{ 
# 1276
__nv_bfloat16 ret; 
# 1277
__asm__("ld.global.cg.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr)); 
# 1278
return ret; 
# 1279
} 
#endif
# 1280 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __ldca(const __nv_bfloat162 *const ptr) 
# 1281
{int volatile ___ = 1;(void)ptr;
# 1285
::exit(___);}
#if 0
# 1281
{ 
# 1282
__nv_bfloat162 ret; 
# 1283
__asm__("ld.global.ca.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr)); 
# 1284
return ret; 
# 1285
} 
#endif
# 1286 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ldca(const __nv_bfloat16 *const ptr) 
# 1287
{int volatile ___ = 1;(void)ptr;
# 1291
::exit(___);}
#if 0
# 1287
{ 
# 1288
__nv_bfloat16 ret; 
# 1289
__asm__("ld.global.ca.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr)); 
# 1290
return ret; 
# 1291
} 
#endif
# 1292 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __ldcs(const __nv_bfloat162 *const ptr) 
# 1293
{int volatile ___ = 1;(void)ptr;
# 1297
::exit(___);}
#if 0
# 1293
{ 
# 1294
__nv_bfloat162 ret; 
# 1295
__asm__("ld.global.cs.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr)); 
# 1296
return ret; 
# 1297
} 
#endif
# 1298 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ldcs(const __nv_bfloat16 *const ptr) 
# 1299
{int volatile ___ = 1;(void)ptr;
# 1303
::exit(___);}
#if 0
# 1299
{ 
# 1300
__nv_bfloat16 ret; 
# 1301
__asm__("ld.global.cs.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr)); 
# 1302
return ret; 
# 1303
} 
#endif
# 1304 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __ldlu(const __nv_bfloat162 *const ptr) 
# 1305
{int volatile ___ = 1;(void)ptr;
# 1309
::exit(___);}
#if 0
# 1305
{ 
# 1306
__nv_bfloat162 ret; 
# 1307
__asm__("ld.global.lu.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr) : "memory"); 
# 1308
return ret; 
# 1309
} 
#endif
# 1310 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ldlu(const __nv_bfloat16 *const ptr) 
# 1311
{int volatile ___ = 1;(void)ptr;
# 1315
::exit(___);}
#if 0
# 1311
{ 
# 1312
__nv_bfloat16 ret; 
# 1313
__asm__("ld.global.lu.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr) : "memory"); 
# 1314
return ret; 
# 1315
} 
#endif
# 1316 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __ldcv(const __nv_bfloat162 *const ptr) 
# 1317
{int volatile ___ = 1;(void)ptr;
# 1321
::exit(___);}
#if 0
# 1317
{ 
# 1318
__nv_bfloat162 ret; 
# 1319
__asm__("ld.global.cv.b32 %0, [%1];" : "=r" (*(reinterpret_cast< unsigned *>(&ret))) : "l" (ptr) : "memory"); 
# 1320
return ret; 
# 1321
} 
#endif
# 1322 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __ldcv(const __nv_bfloat16 *const ptr) 
# 1323
{int volatile ___ = 1;(void)ptr;
# 1327
::exit(___);}
#if 0
# 1323
{ 
# 1324
__nv_bfloat16 ret; 
# 1325
__asm__("ld.global.cv.b16 %0, [%1];" : "=h" (*(reinterpret_cast< unsigned short *>(&ret))) : "l" (ptr) : "memory"); 
# 1326
return ret; 
# 1327
} 
#endif
# 1329 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline void __stwb(__nv_bfloat162 *const ptr, const __nv_bfloat162 value) 
# 1330
{int volatile ___ = 1;(void)ptr;(void)value;
# 1332
::exit(___);}
#if 0
# 1330
{ 
# 1331
__asm__("st.global.wb.b32 [%0], %1;" : : "l" (ptr), "r" (*(reinterpret_cast< const unsigned *>(&value))) : "memory"); 
# 1332
} 
#endif
# 1333 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline void __stwb(__nv_bfloat16 *const ptr, const __nv_bfloat16 value) 
# 1334
{int volatile ___ = 1;(void)ptr;(void)value;
# 1336
::exit(___);}
#if 0
# 1334
{ 
# 1335
__asm__("st.global.wb.b16 [%0], %1;" : : "l" (ptr), "h" (*(reinterpret_cast< const unsigned short *>(&value))) : "memory"); 
# 1336
} 
#endif
# 1337 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline void __stcg(__nv_bfloat162 *const ptr, const __nv_bfloat162 value) 
# 1338
{int volatile ___ = 1;(void)ptr;(void)value;
# 1340
::exit(___);}
#if 0
# 1338
{ 
# 1339
__asm__("st.global.cg.b32 [%0], %1;" : : "l" (ptr), "r" (*(reinterpret_cast< const unsigned *>(&value))) : "memory"); 
# 1340
} 
#endif
# 1341 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline void __stcg(__nv_bfloat16 *const ptr, const __nv_bfloat16 value) 
# 1342
{int volatile ___ = 1;(void)ptr;(void)value;
# 1344
::exit(___);}
#if 0
# 1342
{ 
# 1343
__asm__("st.global.cg.b16 [%0], %1;" : : "l" (ptr), "h" (*(reinterpret_cast< const unsigned short *>(&value))) : "memory"); 
# 1344
} 
#endif
# 1345 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline void __stcs(__nv_bfloat162 *const ptr, const __nv_bfloat162 value) 
# 1346
{int volatile ___ = 1;(void)ptr;(void)value;
# 1348
::exit(___);}
#if 0
# 1346
{ 
# 1347
__asm__("st.global.cs.b32 [%0], %1;" : : "l" (ptr), "r" (*(reinterpret_cast< const unsigned *>(&value))) : "memory"); 
# 1348
} 
#endif
# 1349 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline void __stcs(__nv_bfloat16 *const ptr, const __nv_bfloat16 value) 
# 1350
{int volatile ___ = 1;(void)ptr;(void)value;
# 1352
::exit(___);}
#if 0
# 1350
{ 
# 1351
__asm__("st.global.cs.b16 [%0], %1;" : : "l" (ptr), "h" (*(reinterpret_cast< const unsigned short *>(&value))) : "memory"); 
# 1352
} 
#endif
# 1353 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline void __stwt(__nv_bfloat162 *const ptr, const __nv_bfloat162 value) 
# 1354
{int volatile ___ = 1;(void)ptr;(void)value;
# 1356
::exit(___);}
#if 0
# 1354
{ 
# 1355
__asm__("st.global.wt.b32 [%0], %1;" : : "l" (ptr), "r" (*(reinterpret_cast< const unsigned *>(&value))) : "memory"); 
# 1356
} 
#endif
# 1357 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline void __stwt(__nv_bfloat16 *const ptr, const __nv_bfloat16 value) 
# 1358
{int volatile ___ = 1;(void)ptr;(void)value;
# 1360
::exit(___);}
#if 0
# 1358
{ 
# 1359
__asm__("st.global.wt.b16 [%0], %1;" : : "l" (ptr), "h" (*(reinterpret_cast< const unsigned short *>(&value))) : "memory"); 
# 1360
} 
#endif
# 1381 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __heq2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1382
{int volatile ___ = 1;(void)a;(void)b;
# 1384
::exit(___);}
#if 0
# 1382
{ 
# 1383
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.eq.f32.f32 low_res, low_a, low_b;\n  set.eq.f32.f32 high_res, high_a, " "high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1384
} 
#endif
# 1385 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hne2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1386
{int volatile ___ = 1;(void)a;(void)b;
# 1388
::exit(___);}
#if 0
# 1386
{ 
# 1387
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.ne.f32.f32 low_res, low_a, low_b;\n  set.ne.f32.f32 high_res, high_a, " "high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1388
} 
#endif
# 1389 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hle2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1390
{int volatile ___ = 1;(void)a;(void)b;
# 1392
::exit(___);}
#if 0
# 1390
{ 
# 1391
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.le.f32.f32 low_res, low_a, low_b;\n  set.le.f32.f32 high_res, high_a, " "high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1392
} 
#endif
# 1393 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hge2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1394
{int volatile ___ = 1;(void)a;(void)b;
# 1396
::exit(___);}
#if 0
# 1394
{ 
# 1395
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.ge.f32.f32 low_res, low_a, low_b;\n  set.ge.f32.f32 high_res, high_a, " "high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1396
} 
#endif
# 1397 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hlt2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1398
{int volatile ___ = 1;(void)a;(void)b;
# 1400
::exit(___);}
#if 0
# 1398
{ 
# 1399
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.lt.f32.f32 low_res, low_a, low_b;\n  set.lt.f32.f32 high_res, high_a, " "high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1400
} 
#endif
# 1401 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hgt2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1402
{int volatile ___ = 1;(void)a;(void)b;
# 1404
::exit(___);}
#if 0
# 1402
{ 
# 1403
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.gt.f32.f32 low_res, low_a, low_b;\n  set.gt.f32.f32 high_res, high_a, " "high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1404
} 
#endif
# 1405 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hequ2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1406
{int volatile ___ = 1;(void)a;(void)b;
# 1408
::exit(___);}
#if 0
# 1406
{ 
# 1407
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.equ.f32.f32 low_res, low_a, low_b;\n  set.equ.f32.f32 high_res, high_a" ", high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1408
} 
#endif
# 1409 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hneu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1410
{int volatile ___ = 1;(void)a;(void)b;
# 1412
::exit(___);}
#if 0
# 1410
{ 
# 1411
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.neu.f32.f32 low_res, low_a, low_b;\n  set.neu.f32.f32 high_res, high_a" ", high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1412
} 
#endif
# 1413 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hleu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1414
{int volatile ___ = 1;(void)a;(void)b;
# 1416
::exit(___);}
#if 0
# 1414
{ 
# 1415
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.leu.f32.f32 low_res, low_a, low_b;\n  set.leu.f32.f32 high_res, high_a" ", high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1416
} 
#endif
# 1417 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hgeu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1418
{int volatile ___ = 1;(void)a;(void)b;
# 1420
::exit(___);}
#if 0
# 1418
{ 
# 1419
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.geu.f32.f32 low_res, low_a, low_b;\n  set.geu.f32.f32 high_res, high_a" ", high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1420
} 
#endif
# 1421 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hltu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1422
{int volatile ___ = 1;(void)a;(void)b;
# 1424
::exit(___);}
#if 0
# 1422
{ 
# 1423
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.ltu.f32.f32 low_res, low_a, low_b;\n  set.ltu.f32.f32 high_res, high_a" ", high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1424
} 
#endif
# 1425 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hgtu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1426
{int volatile ___ = 1;(void)a;(void)b;
# 1428
::exit(___);}
#if 0
# 1426
{ 
# 1427
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.gtu.f32.f32 low_res, low_a, low_b;\n  set.gtu.f32.f32 high_res, high_a" ", high_b;\n  shr.u32 low_res, low_res, 16;\n  or.b32  %0, high_res, low_res;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 1428
} 
#endif
# 1443 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbeq2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1444
{int volatile ___ = 1;(void)a;(void)b;
# 1446
::exit(___);}
#if 0
# 1444
{ 
# 1445
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.eq.f32.f32 low_res, low_a, low_b;\n  set.eq.f32.f32 high_res, high_a, " "high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1446
} 
#endif
# 1447 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbne2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1448
{int volatile ___ = 1;(void)a;(void)b;
# 1450
::exit(___);}
#if 0
# 1448
{ 
# 1449
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.ne.f32.f32 low_res, low_a, low_b;\n  set.ne.f32.f32 high_res, high_a, " "high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1450
} 
#endif
# 1451 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hble2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1452
{int volatile ___ = 1;(void)a;(void)b;
# 1454
::exit(___);}
#if 0
# 1452
{ 
# 1453
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.le.f32.f32 low_res, low_a, low_b;\n  set.le.f32.f32 high_res, high_a, " "high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1454
} 
#endif
# 1455 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbge2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1456
{int volatile ___ = 1;(void)a;(void)b;
# 1458
::exit(___);}
#if 0
# 1456
{ 
# 1457
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.ge.f32.f32 low_res, low_a, low_b;\n  set.ge.f32.f32 high_res, high_a, " "high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1458
} 
#endif
# 1459 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hblt2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1460
{int volatile ___ = 1;(void)a;(void)b;
# 1462
::exit(___);}
#if 0
# 1460
{ 
# 1461
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.lt.f32.f32 low_res, low_a, low_b;\n  set.lt.f32.f32 high_res, high_a, " "high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1462
} 
#endif
# 1463 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbgt2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1464
{int volatile ___ = 1;(void)a;(void)b;
# 1466
::exit(___);}
#if 0
# 1464
{ 
# 1465
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.gt.f32.f32 low_res, low_a, low_b;\n  set.gt.f32.f32 high_res, high_a, " "high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1466
} 
#endif
# 1467 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbequ2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1468
{int volatile ___ = 1;(void)a;(void)b;
# 1470
::exit(___);}
#if 0
# 1468
{ 
# 1469
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.equ.f32.f32 low_res, low_a, low_b;\n  set.equ.f32.f32 high_res, high_a" ", high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1470
} 
#endif
# 1471 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbneu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1472
{int volatile ___ = 1;(void)a;(void)b;
# 1474
::exit(___);}
#if 0
# 1472
{ 
# 1473
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.neu.f32.f32 low_res, low_a, low_b;\n  set.neu.f32.f32 high_res, high_a" ", high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1474
} 
#endif
# 1475 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbleu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1476
{int volatile ___ = 1;(void)a;(void)b;
# 1478
::exit(___);}
#if 0
# 1476
{ 
# 1477
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.leu.f32.f32 low_res, low_a, low_b;\n  set.leu.f32.f32 high_res, high_a" ", high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1478
} 
#endif
# 1479 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbgeu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1480
{int volatile ___ = 1;(void)a;(void)b;
# 1482
::exit(___);}
#if 0
# 1480
{ 
# 1481
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.geu.f32.f32 low_res, low_a, low_b;\n  set.geu.f32.f32 high_res, high_a" ", high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1482
} 
#endif
# 1483 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbltu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1484
{int volatile ___ = 1;(void)a;(void)b;
# 1486
::exit(___);}
#if 0
# 1484
{ 
# 1485
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.ltu.f32.f32 low_res, low_a, low_b;\n  set.ltu.f32.f32 high_res, high_a" ", high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1486
} 
#endif
# 1487 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hbgtu2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1488
{int volatile ___ = 1;(void)a;(void)b;
# 1490
::exit(___);}
#if 0
# 1488
{ 
# 1489
{ unsigned val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high_b, %2, 0xffff0000U;\n" "  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.gtu.f32.f32 low_res, low_a, low_b;\n  set.gtu.f32.f32 high_res, high_a" ", high_b;\n  and.b32 %0, high_res, low_res;}\n" : "=r" (val) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return (val != 0U) ? true : false; } 
# 1490
} 
#endif
# 1504 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __heq(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1505
{int volatile ___ = 1;(void)a;(void)b;
# 1507
::exit(___);}
#if 0
# 1505
{ 
# 1506
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.eq.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1507
} 
#endif
# 1508 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hne(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1509
{int volatile ___ = 1;(void)a;(void)b;
# 1511
::exit(___);}
#if 0
# 1509
{ 
# 1510
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.ne.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1511
} 
#endif
# 1512 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hle(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1513
{int volatile ___ = 1;(void)a;(void)b;
# 1515
::exit(___);}
#if 0
# 1513
{ 
# 1514
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.le.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1515
} 
#endif
# 1516 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hge(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1517
{int volatile ___ = 1;(void)a;(void)b;
# 1519
::exit(___);}
#if 0
# 1517
{ 
# 1518
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.ge.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1519
} 
#endif
# 1520 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hlt(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1521
{int volatile ___ = 1;(void)a;(void)b;
# 1523
::exit(___);}
#if 0
# 1521
{ 
# 1522
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.lt.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1523
} 
#endif
# 1524 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hgt(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1525
{int volatile ___ = 1;(void)a;(void)b;
# 1527
::exit(___);}
#if 0
# 1525
{ 
# 1526
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.gt.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1527
} 
#endif
# 1528 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hequ(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1529
{int volatile ___ = 1;(void)a;(void)b;
# 1531
::exit(___);}
#if 0
# 1529
{ 
# 1530
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.equ.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1531
} 
#endif
# 1532 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hneu(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1533
{int volatile ___ = 1;(void)a;(void)b;
# 1535
::exit(___);}
#if 0
# 1533
{ 
# 1534
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.neu.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1535
} 
#endif
# 1536 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hleu(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1537
{int volatile ___ = 1;(void)a;(void)b;
# 1539
::exit(___);}
#if 0
# 1537
{ 
# 1538
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.leu.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1539
} 
#endif
# 1540 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hgeu(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1541
{int volatile ___ = 1;(void)a;(void)b;
# 1543
::exit(___);}
#if 0
# 1541
{ 
# 1542
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.geu.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1543
} 
#endif
# 1544 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hltu(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1545
{int volatile ___ = 1;(void)a;(void)b;
# 1547
::exit(___);}
#if 0
# 1545
{ 
# 1546
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.ltu.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1547
} 
#endif
# 1548 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hgtu(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1549
{int volatile ___ = 1;(void)a;(void)b;
# 1551
::exit(___);}
#if 0
# 1549
{ 
# 1550
{ unsigned val; __asm__("{.reg .b32 a,b;\n  mov.b32 a, {0, %1};\n  mov.b32 b, {0, %2};\n  set.gtu.f32.f32 %0, a, b;}\n" : "=r" (val) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return (val != 0U) ? true : false; } 
# 1551
} 
#endif
# 1573 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hadd2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1574
{int volatile ___ = 1;(void)a;(void)b;
# 1581
::exit(___);}
#if 0
# 1574
{ 
# 1575
__nv_bfloat162 val; 
# 1576
__asm__("{.reg .b32 c;\n  mov.b32 c, 0x3f803f80U;\n  fma.rn.bf16x2 %0,%1,c,%2;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1580
return val; 
# 1581
} 
#endif
# 1582 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hsub2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1583
{int volatile ___ = 1;(void)a;(void)b;
# 1590
::exit(___);}
#if 0
# 1583
{ 
# 1584
__nv_bfloat162 val; 
# 1585
__asm__("{.reg .b32 c;\n  mov.b32 c, 0xbf80bf80U;\n  fma.rn.bf16x2 %0,%2,c,%1;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1589
return val; 
# 1590
} 
#endif
# 1591 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hmul2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1592
{int volatile ___ = 1;(void)a;(void)b;
# 1599
::exit(___);}
#if 0
# 1592
{ 
# 1593
__nv_bfloat162 val; 
# 1594
__asm__("{.reg .b32 c;\n  mov.b32 c, 0x80008000U;\n  fma.rn.bf16x2 %0,%1,%2,c;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1598
return val; 
# 1599
} 
#endif
# 1600 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hadd2_rn(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1601
{int volatile ___ = 1;(void)a;(void)b;
# 1608
::exit(___);}
#if 0
# 1601
{ 
# 1602
__nv_bfloat162 val; 
# 1603
__asm__("{.reg .b32 c;\n  mov.b32 c, 0x3f803f80U;\n  fma.rn.bf16x2 %0,%1,c,%2;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1607
return val; 
# 1608
} 
#endif
# 1609 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hsub2_rn(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1610
{int volatile ___ = 1;(void)a;(void)b;
# 1617
::exit(___);}
#if 0
# 1610
{ 
# 1611
__nv_bfloat162 val; 
# 1612
__asm__("{.reg .b32 c;\n  mov.b32 c, 0xbf80bf80U;\n  fma.rn.bf16x2 %0,%2,c,%1;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1616
return val; 
# 1617
} 
#endif
# 1618 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hmul2_rn(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1619
{int volatile ___ = 1;(void)a;(void)b;
# 1626
::exit(___);}
#if 0
# 1619
{ 
# 1620
__nv_bfloat162 val; 
# 1621
__asm__("{.reg .b32 c;\n  mov.b32 c, 0x80008000U;\n  fma.rn.bf16x2 %0,%1,%2,c;}\n" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1625
return val; 
# 1626
} 
#endif
# 1627 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hadd2_sat(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1628
{int volatile ___ = 1;(void)a;(void)b;
# 1638
::exit(___);}
#if 0
# 1628
{ 
# 1629
__nv_bfloat162 val; 
# 1630
__asm__("{.reg .b32 f, one, zero;\n  mov.b32 one, 0x3f803f80U;\n  mov.b32 zero, 0;\n  fma.rn.bf16x2 f,%1,one,%2;\n  max.bf16x2 f, f, zero" ";\n  min.bf16x2 %0, f, one;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1637
return val; 
# 1638
} 
#endif
# 1639 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hsub2_sat(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1640
{int volatile ___ = 1;(void)a;(void)b;
# 1651
::exit(___);}
#if 0
# 1640
{ 
# 1641
__nv_bfloat162 val; 
# 1642
__asm__("{.reg .b32 f, one, zero, mone;\n  mov.b32 one, 0x3f803f80U;\n  mov.b32 zero, 0;\n  mov.b32 mone, 0xbf80bf80U;\n  fma.rn.bf16x2 f" ",%2,mone,%1;\n  max.bf16x2 f, f, zero;\n  min.bf16x2 %0, f, one;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1650
return val; 
# 1651
} 
#endif
# 1652 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hmul2_sat(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 1653
{int volatile ___ = 1;(void)a;(void)b;
# 1664
::exit(___);}
#if 0
# 1653
{ 
# 1654
__nv_bfloat162 val; 
# 1655
__asm__("{.reg .b32 f, one, zero, mzero;\n  mov.b32 one, 0x3f803f80U;\n  mov.b32 zero, 0;\n  mov.b32 mzero, 0x80008000U;\n  fma.rn.bf16x2" " f,%1,%2,mzero;\n  max.bf16x2 f, f, zero;\n  min.bf16x2 %0, f, one;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 1663
return val; 
# 1664
} 
#endif
# 1665 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hfma2(const __nv_bfloat162 a, const __nv_bfloat162 b, const __nv_bfloat162 c) 
# 1666
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 1671
::exit(___);}
#if 0
# 1666
{ 
# 1667
__nv_bfloat162 val; 
# 1668
__asm__("{fma.rn.bf16x2 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b))), "r" (*(reinterpret_cast< const unsigned *>(&c)))); 
# 1670
return val; 
# 1671
} 
#endif
# 1672 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hfma2_sat(const __nv_bfloat162 a, const __nv_bfloat162 b, const __nv_bfloat162 c) 
# 1673
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 1683
::exit(___);}
#if 0
# 1673
{ 
# 1674
__nv_bfloat162 val; 
# 1675
__asm__("{ .reg .b32 f, one, zero;\n  mov.b32 one, 0x3f803f80U;\n  mov.b32 zero, 0;\n  fma.rn.bf16x2 f, %1, %2, %3;\n  max.bf16x2 f, f, z" "ero;\n  min.bf16x2 %0, f, one;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b))), "r" (*(reinterpret_cast< const unsigned *>(&c)))); 
# 1682
return val; 
# 1683
} 
#endif
# 1684 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __h2div(const __nv_bfloat162 a, const __nv_bfloat162 b) {int volatile ___ = 1;(void)a;(void)b;
# 1698
::exit(___);}
#if 0
# 1684
{ 
# 1685
__nv_bfloat16 ha, hb; 
# 1687
ha = __low2bfloat16(a); 
# 1688
hb = __low2bfloat16(b); 
# 1690
const __nv_bfloat16 v1 = __hdiv(ha, hb); 
# 1692
ha = __high2bfloat16(a); 
# 1693
hb = __high2bfloat16(b); 
# 1695
const __nv_bfloat16 v2 = __hdiv(ha, hb); 
# 1697
return __halves2bfloat162(v1, v2); 
# 1698
} 
#endif
# 1713 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hadd(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1714
{int volatile ___ = 1;(void)a;(void)b;
# 1721
::exit(___);}
#if 0
# 1714
{ 
# 1715
__nv_bfloat16 val; 
# 1716
__asm__("{.reg .b16 c;\n  mov.b16 c, 0x3f80U;\n  fma.rn.bf16 %0,%1,c,%2;}\n" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1720
return val; 
# 1721
} 
#endif
# 1722 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hsub(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1723
{int volatile ___ = 1;(void)a;(void)b;
# 1730
::exit(___);}
#if 0
# 1723
{ 
# 1724
__nv_bfloat16 val; 
# 1725
__asm__("{.reg .b16 c;\n  mov.b16 c, 0xbf80U;\n  fma.rn.bf16 %0,%2,c,%1;}\n" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1729
return val; 
# 1730
} 
#endif
# 1731 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hmul(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1732
{int volatile ___ = 1;(void)a;(void)b;
# 1739
::exit(___);}
#if 0
# 1732
{ 
# 1733
__nv_bfloat16 val; 
# 1734
__asm__("{.reg .b16 c;\n  mov.b16 c, 0x8000U;\n  fma.rn.bf16 %0,%1,%2,c;}\n" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1738
return val; 
# 1739
} 
#endif
# 1740 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hadd_rn(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1741
{int volatile ___ = 1;(void)a;(void)b;
# 1748
::exit(___);}
#if 0
# 1741
{ 
# 1742
__nv_bfloat16 val; 
# 1743
__asm__("{.reg .b16 c;\n  mov.b16 c, 0x3f80U;\n  fma.rn.bf16 %0,%1,c,%2;}\n" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1747
return val; 
# 1748
} 
#endif
# 1749 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hsub_rn(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1750
{int volatile ___ = 1;(void)a;(void)b;
# 1757
::exit(___);}
#if 0
# 1750
{ 
# 1751
__nv_bfloat16 val; 
# 1752
__asm__("{.reg .b16 c;\n  mov.b16 c, 0xbf80U;\n  fma.rn.bf16 %0,%2,c,%1;}\n" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1756
return val; 
# 1757
} 
#endif
# 1758 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hmul_rn(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1759
{int volatile ___ = 1;(void)a;(void)b;
# 1766
::exit(___);}
#if 0
# 1759
{ 
# 1760
__nv_bfloat16 val; 
# 1761
__asm__("{.reg .b16 c;\n  mov.b16 c, 0x8000U;\n  fma.rn.bf16 %0,%1,%2,c;}\n" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1765
return val; 
# 1766
} 
#endif
# 1767 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hadd_sat(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1768
{int volatile ___ = 1;(void)a;(void)b;
# 1778
::exit(___);}
#if 0
# 1768
{ 
# 1769
__nv_bfloat16 val; 
# 1770
__asm__("{ .reg .b16 f, one, zero;\n  mov.b16 one, 0x3f80U;\n  mov.b16 zero, 0;\n  fma.rn.bf16 f, %1, one, %2;\n  max.bf16 f, f, zero;\n " " min.bf16 %0, f, one;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1777
return val; 
# 1778
} 
#endif
# 1779 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hsub_sat(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1780
{int volatile ___ = 1;(void)a;(void)b;
# 1791
::exit(___);}
#if 0
# 1780
{ 
# 1781
__nv_bfloat16 val; 
# 1782
__asm__("{ .reg .b16 f, one, zero, mone;\n  mov.b16 one, 0x3f80U;\n  mov.b16 zero, 0;\n  mov.b16 mone, 0xbf80U;\n  fma.rn.bf16 f, %2, mon" "e, %1;\n  max.bf16 f, f, zero;\n  min.bf16 %0, f, one;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1790
return val; 
# 1791
} 
#endif
# 1792 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hmul_sat(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 1793
{int volatile ___ = 1;(void)a;(void)b;
# 1804
::exit(___);}
#if 0
# 1793
{ 
# 1794
__nv_bfloat16 val; 
# 1795
__asm__("{ .reg .b16 f, one, zero, mzero;\n  mov.b16 one, 0x3f80U;\n  mov.b16 zero, 0;\n  mov.b16 mzero, 0x8000U;\n  fma.rn.bf16 f, %1, %" "2, mzero;\n  max.bf16 f, f, zero;\n  min.bf16 %0, f, one;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 1803
return val; 
# 1804
} 
#endif
# 1805 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hfma(const __nv_bfloat16 a, const __nv_bfloat16 b, const __nv_bfloat16 c) 
# 1806
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 1811
::exit(___);}
#if 0
# 1806
{ 
# 1807
__nv_bfloat16 val; 
# 1808
__asm__("{fma.rn.bf16 %0,%1,%2,%3;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b))), "h" (*(reinterpret_cast< const unsigned short *>(&c)))); 
# 1810
return val; 
# 1811
} 
#endif
# 1812 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hfma_sat(const __nv_bfloat16 a, const __nv_bfloat16 b, const __nv_bfloat16 c) 
# 1813
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 1823
::exit(___);}
#if 0
# 1813
{ 
# 1814
__nv_bfloat16 val; 
# 1815
__asm__("{ .reg .b16 f, one, zero;\n  mov.b16 one, 0x3f80U;\n  mov.b16 zero, 0;\n  fma.rn.bf16 f, %1, %2, %3;\n  max.bf16 f, f, zero;\n  " "min.bf16 %0, f, one;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b))), "h" (*(reinterpret_cast< const unsigned short *>(&c)))); 
# 1822
return val; 
# 1823
} 
#endif
# 1824 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hdiv(const __nv_bfloat16 a, const __nv_bfloat16 b) {int volatile ___ = 1;(void)a;(void)b;
# 1826
::exit(___);}
#if 0
# 1824
{ 
# 1825
{ __nv_bfloat16 val; __asm__("{.reg .b32 a,b,res;\n  mov.b32 a, {0,%1};\n  mov.b32 b, {0,%2};\n  div.rn.f32 res, a, b;\n  cvt.rn.bf16.f32 %0, res;}\n" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); return val; } 
# 1826
} 
#endif
# 1858 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hsin_internal(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1862
::exit(___);}
#if 0
# 1858
{ 
# 1859
float f = __bfloat162float(a); 
# 1860
f = sinf(f); 
# 1861
return __float2bfloat16_rn(f); 
# 1862
} 
#endif
# 1863 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hsin(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1865
::exit(___);}
#if 0
# 1863
{ 
# 1864
return __hsin_internal(a); 
# 1865
} 
#endif
# 1866 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2sin(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 1870
::exit(___);}
#if 0
# 1866
{ 
# 1867
const __nv_bfloat16 l = __low2bfloat16(a); 
# 1868
const __nv_bfloat16 h = __high2bfloat16(a); 
# 1869
return __halves2bfloat162(__hsin_internal(l), __hsin_internal(h)); 
# 1870
} 
#endif
# 1871 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hcos_internal(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1875
::exit(___);}
#if 0
# 1871
{ 
# 1872
float f = __bfloat162float(a); 
# 1873
f = cosf(f); 
# 1874
return __float2bfloat16_rn(f); 
# 1875
} 
#endif
# 1876 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hcos(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1878
::exit(___);}
#if 0
# 1876
{ 
# 1877
return __hcos_internal(a); 
# 1878
} 
#endif
# 1879 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2cos(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 1883
::exit(___);}
#if 0
# 1879
{ 
# 1880
const __nv_bfloat16 l = __low2bfloat16(a); 
# 1881
const __nv_bfloat16 h = __high2bfloat16(a); 
# 1882
return __halves2bfloat162(__hcos_internal(l), __hcos_internal(h)); 
# 1883
} 
#endif
# 1898 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hexp(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1911
::exit(___);}
#if 0
# 1898
{ 
# 1899
__nv_bfloat16 val; 
# 1900
__asm__("{.reg.b32          f, C;           \n .reg.b16          h,r;            \n  mov.b16          h,%1;           \n  mov.b32        " "  f,{0,h};        \n  mov.b32          C, 0x3fb8aa3cU;  \n  mul.f32          f,f,C;          \n  ex2.approx.f32   f,f;          " "  \n  cvt.rn.bf16.f32 r,f;            \n  mov.b16          %0,r;           \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 1910
return val; 
# 1911
} 
#endif
# 1912 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2exp(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 1931
::exit(___);}
#if 0
# 1912
{ 
# 1913
__nv_bfloat162 val; 
# 1914
__asm__("{.reg.b16         hl, hu;         \n .reg.b32         h,r,fl,fu, C;   \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         h," " %1;          \n  mov.b32         fl, {0,hl};     \n  mov.b32         fu, {0,hu};     \n  mov.b32         C, 0x3fb8aa3cU;  \n  m" "ul.f32         fl,fl,C;        \n  mul.f32         fu,fu,C;        \n  ex2.approx.f32      fl, fl;     \n  ex2.approx.f32      f" "u, fu;     \n  cvt.rn.bf16.f32    hl, fl;     \n  cvt.rn.bf16.f32    hu, fu;     \n  mov.b32         r, {hl, hu};    \n  mov.b32" "         %0, r;  \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1930
return val; 
# 1931
} 
#endif
# 1932 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hexp2(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1934
::exit(___);}
#if 0
# 1932
{ 
# 1933
{ __nv_bfloat16 val; __asm__("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  mov.b32         f,{0,r};  \n  ex2.ap" "prox.f32   f,f;  \n  cvt.rn.bf16.f32    r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); return val; } ; 
# 1934
} 
#endif
# 1935 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2exp2(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 1937
::exit(___);}
#if 0
# 1935
{ 
# 1936
{ __nv_bfloat162 val; __asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         fl" ", {0,hl};     \n  mov.b32         fu, {0,hu};     \n  ex2.approx.f32   fl, fl;     \n  ex2.approx.f32   fu, fu;     \n  cvt.rn.b" "f16.f32    hl, fl;     \n  cvt.rn.bf16.f32    hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); return val; } ; 
# 1937
} 
#endif
# 1938 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hexp10(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1952
::exit(___);}
#if 0
# 1938
{ 
# 1939
__nv_bfloat16 val; 
# 1940
__asm__("{.reg.b16         h, r;           \n .reg.b32         f, C;           \n  mov.b16         h, %1;          \n  mov.b32         f," " {0,h};       \n  mov.b32         C, 0x40549A78U;  \n  mul.f32         f,f,C;          \n  ex2.approx.f32      f, f;       \n  c" "vt.rn.bf16.f32    r, f;       \n{.reg.b16 spc, ulp, p;\n  mov.b16 spc,0xBC95U;\n  mov.b16 ulp,0xbf00U;\n  set.eq.f16.f16 p,%1, s" "pc;\n  fma.rn.bf16 r,p,ulp,r;\n}\n  mov.b16         %0, r;          \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 1951
return val; 
# 1952
} 
#endif
# 1953 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2exp10(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 1972
::exit(___);}
#if 0
# 1953
{ 
# 1954
__nv_bfloat162 val; 
# 1955
__asm__("{.reg.b16         hl, hu;         \n .reg.b32         h,r,fl,fu, C;   \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         fl" ", {0,hl};     \n  mov.b32         fu, {0,hu};     \n  mov.b32         C, 0x40549A78U;  \n  mul.f32         fl,fl,C;        \n  m" "ul.f32         fu,fu,C;        \n  ex2.approx.f32      fl, fl;     \n  ex2.approx.f32      fu, fu;     \n  cvt.rn.bf16.f32    hl" ", fl;     \n  cvt.rn.bf16.f32    hu, fu;     \n  mov.b32         r, {hl, hu};    \n{.reg.b32 spc, ulp, p;\n  mov.b32 spc,0xBC95B" "C95U;\n  mov.b32 ulp,0xbf00bf00U;\n  set.eq.f16x2.f16x2 p,%1, spc;\n  fma.rn.bf16x2 r,p,ulp,r;\n}\n  mov.b32         %0, r;  \n}" "" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 1971
return val; 
# 1972
} 
#endif
# 1973 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hlog2(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1975
::exit(___);}
#if 0
# 1973
{ 
# 1974
{ __nv_bfloat16 val; __asm__("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  mov.b32         f,{0,r};  \n  lg2.ap" "prox.f32   f,f;  \n  cvt.rn.bf16.f32    r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); return val; } ; 
# 1975
} 
#endif
# 1976 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2log2(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 1978
::exit(___);}
#if 0
# 1976
{ 
# 1977
{ __nv_bfloat162 val; __asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         fl" ", {0,hl};     \n  mov.b32         fu, {0,hu};     \n  lg2.approx.f32   fl, fl;     \n  lg2.approx.f32   fu, fu;     \n  cvt.rn.b" "f16.f32    hl, fl;     \n  cvt.rn.bf16.f32    hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); return val; } ; 
# 1978
} 
#endif
# 1979 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hlog(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 1992
::exit(___);}
#if 0
# 1979
{ 
# 1980
__nv_bfloat16 val; 
# 1981
__asm__("{.reg.b32         f, C;           \n .reg.b16         r,h;            \n  mov.b16         h,%1;           \n  mov.b32         f," "{0,h};        \n  lg2.approx.f32      f,f;        \n  mov.b32         C, 0x3f317218U; \n  mul.f32         f,f,C;          \n  cv" "t.rn.bf16.f32    r,f;        \n  mov.b16         %0,r;           \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 1991
return val; 
# 1992
} 
#endif
# 1993 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2log(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 2012
::exit(___);}
#if 0
# 1993
{ 
# 1994
__nv_bfloat162 val; 
# 1995
__asm__("{.reg.b16         hl, hu;             \n .reg.b32         r, fl, fu, C, h;    \n  mov.b32         {hl, hu}, %1;       \n  mov.b3" "2         h, %1;              \n  mov.b32         fl, {0,hl};         \n  mov.b32         fu, {0,hu};         \n  lg2.approx.f32" "      fl, fl;         \n  lg2.approx.f32      fu, fu;         \n  mov.b32         C, 0x3f317218U;     \n  mul.f32         fl,fl," "C;            \n  mul.f32         fu,fu,C;            \n  cvt.rn.bf16.f32    hl, fl;         \n  cvt.rn.bf16.f32    hu, fu;     " "    \n  mov.b32         r, {hl, hu};        \n  mov.b32         %0, r;              \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2011
return val; 
# 2012
} 
#endif
# 2013 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hlog10(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 2026
::exit(___);}
#if 0
# 2013
{ 
# 2014
__nv_bfloat16 val; 
# 2015
__asm__("{.reg.b16         h, r;           \n .reg.b32         f, C;           \n  mov.b16         h, %1;          \n  mov.b32         f," " {0,h};           \n  lg2.approx.f32      f, f;       \n  mov.b32         C, 0x3E9A209BU;  \n  mul.f32         f,f,C;          \n" "  cvt.rn.bf16.f32    r, f;       \n  mov.b16         %0, r;          \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2025
return val; 
# 2026
} 
#endif
# 2027 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2log10(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 2046
::exit(___);}
#if 0
# 2027
{ 
# 2028
__nv_bfloat162 val; 
# 2029
__asm__("{.reg.b16         hl, hu;             \n .reg.b32         r, fl, fu, C, h;    \n  mov.b32         {hl, hu}, %1;       \n  mov.b3" "2         h, %1;              \n  mov.b32         fl, {0,hl};         \n  mov.b32         fu, {0,hu};         \n  lg2.approx.f32" "      fl, fl;         \n  lg2.approx.f32      fu, fu;         \n  mov.b32         C, 0x3E9A209BU;      \n  mul.f32         fl,fl" ",C;            \n  mul.f32         fu,fu,C;            \n  cvt.rn.bf16.f32    hl, fl;         \n  cvt.rn.bf16.f32    hu, fu;    " "     \n  mov.b32         r, {hl, hu};        \n  mov.b32         %0, r;              \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2045
return val; 
# 2046
} 
#endif
# 2049 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2rcp(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 2051
::exit(___);}
#if 0
# 2049
{ 
# 2050
{ __nv_bfloat162 val; __asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         fl" ", {0,hl};     \n  mov.b32         fu, {0,hu};     \n  rcp.approx.f32   fl, fl;     \n  rcp.approx.f32   fu, fu;     \n  cvt.rn.b" "f16.f32    hl, fl;     \n  cvt.rn.bf16.f32    hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); return val; } 
# 2051
} 
#endif
# 2052 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hrcp(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 2054
::exit(___);}
#if 0
# 2052
{ 
# 2053
{ __nv_bfloat16 val; __asm__("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  mov.b32         f,{0,r};  \n  rcp.ap" "prox.f32   f,f;  \n  cvt.rn.bf16.f32    r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); return val; } 
# 2054
} 
#endif
# 2055 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2rsqrt(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 2057
::exit(___);}
#if 0
# 2055
{ 
# 2056
{ __nv_bfloat162 val; __asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         fl" ", {0,hl};     \n  mov.b32         fu, {0,hu};     \n  rsqrt.approx.f32   fl, fl;     \n  rsqrt.approx.f32   fu, fu;     \n  cvt." "rn.bf16.f32    hl, fl;     \n  cvt.rn.bf16.f32    hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); return val; } 
# 2057
} 
#endif
# 2058 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hrsqrt(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 2060
::exit(___);}
#if 0
# 2058
{ 
# 2059
{ __nv_bfloat16 val; __asm__("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  mov.b32         f,{0,r};  \n  rsqrt." "approx.f32   f,f;  \n  cvt.rn.bf16.f32    r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); return val; } 
# 2060
} 
#endif
# 2061 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 h2sqrt(const __nv_bfloat162 a) {int volatile ___ = 1;(void)a;
# 2063
::exit(___);}
#if 0
# 2061
{ 
# 2062
{ __nv_bfloat162 val; __asm__("{.reg.b16         hl, hu;         \n .reg.b32         fl, fu;         \n  mov.b32         {hl, hu}, %1;   \n  mov.b32         fl" ", {0,hl};     \n  mov.b32         fu, {0,hu};     \n  sqrt.approx.f32   fl, fl;     \n  sqrt.approx.f32   fu, fu;     \n  cvt.rn" ".bf16.f32    hl, fl;     \n  cvt.rn.bf16.f32    hu, fu;     \n  mov.b32         %0, {hl, hu};   \n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); return val; } 
# 2063
} 
#endif
# 2064 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 hsqrt(const __nv_bfloat16 a) {int volatile ___ = 1;(void)a;
# 2066
::exit(___);}
#if 0
# 2064
{ 
# 2065
{ __nv_bfloat16 val; __asm__("{.reg.b32         f;        \n .reg.b16         r;        \n  mov.b16         r,%1;     \n  mov.b32         f,{0,r};  \n  sqrt.a" "pprox.f32   f,f;  \n  cvt.rn.bf16.f32    r,f;  \n  mov.b16         %0,r;     \n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); return val; } 
# 2066
} 
#endif
# 2069 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hisnan2(const __nv_bfloat162 a) 
# 2070
{int volatile ___ = 1;(void)a;
# 2073
::exit(___);}
#if 0
# 2070
{ 
# 2071
const __nv_bfloat162 b = a; 
# 2072
{ __nv_bfloat162 val; __asm__("{.reg .b32 low_a,low_b,high_a,high_b,high_res,low_res;\n .reg .b16 low,high;\n  and.b32 high_a, %1, 0xffff0000U;\n  and.b32 high" "_b, %2, 0xffff0000U;\n  shl.b32 low_a, %1, 16;\n  shl.b32 low_b, %2, 16;\n  set.nan.f32.f32 low_res, low_a, low_b;\n  set.nan.f3" "2.f32 high_res, high_a, high_b;\n  cvt.rn.bf16.f32 low, low_res;\n  cvt.rn.bf16.f32 high, high_res;\n  mov.b32 %0, {low,high};}\n" "" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); return val; } 
# 2073
} 
#endif
# 2074 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline bool __hisnan(const __nv_bfloat16 a) 
# 2075
{int volatile ___ = 1;(void)a;
# 2082
::exit(___);}
#if 0
# 2075
{ 
# 2076
unsigned r; 
# 2077
__asm__("{.reg .b32 a;\n  mov.b32 a, {0,%1};\n  set.nan.f32.f32 %0, a, a;}\n" : "=r" (r) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2081
return r != 0U; 
# 2082
} 
#endif
# 2083 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hneg2(const __nv_bfloat162 a) 
# 2084
{int volatile ___ = 1;(void)a;
# 2089
::exit(___);}
#if 0
# 2084
{ 
# 2085
__nv_bfloat162 r; 
# 2086
__asm__("{neg.bf16x2 %0,%1;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2088
return r; 
# 2089
} 
#endif
# 2090 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hneg(const __nv_bfloat16 a) 
# 2091
{int volatile ___ = 1;(void)a;
# 2096
::exit(___);}
#if 0
# 2091
{ 
# 2092
__nv_bfloat16 r; 
# 2093
__asm__("{neg.bf16 %0,%1;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2095
return r; 
# 2096
} 
#endif
# 2097 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __habs2(const __nv_bfloat162 a) 
# 2098
{int volatile ___ = 1;(void)a;
# 2103
::exit(___);}
#if 0
# 2098
{ 
# 2099
__nv_bfloat162 r; 
# 2100
__asm__("{abs.bf16x2 %0,%1;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&r))) : "r" (*(reinterpret_cast< const unsigned *>(&a)))); 
# 2102
return r; 
# 2103
} 
#endif
# 2104 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __habs(const __nv_bfloat16 a) 
# 2105
{int volatile ___ = 1;(void)a;
# 2110
::exit(___);}
#if 0
# 2105
{ 
# 2106
__nv_bfloat16 r; 
# 2107
__asm__("{abs.bf16 %0,%1;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&r))) : "h" (*(reinterpret_cast< const unsigned short *>(&a)))); 
# 2109
return r; 
# 2110
} 
#endif
# 2114 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hmax(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 2115
{int volatile ___ = 1;(void)a;(void)b;
# 2120
::exit(___);}
#if 0
# 2115
{ 
# 2116
__nv_bfloat16 val; 
# 2117
__asm__("{ max.bf16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 2119
return val; 
# 2120
} 
#endif
# 2121 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hmin(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 2122
{int volatile ___ = 1;(void)a;(void)b;
# 2127
::exit(___);}
#if 0
# 2122
{ 
# 2123
__nv_bfloat16 val; 
# 2124
__asm__("{ min.bf16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 2126
return val; 
# 2127
} 
#endif
# 2128 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hmax_nan(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 2129
{int volatile ___ = 1;(void)a;(void)b;
# 2134
::exit(___);}
#if 0
# 2129
{ 
# 2130
__nv_bfloat16 val; 
# 2131
__asm__("{ max.NaN.bf16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 2133
return val; 
# 2134
} 
#endif
# 2135 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hmin_nan(const __nv_bfloat16 a, const __nv_bfloat16 b) 
# 2136
{int volatile ___ = 1;(void)a;(void)b;
# 2141
::exit(___);}
#if 0
# 2136
{ 
# 2137
__nv_bfloat16 val; 
# 2138
__asm__("{ min.NaN.bf16 %0,%1,%2;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b)))); 
# 2140
return val; 
# 2141
} 
#endif
# 2142 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 __hfma_relu(const __nv_bfloat16 a, const __nv_bfloat16 b, const __nv_bfloat16 c) 
# 2143
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2148
::exit(___);}
#if 0
# 2143
{ 
# 2144
__nv_bfloat16 val; 
# 2145
__asm__("{ fma.rn.relu.bf16 %0,%1,%2,%3;\n}" : "=h" (*(reinterpret_cast< unsigned short *>(&val))) : "h" (*(reinterpret_cast< const unsigned short *>(&a))), "h" (*(reinterpret_cast< const unsigned short *>(&b))), "h" (*(reinterpret_cast< const unsigned short *>(&c)))); 
# 2147
return val; 
# 2148
} 
#endif
# 2152 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hmax2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 2153
{int volatile ___ = 1;(void)a;(void)b;
# 2158
::exit(___);}
#if 0
# 2153
{ 
# 2154
__nv_bfloat162 val; 
# 2155
__asm__("{ max.bf16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 2157
return val; 
# 2158
} 
#endif
# 2159 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hmin2(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 2160
{int volatile ___ = 1;(void)a;(void)b;
# 2165
::exit(___);}
#if 0
# 2160
{ 
# 2161
__nv_bfloat162 val; 
# 2162
__asm__("{ min.bf16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 2164
return val; 
# 2165
} 
#endif
# 2166 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hmax2_nan(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 2167
{int volatile ___ = 1;(void)a;(void)b;
# 2172
::exit(___);}
#if 0
# 2167
{ 
# 2168
__nv_bfloat162 val; 
# 2169
__asm__("{ max.NaN.bf16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 2171
return val; 
# 2172
} 
#endif
# 2173 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hmin2_nan(const __nv_bfloat162 a, const __nv_bfloat162 b) 
# 2174
{int volatile ___ = 1;(void)a;(void)b;
# 2179
::exit(___);}
#if 0
# 2174
{ 
# 2175
__nv_bfloat162 val; 
# 2176
__asm__("{ min.NaN.bf16x2 %0,%1,%2;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b)))); 
# 2178
return val; 
# 2179
} 
#endif
# 2180 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hfma2_relu(const __nv_bfloat162 a, const __nv_bfloat162 b, const __nv_bfloat162 c) 
# 2181
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2186
::exit(___);}
#if 0
# 2181
{ 
# 2182
__nv_bfloat162 val; 
# 2183
__asm__("{ fma.rn.relu.bf16x2 %0,%1,%2,%3;\n}" : "=r" (*(reinterpret_cast< unsigned *>(&val))) : "r" (*(reinterpret_cast< const unsigned *>(&a))), "r" (*(reinterpret_cast< const unsigned *>(&b))), "r" (*(reinterpret_cast< const unsigned *>(&c)))); 
# 2185
return val; 
# 2186
} 
#endif
# 2188 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 __hcmadd(const __nv_bfloat162 a, const __nv_bfloat162 b, const __nv_bfloat162 c) 
# 2189
{int volatile ___ = 1;(void)a;(void)b;(void)c;
# 2199
::exit(___);}
#if 0
# 2189
{ 
# 2194
__nv_bfloat16 real_tmp = __hfma(a.x, b.x, c.x); 
# 2195
__nv_bfloat16 img_tmp = __hfma(a.x, b.y, c.y); 
# 2196
real_tmp = __hfma(__hneg(a.y), b.y, real_tmp); 
# 2197
img_tmp = __hfma(a.y, b.x, img_tmp); 
# 2198
return make_bfloat162(real_tmp, img_tmp); 
# 2199
} 
#endif
# 2201 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat162 atomicAdd(__nv_bfloat162 *const address, const __nv_bfloat162 val) 
# 2202
{int volatile ___ = 1;(void)address;(void)val;
# 2211
::exit(___);}
#if 0
# 2202
{ 
# 2203
unsigned *address_as_uint = (unsigned *)address; 
# 2204
unsigned old = *address_as_uint, assumed; 
# 2205
do { 
# 2206
assumed = old; 
# 2207
__nv_bfloat162 new_val = __hadd2(val, *((__nv_bfloat162 *)(&assumed))); 
# 2208
old = atomicCAS(address_as_uint, assumed, *((unsigned *)(&new_val))); 
# 2209
} while (assumed != old); 
# 2210
return *((__nv_bfloat162 *)(&old)); 
# 2211
} 
#endif
# 2213 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
__attribute__((unused)) static inline __nv_bfloat16 atomicAdd(__nv_bfloat16 *const address, const __nv_bfloat16 val) 
# 2214
{int volatile ___ = 1;(void)address;(void)val;
# 2223
::exit(___);}
#if 0
# 2214
{ 
# 2215
unsigned short *address_as_us = (unsigned short *)address; 
# 2216
unsigned short old = *address_as_us, assumed; 
# 2217
do { 
# 2218
assumed = old; 
# 2219
old = atomicCAS(address_as_us, assumed, __bfloat16_as_ushort(__hadd(val, __ushort_as_bfloat16(assumed)))); 
# 2221
} while (assumed != old); 
# 2222
return __ushort_as_bfloat16(old); 
# 2223
} 
#endif
# 2238 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cuda_bf16.hpp"
typedef __nv_bfloat16 nv_bfloat16; 
# 2239
typedef __nv_bfloat162 nv_bfloat162; 
# 81 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
extern "C" {
# 102 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
typedef 
# 91
enum { 
# 92
CUBLAS_STATUS_SUCCESS, 
# 93
CUBLAS_STATUS_NOT_INITIALIZED, 
# 94
CUBLAS_STATUS_ALLOC_FAILED = 3, 
# 95
CUBLAS_STATUS_INVALID_VALUE = 7, 
# 96
CUBLAS_STATUS_ARCH_MISMATCH, 
# 97
CUBLAS_STATUS_MAPPING_ERROR = 11, 
# 98
CUBLAS_STATUS_EXECUTION_FAILED = 13, 
# 99
CUBLAS_STATUS_INTERNAL_ERROR, 
# 100
CUBLAS_STATUS_NOT_SUPPORTED, 
# 101
CUBLAS_STATUS_LICENSE_ERROR
# 102
} cublasStatus_t; 
# 104
typedef enum { CUBLAS_FILL_MODE_LOWER, CUBLAS_FILL_MODE_UPPER, CUBLAS_FILL_MODE_FULL} cublasFillMode_t; 
# 106
typedef enum { CUBLAS_DIAG_NON_UNIT, CUBLAS_DIAG_UNIT} cublasDiagType_t; 
# 108
typedef enum { CUBLAS_SIDE_LEFT, CUBLAS_SIDE_RIGHT} cublasSideMode_t; 
# 116
typedef 
# 110
enum { 
# 111
CUBLAS_OP_N, 
# 112
CUBLAS_OP_T, 
# 113
CUBLAS_OP_C, 
# 114
CUBLAS_OP_HERMITAN = 2, 
# 115
CUBLAS_OP_CONJG
# 116
} cublasOperation_t; 
# 118
typedef enum { CUBLAS_POINTER_MODE_HOST, CUBLAS_POINTER_MODE_DEVICE} cublasPointerMode_t; 
# 120
typedef enum { CUBLAS_ATOMICS_NOT_ALLOWED, CUBLAS_ATOMICS_ALLOWED} cublasAtomicsMode_t; 
# 168
typedef 
# 123
enum { 
# 124
CUBLAS_GEMM_DFALT = (-1), 
# 125
CUBLAS_GEMM_DEFAULT = (-1), 
# 126
CUBLAS_GEMM_ALGO0 = 0, 
# 127
CUBLAS_GEMM_ALGO1, 
# 128
CUBLAS_GEMM_ALGO2, 
# 129
CUBLAS_GEMM_ALGO3, 
# 130
CUBLAS_GEMM_ALGO4, 
# 131
CUBLAS_GEMM_ALGO5, 
# 132
CUBLAS_GEMM_ALGO6, 
# 133
CUBLAS_GEMM_ALGO7, 
# 134
CUBLAS_GEMM_ALGO8, 
# 135
CUBLAS_GEMM_ALGO9, 
# 136
CUBLAS_GEMM_ALGO10, 
# 137
CUBLAS_GEMM_ALGO11, 
# 138
CUBLAS_GEMM_ALGO12, 
# 139
CUBLAS_GEMM_ALGO13, 
# 140
CUBLAS_GEMM_ALGO14, 
# 141
CUBLAS_GEMM_ALGO15, 
# 142
CUBLAS_GEMM_ALGO16, 
# 143
CUBLAS_GEMM_ALGO17, 
# 144
CUBLAS_GEMM_ALGO18, 
# 145
CUBLAS_GEMM_ALGO19, 
# 146
CUBLAS_GEMM_ALGO20, 
# 147
CUBLAS_GEMM_ALGO21, 
# 148
CUBLAS_GEMM_ALGO22, 
# 149
CUBLAS_GEMM_ALGO23, 
# 150
CUBLAS_GEMM_DEFAULT_TENSOR_OP = 99, 
# 151
CUBLAS_GEMM_DFALT_TENSOR_OP = 99, 
# 152
CUBLAS_GEMM_ALGO0_TENSOR_OP, 
# 153
CUBLAS_GEMM_ALGO1_TENSOR_OP, 
# 154
CUBLAS_GEMM_ALGO2_TENSOR_OP, 
# 155
CUBLAS_GEMM_ALGO3_TENSOR_OP, 
# 156
CUBLAS_GEMM_ALGO4_TENSOR_OP, 
# 157
CUBLAS_GEMM_ALGO5_TENSOR_OP, 
# 158
CUBLAS_GEMM_ALGO6_TENSOR_OP, 
# 159
CUBLAS_GEMM_ALGO7_TENSOR_OP, 
# 160
CUBLAS_GEMM_ALGO8_TENSOR_OP, 
# 161
CUBLAS_GEMM_ALGO9_TENSOR_OP, 
# 162
CUBLAS_GEMM_ALGO10_TENSOR_OP, 
# 163
CUBLAS_GEMM_ALGO11_TENSOR_OP, 
# 164
CUBLAS_GEMM_ALGO12_TENSOR_OP, 
# 165
CUBLAS_GEMM_ALGO13_TENSOR_OP, 
# 166
CUBLAS_GEMM_ALGO14_TENSOR_OP, 
# 167
CUBLAS_GEMM_ALGO15_TENSOR_OP
# 168
} cublasGemmAlgo_t; 
# 187
typedef 
# 171
enum { 
# 172
CUBLAS_DEFAULT_MATH, 
# 175
CUBLAS_TENSOR_OP_MATH, 
# 179
CUBLAS_PEDANTIC_MATH, 
# 182
CUBLAS_TF32_TENSOR_OP_MATH, 
# 186
CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION = 16
# 187
} cublasMath_t; 
# 190
typedef cudaDataType cublasDataType_t; 
# 211 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
typedef 
# 199
enum { 
# 200
CUBLAS_COMPUTE_16F = 64, 
# 201
CUBLAS_COMPUTE_16F_PEDANTIC, 
# 202
CUBLAS_COMPUTE_32F = 68, 
# 203
CUBLAS_COMPUTE_32F_PEDANTIC, 
# 204
CUBLAS_COMPUTE_32F_FAST_16F = 74, 
# 205
CUBLAS_COMPUTE_32F_FAST_16BF, 
# 206
CUBLAS_COMPUTE_32F_FAST_TF32 = 77, 
# 207
CUBLAS_COMPUTE_64F = 70, 
# 208
CUBLAS_COMPUTE_64F_PEDANTIC, 
# 209
CUBLAS_COMPUTE_32I, 
# 210
CUBLAS_COMPUTE_32I_PEDANTIC
# 211
} cublasComputeType_t; 
# 214
struct cublasContext; 
# 215
typedef cublasContext *cublasHandle_t; 
# 217
cublasStatus_t cublasCreate_v2(cublasHandle_t * handle); 
# 218
cublasStatus_t cublasDestroy_v2(cublasHandle_t handle); 
# 220
cublasStatus_t cublasGetVersion_v2(cublasHandle_t handle, int * version); 
# 221
cublasStatus_t cublasGetProperty(libraryPropertyType type, int * value); 
# 222
size_t cublasGetCudartVersion(); 
# 224
cublasStatus_t cublasSetWorkspace_v2(cublasHandle_t handle, void * workspace, size_t workspaceSizeInBytes); 
# 228
cublasStatus_t cublasSetStream_v2(cublasHandle_t handle, cudaStream_t streamId); 
# 229
cublasStatus_t cublasGetStream_v2(cublasHandle_t handle, cudaStream_t * streamId); 
# 231
cublasStatus_t cublasGetPointerMode_v2(cublasHandle_t handle, cublasPointerMode_t * mode); 
# 232
cublasStatus_t cublasSetPointerMode_v2(cublasHandle_t handle, cublasPointerMode_t mode); 
# 234
cublasStatus_t cublasGetAtomicsMode(cublasHandle_t handle, cublasAtomicsMode_t * mode); 
# 235
cublasStatus_t cublasSetAtomicsMode(cublasHandle_t handle, cublasAtomicsMode_t mode); 
# 237
cublasStatus_t cublasGetMathMode(cublasHandle_t handle, cublasMath_t * mode); 
# 238
cublasStatus_t cublasSetMathMode(cublasHandle_t handle, cublasMath_t mode); 
# 240
cublasStatus_t cublasGetSmCountTarget(cublasHandle_t handle, int * smCountTarget); 
# 241
cublasStatus_t cublasSetSmCountTarget(cublasHandle_t handle, int smCountTarget); 
# 243
const char *cublasGetStatusName(cublasStatus_t status); 
# 244
const char *cublasGetStatusString(cublasStatus_t status); 
# 247
typedef void (*cublasLogCallback)(const char * msg); 
# 249
cublasStatus_t cublasLoggerConfigure(int logIsOn, int logToStdOut, int logToStdErr, const char * logFileName); 
# 253
cublasStatus_t cublasSetLoggerCallback(cublasLogCallback userCallback); 
# 254
cublasStatus_t cublasGetLoggerCallback(cublasLogCallback * userCallback); 
# 279 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
cublasStatus_t cublasSetVector(int n, int elemSize, const void * x, int incx, void * devicePtr, int incy); 
# 304 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
cublasStatus_t cublasGetVector(int n, int elemSize, const void * x, int incx, void * y, int incy); 
# 327 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
cublasStatus_t cublasSetMatrix(int rows, int cols, int elemSize, const void * A, int lda, void * B, int ldb); 
# 349 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
cublasStatus_t cublasGetMatrix(int rows, int cols, int elemSize, const void * A, int lda, void * B, int ldb); 
# 367 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
cublasStatus_t cublasSetVectorAsync(int n, int elemSize, const void * hostPtr, int incx, void * devicePtr, int incy, cudaStream_t stream); 
# 385 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
cublasStatus_t cublasGetVectorAsync(int n, int elemSize, const void * devicePtr, int incx, void * hostPtr, int incy, cudaStream_t stream); 
# 406 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
cublasStatus_t cublasSetMatrixAsync(int rows, int cols, int elemSize, const void * A, int lda, void * B, int ldb, cudaStream_t stream); 
# 425 "/usr/local/cuda/bin/../targets/x86_64-linux/include/cublas_api.h"
cublasStatus_t cublasGetMatrixAsync(int rows, int cols, int elemSize, const void * A, int lda, void * B, int ldb, cudaStream_t stream); 
# 427
void cublasXerbla(const char * srName, int info); 
# 429
cublasStatus_t cublasNrm2Ex(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, void * result, cudaDataType resultType, cudaDataType executionType); 
# 439
cublasStatus_t cublasSnrm2_v2(cublasHandle_t handle, int n, const float * x, int incx, float * result); 
# 442
cublasStatus_t cublasDnrm2_v2(cublasHandle_t handle, int n, const double * x, int incx, double * result); 
# 445
cublasStatus_t cublasScnrm2_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, float * result); 
# 447
cublasStatus_t cublasDznrm2_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, double * result); 
# 450
cublasStatus_t cublasDotEx(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, const void * y, cudaDataType yType, int incy, void * result, cudaDataType resultType, cudaDataType executionType); 
# 462
cublasStatus_t cublasDotcEx(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, const void * y, cudaDataType yType, int incy, void * result, cudaDataType resultType, cudaDataType executionType); 
# 474
cublasStatus_t cublasSdot_v2(cublasHandle_t handle, int n, const float * x, int incx, const float * y, int incy, float * result); 
# 482
cublasStatus_t cublasDdot_v2(cublasHandle_t handle, int n, const double * x, int incx, const double * y, int incy, double * result); 
# 490
cublasStatus_t cublasCdotu_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * result); 
# 498
cublasStatus_t cublasCdotc_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * result); 
# 506
cublasStatus_t cublasZdotu_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * result); 
# 514
cublasStatus_t cublasZdotc_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * result); 
# 522
cublasStatus_t cublasScalEx(cublasHandle_t handle, int n, const void * alpha, cudaDataType alphaType, void * x, cudaDataType xType, int incx, cudaDataType executionType); 
# 531
cublasStatus_t cublasSscal_v2(cublasHandle_t handle, int n, const float * alpha, float * x, int incx); 
# 537
cublasStatus_t cublasDscal_v2(cublasHandle_t handle, int n, const double * alpha, double * x, int incx); 
# 543
cublasStatus_t cublasCscal_v2(cublasHandle_t handle, int n, const cuComplex * alpha, cuComplex * x, int incx); 
# 549
cublasStatus_t cublasCsscal_v2(cublasHandle_t handle, int n, const float * alpha, cuComplex * x, int incx); 
# 555
cublasStatus_t cublasZscal_v2(cublasHandle_t handle, int n, const cuDoubleComplex * alpha, cuDoubleComplex * x, int incx); 
# 561
cublasStatus_t cublasZdscal_v2(cublasHandle_t handle, int n, const double * alpha, cuDoubleComplex * x, int incx); 
# 567
cublasStatus_t cublasAxpyEx(cublasHandle_t handle, int n, const void * alpha, cudaDataType alphaType, const void * x, cudaDataType xType, int incx, void * y, cudaDataType yType, int incy, cudaDataType executiontype); 
# 579
cublasStatus_t cublasSaxpy_v2(cublasHandle_t handle, int n, const float * alpha, const float * x, int incx, float * y, int incy); 
# 587
cublasStatus_t cublasDaxpy_v2(cublasHandle_t handle, int n, const double * alpha, const double * x, int incx, double * y, int incy); 
# 595
cublasStatus_t cublasCaxpy_v2(cublasHandle_t handle, int n, const cuComplex * alpha, const cuComplex * x, int incx, cuComplex * y, int incy); 
# 603
cublasStatus_t cublasZaxpy_v2(cublasHandle_t handle, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy); 
# 611
cublasStatus_t cublasCopyEx(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, void * y, cudaDataType yType, int incy); 
# 615
cublasStatus_t cublasScopy_v2(cublasHandle_t handle, int n, const float * x, int incx, float * y, int incy); 
# 618
cublasStatus_t cublasDcopy_v2(cublasHandle_t handle, int n, const double * x, int incx, double * y, int incy); 
# 621
cublasStatus_t cublasCcopy_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, cuComplex * y, int incy); 
# 624
cublasStatus_t cublasZcopy_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy); 
# 627
cublasStatus_t cublasSswap_v2(cublasHandle_t handle, int n, float * x, int incx, float * y, int incy); 
# 630
cublasStatus_t cublasDswap_v2(cublasHandle_t handle, int n, double * x, int incx, double * y, int incy); 
# 633
cublasStatus_t cublasCswap_v2(cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy); 
# 636
cublasStatus_t cublasZswap_v2(cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy); 
# 638
cublasStatus_t cublasSwapEx(cublasHandle_t handle, int n, void * x, cudaDataType xType, int incx, void * y, cudaDataType yType, int incy); 
# 642
cublasStatus_t cublasIsamax_v2(cublasHandle_t handle, int n, const float * x, int incx, int * result); 
# 645
cublasStatus_t cublasIdamax_v2(cublasHandle_t handle, int n, const double * x, int incx, int * result); 
# 648
cublasStatus_t cublasIcamax_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, int * result); 
# 650
cublasStatus_t cublasIzamax_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, int * result); 
# 653
cublasStatus_t cublasIamaxEx(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, int * result); 
# 658
cublasStatus_t cublasIsamin_v2(cublasHandle_t handle, int n, const float * x, int incx, int * result); 
# 661
cublasStatus_t cublasIdamin_v2(cublasHandle_t handle, int n, const double * x, int incx, int * result); 
# 664
cublasStatus_t cublasIcamin_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, int * result); 
# 666
cublasStatus_t cublasIzamin_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, int * result); 
# 669
cublasStatus_t cublasIaminEx(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, int * result); 
# 673
cublasStatus_t cublasAsumEx(cublasHandle_t handle, int n, const void * x, cudaDataType xType, int incx, void * result, cudaDataType resultType, cudaDataType executiontype); 
# 683
cublasStatus_t cublasSasum_v2(cublasHandle_t handle, int n, const float * x, int incx, float * result); 
# 686
cublasStatus_t cublasDasum_v2(cublasHandle_t handle, int n, const double * x, int incx, double * result); 
# 689
cublasStatus_t cublasScasum_v2(cublasHandle_t handle, int n, const cuComplex * x, int incx, float * result); 
# 691
cublasStatus_t cublasDzasum_v2(cublasHandle_t handle, int n, const cuDoubleComplex * x, int incx, double * result); 
# 694
cublasStatus_t cublasSrot_v2(cublasHandle_t handle, int n, float * x, int incx, float * y, int incy, const float * c, const float * s); 
# 703
cublasStatus_t cublasDrot_v2(cublasHandle_t handle, int n, double * x, int incx, double * y, int incy, const double * c, const double * s); 
# 712
cublasStatus_t cublasCrot_v2(cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy, const float * c, const cuComplex * s); 
# 721
cublasStatus_t cublasCsrot_v2(cublasHandle_t handle, int n, cuComplex * x, int incx, cuComplex * y, int incy, const float * c, const float * s); 
# 730
cublasStatus_t cublasZrot_v2(cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy, const double * c, const cuDoubleComplex * s); 
# 739
cublasStatus_t cublasZdrot_v2(cublasHandle_t handle, int n, cuDoubleComplex * x, int incx, cuDoubleComplex * y, int incy, const double * c, const double * s); 
# 748
cublasStatus_t cublasRotEx(cublasHandle_t handle, int n, void * x, cudaDataType xType, int incx, void * y, cudaDataType yType, int incy, const void * c, const void * s, cudaDataType csType, cudaDataType executiontype); 
# 761
cublasStatus_t cublasSrotg_v2(cublasHandle_t handle, float * a, float * b, float * c, float * s); 
# 767
cublasStatus_t cublasDrotg_v2(cublasHandle_t handle, double * a, double * b, double * c, double * s); 
# 773
cublasStatus_t cublasCrotg_v2(cublasHandle_t handle, cuComplex * a, cuComplex * b, float * c, cuComplex * s); 
# 779
cublasStatus_t cublasZrotg_v2(cublasHandle_t handle, cuDoubleComplex * a, cuDoubleComplex * b, double * c, cuDoubleComplex * s); 
# 785
cublasStatus_t cublasRotgEx(cublasHandle_t handle, void * a, void * b, cudaDataType abType, void * c, void * s, cudaDataType csType, cudaDataType executiontype); 
# 794
cublasStatus_t cublasSrotm_v2(cublasHandle_t handle, int n, float * x, int incx, float * y, int incy, const float * param); 
# 802
cublasStatus_t cublasDrotm_v2(cublasHandle_t handle, int n, double * x, int incx, double * y, int incy, const double * param); 
# 810
cublasStatus_t cublasRotmEx(cublasHandle_t handle, int n, void * x, cudaDataType xType, int incx, void * y, cudaDataType yType, int incy, const void * param, cudaDataType paramType, cudaDataType executiontype); 
# 822
cublasStatus_t cublasSrotmg_v2(cublasHandle_t handle, float * d1, float * d2, float * x1, const float * y1, float * param); 
# 829
cublasStatus_t cublasDrotmg_v2(cublasHandle_t handle, double * d1, double * d2, double * x1, const double * y1, double * param); 
# 836
cublasStatus_t cublasRotmgEx(cublasHandle_t handle, void * d1, cudaDataType d1Type, void * d2, cudaDataType d2Type, void * x1, cudaDataType x1Type, const void * y1, cudaDataType y1Type, void * param, cudaDataType paramType, cudaDataType executiontype); 
# 851
cublasStatus_t cublasSgemv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy); 
# 864
cublasStatus_t cublasDgemv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy); 
# 877
cublasStatus_t cublasCgemv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 890
cublasStatus_t cublasZgemv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 903
cublasStatus_t cublasSgbmv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy); 
# 918
cublasStatus_t cublasDgbmv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy); 
# 933
cublasStatus_t cublasCgbmv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 948
cublasStatus_t cublasZgbmv_v2(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int kl, int ku, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 964
cublasStatus_t cublasStrmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * A, int lda, float * x, int incx); 
# 974
cublasStatus_t cublasDtrmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * A, int lda, double * x, int incx); 
# 984
cublasStatus_t cublasCtrmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * A, int lda, cuComplex * x, int incx); 
# 994
cublasStatus_t cublasZtrmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx); 
# 1005
cublasStatus_t cublasStbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const float * A, int lda, float * x, int incx); 
# 1016
cublasStatus_t cublasDtbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const double * A, int lda, double * x, int incx); 
# 1027
cublasStatus_t cublasCtbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuComplex * A, int lda, cuComplex * x, int incx); 
# 1038
cublasStatus_t cublasZtbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx); 
# 1050
cublasStatus_t cublasStpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * AP, float * x, int incx); 
# 1059
cublasStatus_t cublasDtpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * AP, double * x, int incx); 
# 1068
cublasStatus_t cublasCtpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * AP, cuComplex * x, int incx); 
# 1077
cublasStatus_t cublasZtpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * AP, cuDoubleComplex * x, int incx); 
# 1087
cublasStatus_t cublasStrsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * A, int lda, float * x, int incx); 
# 1097
cublasStatus_t cublasDtrsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * A, int lda, double * x, int incx); 
# 1107
cublasStatus_t cublasCtrsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * A, int lda, cuComplex * x, int incx); 
# 1117
cublasStatus_t cublasZtrsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx); 
# 1128
cublasStatus_t cublasStpsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const float * AP, float * x, int incx); 
# 1137
cublasStatus_t cublasDtpsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const double * AP, double * x, int incx); 
# 1146
cublasStatus_t cublasCtpsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuComplex * AP, cuComplex * x, int incx); 
# 1155
cublasStatus_t cublasZtpsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, const cuDoubleComplex * AP, cuDoubleComplex * x, int incx); 
# 1164
cublasStatus_t cublasStbsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const float * A, int lda, float * x, int incx); 
# 1175
cublasStatus_t cublasDtbsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const double * A, int lda, double * x, int incx); 
# 1186
cublasStatus_t cublasCtbsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuComplex * A, int lda, cuComplex * x, int incx); 
# 1197
cublasStatus_t cublasZtbsv_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int n, int k, const cuDoubleComplex * A, int lda, cuDoubleComplex * x, int incx); 
# 1209
cublasStatus_t cublasSsymv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy); 
# 1221
cublasStatus_t cublasDsymv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy); 
# 1233
cublasStatus_t cublasCsymv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 1245
cublasStatus_t cublasZsymv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 1257
cublasStatus_t cublasChemv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 1269
cublasStatus_t cublasZhemv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 1282
cublasStatus_t cublasSsbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const float * alpha, const float * A, int lda, const float * x, int incx, const float * beta, float * y, int incy); 
# 1295
cublasStatus_t cublasDsbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const double * alpha, const double * A, int lda, const double * x, int incx, const double * beta, double * y, int incy); 
# 1308
cublasStatus_t cublasChbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 1321
cublasStatus_t cublasZhbmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 1335
cublasStatus_t cublasSspmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * AP, const float * x, int incx, const float * beta, float * y, int incy); 
# 1346
cublasStatus_t cublasDspmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * AP, const double * x, int incx, const double * beta, double * y, int incy); 
# 1357
cublasStatus_t cublasChpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * AP, const cuComplex * x, int incx, const cuComplex * beta, cuComplex * y, int incy); 
# 1368
cublasStatus_t cublasZhpmv_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * AP, const cuDoubleComplex * x, int incx, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy); 
# 1380
cublasStatus_t cublasSger_v2(cublasHandle_t handle, int m, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * A, int lda); 
# 1391
cublasStatus_t cublasDger_v2(cublasHandle_t handle, int m, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * A, int lda); 
# 1402
cublasStatus_t cublasCgeru_v2(cublasHandle_t handle, int m, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda); 
# 1413
cublasStatus_t cublasCgerc_v2(cublasHandle_t handle, int m, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda); 
# 1424
cublasStatus_t cublasZgeru_v2(cublasHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda); 
# 1435
cublasStatus_t cublasZgerc_v2(cublasHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda); 
# 1447
cublasStatus_t cublasSsyr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, float * A, int lda); 
# 1456
cublasStatus_t cublasDsyr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, double * A, int lda); 
# 1465
cublasStatus_t cublasCsyr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, cuComplex * A, int lda); 
# 1474
cublasStatus_t cublasZsyr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * A, int lda); 
# 1483
cublasStatus_t cublasCher_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const cuComplex * x, int incx, cuComplex * A, int lda); 
# 1492
cublasStatus_t cublasZher_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * A, int lda); 
# 1502
cublasStatus_t cublasSspr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, float * AP); 
# 1510
cublasStatus_t cublasDspr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, double * AP); 
# 1518
cublasStatus_t cublasChpr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const cuComplex * x, int incx, cuComplex * AP); 
# 1526
cublasStatus_t cublasZhpr_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const cuDoubleComplex * x, int incx, cuDoubleComplex * AP); 
# 1535
cublasStatus_t cublasSsyr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * A, int lda); 
# 1546
cublasStatus_t cublasDsyr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * A, int lda); 
# 1557
cublasStatus_t cublasCsyr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda); 
# 1568
cublasStatus_t cublasZsyr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda); 
# 1579
cublasStatus_t cublasCher2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * A, int lda); 
# 1590
cublasStatus_t cublasZher2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * A, int lda); 
# 1602
cublasStatus_t cublasSspr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * alpha, const float * x, int incx, const float * y, int incy, float * AP); 
# 1612
cublasStatus_t cublasDspr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * alpha, const double * x, int incx, const double * y, int incy, double * AP); 
# 1622
cublasStatus_t cublasChpr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * alpha, const cuComplex * x, int incx, const cuComplex * y, int incy, cuComplex * AP); 
# 1632
cublasStatus_t cublasZhpr2_v2(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * x, int incx, const cuDoubleComplex * y, int incy, cuDoubleComplex * AP); 
# 1642
cublasStatus_t cublasSgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const float *const  Aarray[], int lda, const float *const  xarray[], int incx, const float * beta, float *const  yarray[], int incy, int batchCount); 
# 1656
cublasStatus_t cublasDgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const double * alpha, const double *const  Aarray[], int lda, const double *const  xarray[], int incx, const double * beta, double *const  yarray[], int incy, int batchCount); 
# 1670
cublasStatus_t cublasCgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuComplex * alpha, const cuComplex *const  Aarray[], int lda, const cuComplex *const  xarray[], int incx, const cuComplex * beta, cuComplex *const  yarray[], int incy, int batchCount); 
# 1684
cublasStatus_t cublasZgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex *const  Aarray[], int lda, const cuDoubleComplex *const  xarray[], int incx, const cuDoubleComplex * beta, cuDoubleComplex *const  yarray[], int incy, int batchCount); 
# 1699
cublasStatus_t cublasHSHgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const __half *const  Aarray[], int lda, const __half *const  xarray[], int incx, const float * beta, __half *const  yarray[], int incy, int batchCount); 
# 1713
cublasStatus_t cublasHSSgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const __half *const  Aarray[], int lda, const __half *const  xarray[], int incx, const float * beta, float *const  yarray[], int incy, int batchCount); 
# 1727
cublasStatus_t cublasTSTgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const __nv_bfloat16 *const  Aarray[], int lda, const __nv_bfloat16 *const  xarray[], int incx, const float * beta, __nv_bfloat16 *const  yarray[], int incy, int batchCount); 
# 1741
cublasStatus_t cublasTSSgemvBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const __nv_bfloat16 *const  Aarray[], int lda, const __nv_bfloat16 *const  xarray[], int incx, const float * beta, float *const  yarray[], int incy, int batchCount); 
# 1756
cublasStatus_t cublasSgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const float * A, int lda, long long strideA, const float * x, int incx, long long stridex, const float * beta, float * y, int incy, long long stridey, int batchCount); 
# 1773
cublasStatus_t cublasDgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const double * alpha, const double * A, int lda, long long strideA, const double * x, int incx, long long stridex, const double * beta, double * y, int incy, long long stridey, int batchCount); 
# 1790
cublasStatus_t cublasCgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, long long strideA, const cuComplex * x, int incx, long long stridex, const cuComplex * beta, cuComplex * y, int incy, long long stridey, int batchCount); 
# 1808
cublasStatus_t cublasZgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, long long strideA, const cuDoubleComplex * x, int incx, long long stridex, const cuDoubleComplex * beta, cuDoubleComplex * y, int incy, long long stridey, int batchCount); 
# 1826
cublasStatus_t cublasHSHgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const __half * A, int lda, long long strideA, const __half * x, int incx, long long stridex, const float * beta, __half * y, int incy, long long stridey, int batchCount); 
# 1843
cublasStatus_t cublasHSSgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const __half * A, int lda, long long strideA, const __half * x, int incx, long long stridex, const float * beta, float * y, int incy, long long stridey, int batchCount); 
# 1860
cublasStatus_t cublasTSTgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const __nv_bfloat16 * A, int lda, long long strideA, const __nv_bfloat16 * x, int incx, long long stridex, const float * beta, __nv_bfloat16 * y, int incy, long long stridey, int batchCount); 
# 1877
cublasStatus_t cublasTSSgemvStridedBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, const float * alpha, const __nv_bfloat16 * A, int lda, long long strideA, const __nv_bfloat16 * x, int incx, long long stridex, const float * beta, float * y, int incy, long long stridey, int batchCount); 
# 1897
cublasStatus_t cublasSgemm_v2(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc); 
# 1912
cublasStatus_t cublasDgemm_v2(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc); 
# 1927
cublasStatus_t cublasCgemm_v2(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 1942
cublasStatus_t cublasCgemm3m(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 1956
cublasStatus_t cublasCgemm3mEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc); 
# 1974
cublasStatus_t cublasZgemm_v2(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 1989
cublasStatus_t cublasZgemm3m(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2005
cublasStatus_t cublasHgemm(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const __half * alpha, const __half * A, int lda, const __half * B, int ldb, const __half * beta, __half * C, int ldc); 
# 2021
cublasStatus_t cublasSgemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const float * beta, void * C, cudaDataType Ctype, int ldc); 
# 2039
cublasStatus_t cublasGemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const void * beta, void * C, cudaDataType Ctype, int ldc, cublasComputeType_t computeType, cublasGemmAlgo_t algo); 
# 2060
cublasStatus_t cublasCgemmEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const void * B, cudaDataType Btype, int ldb, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc); 
# 2078
cublasStatus_t cublasUint8gemmBias(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, cublasOperation_t transc, int m, int n, int k, const unsigned char * A, int A_bias, int lda, const unsigned char * B, int B_bias, int ldb, unsigned char * C, int C_bias, int ldc, int C_mult, int C_shift); 
# 2098
cublasStatus_t cublasSsyrk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * beta, float * C, int ldc); 
# 2110
cublasStatus_t cublasDsyrk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * beta, double * C, int ldc); 
# 2122
cublasStatus_t cublasCsyrk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * beta, cuComplex * C, int ldc); 
# 2134
cublasStatus_t cublasZsyrk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2146
cublasStatus_t cublasCsyrkEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc); 
# 2161
cublasStatus_t cublasCsyrk3mEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const void * A, cudaDataType Atype, int lda, const cuComplex * beta, void * C, cudaDataType Ctype, int ldc); 
# 2176
cublasStatus_t cublasCherk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const cuComplex * A, int lda, const float * beta, cuComplex * C, int ldc); 
# 2188
cublasStatus_t cublasZherk_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const cuDoubleComplex * A, int lda, const double * beta, cuDoubleComplex * C, int ldc); 
# 2201
cublasStatus_t cublasCherkEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const float * beta, void * C, cudaDataType Ctype, int ldc); 
# 2216
cublasStatus_t cublasCherk3mEx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const void * A, cudaDataType Atype, int lda, const float * beta, void * C, cudaDataType Ctype, int ldc); 
# 2231
cublasStatus_t cublasSsyr2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc); 
# 2245
cublasStatus_t cublasDsyr2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc); 
# 2259
cublasStatus_t cublasCsyr2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 2273
cublasStatus_t cublasZsyr2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2287
cublasStatus_t cublasCher2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const float * beta, cuComplex * C, int ldc); 
# 2301
cublasStatus_t cublasZher2k_v2(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const double * beta, cuDoubleComplex * C, int ldc); 
# 2315
cublasStatus_t cublasSsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc); 
# 2329
cublasStatus_t cublasDsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc); 
# 2343
cublasStatus_t cublasCsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 2357
cublasStatus_t cublasZsyrkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2371
cublasStatus_t cublasCherkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const float * beta, cuComplex * C, int ldc); 
# 2385
cublasStatus_t cublasZherkx(cublasHandle_t handle, cublasFillMode_t uplo, cublasOperation_t trans, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const double * beta, cuDoubleComplex * C, int ldc); 
# 2399
cublasStatus_t cublasSsymm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const float * alpha, const float * A, int lda, const float * B, int ldb, const float * beta, float * C, int ldc); 
# 2413
cublasStatus_t cublasDsymm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const double * alpha, const double * A, int lda, const double * B, int ldb, const double * beta, double * C, int ldc); 
# 2427
cublasStatus_t cublasCsymm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 2441
cublasStatus_t cublasZsymm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2456
cublasStatus_t cublasChemm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
# 2470
cublasStatus_t cublasZhemm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
# 2485
cublasStatus_t cublasStrsm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float * A, int lda, float * B, int ldb); 
# 2498
cublasStatus_t cublasDtrsm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double * A, int lda, double * B, int ldb); 
# 2511
cublasStatus_t cublasCtrsm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, cuComplex * B, int ldb); 
# 2524
cublasStatus_t cublasZtrsm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, cuDoubleComplex * B, int ldb); 
# 2538
cublasStatus_t cublasStrmm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float * A, int lda, const float * B, int ldb, float * C, int ldc); 
# 2553
cublasStatus_t cublasDtrmm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double * A, int lda, const double * B, int ldb, double * C, int ldc); 
# 2568
cublasStatus_t cublasCtrmm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * B, int ldb, cuComplex * C, int ldc); 
# 2583
cublasStatus_t cublasZtrmm_v2(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * B, int ldb, cuDoubleComplex * C, int ldc); 
# 2599
cublasStatus_t cublasHgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const __half * alpha, const __half *const  Aarray[], int lda, const __half *const  Barray[], int ldb, const __half * beta, __half *const  Carray[], int ldc, int batchCount); 
# 2615
cublasStatus_t cublasSgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float *const  Aarray[], int lda, const float *const  Barray[], int ldb, const float * beta, float *const  Carray[], int ldc, int batchCount); 
# 2631
cublasStatus_t cublasDgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double *const  Aarray[], int lda, const double *const  Barray[], int ldb, const double * beta, double *const  Carray[], int ldc, int batchCount); 
# 2647
cublasStatus_t cublasCgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex *const  Aarray[], int lda, const cuComplex *const  Barray[], int ldb, const cuComplex * beta, cuComplex *const  Carray[], int ldc, int batchCount); 
# 2663
cublasStatus_t cublasCgemm3mBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex *const  Aarray[], int lda, const cuComplex *const  Barray[], int ldb, const cuComplex * beta, cuComplex *const  Carray[], int ldc, int batchCount); 
# 2679
cublasStatus_t cublasZgemmBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex *const  Aarray[], int lda, const cuDoubleComplex *const  Barray[], int ldb, const cuDoubleComplex * beta, cuDoubleComplex *const  Carray[], int ldc, int batchCount); 
# 2695
cublasStatus_t cublasGemmBatchedEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void * alpha, const void *const  Aarray[], cudaDataType Atype, int lda, const void *const  Barray[], cudaDataType Btype, int ldb, const void * beta, void *const  Carray[], cudaDataType Ctype, int ldc, int batchCount, cublasComputeType_t computeType, cublasGemmAlgo_t algo); 
# 2716
cublasStatus_t cublasGemmStridedBatchedEx(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const void * alpha, const void * A, cudaDataType Atype, int lda, long long strideA, const void * B, cudaDataType Btype, int ldb, long long strideB, const void * beta, void * C, cudaDataType Ctype, int ldc, long long strideC, int batchCount, cublasComputeType_t computeType, cublasGemmAlgo_t algo); 
# 2740
cublasStatus_t cublasSgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const float * alpha, const float * A, int lda, long long strideA, const float * B, int ldb, long long strideB, const float * beta, float * C, int ldc, long long strideC, int batchCount); 
# 2759
cublasStatus_t cublasDgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double * alpha, const double * A, int lda, long long strideA, const double * B, int ldb, long long strideB, const double * beta, double * C, int ldc, long long strideC, int batchCount); 
# 2778
cublasStatus_t cublasCgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, long long strideA, const cuComplex * B, int ldb, long long strideB, const cuComplex * beta, cuComplex * C, int ldc, long long strideC, int batchCount); 
# 2797
cublasStatus_t cublasCgemm3mStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuComplex * alpha, const cuComplex * A, int lda, long long strideA, const cuComplex * B, int ldb, long long strideB, const cuComplex * beta, cuComplex * C, int ldc, long long strideC, int batchCount); 
# 2817
cublasStatus_t cublasZgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, long long strideA, const cuDoubleComplex * B, int ldb, long long strideB, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc, long long strideC, int batchCount); 
# 2837
cublasStatus_t cublasHgemmStridedBatched(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const __half * alpha, const __half * A, int lda, long long strideA, const __half * B, int ldb, long long strideB, const __half * beta, __half * C, int ldc, long long strideC, int batchCount); 
# 2858
cublasStatus_t cublasSgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const float * alpha, const float * A, int lda, const float * beta, const float * B, int ldb, float * C, int ldc); 
# 2872
cublasStatus_t cublasDgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const double * alpha, const double * A, int lda, const double * beta, const double * B, int ldb, double * C, int ldc); 
# 2886
cublasStatus_t cublasCgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * beta, const cuComplex * B, int ldb, cuComplex * C, int ldc); 
# 2900
cublasStatus_t cublasZgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * beta, const cuDoubleComplex * B, int ldb, cuDoubleComplex * C, int ldc); 
# 2915
cublasStatus_t cublasSgetrfBatched(cublasHandle_t handle, int n, float *const  A[], int lda, int * P, int * info, int batchSize); 
# 2923
cublasStatus_t cublasDgetrfBatched(cublasHandle_t handle, int n, double *const  A[], int lda, int * P, int * info, int batchSize); 
# 2931
cublasStatus_t cublasCgetrfBatched(cublasHandle_t handle, int n, cuComplex *const  A[], int lda, int * P, int * info, int batchSize); 
# 2939
cublasStatus_t cublasZgetrfBatched(cublasHandle_t handle, int n, cuDoubleComplex *const  A[], int lda, int * P, int * info, int batchSize); 
# 2948
cublasStatus_t cublasSgetriBatched(cublasHandle_t handle, int n, const float *const  A[], int lda, const int * P, float *const  C[], int ldc, int * info, int batchSize); 
# 2958
cublasStatus_t cublasDgetriBatched(cublasHandle_t handle, int n, const double *const  A[], int lda, const int * P, double *const  C[], int ldc, int * info, int batchSize); 
# 2968
cublasStatus_t cublasCgetriBatched(cublasHandle_t handle, int n, const cuComplex *const  A[], int lda, const int * P, cuComplex *const  C[], int ldc, int * info, int batchSize); 
# 2978
cublasStatus_t cublasZgetriBatched(cublasHandle_t handle, int n, const cuDoubleComplex *const  A[], int lda, const int * P, cuDoubleComplex *const  C[], int ldc, int * info, int batchSize); 
# 2990
cublasStatus_t cublasSgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const float *const  Aarray[], int lda, const int * devIpiv, float *const  Barray[], int ldb, int * info, int batchSize); 
# 3002
cublasStatus_t cublasDgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const double *const  Aarray[], int lda, const int * devIpiv, double *const  Barray[], int ldb, int * info, int batchSize); 
# 3014
cublasStatus_t cublasCgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const cuComplex *const  Aarray[], int lda, const int * devIpiv, cuComplex *const  Barray[], int ldb, int * info, int batchSize); 
# 3026
cublasStatus_t cublasZgetrsBatched(cublasHandle_t handle, cublasOperation_t trans, int n, int nrhs, const cuDoubleComplex *const  Aarray[], int lda, const int * devIpiv, cuDoubleComplex *const  Barray[], int ldb, int * info, int batchSize); 
# 3039
cublasStatus_t cublasStrsmBatched(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const float * alpha, const float *const  A[], int lda, float *const  B[], int ldb, int batchCount); 
# 3053
cublasStatus_t cublasDtrsmBatched(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const double * alpha, const double *const  A[], int lda, double *const  B[], int ldb, int batchCount); 
# 3067
cublasStatus_t cublasCtrsmBatched(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuComplex * alpha, const cuComplex *const  A[], int lda, cuComplex *const  B[], int ldb, int batchCount); 
# 3081
cublasStatus_t cublasZtrsmBatched(cublasHandle_t handle, cublasSideMode_t side, cublasFillMode_t uplo, cublasOperation_t trans, cublasDiagType_t diag, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex *const  A[], int lda, cuDoubleComplex *const  B[], int ldb, int batchCount); 
# 3096
cublasStatus_t cublasSmatinvBatched(cublasHandle_t handle, int n, const float *const  A[], int lda, float *const  Ainv[], int lda_inv, int * info, int batchSize); 
# 3105
cublasStatus_t cublasDmatinvBatched(cublasHandle_t handle, int n, const double *const  A[], int lda, double *const  Ainv[], int lda_inv, int * info, int batchSize); 
# 3114
cublasStatus_t cublasCmatinvBatched(cublasHandle_t handle, int n, const cuComplex *const  A[], int lda, cuComplex *const  Ainv[], int lda_inv, int * info, int batchSize); 
# 3123
cublasStatus_t cublasZmatinvBatched(cublasHandle_t handle, int n, const cuDoubleComplex *const  A[], int lda, cuDoubleComplex *const  Ainv[], int lda_inv, int * info, int batchSize); 
# 3133
cublasStatus_t cublasSgeqrfBatched(cublasHandle_t handle, int m, int n, float *const  Aarray[], int lda, float *const  TauArray[], int * info, int batchSize); 
# 3142
cublasStatus_t cublasDgeqrfBatched(cublasHandle_t handle, int m, int n, double *const  Aarray[], int lda, double *const  TauArray[], int * info, int batchSize); 
# 3151
cublasStatus_t cublasCgeqrfBatched(cublasHandle_t handle, int m, int n, cuComplex *const  Aarray[], int lda, cuComplex *const  TauArray[], int * info, int batchSize); 
# 3160
cublasStatus_t cublasZgeqrfBatched(cublasHandle_t handle, int m, int n, cuDoubleComplex *const  Aarray[], int lda, cuDoubleComplex *const  TauArray[], int * info, int batchSize); 
# 3169
cublasStatus_t cublasSgelsBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, float *const  Aarray[], int lda, float *const  Carray[], int ldc, int * info, int * devInfoArray, int batchSize); 
# 3182
cublasStatus_t cublasDgelsBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, double *const  Aarray[], int lda, double *const  Carray[], int ldc, int * info, int * devInfoArray, int batchSize); 
# 3195
cublasStatus_t cublasCgelsBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, cuComplex *const  Aarray[], int lda, cuComplex *const  Carray[], int ldc, int * info, int * devInfoArray, int batchSize); 
# 3208
cublasStatus_t cublasZgelsBatched(cublasHandle_t handle, cublasOperation_t trans, int m, int n, int nrhs, cuDoubleComplex *const  Aarray[], int lda, cuDoubleComplex *const  Carray[], int ldc, int * info, int * devInfoArray, int batchSize); 
# 3221
cublasStatus_t cublasSdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const float * A, int lda, const float * x, int incx, float * C, int ldc); 
# 3232
cublasStatus_t cublasDdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const double * A, int lda, const double * x, int incx, double * C, int ldc); 
# 3243
cublasStatus_t cublasCdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const cuComplex * A, int lda, const cuComplex * x, int incx, cuComplex * C, int ldc); 
# 3254
cublasStatus_t cublasZdgmm(cublasHandle_t handle, cublasSideMode_t mode, int m, int n, const cuDoubleComplex * A, int lda, const cuDoubleComplex * x, int incx, cuDoubleComplex * C, int ldc); 
# 3267
cublasStatus_t cublasStpttr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * AP, float * A, int lda); 
# 3270
cublasStatus_t cublasDtpttr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * AP, double * A, int lda); 
# 3273
cublasStatus_t cublasCtpttr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * AP, cuComplex * A, int lda); 
# 3275
cublasStatus_t cublasZtpttr(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * AP, cuDoubleComplex * A, int lda); 
# 3279
cublasStatus_t cublasStrttp(cublasHandle_t handle, cublasFillMode_t uplo, int n, const float * A, int lda, float * AP); 
# 3282
cublasStatus_t cublasDtrttp(cublasHandle_t handle, cublasFillMode_t uplo, int n, const double * A, int lda, double * AP); 
# 3285
cublasStatus_t cublasCtrttp(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuComplex * A, int lda, cuComplex * AP); 
# 3287
cublasStatus_t cublasZtrttp(cublasHandle_t handle, cublasFillMode_t uplo, int n, const cuDoubleComplex * A, int lda, cuDoubleComplex * AP); 
# 3291
}
# 3293
static inline cublasStatus_t cublasMigrateComputeType(cublasHandle_t handle, cudaDataType_t 
# 3294
dataType, cublasComputeType_t *
# 3295
computeType) { 
# 3296
cublasMath_t mathMode = CUBLAS_DEFAULT_MATH; 
# 3297
cublasStatus_t status = CUBLAS_STATUS_SUCCESS; 
# 3299
status = cublasGetMathMode(handle, &mathMode); 
# 3300
if (status != (CUBLAS_STATUS_SUCCESS)) { 
# 3301
return status; 
# 3302
}  
# 3304
bool isPedantic = (mathMode & 15) == (CUBLAS_PEDANTIC_MATH); 
# 3306
switch (dataType) { 
# 3307
case CUDA_R_32F:  
# 3308
case CUDA_C_32F:  
# 3309
(*computeType) = (isPedantic ? CUBLAS_COMPUTE_32F_PEDANTIC : CUBLAS_COMPUTE_32F); 
# 3310
return CUBLAS_STATUS_SUCCESS; 
# 3311
case CUDA_R_64F:  
# 3312
case CUDA_C_64F:  
# 3313
(*computeType) = (isPedantic ? CUBLAS_COMPUTE_64F_PEDANTIC : CUBLAS_COMPUTE_64F); 
# 3314
return CUBLAS_STATUS_SUCCESS; 
# 3315
case CUDA_R_16F:  
# 3316
(*computeType) = (isPedantic ? CUBLAS_COMPUTE_16F_PEDANTIC : CUBLAS_COMPUTE_16F); 
# 3317
return CUBLAS_STATUS_SUCCESS; 
# 3318
case CUDA_R_32I:  
# 3319
(*computeType) = (isPedantic ? CUBLAS_COMPUTE_32I_PEDANTIC : CUBLAS_COMPUTE_32I); 
# 3320
return CUBLAS_STATUS_SUCCESS; 
# 3321
default:  
# 3322
return CUBLAS_STATUS_NOT_SUPPORTED; 
# 3323
}  
# 3324
} 
# 3326
static inline cublasStatus_t cublasGemmEx(cublasHandle_t handle, cublasOperation_t 
# 3327
transa, cublasOperation_t 
# 3328
transb, int 
# 3329
m, int 
# 3330
n, int 
# 3331
k, const void *
# 3332
alpha, const void *
# 3333
A, cudaDataType 
# 3334
Atype, int 
# 3335
lda, const void *
# 3336
B, cudaDataType 
# 3337
Btype, int 
# 3338
ldb, const void *
# 3339
beta, void *
# 3340
C, cudaDataType 
# 3341
Ctype, int 
# 3342
ldc, cudaDataType 
# 3343
computeType, cublasGemmAlgo_t 
# 3344
algo) { 
# 3345
cublasComputeType_t migratedComputeType = CUBLAS_COMPUTE_32F; 
# 3346
cublasStatus_t status = CUBLAS_STATUS_SUCCESS; 
# 3347
status = cublasMigrateComputeType(handle, computeType, &migratedComputeType); 
# 3348
if (status != (CUBLAS_STATUS_SUCCESS)) { 
# 3349
return status; 
# 3350
}  
# 3352
return cublasGemmEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, B, Btype, ldb, beta, C, Ctype, ldc, migratedComputeType, algo); 
# 3371
} 
# 3373
static inline cublasStatus_t cublasGemmBatchedEx(cublasHandle_t handle, cublasOperation_t 
# 3374
transa, cublasOperation_t 
# 3375
transb, int 
# 3376
m, int 
# 3377
n, int 
# 3378
k, const void *
# 3379
alpha, const void *const 
# 3380
Aarray[], cudaDataType 
# 3381
Atype, int 
# 3382
lda, const void *const 
# 3383
Barray[], cudaDataType 
# 3384
Btype, int 
# 3385
ldb, const void *
# 3386
beta, void *const 
# 3387
Carray[], cudaDataType 
# 3388
Ctype, int 
# 3389
ldc, int 
# 3390
batchCount, cudaDataType 
# 3391
computeType, cublasGemmAlgo_t 
# 3392
algo) { 
# 3393
cublasComputeType_t migratedComputeType; 
# 3394
cublasStatus_t status; 
# 3395
status = cublasMigrateComputeType(handle, computeType, &migratedComputeType); 
# 3396
if (status != (CUBLAS_STATUS_SUCCESS)) { 
# 3397
return status; 
# 3398
}  
# 3400
return cublasGemmBatchedEx(handle, transa, transb, m, n, k, alpha, Aarray, Atype, lda, Barray, Btype, ldb, beta, Carray, Ctype, ldc, batchCount, migratedComputeType, algo); 
# 3420
} 
# 3422
static inline cublasStatus_t cublasGemmStridedBatchedEx(cublasHandle_t handle, cublasOperation_t 
# 3423
transa, cublasOperation_t 
# 3424
transb, int 
# 3425
m, int 
# 3426
n, int 
# 3427
k, const void *
# 3428
alpha, const void *
# 3429
A, cudaDataType 
# 3430
Atype, int 
# 3431
lda, long long 
# 3432
strideA, const void *
# 3433
B, cudaDataType 
# 3434
Btype, int 
# 3435
ldb, long long 
# 3436
strideB, const void *
# 3437
beta, void *
# 3438
C, cudaDataType 
# 3439
Ctype, int 
# 3440
ldc, long long 
# 3441
strideC, int 
# 3442
batchCount, cudaDataType 
# 3443
computeType, cublasGemmAlgo_t 
# 3444
algo) { 
# 3445
cublasComputeType_t migratedComputeType; 
# 3446
cublasStatus_t status; 
# 3447
status = cublasMigrateComputeType(handle, computeType, &migratedComputeType); 
# 3448
if (status != (CUBLAS_STATUS_SUCCESS)) { 
# 3449
return status; 
# 3450
}  
# 3452
return cublasGemmStridedBatchedEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, strideA, B, Btype, ldb, strideB, beta, C, Ctype, ldc, strideC, batchCount, migratedComputeType, algo); 
# 3475
} 
# 9 "/home/zhoub/CLionProjects/cudaTest/main.cu"
inline std::shared_ptr< void>  MyCudaMalloc(int size) 
# 10
{ 
# 11
void *tmp = (nullptr); 
# 12
if ((cudaError_t::cudaSuccess) != (cudaMalloc(&tmp, size))) { 
# 13
throw std::bad_alloc(); }  
# 14
return {tmp, [](void *p) { cudaFree(p); } }; 
# 15
} 
# 24 "/home/zhoub/CLionProjects/cudaTest/main.cu"
void MatrixMul_T_T(int cTileK, int m, int n, int k, float alpha, const float *A, int lda, const float *B, int ldb, float beta, float *C, int ldc) ;
#if 0
# 25
{ 
# 26
float4 f4_zero = make_float4((0.0F), (0.0F), (0.0F), (0.0F)); 
# 27
float4 result[4][4] = {{f4_zero}}; 
# 28
float4 reg_a[2]; 
# 29
float4 reg_b[2]; 
# 31
__attribute__((unused)) float4 smemA[2][16][32]; 
# 32
__attribute__((unused)) float4 smemB[2][16][32]; 
# 34
int tx_4, ty_4, tx_32, ty_32; 
# 35
{ 
# 36
int ltid = ((__device_builtin_variable_threadIdx.y) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
# 37
tx_4 = (ltid % 4); 
# 38
ty_4 = (ltid / 4); 
# 39
tx_32 = (ltid % 32); 
# 40
ty_32 = (ltid / 32); 
# 41
} 
# 43
int tileIdx = 0; 
# 44
float4 ldA[2], ldB[2]; 
# 45
{ 
# 46
const float *pTileA = (A + (((__device_builtin_variable_blockIdx.y) * (128)) * lda)) + (tileIdx * 16); 
# 47
const float *pTileB = (B + ((tileIdx * 16) * ldb)) + ((__device_builtin_variable_blockIdx.x) * (128)); 
# 48
(ldA[0]) = (*((float4 *)((pTileA + (ty_4 * lda)) + (tx_4 * 4)))); 
# 49
(ldA[1]) = (*((float4 *)((pTileA + ((ty_4 + 64) * lda)) + (tx_4 * 4)))); 
# 50
(ldB[0]) = (*((float4 *)((pTileB + (ty_32 * ldb)) + (tx_32 * 4)))); 
# 51
(ldB[1]) = (*((float4 *)((pTileB + ((ty_32 + 8) * ldb)) + (tx_32 * 4)))); 
# 53
(*((((float *)(&(((smemA[0])[0])[0]))) + ((tx_4 * 4) * 128)) + ty_4)) = ((ldA[0]).x); 
# 54
(*((((float *)(&(((smemA[0])[0])[0]))) + (((tx_4 * 4) + 1) * 128)) + ty_4)) = ((ldA[0]).y); 
# 55
(*((((float *)(&(((smemA[0])[0])[0]))) + (((tx_4 * 4) + 2) * 128)) + ty_4)) = ((ldA[0]).z); 
# 56
(*((((float *)(&(((smemA[0])[0])[0]))) + (((tx_4 * 4) + 3) * 128)) + ty_4)) = ((ldA[0]).w); 
# 58
(*(((((float *)(&(((smemA[0])[0])[0]))) + ((tx_4 * 4) * 128)) + ty_4) + 64)) = ((ldA[1]).x); 
# 59
(*(((((float *)(&(((smemA[0])[0])[0]))) + (((tx_4 * 4) + 1) * 128)) + ty_4) + 64)) = ((ldA[1]).y); 
# 60
(*(((((float *)(&(((smemA[0])[0])[0]))) + (((tx_4 * 4) + 2) * 128)) + ty_4) + 64)) = ((ldA[1]).z); 
# 61
(*(((((float *)(&(((smemA[0])[0])[0]))) + (((tx_4 * 4) + 3) * 128)) + ty_4) + 64)) = ((ldA[1]).w); 
# 63
(((smemB[0])[ty_32])[tx_32]) = (ldB[0]); 
# 64
(((smemB[0])[ty_32 + 8])[tx_32]) = (ldB[1]); 
# 65
} 
# 67
__syncthreads(); 
# 68
int write_stage_idx = 1; 
# 69
do 
# 70
{ 
# 71
int load_stage_idx = write_stage_idx ^ 1; 
# 72
++tileIdx; 
# 73
if (tileIdx < cTileK) 
# 74
{ 
# 75
const float *pTileA = (A + (((__device_builtin_variable_blockIdx.y) * (128)) * lda)) + (tileIdx * 16); 
# 76
const float *pTileB = (B + ((tileIdx * 16) * ldb)) + ((__device_builtin_variable_blockIdx.x) * (128)); 
# 77
(ldA[0]) = (*((float4 *)((pTileA + (ty_4 * lda)) + (tx_4 * 4)))); 
# 78
(ldA[1]) = (*((float4 *)((pTileA + ((ty_4 + 64) * lda)) + (tx_4 * 4)))); 
# 79
(ldB[0]) = (*((float4 *)((pTileB + (ty_32 * ldb)) + (tx_32 * 4)))); 
# 80
(ldB[1]) = (*((float4 *)((pTileB + ((ty_32 + 8) * ldb)) + (tx_32 * 4)))); 
# 81
}  
# 84
#pragma unroll
for (
# 84
int subTileIdx = 0; subTileIdx < 16; ++subTileIdx) 
# 85
{ 
# 86
(reg_a[0]) = (((smemA[load_stage_idx])[subTileIdx])[__device_builtin_variable_threadIdx.y]); 
# 87
(reg_a[1]) = (((smemA[load_stage_idx])[subTileIdx])[(__device_builtin_variable_threadIdx.y) + (16)]); 
# 89
(reg_b[0]) = (((smemB[load_stage_idx])[subTileIdx])[__device_builtin_variable_threadIdx.x]); 
# 90
(reg_b[1]) = (((smemB[load_stage_idx])[subTileIdx])[(__device_builtin_variable_threadIdx.x) + (16)]); 
# 92
(((result[0])[0]).x) += (((reg_a[0]).x) * ((reg_b[0]).x)); 
# 93
(((result[0])[0]).y) += (((reg_a[0]).x) * ((reg_b[0]).y)); 
# 94
(((result[0])[0]).z) += (((reg_a[0]).x) * ((reg_b[0]).z)); 
# 95
(((result[0])[0]).w) += (((reg_a[0]).x) * ((reg_b[0]).w)); 
# 96
(((result[0])[1]).x) += (((reg_a[0]).y) * ((reg_b[0]).x)); 
# 97
(((result[0])[1]).y) += (((reg_a[0]).y) * ((reg_b[0]).y)); 
# 98
(((result[0])[1]).z) += (((reg_a[0]).y) * ((reg_b[0]).z)); 
# 99
(((result[0])[1]).w) += (((reg_a[0]).y) * ((reg_b[0]).w)); 
# 100
(((result[0])[2]).x) += (((reg_a[0]).z) * ((reg_b[0]).x)); 
# 101
(((result[0])[2]).y) += (((reg_a[0]).z) * ((reg_b[0]).y)); 
# 102
(((result[0])[2]).z) += (((reg_a[0]).z) * ((reg_b[0]).z)); 
# 103
(((result[0])[2]).w) += (((reg_a[0]).z) * ((reg_b[0]).w)); 
# 104
(((result[0])[3]).x) += (((reg_a[0]).w) * ((reg_b[0]).x)); 
# 105
(((result[0])[3]).y) += (((reg_a[0]).w) * ((reg_b[0]).y)); 
# 106
(((result[0])[3]).z) += (((reg_a[0]).w) * ((reg_b[0]).z)); 
# 107
(((result[0])[3]).w) += (((reg_a[0]).w) * ((reg_b[0]).w)); 
# 111
(((result[1])[0]).x) += (((reg_a[0]).x) * ((reg_b[1]).x)); 
# 112
(((result[1])[0]).y) += (((reg_a[0]).x) * ((reg_b[1]).y)); 
# 113
(((result[1])[0]).z) += (((reg_a[0]).x) * ((reg_b[1]).z)); 
# 114
(((result[1])[0]).w) += (((reg_a[0]).x) * ((reg_b[1]).w)); 
# 115
(((result[1])[1]).x) += (((reg_a[0]).y) * ((reg_b[1]).x)); 
# 116
(((result[1])[1]).y) += (((reg_a[0]).y) * ((reg_b[1]).y)); 
# 117
(((result[1])[1]).z) += (((reg_a[0]).y) * ((reg_b[1]).z)); 
# 118
(((result[1])[1]).w) += (((reg_a[0]).y) * ((reg_b[1]).w)); 
# 119
(((result[1])[2]).x) += (((reg_a[0]).z) * ((reg_b[1]).x)); 
# 120
(((result[1])[2]).y) += (((reg_a[0]).z) * ((reg_b[1]).y)); 
# 121
(((result[1])[2]).z) += (((reg_a[0]).z) * ((reg_b[1]).z)); 
# 122
(((result[1])[2]).w) += (((reg_a[0]).z) * ((reg_b[1]).w)); 
# 123
(((result[1])[3]).x) += (((reg_a[0]).w) * ((reg_b[1]).x)); 
# 124
(((result[1])[3]).y) += (((reg_a[0]).w) * ((reg_b[1]).y)); 
# 125
(((result[1])[3]).z) += (((reg_a[0]).w) * ((reg_b[1]).z)); 
# 126
(((result[1])[3]).w) += (((reg_a[0]).w) * ((reg_b[1]).w)); 
# 130
(((result[2])[0]).x) += (((reg_a[1]).x) * ((reg_b[0]).x)); 
# 131
(((result[2])[0]).y) += (((reg_a[1]).x) * ((reg_b[0]).y)); 
# 132
(((result[2])[0]).z) += (((reg_a[1]).x) * ((reg_b[0]).z)); 
# 133
(((result[2])[0]).w) += (((reg_a[1]).x) * ((reg_b[0]).w)); 
# 134
(((result[2])[1]).x) += (((reg_a[1]).y) * ((reg_b[0]).x)); 
# 135
(((result[2])[1]).y) += (((reg_a[1]).y) * ((reg_b[0]).y)); 
# 136
(((result[2])[1]).z) += (((reg_a[1]).y) * ((reg_b[0]).z)); 
# 137
(((result[2])[1]).w) += (((reg_a[1]).y) * ((reg_b[0]).w)); 
# 138
(((result[2])[2]).x) += (((reg_a[1]).z) * ((reg_b[0]).x)); 
# 139
(((result[2])[2]).y) += (((reg_a[1]).z) * ((reg_b[0]).y)); 
# 140
(((result[2])[2]).z) += (((reg_a[1]).z) * ((reg_b[0]).z)); 
# 141
(((result[2])[2]).w) += (((reg_a[1]).z) * ((reg_b[0]).w)); 
# 142
(((result[2])[3]).x) += (((reg_a[1]).w) * ((reg_b[0]).x)); 
# 143
(((result[2])[3]).y) += (((reg_a[1]).w) * ((reg_b[0]).y)); 
# 144
(((result[2])[3]).z) += (((reg_a[1]).w) * ((reg_b[0]).z)); 
# 145
(((result[2])[3]).w) += (((reg_a[1]).w) * ((reg_b[0]).w)); 
# 149
(((result[3])[0]).x) += (((reg_a[1]).x) * ((reg_b[1]).x)); 
# 150
(((result[3])[0]).y) += (((reg_a[1]).x) * ((reg_b[1]).y)); 
# 151
(((result[3])[0]).z) += (((reg_a[1]).x) * ((reg_b[1]).z)); 
# 152
(((result[3])[0]).w) += (((reg_a[1]).x) * ((reg_b[1]).w)); 
# 153
(((result[3])[1]).x) += (((reg_a[1]).y) * ((reg_b[1]).x)); 
# 154
(((result[3])[1]).y) += (((reg_a[1]).y) * ((reg_b[1]).y)); 
# 155
(((result[3])[1]).z) += (((reg_a[1]).y) * ((reg_b[1]).z)); 
# 156
(((result[3])[1]).w) += (((reg_a[1]).y) * ((reg_b[1]).w)); 
# 157
(((result[3])[2]).x) += (((reg_a[1]).z) * ((reg_b[1]).x)); 
# 158
(((result[3])[2]).y) += (((reg_a[1]).z) * ((reg_b[1]).y)); 
# 159
(((result[3])[2]).z) += (((reg_a[1]).z) * ((reg_b[1]).z)); 
# 160
(((result[3])[2]).w) += (((reg_a[1]).z) * ((reg_b[1]).w)); 
# 161
(((result[3])[3]).x) += (((reg_a[1]).w) * ((reg_b[1]).x)); 
# 162
(((result[3])[3]).y) += (((reg_a[1]).w) * ((reg_b[1]).y)); 
# 163
(((result[3])[3]).z) += (((reg_a[1]).w) * ((reg_b[1]).z)); 
# 164
(((result[3])[3]).w) += (((reg_a[1]).w) * ((reg_b[1]).w)); 
# 165
}  
# 167
if (tileIdx < cTileK) 
# 168
{ 
# 169
(*((((float *)(&(((smemA[write_stage_idx])[0])[0]))) + ((tx_4 * 4) * 128)) + ty_4)) = ((ldA[0]).x); 
# 170
(*((((float *)(&(((smemA[write_stage_idx])[0])[0]))) + (((tx_4 * 4) + 1) * 128)) + ty_4)) = ((ldA[0]).y); 
# 171
(*((((float *)(&(((smemA[write_stage_idx])[0])[0]))) + (((tx_4 * 4) + 2) * 128)) + ty_4)) = ((ldA[0]).z); 
# 172
(*((((float *)(&(((smemA[write_stage_idx])[0])[0]))) + (((tx_4 * 4) + 3) * 128)) + ty_4)) = ((ldA[0]).w); 
# 174
(*(((((float *)(&(((smemA[write_stage_idx])[0])[0]))) + ((tx_4 * 4) * 128)) + ty_4) + 64)) = ((ldA[1]).x); 
# 175
(*(((((float *)(&(((smemA[write_stage_idx])[0])[0]))) + (((tx_4 * 4) + 1) * 128)) + ty_4) + 64)) = ((ldA[1]).y); 
# 176
(*(((((float *)(&(((smemA[write_stage_idx])[0])[0]))) + (((tx_4 * 4) + 2) * 128)) + ty_4) + 64)) = ((ldA[1]).z); 
# 177
(*(((((float *)(&(((smemA[write_stage_idx])[0])[0]))) + (((tx_4 * 4) + 3) * 128)) + ty_4) + 64)) = ((ldA[1]).w); 
# 179
(((smemB[write_stage_idx])[ty_32])[tx_32]) = (ldB[0]); 
# 180
(((smemB[write_stage_idx])[ty_32 + 8])[tx_32]) = (ldB[1]); 
# 181
write_stage_idx ^= 1; 
# 182
__syncthreads(); 
# 183
}  
# 185
} while (tileIdx < cTileK); 
# 188
#pragma unroll
for (
# 188
int i = 0; i < 4; ++i) 
# 189
{ 
# 191
#pragma unroll
for (
# 191
int j = 0; j < 4; ++j) 
# 192
{ 
# 193
(((result[i])[j]).x) *= alpha; 
# 194
(((result[i])[j]).y) *= alpha; 
# 195
(((result[i])[j]).z) *= alpha; 
# 196
(((result[i])[j]).w) *= alpha; 
# 197
}  
# 198
}  
# 199
float *startPointer[4] = {((C + ((((__device_builtin_variable_blockIdx.y) * (128)) + ((__device_builtin_variable_threadIdx.y) * (4))) * ldc)) + ((__device_builtin_variable_blockIdx.x) * (128))) + ((__device_builtin_variable_threadIdx.x) * (4)), (((C + ((((__device_builtin_variable_blockIdx.y) * (128)) + ((__device_builtin_variable_threadIdx.y) * (4))) * ldc)) + ((__device_builtin_variable_blockIdx.x) * (128))) + ((__device_builtin_variable_threadIdx.x) * (4))) + 64, ((C + (((((__device_builtin_variable_blockIdx.y) * (128)) + ((__device_builtin_variable_threadIdx.y) * (4))) + (64)) * ldc)) + ((__device_builtin_variable_blockIdx.x) * (128))) + ((__device_builtin_variable_threadIdx.x) * (4)), (((C + (((((__device_builtin_variable_blockIdx.y) * (128)) + ((__device_builtin_variable_threadIdx.y) * (4))) + (64)) * ldc)) + ((__device_builtin_variable_blockIdx.x) * (128))) + ((__device_builtin_variable_threadIdx.x) * (4))) + 64}; 
# 206
#pragma unroll
for (
# 206
int i = 0; i < 4; ++i) 
# 207
{ 
# 209
#pragma unroll
for (
# 209
int j = 0; j < 4; ++j) 
# 210
{ 
# 211
if (beta == (0)) { 
# 212
(*((float4 *)((startPointer[i]) + (j * ldc)))) = ((result[i])[j]); 
# 213
} else { 
# 214
float4 value = *((float4 *)((startPointer[i]) + (j * ldc))); 
# 215
(value.x) = ((beta * (value.x)) + (((result[i])[j]).x)); 
# 216
(value.y) = ((beta * (value.y)) + (((result[i])[j]).y)); 
# 217
(value.z) = ((beta * (value.z)) + (((result[i])[j]).z)); 
# 218
(value.w) = ((beta * (value.w)) + (((result[i])[j]).w)); 
# 219
(*((float4 *)((startPointer[i]) + (j * ldc)))) = value; 
# 220
}  
# 221
}  
# 222
}  
# 223
} 
#endif
# 225 "/home/zhoub/CLionProjects/cudaTest/main.cu"
void MySgemm(cublasOperation_t transa, cublasOperation_t 
# 226
transb, int 
# 227
m, int 
# 228
n, int 
# 229
k, float 
# 230
alpha, const float *
# 231
A, int 
# 232
lda, const float *
# 233
B, int 
# 234
ldb, float 
# 235
beta, float *
# 236
C, int 
# 237
ldc) 
# 238
{ 
# 240 "/home/zhoub/CLionProjects/cudaTest/main.cu" 3
(static_cast< bool>(transa == (CUBLAS_OP_T))) ? (void)0 : __assert_fail("transa == CUBLAS_OP_T", "/home/zhoub/CLionProjects/cudaTest/main.cu", 240, __extension__ __PRETTY_FUNCTION__); 
# 241 "/home/zhoub/CLionProjects/cudaTest/main.cu" 3
(static_cast< bool>(transb == (CUBLAS_OP_T))) ? (void)0 : __assert_fail("transb == CUBLAS_OP_T", "/home/zhoub/CLionProjects/cudaTest/main.cu", 241, __extension__ __PRETTY_FUNCTION__); 
# 242 "/home/zhoub/CLionProjects/cudaTest/main.cu" 3
(static_cast< bool>((m % 128) == 0)) ? (void)0 : __assert_fail("m % 128 == 0", "/home/zhoub/CLionProjects/cudaTest/main.cu", 242, __extension__ __PRETTY_FUNCTION__); 
# 243 "/home/zhoub/CLionProjects/cudaTest/main.cu" 3
(static_cast< bool>((n % 128) == 0)) ? (void)0 : __assert_fail("n % 128 == 0", "/home/zhoub/CLionProjects/cudaTest/main.cu", 243, __extension__ __PRETTY_FUNCTION__); 
# 244 "/home/zhoub/CLionProjects/cudaTest/main.cu" 3
(static_cast< bool>((k % 128) == 0)) ? (void)0 : __assert_fail("k % 128 == 0", "/home/zhoub/CLionProjects/cudaTest/main.cu", 244, __extension__ __PRETTY_FUNCTION__); 
# 246 "/home/zhoub/CLionProjects/cudaTest/main.cu"
dim3 dimBlock(16, 16); 
# 247
dim3 dimGrid(n / 128, m / 128); 
# 248
if ((n % 128) != 0) { (dimGrid.x) += (1); }  
# 249
if ((m % 128) != 0) { (dimGrid.y) += (1); }  
# 250
int cTileK = k / 16; 
# 251
if ((k % 16) != 0) { cTileK++; }  
# 252
(__cudaPushCallConfiguration(dimGrid, dimBlock)) ? (void)0 : MatrixMul_T_T(cTileK, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc); 
# 253
} 
# 255
int main() { 
# 256
const int m = 2048; 
# 257
const int k = 1024; 
# 258
const int n = 2048; 
# 259
const int iter_count = 500; 
# 260
cv::Mat matA(m, k, (5 & ((1 << 3) - 1)) + ((1 - 1) << 3)); 
# 261 "/home/zhoub/CLionProjects/cudaTest/main.cu"
cv::randn(matA, (0.5), 1); 
# 262
cv::Mat matB(k, n, (5 & ((1 << 3) - 1)) + ((1 - 1) << 3)); 
# 263 "/home/zhoub/CLionProjects/cudaTest/main.cu"
cv::randn(matB, (0.5), 1); 
# 264
auto cpuT1 = std::chrono::high_resolution_clock::now(); 
# 265
cv::Mat matC = ((matA * matB)); 
# 266
auto cpuT2 = std::chrono::high_resolution_clock::now(); 
# 267
(((std::cout << ((std::chrono::duration_cast< std::chrono::duration< signed long, std::ratio< 1L, 1000000L> > > ((cpuT2 - cpuT1)).count()) / (1000000.0)))) << (std::endl)); 
# 268
cv::Mat matD(n, m, (5 & ((1 << 3) - 1)) + ((1 - 1) << 3)); 
# 269 "/home/zhoub/CLionProjects/cudaTest/main.cu"
cv::Mat matE(m, n, (5 & ((1 << 3) - 1)) + ((1 - 1) << 3)); 
# 271 "/home/zhoub/CLionProjects/cudaTest/main.cu"
auto pMatA = MyCudaMalloc((m * k) * sizeof(float)); 
# 272
cudaMemcpy(pMatA.get(), (void *)(matA.data), ((matA.rows) * (matA.cols)) * sizeof(float), cudaMemcpyKind::cudaMemcpyHostToDevice); 
# 273
auto pMatB = MyCudaMalloc((k * n) * sizeof(float)); 
# 274
cudaMemcpy(pMatB.get(), (void *)(matB.data), ((matB.rows) * (matB.cols)) * sizeof(float), cudaMemcpyKind::cudaMemcpyHostToDevice); 
# 275
auto pMatC = MyCudaMalloc((m * n) * sizeof(float)); 
# 276
auto pMatD = MyCudaMalloc((m * n) * sizeof(float)); 
# 277
cublasHandle_t handle; 
# 278
cublasCreate_v2(&handle); 
# 280
float alpha = (1), beta = (0); 
# 281
double total = (0); 
# 282
for (int i = 0; i < iter_count; ++i) 
# 283
{ 
# 284
cudaEvent_t evtStart, evtFinish; 
# 285
cudaEventCreate(&evtStart); 
# 286
cudaEventCreate(&evtFinish); 
# 287
cudaMemset(pMatC.get(), 0, (m * n) * sizeof(float)); 
# 288
cudaEventRecord(evtStart, 0); 
# 289
cublasSgemm_v2(handle, CUBLAS_OP_T, CUBLAS_OP_T, m, n, k, &alpha, (float *)pMatA.get(), k, (float *)pMatB.get(), n, &beta, (float *)pMatC.get(), m); 
# 290
cudaEventRecord(evtFinish, 0); 
# 291
cudaEventSynchronize(evtFinish); 
# 292
float ms = (0); 
# 293
cudaEventElapsedTime(&ms, evtStart, evtFinish); 
# 294
total += ms; 
# 295
cudaEventDestroy(evtStart); 
# 296
cudaEventDestroy(evtFinish); 
# 297
}  
# 298
cudaMemcpy(matD.data, pMatC.get(), (m * n) * sizeof(float), cudaMemcpyDeviceToHost); 
# 299
(matD = (matD.t())); 
# 300
(((std::cout << ((total / (1000.0)) / iter_count))) << (std::endl)); 
# 302
total = (0); 
# 303
for (int i = 0; i < iter_count; ++i) 
# 304
{ 
# 305
cudaEvent_t evtStart, evtFinish; 
# 306
cudaEventCreate(&evtStart); 
# 307
cudaEventCreate(&evtFinish); 
# 308
cudaMemset(pMatD.get(), 0, (m * n) * sizeof(float)); 
# 309
cudaEventRecord(evtStart, 0); 
# 310
MySgemm(CUBLAS_OP_T, CUBLAS_OP_T, m, n, k, alpha, (float *)pMatA.get(), k, (float *)pMatB.get(), n, beta, (float *)pMatD.get(), n); 
# 311
cudaEventRecord(evtFinish, 0); 
# 312
cudaEventSynchronize(evtFinish); 
# 313
float ms = (0); 
# 314
cudaEventElapsedTime(&ms, evtStart, evtFinish); 
# 315
total += ms; 
# 316
cudaEventDestroy(evtStart); 
# 317
cudaEventDestroy(evtFinish); 
# 318
}  
# 319
(((std::cout << ((total / (1000.0)) / iter_count))) << (std::endl)); 
# 321
cudaMemcpy(matE.data, pMatD.get(), (m * n) * sizeof(float), cudaMemcpyDeviceToHost); 
# 323
for (int i = 0; i < m; ++i) 
# 324
{ 
# 325
(((((((((((std::cout << (matD.at< float> (0, i)))) << ("\t"))) << (matE.at< float> (0, i)))) << ("\t"))) << (matC.at< float> (0, i)))) << (std::endl)); 
# 326
}  
# 331
return 0; 
# 332
} 

# 1 "main.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__fe384d24_7_main_cu_aced82d4
#ifdef _NV_ANON_NAMESPACE
#endif
# 1 "main.cudafe1.stub.c"
#include "main.cudafe1.stub.c"
# 1 "main.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE

extern "C" {
extern __attribute__ ((section (".nvHRKI"))) __attribute__((weak)) const unsigned char hostRefKernelArrayInternalLinkage[] = {
0x0};
}

extern "C" {
extern __attribute__ ((section (".nvHRKE"))) __attribute__((weak)) const unsigned char hostRefKernelArrayExternalLinkage[] = {
/* _Z13MatrixMul_T_T* */
0x5f,0x5a,0x31,0x33,0x4d,0x61,0x74,0x72,0x69,0x78,0x4d,0x75,0x6c,0x5f,0x54,0x5f,0x54,0x2a,0x0,
};
}

extern "C" {
extern __attribute__ ((section (".nvHRCI"))) __attribute__((weak)) const unsigned char hostRefConstantArrayInternalLinkage[] = {
0x0};
}

extern "C" {
extern __attribute__ ((section (".nvHRCE"))) __attribute__((weak)) const unsigned char hostRefConstantArrayExternalLinkage[] = {
0x0};
}
